   fSuccess = FALSE;
                break;
            }
            puof = ccxpvInfo;
            ofi.Inherit = (puof->fInherit != FALSE);
            ofi.ProtectFromClose = (ohi.HandleAttributes & OBJ_PROTECT_CLOSE) ? TRUE : FALSE;
            ObSetHandleAttributes(h, &ofi, UserMode);
            if (pHead->Type == *ExDesktopObjectType) {
                SetHandleFlag(h, HF_DESKTOPHOOK,
                        puof->dwFlags & DF_ALLOWOTHERACCOUNTHOOK);
            }
            break;
        default:
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
            fSuccess = FALSE;
            break;
        }
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        fSuccess = FALSE;
    }

#ifdef LOGDESKTOPLOCKS
    if (OBJECT_TO_OBJECT_HEADER(pObject)->Type == *ExDesktopObjectType) {
        LogDesktop(pObject, LD_DEREF_FN_SETUSEROBJECTINFORMATION, FALSE, (ULONG_PTR)PtiCurrent());
    }
#endif

    ObDereferenceObject(pObject);

    return fSuccess;
}

/***************************************************************************\
* UserScreenAccessCheck
*
* Called from the engine to determine if the thread's desktop is
* active and the process has WINSTA_READSCREEN access.
*
* Note that we may or may not be in USER's critical section when this
* is called.  This is OK as long as we don't reference thing belonging
* to other threads.  If we did try to enter the critical section here,
* a deadlock may occur between the engine and user.
*
* History:
* 05-20-1993 JimA         Created.
* 11-22-1996 BradG        Brought back to life.
* 05-07-2001 JasonSch     CSRSS threads aren't always attached to a desktop,
*                         but they need to draw anyway (for console).
\***************************************************************************/

BOOL FASTCALL UserScreenAccessCheck(VOID)
{
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    UserAssert(ptiCurrent != NULL);

    return (ptiCurrent != NULL &&
            (ptiCurrent->rpdesk == grpdeskRitInput || (ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) != 0) &&
            (W32GetCurrentProcess()->W32PF_Flags & (W32PF_READSCREENACCESSGRANTED | W32PF_IOWINSTA)) == (W32PF_READSCREENACCESSGRANTED | W32PF_IOWINSTA)
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\sendmsg.c ===
/****************************** Module Header ******************************\
* Module Name: sendmsg.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains SendMessage, xxxSendNotifyMessage, ReplyMessage, InSendMessage,
* RegisterWindowMessage and a few closely related functions.
*
* History:
* 10-19-90 darrinm      Created.
* 02-04-91 IanJa        Window handle revalidation added
\***************************************************************************/

#include "precomp.h"

#include <dbt.h>

#pragma hdrstop

#define IsASwitchWnd( pw )  \
        (gpsi->atomSysClass[ICLS_SWITCH] == pw->pcls->atomClassName)

#define IsOleMainThreadWnd( pw )  \
        (gaOleMainThreadWndClass == pw->pcls->atomClassName)

VOID UnlinkSendListSms(PSMS, PSMS *);
VOID ReceiverDied(PSMS, PSMS *);
VOID SenderDied(PSMS, PSMS *);
NTSTATUS InitSMSLookaside(VOID);

#pragma alloc_text(INIT, InitSMSLookaside)

/*
 * Globals local to this file only
 */
PPAGED_LOOKASIDE_LIST SMSLookaside;

/***************************************************************************\
* BroadcastProc
*
* Some windows need to be insulated from Broadcast messages.
* These include icon title windows, the switch window, all
* menu windows, etc.  Before stuffing the message in the task's
* queue, check to see if it is one we want to trash.
*
* Notes:  this procedure does not do exactly the same thing it does in
* windows 3.1.  There it actually posts/Sends the message.  For NT, it
* just returns TRUE if we SHOULD post the message, or FALSE other wise
*
* History:
* 25-Jun-1992 JonPa      Ported from Windows 3.1 sources
\***************************************************************************/
#define fBroadcastProc(pwnd)  \
    (!(ISAMENU(pwnd) || IsASwitchWnd(pwnd) || IsOleMainThreadWnd(pwnd)))



/***************************************************************************\
* StubAllocSMS / StubFreeSMS
*
* These are stub routines for SMS allocations. We need these to call
* our debug UserAlloc routines
*
* Dec-16-97  clupu   Created.
\***************************************************************************/
PVOID StubAllocSMS(
    POOL_TYPE PoolType,
    SIZE_T uBytes,
    ULONG iTag)
{
    return UserAllocPool(uBytes, iTag);

    UNREFERENCED_PARAMETER(PoolType);
}

VOID StubFreeSMS(
    PVOID p)
{
    UserFreePool(p);
}

/***************************************************************************\
* InitSMSLookaside
*
* Initializes the SMS entry lookaside list. This improves SMS entry locality
* by keeping SMS entries in a single page
*
* 09-09-93  Markl   Created.
\***************************************************************************/

NTSTATUS
InitSMSLookaside()
{
    SMSLookaside = Win32AllocPoolNonPagedNS(sizeof(PAGED_LOOKASIDE_LIST),
                                            TAG_LOOKASIDE);
    if (SMSLookaside == NULL) {
        return STATUS_NO_MEMORY;
    }

    ExInitializePagedLookasideList(SMSLookaside,
                                   StubAllocSMS,
                                   StubFreeSMS,
                                   POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                   sizeof(SMS),
                                   TAG_SMS,
                                   8);

    return STATUS_SUCCESS;
}

/***************************************************************************\
* AllocSMS
*
* Allocates a message on a message list. DelSMS deletes a message
* on a message list.
*
* 10-22-92 ScottLu      Created.
\***************************************************************************/

PSMS AllocSMS(
    VOID)
{
    return ExAllocateFromPagedLookasideList(SMSLookaside);
}

/***************************************************************************\
* FreeSMS
*
* Returns a qmsg to the lookaside buffer or free the memory.
*
* 10-26-93 JimA         Created.
\***************************************************************************/

void FreeSMS(
    PSMS psms)
{
    ExFreeToPagedLookasideList(SMSLookaside, psms);
}

/***************************************************************************\
* _ReplyMessage (API)
*
* This function replies to a message sent from one thread to another, using
* the provided lRet value.
*
* The return value is TRUE if the calling thread is processing a SendMessage()
* and FALSE otherwise.
*
* History:
* 01-13-91 DavidPe      Ported.
* 01-24-91 DavidPe      Rewrote for Windows.
\***************************************************************************/

BOOL _ReplyMessage(
    LRESULT lRet)
{
    PTHREADINFO ptiCurrent;
    PSMS psms;

    CheckCritIn();

    ptiCurrent = PtiCurrent();

    /*
     * Are we processing a SendMessage?
     */
    psms = ptiCurrent->psmsCurrent;
    if (psms == NULL)
        return FALSE;

    /*
     * See if the reply has been made already.
     */
    if (psms->flags & SMF_REPLY)
        return FALSE;

    /*
     * Blow off the rest of the call if the SMS came
     * from xxxSendNotifyMessage().  Obviously there's
     * no one around to reply to in the case.
     */
    if (psms->ptiSender != NULL) {

        /*
         * Reply to this message.  The sender should not free the SMS
         * because the receiver still considers it valid.  Thus we
         * mark it with a special bit indicating it has been replied
         * to.  We wait until both the sender and receiver are done
         * with the sms before we free it.
         */
        psms->lRet = lRet;
        psms->flags |= SMF_REPLY;

        /*
         * Wake up the sender.
         * ??? why don't we test that psms == ptiSender->psmsSent?
         */
        SetWakeBit(psms->ptiSender, QS_SMSREPLY);
    } else if (psms->flags & SMF_CB_REQUEST) {

        /*
         * From SendMessageCallback REQUEST callback.  Send the message
         * back with a the REPLY value.
         */
        TL tlpwnd;
        INTRSENDMSGEX ism;

        psms->flags |= SMF_REPLY;

        if (!(psms->flags & SMF_SENDERDIED)) {
            ism.fuCall = ISM_CALLBACK | ISM_REPLY;
            if (psms->flags & SMF_CB_CLIENT)
                ism.fuCall |= ISM_CB_CLIENT;
            ism.lpResultCallBack = psms->lpResultCallBack;
            ism.dwData = psms->dwData;
            ism.lRet = lRet;

            ThreadLockWithPti(ptiCurrent, psms->spwnd, &tlpwnd);

            xxxInterSendMsgEx(psms->spwnd, psms->message, 0L, 0L,
                    NULL, psms->ptiCallBackSender, &ism );

            ThreadUnlock(&tlpwnd);
        }
    }

    /*
     * We have 4 conditions to satisfy:
     *
     * 16 - 16 : receiver yields if sender is waiting for this reply
     * 32 - 16 : receiver yields if sender is waiting for this reply
     * 16 - 32 : no yield required
     * 32 - 32 : No yielding required.
     */
    if (psms->ptiSender &&
        (psms->ptiSender->TIF_flags & TIF_16BIT || ptiCurrent->TIF_flags & TIF_16BIT)) {

        DirectedScheduleTask(ptiCurrent, psms->ptiSender, FALSE, psms);
        if (ptiCurrent->TIF_flags & TIF_16BIT && psms->ptiSender->psmsSent == psms) {
            xxxSleepTask(TRUE, NULL);
        }
    }

    return TRUE;
}

VOID
UserLogError(
    PCWSTR pwszError,
    ULONG cbError,
    NTSTATUS ErrorCode)
{
    PIO_ERROR_LOG_PACKET perrLogEntry;

    /*
     * Allocate an error packet, fill it out, and write it to the log.
     */
    perrLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(gpWin32kDriverObject,
                                (UCHAR)(cbError + sizeof(IO_ERROR_LOG_PACKET)));
    if (perrLogEntry) {
        perrLogEntry->ErrorCode = ErrorCode;
        if (cbError) {
            perrLogEntry->NumberOfStrings = 1;
            perrLogEntry->StringOffset = FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData);
            RtlCopyMemory(perrLogEntry->DumpData, pwszError, cbError);
        }
        IoWriteErrorLogEntry(perrLogEntry);
    }
}

NTSTATUS
GetWindowLuid(
    PWND pwnd,
    PLUID pluidWnd
    )
{
    PACCESS_TOKEN pUserToken = NULL;
    BOOLEAN fCopyOnOpen;
    BOOLEAN fEffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    NTSTATUS Status;
    PTHREADINFO pti = GETPTI(pwnd);

    //
    // Get the window's thread token
    //
    pUserToken = PsReferenceImpersonationToken(pti->pEThread,
            &fCopyOnOpen, &fEffectiveOnly, &ImpersonationLevel);

    if (pUserToken == NULL) {

        //
        // No thread token, go to the process
        //

        pUserToken = PsReferencePrimaryToken(pti->ppi->Process);
        if (pUserToken == NULL)
            return STATUS_NO_TOKEN;
    }

    Status = SeQueryAuthenticationIdToken(pUserToken, pluidWnd);

    //
    // We're finished with the token
    //

    ObDereferenceObject(pUserToken);

    return Status;
}

BOOL xxxSendBSMtoDesktop(
    PWND pwndDesk,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPBROADCASTSYSTEMMSGPARAMS pbsmParams)
{
    PBWL pbwl;
    HWND *phwnd;
    PWND pwnd;
    TL tlpwnd;
    BOOL fReturnValue = TRUE;
    BOOL fFilterDriveMsg = FALSE;
    PTHREADINFO ptiCurrent = PtiCurrent();
    BOOL fPrivateMessage = (message >= WM_USER) && (message < MAXINTATOM);
    DEV_BROADCAST_VOLUME dbv;


    if (fPrivateMessage) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Attempt to broadcast a private message");
    }

    pbwl = BuildHwndList(pwndDesk->spwndChild, BWL_ENUMLIST, NULL);

    if (pbwl == NULL)
        return 0;

    if (!(pbsmParams->dwFlags & BSF_POSTMESSAGE)) {
        /*
         * Does the caller want to allow the receivers to take the foreground
         *  while processing the notification?
         */
        /*
         * Bug 412159. In order to allow the AppsHelp window to come to the
         * foreground we set ptiLastWoken to NULL, which will allow any window
         * to come to the foreground after a CD's been inserted.
         */
        if ((pbsmParams->dwFlags & BSF_ALLOWSFW) &&
           (GETPDESK(pwndDesk) == grpdeskRitInput) &&
           ((ptiCurrent->TIF_flags & TIF_CSRSSTHREAD)
            || CanForceForeground(ptiCurrent->ppi FG_HOOKLOCK_PARAM(ptiCurrent)))) {
             glinp.ptiLastWoken = NULL;
         }

    }

    /*
     * Determine if we need to filter the Drive Letter mask in fnINDEVICECHANGE
     * WM_DEVICECHANGE message are sent synchronously
     * LUID DosDevices maps must be enabled
     */
    if ((gLUIDDeviceMapsEnabled == TRUE) &&
        (message == WM_DEVICECHANGE) &&
        ((wParam == DBT_DEVICEREMOVECOMPLETE) || (wParam == DBT_DEVICEARRIVAL)) &&
        (((struct _DEV_BROADCAST_HEADER *)lParam)->dbcd_devicetype == DBT_DEVTYP_VOLUME)
        ) {
        LUID luidClient;
        NTSTATUS Status;

        if( ((DEV_BROADCAST_VOLUME *)lParam)->dbcv_unitmask & DBV_FILTER_MSG ) {
            return 0;
        }
        else {
            dbv = *((DEV_BROADCAST_VOLUME *)lParam);
            dbv.dbcv_unitmask |= DBV_FILTER_MSG;
        }

        /*
         * Caller must be LocalSystem and BSF_LUID is not specified
         */
        if (!(pbsmParams->dwFlags & BSF_LUID)) {
            Status = GetProcessLuid(NULL, &luidClient);
            if (NT_SUCCESS(Status) &&
                    RtlEqualLuid(&luidClient, &luidSystem)) {
                fFilterDriveMsg = TRUE;
            }
        }
    }

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        BOOL UseFilterLparam = FALSE;

        /*
         * Make sure this hwnd is still around.
         */
        if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        if (pbsmParams->dwFlags &  BSF_IGNORECURRENTTASK) {
        // Don't deal with windows in the current task.
            if (GETPTI(pwnd)->pq == ptiCurrent->pq)
                continue;
        }

        if (pbsmParams->dwFlags &  BSF_LUID) {
            LUID luidWnd;

            luidWnd.LowPart = luidWnd.HighPart = 0;
            /*
             * Now we have the window Luid LuidWindow
             * Check to see if it is equal to the callers Luid or not
             */
            if (!NT_SUCCESS(GetWindowLuid(pwnd, &luidWnd)) ||
                    !RtlEqualLuid(&pbsmParams->luid, &luidWnd)) {
                continue;
            }
        }

        if (fFilterDriveMsg == TRUE) {
            LUID luidWnd;

            if (!NT_SUCCESS(GetWindowLuid(pwnd, &luidWnd))) {
                continue;
            }

            /*
             * Since LocalSystem uses the Global DosDevices,
             * don't filter for windows owned by LocalSystem
             */
            if(!RtlEqualLuid(&luidSystem, &luidWnd)) {
                UseFilterLparam = TRUE;
            }
        }

        /*
         * Make sure this window can handle broadcast messages
         */

        if (!fBroadcastProc(pwnd)) {
            continue;
        }

        if (fPrivateMessage && TestWF(pwnd, WFWIN40COMPAT)) { // Don't broadcast
            continue;                                         // private message
        }                                                     // to 4.0 apps.

        ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);

        // Now, send message; This could be a query; so, remember the return value.
        if (pbsmParams->dwFlags & BSF_POSTMESSAGE) {
            _PostMessage(pwnd, message, wParam, lParam);
        } else if (pbsmParams->dwFlags & BSF_SENDNOTIFYMESSAGE) {
            /*
             * We don't want to wait for an answer, but we don't want to use
             * PostMessage either. This is useful if you need to maintain the
             * order in which messages are delivered, but you only want to
             * wait for some of them. See WM_POWERBROADCAST for an example.
             */
            xxxSendNotifyMessage(pwnd, message, wParam, lParam);
        } else if (pbsmParams->dwFlags & BSF_QUEUENOTIFYMESSAGE) {
            /*
             * We don't want to wait for an answer, but we don't want to use
             * PostMessage either. This is useful if you need to maintain the
             * order in which messages are delivered, but you only want to
             * wait for some of them. See WM_POWERBROADCAST for an example.
             */
            QueueNotifyMessage(pwnd, message, wParam, lParam);
        } else {
            /*
             * pbsmParams->dwFlags can be changed while we loop here
             *  so we need to check it in every iteration.
             */
            BOOL fNoHang = (BOOL)pbsmParams->dwFlags & BSF_NOHANG;
            BOOL fForce = (BOOL)pbsmParams->dwFlags & BSF_FORCEIFHUNG;
            DWORD dwTimeout;
            ULONG_PTR dwResult = 0;

            if (fNoHang)
                dwTimeout = CMSWAITTOKILLTIMEOUT;
            else
                dwTimeout = 0;

            if (xxxSendMessageTimeout(pwnd, message, wParam,
                (UseFilterLparam ? (LPARAM)&dbv : lParam),
                (fNoHang ? SMTO_ABORTIFHUNG : SMTO_NORMAL) |
                ((pbsmParams->dwFlags & BSF_NOTIMEOUTIFNOTHUNG) ? SMTO_NOTIMEOUTIFNOTHUNG : 0),
                dwTimeout, &dwResult)) {

                if (pbsmParams->dwFlags & BSF_QUERY) {
                    // For old messages, returning 0 means a deny
                    if(message == WM_QUERYENDSESSION)
                        fReturnValue = (dwResult != 0);
                    else
                    // For all new messages, returning BROADCAST_QUERY_DENY is
                    // the way to deny a query.
                        fReturnValue = (dwResult != BROADCAST_QUERY_DENY);
                }
            } else {
                fReturnValue = fForce;
            }

            /*
             * If our query was denied, return immediately.
             */
            if (fReturnValue == 0) {
                // Store who denied the query.
                pbsmParams->hwnd = HWq(pwnd);
                if (pbsmParams->dwFlags & BSF_RETURNHDESK) {
                    NTSTATUS Status;
                    HDESK hdesk = NULL;
                    if (pwnd->head.rpdesk) {
                        Status = ObOpenObjectByPointer(pwnd->head.rpdesk,
                                                       0,
                                                       NULL,
                                                       EVENT_ALL_ACCESS,
                                                       NULL,
                                                       UserMode,
                                                       &hdesk);
                        if (!NT_SUCCESS(Status)) {
                            RIPMSG2(RIP_WARNING, "Could not get a handle for pdesk %#p Status %x",
                                    pwnd->head.rpdesk, Status);
                        }
                    }
                    pbsmParams->hdesk = hdesk;
                }

                if (message == WM_POWERBROADCAST && wParam == PBT_APMQUERYSUSPEND) {
                    WCHAR wchTask[40];
                    ULONG cbTask;

                    /*
                     * Get the application name and log an error.
                     */
                    cbTask = GetTaskName(GETPTI(pwnd), wchTask, sizeof(wchTask));
                    UserLogError(wchTask, cbTask, WARNING_POWER_QUERYSUSPEND_CANCELLED);
                }
                ThreadUnlock(&tlpwnd);
                break;
            }
        }
        ThreadUnlock(&tlpwnd);
    }

    FreeHwndList(pbwl);

    return fReturnValue;
}

LONG xxxSendMessageBSM(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPBROADCASTSYSTEMMSGPARAMS pbsmParams)

{
    PTHREADINFO ptiCurrent = PtiCurrent();
    LONG        lRet;

    if (pbsmParams->dwRecipients & BSM_ALLDESKTOPS) {
        PWINDOWSTATION  pwinsta;
        PDESKTOP        pdesk;
        TL              tlpwinsta;
        TL              tlpdesk;

        /*
         * Walk through all windowstations and desktop looking for
         * top-level windows.
         */
        ThreadLockWinSta(ptiCurrent, NULL, &tlpwinsta);
        ThreadLockDesktop(ptiCurrent, NULL, &tlpdesk, LDLT_FN_SENDMESSAGEBSM);
        for (pwinsta = grpWinStaList; pwinsta != NULL; ) {
            ThreadLockExchangeWinSta(ptiCurrent, pwinsta, &tlpwinsta);
            for (pdesk = pwinsta->rpdeskList; pdesk != NULL; ) {
                ThreadLockExchangeDesktop(ptiCurrent, pdesk, &tlpdesk, LDLT_FN_SENDMESSAGEBSM);

                lRet = xxxSendBSMtoDesktop(pdesk->pDeskInfo->spwnd,
                              message, wParam, lParam, pbsmParams);

                /*
                 * If our query was denied, return immediately.
                 */
                if ((lRet == 0) && (pbsmParams->dwFlags & BSF_QUERY)) {
                    ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_SENDMESSAGEBSM1);
                    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);
                    return 0;
                }
                pdesk = pdesk->rpdeskNext;
            }
            pwinsta = pwinsta->rpwinstaNext;
        }
        ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_SENDMESSAGEBSM2);
        ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    } else {
        lRet = xxxSendBSMtoDesktop(pwnd, message, wParam, lParam,
                    pbsmParams);
    }

    return lRet;
}


/***************************************************************************\
* xxxSendMessageFF
*
* We can't check for -1 in the thunks because that would allow all message
* thunk apis to take -1 erroneously. Since all message apis need to go through
* the message thunks, the message thunks can only do least-common-denominator
* hwnd validation (can't allow -1). So I made a special thunk that gets called
* when SendMessage(-1) gets called. This means the client side will do the
* special stuff to make sure the pwnd passed goes through thunk validation
* ok. I do it this way rather than doing validation in all message apis and
* not in the thunks (if I did it this way the code would be larger and
* inefficient in the common cases).
*
* 03-20-92 ScottLu      Created.
\***************************************************************************/

LRESULT xxxSendMessageFF(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    UNREFERENCED_PARAMETER(pwnd);

    /*
     * Call xxxSendMessage() to do broadcasting rather than calling
     * broadcast from here in case any internal code that calls
     * sendmessage passes a -1 (that way the internal code doesn't
     * need to know about this weird routine).
     */
    if (xParam != 0L) {
        /*
         * SendMessageTimeout call
         */
        return xxxSendMessageEx(PWND_BROADCAST, message, wParam, lParam, xParam);
    } else {
        /*
         * Normal SendMessage call
         */
        return xxxSendMessageTimeout(PWND_BROADCAST, message, wParam,
                lParam, SMTO_NORMAL, 0, NULL );
    }
}

/***************************************************************************\
* xxxSendMessageEx
*
* The SendMessageTimeOut sends a pointer to struct that holds the extra
* params needed for the timeout call.  Instead of chaning a bunch of things,
* we use the xParam to hold a ptr to a struct.  So we change the client/srv
* entry point to hear so we can check for the extra param and extract the
* stuff we need if it's there.
*
*
* WARNING!!!! RETURN VALUE SWAPPED
*
* Only call this function from the thunks!
*
* our thunks are written for SendMessage where it returns the value of
* the message.  This routine is used to dispatch SendMessageTimeout calls.
* SendMessageTimeout returns only TRUE or FALSE and returns the retval of
* the function in lpdwResult.  So here the meanings are swapped and fixed
* up again in Client side SendMessageTimeout
*
*
* 08-10-92 ChrisBl      Created.
\***************************************************************************/

LRESULT xxxSendMessageEx(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    /*
     * extract values from the xParam if from TimeOut call
     * This should be the only way this function is ever
     * called, but check it just in case...
     */
    if (xParam != 0L) {
        LRESULT lRet;
        LRESULT lResult;
        NTSTATUS Status;
        SNDMSGTIMEOUT smto;
        PETHREAD Thread = PsGetCurrentThread();

        if (Thread == NULL)
            return FALSE;

        /*
         * Probe all read arguments
         */
        try {
            ProbeForWrite((PVOID)xParam, sizeof(smto), sizeof(ULONG));
            smto = *(SNDMSGTIMEOUT *)xParam;
            Status = STATUS_SUCCESS;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            Status = GetExceptionCode();
        }
        if ( !NT_SUCCESS(Status) ) {
            return FALSE;
        }

        lRet = xxxSendMessageTimeout(pwnd, message, wParam, lParam,
                smto.fuFlags, smto.uTimeout, &lResult);

        /*
         * put the result back into the client
         */
        smto.lSMTOResult = lResult;
        smto.lSMTOReturn = lRet;

        try {
            *(SNDMSGTIMEOUT *)xParam = smto;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            lResult = FALSE;
        }

        /*
         * Return the lResult so our thunks are happy.
         */
        return lResult;
    }

    return xxxSendMessageTimeout(pwnd, message, wParam,
            lParam, SMTO_NORMAL, 0, NULL);
}


/***********************************************************************\
* xxxSendMessage (API)
*
* This function synchronously sends a message to a window. The four
* parameters hwnd, message, wParam, and lParam are passed to the window
* procedure of the receiving window.  If the window receiving the message
* belongs to the same queue as the current thread, the window proc is called
* directly.  Otherwise, we set up an sms structure, wake the appropriate
* thread to receive the message and wait for a reply.
*
* Returns:
*   the value returned by the window procedure, or NULL if there is an error
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/
LRESULT xxxSendMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return xxxSendMessageTimeout(pwnd, message, wParam, lParam,
            SMTO_NORMAL, 0, NULL);
}

/***********************************************************************\
* xxxSendMessageToClient
*
* History:
* 04-22-98 GerardoB   Extracted from xxxSendMessageTimeout, xxxSendMesageCallback
*                      and xxxReceiveMessage
* 05-12-00 JStall     Changed from macro to inline function.
\***********************************************************************/
__inline void
xxxSendMessageToClient(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PSMS psms,
    BOOL fLock,
    LRESULT * plRet)
{
    DWORD dwSCMSFlags;
    WORD fnid;

    /*
     * If the window has a client side worker proc and has
     * not been subclassed, dispatch the message directly
     * to the worker proc.  Otherwise, dispatch it normally.
     */
    dwSCMSFlags = TestWF((pwnd), WFANSIPROC) ? SCMS_FLAGS_ANSI : 0;

    if (gihmodUserApiHook >= 0) {
        /*
         * UserApiHooks are installed, so we can't optimize the sending because
         * the OverrideWndProc's needs to get the message.
         */
        goto StandardSend;
    }

    fnid = GETFNID((pwnd));
    if ((fnid >= FNID_CONTROLSTART && fnid <= FNID_CONTROLEND) &&
        ((ULONG_PTR)(pwnd)->lpfnWndProc == FNID_TO_CLIENT_PFNW(fnid) ||
         (ULONG_PTR)(pwnd)->lpfnWndProc == FNID_TO_CLIENT_PFNA(fnid))) {
        PWNDMSG pwm = &gSharedInfo.awmControl[fnid - FNID_START] ;
        /*
         * If this message is not processed by the control, call
         * xxxDefWindowProc
         */
        if (pwm->abMsgs && (((message) > pwm->maxMsgs) ||
                !((pwm->abMsgs)[(message) / 8] & (1 << ((message) & 7))))) {
            /*
             * If this is a dialog window, we need to call the client because
             *  the app might want this message (eventhough DefDlgProc doesn't
             *  want it).
             * If the dialog hasn't been marked as such, the app's DlgProc is
             *  not yet available so it's OK to ignore the message.
             */
            if (TestWF((pwnd), WFDIALOGWINDOW)) {
                *plRet = ScSendMessageSMS((pwnd), (message), (wParam), (lParam),
                        dwSCMSFlags, (PROC)(FNID_TO_CLIENT_PFNWORKER(fnid)),
                        dwSCMSFlags, (psms));
            } else {
                TL tlpwnd;
                if (fLock) {
                    ThreadLock((pwnd), &tlpwnd);
                }
                *plRet = xxxDefWindowProc((pwnd), (message), (wParam), (lParam));
                if (fLock) {
                    ThreadUnlock(&tlpwnd);
                }
            }
        } else {
            *plRet = ScSendMessageSMS((pwnd), (message), (wParam), (lParam),
                    dwSCMSFlags, (PROC)(FNID_TO_CLIENT_PFNWORKER(fnid)),
                    dwSCMSFlags, (psms));
        }
    } else {
StandardSend:
        *plRet = ScSendMessageSMS((pwnd), (message), (wParam), (lParam),
                (ULONG_PTR)(pwnd)->lpfnWndProc,
                gpsi->apfnClientW.pfnDispatchMessage, dwSCMSFlags, (psms));
    }
}


/***********************************************************************\
* xxxSendMessageTimeout (API)
*
* This function synchronously sends a message to a window. The four
* parameters hwnd, message, wParam, and lParam are passed to the window
* procedure of the receiving window.  If the window receiving the message
* belongs to the same queue as the current thread, the window proc is called
* directly.  Otherwise, we set up an sms structure, wake the appropriate
* thread to receive the message and wait for a reply.
* If the thread is 'hung' or if the time-out value is exceeded, we will
* fail the request.
*
* lpdwResult = NULL if normal sendmessage, if !NULL then it's a timeout call
*
* Returns:
*   the value returned by the window procedure, or NULL if there is an error
*
* History:
* 07-13-92 ChrisBl      Created/extended from SendMessage
\***********************************************************************/
LRESULT xxxSendMessageTimeout(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    PLONG_PTR lpdwResult)
{
    LRESULT lRet;
    PTHREADINFO ptiCurrent;
    ULONG_PTR uResult;   // holder for DDE_INITIATE case

    CheckCritIn();

    /*
     * The timeout value is only respected if lpdwResult is non-NULL. This,
     * however, is not obvious, and has caused multiple, hard to track down
     * bugs. So let's assert that the call makes sense.
     */
    UserAssert(uTimeout == 0 || lpdwResult != NULL);

    if (lpdwResult != NULL) {
       *lpdwResult = 0L;
    }

    /*
     * Is this a BroadcastMsg()?
     */
    if (pwnd == PWND_BROADCAST) {
        BROADCASTMSG bcm;
        PBROADCASTMSG pbcm = NULL;
        UINT uCmd = BMSG_SENDMSG;

        if (lpdwResult != NULL) {
            uCmd = BMSG_SENDMSGTIMEOUT;
            bcm.to.fuFlags = fuFlags;
            bcm.to.uTimeout = uTimeout;
            bcm.to.lpdwResult = lpdwResult;
            pbcm = &bcm;
        }

        return xxxBroadcastMessage(NULL, message, wParam, lParam, uCmd, pbcm );
    }

    CheckLock(pwnd);

    if (message >= WM_DDE_FIRST && message <= WM_DDE_LAST) {
        /*
         * Even though apps should only send WM_DDE_INITIATE or WM_DDE_ACK
         * messages, we hook them all so DDESPY can monitor them.
         */
        if (!xxxDDETrackSendHook(pwnd, message, wParam, lParam)) {
            return 0;
        }
        if (message == WM_DDE_INITIATE && guDdeSendTimeout) {
            /*
             * This hack prevents DDE apps from locking up because some
             * one in the system has a top level window and is not
             * processing messages.  guDdeSendTimeout is registry set.
             */
            if (lpdwResult == NULL) {
                lpdwResult = &uResult;
            }
            fuFlags |= SMTO_ABORTIFHUNG;
            uTimeout = guDdeSendTimeout;
        }
    }

    ptiCurrent = PtiCurrent();

    /*
     * Do inter-thread call if window queue differs from current queue
     */
    if (ptiCurrent != GETPTI(pwnd)) {
        INTRSENDMSGEX ism;
        PINTRSENDMSGEX pism = NULL;

        /*
         * If this window is a zombie, don't allow inter-thread send messages
         * to it.
         */
        if (HMIsMarkDestroy(pwnd))
            return xxxDefWindowProc(pwnd, message, wParam, lParam);

        if ( lpdwResult != NULL ) {
            /*
             * fail if we think the thread is hung
             */
            if ((fuFlags & SMTO_ABORTIFHUNG) && FHungApp(GETPTI(pwnd), CMSWAITTOKILLTIMEOUT))
               return 0;

            /*
             * Setup for a InterSend time-out call
             */
            ism.fuCall = ISM_TIMEOUT;
            ism.fuSend = fuFlags;
            ism.uTimeout = uTimeout;
            ism.lpdwResult = lpdwResult;
            pism = &ism;
        }

        lRet = xxxInterSendMsgEx(pwnd, message, wParam, lParam,
                ptiCurrent, GETPTI(pwnd), pism );

        return lRet;
    }

    /*
     * Call WH_CALLWNDPROC if it's installed and the window is not marked
     * as destroyed.
     */
    if (IsHooked(ptiCurrent, WHF_CALLWNDPROC)) {
        CWPSTRUCTEX cwps;

        cwps.hwnd = HWq(pwnd);
        cwps.message = message;
        cwps.wParam = wParam;
        cwps.lParam = lParam;
        cwps.psmsSender = NULL;

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.
         */
        xxxCallHook(HC_ACTION, FALSE, (LPARAM)&cwps, WH_CALLWNDPROC);

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.  If this behavior reverts to
         * Win3.1 semantics, we will need to copy the new parameters
         * from cwps.
         */
    }

    /*
     * If this window's proc is meant to be executed from the server side
     * we'll just stay inside the semaphore and call it directly.  Note
     * how we don't convert the pwnd into an hwnd before calling the proc.
     */
    if (TestWF(pwnd, WFSERVERSIDEPROC)) {

        /*
         * We have a number of places where we do recursion in User.  This often goes
         * through SendMessage (when we send a message to the parent for example) which
         * can eat the amount of stack we have
         */
        if ((IoGetRemainingStackSize() < KERNEL_STACK_MINIMUM_RESERVE)
#if defined(_IA64_)
                || (GET_CURRENT_BSTORE() < KERNEL_BSTORE_MINIMUM_RESERVE)
#endif
            ) {
            RIPMSG1(RIP_ERROR, "SendMessage: Thread recursing in User with message %lX; failing", message);
            return FALSE;
        }


        lRet = pwnd->lpfnWndProc(pwnd, message, wParam, lParam);

        if ( lpdwResult == NULL ) {
            return lRet;
        } else {      /* time-out call */
            *lpdwResult = lRet;
            return TRUE;
        }
    }

    /*
     * Call the client or xxxDefWindowProc. pwnd is already locked.
     */
    xxxSendMessageToClient(pwnd, message, wParam, lParam, NULL, FALSE, &lRet);

    /*
     * Call WH_CALLWNDPROCRET if it's installed.
     */
    if (IsHooked(ptiCurrent, WHF_CALLWNDPROCRET)) {
        CWPRETSTRUCTEX cwps;

        cwps.hwnd = HWq(pwnd);
        cwps.message = message;
        cwps.wParam = wParam;
        cwps.lParam = lParam;
        cwps.lResult = lRet;
        cwps.psmsSender = NULL;

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.
         */
        xxxCallHook(HC_ACTION, FALSE, (LPARAM)&cwps, WH_CALLWNDPROCRET);

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.  If this behavior reverts to
         * Win3.1 semantics, we will need to copy the new parameters
         * from cwps.
         */
    }

    if ( lpdwResult != NULL ) {     /* time-out call */
        *lpdwResult = lRet;
        return TRUE;
    }

    return lRet;
}

/***************************************************************************\
* QueueNotifyMessage
*
* This routine queues up a notify message *only*, and does NOT do any callbacks
* or any waits. This is for certain code that cannot do a callback for
* compatibility reasons, but still needs to send notify messages (normal
* notify messages actually do a callback if the calling thread created the
* pwnd. Also this will NOT callback any hooks (sorry!)
*
* 04-13-93 ScottLu      Created.
\***************************************************************************/
void QueueNotifyMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TL tlpwnd;
    BEGINATOMICCHECK();

    /*
     * We have to thread lock the window even though we don't leave
     * the critical section or else xxxSendMessageCallback complains.
     */
    ThreadLock(pwnd, &tlpwnd);
    xxxSendMessageCallback(pwnd, message, wParam, lParam, NULL, 1L, 0);
    ThreadUnlock(&tlpwnd);
    ENDATOMICCHECK();
}


/***************************************************************************\
* xxxSystemBroadcastMessage
*
* Sends a message to all top-level windows in the system.  To do this
* for messages with parameters that point to data structures in a way
* that won't block on a hung app, post an event message for
* each window that is to receive the real message.  The real message
* will be sent when the event message is processed.
*
* History:
* 05-12-94 JimA         Created.
\***************************************************************************/

VOID xxxSystemBroadcastMessage(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    UINT wCmd,
    PBROADCASTMSG pbcm)
{
    PTHREADINFO     ptiCurrent = PtiCurrent();
    PWINDOWSTATION  pwinsta;
    PDESKTOP        pdesk;
    TL              tlpwinsta;
    TL              tlpdesk;

    /*
     * Walk through all windowstations and desktop looking for
     * top-level windows.
     */
    ThreadLockWinSta(ptiCurrent, NULL, &tlpwinsta);
    ThreadLockDesktop(ptiCurrent, NULL, &tlpdesk, LDLT_FN_SYSTEMBROADCASTMESSAGE);
    for (pwinsta = grpWinStaList; pwinsta != NULL; ) {
        UINT wCmd1;

        if ((wCmd == BMSG_SENDMSG) && (pwinsta != ptiCurrent->rpdesk->rpwinstaParent))
            wCmd1 = BMSG_SENDNOTIFYMSG;
        else
            wCmd1 = wCmd;

        ThreadLockExchangeWinSta(ptiCurrent, pwinsta, &tlpwinsta);
        for (pdesk = pwinsta->rpdeskList; pdesk != NULL; ) {

            ThreadLockExchangeDesktop(ptiCurrent, pdesk, &tlpdesk, LDLT_FN_SYSTEMBROADCASTMESSAGE);

            /*
             * Bug 276814. Don't recurse calling again xxxBroadcastMessage if there
             * is no window on this desktop.
             */
            if (pdesk->pDeskInfo->spwnd != NULL) {
                xxxBroadcastMessage(pdesk->pDeskInfo->spwnd, message, wParam, lParam,
                        wCmd1, pbcm);
            }

            pdesk = pdesk->rpdeskNext;
        }
        pwinsta = pwinsta->rpwinstaNext;
    }
    ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_SYSTEMBROADCASTMESSAGE);
    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);
}


/***********************************************************************\
* xxxSendNotifyMessage (API)
*
* This function sends a message to the window proc associated with pwnd.
* The window proc is executed in the context of the thread which created
* pwnd.  The function is identical to SendMessage() except that in the
* case of an inter-thread call, the send does not wait for a reply from
* the receiver, it simply returns a BOOL indicating success or failure.
* If the message is sent to a window on the current thread, then the
* function behaves just like SendMessage() and essentially does a
* subroutine call to pwnd's window procedure.
*
* History:
* 01-23-91 DavidPe      Created.
* 07-14-92 ChrisBl      Will return T/F if in same thread, as documented
\***********************************************************************/

BOOL xxxSendNotifyMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    /*
     * If this is a broadcast of one of the system
     * notification messages,  send it to all top-level
     * windows in the system.
     */
    if (pwnd == PWND_BROADCAST) {
        switch (message) {
        case WM_WININICHANGE:
        case WM_DEVMODECHANGE:
        case WM_SPOOLERSTATUS:
            xxxSystemBroadcastMessage(message, wParam, lParam,
                    BMSG_SENDNOTIFYMSG, NULL);
            return 1;

        default:
            break;
        }
    }

    return xxxSendMessageCallback( pwnd, message, wParam, lParam,
            NULL, 0L, 0 );
}


/***********************************************************************\
* xxxSendMessageCallback (API)
*
* This function synchronously sends a message to a window. The four
* parameters hwnd, message, wParam, and lParam are passed to the window
* procedure of the receiving window.  If the window receiving the message
* belongs to the same queue as the current thread, the window proc is called
* directly.  Otherwise, we set up an sms structure, wake the appropriate
* thread to receive the message and give him a call back function to send
* the result to.
*
* History:
* 07-13-92 ChrisBl      Created/extended from SendNotifyMessage
\***********************************************************************/

BOOL xxxSendMessageCallback(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    ULONG_PTR dwData,
    BOOL fClientRequest)
{
    LRESULT lRet;
    PTHREADINFO ptiCurrent;
    BOOL fQueuedNotify;

    /*
     * See if this is a queued notify message.
     */
    fQueuedNotify = FALSE;
    if (lpResultCallBack == NULL && dwData == 1L)
        fQueuedNotify = TRUE;

    /*
     * First check to see if this message takes DWORDs only. If it does not,
     * fail the call. Cannot allow an app to post a message with pointers or
     * handles in it - this can cause the server to fault and cause other
     * problems - such as causing apps in separate address spaces to fault.
     * (or even an app in the same address space to fault!)
     */
    if (TESTSYNCONLYMESSAGE(message, wParam)) {
        RIPERR1(ERROR_MESSAGE_SYNC_ONLY, RIP_WARNING,
                "Trying to non-synchronously send a structure msg=%lX", message);
        return FALSE;
    }

    CheckCritIn();

    /*
     * Is this a BroadcastMsg()?
     */
    if (pwnd == PWND_BROADCAST) {
        BROADCASTMSG bcm;
        PBROADCASTMSG pbcm = NULL;
        UINT uCmd = BMSG_SENDNOTIFYMSG;

        if (lpResultCallBack != NULL) {
            uCmd = BMSG_SENDMSGCALLBACK;
            bcm.cb.lpResultCallBack = lpResultCallBack;
            bcm.cb.dwData = dwData;
            bcm.cb.bClientRequest = fClientRequest;
            pbcm = &bcm;
        }

        return xxxBroadcastMessage(NULL, message, wParam, lParam, uCmd, pbcm );
    }

    CheckLock(pwnd);

    ptiCurrent = PtiCurrent();

    /*
     * Do inter-thread call if window thead differs from current thread.
     * We pass NULL for ptiSender to tell xxxInterSendMsgEx() that this is
     * a xxxSendNotifyMessage() and that there's no need for a reply.
     *
     * If this is a queued notify, always call InterSendMsgEx() so that
     * we queue it up and return - we don't do callbacks here with queued
     * notifies.
     */
    if (fQueuedNotify || ptiCurrent != GETPTI(pwnd)) {
        INTRSENDMSGEX ism;
        PINTRSENDMSGEX pism = NULL;

        if (lpResultCallBack != NULL) {  /* CallBack request */
            ism.fuCall = ISM_CALLBACK | (fClientRequest ? ISM_CB_CLIENT : 0);
            ism.lpResultCallBack = lpResultCallBack;
            ism.dwData = dwData;
            pism = &ism;
        }
        return (BOOL)xxxInterSendMsgEx(pwnd, message, wParam, lParam,
                NULL, GETPTI(pwnd), pism );
    }

    /*
     * Call WH_CALLWNDPROC if it's installed.
     */
    if (!fQueuedNotify && IsHooked(ptiCurrent, WHF_CALLWNDPROC)) {
        CWPSTRUCTEX cwps;

        cwps.hwnd = HWq(pwnd);
        cwps.message = message;
        cwps.wParam = wParam;
        cwps.lParam = lParam;
        cwps.psmsSender = NULL;

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.
         */
        xxxCallHook(HC_ACTION, FALSE, (LPARAM)&cwps, WH_CALLWNDPROC);

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.  If this behavior reverts to
         * Win3.1 semantics, we will need to copy the new parameters
         * from cwps.
         */
    }

    /*
     * If this window's proc is meant to be executed from the server side
     * we'll just stay inside the semaphore and call it directly.  Note
     * how we don't convert the pwnd into an hwnd before calling the proc.
     */
    if (TestWF(pwnd, WFSERVERSIDEPROC)) {
        lRet = pwnd->lpfnWndProc(pwnd, message, wParam, lParam);
    } else {
        /*
         * Call the client or xxxDefWindowProc. pwnd is already locked
         */
        xxxSendMessageToClient(pwnd, message, wParam, lParam, NULL, FALSE, &lRet);
    }

    if (lpResultCallBack != NULL) {
       /*
        * Call the callback funtion for the return value
        */
        if (fClientRequest) {
            /*
             * The application-defined callback proc is neither Unicode/ANSI
             */
            SET_FLAG(ptiCurrent->pcti->CTIF_flags, CTIF_INCALLBACKMESSAGE);
            CallClientProcA(pwnd, message, dwData, lRet,
                    (ULONG_PTR)lpResultCallBack);
            CLEAR_FLAG(ptiCurrent->pcti->CTIF_flags, CTIF_INCALLBACKMESSAGE);
        } else {
            (*lpResultCallBack)((HWND)pwnd, message, dwData, lRet);
        }
    }

    /*
     * Call WH_CALLWNDPROCRET if it's installed.
     */
    if (!fQueuedNotify && IsHooked(ptiCurrent, WHF_CALLWNDPROCRET)) {
        CWPRETSTRUCTEX cwps;

        cwps.hwnd = HWq(pwnd);
        cwps.message = message;
        cwps.wParam = wParam;
        cwps.lParam = lParam;
        cwps.lResult = lRet;
        cwps.psmsSender = NULL;

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.
         */
        xxxCallHook(HC_ACTION, FALSE, (LPARAM)&cwps, WH_CALLWNDPROCRET);

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.  If this behavior reverts to
         * Win3.1 semantics, we will need to copy the new parameters
         * from cwps.
         */
    }

    return TRUE;
}


/***********************************************************************\
* xxxInterSendMsgEx
*
* This function does an inter-thread send message.  If ptiSender is NULL,
* that means we're called from xxxSendNotifyMessage() and should act
* accordingly.
*
* History:
* 07-13-92 ChrisBl       Created/extended from xxxInterSendMsg
\***********************************************************************/

#define NoString        0
#define IsAnsiString    1
#define IsUnicodeString 2

/*
 * We will capture the an address in two cases
 * 1- If the address is a user mode address or
 * 2- The call is a SendNotifyMessafe or SendMessageCallback.
 *
 * #2 is true if ptiSender is NULL see xxxSendMessageCallback implementation.
 * Why we do that?
 * if we are in SendNotifyMessafe or SendMessageCallback then force capture.
 * because these two APIs will not wait till the receiver thread handles the
 * message, then any kernel stack memory will be invalid once we return from
 * these two APIs.
 */
#define FORCE_CAPTURE(Addr) (!IS_SYSTEM_ADDRESS(Addr) || (ptiSender == NULL))

LRESULT xxxInterSendMsgEx(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PTHREADINFO ptiSender,
    PTHREADINFO ptiReceiver,
    PINTRSENDMSGEX pism)
{
    PSMS psms, *ppsms;
    PSMS psmsSentSave;
    LRESULT lRet = 0;
    DWORD cbCapture, cbOutput;
    PBYTE lpCapture;
    PCOPYDATASTRUCT pcds;
    PMDICREATESTRUCTEX pmdics;
    LPHLP phlp;
    LPHELPINFO phelpinfo;
    LARGE_STRING str;
    LPARAM lParamSave;
    UINT fString = NoString;
    BOOLEAN bWasSwapEnabled;

    CheckCritIn();


    /*
     * If the sender is dying, fail the call
     */
    if ((ptiSender != NULL) && (ptiSender->TIF_flags & TIF_INCLEANUP))
        return 0;

    /*
     * Some messages cannot be sent across process because we don't know how to thunk them
     * Fail attempts to read passwords across processes.
     */
    if (pwnd && GETPTI(pwnd)->ppi != PpiCurrent()) {
        switch (message) {
        case EM_SETWORDBREAKPROC:
            if (!RtlEqualLuid(&(GETPTI(pwnd)->ppi->luidSession), &(PpiCurrent()->luidSession))) {
                RIPMSGF3(RIP_WARNING,
                         "Message cannot be sent across different LUID, pwnd: %p, message: 0x%x, target ppi: %p.",
                         pwnd,
                         message,
                         GETPTI(pwnd)->ppi);
                return 0;
            }
            break;
        case WM_INITDIALOG:
        case WM_NOTIFY:
            RIPMSG0(RIP_WARNING | RIP_THERESMORE, "xxxInterSendMsgEx: message cannot be sent across processes");
            RIPMSG4(RIP_WARNING | RIP_THERESMORE, " pwnd:%#p message:%#x wParam:%#p lParam:%#p", pwnd, message, wParam, lParam);
            return 0;

        /*
         * A change was introduced here to check with IS_EDIT macro instead of directly
         * accessing FNID.  The reason is to maintain conformity and not break
         * comctl32 v6 password edits which can't set fnid field in pwnd.
         */
        case WM_GETTEXT:
        case EM_GETLINE:
        case EM_SETPASSWORDCHAR:
            if (IS_EDIT(pwnd) && TestWF(pwnd, EFPASSWORD)) {
                RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Can't access protected edit control");
                return 0;
            }
            break;
        }
    }

    /*
     * Alloc SMS structure.
     */
    psms = AllocSMS();
    if (psms == NULL) {

        /*
         * Set to zero so xxxSendNotifyMessage would return FALSE.
         */
        return 0;
    }

    /*
     * Prepare to capture variable length data from client
     * space.  Addresses have already been probed.  Fixed-length
     * data is probed and captured in the message thunk.
     */
    psms->pvCapture = NULL;
    cbCapture = cbOutput = 0;
    lpCapture = (LPBYTE)lParam;

    /*
     * If this is a reply message then wParam and lParam is equal NULL.
     * No need to capture anything.
     */
    if ((pism != NULL) && (pism->fuCall == (ISM_CALLBACK | ISM_REPLY))) {
        goto REPLY_MSG;
    }

    /*
     * For messages with indirect data, set cbCapture and lpCapture
     * (if not lParam) as approp.
     */
    try {
        switch (message) {
        case WM_COPYGLOBALDATA:     // fnCOPYGLOBALDATA
            cbCapture = (DWORD)wParam;
            break;

        case WM_COPYDATA:           // fnCOPYDATA
            pcds = (PCOPYDATASTRUCT)lParam;
            if (pcds->lpData) {
                cbCapture = sizeof(COPYDATASTRUCT) + pcds->cbData;
            } else {
                cbCapture = sizeof(COPYDATASTRUCT);
            }
            break;

        case WM_CREATE:             // fnINLPCREATESTRUCT
        case WM_NCCREATE:           // fnINLPCREATESTRUCT
            RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Can't Intersend WM_CREATE or WM_NCCREATE message");
            FreeSMS(psms);
            return 0;

        case WM_HELP:               // fnINLPHELPINFOSTRUCT
            phelpinfo = (LPHELPINFO)lParam;
            cbCapture = phelpinfo->cbSize;
            break;

        case WM_WINHELP:            // fnINLPHLPSTRUCT
            phlp = (LPHLP)lParam;
            cbCapture = phlp->cbData;
            break;

        case WM_MDICREATE:          // fnINLPMDICREATESTRUCT
            pmdics = (PMDICREATESTRUCTEX)lParam;
            cbCapture = pmdics->strTitle.MaximumLength +
                    pmdics->strClass.MaximumLength;
            UserAssert(pmdics->strClass.Buffer == NULL || pmdics->strClass.Buffer == pmdics->mdics.szClass);
            if (pmdics->strTitle.Buffer)
                UserAssert(pmdics->strTitle.Buffer == pmdics->mdics.szTitle);
            break;

        case LB_ADDSTRING:           // INLBOXSTRING calls fnINSTRING
        case LB_INSERTSTRING:        // INLBOXSTRING calls fnINSTRING
        case LB_SELECTSTRING:        // INLBOXSTRING calls fnINSTRING
        case LB_FINDSTRING:          // INLBOXSTRING calls fnINSTRING
        case LB_FINDSTRINGEXACT:     // INLBOXSTRING calls fnINSTRING
            /*
             * See if the control is ownerdraw and does not have the LBS_HASSTRINGS
             * style. If so, treat lParam as a DWORD.
             */
            if (pwnd && !(pwnd->style & LBS_HASSTRINGS) &&
                    (pwnd->style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE))) {
                /*
                 * Treat lParam as a dword.
                 */
                break;
            } else {
                goto fnINSTRINGThunk;
            }
            break;

        case CB_ADDSTRING:           // INCBOXSTRING calls fnINSTRING
        case CB_INSERTSTRING:        // INCBOXSTRING calls fnINSTRING
        case CB_SELECTSTRING:        // INCBOXSTRING calls fnINSTRING
        case CB_FINDSTRING:          // INCBOXSTRING calls fnINSTRING
        case CB_FINDSTRINGEXACT:     // INCBOXSTRING calls fnINSTRING
            /*
             * See if the control is ownerdraw and does not have the CBS_HASSTRINGS
             * style. If so, treat lParam as a DWORD.
             */
            if (pwnd && !(pwnd->style & CBS_HASSTRINGS) &&
                    (pwnd->style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))) {

                /*
                 * Treat lParam as a dword.
                 */
                break;
            } else {
                goto fnINSTRINGThunk;
            }
            break;

        case EM_REPLACESEL:         // fnINSTRINGNULL
        case WM_SETTEXT:            // fnINSTRINGNULL
        case WM_WININICHANGE:       // fnINSTRINGNULL
            if (lParam == 0)
                break;

            /*
             * Fall through
             */

        case CB_DIR:                // fnINSTRING
        case LB_ADDFILE:            // fnINSTRING
        case LB_DIR:                // fnINSTRING
        case WM_DEVMODECHANGE:      // fnINSTRING
fnINSTRINGThunk:

            /*
             * Only capture strings if they are not in system space or ptiSender
             * is NULL (see FORCE_CAPTURE definition).
             *
             * Also we are going to capture the LARGE_STRING structure itself because
             * it is (lParam) a stack memory.
             */
            str = *(PLARGE_STRING)lParam;

            if (FORCE_CAPTURE(str.Buffer))
                cbCapture = str.Length + sizeof(WCHAR) + sizeof(LARGE_STRING);
            break;

        case WM_DEVICECHANGE:
            if (lParam == 0)
                break;

            /*
             * Only capture data if lParam is a pointer and
             * the data is not in system space
             */
            if ((wParam & 0x8000) != 0x8000)
                break;

            if (FORCE_CAPTURE((LPVOID)lParam)) {
                cbCapture = *((DWORD *)lpCapture);
                UserAssert(FALSE);
            }
            break;

        case EM_SETTABSTOPS:        // fnPOPTINLPUINT
        case LB_SETTABSTOPS:        // fnPOPTINLPUINT
        case LB_GETSELITEMS:        // fnPOUTLPINT
            cbCapture = (UINT)wParam * sizeof(INT);
            break;

        case EM_GETLINE:            // fnINCNTOUTSTRING
        case WM_ASKCBFORMATNAME:    // fnINCNTOUTSTRINGNULL
        case WM_GETTEXT:            // fnOUTSTRING
        case LB_GETTEXT:            // fnOUTLBOXSTRING
        case CB_GETLBTEXT:          // fnOUTCBOXSTRING

            /*
             * Only allocate output buffer if the real one is not in system space
             */
            str = *(PLARGE_STRING)lParam;
            /*
            * Bug 18108. For WM_GETTEXT only copy the actual string and not the
            * the maximum size into the output buffer
            */
            if(str.bAnsi) {
                fString = IsAnsiString  ;
            } else {
                fString  = IsUnicodeString ;
            }
            lParam = (LPARAM)&str;
            if (FORCE_CAPTURE(str.Buffer))
                cbCapture = str.MaximumLength;
            break;
        }
        if (cbCapture &&
                (psms->pvCapture = UserAllocPoolWithQuota(cbCapture, TAG_SMS_CAPTURE)) != NULL) {

            lParamSave = lParam;

            /*
             * now actually copy memory from lpCapture to psms->pvCapture
             * and fixup any references to the indirect data to point to
             * psms->pvCapture.
             */
            switch (message) {
            case WM_COPYDATA:     // fnCOPYDATA
                {
                    PCOPYDATASTRUCT pcdsNew = (PCOPYDATASTRUCT)psms->pvCapture;
                    lParam = (LPARAM)pcdsNew;
                    RtlCopyMemory(pcdsNew, pcds, sizeof(COPYDATASTRUCT));
                    if (pcds->lpData) {
                        pcdsNew->lpData = (PVOID)((PBYTE)pcdsNew + sizeof(COPYDATASTRUCT));
                        RtlCopyMemory(pcdsNew->lpData, pcds->lpData, pcds->cbData);
                    }
                }
                break;
            case WM_MDICREATE:          // fnINLPMDICREATESTRUCT
                if (pmdics->strClass.Buffer) {
                    RtlCopyMemory(psms->pvCapture, pmdics->strClass.Buffer,
                            pmdics->strClass.MaximumLength);
                    pmdics->mdics.szClass = (LPWSTR)psms->pvCapture;
                }
                if (pmdics->strTitle.Length) {
                    lpCapture = (PBYTE)psms->pvCapture + pmdics->strClass.MaximumLength;
                    RtlCopyMemory(lpCapture, pmdics->strTitle.Buffer,
                            pmdics->strTitle.MaximumLength);
                    pmdics->mdics.szTitle = (LPWSTR)lpCapture;
                }
                break;

            case CB_DIR:                // fnINSTRING
            case LB_FINDSTRING:         // INLBOXSTRING calls fnINSTRING
            case LB_FINDSTRINGEXACT:    // INLBOXSTRING calls fnINSTRING
            case CB_FINDSTRING:         // INCBOXSTRING calls fnINSTRING
            case CB_FINDSTRINGEXACT:    // INCBOXSTRING calls fnINSTRING
            case LB_ADDFILE:            // fnINSTRING
            case LB_ADDSTRING:          // INLBOXSTRING calls fnINSTRING
            case LB_INSERTSTRING:       // INLBOXSTRING calls fnINSTRING
            case LB_SELECTSTRING:       // INLBOXSTRING calls fnINSTRING
            case CB_ADDSTRING:          // INCBOXSTRING calls fnINSTRING
            case CB_INSERTSTRING:       // INCBOXSTRING calls fnINSTRING
            case CB_SELECTSTRING:       // INCBOXSTRING calls fnINSTRING
            case LB_DIR:                // fnINSTRING
            case WM_DEVMODECHANGE:      // fnINSTRING
            case EM_REPLACESEL:         // fnINSTRINGNULL
            case WM_SETTEXT:            // fnINSTRINGNULL
            case WM_WININICHANGE:       // fnINSTRINGNULL
                {
                    PLARGE_STRING pstr = psms->pvCapture;
                    lParam = (LPARAM)pstr;
                    pstr->bAnsi  = str.bAnsi;
                    pstr->Length = str.Length;
                    pstr->Buffer = (LPBYTE)pstr + sizeof(LARGE_STRING);
                    pstr->MaximumLength = cbCapture - sizeof(LARGE_STRING);
                    UserAssert(pstr->MaximumLength == pstr->Length + sizeof(WCHAR));
                    RtlCopyMemory(pstr->Buffer, str.Buffer, pstr->MaximumLength);
                }
                break;

            case LB_GETSELITEMS:
                 cbOutput = cbCapture;
                 RtlCopyMemory(psms->pvCapture, lpCapture, cbCapture);
                 lParam = (LPARAM)psms->pvCapture;
                 break;

            case EM_GETLINE:            // fnINCNTOUTSTRING
                 *(WORD *)psms->pvCapture = *(WORD *)str.Buffer;

                /*
                 * Fall through
                 */
            case WM_ASKCBFORMATNAME:    // fnINCNTOUTSTRINGNULL
            case WM_GETTEXT:            // fnOUTSTRING
            case LB_GETTEXT:            // fnOUTLBOXSTRING
            case CB_GETLBTEXT:          // fnOUTCBOXSTRING
                cbOutput = cbCapture;
                lParamSave = (LPARAM)str.Buffer;
                str.Buffer = psms->pvCapture;
                break;

            default:
                RtlCopyMemory(psms->pvCapture, lpCapture, cbCapture);
                lParam = (LPARAM)psms->pvCapture;
                break;
            }
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        if (psms->pvCapture != NULL)
            UserFreePool(psms->pvCapture);
        FreeSMS(psms);
        return 0;
    }

    if (cbCapture && psms->pvCapture == NULL) {
        FreeSMS(psms);
        return 0;
    }
REPLY_MSG:
    /*
     * Copy message parms
     */
    psms->spwnd = NULL;
    psms->psmsReceiveNext = NULL;
#if DBG
    psms->psmsSendList = NULL;
    psms->psmsSendNext = NULL;
#endif
    Lock(&(psms->spwnd), pwnd);
    psms->message = message;
    psms->wParam = wParam;
    psms->lParam = lParam;
    psms->flags = 0;

    /*
     * Link into gpsmsList
     */
    psms->psmsNext = gpsmsList;
    gpsmsList = psms;

    /*
     * Time stamp message
     */
    psms->tSent = NtGetTickCount();

    /*
     * Set queue fields
     */
    psms->ptiReceiver = ptiReceiver;
    psms->ptiSender = ptiSender;
    psms->ptiCallBackSender = NULL;

    if ((pism != NULL) && (pism->fuCall & ISM_CALLBACK)) {
        /*
         * Setup for a SendMessageCallback
         */
        psms->flags |= (pism->fuCall & ISM_CB_CLIENT) ? SMF_CB_CLIENT : SMF_CB_SERVER;
        psms->lpResultCallBack = pism->lpResultCallBack;
        psms->dwData = pism->dwData;

        if (pism->fuCall & ISM_REPLY) {
            psms->flags |= SMF_CB_REPLY;
            psms->lRet = pism->lRet;
        } else {  /* REQUEST */
            psms->flags |= SMF_CB_REQUEST;
            psms->ptiCallBackSender = PtiCurrent();
        }
    }

    /*
     * Add SMS to the end of the ptiReceiver's receive list
     */
    ppsms = &ptiReceiver->psmsReceiveList;
    while (*ppsms != NULL) {
        ppsms = &((*ppsms)->psmsReceiveNext);
    }
    *ppsms = psms;

    /*
     * Link this SMS into the SendMsg chain.  Of course only do this if
     * it's not from a xxxSendNotifyMessage() call.
     *
     * The psmsSendNext field implements a chain of messages being
     * processed because of an initial SendMsg call.  For example, if
     * thread A sends message M1 to thread B, which causes B to send
     * message M2 to thread C, the SendMsg chain is M1->M2.  If the
     * system hangs in this situation, the chain is traversed to find
     * the offending thread (C).
     *
     * psms->psmsSendList always points to the head of this list so
     * we can tell where to begin a list traversal.
     *
     * ptiSender->psmsCurrent is the last SMS in the chain.
     */
#if DBG
    if (ptiSender != NULL && ptiSender->psmsCurrent != NULL) {
        /*
         * sending queue is currently processing a message sent to it,
         * so append SMS to the chain.  Link in the new sms because
         * psmsSendNext may be pointing to a replied-to message.
         */
        psms->psmsSendNext = ptiSender->psmsCurrent->psmsSendNext;
        ptiSender->psmsCurrent->psmsSendNext = psms;
        psms->psmsSendList = ptiSender->psmsCurrent->psmsSendList;

    } else {
        /*
         * sending queue is initiating a send sequence, so put sms at
         * the head of the chain
         */
        psms->psmsSendList = psms;
    }
#endif

    if (ptiSender != NULL) {
        /*
         * ptiSender->psmsSent marks the most recent message sent from this
         * thread that has not yet been replied to.  Save the previous value
         * on the stack so it can be restored when we get the reply.
         *
         * This way when an "older" SMS for this thread gets a reply before
         * the "current" one does, the thread does get woken up.
         */
        psmsSentSave = ptiSender->psmsSent;
        ptiSender->psmsSent = psms;
    } else {

        /*
         * Set SMF_RECEIVERFREE since we'll be returning to
         * xxxSendNotifyMessage() right away and won't get a
         * chance to free it.
         */
        psms->flags |= SMF_RECEIVERFREE;
    }

#ifdef DEBUG_SMS
    ValidateSmsSendLists(psms);
#endif

    /*
     * If we're not being called from xxxSendNotifyMessage() or
     * SendMessageCallback(), then sleep while we wait for the reply.
     */
    if (ptiSender == NULL) {
        /*
         * Wake receiver for the sent message
         */
        SetWakeBit(ptiReceiver, QS_SENDMESSAGE);

        return (LONG)TRUE;
    } else {
        BOOL fTimeOut = FALSE;
        UINT uTimeout = 0;
        UINT uWakeMask = QS_SMSREPLY;

        /*
         * Wake up the receiver thread.
         */
        SetWakeBit(ptiReceiver, QS_SENDMESSAGE);

        /*
         * We have 4 sending cases:
         *
         * 16 - 16 : yield to the 16 bit receiver
         * 32 - 16 : no yielding required
         * 16 - 32 : sender yields while receiver processes the message
         * 32 - 32 : no yielding required.
         */
        if (ptiSender->TIF_flags & TIF_16BIT || ptiReceiver->TIF_flags & TIF_16BIT) {
            DirectedScheduleTask(ptiSender, ptiReceiver, TRUE, psms);
        }

        /*
         * Put this thread to sleep until the reply arrives.  First clear
         * the QS_SMSREPLY bit, then leave the semaphore and go to sleep.
         *
         * IMPORTANT:  The QS_SMSREPLY bit is not cleared once we get a
         * reply because of the following case:
         *
         * We've recursed a second level into SendMessage() when the first level
         * receiver thread dies, causing exit list processing to simulate
         * a reply to the first message.  When the second level send returns,
         * SleepThread() is called again to get the first reply.
         *
         * Keeping QS_SMSREPLY set causes this call to SleepThread()
         * to return without going to sleep to wait for the reply that has
         * already happened.
         */
        if ( pism != NULL ) {
            if (pism->fuSend & SMTO_BLOCK) {
                /*
                 * only wait for a return, all other events will
                 * be ignored until timeout or return
                 */
                uWakeMask |= QS_EXCLUSIVE;
            }

            uTimeout = pism->uTimeout;
        }


        /*
         * Don't swap this guys stack while sleeping during a sendmessage
         */
        if (ptiSender->cEnterCount == 0) {
            bWasSwapEnabled = KeSetKernelStackSwapEnable(FALSE);
        } else {
            UserAssert(ptiSender->cEnterCount > 0);
        }
        ptiSender->cEnterCount++;


        while ((psms->flags & SMF_REPLY) == 0 && !fTimeOut) {
            PHOOK phk = NULL;
            TL tl;
            BOOLEAN fRememberTimeout = FALSE;

            ptiSender->pcti->fsChangeBits &= ~QS_SMSREPLY;

            if (message == WM_HOOKMSG && lParam && GetAppCompatFlags2ForPti(ptiReceiver, VER51)) {
                phk = ((PHOOKMSGSTRUCT)lParam)->phk;
                switch (phk->iHook) {
                case WH_KEYBOARD_LL:
                case WH_MOUSE_LL:
                    ThreadLock(phk, &tl);
                    fRememberTimeout = TRUE;
                    break;
                }
            }

            /*
             * If SendMessageTimeout, sleep for timeout amount, else wait
             * forever.  Since this is not technically a transition to an
             * idle condition, indicate that this sleep is not going "idle".
             */
            fTimeOut = !xxxSleepThread(uWakeMask, uTimeout, FALSE);

            /*
             * Windows bug 307738: EverQuest LL hook is virtually
             * hung, blocking the DirectInput thread.
             */
            if (fRememberTimeout) {
                phk->fLastHookHung = fTimeOut;
                ThreadUnlock(&tl);
            }

            /*
             * If a timeout occurs, and the SMTO_NOTIMEOUTIFNOTHUNG bit is set,
             * and the app is still calling GetMessage(), then just try again.
             * This probably means that the receiver has put up some UI in
             * response to this message but the user hasn't completed the
             * interaction yet.
             */
            if (fTimeOut && pism && (pism->fuSend & SMTO_NOTIMEOUTIFNOTHUNG) &&
                    !FHungApp(ptiReceiver, CMSHUNGAPPTIMEOUT)) {
                fTimeOut = FALSE;
            }
        }

        UserAssert(ptiSender->cEnterCount > 0);
        if (--ptiSender->cEnterCount == 0) {
            KeSetKernelStackSwapEnable(bWasSwapEnabled);
        }

        /*
         * The reply bit should always be set! (even if we timed out). That
         * is because if we're recursed into intersendmsg, we're going to
         * return to the first intersendmsg's call to SleepThread() - and
         * it needs to return back to intersendmsgex to see if its sms
         * has been replied to.
         */
        SetWakeBit(ptiSender, QS_SMSREPLY);

        /*
         * Copy out captured data.  If cbOutput != 0 we know
         * that the output buffer is in user-mode address
         * space.
         */
        if (!fTimeOut && cbOutput) {
            PBYTE pbOutput;
            INT len;

            /*
             * Probe output buffer if it is in the user's address space
             */

            pbOutput = (PBYTE)lParamSave;
            try {
                if(fString == NoString) {
                    RtlCopyMemory((PBYTE)pbOutput, psms->pvCapture,
                            cbOutput);
                } else if(fString == IsAnsiString) {
                    len = strncpycch((LPSTR)pbOutput,(LPCSTR)psms->pvCapture,
                            cbOutput);
                    #if DBG
                     len--; //Length includes terminating NULL char
                     if(len != psms->lRet) {
                        RIPMSG0(RIP_WARNING,
                            "Length of the copied string being returned is diffrent from the actual string length");
                     }
                    #endif
                } else  { //IsUnicodeString
                    len = wcsncpycch((LPWSTR)pbOutput,(LPCWSTR)psms->pvCapture,
                            cbOutput/sizeof(WCHAR));
                    #if DBG
                    len--;
                     if(len != psms->lRet) {
                        RIPMSG0(RIP_WARNING,
                            "Length of the copied string being returned is diffrent from the actual string length");
                     }
                    #endif
                }
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {

                /*
                 * Return 0 to indicate an error.
                 */
                psms->lRet = 0;
            }
        }

        /*
         * we now have the reply -- restore psmsSent and save the return value
         */
        ptiSender->psmsSent = psmsSentSave;

        if (pism == NULL) {
            lRet = psms->lRet;
        } else {
            /*
             * save the values off for a SendMesssageTimeOut
             */
            *pism->lpdwResult = psms->lRet;
            lRet = (!fTimeOut) ? TRUE : FALSE;  /* do this to ensure ret is T or F... */

            /*
             * If we did timeout and no reply was received, rely on
             * the receiver to free the sms.
             */
            if (!(psms->flags & SMF_REPLY))
                psms->flags |= SMF_REPLY | SMF_RECEIVERFREE;
        }

        /*
         * If the reply came while the receiver is still processing
         * the sms, force the receiver to free the sms.  This can occur
         * via timeout, ReplyMessage or journal cancel.
         */
        if ((psms->flags & (SMF_RECEIVERBUSY | SMF_RECEIVEDMESSAGE)) != SMF_RECEIVEDMESSAGE) {
            psms->flags |= SMF_RECEIVERFREE;
        }

        /*
         * Unlink the SMS structure from both the SendMsg chain and gpsmsList
         * list and free it.  This sms could be anywhere in the chain.
         *
         * If the SMS was replied to by a thread other than the receiver
         * (ie.  through ReplyMessage()), we don't free the SMS because the
         * receiver is still processing it and will free it when done.
         */
        if ((psms->flags & SMF_RECEIVERFREE) == 0) {
            UnlinkSendListSms(psms, NULL);
        }
    }

    return lRet;
}


/***********************************************************************\
* xxxReceiveMessage
*
* This function receives a message sent from another thread.  Physically,
* it gets the message, calls the window proc and then cleans up the
* fsWakeBits and sms stuctures.
*
* History:
* 01-13-91 DavidPe      Ported.
* 01-23-91 DavidPe      Add xxxSendNotifyMessage() support.
* 07-14-92 ChrisBl      Added xxxSendMessageCallback support.
\***********************************************************************/

VOID xxxReceiveMessage(
    PTHREADINFO ptiReceiver)
{
    PSMS psms;
    PSMS psmsCurrentSave;
    PTHREADINFO ptiSender;
    LRESULT lRet = 0;
    TL tlpwnd;

    CheckCritIn();

    /*
     * Get the SMS and unlink it from the list of SMSs we've received
     */
    psms = ptiReceiver->psmsReceiveList;

    /*
     * This can be NULL because an SMS can be removed in our cleanup
     * code without clearing the QS_SENDMESSAGE bit.
     */
    if (psms == NULL) {
        ptiReceiver->pcti->fsWakeBits &= ~QS_SENDMESSAGE;
        ptiReceiver->pcti->fsChangeBits &= ~QS_SENDMESSAGE;
        return;
    }

    ptiReceiver->psmsReceiveList = psms->psmsReceiveNext;
    psms->psmsReceiveNext = NULL;

    /*
     * We've taken the SMS off the receive list - mark the SMS with this
     * information - used during cleanup.
     */
    psms->flags |= SMF_RECEIVERBUSY | SMF_RECEIVEDMESSAGE;

    /*
     * Clear QS_SENDMESSAGE wakebit if list is now empty
     */
    if (ptiReceiver->psmsReceiveList == NULL) {
        ptiReceiver->pcti->fsWakeBits &= ~QS_SENDMESSAGE;
        ptiReceiver->pcti->fsChangeBits &= ~QS_SENDMESSAGE;
    }

    ptiSender = psms->ptiSender;

    if (psms->flags & SMF_CB_REPLY) {
        /*
         * From SendMessageCallback REPLY to callback.  We need to call
         * the call back function to give the return value.
         * Don't process any this message, just mechanism for notification
         * the sender's thread lock is already gone, so we need to re-lock here.
         */
        if (ptiSender == NULL) {
            ThreadLock(psms->spwnd, &tlpwnd);
        }

        if (psms->flags & SMF_CB_CLIENT) {
            PTHREADINFO ptiCurrent = PtiCurrent();
            /*
             * Application-defined callback proc is neither Unicode nor ANSI
             */
            SET_FLAG(ptiCurrent->pcti->CTIF_flags, CTIF_INCALLBACKMESSAGE);
            CallClientProcA(psms->spwnd, psms->message, psms->dwData,
                    psms->lRet, (ULONG_PTR)psms->lpResultCallBack);
            CLEAR_FLAG(ptiCurrent->pcti->CTIF_flags, CTIF_INCALLBACKMESSAGE);
        } else {
            psms->lpResultCallBack(HW(psms->spwnd), psms->message,
                    psms->dwData, psms->lRet);
        }

        if (ptiSender == NULL) {
            ThreadUnlock(&tlpwnd);
        }
    } else if (!(psms->flags & (SMF_REPLY | SMF_SENDERDIED | SMF_RECEIVERDIED))) {
        /*
         * Don't process message if it has been replied to already or
         * if the sending or receiving thread has died
         */

        /*
         * Set new psmsCurrent for this queue, saving the current one
         */
        psmsCurrentSave = ptiReceiver->psmsCurrent;
        ptiReceiver->psmsCurrent = psms;
        SET_FLAG(ptiReceiver->pcti->CTIF_flags, CTIF_INSENDMESSAGE);

        /*
         * If this SMS originated from a xxxSendNotifyMessage() or a
         * xxxSendMessageCallback() call, the sender's thread lock is
         * already gone, so we need to re-lock here.
         */
        if (ptiSender == NULL) {
            ThreadLock(psms->spwnd, &tlpwnd);
        }

        if (psms->message == WM_HOOKMSG) {
            union {
                EVENTMSG emsg;          // WH_JOURNALRECORD/PLAYBACK
                MOUSEHOOKSTRUCTEX mhs;  // WH_MOUSE
                KBDLLHOOKSTRUCT   kbds; // WH_KEYBORD_LL
                MSLLHOOKSTRUCT    mslls;// WH_MOUSE_LL
#ifdef REDIRECTION
                HTHOOKSTRUCT      ht;   // WH_HITTEST
#endif // REDIRECTION
            } LocalData;
            PVOID pSendersData;
            PHOOKMSGSTRUCT phkmp;
            int iHook;
            BOOL bAnsiHook;

            /*
             * Some hook types (eg: WH_JOURNALPLAYBACK) pass pointers to
             * data in the calling thread's stack.  We must copy this to our
             * own (called thread's) stack for safety because of the way this
             * "message" is handled and in case the calling thread dies. #13577
             *
             * Originally only WH_JOURNALRECORD and WH_JOURNALPLAYBACK went
             * through this code, but now all sorts of hooks do.
             */
            phkmp = (PHOOKMSGSTRUCT)psms->lParam;
            pSendersData = (PVOID)(phkmp->lParam);
            iHook = phkmp->phk->iHook;

            switch (iHook) {
            case WH_JOURNALRECORD:
            case WH_JOURNALPLAYBACK:
                if (pSendersData)
                    LocalData.emsg = *(PEVENTMSG)pSendersData;
                break;

            case WH_MOUSE:
                if (pSendersData)
                    LocalData.mhs = *(LPMOUSEHOOKSTRUCTEX)pSendersData;
                break;

            case WH_KEYBOARD_LL:
                if (pSendersData)
                    LocalData.kbds = *(LPKBDLLHOOKSTRUCT)pSendersData;
                break;

            case WH_MOUSE_LL:
                if (pSendersData)
                    LocalData.mslls = *(LPMSLLHOOKSTRUCT)pSendersData;
                break;

#ifdef REDIRECTION
            case WH_HITTEST:
                if (pSendersData)
                    LocalData.ht = *(LPHTHOOKSTRUCT)pSendersData;
                break;
#endif // REDIRECTION

            case WH_KEYBOARD:
            case WH_SHELL:
                /*
                 * Fall thru...
                 */
                pSendersData = NULL;
                break;

            default:
                /*
                 * No pointers: wParam & lParam can be sent as is.
                 */
                RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Receive hook %d", iHook);
                pSendersData = NULL;
                break;
            }


            lRet = xxxCallHook2(phkmp->phk, phkmp->nCode, psms->wParam,
                    pSendersData ? (LPARAM)&LocalData : phkmp->lParam, &bAnsiHook);

            /*
             * Copy back data only if the sender hasn't died or timed out
             * (timed out messages are marked SMF_REPLY by the sending thread)
             */
            if (!(psms->flags & (SMF_SENDERDIED|SMF_REPLY)) && pSendersData) {
                switch (iHook) {
                case WH_JOURNALRECORD:
                case WH_JOURNALPLAYBACK:
                    *(PEVENTMSG)pSendersData = LocalData.emsg;
                    break;

                case WH_KEYBOARD_LL:
                    *(LPKBDLLHOOKSTRUCT)pSendersData = LocalData.kbds;
                    break;

                case WH_MOUSE_LL:
                    *(LPMSLLHOOKSTRUCT)pSendersData = LocalData.mslls;
                    break;

                case WH_MOUSE:
                    *(LPMOUSEHOOKSTRUCTEX)pSendersData = LocalData.mhs;
                    break;

#ifdef REDIRECTION
                case WH_HITTEST:
                    *(LPHTHOOKSTRUCT)pSendersData = LocalData.ht;
                    break;
#endif // REDIRECTION
                }
            }

        } else {
            /*
             * Call WH_CALLWNDPROC if it's installed and the window is not marked
             * as destroyed.
             */
            if (IsHooked(ptiReceiver, WHF_CALLWNDPROC)) {
                CWPSTRUCTEX cwps;

                cwps.hwnd = HW(psms->spwnd);
                cwps.message = psms->message;
                cwps.wParam = psms->wParam;
                cwps.lParam = psms->lParam;
                cwps.psmsSender = psms;

                xxxCallHook(HC_ACTION, TRUE, (LPARAM)&cwps, WH_CALLWNDPROC);

                /*
                 * Unlike Win3.1, NT and Win95 ignore any changes the app makes
                 * to the CWPSTRUCT contents.  If this behavior reverts to
                 * Win3.1 semantics, we will need to copy the new parameters
                 * from cwps.
                 */
            }

            if (!(psms->flags & (SMF_REPLY | SMF_SENDERDIED | SMF_RECEIVERDIED)) &&
                    psms->spwnd != NULL) {
                if (TestWF(psms->spwnd, WFSERVERSIDEPROC)) {
                    TL tlpwndKernel;

                    ThreadLock(psms->spwnd, &tlpwndKernel);
                    /*
                     * If this window's proc is meant to be executed from the server side
                     * we'll just stay inside the semaphore and call it directly.  Note
                     * how we don't convert the pwnd into an hwnd before calling the proc.
                     */
                    lRet = psms->spwnd->lpfnWndProc(psms->spwnd, psms->message,
                            psms->wParam, psms->lParam);

                    ThreadUnlock(&tlpwndKernel);
                } else {
                    /*
                     * Call the client or xxxDefWindowProc.
                     */
                    xxxSendMessageToClient(psms->spwnd, psms->message, psms->wParam, psms->lParam,
                                        psms, TRUE, &lRet);
                }

                /*
                 * Call WH_CALLWNDPROCRET if it's installed.
                 */
                if (IsHooked(ptiReceiver, WHF_CALLWNDPROCRET) &&
                        !(psms->flags & SMF_SENDERDIED)) {
                    CWPRETSTRUCTEX cwps;

                    cwps.hwnd = HW(psms->spwnd);
                    cwps.message = psms->message;
                    cwps.wParam = psms->wParam;
                    cwps.lParam = psms->lParam;
                    cwps.lResult = lRet;
                    cwps.psmsSender = psms;

                    /*
                     * Unlike Win3.1, NT and Win95 ignore any changes the app makes
                     * to the CWPSTRUCT contents.
                     */
                    xxxCallHook(HC_ACTION, TRUE, (LPARAM)&cwps, WH_CALLWNDPROCRET);

                    /*
                     * Unlike Win3.1, NT and Win95 ignore any changes the app makes
                     * to the CWPSTRUCT contents.  If this behavior reverts to
                     * Win3.1 semantics, we will need to copy the new parameters
                     * from cwps.
                     */
                }
            }
        }

        if ((psms->flags & (SMF_CB_REQUEST | SMF_REPLY)) == SMF_CB_REQUEST) {

            /*
             * From SendMessageCallback REQUEST callback.  Send the message
             * back with a the REPLY value.
             */
            INTRSENDMSGEX ism;

            psms->flags |= SMF_REPLY;

            if (!(psms->flags & SMF_SENDERDIED)) {
                ism.fuCall = ISM_CALLBACK | ISM_REPLY;
                if (psms->flags & SMF_CB_CLIENT)
                    ism.fuCall |= ISM_CB_CLIENT;
                ism.lpResultCallBack = psms->lpResultCallBack;
                ism.dwData = psms->dwData;
                ism.lRet = lRet;

                xxxInterSendMsgEx(psms->spwnd, psms->message, 0L, 0L,
                        NULL, psms->ptiCallBackSender, &ism );
            }
        }

        if (ptiSender == NULL) {
            ThreadUnlock(&tlpwnd);
        }

        /*
         * Restore receiver's original psmsCurrent.
         */
        ptiReceiver->psmsCurrent = psmsCurrentSave;
        SET_OR_CLEAR_FLAG(ptiReceiver->pcti->CTIF_flags,
                          CTIF_INSENDMESSAGE,
                          ptiReceiver->psmsCurrent);

#ifdef DEBUG_SMS
        ValidateSmsSendLists(psmsCurrentSave);
#endif
    }

    /*
     * We're done with this sms, so the appropriate thread
     * can now free it.
     */
    psms->flags &= ~SMF_RECEIVERBUSY;

    /*
     * Free the sms and return without reply if the
     * SMF_RECEIVERFREE bit is set.  Handily, this does just what we
     * want for xxxSendNotifyMessage() since we set SMF_RECEIVERFREE
     * in that case.
     */
    if (psms->flags & SMF_RECEIVERFREE) {
        UnlinkSendListSms(psms, NULL);
        return;
    }

    /*
     * Set reply flag and return value if this message has not already
     * been replied to with ReplyMessage().
     */
    if (!(psms->flags & SMF_REPLY)) {
        psms->lRet = lRet;
        psms->flags |= SMF_REPLY;

        /*
         * Tell the sender, the reply is done
         */
        if (ptiSender != NULL) {
            /*
             * Wake up the sender thread.
             */
            SetWakeBit(ptiSender, QS_SMSREPLY);

            /*
             * We have 4 conditions to satisfy:
             *
             * 16 - 16 : yielding required, if sender is waiting for this reply
             * 32 - 16 : yielding required, if sender is waiting for this reply
             * 16 - 32 : no yielding required
             * 32 - 32 : No yielding required.
             */

            if (ptiSender->TIF_flags & TIF_16BIT || ptiReceiver->TIF_flags & TIF_16BIT) {
                DirectedScheduleTask(ptiReceiver, ptiSender, FALSE, psms);
                if (ptiReceiver->TIF_flags & TIF_16BIT &&
                    ptiSender->psmsSent == psms)
                  {
                    xxxSleepTask(TRUE, NULL);
                }
            }
        }
    }

}


/***********************************************************************\
* SendMsgCleanup
*
* This function cleans up sendmessage structures when the thread associated
* with a queue terminates.  In the following, S is the sending thread,
* R the receiving thread.
*
* Case Table:
*
* single death:
*   R no reply, S dies:  mark that S died, R will free sms
*   R no reply, R dies:  fake reply for S
*   R replied,  S dies:  free sms
*   R replied,  R dies:  no problem
*
* double death:
*   R no reply, S dies, R dies:  free sms
*   R no reply, R dies, S dies:  free sms
*   R replied,  S dies, R dies:  sms freed when S dies, as in single death
*   R replied,  R dies, S dies:  sms freed when S dies, as in single death
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

VOID SendMsgCleanup(
    PTHREADINFO ptiCurrent)
{
    PSMS *ppsms;
    PSMS psmsNext;

    CheckCritIn();

    for (ppsms = &gpsmsList; *ppsms; ) {
        psmsNext = (*ppsms)->psmsNext;

        if ((*ppsms)->ptiSender == ptiCurrent ||
                (*ppsms)->ptiCallBackSender == ptiCurrent) {
            SenderDied(*ppsms, ppsms);
        } else if ((*ppsms)->ptiReceiver == ptiCurrent) {
            ReceiverDied(*ppsms, ppsms);
        }

        /*
         * If the message was not unlinked, go to the next one.
         */
        if (*ppsms != psmsNext)
            ppsms = &(*ppsms)->psmsNext;
    }
}


/***********************************************************************\
* ClearSendMessages
*
* This function marks messages destined for a given window as invalid.
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

VOID ClearSendMessages(
    PWND pwnd)
{
    PSMS psms, psmsNext;
    PSMS *ppsms;

    CheckCritIn();

    psms = gpsmsList;
    while (psms != NULL) {
        /*
         * Grab the next one beforehand in case we free the current one.
         */
        psmsNext = psms->psmsNext;

        if (psms->spwnd == pwnd) {

            /*
             * If the sender has died, then mark this receiver free so the
             * receiver will destroy it in its processing.
             */
            if (psms->flags & SMF_SENDERDIED) {
                psms->flags |= SMF_REPLY | SMF_RECEIVERFREE;
            } else {
                /*
                 * The sender is alive. If the receiver hasn't replied to
                 * this yet, make a reply so the sender gets it. Make sure
                 * the receiver is the one free it so we don't have a race
                 * condition.
                 */
                if (!(psms->flags & SMF_REPLY)) {

                    /*
                     * The sms is either still on the receive list
                     * or is currently being received. Since the sender
                     * is alive, we want the sender to get the reply
                     * to this SMS. If it hasn't been received, take
                     * it off the receive list and reply to it. If it
                     * has been received, then just leave it alone:
                     * it'll get replied to normally.
                     */
                    if (psms->flags & SMF_CB_REQUEST) {
                        /*
                         * From SendMessageCallback REQUEST callback.  Send the
                         * message back with a the REPLY value.
                         */
                        TL tlpwnd;
                        INTRSENDMSGEX ism;

                        psms->flags |= SMF_REPLY;

                        ism.fuCall = ISM_CALLBACK | ISM_REPLY;
                        if (psms->flags & SMF_CB_CLIENT)
                            ism.fuCall |= ISM_CB_CLIENT;
                        ism.lpResultCallBack = psms->lpResultCallBack;
                        ism.dwData = psms->dwData;
                        ism.lRet = 0L;    /* null return */

                        ThreadLock(psms->spwnd, &tlpwnd);

                        xxxInterSendMsgEx(psms->spwnd, psms->message, 0L, 0L,
                                NULL, psms->ptiCallBackSender, &ism );

                        ThreadUnlock(&tlpwnd);
                    } else if (!(psms->flags & SMF_RECEIVERBUSY)) {
                        /*
                         * If there is no sender, this is a notification
                         * message (nobody to reply to). In this case,
                         * just set the SMF_REPLY bit (SMF_RECEIVERFREE
                         * is already set) and this'll cause ReceiveMessage
                         * to just free this SMS and return.
                         */
                        if (psms->ptiSender == NULL) {
                            psms->flags |= SMF_REPLY;
                        } else {
                            /*
                             * There is a sender, and it wants a reply: take
                             * this SMS off the receive list, and reply
                             * to the sender.
                             */
                            for (ppsms = &(psms->ptiReceiver->psmsReceiveList);
                                        *ppsms != NULL;
                                        ppsms = &((*ppsms)->psmsReceiveNext)) {

                                if (*ppsms == psms) {
                                    *ppsms = psms->psmsReceiveNext;
                                    break;
                                }
                            }


      /*
                             * Reply to this message so the sender
                             * wakes up.
                             */
                            psms->flags |= SMF_REPLY;
                            psms->lRet = 0;
                            psms->psmsReceiveNext = NULL;
                            SetWakeBit(psms->ptiSender, QS_SMSREPLY);

                            /*
                             *  16 bit senders need to be notifed that sends completed
                             *  otherwise it may wait for a very long time for the reply.
                             */
                            if (psms->ptiSender->TIF_flags & TIF_16BIT) {
                                DirectedScheduleTask(psms->ptiReceiver, psms->ptiSender, FALSE, psms);
                            }
                        }
                    }
                }
            }

            /*
             * Unlock the pwnd from the SMS structure.
             */
            Unlock(&psms->spwnd);
        }

        psms = psmsNext;
    }
}

/***********************************************************************\
* ReceiverDied
*
* This function cleans up the send message structures after a message
* receiver window or queue has died.  It fakes a reply if one has not
* already been sent and the sender has not died.  It frees the sms if
* the sender has died.
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

VOID ReceiverDied(
    PSMS psms,
    PSMS *ppsmsUnlink)
{
    PSMS *ppsms;
    PTHREADINFO ptiReceiver;
    PTHREADINFO ptiSender;

    /*
     * mark that the receiver died
     */
    ptiReceiver = psms->ptiReceiver;
    psms->ptiReceiver = NULL;
    psms->flags |= SMF_RECEIVERDIED;

    /*
     * Unlink sms from thread if it is not dying.  We need to do
     * this for journal cleanup.
     */
    if (!(ptiReceiver->TIF_flags & TIF_INCLEANUP)) {

        /*
         * unlink sms from the receiver's receive list
         */
        for (ppsms = &(ptiReceiver->psmsReceiveList); *ppsms != NULL;
                    ppsms = &((*ppsms)->psmsReceiveNext)) {

            if (*ppsms == psms) {
                *ppsms = psms->psmsReceiveNext;
                break;
            }
        }

        /*
         * clear the QS_SENDMESSAGE bit if there are no more messages
         */
        if (ptiReceiver->psmsReceiveList == NULL) {
            ptiReceiver->pcti->fsWakeBits &= ~QS_SENDMESSAGE;
            ptiReceiver->pcti->fsChangeBits &= ~QS_SENDMESSAGE;
        }
    } else {

        /*
         * The receiver thread is dying.  Clear the received flag
         * so that if there is a sender, it will free the sms.
         */
        psms->flags &= ~SMF_RECEIVERBUSY;
    }

    psms->psmsReceiveNext = NULL;

    /*
     * Check if the sender died or if the receiver was marked to
     * free the sms.
     */
    if (psms->ptiSender == NULL) {

        if (!(psms->flags & SMF_SENDERDIED) &&
                (psms->flags & (SMF_CB_REQUEST | SMF_REPLY)) == SMF_CB_REQUEST) {

            /*
             * From SendMessageCallback REQUEST callback.  Send the message
             * back with a the REPLY value.
             */
            TL tlpwnd;
            INTRSENDMSGEX ism;

            psms->flags |= SMF_REPLY;

            ism.fuCall = ISM_CALLBACK | ISM_REPLY;
            if (psms->flags & SMF_CB_CLIENT)
                ism.fuCall |= ISM_CB_CLIENT;
            ism.lpResultCallBack = psms->lpResultCallBack;
            ism.dwData = psms->dwData;
            ism.lRet = 0L;    /* null return */

            ThreadLock(psms->spwnd, &tlpwnd);

            xxxInterSendMsgEx(psms->spwnd, psms->message, 0L, 0L,
                    NULL, psms->ptiCallBackSender, &ism );

            ThreadUnlock(&tlpwnd);
        }

        /*
         * If the receiver is not processing the message, free it.
         */
        if (!(psms->flags & SMF_RECEIVERBUSY))
            UnlinkSendListSms(psms, ppsmsUnlink);
        return;

    } else if (!(psms->flags & SMF_REPLY)) {

        /*
         * fake a reply
         */
        psms->flags |= SMF_REPLY;
        psms->lRet = 0;
        psms->ptiReceiver = NULL;

        /*
         * wake the sender if he was waiting for us
         */
        SetWakeBit(psms->ptiSender, QS_SMSREPLY);
    } else {
        /*
         * There is a reply. We know the receiver is dying, so clear the
         * SMF_RECEIVERFREE bit or the sender won't free this SMS!
         * Although the sender's wake bit has already been set by the
         * call to ClearSendMessages() earlier in the cleanup code,
         * set it here again for safety.
         *
         * ??? Why would SMF_RECEIVERFREE be set?
         */
        psms->flags &= ~SMF_RECEIVERFREE;
        SetWakeBit(psms->ptiSender, QS_SMSREPLY);
    }

    /*
     * If the sender is a WOW task, that task is now blocked in the non-
     * preemptive scheduler waiting for a reply.  DestroyTask will
     * clean this up (even if ptiReceiver is 32-bit).
     */
    ptiSender = psms->ptiSender;
    if (ptiSender->TIF_flags & TIF_16BIT) {
        DirectedScheduleTask(ptiReceiver, ptiSender, FALSE, psms);
    }

    /*
     * Unlock this window from the sms: it is no longer needed, and will get
     * rid of lock warnings.
     */
    Unlock(&psms->spwnd);
}


/***********************************************************************\
* SenderDied
*
* This function cleans up the send message structures after a message
* sender has died.
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

VOID SenderDied(
    PSMS psms,
    PSMS *ppsmsUnlink)
{
    PTHREADINFO ptiSender;
    BOOL fReply = FALSE;

    /*
     * mark the death
     */
    if (psms->ptiSender != NULL)
        ptiSender = psms->ptiSender;
    else
        ptiSender = psms->ptiCallBackSender;
    psms->ptiSender = NULL;
    psms->flags |= SMF_SENDERDIED;

    /*
     * There are two cases where we leave the sms alone so the receiver
     * can handle the message and then free the sms itself.
     *
     *  1.  When the receiver is processing the message.
     *
     *  2.  When the message has not yet been received.
     */

    /*
     * If the receiver is processing the message, make it free the sms.
     * Fake a reply for journal cancel.
     */
    if (psms->flags & SMF_RECEIVERBUSY) {
        psms->flags |= SMF_RECEIVERFREE;
        fReply = TRUE;
    }

    /*
     * This sms may be in the process of being sent, but has not yet
     * been received.  In so, fake a reply and wake the sender.
     * The last thread to touch the sms, either the sender or
     * receiver, will free the sms.
     */
    if (ptiSender->psmsSent == psms)
        fReply = TRUE;

    /*
     * If journalling is being cancelled and reply needs to be made,
     * fake a reply and return.
     */
    if (!(ptiSender->TIF_flags & TIF_INCLEANUP) && fReply) {

        /*
         * fake a reply
         */
        psms->flags |= SMF_REPLY;
        psms->lRet = 0;

        /*
         * wake the sender if he was waiting for us
         */
        SetWakeBit(ptiSender, QS_SMSREPLY);
        return;
    }

    /*
     * If the receiver isn't dead, check to see if it has honestly replied to
     * this SMS. If it has not replied, leave it alone so the receiver can
     * reply to it (it'll then clean it up). If it has replied, then it's
     * ok to free it.
     *
     * It is also ok to free it if the receiver is dead.
     */
    if ((psms->flags & SMF_RECEIVERDIED) ||
            (psms->flags & (SMF_REPLY | SMF_RECEIVERFREE)) == SMF_REPLY) {
        UnlinkSendListSms(psms, ppsmsUnlink);
    } else {
        psms->flags |= SMF_RECEIVERFREE;
    }
}


/***********************************************************************\
* UnlinkSendListSms
*
* This function unlinks an sms structure from both its SendMsg chain and
* the global gpsmsList and frees it.
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

VOID UnlinkSendListSms(
    PSMS psms,
    PSMS *ppsmsUnlink)
{
#if DBG
    PSMS psmsT;
    BOOL fUpdateSendList;
    PSMS *ppsms;
#endif

    CheckCritIn();

#ifdef DEBUG_SMS
    ValidateSmsSendLists(psms);
#endif

    UserAssert(psms->psmsReceiveNext == NULL);

#if DBG
    /*
     * Remember ahead of time if the psms we're unlinking is also the
     * head of the sms send list (so we know if we need to update this field
     * member in every SMS in this list).
     */
    fUpdateSendList = (psms == psms->psmsSendList);

    /*
     * Unlink sms from the sendlist chain. This effectively unlinks the SMS
     * and updates psms->psmsSendList with the right head....
     */
    ppsms = &(psms->psmsSendList);
    while (*ppsms != NULL) {
        if (*ppsms == psms) {
            *ppsms = psms->psmsSendNext;
            break;
        }
        ppsms = &(*ppsms)->psmsSendNext;
    }

    /*
     * Update psmsSendList if necessary. psms->psmsSendList has been updated
     * with the right sms send list head... distribute this head to all other
     * sms's in this chain if this sms we're removing the current head.
     */
    if (fUpdateSendList) {
        for (psmsT = psms->psmsSendList; psmsT != NULL;
                psmsT = psmsT->psmsSendNext) {
            psmsT->psmsSendList = psms->psmsSendList;
        }
    }

    psms->psmsSendList = NULL;
#endif

    /*
     * This unlinks an sms structure from the global gpsmsList and frees it.
     */
    if (ppsmsUnlink == NULL) {
        ppsmsUnlink = &gpsmsList;

        while (*ppsmsUnlink && (*ppsmsUnlink != psms)) {
            ppsmsUnlink = &((*ppsmsUnlink)->psmsNext);
        }
    }

    UserAssert(*ppsmsUnlink);

    *ppsmsUnlink = psms->psmsNext;

    Unlock(&psms->spwnd);

#if DBG
    UserAssert(!(psms == psms->psmsSendList && psms->psmsSendNext != NULL));
#endif

    if (psms->pvCapture)
        UserFreePool(psms->pvCapture);

    FreeSMS(psms);
}


/***************************************************************************\
* xxxSendSizeMessages
*
*
*
* History:
* 10-19-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

void xxxSendSizeMessage(
    PWND pwnd,
    UINT cmdSize)
{
    RECT rc;
    CheckLock(pwnd);

    // Added by Chicago: HACK ALERT:
    // If the window is minimized then the real client width and height are
    // zero. But, in win3.1 they were non-zero. Under Chicago, PrintShop
    // Deluxe ver 1.2 hits a divide by zero. To fix this we fake the width
    // and height for old apps to be non-zero values.
    // GetClientRect does that job for us.
    _GetClientRect(pwnd, &rc);

    xxxSendMessage(pwnd, WM_SIZE, cmdSize,
            MAKELONG(rc.right - rc.left, rc.bottom - rc.top));
}


/***************************************************************************\
* xxxProcessAsyncSendMessage
*
* Processes an event message posted by xxxSystemBroadcastMessage by
* sending a message to the window stored in the event.
*
* History:
* 05-12-94 JimA         Created.
\***************************************************************************/

VOID xxxProcessAsyncSendMessage(
    PASYNCSENDMSG pmsg)
{
    PWND pwnd;
    TL tlpwndT;
    WCHAR awchString[MAX_PATH];
    ATOM Atom = 0;
    LARGE_UNICODE_STRING str;

    pwnd = RevalidateHwnd(pmsg->hwnd);
    if (pwnd != NULL) {
        ThreadLockAlways(pwnd, &tlpwndT);
        switch (pmsg->message) {
        case WM_WININICHANGE:
        case WM_DEVMODECHANGE:
            if (pmsg->lParam) {
                if (UserGetAtomName((ATOM)pmsg->lParam, awchString, sizeof(awchString))) {
                    Atom = (ATOM)pmsg->lParam;
                    RtlInitLargeUnicodeString(&str, awchString, (UINT)-1);
                    pmsg->lParam = (LPARAM)&str;
                } else {
                    UserAssert(FALSE);
                    pmsg->lParam = 0;
                }
            }
            break;
        }
        xxxSendMessage(pwnd, pmsg->message, pmsg->wParam, pmsg->lParam);
        ThreadUnlock(&tlpwndT);
    }
    if (Atom) {
        UserDeleteAtom(Atom);
    }
    UserFreePool(pmsg);
}


/***************************************************************************\
* xxxBroadcastMessage
*
*
*
* History:
* 02-21-91 DavidPe      Created.
\***************************************************************************/

LONG xxxBroadcastMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    UINT wCmd,
    PBROADCASTMSG pbcm)
{
    PBWL pbwl;
    HWND *phwnd;
    TL tlpwnd;
    PASYNCSENDMSG pmsg;
    PPROCESSINFO ppiCurrent;
    LONG lRet = TRUE;
    TL tlPool;
    PTHREADINFO ptiCurrent = PtiCurrent();
    BOOL fPrivateMessage = (message >= WM_USER) && (message < MAXINTATOM);

    if (fPrivateMessage) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Attempt to broadcast a private message");
    }

    if (pwnd == NULL) {
        LARGE_UNICODE_STRING str;
        PLARGE_STRING pstr;

        /*
         * Handle special system-wide broadcasts.
         */
        switch (message) {
        case WM_SPOOLERSTATUS:
            xxxSystemBroadcastMessage(message, wParam, lParam, wCmd, pbcm);
            return 1;

        case WM_WININICHANGE:
        case WM_DEVMODECHANGE:

            /*
             * Probe and capture the string.
             */
            if (lParam) {
                UINT cbAlloc;
                NTSTATUS Status;

                /*
                 * Allocate a temp buffer and convert
                 * the string to Unicode
                 */
                pstr = ((PLARGE_STRING)lParam);
                if (pstr->bAnsi)
                    cbAlloc = (pstr->Length + 1) * sizeof(WCHAR);
                else
                    cbAlloc = pstr->Length + sizeof(WCHAR);
                str.Buffer = UserAllocPoolWithQuota(cbAlloc, TAG_SMS_STRING);
                if (str.Buffer == NULL) {
                    return 0;
                }
                str.MaximumLength = cbAlloc;
                str.bAnsi = FALSE;
                try {
                    if (pstr->bAnsi) {
                        Status = RtlMultiByteToUnicodeN(
                                        (PWCH)str.Buffer,
                                        cbAlloc,
                                        &cbAlloc,
                                        (PCH)pstr->Buffer,
                                        pstr->Length
                                        );
                        str.Length = cbAlloc;
                    } else {
                        str.Length = pstr->Length;
                        RtlCopyMemory(str.Buffer, pstr->Buffer, str.Length);
                        Status = STATUS_SUCCESS;
                    }
                    str.Buffer[str.Length / sizeof(WCHAR)] = 0;
                } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                    Status = GetExceptionCode();
                }
                if (!NT_SUCCESS(Status)) {
                    UserFreePool(str.Buffer);
                    return 0;
                }
                pstr->Buffer = str.Buffer;
            }
            if (lParam) {
                ThreadLockPool(ptiCurrent, str.Buffer, &tlPool);
            }
            xxxSystemBroadcastMessage(message, wParam,
                    lParam ? (LPARAM)&str : 0, wCmd, pbcm);
            if (lParam)
                ThreadUnlockAndFreePool(ptiCurrent, &tlPool);
            return 1;

        case WM_TIMECHANGE:
            /*
             * We automatically broadcast a WM_TIMECHANGE message whenever the
             * kernel tells us the time has changed, so blow off any apps who
             * are trying to do the same thing.
             */
            if (!(ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD)) {
                RIPMSG0(RIP_WARNING, "Only system should broadcast WM_TIMECHANGE");
                return 0;
            }
            break;
        }

        UserAssert(ptiCurrent->rpdesk);

        pwnd = ptiCurrent->rpdesk->pDeskInfo->spwnd;

        if (pwnd == NULL) {
            RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "sender must have an associated desktop");
            return 0;
        }
    }

    pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL);
    if (pbwl == NULL)
        return 0;

    ppiCurrent = PpiCurrent();

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        /*
         * Make sure this hwnd is still around.
         */
        if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        /*
         * Make sure this window can handle broadcast messages
         */
        if (!fBroadcastProc(pwnd))
            continue;

        if (fPrivateMessage && TestWF(pwnd, WFWIN40COMPAT)) { // Don't broadcast
            continue;                                         // private message
        }                                                     // to 4.0 apps.

        /*
         * Don't bother sending palette messages to windows that are not
         * visible on threads that are not palette aware.
         */
        if ((message == WM_PALETTEISCHANGING || message == WM_PALETTECHANGED) &&
                !TestWF(pwnd, WFVISIBLE) &&
                !(GETPTI(pwnd)->TIF_flags & TIF_PALETTEAWARE)) {
            continue;
        }

        ThreadLockAlways(pwnd, &tlpwnd);

        switch (wCmd) {
        case BMSG_SENDMSG:
            xxxSendMessage(pwnd, message, wParam, lParam);
            break;

        case BMSG_SENDNOTIFYMSG:
            {
                ATOM Atom = 0;

                switch (message) {
                case WM_WININICHANGE:
                case WM_DEVMODECHANGE:
                    if (lParam) {
                        PLARGE_STRING pstr = (PLARGE_STRING)lParam;

                        /*
                         * Convert strings to atoms for the post.
                         */
                        if (pstr)
                            Atom = UserAddAtom(pstr->Buffer, FALSE);
                        if (!Atom) {
                            lRet = FALSE;
                            break;
                        }
                    }

                    /*
                     * These messages need to be able to cross
                     * desktops so PostEvent 'em.
                     */
                    pmsg = UserAllocPool(sizeof(ASYNCSENDMSG),
                        TAG_SMS_ASYNC);
                    if (pmsg == NULL) {
                        goto CleanupAtom;
                    }

                    pmsg->hwnd = *phwnd;
                    pmsg->message = message;
                    pmsg->wParam = wParam;
                    pmsg->lParam = Atom;

                    if (!PostEventMessage(GETPTI(pwnd), GETPTI(pwnd)->pq,
                                         QEVENT_ASYNCSENDMSG,NULL, 0,
                                         (WPARAM)pmsg, 0)) {

                        UserFreePool(pmsg);
CleanupAtom:
                        if (Atom) {
                            UserDeleteAtom(Atom);
                        }
                        lRet = FALSE;
                    }
                    break;

                default:
                    /*
                     * A regular kind of guy.  No desktop crossing.
                     */
                    xxxSendNotifyMessage(pwnd, message, wParam, lParam);
                    break;
                }
            }
            break;

        case BMSG_SENDNOTIFYMSGPROCESS:
            UserAssert(message != WM_WININICHANGE && message != WM_DEVMODECHANGE);

            /*
             * Intra-process messages are synchronous; 22238.
             * WM_PALETTECHANGED was being sent after the WM_DESTROY
             * but console thread must not be synchronous.
             */
            if ((GETPTI(pwnd)->ppi == ppiCurrent) && !(GETPTI(pwnd)->TIF_flags & TIF_CSRSSTHREAD)) {
                xxxSendMessage(pwnd, message, wParam, lParam);
            } else {
                xxxSendNotifyMessage(pwnd, message, wParam, lParam);
            }
            break;

        case BMSG_POSTMSG:
            /*
             * Don't broadcast-post to owned windows (Win3.1 compatiblilty)
             */
            if (pwnd->spwndOwner == NULL)
                _PostMessage(pwnd, message, wParam, lParam);
            break;

        case BMSG_SENDMSGCALLBACK:
            xxxSendMessageCallback(pwnd, message, wParam, lParam,
                    pbcm->cb.lpResultCallBack, pbcm->cb.dwData, pbcm->cb.bClientRequest);
            break;

        case BMSG_SENDMSGTIMEOUT:
            xxxSendMessageTimeout(pwnd, message, wParam, lParam,
                    pbcm->to.fuFlags, pbcm->to.uTimeout, pbcm->to.lpdwResult);
            break;
        }

        ThreadUnlock(&tlpwnd);
    }

    FreeHwndList(pbwl);

    /*
     * Excel-Solver 3.0 expects a non-zero return value from a
     * SendMessage(-1,WM_DDE_INITIATE,....); Because, we had
     * FFFE_FARFRAME in 3.0, the DX register at this point always had
     * a value of 0x102; But, because we removed it under Win3.1, we get
     * a zero value in ax and dx; This makes solver think that the DDE has
     * failed.  So, to support the existing SOLVER, we make dx nonzero.
     * Fix for Bug #6005 -- SANKAR -- 05-16-91 --
     */
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\showwin.c ===
/****************************** Module Header ******************************\
* Module Name: showwin.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains the xxxShowWindow API and related functions.
*
* History:
* 10-20-90 darrinm      Created.
* 02-04-91 IanJa        Window handle revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* _ShowWindowAsync
*
* This queues a show window event in another thread's queue. Used mainly from
* within taskmgr, so that taskmgr doesn't hang waiting on hung apps.
*
* 04-23-93 ScottLu      Created.
\***************************************************************************/

BOOL _ShowWindowAsync(PWND pwnd, int cmdShow, UINT uWPFlags)
{

    return PostEventMessage(
            GETPTI(pwnd),
            GETPTI(pwnd)->pq,
            QEVENT_SHOWWINDOW,
            NULL,
            uWPFlags,
            (WPARAM)HWq(pwnd),
            cmdShow | TEST_PUDF(PUDF_ANIMATE));
}

/***************************************************************************\
* xxxShowWindow (API)
*
* This function changes the "state" of a window based upon the cmdShow
* parameter.  The action taken is:
*
* SW_HIDE             0  Hide the window and pass avtivation to someone else
*
* SW_SHOWNORMAL       1  Show a window in its most recent "normal"
* SW_RESTORE             size and position.  This will "restore" a iconic
*                        or zoomed window.  This is compatible with 1.03
*                        SHOW_OPENWINDOW.  This will also activate the window.
*
* SW_SHOWMINIMIZED    2  Show the window as iconic and make it active.
*
* SW_SHOWMAXIMIZED    3  Show the window as maximized and make it active.
*
* SW_SHOWNOACTIVATE   4  Same as SW_SHOWNORMAL except that it doesn't change
*                        the activation (currently active window stays active).
*
* All the above are compatible with 1.03 ShowWindow parameters.  Now here are
* the new ones:
*
* SW_SHOW             5  Show the window in its current state (iconic, etc.)
*                        That is, if the window is iconic when hidden, it will
*                        still be iconic. This will activate the window.
*                        (This is one we don't have today)
*
* SW_MINIMIZE         6  minimize the window, activate the toplevel open window
*
* SW_SHOWMINNOACTIVE  7  show the icon, don't change activation.
*
* SW_SHOWNA           8  Same as SW_SHOW except that it doesn't change
*                        the activation.
*
* SW_SHOWDEFAULT      10 Use value obtained from STARTUPINFO.
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
* 04-16-91 JimA         Added SW_SHOWDEFAULT support.
\***************************************************************************/

/*
 * cmdShow now has fAnimate as the lower bit in the upper word.  This puts it in the
 * MINMAX_ANIMATE position for calling MinMaximize.
 */

BOOL xxxShowWindow(
    PWND pwnd,
    DWORD cmdShowAnimate)
{
    BOOL fVisOld, fVisNew;
    UINT swpFlags = SWP_NOMOVE | SWP_NOSIZE;
    PTHREADINFO pti;
    BOOL bFirstMain = FALSE;
    int cmdShow = LOWORD(cmdShowAnimate);

    CheckLock(pwnd);

    fVisOld = TestWF(pwnd, WFVISIBLE);
    pti = PtiCurrent();

    /*
     * See if this is the first "main" top level
     * window being created by this application - if show, assume it
     * is showing with the SW_SHOWDEFAULT command.
     *
     * Checks for:
     * - cmdShow is a "default" show command
     * - we haven't done startupinfo yet (we only use it once)
     * - this is not a child (it is a top level window)
     * - this has a titlebar (indicator of the main window)
     * - it isn't owned (indicator of the main window)
     */
    if ((pti->ppi->usi.dwFlags & STARTF_USESHOWWINDOW) &&
            !TestwndChild(pwnd) &&
            (TestWF(pwnd, WFBORDERMASK) == (BYTE)LOBYTE(WFCAPTION)) &&
            (pwnd->spwndOwner == NULL)) {

        bFirstMain = TRUE;

        switch (cmdShow) {
        case SW_SHOWNORMAL:
        case SW_SHOW:

            /*
             * Then assume default!
             */
            cmdShow = SW_SHOWDEFAULT;
            break;
        }
    }

    /*
     * If this application specified SW_SHOWDEFAULT, then we get the
     * real SW_* command from the application's STARTUPINFO structure
     * (STARTUPINFO is passed to CreateProcess() when this application
     * was launched).
     */
    if (cmdShow == SW_SHOWDEFAULT) {

        /*
         * Call the client to get the SW_* command from the STARTUPINFO
         * for this process.
         */
        if (pti->ppi->usi.dwFlags & STARTF_USESHOWWINDOW) {

            bFirstMain = TRUE;

            cmdShow = pti->ppi->usi.wShowWindow;

            /*
             * The following code was removed in 3.51
             *
             * switch (cmdShow) {
             * case SW_SHOWMINIMIZED:
             * case SW_MINIMIZE:
             *
             *      *
             *      * If the default show was "minimized", then make sure it doesn't
             *      * become active.  Minimized is effectively "background".
             *      *
             *     cmdShow = SW_SHOWMINNOACTIVE;
             *     break;
             * }
             *
             */
        }
    }


    /*
     * This is in case someone said SW_SHOWDEFAULT but has no startupinfo.
     * Or in case cmdShow inside of STARTUPINFO is SW_SHOWDEFAULT.
     */
    if (cmdShow == SW_SHOWDEFAULT)
        cmdShow = SW_SHOWNORMAL;

    /*
     * Turn off startup info.  We turn this off after the first call to
     * ShowWindow.  If we don't apps can be started by progman with
     * the start info being minimized and then be restored and then
     * call ShowWindow(SW_SHOW) and the app would minimize again.
     * Notepad had that problem 2985.
     */
    if (bFirstMain) {
        pti->ppi->usi.dwFlags &=
                ~(STARTF_USESHOWWINDOW | STARTF_USESIZE | STARTF_USEPOSITION);
    }


    /*
     * Take care of all the OLD show commands with columns & iconslot.
     */
    if (cmdShow & 0xFF00) {
        if ((cmdShow & 0xFF80) == (int)0xFF80)
            cmdShow = SW_SHOWMINNOACTIVE;
        else
            cmdShow = SW_SHOW;
    }

    /*
     * Change to new fullscreen if needed and in same desktop
     */
    if ((GetFullScreen(pwnd) != WINDOWED)
            && (pwnd->head.rpdesk == grpdeskRitInput)) {
        if ((cmdShow == SW_SHOWNORMAL) ||
            (cmdShow == SW_RESTORE) ||
            (cmdShow == SW_MAXIMIZE) ||
            (cmdShow == SW_SHOWMAXIMIZED)) {
            cmdShow = SW_SHOWMINIMIZED;

            if (GetFullScreen(pwnd) == FULLSCREENMIN) {
                SetFullScreen(pwnd, FULLSCREEN);
            }

            if (gpqForeground != NULL &&
                gpqForeground->spwndActive == pwnd) {
                xxxMakeWindowForegroundWithState(NULL, 0);
            }
        }
    }

    switch (cmdShow) {
    case SW_SHOWNOACTIVATE:
    case SW_SHOWNORMAL:
    case SW_RESTORE:

        /*
         * If min/max, let xxxMinMaximize() do all the work.
         */
        if (TestWF(pwnd, WFMINIMIZED) || TestWF(pwnd, WFMAXIMIZED)) {
            xxxMinMaximize(pwnd, (UINT)cmdShow, cmdShowAnimate & MINMAX_ANIMATE);
            return fVisOld;

        } else {

            /*
             * Ignore if the window is already visible.
             */
            if (fVisOld) {
                return fVisOld;
            }

            swpFlags |= SWP_SHOWWINDOW;
            if (   cmdShow == SW_SHOWNOACTIVATE) {
                swpFlags |= SWP_NOZORDER;
#ifdef NEVER
                /*
                 * This is what win3.1 does. On NT, since each "queue" has
                 * its own active window, there is often no active window.
                 * In this case, win3.1 turns a SHOWNOACTIVATE into a "SHOW
                 * with activate". Since win3.1 almost always has an active
                 * window, this almost never happens. So on NT, we're not
                 * going to do this check - that way we'll be more compatible
                 * with win3.1 because we'll usally not activate (like win3.1).
                 * With this check, this causes FoxPro 2.5 for Windows to not
                 * properly activate its command window when first coming up.
                 */
                if (pti->pq->spwndActive != NULL)
                    swpFlags |= SWP_NOACTIVATE;
#else
                swpFlags |= SWP_NOACTIVATE;
#endif
            }
        }
        break;

    case SW_FORCEMINIMIZE:
        xxxMinimizeHungWindow(pwnd);
        return fVisOld;

    case SW_SHOWMINNOACTIVE:
    case SW_SHOWMINIMIZED:
    case SW_SHOWMAXIMIZED:
    case SW_MINIMIZE:
        xxxMinMaximize(pwnd, (UINT)cmdShow, cmdShowAnimate & MINMAX_ANIMATE);
        return fVisOld;

    case SW_SHOWNA:
        swpFlags |= SWP_SHOWWINDOW | SWP_NOACTIVATE;


        /*
         * LATER removed this to be compatible with SHOWNOACTIVATE
         * if (pti->pq->spwndActive != NULL)
         *     swpFlags |= SWP_NOACTIVATE;
         */
        break;

    case SW_SHOW:

        /*
         * Don't bother if it is already visible.
         */
        if (fVisOld)
            return fVisOld;

        swpFlags |= SWP_SHOWWINDOW;
        UserAssert(cmdShow != SW_SHOWNOACTIVATE);
        break;

    case SW_HIDE:

        /*
         * Don't bother if it is already hidden.
         */
        if (!fVisOld)
            return fVisOld;

        swpFlags |= SWP_HIDEWINDOW;
        if (pwnd != pti->pq->spwndActive)
            swpFlags |= (SWP_NOACTIVATE | SWP_NOZORDER);
        break;

    default:
        RIPERR0(ERROR_INVALID_SHOWWIN_COMMAND, RIP_VERBOSE, "");
        return fVisOld;
    }

    /*
     * If we're changing from visible to hidden or vise-versa, send
     * WM_SHOWWINDOW.
     */
    fVisNew = !(cmdShow == SW_HIDE);
    if (fVisNew != fVisOld) {
        xxxSendMessage(pwnd, WM_SHOWWINDOW, fVisNew, 0L);
        if (!TestWF(pwnd, WFWIN31COMPAT)) {
            xxxSendMessage(pwnd, WM_SETVISIBLE, fVisNew, 0L);
        }
    }

    if (!TestwndChild(pwnd)) {
        if (TestCF(pwnd, CFSAVEBITS)) {

            /*
             * Activate to prevent discarding saved bits???
             */
            if (cmdShow == SW_SHOW || cmdShow == SW_SHOWNORMAL) {
                xxxActivateWindow(pwnd, AW_USE);
                swpFlags |= SWP_NOZORDER | SWP_NOACTIVATE;
            }
        }
    } else {

        /*
         * Children can't get activation...
         */
        swpFlags |= (SWP_NOACTIVATE | SWP_NOZORDER);
    }

    /*
     * If our parent is hidden, don't bother to call xxxSetWindowPos.
     */
    if (_FChildVisible(pwnd)) {
        xxxSetWindowPos(pwnd, (PWND)NULL, 0, 0, 0, 0, swpFlags);
    } else {
        if (cmdShow == SW_HIDE) {
            SetVisible(pwnd, SV_UNSET);
            ClrWF(pwnd, WEFGHOSTMAKEVISIBLE);
        }    
        else {
            SetVisible(pwnd, SV_SET);
            SetWF(pwnd, WEFGHOSTMAKEVISIBLE);
        }     
    }

    /*
     * Send size and move messages AFTER repainting
     */
    if (TestWF(pwnd, WFSENDSIZEMOVE)) {
        ClrWF(pwnd, WFSENDSIZEMOVE);
        if (TestWF(pwnd, WFMINIMIZED)) {
            xxxSendSizeMessage(pwnd, SIZE_MINIMIZED);
        } else if (TestWF(pwnd, WFMAXIMIZED)) {
            xxxSendSizeMessage(pwnd, SIZE_MAXIMIZED);
        } else {
            xxxSendSizeMessage(pwnd, SIZE_RESTORED);
        }

        xxxSendMessage(pwnd, WM_MOVE, 0,
                (pwnd->spwndParent == PWNDDESKTOP(pwnd)) ?
                MAKELONG(pwnd->rcClient.left, pwnd->rcClient.top) :
                MAKELONG(
                    pwnd->rcClient.left - pwnd->spwndParent->rcClient.left,
                    pwnd->rcClient.top - pwnd->spwndParent->rcClient. top));
    }

    /*
     * If hiding and is active-foreground window, activate someone else.
     * If hiding a active window make someone active.
     */
    if (cmdShow == SW_HIDE) {
        if ((pwnd == pti->pq->spwndActive) && (pti->pq == gpqForeground)) {
            xxxActivateWindow(pwnd, AW_SKIP);
        } else {
            xxxCheckFocus(pwnd);
        }
    }

    return fVisOld;
}

/***************************************************************************\
* xxxShowOwnedWindows
*
* xxxShowOwnedWindows is used to hide or show associated popups for the
* following reasons:
*
*     1. Window going iconic
*     2. Popup window being hidden
*     3. Iconic window being opened
*     4. Popup window being shown
*     5. Window being zoomed or unzoomed
*
* For cases 1 and 2, all popups associated with that window are hidden,
* and the WFHIDDENPOPUP bit is set.  This bit is used to differentiate
* between windows hidded by xxxShowOwnedWindows and those hidden by the
* application.
*
* For cases 3 and 4, all popups associated with that window that have the
* WFHIDDENPOPUP bit set are shown.
*
* For case 5, all popups associated with any window BUT the supplied
* window are hidden or shown.  In this case as well, the SW_OTHERZOOM
* or SW_OTHERUNZOOM message is send to all tiled windows to notify them
* that they are being covered or uncovered by the zoomed window.
*
* In all cases, the WM_SHOWWINDOW message is sent to the window to hide or
* show it.
*
* This routine works by simply enumerating all popup windows checking to see
* if the owner of the popup matches the pwndOwner parameter, and taking the
* appropriate action.
*
* We will eventually want 3 separate hide bits: one each for other zoom/unzoom,
* owner iconic/open, owner hide/show.  Right now, there is only one bit, so
* we show windows sometimes when we shouldn't
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

void xxxShowOwnedWindows(
    PWND pwndOwner,
    UINT cmdShow,
    HRGN hrgnHung)
{
    BOOL fShow;
    int cmdZoom;
    HWND *phwnd;
    PBWL pbwl;
    PWND pwnd, pwndTopOwner;
    TL tlpwnd;

    CheckLock(pwndOwner);

    /*
     * Not interested in child windows
     */
    if (TestwndChild(pwndOwner))
        return;

    if ((pbwl = BuildHwndList(PWNDDESKTOP(pwndOwner)->spwndChild, BWL_ENUMLIST, NULL)) == NULL)
        return;

    /*
     * NOTE: The following code assumes the values of SW_* are 1, 2, 3, and 4
     */
    fShow = (cmdShow >= SW_PARENTOPENING);

    cmdZoom = 0;
    if (cmdShow == SW_OTHERZOOM)
        cmdZoom = SIZEZOOMHIDE;

    if (cmdShow == SW_OTHERUNZOOM)
        cmdZoom = SIZEZOOMSHOW;

    /*
     * If zoom/unzoom, then open/close all popups owned by all other
     * windows.  Otherwise, open/close popups owned by pwndOwner.
     */
    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        /*
         * Lock the window before we play with it.
         * If the window handle is invalid, skip it
         */
        if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        /*
         * Kanji windows can't be owned, so skip it.
         */
        if (TestCF(pwnd, CFKANJIWINDOW))
            continue;

        /*
         * If same as window passed in, skip it.
         */
        if (pwnd == pwndOwner)
            continue;

        /*
         * Find ultimate owner of popup, but only go up as far as pwndOwner.
         */
        if ((pwndTopOwner = pwnd->spwndOwner) != NULL) {

            /*
             * The TestwndHI is needed since if it has an icon, pwndOwner
             * is invalid.
             */
            while (!TestwndHI(pwndTopOwner) && pwndTopOwner != pwndOwner &&
                    pwndTopOwner->spwndOwner != NULL)
                pwndTopOwner = pwndTopOwner->spwndOwner;
        }

        /*
         * Zoom/Unzoom case.
         */
        if (cmdZoom != 0) {

            /*
             * If no parent, or parents are the same, skip.
             */
            if (pwndTopOwner == NULL || pwndTopOwner == pwndOwner)
                continue;

            /*
             * If owner is iconic, then this window should stay hidden,
             * UNLESS the minimized window is disabled, in which case we'd
             * better show the window.
             */
            if (   cmdShow == SW_OTHERUNZOOM
                && pwndTopOwner != NULL
                && TestWF(pwndTopOwner, WFMINIMIZED)
                && !TestWF(pwndTopOwner, WFDISABLED)
               )
                continue;
        } else {
            /*
             * Hide/Iconize/Show/Open case.
             */
            /*
             * If parents aren't the same, skip.
             */
            if (pwndTopOwner != pwndOwner)
                continue;
        }

        /*
         * Hide or show if:
         * Showing & this is a hidden popup
         *   OR
         * Hiding & this is a visible window
         */
        if ((fShow && TestWF(pwnd, WFHIDDENPOPUP)) ||
                (!fShow && TestWF(pwnd, WFVISIBLE))) {
            /*
             * For hung minimization, just set the HIDDENPOPUP bit, clear
             * the visible bit and add the window rect to the region to
             * be repainted.
             */
            if (hrgnHung != NULL) {
                HRGN hrgn = GreCreateRectRgnIndirect(&pwnd->rcWindow);
                UnionRgn(hrgnHung, hrgnHung, hrgn);
                GreDeleteObject(hrgn);

                UserAssert(!fShow);

                SetWF(pwnd, WFHIDDENPOPUP);
                SetVisible(pwnd, SV_UNSET);
            } else {
                ThreadLockAlways(pwnd, &tlpwnd);
                xxxSendMessage(pwnd, WM_SHOWWINDOW, fShow, (LONG)cmdShow);
                ThreadUnlock(&tlpwnd);
            }
        }
    }

    /*
     * Free the window list.
     */
    FreeHwndList(pbwl);
}


/***************************************************************************\
* xxxShowOwnedPopups (API)
*
* This routine is accessable to the user.  It will either show or
* hide all popup windows owned by the window handle specified.  If
* fShow if TRUE, all hidden popups will be shown.  If it is FALSE, all
* visible popups will be hidden.
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

BOOL xxxShowOwnedPopups(
    PWND pwndOwner,
    BOOL fShow)
{
    CheckLock(pwndOwner);

    xxxShowOwnedWindows(pwndOwner,
            (UINT)(fShow ? SW_PARENTOPENING : SW_PARENTCLOSING), NULL);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\sirens.c ===
/****************************** Module Header ******************************\
* Module Name: sirens.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the functions used by the Access Pack features to
* provide audible feedback.
*
* History:
*   4 Feb 93 Gregoryw   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define TONE_HIGH_FREQ 2000   // High tone frequency (Hz)
#define TONE_HIGH_LEN 75      // High tone duration (ms)
#define TONE_LOW_FREQ 500     // Low tone frequency (Hz)
#define TONE_LOW_LEN 75       // Low tone duration (ms)
#define TONE_CLICK_FREQ 400   // Key click tone frequency (Hz)
#define TONE_CLICK_LEN 4      // Key click tone duration (ms)
#define TONE_SILENT 10
#define SIREN_LOW_FREQ 1200   // Lowest freq for siren (Hz)
#define SIREN_HIGH_FREQ 2000  // Highest freq for siren (Hz)
#define SIREN_INTERVAL 100    // +/- interval SIREN_LOW_FREQ <-> SIREN_HIGH_FREQ

/***************************************************************************\
* HighBeep
*
* Send a high beep to the beep device
*
* History:
\***************************************************************************/

BOOL HighBeep(void)
{
    BOOL Status;

    LeaveCrit();
    Status = UserBeep(TONE_HIGH_FREQ, TONE_HIGH_LEN);
    EnterCrit();
    return Status;
}

/***************************************************************************\
* LowBeep
*
* Send a low beep to the beep device
*
* History:
\***************************************************************************/

BOOL LowBeep(void)
{
    BOOL Status;

    LeaveCrit();
    Status = UserBeep(TONE_LOW_FREQ, TONE_LOW_LEN);
    EnterCrit();
    return Status;
}

/***************************************************************************\
* KeyClick
*
* Send a key click to the beep device
*
* History:
\***************************************************************************/

BOOL KeyClick(void)
{
    BOOL Status;

    LeaveCrit();
    Status = UserBeep(TONE_CLICK_FREQ, TONE_CLICK_LEN);
    EnterCrit();
    return Status;
}

/***************************************************************************\
* UpSiren
*
* Generate an up-siren tone.
*
* History:
\***************************************************************************/

BOOL UpSiren(void)
{
    DWORD freq;
    BOOL BeepStatus = TRUE;

    LeaveCrit();
    for (freq = SIREN_LOW_FREQ;
        BeepStatus && freq <= SIREN_HIGH_FREQ;
            freq += SIREN_INTERVAL) {
        BeepStatus = UserBeep(freq, (DWORD)1);
    }
    EnterCrit();
    return BeepStatus;
}

/***************************************************************************\
* DownSiren
*
* Generate a down-siren tone.
*
* History:
\***************************************************************************/

BOOL DownSiren(void)
{
    DWORD freq;
    BOOL BeepStatus = TRUE;

    LeaveCrit();

    for (freq = SIREN_HIGH_FREQ;
        BeepStatus && freq >= SIREN_LOW_FREQ;
            freq -= SIREN_INTERVAL) {
        BeepStatus = UserBeep(freq, (DWORD)1);
    }
    EnterCrit();
    return BeepStatus;
}

BOOL DoBeep(BEEPPROC BeepProc, UINT Count)
{
    while (Count--) {
        (*BeepProc)();
        UserSleep(100);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\server.c ===
/**************************************************************************\
* Module Name: server.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Server support routines for the CSR stuff. This basically performs the
* startup/initialization for USER.
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "prefetch.h"

extern WORD gDispatchTableValues;

BOOL gbUserInitialized;

/*
 * Initialization Routines (external).
 */
NTSTATUS     InitQEntryLookaside(VOID);
NTSTATUS     InitSMSLookaside(VOID);

NTSTATUS    InitCreateSharedSection(VOID);
NTSTATUS    InitCreateObjectDirectory(VOID);
BOOL        InitCreateUserSubsystem(VOID);
VOID        InitFunctionTables(VOID);
VOID        InitMessageTables(VOID);
VOID        InitWindowMsgTable(PBYTE*, PUINT, CONST WORD*);

VOID        VerifySyncOnlyMessages(VOID);
BOOL        InitOLEFormats(VOID);
NTSTATUS    Win32UserInitialize(VOID);

#pragma alloc_text(INIT, InitCreateSharedSection)
#pragma alloc_text(INIT, InitCreateUserCrit)
#pragma alloc_text(INIT, InitCreateObjectDirectory)
#pragma alloc_text(INIT, InitCreateUserSubsystem)
#pragma alloc_text(INIT, InitFunctionTables)
#pragma alloc_text(INIT, InitMessageTables)
#pragma alloc_text(INIT, InitWindowMsgTable)

#pragma alloc_text(INIT, VerifySyncOnlyMessages)
#pragma alloc_text(INIT, InitOLEFormats)
#pragma alloc_text(INIT, Win32UserInitialize)

/*
 * Constants pertaining to the user-initialization.
 */
#define USRINIT_SHAREDSECT_SIZE   32
#define USRINIT_ATOMBUCKET_SIZE   37

#define USRINIT_WINDOWSECT_SIZE  512
#define USRINIT_NOIOSECT_SIZE    128

#define USRINIT_SHAREDSECT_BUFF_SIZE     640
#define USRINIT_SHAREDSECT_READ_SIZE     (USRINIT_SHAREDSECT_BUFF_SIZE-33)


/***************************************************************************\
* Globals stored in the INIT section. These should only be accessed at
* load time!
\***************************************************************************/
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT$Data")
#endif

CONST WCHAR szCHECKPOINT_PROP_NAME[]  = L"SysCP";
CONST WCHAR szDDETRACK_PROP_NAME[]    = L"SysDT";
CONST WCHAR szQOS_PROP_NAME[]         = L"SysQOS";
CONST WCHAR szDDEIMP_PROP_NAME[]      = L"SysDDEI";
CONST WCHAR szWNDOBJ_PROP_NAME[]      = L"SysWNDO";
CONST WCHAR szIMELEVEL_PROP_NAME[]    = L"SysIMEL";
CONST WCHAR szLAYER_PROP_NAME[]       = L"SysLayer";
CONST WCHAR szUSER32[]                = L"USER32";
CONST WCHAR szCONTEXTHELPIDPROP[]     = L"SysCH";
CONST WCHAR szICONSM_PROP_NAME[]      = L"SysICS";
CONST WCHAR szICON_PROP_NAME[]        = ICON_PROP_NAME;
CONST WCHAR szSHELLHOOK[]             = L"SHELLHOOK";
CONST WCHAR szACTIVATESHELLWINDOW[]   = L"ACTIVATESHELLWINDOW";
CONST WCHAR szOTHERWINDOWCREATED[]    = L"OTHERWINDOWCREATED";
CONST WCHAR szOTHERWINDOWDESTROYED[]  = L"OTHERWINDOWDESTROYED";
CONST WCHAR szOLEMAINTHREADWNDCLASS[] = L"OleMainThreadWndClass";
CONST WCHAR szFLASHWSTATE[]           = L"FlashWState";

#ifdef HUNGAPP_GHOSTING
CONST WCHAR szGHOST[]                 = L"Ghost";
#endif

CONST WCHAR szSHADOW[]                = L"SysShadow";

/***************************************************************************\
* Message Tables
*
*   DefDlgProc
*   MenuWndProc
*   ScrollBarWndProc
*   StaticWndProc
*   ButtonWndProc
*   ListboxWndProc
*   ComboWndProc
*   EditWndProc
*   DefWindowMsgs
*   DefWindowSpecMsgs
*
* These are used in InitMessageTables() to initialize gSharedInfo.awmControl[]
* using the INITMSGTABLE() macro.
*
* 25-Aug-1995 ChrisWil  Created comment block.
\***************************************************************************/

CONST WORD gawDefDlgProc[] = {
    WM_COMPAREITEM,
    WM_VKEYTOITEM,
    WM_CHARTOITEM,
    WM_INITDIALOG,
    WM_QUERYDRAGICON,
    WM_CTLCOLOR,
    WM_CTLCOLORMSGBOX,
    WM_CTLCOLOREDIT,
    WM_CTLCOLORLISTBOX,
    WM_CTLCOLORBTN,
    WM_CTLCOLORDLG,
    WM_CTLCOLORSCROLLBAR,
    WM_CTLCOLORSTATIC,
    WM_ERASEBKGND,
    WM_SHOWWINDOW,
    WM_SYSCOMMAND,
    WM_SYSKEYDOWN,
    WM_ACTIVATE,
    WM_SETFOCUS,
    WM_CLOSE,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    DM_REPOSITION,
    DM_SETDEFID,
    DM_GETDEFID,
    WM_NEXTDLGCTL,
    WM_ENTERMENULOOP,
    WM_LBUTTONDOWN,
    WM_NCLBUTTONDOWN,
    WM_GETFONT,
    WM_NOTIFYFORMAT,
    WM_INPUTLANGCHANGEREQUEST,
    0
};

CONST WORD gawMenuWndProc[] = {
    WM_NCCREATE,
    WM_FINALDESTROY,
    WM_PAINT,
    WM_NCCALCSIZE,
    WM_CHAR,
    WM_SYSCHAR,
    WM_KEYDOWN,
    WM_SYSKEYDOWN,
    WM_TIMER,
    MN_SETHMENU,
    MN_SIZEWINDOW,
    MN_OPENHIERARCHY,
    MN_CLOSEHIERARCHY,
    MN_SELECTITEM,
    MN_SELECTFIRSTVALIDITEM,
    MN_CANCELMENUS,
    MN_FINDMENUWINDOWFROMPOINT,
    MN_SHOWPOPUPWINDOW,
    MN_BUTTONDOWN,
    MN_MOUSEMOVE,
    MN_BUTTONUP,
    MN_SETTIMERTOOPENHIERARCHY,
    WM_ACTIVATE,
    MN_GETHMENU,
    MN_DBLCLK,
    MN_ACTIVATEPOPUP,
    MN_ENDMENU,
    MN_DODRAGDROP,
    WM_ACTIVATEAPP,
    WM_MOUSELEAVE,
    WM_SIZE,
    WM_MOVE,
    WM_NCHITTEST,
    WM_NCPAINT,
    WM_PRINT,
    WM_PRINTCLIENT,
    WM_ERASEBKGND,
    WM_WINDOWPOSCHANGING,
    WM_WINDOWPOSCHANGED,
    0
};

CONST WORD gawDesktopWndProc[] = {
    WM_PAINT,
    WM_ERASEBKGND,
    0
};

CONST WORD gawScrollBarWndProc[] = {
    WM_CREATE,
    WM_SETFOCUS,
    WM_KILLFOCUS,
    WM_ERASEBKGND,
    WM_PAINT,
    WM_LBUTTONDBLCLK,
    WM_LBUTTONDOWN,
    WM_KEYUP,
    WM_KEYDOWN,
    WM_ENABLE,
    SBM_ENABLE_ARROWS,
    SBM_SETPOS,
    SBM_SETRANGEREDRAW,
    SBM_SETRANGE,
    SBM_SETSCROLLINFO,
    SBM_GETSCROLLINFO,
    SBM_GETSCROLLBARINFO,
    WM_PRINTCLIENT,
    WM_MOUSEMOVE,
    WM_MOUSELEAVE,
    0
};

CONST WORD gawStaticWndProc[] = {
    STM_GETICON,
    STM_GETIMAGE,
    STM_SETICON,
    STM_SETIMAGE,
    WM_ERASEBKGND,
    WM_PAINT,
    WM_PRINTCLIENT,
    WM_CREATE,
    WM_DESTROY,
    WM_NCCREATE,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    WM_NCHITTEST,
    WM_LBUTTONDOWN,
    WM_NCLBUTTONDOWN,
    WM_LBUTTONDBLCLK,
    WM_NCLBUTTONDBLCLK,
    WM_SETTEXT,
    WM_ENABLE,
    WM_GETDLGCODE,
    WM_SETFONT,
    WM_GETFONT,
    WM_GETTEXT,
    WM_TIMER,
    WM_INPUTLANGCHANGEREQUEST,
    WM_UPDATEUISTATE,
    0
};

CONST WORD gawButtonWndProc[] = {
    WM_NCHITTEST,
    WM_ERASEBKGND,
    WM_PRINTCLIENT,
    WM_PAINT,
    WM_SETFOCUS,
    WM_GETDLGCODE,
    WM_CAPTURECHANGED,
    WM_KILLFOCUS,
    WM_LBUTTONDBLCLK,
    WM_LBUTTONUP,
    WM_MOUSEMOVE,
    WM_LBUTTONDOWN,
    WM_CHAR,
    BM_CLICK,
    WM_KEYDOWN,
    WM_KEYUP,
    WM_SYSKEYUP,
    BM_GETSTATE,
    BM_SETSTATE,
    BM_GETCHECK,
    BM_SETCHECK,
    BM_SETSTYLE,
    WM_SETTEXT,
    WM_ENABLE,
    WM_SETFONT,
    WM_GETFONT,
    BM_GETIMAGE,
    BM_SETIMAGE,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    WM_NCCREATE,
    WM_INPUTLANGCHANGEREQUEST,
    WM_UPDATEUISTATE,
    0
};

CONST WORD gawListboxWndProc[] = {
    LB_GETTOPINDEX,
    LB_SETTOPINDEX,
    WM_SIZE,
    WM_ERASEBKGND,
    LB_RESETCONTENT,
    WM_TIMER,
    WM_MOUSEMOVE,
    WM_MBUTTONDOWN,
    WM_LBUTTONDOWN,
    WM_LBUTTONUP,
    WM_LBUTTONDBLCLK,
    WM_CAPTURECHANGED,
    LBCB_STARTTRACK,
    LBCB_ENDTRACK,
    WM_PRINTCLIENT,
    WM_PAINT,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    WM_SETFOCUS,
    WM_KILLFOCUS,
    WM_VSCROLL,
    WM_HSCROLL,
    WM_GETDLGCODE,
    WM_CREATE,
    WM_SETREDRAW,
    WM_ENABLE,
    WM_SETFONT,
    WM_GETFONT,
    WM_DRAGSELECT,
    WM_DRAGLOOP,
    WM_DRAGMOVE,
    WM_DROPFILES,
    WM_QUERYDROPOBJECT,
    WM_DROPOBJECT,
    LB_GETITEMRECT,
    LB_GETITEMDATA,
    LB_SETITEMDATA,
    LB_ADDSTRINGUPPER,
    LB_ADDSTRINGLOWER,
    LB_ADDSTRING,
    LB_INSERTSTRINGUPPER,
    LB_INSERTSTRINGLOWER,
    LB_INSERTSTRING,
    LB_INITSTORAGE,
    LB_DELETESTRING,
    LB_DIR,
    LB_ADDFILE,
    LB_SETSEL,
    LB_SETCURSEL,
    LB_GETSEL,
    LB_GETCURSEL,
    LB_SELITEMRANGE,
    LB_SELITEMRANGEEX,
    LB_GETTEXTLEN,
    LB_GETTEXT,
    LB_GETCOUNT,
    LB_SETCOUNT,
    LB_SELECTSTRING,
    LB_FINDSTRING,
    LB_GETLOCALE,
    LB_SETLOCALE,
    WM_KEYDOWN,
    WM_CHAR,
    LB_GETSELITEMS,
    LB_GETSELCOUNT,
    LB_SETTABSTOPS,
    LB_GETHORIZONTALEXTENT,
    LB_SETHORIZONTALEXTENT,
    LB_SETCOLUMNWIDTH,
    LB_SETANCHORINDEX,
    LB_GETANCHORINDEX,
    LB_SETCARETINDEX,
    LB_GETCARETINDEX,
    LB_SETITEMHEIGHT,
    LB_GETITEMHEIGHT,
    LB_FINDSTRINGEXACT,
    LB_ITEMFROMPOINT,
    LB_SETLOCALE,
    LB_GETLOCALE,
    LBCB_CARETON,
    LBCB_CARETOFF,
    LB_GETLISTBOXINFO,
    WM_NCCREATE,
    WM_WINDOWPOSCHANGED,
    WM_MOUSEWHEEL,
    WM_STYLECHANGED,
    WM_STYLECHANGING,
    0
};

CONST WORD gawComboWndProc[] = {
    CBEC_KILLCOMBOFOCUS,
    WM_COMMAND,
    WM_CTLCOLORMSGBOX,
    WM_CTLCOLOREDIT,
    WM_CTLCOLORLISTBOX,
    WM_CTLCOLORBTN,
    WM_CTLCOLORDLG,
    WM_CTLCOLORSCROLLBAR,
    WM_CTLCOLORSTATIC,
    WM_CTLCOLOR,
    WM_GETTEXT,
    WM_GETTEXTLENGTH,
    WM_CLEAR,
    WM_CUT,
    WM_PASTE,
    WM_COPY,
    WM_SETTEXT,
    WM_CREATE,
    WM_ERASEBKGND,
    WM_GETFONT,
    WM_PRINT,
    WM_PRINTCLIENT,
    WM_PAINT,
    WM_GETDLGCODE,
    WM_SETFONT,
    WM_SYSKEYDOWN,
    WM_KEYDOWN,
    WM_CHAR,
    WM_LBUTTONDBLCLK,
    WM_LBUTTONDOWN,
    WM_CAPTURECHANGED,
    WM_LBUTTONUP,
    WM_MOUSEMOVE,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    WM_SETFOCUS,
    WM_KILLFOCUS,
    WM_SETREDRAW,
    WM_ENABLE,
    WM_SIZE,
    CB_GETDROPPEDSTATE,
    CB_GETDROPPEDCONTROLRECT,
    CB_SETDROPPEDWIDTH,
    CB_GETDROPPEDWIDTH,
    CB_DIR,
    CB_SETEXTENDEDUI,
    CB_GETEXTENDEDUI,
    CB_GETEDITSEL,
    CB_LIMITTEXT,
    CB_SETEDITSEL,
    CB_ADDSTRING,
    CB_DELETESTRING,
    CB_INITSTORAGE,
    CB_SETTOPINDEX,
    CB_GETTOPINDEX,
    CB_GETCOUNT,
    CB_GETCURSEL,
    CB_GETLBTEXT,
    CB_GETLBTEXTLEN,
    CB_INSERTSTRING,
    CB_RESETCONTENT,
    CB_GETHORIZONTALEXTENT,
    CB_SETHORIZONTALEXTENT,
    CB_FINDSTRING,
    CB_FINDSTRINGEXACT,
    CB_SELECTSTRING,
    CB_SETCURSEL,
    CB_GETITEMDATA,
    CB_SETITEMDATA,
    CB_SETITEMHEIGHT,
    CB_GETITEMHEIGHT,
    CB_SHOWDROPDOWN,
    CB_SETLOCALE,
    CB_GETLOCALE,
    CB_GETCOMBOBOXINFO,
    WM_MEASUREITEM,
    WM_DELETEITEM,
    WM_DRAWITEM,
    WM_COMPAREITEM,
    WM_NCCREATE,
    WM_HELP,
    WM_MOUSEWHEEL,
    WM_MOUSELEAVE,
    WM_STYLECHANGED,
    WM_STYLECHANGING,
    WM_UPDATEUISTATE,
    0
};

CONST WORD gawEditWndProc[] = {
    EM_CANUNDO,
    EM_CHARFROMPOS,
    EM_EMPTYUNDOBUFFER,
    EM_FMTLINES,
    EM_GETFIRSTVISIBLELINE,
    EM_GETFIRSTVISIBLELINE,
    EM_GETHANDLE,
    EM_GETLIMITTEXT,
    EM_GETLINE,
    EM_GETLINECOUNT,
    EM_GETMARGINS,
    EM_GETMODIFY,
    EM_GETPASSWORDCHAR,
    EM_GETRECT,
    EM_GETSEL,
    EM_GETWORDBREAKPROC,
    EM_SETIMESTATUS,
    EM_GETIMESTATUS,
    EM_LINEFROMCHAR,
    EM_LINEINDEX,
    EM_LINELENGTH,
    EM_LINESCROLL,
    EM_POSFROMCHAR,
    EM_REPLACESEL,
    EM_SCROLL,
    EM_SCROLLCARET,
    EM_SETHANDLE,
    EM_SETLIMITTEXT,
    EM_SETMARGINS,
    EM_SETMODIFY,
    EM_SETPASSWORDCHAR,
    EM_SETREADONLY,
    EM_SETRECT,
    EM_SETRECTNP,
    EM_SETSEL,
    EM_SETTABSTOPS,
    EM_SETWORDBREAKPROC,
    EM_UNDO,
    WM_CAPTURECHANGED,
    WM_CHAR,
    WM_CLEAR,
    WM_CONTEXTMENU,
    WM_COPY,
    WM_CREATE,
    WM_CUT,
    WM_ENABLE,
    WM_ERASEBKGND,
    WM_GETDLGCODE,
    WM_GETFONT,
    WM_GETTEXT,
    WM_GETTEXTLENGTH,
    WM_HSCROLL,
    WM_IME_STARTCOMPOSITION,
    WM_IME_ENDCOMPOSITION,
    WM_IME_COMPOSITION,
    WM_IME_SETCONTEXT,
    WM_IME_NOTIFY,
    WM_IME_COMPOSITIONFULL,
    WM_IME_SELECT,
    WM_IME_CHAR,
    WM_IME_REQUEST,
    WM_INPUTLANGCHANGE,
    WM_KEYUP,
    WM_KEYDOWN,
    WM_KILLFOCUS,
    WM_MBUTTONDOWN,
    WM_LBUTTONDBLCLK,
    WM_LBUTTONDOWN,
    WM_LBUTTONUP,
    WM_MOUSEMOVE,
    WM_NCCREATE,
    WM_NCDESTROY,
    WM_RBUTTONDOWN,
    WM_RBUTTONUP,
    WM_FINALDESTROY,
    WM_PAINT,
    WM_PASTE,
    WM_PRINTCLIENT,
    WM_SETFOCUS,
    WM_SETFONT,
    WM_SETREDRAW,
    WM_SETTEXT,
    WM_SIZE,
    WM_STYLECHANGED,
    WM_STYLECHANGING,
    WM_SYSCHAR,
    WM_SYSKEYDOWN,
    WM_SYSTIMER,
    WM_UNDO,
    WM_VSCROLL,
    WM_MOUSEWHEEL,
    0
};

CONST WORD gawImeWndProc[] = {
    WM_ERASEBKGND,
    WM_PAINT,
    WM_DESTROY,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    WM_CREATE,
    WM_IME_SYSTEM,
    WM_IME_SELECT,
    WM_IME_CONTROL,
    WM_IME_SETCONTEXT,
    WM_IME_NOTIFY,
    WM_IME_COMPOSITION,
    WM_IME_STARTCOMPOSITION,
    WM_IME_ENDCOMPOSITION,
    WM_IME_REQUEST,
    WM_COPYDATA,
    0
};

/*
 * This array is for all the messages that need to be passed straight
 * across to the server for handling.
 */
CONST WORD gawDefWindowMsgs[] = {
    WM_GETHOTKEY,
    WM_SETHOTKEY,
    WM_SETREDRAW,
    WM_SETTEXT,
    WM_PAINT,
    WM_CLOSE,
    WM_ERASEBKGND,
    WM_CANCELMODE,
    WM_SETCURSOR,
    WM_PAINTICON,
    WM_ICONERASEBKGND,
    WM_DRAWITEM,
    WM_KEYF1,
    WM_ISACTIVEICON,
    WM_NCCREATE,
    WM_SETICON,
    WM_NCCALCSIZE,
    WM_NCPAINT,
    WM_NCACTIVATE,
    WM_NCMOUSEMOVE,
    WM_NCRBUTTONUP,
    WM_NCRBUTTONDOWN,
#ifndef LAME_BUTTON
    WM_NCLBUTTONDOWN,
#endif
    WM_NCLBUTTONUP,
    WM_NCLBUTTONDBLCLK,
    WM_KEYUP,
    WM_SYSKEYUP,
#ifndef LAME_BUTTON
    WM_SYSCHAR,
    WM_SYSCOMMAND,
#endif
    WM_QUERYDROPOBJECT,
    WM_CLIENTSHUTDOWN,
    WM_SYNCPAINT,
    WM_PRINT,
    WM_GETICON,
    WM_CONTEXTMENU,
    WM_SYSMENU,
    WM_INPUTLANGCHANGEREQUEST,
    WM_INPUTLANGCHANGE,
    WM_UPDATEUISTATE,
    WM_NCUAHDRAWCAPTION,
    WM_NCUAHDRAWFRAME,
    WM_UAHINIT,
    0
};

/*
 * This array is for all messages that can be handled with some special
 * code by the client. DefWindowProcWorker returns 0 for all messages
 * that aren't in this array or the one above.
 */
CONST WORD gawDefWindowSpecMsgs[] = {
    WM_ACTIVATE,
    WM_GETTEXT,
    WM_GETTEXTLENGTH,
    WM_RBUTTONUP,
    WM_QUERYENDSESSION,
    WM_QUERYOPEN,
    WM_SHOWWINDOW,
    WM_MOUSEACTIVATE,
    WM_HELP,
    WM_VKEYTOITEM,
    WM_CHARTOITEM,
    WM_KEYDOWN,
#ifdef LAME_BUTTON
    WM_SYSCOMMAND,
    WM_SYSCHAR,
#endif
    WM_SYSKEYDOWN,
    WM_UNICHAR,
    WM_DROPOBJECT,
    WM_WINDOWPOSCHANGING,
    WM_WINDOWPOSCHANGED,
    WM_KLUDGEMINRECT,
    WM_CTLCOLOR,
    WM_CTLCOLORMSGBOX,
    WM_CTLCOLOREDIT,
    WM_CTLCOLORLISTBOX,
    WM_CTLCOLORBTN,
    WM_CTLCOLORDLG,
    WM_CTLCOLORSCROLLBAR,
    WM_NCHITTEST,
#ifdef LAME_BUTTON
    WM_NCLBUTTONDOWN,
#endif
    WM_NCXBUTTONUP,
    WM_CTLCOLORSTATIC,
    WM_NOTIFYFORMAT,
    WM_DEVICECHANGE,
    WM_POWERBROADCAST,
    WM_MOUSEWHEEL,
    WM_XBUTTONUP,
    WM_IME_KEYDOWN,
    WM_IME_KEYUP,
    WM_IME_CHAR,
    WM_IME_COMPOSITION,
    WM_IME_STARTCOMPOSITION,
    WM_IME_ENDCOMPOSITION,
    WM_IME_COMPOSITIONFULL,
    WM_IME_SETCONTEXT,
    WM_IME_CONTROL,
    WM_IME_NOTIFY,
    WM_IME_SELECT,
    WM_IME_SYSTEM,
    WM_LPKDRAWSWITCHWND,
    WM_QUERYDRAGICON,
    WM_CHANGEUISTATE,
    WM_QUERYUISTATE,
    WM_APPCOMMAND,
    0
};

static CONST LPCWSTR lpszOLEFormats[] = {
    L"ObjectLink",
    L"OwnerLink",
    L"Native",
    L"Binary",
    L"FileName",
    L"FileNameW",
    L"NetworkName",
    L"DataObject",
    L"Embedded Object",
    L"Embed Source",
    L"Custom Link Source",
    L"Link Source",
    L"Object Descriptor",
    L"Link Source Descriptor",
    L"OleDraw",
    L"PBrush",
    L"MSDraw",
    L"Ole Private Data",
    L"Screen Picture",
    L"OleClipboardPersistOnFlush",
    L"MoreOlePrivateData"
};

static CONST LPCWSTR lpszControls[] = {
    L"Button",
    L"Edit",
    L"Static",
    L"ListBox",
    L"ScrollBar",
    L"ComboBox",
    L"MDIClient",
    L"ComboLBox",
    L"DDEMLEvent",
    L"DDEMLMom",
    L"DMGClass",
    L"DDEMLAnsiClient",
    L"DDEMLUnicodeClient",
    L"DDEMLAnsiServer",
    L"DDEMLUnicodeServer",
    L"IME",
};


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

/***************************************************************************\
* DispatchServerMessage
*
*
* 19-Aug-1992 MikeKe    Created
\***************************************************************************/

#define WRAPPFN(pfn, type)                                   \
LRESULT xxxWrap ## pfn(                                      \
    PWND  pwnd,                                              \
    UINT  message,                                           \
    WPARAM wParam,                                           \
    LPARAM lParam,                                           \
    ULONG_PTR xParam)                                        \
{                                                            \
    UNREFERENCED_PARAMETER(xParam);                          \
                                                             \
    return xxx ## pfn((type)pwnd, message, wParam, lParam);  \
}

WRAPPFN(SBWndProc, PSBWND)
WRAPPFN(MenuWindowProc, PWND)
WRAPPFN(DesktopWndProc, PWND);
WRAPPFN(RealDefWindowProc, PWND)
WRAPPFN(SwitchWndProc, PWND)

LRESULT xxxWrapSendMessageCallback(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    SNDMSGCALLBACK smcb;
    TL tlpwnd;
    LRESULT lRet = 0;
    NTSTATUS Status = STATUS_SUCCESS;


    UserAssert (xParam != 0L);

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (message & MSGFLAG_MASK) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid message");
        return 0;
    }

    /*
     * Probe all read arguments
     */
    try {
        ProbeForWrite((PVOID)xParam, sizeof(smcb), sizeof(ULONG));
        smcb = *(PSNDMSGCALLBACK)xParam;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        Status = GetExceptionCode();
    }
    if ( !NT_SUCCESS(Status) ) {
        return 0;
    }

    if (pwnd != PWND_BROADCAST)
        ThreadLockAlways(pwnd, &tlpwnd);

    lRet = (LRESULT)xxxSendMessageCallback(pwnd,
                                           message,
                                           wParam,
                                           lParam,
                                           smcb.lpResultCallBack,
                                           smcb.dwData,
                                           TRUE);
    if (pwnd != PWND_BROADCAST)
        ThreadUnlock(&tlpwnd);

    return lRet;
}

LRESULT xxxWrapSendNotifyMessage(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    TL tlpwnd;
    LRESULT lRet = 0;

    UNREFERENCED_PARAMETER(xParam);

    if (message & MSGFLAG_MASK) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid message");
        return 0;
    }

    if (pwnd != PWND_BROADCAST) {
        ThreadLockAlways(pwnd, &tlpwnd);
    }

    lRet = (LRESULT)xxxSendNotifyMessage(pwnd,
                                         message,
                                         wParam,
                                         lParam);
    if (pwnd != PWND_BROADCAST) {
        ThreadUnlock(&tlpwnd);
    }

    return lRet;
}

LRESULT xxxWrapSendMessage(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    UNREFERENCED_PARAMETER(xParam);

    return xxxSendMessageTimeout(pwnd,
                                 message,
                                 wParam,
                                 lParam,
                                 SMTO_NORMAL,
                                 0,
                                 NULL);
}

LRESULT xxxWrapSendMessageBSM(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    BROADCASTSYSTEMMSGPARAMS bsmParams;
    LRESULT lRet;

    try {
        ProbeForWriteBroadcastSystemMsgParams((LPBROADCASTSYSTEMMSGPARAMS)xParam);
        RtlCopyMemory(&bsmParams, (LPBROADCASTSYSTEMMSGPARAMS)xParam, sizeof(BROADCASTSYSTEMMSGPARAMS));
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return 0;
    }

    /*
     * If this broadcast is going to all desktops, make sure the thread has
     * sufficient privileges. Do the check here, so we don't effect kernel
     * generated broadcasts (i.e power messages).
     */
    if (bsmParams.dwRecipients & (BSM_ALLDESKTOPS)) {
        if (!IsPrivileged(&psTcb)) {
            bsmParams.dwRecipients &= ~(BSM_ALLDESKTOPS);
            try {
                RtlCopyMemory((LPBROADCASTSYSTEMMSGPARAMS)xParam, &bsmParams, sizeof(BROADCASTSYSTEMMSGPARAMS));
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                  /* empty */
            }
        }
    }

    lRet = xxxSendMessageBSM(pwnd,
                             message,
                             wParam,
                             lParam,
                             &bsmParams);
    /*
     * If our query was denied, return who denied the query.
     */
    if (lRet == 0 && (bsmParams.dwFlags & BSF_QUERY)) {
        try {
            RtlCopyMemory((LPBROADCASTSYSTEMMSGPARAMS)xParam, &bsmParams, sizeof(BROADCASTSYSTEMMSGPARAMS));
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            return 0;
        }
    }

    return lRet;
}

/***************************************************************************\
* xxxUnusedFunctionId
*
* This function is catches attempts to access invalid entries in the server
* side function dispatch table.
*
\***************************************************************************/
LRESULT xxxUnusedFunctionId(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(xParam);

    UserAssert(FALSE);
    return 0;
}

/***************************************************************************\
* xxxWrapCallWindowProc
*
* Warning should only be called with valid CallProc Handles or the
* EditWndProc special handlers.
*
*
* 21-Apr-1993 JohnC     Created
\***************************************************************************/

LRESULT xxxWrapCallWindowProc(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    PCALLPROCDATA pCPD;
    LRESULT       lRet = 0;

    if (pCPD = HMValidateHandleNoRip((PVOID)xParam, TYPE_CALLPROC)) {

        lRet = ScSendMessage(pwnd,
                              message,
                              wParam,
                              lParam,
                              pCPD->pfnClientPrevious,
                              gpsi->apfnClientW.pfnDispatchMessage,
                              (pCPD->wType & CPD_UNICODE_TO_ANSI) ?
                                      SCMS_FLAGS_ANSI : 0);

    } else {

        /*
         * If it is not a real call proc handle it must be a special
         * handler for editwndproc or regular EditWndProc
         */
        lRet = ScSendMessage(pwnd,
                              message,
                              wParam,
                              lParam,
                              xParam,
                              gpsi->apfnClientA.pfnDispatchMessage,
                              (xParam == (ULONG_PTR)gpsi->apfnClientA.pfnEditWndProc) ?
                                      SCMS_FLAGS_ANSI : 0);
    }

    return lRet;
}

#if DBG
VOID VerifySyncOnlyMessages(VOID)
{
    int i;

    TRACE_INIT(("UserInit: Verify Sync Only Messages\n"));

    /*
     * There are a couple of thunks that just pass parameters. There are other
     * thunks besides SfnDWORD that do a straight pass through because they
     * do other processing beside the wparam and lparam
     */

    /*
     * Allow posting of LB_DIR and CB_DIR because DlgDirList allows a DDL_POSTMSGS
     * flag that makes the API post the messages. This should be OK as long as we
     * don't handle these messages in the kernel. NT 3.51 allowed posting these.
     */
    for (i=0; i<WM_USER; i++) {
        if (    i != LB_DIR
                && i != CB_DIR
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnDWORD)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnNCDESTROY)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnINWPARAMCHAR)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnINWPARAMDBCSCHAR)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnSENTDDEMSG)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnPOWERBROADCAST)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnLOGONNOTIFY)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnINDESTROYCLIPBRD)) {
            if (!(TESTSYNCONLYMESSAGE(i,0x8000)))
                RIPMSG1(RIP_ERROR, "InitSyncOnly: is this message sync-only 0x%lX", i);
        } else {
            if (TESTSYNCONLYMESSAGE(i,0))
                RIPMSG1(RIP_VERBOSE, "InitSyncOnly: is this message not sync-only 0x%lX", i);
        }

    }
}
#endif // DBG

/***************************************************************************\
* InitWindowMsgTables
*
* This function generates a bit-array lookup table from a list of messages.
* The lookup table is used to determine whether the message needs to be
* passed over to the server for handling or whether it can be handled
* directly on the client.
*
* LATER: Some memory (a couple hundred bytes per process) could be saved
*        by putting this in the shared read-only heap.
*
*
* 27-Mar-1992 DarrinM   Created.
* 06-Dec-1993 MikeKe    Added support for all of our window procs.
\***************************************************************************/
VOID InitWindowMsgTable(
    PBYTE      *ppbyte,
    PUINT      pmax,
    CONST WORD *pw)
{
    UINT i;
    WORD msg;
    UINT cbTable;

    *pmax = 0;
    for (i = 0; (msg = pw[i]) != 0; i++) {
        if (msg > *pmax)
            *pmax = msg;
    }

    cbTable = *pmax / 8 + 1;
    *ppbyte = SharedAlloc(cbTable);
    if (*ppbyte == NULL) {
        return;
    }

    for (i = 0; (msg = pw[i]) != 0; i++) {
        (*ppbyte)[msg / 8] |= (BYTE)(1 << (msg & 7));
    }
}

/***************************************************************************\
* InitFunctionTables
*
* Initialize the procedures and function tables.
*
*
* 25-Aug-1995 ChrisWil  Created comment block.
\***************************************************************************/
VOID InitFunctionTables(
    VOID)
{
    UINT i;

    TRACE_INIT(("UserInit: Initialize Function Tables\n"));

    UserAssert(sizeof(CLIENTINFO) <= sizeof(NtCurrentTeb()->Win32ClientInfo));

    /*
     * This table is used to convert from server procs to client procs.
     */
    STOCID(FNID_SCROLLBAR)              = (WNDPROC_PWND)xxxSBWndProc;
    STOCID(FNID_ICONTITLE)              = xxxDefWindowProc;
    STOCID(FNID_MENU)                   = xxxMenuWindowProc;
    STOCID(FNID_DESKTOP)                = xxxDesktopWndProc;
    STOCID(FNID_DEFWINDOWPROC)          = xxxDefWindowProc;
    STOCID(FNID_MESSAGEWND)             = xxxDefWindowProc;

    /*
     * This table is used to determine the number minimum number of reserved
     * windows words required for the server proc.
     */
    CBFNID(FNID_SCROLLBAR)              = sizeof(SBWND);
    CBFNID(FNID_ICONTITLE)              = sizeof(WND);
    CBFNID(FNID_MENU)                   = sizeof(MENUWND);

    /*
     * Initialize this data structure (api function table).
     */
    for (i = 0; i < FNID_ARRAY_SIZE; i++) {
        FNID((i + FNID_START)) = xxxUnusedFunctionId;
    }
    FNID(FNID_SCROLLBAR)                = xxxWrapSBWndProc;
    FNID(FNID_ICONTITLE)                = xxxWrapRealDefWindowProc;
    FNID(FNID_MENU)                     = xxxWrapMenuWindowProc;
    FNID(FNID_DESKTOP)                  = xxxWrapDesktopWndProc;
    FNID(FNID_DEFWINDOWPROC)            = xxxWrapRealDefWindowProc;
    FNID(FNID_MESSAGEWND)               = xxxWrapRealDefWindowProc;
    FNID(FNID_SENDMESSAGE)              = xxxWrapSendMessage;
    FNID(FNID_HKINLPCWPEXSTRUCT)        = fnHkINLPCWPEXSTRUCT;
    FNID(FNID_HKINLPCWPRETEXSTRUCT)     = fnHkINLPCWPRETEXSTRUCT;
    FNID(FNID_SENDMESSAGEFF)            = xxxSendMessageFF;
    FNID(FNID_SENDMESSAGEEX)            = xxxSendMessageEx;
    FNID(FNID_CALLWINDOWPROC)           = xxxWrapCallWindowProc;
    FNID(FNID_SENDMESSAGEBSM)           = xxxWrapSendMessageBSM;
    FNID(FNID_SWITCH)                   = xxxWrapSwitchWndProc;
    FNID(FNID_SENDNOTIFYMESSAGE)        = xxxWrapSendNotifyMessage;
    FNID(FNID_SENDMESSAGECALLBACK)      = xxxWrapSendMessageCallback;

#if DBG
    {
        PULONG_PTR pdw;

        /*
         * Make sure that everyone got initialized.
         */
        for (pdw = (PULONG_PTR)&STOCID(FNID_START);
                (ULONG_PTR)pdw<(ULONG_PTR)(&STOCID(FNID_WNDPROCEND)); pdw++) {
            UserAssert(*pdw);
        }

        for (pdw=(PULONG_PTR)&FNID(FNID_START);
                (ULONG_PTR)pdw<(ULONG_PTR)(&FNID(FNID_WNDPROCEND)); pdw++) {
            UserAssert(*pdw);
        }
    }
#endif
}

/***************************************************************************\
* InitMessageTables
*
* Initialize the message tables.
*
* 25-Aug-1995 ChrisWil      Created.
\***************************************************************************/
VOID InitMessageTables(
    VOID)
{
    TRACE_INIT(("UserInit: Initialize Message Tables\n"));

#define INITMSGTABLE(member, procname)                \
    InitWindowMsgTable(&(gSharedInfo.member.abMsgs),  \
                       &(gSharedInfo.member.maxMsgs), \
                       gaw ## procname);

    INITMSGTABLE(DefWindowMsgs, DefWindowMsgs);
    INITMSGTABLE(DefWindowSpecMsgs, DefWindowSpecMsgs);

    INITMSGTABLE(awmControl[FNID_DIALOG       - FNID_START], DefDlgProc);
    INITMSGTABLE(awmControl[FNID_SCROLLBAR    - FNID_START], ScrollBarWndProc);
    INITMSGTABLE(awmControl[FNID_MENU         - FNID_START], MenuWndProc);
    INITMSGTABLE(awmControl[FNID_DESKTOP      - FNID_START], DesktopWndProc);
    INITMSGTABLE(awmControl[FNID_STATIC       - FNID_START], StaticWndProc);
    INITMSGTABLE(awmControl[FNID_BUTTON       - FNID_START], ButtonWndProc);
    INITMSGTABLE(awmControl[FNID_LISTBOX      - FNID_START], ListboxWndProc);
    INITMSGTABLE(awmControl[FNID_COMBOBOX     - FNID_START], ComboWndProc);
    INITMSGTABLE(awmControl[FNID_COMBOLISTBOX - FNID_START], ListboxWndProc);
    INITMSGTABLE(awmControl[FNID_EDIT         - FNID_START], EditWndProc);
    INITMSGTABLE(awmControl[FNID_IME          - FNID_START], ImeWndProc);
}

/***************************************************************************\
* InitOLEFormats
*
* OLE performance hack. OLE was previously having to call the server 15
* times for clipboard formats and another 15 LPC calls for the global atoms.
* Now we preregister them. We also assert they are in order so OLE only has
* to query the first to know them all. We call AddAtom directly instead of
* RegisterClipboardFormat.
*
* 25-Aug-1995 ChrisWil      Created.
\***************************************************************************/
BOOL InitOLEFormats(
    VOID)
{
    UINT idx;
    ATOM a1;
    ATOM a2;
    BOOL fSuccess = TRUE;

    TRACE_INIT(("UserInit: Initialize OLE Formats\n"));

    a1 = UserAddAtom(lpszOLEFormats[0], TRUE);

    for (idx = 1; idx < ARRAY_SIZE(lpszOLEFormats); idx++) {
        a2 = UserAddAtom(lpszOLEFormats[idx], TRUE);
        fSuccess &= !!a2;

        UserAssert(((a1 + 1) == a2) && (a1 = a2));
    }

    if (!fSuccess) {
        RIPMSG0(RIP_ERROR, "InitOLEFormats: at least one atom not registered");
    }

    return fSuccess;
}

#if DBG
/***************************************************************************\
* InitGlobalRIPFlags (CHK only).
*
* This initializes the global RIP flags from the registry.
*
* 25-Aug-1995 ChrisWil      Created.
\***************************************************************************/
VOID InitGlobalRIPFlags(
    VOID)
{

    UINT  idx;
    UINT  nCount;
    DWORD dwFlag;

    static CONST struct {
        LPWSTR lpszKey;
        DWORD  dwDef;
        DWORD  dwFlag;
    } aRIPFlags[] = {
        {L"fPromptOnError"  , 1, RIPF_PROMPTONERROR},
        {L"fPromptOnWarning", 0, RIPF_PROMPTONWARNING},
        {L"fPromptOnVerbose", 0, RIPF_PROMPTONVERBOSE},
        {L"fPrintError"     , 1, RIPF_PRINTONERROR},
        {L"fPrintWarning"   , 1, RIPF_PRINTONWARNING},
        {L"fPrintVerbose"   , 0, RIPF_PRINTONVERBOSE},
        {L"fPrintFileLine"  , 0, RIPF_PRINTFILELINE},
    };

    TRACE_INIT(("UserInit: Initialize Global RIP Flags\n"));

    nCount = ARRAY_SIZE(aRIPFlags);

    /*
     * Turn off the rip-on-warning bit. This is necessary to prevent the
     * FastGetProfileDwordW() routine from breaking into the debugger if an
     * entry can't be found. Since we provide default values, there's no sense
     * to break.
     */
    CLEAR_FLAG(gpsi->dwRIPFlags, RIPF_PROMPTONWARNING);
    CLEAR_FLAG(gpsi->dwRIPFlags, RIPF_PRINTONWARNING);

    for (idx = 0; idx < nCount; idx++) {
        FastGetProfileDwordW(NULL,
                             PMAP_WINDOWSM,
                             aRIPFlags[idx].lpszKey,
                             aRIPFlags[idx].dwDef,
                             &dwFlag,
                             0);

        SET_OR_CLEAR_FLAG(gpsi->dwRIPFlags, aRIPFlags[idx].dwFlag, dwFlag);
    }
}
#else
#define InitGlobalRIPFlags()
#endif


/***************************************************************************\
* _GetTextMetricsW
* _TextOutW
*
* Server shared function thunks.
*
* History:
* 10-Nov-1993 MikeKe    Created
\***************************************************************************/
BOOL _GetTextMetricsW(
    HDC           hdc,
    LPTEXTMETRICW ptm)
{
    TMW_INTERNAL tmi;
    BOOL         fret;

    fret = GreGetTextMetricsW(hdc, &tmi);

    *ptm = tmi.tmw;

    return fret;
}

BOOL _TextOutW(
    HDC     hdc,
    int     x,
    int     y,
    LPCWSTR lp,
    UINT    cc)
{
    return GreExtTextOutW(hdc, x, y, 0, NULL, (LPWSTR)lp, cc, NULL);
}


#define ROUND_UP_TO_PAGES(SIZE) \
        (((ULONG)(SIZE) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

/***************************************************************************\
* InitCreateSharedSection
*
* This creates the shared section.
*
*
* 25-Aug-1995 ChrisWil      Created comment block.
\***************************************************************************/
NTSTATUS InitCreateSharedSection(
    VOID)
{
    ULONG             ulHeapSize;
    ULONG             ulHandleTableSize;
    NTSTATUS          Status;
    LARGE_INTEGER     SectionSize;
    SIZE_T            ViewSize;
    PVOID             pHeapBase;

    TRACE_INIT(("UserInit: Create Shared Memory Section\n"));

    UserAssert(ghSectionShared == NULL);

    ulHeapSize        = ROUND_UP_TO_PAGES(USRINIT_SHAREDSECT_SIZE * 1024);
    ulHandleTableSize = ROUND_UP_TO_PAGES(0x10000 * sizeof(HANDLEENTRY));

    TRACE_INIT(("UserInit: Share: TableSize = %X; HeapSize = %X\n",
            ulHandleTableSize, ulHeapSize));

    SectionSize.LowPart  = ulHeapSize + ulHandleTableSize;
    SectionSize.HighPart = 0;

    Status = Win32CreateSection(&ghSectionShared,
                                SECTION_ALL_ACCESS,
                                NULL,
                                &SectionSize,
                                PAGE_EXECUTE_READWRITE,
                                SEC_RESERVE,
                                NULL,
                                NULL,
                                TAG_SECTION_SHARED);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "MmCreateSection failed in InitCreateSharedSection with Status %x",
                Status);
        return Status;
    }

    ViewSize = 0;
    gpvSharedBase = NULL;

    Status = Win32MapViewInSessionSpace(ghSectionShared, &gpvSharedBase, &ViewSize);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "Win32MapViewInSessionSpace failed with Status %x",
                Status);
        Win32DestroySection(ghSectionShared);
        ghSectionShared = NULL;
        return Status;
    }

    pHeapBase = ((PBYTE)gpvSharedBase + ulHandleTableSize);

    TRACE_INIT(("UserInit: Share: BaseAddr = %#p; Heap = %#p, ViewSize = %X\n",
            gpvSharedBase, pHeapBase, ViewSize));

    /*
     * Create shared heap.
     */
    if ((gpvSharedAlloc = UserCreateHeap(
            ghSectionShared,
            ulHandleTableSize,
            pHeapBase,
            ulHeapSize,
            UserCommitSharedMemory)) == NULL) {
        RIPERR0(ERROR_NOT_ENOUGH_MEMORY,
                RIP_WARNING,
                "Can't create shared memory heap.");

        Win32UnmapViewInSessionSpace(gpvSharedBase);

        Win32DestroySection(ghSectionShared);
        gpvSharedAlloc = NULL;
        gpvSharedBase = NULL;
        ghSectionShared = NULL;

        return STATUS_NO_MEMORY;
    }

    UserAssert(Win32HeapGetHandle(gpvSharedAlloc) == pHeapBase);

    return STATUS_SUCCESS;
}

/**************************************************************************\
* InitCreateUserCrit
*
* Create and initialize the user critical sections needed throughout the
* system.
*
* 23-Jan-1996 ChrisWil      Created.
\**************************************************************************/
BOOL InitCreateUserCrit(
    VOID)
{
    TRACE_INIT(("Win32UserInit: InitCreateUserCrit()\n"));

    /*
     * Initialize a critical section structure that will be used to protect
     * all of the User Server's critical sections (except a few special
     * cases like the RIT -- see below).
     */
    gpresUser = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(ERESOURCE),
                                      TAG_ERESOURCE);
    if (!gpresUser) {
        goto InitCreateUserCritExit;
    }

    if (!NT_SUCCESS(ExInitializeResourceLite(gpresUser))) {
        goto InitCreateUserCritExit;
    }

    /*
     * Initialize a critical section to be used in [Un]QueueMouseEvent
     * to protect the queue of mouse input events that the desktop thread
     * uses to pass input on to the RIT, after having moved the cursor
     * without obtaining gpresUser itself.
     */
    gpresMouseEventQueue = ExAllocatePoolWithTag(NonPagedPool,
                                                 sizeof(ERESOURCE),
                                                 TAG_ERESOURCE);
    if (!gpresMouseEventQueue) {
        goto InitCreateUserCritExit;
    }
    if (!NT_SUCCESS(ExInitializeResourceLite(gpresMouseEventQueue))) {
        goto InitCreateUserCritExit;
    }

    /*
     * Initialize a critical section to protect the list of DEVICEINFO structs
     * kept under gpDeviceInfoList. This is used by the RIT when reading kbd
     * input, the desktop thread when reading mouse input, and the PnP callback
     * routines DeviceClassNotify() and DeviceNotify() when devices come and go.
     */
    gpresDeviceInfoList = ExAllocatePoolWithTag(NonPagedPool,
                                            sizeof(ERESOURCE),
                                            TAG_ERESOURCE);
    if (!gpresDeviceInfoList) {
        goto InitCreateUserCritExit;
    }
    if (!NT_SUCCESS(ExInitializeResourceLite(gpresDeviceInfoList))) {
        goto InitCreateUserCritExit;
    }

    /*
     * Create the handle flag mutex. We'll need this once we start creating
     * windowstations and desktops.
     */
    gpHandleFlagsMutex = ExAllocatePoolWithTag(NonPagedPool,
                                               sizeof(FAST_MUTEX),
                                               TAG_SYSTEM);
    if (gpHandleFlagsMutex == NULL) {
        goto InitCreateUserCritExit;
    }
    ExInitializeFastMutex(gpHandleFlagsMutex);

    TRACE_INIT(("Win32UserInit: gpHandleFlagsMutex = %#p\n", gpHandleFlagsMutex));
    TRACE_INIT(("Win32UserInit: gpresDeviceInfoList = %#p\n", gpresDeviceInfoList));
    TRACE_INIT(("Win32UserInit: gpresMouseEventQueue = %#p\n", gpresMouseEventQueue));
    TRACE_INIT(("Win32UserInit: gpresUser  = %#p\n", gpresUser));

    TRACE_INIT(("Win32UserInit: exit InitCreateUserCrit()\n"));
    return TRUE;

InitCreateUserCritExit:
    RIPERR0(ERROR_NOT_ENOUGH_MEMORY,
            RIP_WARNING,
            "Win32UserInit: InitCreateUserCrit failed");

    if (gpresUser) {
        ExFreePool(gpresUser);
    }

    if (gpresMouseEventQueue) {
        ExFreePool(gpresMouseEventQueue);
    }

    if (gpresDeviceInfoList) {
        ExFreePool(gpresDeviceInfoList);
    }

    return FALSE;
}

/**************************************************************************\
* InitCreateObjectDirectory
*
* Create and initialize the user critical sections needed throughout the
* system.
*
* 23-Jan-1996 ChrisWil      Created.
\**************************************************************************/
NTSTATUS InitCreateObjectDirectory(VOID)
{
    HANDLE            hDir;
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UnicodeString;
    ULONG             attributes = OBJ_CASE_INSENSITIVE | OBJ_PERMANENT;

    TRACE_INIT(("UserInit: Create User Object-Directory\n"));

    RtlInitUnicodeString(&UnicodeString, szWindowStationDirectory);

    if (gbRemoteSession) {
       /*
        * Remote sessions don't use this flag
        */
       attributes &= ~OBJ_PERMANENT;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               attributes,
                               NULL,
                               gpsdInitWinSta);

    Status = ZwCreateDirectoryObject(&hDir,
                                     DIRECTORY_CREATE_OBJECT,
                                     &ObjectAttributes);

    UserFreePool(gpsdInitWinSta);

    /*
     * Do not close this handle for remote session because
     * if we do close it then the directory will go away and
     * we don't want that to happen. When CSRSS will go away
     * this handle will be freed also.
     */
    if (!gbRemoteSession)
        ZwClose(hDir);

    gpsdInitWinSta = NULL;

    return Status;
}

/**************************************************************************\
* InitCreateUserSubsystem
*
* Create and initialize the user subsystem stuff.
* system.
*
* 23-Jan-1996 ChrisWil      Created.
\**************************************************************************/
BOOL
InitCreateUserSubsystem()
{
    LPWSTR         lpszSubSystem;
    LPWSTR         lpszT;
    UNICODE_STRING strSize;

    TRACE_INIT(("UserInit: Create User SubSystem\n"));

    /*
     * Initialize the subsystem section. This identifies the default
     * user-heap size.
     */
    lpszSubSystem = UserAllocPoolWithQuota(USRINIT_SHAREDSECT_BUFF_SIZE * sizeof(WCHAR),
                                           TAG_SYSTEM);

    if (lpszSubSystem == NULL) {
        return FALSE;
    }

    if (FastGetProfileStringW(NULL,
                              PMAP_SUBSYSTEMS,
                              L"Windows",
                              L"SharedSection=,3072",
                              lpszSubSystem,
                              USRINIT_SHAREDSECT_READ_SIZE,
                              0) == 0) {
        RIPMSG0(RIP_WARNING,
                "UserInit: Windows subsystem definition not found");
        UserFreePool(lpszSubSystem);
        return FALSE;
    }

    /*
     * Locate the SharedSection portion of the definition and extract
     * the second value.
     */
    gdwDesktopSectionSize = USER_WINDOWSECT_SIZE;
    gdwNOIOSectionSize    = USER_NOIOSECT_SIZE;

    if (lpszT = wcsstr(lpszSubSystem, L"SharedSection")) {

        *(lpszT + 32) = UNICODE_NULL;

        if (lpszT = wcschr(lpszT, L',')) {

            RtlInitUnicodeString(&strSize, ++lpszT);
            RtlUnicodeStringToInteger(&strSize, 0, &gdwDesktopSectionSize);

            /*
             * Assert this logic doesn't need to change.
             */
            UserAssert(gdwDesktopSectionSize >= USER_WINDOWSECT_SIZE);

            gdwDesktopSectionSize = max(USER_WINDOWSECT_SIZE, gdwDesktopSectionSize);
            gdwNOIOSectionSize    = gdwDesktopSectionSize;

            /*
             * Now see if the optional non-interactive desktop
             * heap size was specified.
             */
            if (lpszT = wcschr(lpszT, L',')) {

                RtlInitUnicodeString(&strSize, ++lpszT);
                RtlUnicodeStringToInteger(&strSize, 0, &gdwNOIOSectionSize);

                UserAssert(gdwNOIOSectionSize >= USER_NOIOSECT_SIZE);
                gdwNOIOSectionSize = max(USER_NOIOSECT_SIZE, gdwNOIOSectionSize);
            }
        }
    }

    UserFreePool(lpszSubSystem);

    return TRUE;
}

extern UNICODE_STRING *gpastrSetupExe;     // These are used in
extern int giSetupExe;                     // SetAppImeCompatFlags in
                                           // queue.c

WCHAR* glpSetupPrograms;

/**************************************************************************\
* CreateSetupNameArray
*
* Create and initialize the arrary of setup app names. We inherited this
* hack From Chicago. See queue.c for more details.
\**************************************************************************/
BOOL CreateSetupNameArray(
    VOID)
{
    DWORD  dwProgNames;
    int    iSetupProgramCount = 0;
    WCHAR* lpTemp;
    int    ic, icnt, icMax;

    dwProgNames = FastGetProfileValue(NULL,
                                      PMAP_SETUPPROGRAMNAMES,
                                      L"SetupProgramNames",
                                      NULL,
                                      NULL,
                                      0,
                                      0);

    /*
     * This key is a multi-string, so is best to read as a value.
     * First, get the length and create the buffer to hold all of
     * the strings.
     */
    if (dwProgNames == 0) {
        return FALSE;
    }

    glpSetupPrograms = UserAllocPoolWithQuota(dwProgNames,
                                       TAG_SYSTEM);

    if (glpSetupPrograms == NULL) {
        RIPMSG0(RIP_WARNING, "CreateSetupNameArray: Memory allocation failure");
        return FALSE;
    }

    FastGetProfileValue(NULL,
                        PMAP_SETUPPROGRAMNAMES,
                        L"SetupProgramNames",
                        NULL,
                        (PBYTE)glpSetupPrograms,
                        dwProgNames,
                        0);

    lpTemp = glpSetupPrograms;
    icMax = dwProgNames/2;
    ic = 0; icnt=0;
    /*
     * Now count the strings.
     */
    while (ic < icMax) {
        if (*(lpTemp+ic) == 0) {
            ic++;
            continue;
        }
        ic += wcslen(lpTemp+ic)+1;
        icnt++;
    }

    /*
     * gpastrSetupExe is a pointer to an array of UNICODE_STRING structures.
     * Each structure is the name of one setup program.
     */
    giSetupExe = icnt;
    gpastrSetupExe = UserAllocPoolWithQuota(giSetupExe * sizeof(UNICODE_STRING),
                                       TAG_SYSTEM);

    if (gpastrSetupExe == NULL) {
        RIPMSG0(RIP_WARNING, "CreateSetupNameArray: Memory allocation failure");
        giSetupExe = 0;
        UserFreePool(glpSetupPrograms);
        glpSetupPrograms = NULL;
        return FALSE;
    }

    ic = 0; icnt=0;
    while (ic < icMax) {
        if (*(lpTemp+ic) == 0) {
            ic++;
            continue;
        }
        gpastrSetupExe[icnt].Buffer = lpTemp+ic;
        gpastrSetupExe[icnt].Length = sizeof(WCHAR)*wcslen(lpTemp+ic);
        gpastrSetupExe[icnt].MaximumLength = gpastrSetupExe[icnt].Length + sizeof(WCHAR);
        ic += wcslen(lpTemp+ic)+1;
        icnt++;

    }

    return TRUE;
}

#define CALC_DELTA(element)                   \
        (PVOID)((PBYTE)pClientBase +          \
        ((PBYTE)gSharedInfo.element -         \
        (PBYTE)gpvSharedBase))

/***************************************************************************\
* InitMapSharedSection
*
* This maps the shared section.
*
*
* 25-Aug-1995 ChrisWil      Created comment block.
\***************************************************************************/

NTSTATUS InitMapSharedSection(
    PEPROCESS    Process,
    PUSERCONNECT pUserConnect)
{
    int           i;
    PVOID         pClientBase = NULL;
    ULONG_PTR      ulSharedDelta;
    PW32PROCESS   pw32p;

    TRACE_INIT(("UserInit: Map Shared Memory Section\n"));

    UserAssert(ghSectionShared != NULL);

    ValidateProcessSessionId(Process);

    /*
     * Check to see if we haven't already mapped the section
     * This might happen for multiple LoadLibrary()/FreeLibrary calls
     * in one process. MCostea #56946
     */
    pw32p = PsGetProcessWin32Process(Process);
    if (pw32p == NULL ||
        ((PPROCESSINFO)pw32p)->pClientBase == NULL) {

        SIZE_T        ViewSize;
        LARGE_INTEGER liOffset;
        NTSTATUS Status;

        ViewSize = 0;
        liOffset.QuadPart = 0;

        Status = MmMapViewOfSection(ghSectionShared,
                                Process,
                                &pClientBase,
                                0,
                                0,
                                &liOffset,
                                &ViewSize,
                                ViewUnmap,
                                SEC_NO_CHANGE,
                                PAGE_EXECUTE_READ);
        if (NT_SUCCESS(Status)) {
            TRACE_INIT(("UserInit: Map: Client SharedInfo Base = %#p\n", pClientBase));

            UserAssert(gpvSharedBase > pClientBase);
            pw32p = PsGetProcessWin32Process(Process);
            if (pw32p != NULL) {
                ((PPROCESSINFO)pw32p)->pClientBase = pClientBase;
            }
        } else {
            return Status;
        }

    } else {
        pClientBase = ((PPROCESSINFO)PsGetProcessWin32Process(Process))->pClientBase;
    }
    ulSharedDelta = (PBYTE)gpvSharedBase - (PBYTE)pClientBase;
    pUserConnect->siClient.ulSharedDelta = ulSharedDelta;

    pUserConnect->siClient.psi          = CALC_DELTA(psi);
    pUserConnect->siClient.aheList      = CALC_DELTA(aheList);
    pUserConnect->siClient.pDispInfo    = CALC_DELTA(pDispInfo);


    pUserConnect->siClient.DefWindowMsgs.maxMsgs     = gSharedInfo.DefWindowMsgs.maxMsgs;
    pUserConnect->siClient.DefWindowMsgs.abMsgs      = CALC_DELTA(DefWindowMsgs.abMsgs);
    pUserConnect->siClient.DefWindowSpecMsgs.maxMsgs = gSharedInfo.DefWindowSpecMsgs.maxMsgs;
    pUserConnect->siClient.DefWindowSpecMsgs.abMsgs  = CALC_DELTA(DefWindowSpecMsgs.abMsgs);

    for (i = 0; i < (FNID_END - FNID_START + 1); ++i) {

        pUserConnect->siClient.awmControl[i].maxMsgs = gSharedInfo.awmControl[i].maxMsgs;

        if (gSharedInfo.awmControl[i].abMsgs)
            pUserConnect->siClient.awmControl[i].abMsgs = CALC_DELTA(awmControl[i].abMsgs);
        else
            pUserConnect->siClient.awmControl[i].abMsgs = NULL;
    }
    return STATUS_SUCCESS;
}
/**************************************************************************\
* InitLoadResources
*
*
* 25-Aug-1995 ChrisWil      Created.
\**************************************************************************/

VOID InitLoadResources()
{
    PRECT   prc;

    DISPLAYRESOURCE dr = {
        17,     // Height of vertical thumb
        17,     // Width of horizontal thumb
        2,      // Icon horiz compression factor
        2,      // Icon vert compression factor
        2,      // Cursor horz compression factor
        2,      // Cursor vert compression factor
        0,      // Kanji window height
        1,      // cxBorder (thickness of vertical lines)
        1       // cyBorder (thickness of horizontal lines)
    };


    TRACE_INIT(("UserInit: Load Display Resources\n"));

    /*
     * For high-DPI systems, don't compress the cursor as much.
     * This really should be a more configurable method, such as a System
     * Parameter Info setting or something. But for now, we'll hard-code
     * 150dpi to be the threshhold at which we'll double the cursor size.
     */
    if (gpsi->dmLogPixels >= 150) {
        dr.xCompressCursor = 1;
        dr.yCompressCursor = 1;
    }

    if (dr.xCompressIcon > 10) {

        /*
         * If so, the actual dimensions of icons and cursors are
         * kept in OEMBIN.
         */
        SYSMET(CXICON)   = dr.xCompressIcon;
        SYSMET(CYICON)   = dr.yCompressIcon;
        SYSMET(CXCURSOR) = dr.xCompressCursor;
        SYSMET(CYCURSOR) = dr.yCompressCursor;

    } else {

        /*
         * Else, only the ratio of (64/icon dimensions) is kept there.
         */
        SYSMET(CXICON)   = (64 / dr.xCompressIcon);
        SYSMET(CYICON)   = (64 / dr.yCompressIcon);
        SYSMET(CXCURSOR) = (64 / dr.xCompressCursor);
        SYSMET(CYCURSOR) = (64 / dr.yCompressCursor);
    }

    SYSMET(CXSMICON) = SYSMET(CXICON) / 2;
    SYSMET(CYSMICON) = SYSMET(CYICON) / 2;

    SYSMET(CYKANJIWINDOW) = dr.yKanji;

    /*
     * Get border thicknesses.
     */
    SYSMET(CXBORDER) = dr.cxBorder;
    SYSMET(CYBORDER) = dr.cyBorder;

    /*
     * Edge is two borders.
     */
    SYSMET(CXEDGE) = 2 * SYSMET(CXBORDER);
    SYSMET(CYEDGE) = 2 * SYSMET(CYBORDER);

    /*
     * Fixed frame is outer edge + border.
     */
    SYSMET(CXDLGFRAME) = SYSMET(CXEDGE) + SYSMET(CXBORDER);
    SYSMET(CYDLGFRAME) = SYSMET(CYEDGE) + SYSMET(CYBORDER);

    if (gbRemoteSession) {
        return;
    }

    prc = &GetPrimaryMonitor()->rcMonitor;
    SYSMET(CXFULLSCREEN) = prc->right;
    SYSMET(CYFULLSCREEN) = prc->bottom - SYSMET(CYCAPTION);

    /*
     * Set the initial cursor position to the center of the primary screen.
     */
    gpsi->ptCursor.x = prc->right / 2;
    gpsi->ptCursor.y = prc->bottom / 2;
}

/***************************************************************************\
* GetCharDimensions
*
* This function loads the Textmetrics of the font currently selected into
* the hDC and returns the Average char width of the font; Pl Note that the
* AveCharWidth value returned by the Text metrics call is wrong for
* proportional fonts. So, we compute them On return, lpTextMetrics contains
* the text metrics of the currently selected font.
*
* History:
* 10-Nov-1993 mikeke   Created
\***************************************************************************/
int GetCharDimensions(
        HDC          hdc,
        TEXTMETRIC*  lptm,
        LPINT        lpcy
        )
{
    TEXTMETRIC tm;

    /*
     * Didn't find it in cache, store the font metrics info.
     */
    if (!_GetTextMetricsW(hdc, &tm)) {
        RIPMSG1(RIP_WARNING, "GetCharDimensions: _GetTextMetricsW failed. hdc %#lx", hdc);
        tm = gpsi->tmSysFont; // damage control

        if (tm.tmAveCharWidth == 0) {
            RIPMSG0(RIP_WARNING, "GetCharDimensions: _GetTextMetricsW first time failure");
            tm.tmAveCharWidth = 8;
        }
    }
    if (lptm != NULL)
        *lptm = tm;
    if (lpcy != NULL)
        *lpcy = tm.tmHeight;

    /*
     * If variable_width font
     */
    if (tm.tmPitchAndFamily & TMPF_FIXED_PITCH) {
        SIZE size;
        static CONST WCHAR wszAvgChars[] =
                L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

        /*
         * Change from tmAveCharWidth. We will calculate a true average
         * as opposed to the one returned by tmAveCharWidth. This works
         * better when dealing with proportional spaced fonts.
         */
        if (GreGetTextExtentW(
                hdc, (LPWSTR)wszAvgChars,
                (sizeof(wszAvgChars) / sizeof(WCHAR)) - 1,
                &size, GGTE_WIN3_EXTENT)) {

            UserAssert((((size.cx / 26) + 1) / 2) > 0);
            return ((size.cx / 26) + 1) / 2;    // round up
        } else {
            RIPMSG1(RIP_WARNING, "GetCharDimensions: GreGetTextExtentW failed. hdc %#lx", hdc);
        }
    }

    UserAssert(tm.tmAveCharWidth > 0);

    return tm.tmAveCharWidth;
}


/**************************************************************************\
* InitVideo
*
* Create pmdev.
*
* 03-March-1998 CLupu  Moved from UserInitialize code
\**************************************************************************/
PMDEV InitVideo(
    BOOL bReenumerationNeeded)
{
    PMDEV pmdev;
    LONG  ChangeStatus;

    /*
     * NOTE: Need to get a status return from this call.
     * DrvInitConsole doesn't return failure, if or when it does we
     * should check for it and return NULL. However there seem to be
     * no known problems related to this.
     */

    DrvInitConsole(bReenumerationNeeded);

    /*
     * BASEVIDEO may be on or off, whether we are in setup or not.
     */

    ChangeStatus = DrvChangeDisplaySettings(NULL,
                                            NULL,
                                            NULL,
                                            (PVOID)GW_DESKTOP_ID,
                                            KernelMode,
                                            FALSE,
                                            TRUE,
                                            NULL,
                                            &pmdev,
                                            GRE_DEFAULT,
                                            TRUE);


    if (ChangeStatus != GRE_DISP_CHANGE_SUCCESSFUL) {
        /*
         * If we fail, try BASEVIDEO temporarily.
         */
        DrvSetBaseVideo(TRUE);

        ChangeStatus = DrvChangeDisplaySettings(NULL,
                                                NULL,
                                                NULL,
                                                (PVOID)GW_DESKTOP_ID,
                                                KernelMode,
                                                FALSE,
                                                TRUE,
                                                NULL,
                                                &pmdev,
                                                GRE_DEFAULT,
                                                TRUE);

        DrvSetBaseVideo(FALSE);

        /*
         * Give it one last try, not in basevideo, to handle TGA
         * (non-vgacompatible) during GUI-mode setup (BASEVIDEO is on by
         * default)
         */

        if (ChangeStatus != GRE_DISP_CHANGE_SUCCESSFUL) {
            ChangeStatus = DrvChangeDisplaySettings(NULL,
                                                    NULL,
                                                    NULL,
                                                    (PVOID)GW_DESKTOP_ID,
                                                    KernelMode,
                                                    FALSE,
                                                    TRUE,
                                                    NULL,
                                                    &pmdev,
                                                    GRE_DEFAULT,
                                                    TRUE);

        }
    }

    if (ChangeStatus != GRE_DISP_CHANGE_SUCCESSFUL) {
        RIPMSG0(RIP_WARNING, "InitVideo: No working display driver found");
        return NULL;
    }

    /*
     * Remove the basevideo flag. We want it set only on the first modeset.
     */
    DrvSetBaseVideo(FALSE);

    gpDispInfo->hDev  = pmdev->hdevParent;
    gpDispInfo->pmdev = pmdev;

    GreUpdateSharedDevCaps(gpDispInfo->hDev);

    if (!InitUserScreen()) {
        RIPMSG0(RIP_WARNING, "InitUserScreen failed");
        return NULL;
    }

    HYDRA_HINT(HH_INITVIDEO);

    return pmdev;
}

VOID DrvDriverFailure(
    VOID)
{
    KeBugCheckEx(VIDEO_DRIVER_INIT_FAILURE,
                 0,
                 0,
                 0,
                 USERCURRENTVERSION);
}

/***************************************************************************\
* BeginBootPhase
*
* Let's kernel know of boot progress on the console.
*
* 10-Apr-2001 Cenke  Created.
\***************************************************************************/
NTSTATUS BeginBootPhase(
    PF_BOOT_PHASE_ID Phase)
{
    PREFETCHER_INFORMATION PrefetcherInformation;
    NTSTATUS Status;

    /*
     * We should be called only on the console.
     */

    UserAssert(gSessionId == 0);

    /*
     * Setup the structure that will be passed to system call.
     */

    PrefetcherInformation.Magic = PF_SYSINFO_MAGIC_NUMBER;
    PrefetcherInformation.Version = PF_CURRENT_VERSION;
    PrefetcherInformation.PrefetcherInformationClass = PrefetcherBootPhase;
    PrefetcherInformation.PrefetcherInformation = &Phase;
    PrefetcherInformation.PrefetcherInformationLength = sizeof(Phase);

    /*
     * Call system and return status to caller.
     */

    Status = ZwSetSystemInformation(SystemPrefetcherInformation,
                                    &PrefetcherInformation,
                                    sizeof(PrefetcherInformation));

    return Status;
}

/**************************************************************************\
* ReserveUserSessionViews
*
* Reserve user needed session views beforhand to prevert GDI from eating
* uo the session view space when hardware acceleration is turned off.
*
* 27-Nov-2001 MSadek  Created it
\**************************************************************************/
NTSTATUS
ReserveUserSessionViews(
    PHANDLE phSection,
    PPVOID  ppMapBase)
{
    LARGE_INTEGER SectionSize;
    ULONG         ulSectionSize;
    SIZE_T        ulViewSize;
    NTSTATUS      Status;

    /*
     * We need to reserve session view space for:
     * - Winlogon desktop heap.
     * - Disconnect desktop heap.
     * - Winlogon desktop heap.
     * - Services desktops heap (how many?, let's have a factor of safety here).
     */

    ulSectionSize = GetDesktopHeapSize(DHS_LOGON) +
                    GetDesktopHeapSize(DHS_DISCONNECT) +
                    GetDesktopHeapSize(0) +
                    GetDesktopHeapSize(DHS_NOIO) * NOIO_DESKTOP_NUMBER;

    SectionSize.QuadPart = ulSectionSize;

    Status = Win32CreateSection(phSection,
                                SECTION_ALL_ACCESS,
                                (POBJECT_ATTRIBUTES)NULL,
                                &SectionSize,
                                PAGE_EXECUTE_READWRITE,
                                SEC_RESERVE,
                                (HANDLE)NULL,
                                NULL,
                                TAG_SECTION_DESKTOP);

    if (!NT_SUCCESS( Status )) {
        RIPNTERR0(Status,
                  RIP_WARNING,
                  "Can't create section for reserved session views.");
        return Status;
    }

    ulViewSize = ulSectionSize;
    *ppMapBase = NULL;

    Status = Win32MapViewInSessionSpace(*phSection, ppMapBase, &ulViewSize);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status,
                  RIP_WARNING,
                  "Can't map section for for reserved session views into session space.");
        Win32DestroySection(&phSection);
    }

    return Status;
}

/**************************************************************************\
* UserInitialize
*
* Worker routine for user initialization.
*
* 25-Aug-1995 ChrisWil  Created comment block/Multiple desktop support.
* 15-Dec-1995 BradG     Modified to return MediaChangeEvent Handle.
\**************************************************************************/
NTSTATUS
UserInitialize(
    VOID)
{
    NTSTATUS Status;
    DWORD    dwData;
    HANDLE   hSection;
    PVOID    pSectionBase;

#if DBG
    /*
     * Allow a trace of all the init stuff going on related to display
     * drivers. Useful to debug boot time problems related to graphics.
     */
    if (RtlGetNtGlobalFlags() & FLG_SHOW_LDR_SNAPS) {
        TraceInitialization = 1;
    }
#endif

    TRACE_INIT(("Entering UserInitialize\n"));

    EnterCrit();

    HYDRA_HINT(HH_USERINITIALIZE);

    if (ISTS() && gbRemoteSession) {
        swprintf(szWindowStationDirectory, L"%ws\\%ld%ws",
                 SESSION_ROOT, gSessionId, WINSTA_DIR);
    } else {
        wcscpy(szWindowStationDirectory, WINSTA_DIR);
    }

    /*
     * Create WindowStation object directory.
     */
    Status = InitCreateObjectDirectory();

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "InitCreateObjectDirectory failed with Status %x",
                Status);

        goto Exit;
    }

    /*
     * Create the event for  PnP RequestDeviceChangeSyncronization
     */
    gpEventPnPWainting = CreateKernelEvent(SynchronizationEvent, TRUE);

    if (gpEventPnPWainting == NULL) {
        RIPMSG0(RIP_WARNING, "Failed to create gpEventPnPWainting");
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * Read the registry configuration for the multimon snapsot flag
     */

    if (FastGetProfileIntFromID(NULL,PMAP_TS, STR_SNAPSHOTMONITORS, 1, &dwData, 0)) {
        if (dwData != 0) {
            gbSnapShotWindowsAndMonitors = TRUE;
        } else {
            gbSnapShotWindowsAndMonitors = FALSE;
        }
    }  else{
        gbSnapShotWindowsAndMonitors = TRUE;
    }



    /*
     * Create the event for the diconnect desktop creation
     */
    gpEventDiconnectDesktop = CreateKernelEvent(SynchronizationEvent, FALSE);

    if (gpEventDiconnectDesktop == NULL) {
        RIPMSG0(RIP_WARNING, "Failed to create gpEventDiconnectDesktop");
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * WinStations get init'ed on the first connect.
     */
    if (!gbRemoteSession) {
        BeginBootPhase(PfVideoInitPhase);

        /* If hardware acceleration is turned off, GDI will map huge sections for the panning
         * surfaces. We might end up exceeding the session view size quota before mapping the heap
         * section for critical desktops.
         * Let's pre-reserve approximately what we need now.
         */
        Status = ReserveUserSessionViews(&hSection, &pSectionBase);
        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }

        if (InitVideo(TRUE) == NULL) {
            DrvDriverFailure();
        }

        Status = Win32UnmapViewInSessionSpace(pSectionBase);
        Win32DestroySection(hSection);

        BeginBootPhase(PfPostVideoInitPhase);

        /*
         * Do this here so power callouts
         * have the pmdev in gpDispInfo set
         */
        gbVideoInitialized = TRUE;
    }

    gbUserInitialized = TRUE;

    /*
     * Now that the system is initialized, allocate a pti for this thread.
     */
    Status = xxxCreateThreadInfo(PsGetCurrentThread());
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "xxxCreateThreadInfo failed during UserInitialize with Status 0x%x",
                Status);
        goto Exit;
    }

    /*
     * Initialize Global RIP flags (debug only).
     */
    InitGlobalRIPFlags();

    /*
     * WinStations get init'ed on the first connect.
     */
    if (!gbRemoteSession) {
        UserVerify(LW_BrushInit());
    }

    InitLoadResources();

Exit:
    LeaveCrit();

    TRACE_INIT(("Leaving UserInitialize\n"));

    return Status;
}

/**************************************************************************\
* IsDBCSEnabledSystem
*
* check if the system is configured as FE Enabled
*
* 07-Feb-1997 HiroYama  Created
\**************************************************************************/
__inline BOOL IsDBCSEnabledSystem(
    VOID)
{
    return !!NLS_MB_CODE_PAGE_TAG;
}


BOOL IsIMMEnabledSystem(
    VOID)
{
    DWORD dwRet = 0;

    /*
     * If the entire system is DBCS enabled, IMM/IME should be activated
     * anyway.
     */
    if (IsDBCSEnabledSystem()) {
        return TRUE;
    }

    FastGetProfileDwordW(NULL, PMAP_IMM, TEXT("LoadIMM"), 0, &dwRet, 0);
    return dwRet;
}

#ifdef CUAS_ENABLE

BOOL IsCTFIMEEnabledSystem(
    VOID)
{
    DWORD dwRet = 0;

    FastGetProfileDwordW(NULL, PMAP_IMM, TEXT("DontLoadCTFIME"), 0, &dwRet, 0);
    if (dwRet)
        return FALSE;

    return IsIMMEnabledSystem();
}

#endif

/*
 * Get ACP and check if the system is configured as ME Enabled.
 */
BOOL IsMidEastEnabledSystem(
    VOID)
{
    extern __declspec(dllimport) USHORT NlsAnsiCodePage;
    /*
     * 1255 == Hebrew and 1256 == Arabic.
     */
    if (NlsAnsiCodePage == 1255 || NlsAnsiCodePage == 1256) {
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* SetupClassAtoms
*
* 10/01/1998   clupu          moved from Win32UserInitialize
\***************************************************************************/
BOOL SetupClassAtoms(
    VOID)
{
    BOOL fSuccess = TRUE;
    int  ind;

    /*
     * Set up class atoms.
     *
     * HACK: Controls are registered on the client side so we can't fill in
     * their atomSysClass entry the same way we do for the other classes.
     */
    for (ind = ICLS_BUTTON; ind < ICLS_CTL_MAX; ind++) {
        gpsi->atomSysClass[ind] = UserAddAtom(lpszControls[ind], TRUE);
        fSuccess &= !!gpsi->atomSysClass[ind];
    }

    gpsi->atomSysClass[ICLS_DIALOG]    = PTR_TO_ID(DIALOGCLASS);
    gpsi->atomSysClass[ICLS_ICONTITLE] = PTR_TO_ID(ICONTITLECLASS);
    gpsi->atomSysClass[ICLS_TOOLTIP]   = PTR_TO_ID(TOOLTIPCLASS);
    gpsi->atomSysClass[ICLS_DESKTOP]   = PTR_TO_ID(DESKTOPCLASS);
    gpsi->atomSysClass[ICLS_SWITCH]    = PTR_TO_ID(SWITCHWNDCLASS);
    gpsi->atomSysClass[ICLS_MENU]      = PTR_TO_ID(MENUCLASS);

    gpsi->atomContextHelpIdProp = UserAddAtom(szCONTEXTHELPIDPROP, TRUE);
    fSuccess &= !!gpsi->atomContextHelpIdProp;

    gpsi->atomIconSmProp        = UserAddAtom(szICONSM_PROP_NAME, TRUE);
    fSuccess &= !!gpsi->atomIconSmProp;

    gpsi->atomIconProp          = UserAddAtom(szICON_PROP_NAME, TRUE);
    fSuccess &= !!gpsi->atomIconProp;

    gpsi->uiShellMsg            = UserAddAtom(szSHELLHOOK, TRUE);
    fSuccess &= !!gpsi->uiShellMsg;

    /*
     * Initialize the integer atoms for our magic window properties
     */
    atomCheckpointProp = UserAddAtom(szCHECKPOINT_PROP_NAME, TRUE);
    fSuccess &= !!atomCheckpointProp;

    atomDDETrack = UserAddAtom(szDDETRACK_PROP_NAME, TRUE);
    fSuccess &= !!atomDDETrack;

    atomQOS = UserAddAtom(szQOS_PROP_NAME, TRUE);
    fSuccess &= !!atomQOS;

    atomDDEImp = UserAddAtom(szDDEIMP_PROP_NAME, TRUE);
    fSuccess &= !!atomDDEImp;

    atomWndObj = UserAddAtom(szWNDOBJ_PROP_NAME, TRUE);
    fSuccess &= !!atomWndObj;

    atomImeLevel = UserAddAtom(szIMELEVEL_PROP_NAME, TRUE);
    fSuccess &= !!atomImeLevel;

    atomLayer = UserAddAtom(szLAYER_PROP_NAME, TRUE);
    fSuccess &= !!atomLayer;

    guiActivateShellWindow = UserAddAtom(szACTIVATESHELLWINDOW, TRUE);
    fSuccess &= !!guiActivateShellWindow;

    guiOtherWindowCreated = UserAddAtom(szOTHERWINDOWCREATED, TRUE);
    fSuccess &= !!guiOtherWindowCreated;

    guiOtherWindowDestroyed = UserAddAtom(szOTHERWINDOWDESTROYED, TRUE);
    fSuccess &= !!guiOtherWindowDestroyed;

    gatomMessage = UserAddAtom(szMESSAGE, TRUE);
    fSuccess &= !!gatomMessage;

#ifdef HUNGAPP_GHOSTING
    gatomGhost = UserAddAtom(szGHOST, TRUE);
    fSuccess &= !!gatomGhost;
#endif

    gatomShadow = UserAddAtom(szSHADOW, TRUE);
    fSuccess &= !!gatomShadow;

    gaOleMainThreadWndClass = UserAddAtom(szOLEMAINTHREADWNDCLASS, TRUE);
    fSuccess &= !!gaOleMainThreadWndClass;

    gaFlashWState = UserAddAtom(szFLASHWSTATE, TRUE);
    fSuccess &= !!gaFlashWState;

    gatomLastPinned = gaOleMainThreadWndClass;

    return fSuccess;
}

/**************************************************************************\
* IsDesktopHeapLoggingOn
*
* Checks the registry to determine if we should write a message to the
* event log on desktop heap allocation failures.
*
* 05-19-2002    JasonSch    Created.
\**************************************************************************/
BOOL IsDesktopHeapLoggingOn(
    VOID)
{
    DWORD dwDesktopHeapLogging;

    FastGetProfileDwordW(NULL,
                         PMAP_WINDOWSM,
                         L"DesktopHeapLogging",
                         0,
                         &dwDesktopHeapLogging,
                         0);

    return (dwDesktopHeapLogging != 0);
}

/**************************************************************************\
* Win32UserInitialize
*
* Worker routine for user initialization called from Win32k's DriverEntry.
\**************************************************************************/
NTSTATUS Win32UserInitialize(
    VOID)
{
    NTSTATUS Status;
    POBJECT_TYPE_INITIALIZER pTypeInfo;
    LONG lTemp;

    TRACE_INIT(("Entering Win32UserInitialize\n"));

    /*
     * Create the shared section.
     */
    Status = InitCreateSharedSection();
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "InitCreateSharedSection failed with Status 0x%x",
                Status);
        return Status;
    }

    EnterCrit();

    /*
     * Initialize security stuff.
     */
    if (!InitSecurity()) {
        RIPMSG0(RIP_WARNING, "InitSecurity failed");
        goto ExitWin32UserInitialize;
    }

    /*
     * Fill in windowstation and desktop object types
     */
    pTypeInfo = &(*ExWindowStationObjectType)->TypeInfo;
    pTypeInfo->DefaultNonPagedPoolCharge = sizeof(WINDOWSTATION) + sizeof(KEVENT);
    pTypeInfo->DefaultPagedPoolCharge    = 0;
    pTypeInfo->MaintainHandleCount       = TRUE;
    pTypeInfo->ValidAccessMask           = WinStaMapping.GenericAll;
    pTypeInfo->GenericMapping            = WinStaMapping;

    pTypeInfo = &(*ExDesktopObjectType)->TypeInfo;
    pTypeInfo->DefaultNonPagedPoolCharge = sizeof(DESKTOP);
    pTypeInfo->DefaultPagedPoolCharge    = 0;
    pTypeInfo->MaintainHandleCount       = TRUE;
    pTypeInfo->ValidAccessMask           = DesktopMapping.GenericAll;
    pTypeInfo->GenericMapping            = DesktopMapping;

    /*
     * Get this process so we can use the profiles.
     */
    gpepInit = PsGetCurrentProcess();

    Status  = InitQEntryLookaside();
    Status |= InitSMSLookaside();
    Status |= UserRtlCreateAtomTable(USRINIT_ATOMBUCKET_SIZE);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "Initialization failure (Status = 0x%x)",
                Status);
        goto ExitWin32UserInitialize;
    }

    atomUSER32 = UserAddAtom(szUSER32, TRUE);

    gatomFirstPinned = atomUSER32;

    if (gatomFirstPinned == 0) {
        RIPMSG0(RIP_WARNING, "Could not create atomUSER32");
        goto ExitWin32UserInitialize;
    }

    /*
     * Initialize the user subsystem information.
     */
    if (!InitCreateUserSubsystem()) {
        RIPMSG0(RIP_WARNING, "InitCreateUserSubsystem failed");
        goto ExitWin32UserInitialize;
    }

    /*
     * Don't bail out if CreateSetupNameArray fails.
     */
    CreateSetupNameArray();

    /*
     * Allocated shared SERVERINFO structure.
     */
    if ((gpsi = (PSERVERINFO)SharedAlloc(sizeof(SERVERINFO))) == NULL) {
        RIPMSG0(RIP_WARNING, "Could not allocate SERVERINFO");
        goto ExitWin32UserInitialize;
    }

    /*
     * Set the default rip-flags to rip on just about everything. We'll
     * truly set this in the InitGlobalRIPFlags() routine. These are needed
     * so that we can do appropriate ripping during the rest of the init
     * calls.
     */
#if DBG
    SET_FLAG(gpsi->dwRIPFlags, RIPF_DEFAULT);
#endif

    /*
     * Make sure we will not get a division by zero if the initialization
     * will not complete correctly. Set these to their normal values.
     */
    gpsi->cxMsgFontChar = 6;
    gpsi->cyMsgFontChar = 13;
    gpsi->cxSysFontChar = 8;
    gpsi->cySysFontChar = 16;

    /*
     * Initialize the last time we updated system-wide LastSystemRITEventTickCount
     * on system shared page.
     */

    gpsi->dwLastSystemRITEventTickCountUpdate = 0;

    /*
     * Initialize the DISPLAYINFO structure.
     */
    gpDispInfo = SharedAlloc(sizeof(*gpDispInfo));
    if (!gpDispInfo) {
        RIPMSG0(RIP_WARNING, "Could not allocate gpDispInfo");
        goto ExitWin32UserInitialize;
    }

    InitDbgTags();

    SET_OR_CLEAR_SRVIF(SRVIF_LOGDESKTOPHEAPFAILURE, IsDesktopHeapLoggingOn());
    SET_OR_CLEAR_SRVIF(SRVIF_DBCS, IsDBCSEnabledSystem());
    SET_OR_CLEAR_SRVIF(SRVIF_IME, IsIMMEnabledSystem());
#ifdef CUAS_ENABLE
    SET_OR_CLEAR_SRVIF(SRVIF_CTFIME_ENABLED, IsCTFIMEEnabledSystem());
#endif // CUAS_ENABLE

    SET_OR_CLEAR_SRVIF(SRVIF_MIDEAST, IsMidEastEnabledSystem());

#if DBG
    SET_SRVIF(SRVIF_CHECKED);

#if !defined(CUAS_ENABLE)
    RIPMSG3(RIP_WARNING, "*** win32k: DBCS:[%d] IME:[%d] MiddleEast:[%d]",
            IS_DBCS_ENABLED(),
            IS_IME_ENABLED(),
            IS_MIDEAST_ENABLED());
#else
    RIPMSG4(RIP_WARNING, "*** win32k: DBCS:[%d] IME:[%d] MiddleEast:[%d] CTFIME:[%d]",
            IS_DBCS_ENABLED(),
            IS_IME_ENABLED(),
            IS_MIDEAST_ENABLED(),
            IS_CICERO_ENABLED());
#endif
#endif

    gpsi->dwDefaultHeapSize = gdwDesktopSectionSize * 1024;

    /*
     * Initialize procedures and message tables.
     * Initialize the class structures for Get/SetClassWord/Long.
     * Initialize message-box strings.
     * Initialize OLE-Formats (performance-hack).
     */
    InitFunctionTables();
    InitMessageTables();
#if DBG
    VerifySyncOnlyMessages();
#endif
    if (!InitOLEFormats()) {
        RIPMSG0(RIP_WARNING, "InitOLEFormats failed");
        goto ExitWin32UserInitialize;
    }

    /*
     * Set up class atoms
     */
    if (!SetupClassAtoms()) {
        RIPMSG0(RIP_WARNING, "SetupClassAtoms failed to register atoms");
        goto ExitWin32UserInitialize;
    }

    /*
     * Initialize the handle manager.
     */
    if (!HMInitHandleTable(gpvSharedBase)) {
        RIPMSG0(RIP_WARNING, "HMInitHandleTable failed");
        goto ExitWin32UserInitialize;
    }

    /*
     * Setup shared info block.
     */
    gSharedInfo.psi = gpsi;
    gSharedInfo.pDispInfo = gpDispInfo;

    /*
     * Determine if we have unsigned drivers installed
     * Use      2BD63D28D7BCD0E251195AEB519243C13142EBC3 as current key to check.
     * Old key: 300B971A74F97E098B67A4FCEBBBF6B9AE2F404C
     */
    if (NT_SUCCESS(RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE, L"\\Registry\\Machine\\SOFTWARE\\Policies\\Microsoft\\SystemCertificates\\Root\\Certificates\\2BD63D28D7BCD0E251195AEB519243C13142EBC3")) ||
        NT_SUCCESS(RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE, L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\SystemCertificates\\Root\\Certificates\\2BD63D28D7BCD0E251195AEB519243C13142EBC3")) ||
        NT_SUCCESS(RtlCheckRegistryKey(RTL_REGISTRY_USER, L"\\SOFTWARE\\Microsoft\\SystemCertificates\\Root\\Certificates\\2BD63D28D7BCD0E251195AEB519243C13142EBC3"))) {
        gfUnsignedDrivers = TRUE;
    }

    FastGetProfileDwordW(NULL,
                         PMAP_WINDOWSM,
                         L"USERProcessHandleQuota",
                         DEFAULT_USER_HANDLE_QUOTA,
                         &lTemp,
                         0);
    gUserProcessHandleQuota = lTemp;

    /*
     * The maximum number of posted message for a thread.
     */
    FastGetProfileDwordW(NULL,
                         PMAP_WINDOWSM,
                         L"USERPostMessageLimit",
                         DEFAULT_POSTMESSAGE_LIMIT,
                         &lTemp,
                         0);
    if (lTemp == 0) {
        /*
         * 0 means (virtually) no limit.
         */
        gUserPostMessageLimit = ~0;
    } else {
        gUserPostMessageLimit = lTemp;
    }

    if (!gDrawVersionAlways) {
        FastGetProfileDwordW(NULL,
                             PMAP_WINDOWSM,
                             L"DisplayVersion",
                             0,
                             &gDrawVersionAlways,
                             0);
    }

    FastGetProfileDwordW(NULL,
                         PMAP_TS_EXCLUDE_DESKTOP_VERSION,
                         L"TSExcludeDesktopVersion",
                         0,
                         &gdwTSExcludeDesktopVersion,
                         0);

    FastGetProfileDwordW(NULL,
                         PMAP_TABLETPC,
                         L"Installed",
                         0,
                         &SYSMET(TABLETPC),
                         0);

    FastGetProfileDwordW(NULL,
                         PMAP_MEDIACENTER,
                         L"Installed",
                         0,
                         &SYSMET(MEDIACENTER),
                         0);

    /*
     * Initialize SMWP structure.
     */
    if (!AllocateCvr(&gSMWP, 4)) {
        RIPMSG0(RIP_WARNING, "AllocateCvr failed");
        goto ExitWin32UserInitialize;
    }
    LeaveCrit();

    UserAssert(NT_SUCCESS(Status));
    return Status;

ExitWin32UserInitialize:
    LeaveCrit();

    if (NT_SUCCESS(Status)) {
        Status = STATUS_NO_MEMORY;
    }

    RIPMSG1(RIP_WARNING, "UserInitialize failed with Status = 0x%x", Status);
    return Status;
}


/**************************************************************************\
* UserGetDesktopDC
*
* 09-Jan-1992 mikeke created
*    Dec-1993 andreva changed to support desktops.
\**************************************************************************/

HDC UserGetDesktopDC(
    ULONG type,
    BOOL  bAltType,
    BOOL  bValidate)
{
    PETHREAD    Thread;
    HDC         hdc;
    PTHREADINFO pti = PtiCurrentShared();  // This is called from outside the crit sec
    HDEV        hdev  = gpDispInfo->hDev;

    if (bValidate && type != DCTYPE_INFO &&
        IS_THREAD_RESTRICTED(pti, JOB_OBJECT_UILIMIT_HANDLES)) {

        UserAssert(pti->rpdesk != NULL);

        if (!ValidateHwnd(PtoH(pti->rpdesk->pDeskInfo->spwnd))) {
            RIPMSG0(RIP_WARNING,
                    "UserGetDesktopDC fails desktop window validation");
            return NULL;
        }
    }

    /*
     * NOTE:
     * This is a real nasty trick to get both DCs created on a desktop on
     * a different device to work (for the video applet) and to be able
     * to clip DCs that are actually on the same device ...
     */
    if (pti && pti->rpdesk)
        hdev = pti->rpdesk->pDispInfo->hDev;

    /*
     * We want to turn this call that was originally OpenDC("Display", ...)
     * into GetDC null call so this DC will be clipped to the current
     * desktop or else the DC can write to any desktop. Only do this
     * for client apps; let the server do whatever it wants.
     */
    Thread = PsGetCurrentThread();
    if ((type != DCTYPE_DIRECT)  ||
        (hdev != gpDispInfo->hDev) ||
        PsIsSystemThread(Thread) ||
        (PsGetThreadProcess(Thread) == gpepCSRSS)) {

        hdc = GreCreateDisplayDC(hdev, type, bAltType);

    } else {

        PDESKTOP pdesk;

        EnterCrit();

        if (pdesk = PtiCurrent()->rpdesk) {

            hdc = _GetDCEx(pdesk->pDeskInfo->spwnd,
                           NULL,
                           DCX_WINDOW | DCX_CACHE | DCX_CREATEDC);
        } else {
            hdc = NULL;
        }

        LeaveCrit();
    }

    return hdc;
}


/**************************************************************************\
* UserThreadCallout
*
*
* Called by the kernel when a thread starts or ends.
*
* Dec-1993 andreva created.
\**************************************************************************/

NTSTATUS UserThreadCallout(
    IN PETHREAD pEThread,
    IN PSW32THREADCALLOUTTYPE CalloutType)
{
    PTHREADINFO pti;
    NTSTATUS    Status = STATUS_SUCCESS;

    UserAssert(gpresUser != NULL);

    switch (CalloutType) {
        case PsW32ThreadCalloutInitialize:
            TRACE_INIT(("Entering UserThreadCallout PsW32ThreadCalloutInitialize\n"));

            if (gbNoMorePowerCallouts) {
                RIPMSG0(RIP_WARNING, "No more GUI threads allowed");
                return STATUS_UNSUCCESSFUL;
            }

            /*
             * Only create a thread info structure if we're initialized.
             */
            if (gbUserInitialized) {
                EnterCrit();
                UserAssert(gpepCSRSS != NULL);

                /*
                 * Initialize this thread
                 */
                Status = xxxCreateThreadInfo(pEThread);

                LeaveCrit();
            }
            break;

        case PsW32ThreadCalloutExit:

            TRACE_INIT(("Entering UserThreadCallout PsW32ThreadCalloutExit\n"));

            /*
             * If we aren't already inside the critical section, enter it.
             * Because this is the first pass, we remain in the critical
             * section when we return so that our try/finally handlers
             * are protected by the critical section.
             * EnterCrit here before GreUnlockDisplay() provides a pti which
             * may be required if unlocking the display may release some
             * deferred WinEvents, for which a pti is required.
             */
            EnterCrit();

            pti = (PTHREADINFO)PsGetThreadWin32Thread(pEThread);

            /*
             * Mark this thread as in the middle of cleanup. This is useful for
             * several problems in USER where we need to know this information.
             */
            pti->TIF_flags |= TIF_INCLEANUP;

            /*
             * If we died during a full screen switch make sure we cleanup
             * correctly
             */
            FullScreenCleanup();

            /*
             * Cleanup gpDispInfo->hdcScreen - if we crashed while using it,
             * it may have owned objects still selected into it. Cleaning
             * it this way will ensure that gdi doesn't try to delete these
             * objects while they are still selected into this public hdc.
             */

            /*
             * WinStations that haven't gone through the first connect do not
             * have any of the graphics setup.
             */
            if (!gbRemoteSession || gbVideoInitialized) {
                GreCleanDC(gpDispInfo->hdcScreen);
            }

            /*
             * This thread is exiting execution; xxxDestroyThreadInfo cleans
             *  up everything that can go now
             */
            UserAssert(pti == PtiCurrent());
            xxxDestroyThreadInfo();
            LeaveCrit();

            break;
    }

    TRACE_INIT(("Leaving UserThreadCallout\n"));

    return Status;
}

/**************************************************************************\
* NtUserInitialize
*
* 01-Dec-1993 andreva created.
* 01-Dec-1995 BradG   Modified to return handle to Media Change Event
\**************************************************************************/

BOOL TellGdiToGetReady();

NTSTATUS NtUserInitialize(
    IN DWORD   dwVersion,
    IN HANDLE  hPowerRequestEvent,
    IN HANDLE  hMediaRequestEvent)
{
    NTSTATUS Status;

    TRACE_INIT(("Entering NtUserInitialize\n"));

    /*
     * Make sure we're not trying to load this twice.
     */
    if (gpepCSRSS != NULL) {
        RIPMSG0(RIP_WARNING, "Can't initialize more than once");
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Check version number
     */
    if (dwVersion != USERCURRENTVERSION) {
        KeBugCheckEx(WIN32K_INIT_OR_RIT_FAILURE,
                     0,
                     0,
                     dwVersion,
                     USERCURRENTVERSION);
    }

    /*
     * Get the session ID from the EPROCESS structure
     */
    gSessionId = PsGetCurrentProcessSessionId();
    UserAssert(gSessionId == 0 || gbRemoteSession == TRUE);

    Status = InitializePowerRequestList(hPowerRequestEvent);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = InitializeMediaChange(hMediaRequestEvent);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    /*
     * Save the system process structure.
     */
    gpepCSRSS = PsGetCurrentProcess();
    ObReferenceObject(gpepCSRSS);
    if (!TellGdiToGetReady()) {
        RIPMSG0(RIP_WARNING, "TellGdiToGetReady failed");
        Status = STATUS_UNSUCCESSFUL;
        return Status;
    }

    /*
     * Allow CSR to read the screen
     */
    ((PW32PROCESS)PsGetProcessWin32Process(gpepCSRSS))->W32PF_Flags |= (W32PF_READSCREENACCESSGRANTED|W32PF_IOWINSTA);


    Status = UserInitialize();

    TRACE_INIT(("Leaving NtUserInitialize\n"));
    return Status;
}

/**************************************************************************\
* NtUserProcessConnect
*
* 01-Dec-1993   Andreva     Created.
\**************************************************************************/

NTSTATUS NtUserProcessConnect(
    IN HANDLE    hProcess,
    IN OUT PVOID pConnectInfo,
    IN ULONG     cbConnectInfo)
{
    PEPROCESS    Process;
    PUSERCONNECT pucConnect = (PUSERCONNECT)pConnectInfo;
    USERCONNECT  ucLocal;
    NTSTATUS     Status = STATUS_SUCCESS;


    TRACE_INIT(("Entering NtUserProcessConnect\n"));

    if (!pucConnect || (cbConnectInfo != sizeof(USERCONNECT))) {
        return STATUS_UNSUCCESSFUL;
    }

    try {
        ProbeForWrite(pucConnect, cbConnectInfo, sizeof(DWORD));

        ucLocal = *pucConnect;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return GetExceptionCode();
    }

    /*
     * Check client/server versions.
     */
    if (ucLocal.ulVersion != USERCURRENTVERSION) {

        RIPMSG2(RIP_ERROR,
            "Client version %lx > server version %lx\n",
            ucLocal.ulVersion, USERCURRENTVERSION);
        return STATUS_UNSUCCESSFUL;
    }



    if (ucLocal.dwDispatchCount != gDispatchTableValues) {
        RIPMSG2(RIP_ERROR,
            "!!!! Client Dispatch info %lX != Server %lX\n",
            ucLocal.dwDispatchCount, gDispatchTableValues);
    }


    /*
     * Reference the process.
     */
    Status = ObReferenceObjectByHandle(hProcess,
                                       PROCESS_VM_OPERATION,
                                       *PsProcessType,
                                       UserMode,
                                       &Process,
                                       NULL);
    if (!NT_SUCCESS(Status))
        return Status;
    /*
     * Return client's view of shared data.
     */
    EnterCrit();
    Status = InitMapSharedSection(Process, &ucLocal);
    LeaveCrit();

    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_WARNING,
              "Failed to map shared data into client %x, status = %x\n",
              PsGetCurrentProcessId(), Status);
    }

    ObDereferenceObject(Process);

    if (NT_SUCCESS(Status)) {

        try {
             *pucConnect = ucLocal;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            Status = GetExceptionCode();
        }
    }

    TRACE_INIT(("Leaving NtUserProcessConnect\n"));

    return Status;
}

/**************************************************************************\
* xxxUserProcessCallout
*
* 01-Dec-1993   andreva     Created.
\**************************************************************************/

NTSTATUS xxxUserProcessCallout(
    IN PW32PROCESS Process,
    IN BOOLEAN     Initialize)
{
    NTSTATUS     Status = STATUS_SUCCESS;

    if (Initialize) {

        TRACE_INIT(("Entering xxxUserProcessCallout Initialize\n"));

        UserAssert(gpresUser != NULL);
        EnterCrit();

        /*
         * Initialize the important process level stuff.
         */
        Status = xxxInitProcessInfo(Process);

        LeaveCrit();

        if (Status == STATUS_SUCCESS) {

            PEJOB Job = PsGetProcessJob(Process->Process);

            if (Job != NULL &&
                PsGetJobUIRestrictionsClass(Job) != 0) {

                WIN32_JOBCALLOUT_PARAMETERS Parms;

                /*
                 * aquire the job's lock and after that enter the user
                 * critical section.
                 */
                KeEnterCriticalRegion();
                ExAcquireResourceExclusiveLite(PsGetJobLock(Job), TRUE);

                Parms.Job = Job;
                Parms.CalloutType = PsW32JobCalloutAddProcess;
                Parms.Data = Process;

                UserAssert(PsGetJobSessionId(Job) == PsGetProcessSessionId(Process->Process));

                UserJobCallout(&Parms);

                ExReleaseResourceLite(PsGetJobLock(Job));
                KeLeaveCriticalRegion();
            }
        }
    } else {

        int  i;
        PHE  phe;
        PDCE *ppdce;
        PDCE pdce;

        TRACE_INIT(("Entering xxxUserProcessCallout Cleanup\n"));

        UserAssert(gpresUser != NULL);

        EnterCrit();

#if DBG
        if (Process->Process == gpepCSRSS) {

            /*
             * CSRSS should be the last to go ...
             */
            UserAssert(gppiList->ppiNextRunning == NULL);
        }
#endif // DBG

        if (Process->Process && PsGetProcessJob(Process->Process) != NULL) {
            RemoveProcessFromJob((PPROCESSINFO)Process);
        }

        /*
         * DestroyProcessInfo will return TRUE if any threads ever
         * connected. If nothing ever connected, we needn't do
         * this cleanup.
         */
        if (DestroyProcessInfo(Process)) {

            /*
             * See if we can compact the handle table.
             */
            i = giheLast;
            phe = &gSharedInfo.aheList[giheLast];
            while ((phe > &gSharedInfo.aheList[0]) && (phe->bType == TYPE_FREE)) {
                phe--;
                giheLast--;
            }

            /*
             * Scan the DC cache to find any DC's that need to be destroyed.
             */
            for (ppdce = &gpDispInfo->pdceFirst; *ppdce != NULL; ) {

                pdce = *ppdce;
                if (pdce->DCX_flags & DCX_DESTROYTHIS)
                    DestroyCacheDC(ppdce, pdce->hdc);

                /*
                 * Step to the next DC. If the DC was deleted, there
                 * is no need to calculate the address of the next entry.
                 */
                if (pdce == *ppdce)
                    ppdce = &pdce->pdceNext;
            }
        }

        UserAssert(gpresUser != NULL);

        LeaveCrit();
    }

    TRACE_INIT(("Leaving xxxUserProcessCallout\n"));

    return Status;
}

/**************************************************************************\
* UserGetHDEV
*
* Provided as a means for GDI to get a hold of USER's hDev.
*
* 01-Jan-1996   ChrisWil    Created.
\**************************************************************************/

HDEV UserGetHDEV(VOID)
{

    /*
     *  NOTE: This is busted.
     *        This need to return the device for the current desktop.
     *        The graphics device may not be the same for all desktops.
     *        -Andre
     */
    return gpDispInfo->hDev;
}

/**************************************************************************\
* _UserGetGlobalAtomTable
*
* This function is called by the kernel mode global atom manager to get the
* address of the current thread's global atom table.
*
* Pointer to the global atom table for the current thread or NULL if unable
* to access it.
\**************************************************************************/
PVOID UserGlobalAtomTableCallout(
    VOID)
{
    PETHREAD       Thread;
    PTHREADINFO    pti;
    PWINDOWSTATION pwinsta;
    PW32JOB        pW32Job;
    PEJOB          Job;
    PVOID          GlobalAtomTable = NULL;

    Thread = PsGetCurrentThread();
    pti = PtiFromThread(Thread);

    EnterCrit();

    /*
     * For restricted threads access the atom table off of the job object
     */
    if (pti != NULL && IS_THREAD_RESTRICTED(pti, JOB_OBJECT_UILIMIT_GLOBALATOMS)) {
        TAGMSG1(DBGTAG_Callout, "Retrieving global atom table for pti 0x%p", pti);

        pW32Job = pti->ppi->pW32Job;

        UserAssert(pW32Job->pAtomTable != NULL);
        GlobalAtomTable = pW32Job->pAtomTable;

        goto End;
    }

    Job = PsGetProcessJob(PsGetCurrentProcess());

    /*
     * Now handle the case where this is not a GUI thread/process
     * but it is assigned to a job that has JOB_OBJECT_UILIMIT_GLOBALATOMS
     * restrictions set. There is no easy way to convert this thread
     * to GUI.
     */
    if (pti == NULL && Job != NULL &&
        (PsGetJobUIRestrictionsClass(Job) & JOB_OBJECT_UILIMIT_GLOBALATOMS)) {

        /*
         * find the W32JOB in the global list
         */
        pW32Job = gpJobsList;

        while (pW32Job) {
            if (pW32Job->Job == Job) {
                break;
            }
            pW32Job = pW32Job->pNext;
        }

        UserAssert(pW32Job != NULL && pW32Job->pAtomTable != NULL);

        GlobalAtomTable = pW32Job->pAtomTable;

        goto End;
    }

#if DBG
    pwinsta = NULL;
#endif

    if (NT_SUCCESS(ReferenceWindowStation(Thread,
                                    PsGetCurrentProcessWin32WindowStation(),
                                    WINSTA_ACCESSGLOBALATOMS,
                                    &pwinsta,
                                    TRUE))) {
        UserAssert(pwinsta != NULL);

        GlobalAtomTable = pwinsta->pGlobalAtomTable;
    }

End:
    LeaveCrit();

#if DBG
    if (GlobalAtomTable == NULL) {
        RIPMSG1(RIP_WARNING,
                "_UserGetGlobalAtomTable: NULL Atom Table for pwinsta=%#p",
                pwinsta);
    }
#endif

    return GlobalAtomTable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\shadow.c ===
/****************************** Module Header ******************************\
* Module Name: shadow.c
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Drop shadow support.
*
* History:
* 04/12/2000      vadimg      created
* 02/12/2001      msadek      added rounded rectangular shadow support 
*                             for rectangular windows
* 05/08/2001      msadek      rewrote the non rounded corners shadow algorithm
*                             to work well with regional windows, correct visuall effect.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

// shadow horizontal and veritcal offsets
#define CX_SHADOW 5
#define CY_SHADOW 5
#define C_SHADOW CX_SHADOW

// black as the shadow color
#define RGBA_SHADOW 0x00FFFFFF
// white as the transparent color
#define RGBA_TRANSPARENT 0x00000000

typedef struct tagSHADOW *PSHADOW;
typedef struct tagSHADOW {
    PWND pwnd;              // window we're shadowing
    PWND pwndShadow;        // the shadow window we create
    PSHADOW pshadowNext;    // link to the next shadow struct
} SHADOW;

PSHADOW gpshadowFirst;

// Macro used to map gray scale shadow values to alpha blending scale.
#define ALPHA(x) ((255 - (x)) << 24)
#define ARGB(a, r, g, b) (((DWORD)a<<24)|((DWORD)r<<16)|((DWORD)g<<8)|b)

// Gray scale values for the shadow grades
#define GS01 255
#define GS02 254
#define GS03 253
#define GS04 252
#define GS05 250
#define GS06 246
#define GS07 245
#define GS08 242
#define GS09 241
#define GS10 227
#define GS11 217
#define GS12 213
#define GS13 212
#define GS14 199
#define GS15 180 
#define GS16 172 
#define GS17 171
#define GS18 155
#define GS19 144
#define GS20 142

// pre-computed alpha values for the shadow
CONST BYTE grgShadow[C_SHADOW] =             {
                                             GS04, GS09, GS13, GS17, GS20,
                                             };

CONST ULONG TopRightLTR [CY_SHADOW][CX_SHADOW] = {
                                             ALPHA(GS08), ALPHA(GS06), ALPHA(GS05), ALPHA(GS03), ALPHA(GS02), 
                                             ALPHA(GS11), ALPHA(GS10), ALPHA(GS09), ALPHA(GS05), ALPHA(GS02), 
                                             ALPHA(GS15), ALPHA(GS14), ALPHA(GS10), ALPHA(GS07), ALPHA(GS03), 
                                             ALPHA(GS18), ALPHA(GS15), ALPHA(GS11), ALPHA(GS08), ALPHA(GS03), 
                                             ALPHA(GS19), ALPHA(GS16), ALPHA(GS12), ALPHA(GS09), ALPHA(GS04),
                                             };

CONST ULONG RightLTR [CX_SHADOW] =           {
                                             ALPHA(GS20), ALPHA(GS17), ALPHA(GS13), ALPHA(GS09), ALPHA(GS04), 
                                             };

CONST ULONG BottomRightLTR [CY_SHADOW][CX_SHADOW] = {
                                             ALPHA(GS18), ALPHA(GS15), ALPHA(GS11), ALPHA(GS08), ALPHA(GS03), 
                                             ALPHA(GS15), ALPHA(GS14), ALPHA(GS10), ALPHA(GS07), ALPHA(GS03),
                                             ALPHA(GS11), ALPHA(GS10), ALPHA(GS09), ALPHA(GS05), ALPHA(GS02),
                                             ALPHA(GS08), ALPHA(GS06), ALPHA(GS05), ALPHA(GS03), ALPHA(GS02), 
                                             ALPHA(GS03), ALPHA(GS03), ALPHA(GS02), ALPHA(GS02), ALPHA(GS01),
                                             };

CONST ULONG Bottom [CY_SHADOW] =             {
                                             ALPHA(GS20), ALPHA(GS17), ALPHA(GS13), ALPHA(GS09), ALPHA(GS04),     
                                             };

CONST ULONG BottomLeftLTR [CY_SHADOW][CX_SHADOW] = {
                                             ALPHA(GS08), ALPHA(GS11), ALPHA(GS15), ALPHA(GS18), ALPHA(GS19), 
                                             ALPHA(GS06), ALPHA(GS10), ALPHA(GS14), ALPHA(GS15), ALPHA(GS16),
                                             ALPHA(GS05), ALPHA(GS09), ALPHA(GS10), ALPHA(GS11), ALPHA(GS12),
                                             ALPHA(GS03), ALPHA(GS05), ALPHA(GS07), ALPHA(GS08), ALPHA(GS09),
                                             ALPHA(GS02), ALPHA(GS02), ALPHA(GS03), ALPHA(GS03), ALPHA(GS04),
                                             };
/***************************************************************************\
* DrawWindowShadow
*
\***************************************************************************/

BOOL DrawWindowShadow(PWND pwnd, HDC hdc, BOOL fRTL, BOOL fForceComplexRgn, PBOOL pfSimpleRgn)
{
    HRGN hrgn1, hrgn2;
    RECT rc;
    HBRUSH hBrushShadow;
    BOOL bRet = FALSE;

    UserAssert(pfSimpleRgn != NULL);
        
    hrgn1 = GreCreateRectRgn(0, 0, 0, 0);
    hrgn2 = GreCreateRectRgn(0, 0, 0, 0);

    if (hrgn1 == NULL || hrgn2 == NULL) {
        goto Cleanup;
    }

    /*
     * Handle the case when the window is a rectangle or a regional window.
     */
    if (pwnd->hrgnClip == NULL || TestWF(pwnd, WFMAXFAKEREGIONAL)) {
        rc = pwnd->rcWindow;
        OffsetRect(&rc, -rc.left, -rc.top);
        GreSetRectRgn(hrgn1, 0, 0, rc.right, rc.bottom);
        *pfSimpleRgn = TRUE;
    } else {
        GreCombineRgn(hrgn1, pwnd->hrgnClip, NULL, RGN_COPY);
        GreOffsetRgn(hrgn1, -pwnd->rcWindow.left, -pwnd->rcWindow.top);
        *pfSimpleRgn = FALSE;
    }

    /*
     * Offset the window by the shadow offsets and fill the difference
     * with the shadow color. The result will be window's shadow.
     */
    GreCombineRgn(hrgn2, hrgn1, NULL, RGN_COPY);
    if (fRTL) {
        GreOffsetRgn(hrgn1, CX_SHADOW, 0);
        GreOffsetRgn(hrgn2, 0, CY_SHADOW);
    } else {
        GreOffsetRgn(hrgn2, CX_SHADOW, CY_SHADOW);
    }
    bRet = TRUE;
    
    if (!*pfSimpleRgn || fForceComplexRgn) {
        int i;
        BYTE gs;

        for (i = C_SHADOW ; i > 0; i--) {
            gs = grgShadow[i - 1]; 
            hBrushShadow = GreCreateSolidBrush(RGB(gs , gs , gs));
            if (hBrushShadow == NULL) {
                bRet = FALSE;
                goto Cleanup;
            }
            NtGdiFrameRgn(hdc, hrgn2, hBrushShadow, i, i);
            GreDeleteObject(hBrushShadow);
        }
        GreFillRgn(hdc, hrgn1, (HBRUSH)GreGetStockObject(BLACK_BRUSH));
    } else {
        GreCombineRgn(hrgn2, hrgn2, hrgn1, RGN_DIFF);
        GreFillRgn(hdc, hrgn2, (HBRUSH)GreGetStockObject(WHITE_BRUSH));
        }

Cleanup:
    GreDeleteObject(hrgn1);
    GreDeleteObject(hrgn2);
    return bRet;
}

/***************************************************************************\
* DrawTopLogicallyRightCorner
*
* Draw the shadow effect of the top, logically right (visually right for LTR, left for RTL window layout)
* corner of a rounded rectangular shadow.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawTopLogicallyRightCorner(VOID* pBits, LONG cx, LONG cy, BOOL fRTL)
{
    LONG i, j;
    ULONG* ppixel;

    if (fRTL) {
        for (i = CY_SHADOW; i < (2 * CY_SHADOW); i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                 ppixel = (ULONG*)pBits + ((cy - i - 1) * cx) + j;
                *ppixel = TopRightLTR[i - CY_SHADOW][CX_SHADOW - 1 - j];                
            }
        }
    }
    else {
        for (i = CY_SHADOW; i < (2 * CY_SHADOW); i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                 ppixel = (ULONG*)pBits + ((cy - i) * cx) - CX_SHADOW + j;
                *ppixel = TopRightLTR[i - CY_SHADOW][j];
            }
        }
    }
}

/***************************************************************************\
* DrawLogicallyRightSide
*
* Draw the shadow effect of the logically right (visually right for LTR, left for RTL window layout)
* side of a rounded rectangular shadow.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawLogicallyRightSide(VOID* pBits, LONG cx, LONG cy, BOOL fRTL)
{
    LONG i, j;
    ULONG* ppixel;

    if (fRTL) {
        for (i =  (2 * CY_SHADOW); i < (cy - CY_SHADOW); i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                ppixel = (ULONG*)pBits + (cx * ( cy - i -1)) + j;
                *ppixel = RightLTR[CX_SHADOW - 1 - j];
            }    
        }
    } else {
        for (i = (2 * CY_SHADOW); i < (cy - CY_SHADOW); i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                ppixel = (ULONG*)pBits + (cx * ( cy - i -1)) + (cx - CX_SHADOW) + j;
                *ppixel = RightLTR[j];
            }    
        }
    }
}

/***************************************************************************\
* DrawBottomLogicallyRightCorner
*
* Draw the shadow effect of the bottom logically right (visually right for LTR, left for RTL window layout)
* side of a rounded rectangular shadow.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawBottomLogicallyRightCorner(VOID* pBits, LONG cx, BOOL fRTL)
{
    LONG i, j;
    ULONG* ppixel;

    if (fRTL) {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                ppixel = (ULONG*)pBits + ((CY_SHADOW - i - 1) * cx) + j;
                *ppixel = BottomRightLTR[i][CX_SHADOW - 1 - j];
            }    
        }
    } else {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                 ppixel = (ULONG*)pBits + ((CY_SHADOW - i) * cx) - CX_SHADOW + j;
                *ppixel = BottomRightLTR[i][j];
            }    
        }
    }
}

/***************************************************************************\
* DrawBottomSide
*
* Draw the shadow effect of the bottom side of a rounded rectangular shadow.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawBottomSide(VOID* pBits, LONG cx, BOOL fRTL)
{
    LONG i, j;
    ULONG* ppixel;

    if (fRTL) {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j = CX_SHADOW; j < (cx - (2 * CX_SHADOW)); j++) {
                 ppixel = (ULONG*)pBits + ((CY_SHADOW - i - 1) * cx) + j;
                *ppixel = Bottom[i];
            }    
        }
    } else {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j =  (2 * CX_SHADOW); j < (cx - CX_SHADOW); j++) {
                 ppixel = (ULONG*)pBits + ((CY_SHADOW - i - 1) * cx) + j;
                *ppixel = Bottom[i];
            }    
        }
    }
}

/***************************************************************************\
* DrawBottomLogicallyLeftCorner
*
* Draw the shadow effect of the bottom logically left (visually left for LTR, right for RTL window layout)
* side of a rounded rectangular shadow.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawBottomLogicallyLeftCorner(VOID* pBits, LONG cx, BOOL fRTL)
{
    LONG i, j;
    ULONG* ppixel;

    if (fRTL) {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                 ppixel = (ULONG*)pBits + ((CY_SHADOW - i) * cx) - (2 * CX_SHADOW) + j;
                *ppixel = BottomLeftLTR[i][CX_SHADOW - 1 -j];
            }    
        }
        
    } else {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                 ppixel = (ULONG*)pBits + ((CY_SHADOW - i - 1) * cx) + CX_SHADOW + j;
                *ppixel = BottomLeftLTR[i][j];
            }    
        }
    }
}

/***************************************************************************\
* DrawRoundedRectangularShadow
* Draw a rounded rectangular shadow effect.
* Does not search for shadow pixel location in the bitmap but rather assumes
* it to be the corners of the bitmap.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawRoundedRectangularShadow(VOID* pBits, LONG cx, LONG cy, BOOL fRTL)
{
    DrawTopLogicallyRightCorner(pBits, cx, cy, fRTL);
    DrawLogicallyRightSide(pBits, cx, cy,  fRTL);
    DrawBottomLogicallyRightCorner(pBits, cx, fRTL);
    DrawBottomSide(pBits, cx, fRTL);
    DrawBottomLogicallyLeftCorner(pBits, cx, fRTL);
}

/***************************************************************************\
* DrawRegionalShadow
* Search for shadow pixel location in the bitmap (those with gray scale in grgShadow
* and adjust the alpha values.
*
*
* History:
* 05/08/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawRegionalShadow(VOID* pBits, LONG cx, LONG cy)
{
    LONG i, j, k;
    ULONG* pixel;    
    BYTE gs;

    for (i = 0; i < cy; i++) {
        for (j = 0; j < cx; j++) {
            pixel = (ULONG*)pBits + (cy - 1 - i) * cx + j;
            for (k = 0; k < C_SHADOW; k++) {
                gs = grgShadow[k];
                if (*pixel == ARGB(0, gs, gs, gs)) {
                    *pixel = ALPHA(gs);
                }
            }
        }
    }
}

/***************************************************************************\
* GenerateWindowShadow
*
\***************************************************************************/

HBITMAP GenerateWindowShadow(PWND pwnd, HDC hdc)
{
    BITMAPINFO bmi;
    HBITMAP hbm;
    VOID* pBits;
    LONG cx, cy;
    RECT rc;
    BOOL fRTL = TestWF(pwnd, WEFLAYOUTRTL);
    BOOL fSimpleRgn, fForceComplexRgn = FALSE;

    rc = pwnd->rcWindow;
    OffsetRect(&rc, -rc.left, -rc.top);
    
    /*
     * Doesn't make sense to have a shadow for a window with zero height or width
     */
    if (IsRectEmpty(&rc)) {
        return NULL;
    }

    rc.right += CX_SHADOW;
    rc.bottom += CY_SHADOW;

    cx = rc.right;
    cy = rc.bottom;

    /*
     * Create the DIB section.
     */
    RtlZeroMemory(&bmi, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = cx;
    bmi.bmiHeader.biHeight = cy;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    hbm = GreCreateDIBitmapReal(hdc, 0, NULL, &bmi, DIB_RGB_COLORS,
            sizeof(bmi), 0, NULL, 0, NULL, 0, 0, &pBits);

    if (hbm == NULL) {
        return NULL;
    }

    /*
     * Fill the dib section with the transparent color and then
     * draw the shadow on top of it.
     */
    GreSelectBitmap(hdc, hbm);
    FillRect(hdc, &rc, (HBRUSH)GreGetStockObject(BLACK_BRUSH));

    /*
     * Rectangular window shadow assumes the bitmap dimension to be greater than
     * or equal 2 * CX_SHADOW and 2 * CY_SHADOW else it will overrun bitmap buffer.
     * and in order to get a real rectangular shadow, the dimension should be 3 * CX_SHADOW
     * amd 3 * CY_SHADOW.
     */
    if ( (cx < 3 * CX_SHADOW) || (cy < 3 * CY_SHADOW)) {
        fForceComplexRgn = TRUE;
    } 
    
    if (!DrawWindowShadow(pwnd, hdc, fRTL, fForceComplexRgn, &fSimpleRgn)) {
        return NULL;
    }
        
    if (fSimpleRgn && !fForceComplexRgn)  {
        DrawRoundedRectangularShadow(pBits, cx, cy, fRTL);
        return hbm;
    }
    
    DrawRegionalShadow(pBits, cx, cy);
    return hbm;
}

/***************************************************************************\
* FindShadow
*
\***************************************************************************/

PSHADOW FindShadow(PWND pwnd)
{
    PSHADOW pshadow;

    for (pshadow = gpshadowFirst; pshadow != NULL; pshadow = pshadow->pshadowNext) {
        if (pshadow->pwnd == pwnd) {
            return pshadow;
        }
    }
    return NULL;
}

/***************************************************************************\
* WindowHasShadow
*
\***************************************************************************/

BOOL WindowHasShadow(PWND pwnd)
{
    BOOL fHasShadow = FALSE;

    if (TestWF(pwnd, WFVISIBLE)) {
        PSHADOW pshadow = FindShadow(pwnd);
        fHasShadow = (pshadow != NULL);
    } else {
        /*
         * The window isn't currently visible, so there is no shadow window.
         * We need to return if the window *would* have a shadow if it were
         * shown.
         */
        if (TestCF(pwnd, CFDROPSHADOW)) {
            fHasShadow = TRUE;

            if ((GETFNID(pwnd) == FNID_MENU) && (!TestALPHA(MENUFADE)) && TestEffectUP(MENUANIMATION)) {
                fHasShadow = FALSE;
            }
        }

        if (!TestALPHA(DROPSHADOW)) {
            fHasShadow = FALSE;
        }
    }

    return fHasShadow;
}

/***************************************************************************\
* ApplyShadow
*
\***************************************************************************/

BOOL ApplyShadow(PWND pwnd, PWND pwndShadow)
{
    POINT pt, ptSrc = {0, 0};
    SIZE size;
    BLENDFUNCTION blend;
    HDC hdcShadow;
    HBITMAP hbmShadow;
    BOOL fRet;

    hdcShadow = GreCreateCompatibleDC(gpDispInfo->hdcScreen);

    if (hdcShadow == NULL) {
        return FALSE;
    }

    hbmShadow = GenerateWindowShadow(pwnd, hdcShadow);
    if (hbmShadow == NULL) {
        GreDeleteDC(hdcShadow);
        return FALSE;
    }

    pt.x = pwnd->rcWindow.left;
    pt.y = pwnd->rcWindow.top;
    size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left + CX_SHADOW;
    size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top + CY_SHADOW;

    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        pt.x -= CX_SHADOW;
    }

    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = 0;
    blend.AlphaFormat = AC_SRC_ALPHA;
    blend.SourceConstantAlpha = 255;

    fRet = _UpdateLayeredWindow(pwndShadow, NULL, &pt, &size, hdcShadow, &ptSrc, 0,
            &blend, ULW_ALPHA);

    GreDeleteDC(hdcShadow);
    GreDeleteObject(hbmShadow);

    return fRet;
}

/***************************************************************************\
* MoveShadow
*
\***************************************************************************/

VOID MoveShadow(PWND pwnd)
{
    PSHADOW pshadow = FindShadow(pwnd);
    POINT pt;

    if (pshadow == NULL) {
        return;
    }

    pt.x = pwnd->rcWindow.left;
    pt.y = pwnd->rcWindow.top;

    _UpdateLayeredWindow(pshadow->pwndShadow, NULL, &pt, NULL, NULL, NULL, 0, NULL, 0);
}

/***************************************************************************\
* UpdateShadowShape
*
\***************************************************************************/

VOID UpdateShadowShape(PWND pwnd)
{
    PSHADOW pshadow = FindShadow(pwnd);

    if (pshadow == NULL) {
        return;
    }

    ApplyShadow(pshadow->pwnd, pshadow->pwndShadow);
}

/***************************************************************************\
* xxxUpdateShadowZorder
*
\***************************************************************************/

VOID xxxUpdateShadowZorder(PWND pwnd)
{
    TL tlpwnd;
    PWND pwndShadow;
    PSHADOW pshadow = FindShadow(pwnd);

    if (pshadow == NULL) {
        return;
    }

    pwndShadow = pshadow->pwndShadow;

    if (TestWF(pwnd, WEFTOPMOST) && !TestWF(pwndShadow, WEFTOPMOST)) {
        SetWF(pwndShadow, WEFTOPMOST);
    } else if (!TestWF(pwnd, WEFTOPMOST) && TestWF(pwndShadow, WEFTOPMOST)) {
        ClrWF(pwndShadow, WEFTOPMOST);
    }

    ThreadLock(pwndShadow, &tlpwnd);

    xxxSetWindowPos(pwndShadow, pwnd, 0, 0, 0, 0, SWP_NOACTIVATE |
            SWP_NOSIZE | SWP_NOMOVE);

    ThreadUnlock(&tlpwnd);

}
/***************************************************************************\
* xxxRemoveShadow
*
* Given the shadowed window, destroy the shadow window, cleanup the
* memory used by the shadow structure and remove it from the list.
\***************************************************************************/

VOID xxxRemoveShadow(PWND pwnd)
{
    PSHADOW* ppshadow;
    PSHADOW pshadow;
    PWND pwndT;

    CheckLock(pwnd);

    ppshadow = &gpshadowFirst;

    while (*ppshadow != NULL) {

        pshadow = *ppshadow;

        if (pshadow->pwnd == pwnd) {

            pwndT = pshadow->pwndShadow;

            *ppshadow = pshadow->pshadowNext;
            UserFreePool(pshadow);

            xxxDestroyWindow(pwndT);

            break;
        }

        ppshadow = &pshadow->pshadowNext;
    }
}

/***************************************************************************\
* RemoveShadow
*
* Given a shadow structure pointer, search for it in the list and remove it
\***************************************************************************/

VOID RemoveShadow(PSHADOW pshadow)
{
    PSHADOW* ppshadow;
    PSHADOW pshadowT;
    ppshadow = &gpshadowFirst;

    while (*ppshadow != NULL) {

        pshadowT = *ppshadow;

        if (pshadowT == pshadow) {
            *ppshadow = pshadowT->pshadowNext;
            UserFreePool(pshadowT);
            break;
        }

        ppshadow = &pshadowT->pshadowNext;
    }
}

/***************************************************************************\
* CleanupShadow
*
* Given the shadow window, remove the shadow structure from the list and
* cleanup the memory used by the shadow structure.
\***************************************************************************/

VOID CleanupShadow(PWND pwndShadow)
{
    PSHADOW* ppshadow;
    PSHADOW pshadow;

    CheckLock(pwndShadow);

    ppshadow = &gpshadowFirst;

    while (*ppshadow != NULL) {

        pshadow = *ppshadow;

        if (pshadow->pwndShadow == pwndShadow) {
        
            *ppshadow = pshadow->pshadowNext;
            UserFreePool(pshadow);
            
            break;
        }

        ppshadow = &pshadow->pshadowNext;
    }
}
/***************************************************************************\
* xxxAddShadow
*
\***************************************************************************/

BOOL xxxAddShadow(PWND pwnd)
{
    PWND pwndShadow;
    DWORD ExStyle;
    TL tlpwnd;
    TL tlpool;
    PSHADOW pshadow;

    CheckLock(pwnd);

    if (!TestALPHA(DROPSHADOW)) {
        return FALSE;
    }

    if (FindShadow(pwnd)) {
        return TRUE;
    }

    if ((pshadow = (PSHADOW)UserAllocPool(sizeof(SHADOW), TAG_SHADOW)) == NULL) {
        return FALSE;
    }

    ThreadLockPool(PtiCurrent(), pshadow, &tlpool);

    ExStyle = WS_EX_TOOLWINDOW | WS_EX_LAYERED | WS_EX_TRANSPARENT;
    if (TestWF(pwnd, WEFTOPMOST)) {
        ExStyle |= WS_EX_TOPMOST;
    }

    pwndShadow = xxxNVCreateWindowEx(ExStyle, (PLARGE_STRING)gatomShadow,
            NULL, WS_POPUP, 0, 0, 0, 0, NULL, NULL, hModuleWin, NULL, WINVER);

    if (pwndShadow == NULL || !ApplyShadow(pwnd, pwndShadow)) {
        UserFreePool(pshadow);
        ThreadUnlockPool(PtiCurrent(), &tlpool);

        if (pwndShadow != NULL) {
            ThreadLock(pwndShadow, &tlpwnd);
            xxxDestroyWindow(pwndShadow);
            ThreadUnlock(&tlpwnd);
        }

        return FALSE;
    }

    pshadow->pshadowNext = gpshadowFirst;
    gpshadowFirst = pshadow;

    pshadow->pwnd = pwnd;
    pshadow->pwndShadow = pwndShadow;

    /* 
     * Since we added it the global list, we need to change the way
     * we lock its pool.
     */
    ThreadUnlockPool(PtiCurrent(), &tlpool);
    ThreadLockPoolCleanup(PtiCurrent(), pshadow, &tlpool, RemoveShadow);
    ThreadLock(pwndShadow, &tlpwnd);

    xxxSetWindowPos(pwndShadow, pwnd, 0, 0, 0, 0, SWP_SHOWWINDOW |
            SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);

    ThreadUnlock(&tlpwnd);

    ThreadUnlockPool(PtiCurrent(), &tlpool);

    return TRUE;
}

/***************************************************************************\
* FAnyShadows
*
\***************************************************************************/

BOOL FAnyShadows(VOID)
{
    return (gpshadowFirst != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(WINCORE_PATH)\core.inc

MAJORCOMP=user
MINORCOMP=kernel

TARGETTYPE=LIBRARY

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -DUNICODE -D_USER32_       \
          -DNTOS_KERNEL_RUNTIME=1 -D_NTDRIVER_ -D_NTSYSTEM_DRIVER_  \
	  -DNO_INTERLOCKED_INTRINSICS

!IFDEF USER_PERFORMANCE
C_DEFINES=$(C_DEFINES) -DUSER_PERFORMANCE
!ENDIF

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..;                                     \
         $(NTUSER_PATH)\inc;                     \
         $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O); \
         $(NTGDI_PATH)\ntgdi\inc;                \
         $(WINCORE_PATH)\w32inc;                 \
         $(WINCORE_PATH)\w32inc\$(O);            \
         $(BASE_INC_PATH)

NT_UP=0

TARGETNAME=userk
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

NTTARGETFILE0=$(O)\strid.h $(O)\msg00001.bin $(O)\strid.rc $(O)\callcf.c $(O)\kbdus.c

SOURCES=..\access.c   \
        ..\acons.c    \
        ..\atom.c     \
        ..\base.c     \
        ..\calcclrc.c \
        ..\caption.c  \
        ..\capture.c  \
        ..\caret.c    \
        ..\class.c    \
        ..\classchg.c \
        ..\cleanup.c  \
        ..\clipbrd.c  \
        ..\createw.c  \
        ..\cursor.c   \
        ..\dc.c       \
        ..\ddemlsvr.c \
        ..\ddetrack.c \
        ..\debug.c    \
        ..\desktop.c  \
        ..\dragdrop.c \
        ..\drawfrm.c  \
        ..\dtbitmap.c \
        ..\dwp.c      \
        ..\enumwin.c  \
        ..\event.c    \
        ..\ex.c       \
        ..\exitwin.c  \
        ..\fekbd.c    \
        ..\focusact.c \
        ..\fullscr.c  \
        ..\getset.c   \
        ..\ghost.c    \
        ..\globals.c  \
        ..\handtabl.c \
        ..\heap.c     \
        ..\help.c     \
        ..\hidevice.c \
        ..\hooks.c    \
        ..\hotkeys.c  \
        ..\hungapp.c  \
        ..\icons.c    \
        ..\imehotky.c \
        ..\inctlpan.c \
        ..\init.c     \
        ..\input.c    \
        ..\job.c      \
        ..\kbd.c      \
        $(O)\kbdus.c  \
        ..\kbdlyout.c \
        ..\keyboard.c \
        ..\keyconv.c  \
        ..\libmgmt.c  \
        ..\loadbits.c \
        ..\logon.c    \
        ..\menu.c     \
        ..\menudd.c   \
        ..\metrics.c  \
        ..\minmax.c   \
        ..\miscutil.c \
        ..\mnaccel.c  \
        ..\mnapi.c    \
        ..\mnchange.c \
        ..\mncomput.c \
        ..\mncreate.c \
        ..\mndraw.c   \
        ..\mndstry.c  \
        ..\mngray.c   \
        ..\mnkey.c    \
        ..\mnloop.c   \
        ..\mnpopup.c  \
        ..\mnsel.c    \
        ..\mnstate.c  \
        ..\mnsys.c    \
        ..\movesize.c \
        ..\msgbeep.c  \
        ..\multimon.c \
        ..\newmouse.c \
        ..\ntimm.c    \
        ..\ntinput.c  \
        ..\ntstubs.c  \
        ..\paint.c    \
        ..\palette.c  \
        ..\pnp.c      \
        ..\pool.c     \
        ..\power.c    \
        ..\profile.c  \
        ..\queue.c    \
        ..\random.c   \
        ..\rare.c     \
        ..\sbapi.c    \
        ..\sbctl.c    \
        ..\scrollw.c  \
        ..\security.c \
        ..\sendmsg.c  \
        ..\server.c   \
        ..\service.c  \
        ..\shadow.c   \
        ..\showwin.c  \
        ..\sirens.c   \
        ..\snapshot.c \
        ..\spb.c      \
        ..\sprite.c   \
        ..\srvhook.c  \
        ..\srvmsg.c   \
        ..\ssend.c    \
        ..\swp.c      \
        ..\syscmd.c   \
        ..\sysmet.c   \
        ..\taskman.c  \
        ..\text.c     \
        ..\timers.c   \
        ..\tmswitch.c \
        ..\tooltips.c \
        ..\tounicod.c \
        ..\update.c   \
        ..\usergdi.c  \
        ..\validate.c \
        ..\visrgn.c   \
        ..\winable.c  \
        ..\winable2.c \
        ..\winhtky.c  \
        ..\winloop2.c \
        ..\winmgr.c   \
        ..\winprop.c  \
        ..\winsta.c   \
        ..\winwhere.c \
        ..\wmicon.c   \
        ..\xlate.c    \
        $(O)\callcf.c


UMTYPE=windows
UMTEST=
UMLIBS=

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\service.c ===
/**************************** Module Header ********************************\
* Module Name: service.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Service Support Routines
*
* History:
* 12-22-93 JimA         Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* xxxConnectService
*
* Open the windowstation assigned to the service logon session. If no
* windowstation exists, create the windowstation and a default desktop.
*
* History:
* 12-23-93 JimA         Created.
\***************************************************************************/
HWINSTA xxxConnectService(
    PUNICODE_STRING pstrWinSta,
    HDESK *phdesk)
{
    NTSTATUS Status;
    HANDLE hToken;
    ULONG ulLength;
    PTOKEN_USER ptuService;
    PSECURITY_DESCRIPTOR psdService;
    PSID psid;
    PACCESS_ALLOWED_ACE paceService = NULL, pace;
    OBJECT_ATTRIBUTES ObjService;
    HWINSTA hwinsta;
    UNICODE_STRING strDesktop;
    TL tlPoolSdService, tlPoolAceService, tlPoolToken;

    /*
     * Open the token of the service.
     */
    Status = OpenEffectiveToken(&hToken);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "ConnectService: Could not open process/thread token (0x%X)", Status);
        return NULL;
    }

    /*
     * Get the user SID assigned to the service.
     */
    ptuService = NULL;
    paceService = NULL;
    psdService = NULL;
    hwinsta = NULL;
    ZwQueryInformationToken(hToken, TokenUser, NULL, 0, &ulLength);
    ptuService = (PTOKEN_USER)UserAllocPool(ulLength, TAG_TOKEN);
    if (ptuService == NULL) {
        RIPMSG1(RIP_WARNING, "ConnectService: Can't alloc buffer (size=%d) for token info", ulLength);
        ZwClose(hToken);
        goto sd_error;
    }
    Status = ZwQueryInformationToken(hToken, TokenUser, ptuService,
            ulLength, &ulLength);
    ZwClose(hToken);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "ConnectService: QueryInformationToken failed (0x%X)", Status);
        goto sd_error;
    }
    psid = ptuService->User.Sid;

    /*
     * Create ACE list.
     */
    paceService = AllocAce(NULL, ACCESS_ALLOWED_ACE_TYPE, 0,
            WINSTA_CREATEDESKTOP | WINSTA_READATTRIBUTES |
                WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS |
                WINSTA_ACCESSCLIPBOARD | STANDARD_RIGHTS_REQUIRED,
            psid, &ulLength);
    if (paceService == NULL) {
        RIPMSG0(RIP_WARNING, "ConnectService: AllocAce for WindowStation attributes failed");
        goto sd_error;
    }
    pace = AllocAce(paceService, ACCESS_ALLOWED_ACE_TYPE, OBJECT_INHERIT_ACE |
            INHERIT_ONLY_ACE | NO_PROPAGATE_INHERIT_ACE,
            DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS | DESKTOP_ENUMERATE |
                DESKTOP_CREATEWINDOW | DESKTOP_CREATEMENU | DESKTOP_HOOKCONTROL |
                STANDARD_RIGHTS_REQUIRED,
            psid, &ulLength);
    if (pace == NULL) {
        RIPMSG0(RIP_WARNING, "ConnectService: AllocAce for Desktop Attributes failed");
        goto sd_error;
    }
    paceService = pace;
    pace = AllocAce(pace, ACCESS_ALLOWED_ACE_TYPE, 0,
            WINSTA_ENUMERATE,
            SeExports->SeAliasAdminsSid, &ulLength);
    if (pace == NULL) {
        RIPMSG0(RIP_WARNING, "ConnectService: AllocAce for admin WinSta enumerate failed");
        goto sd_error;
    }
    paceService = pace;
    pace = AllocAce(pace, ACCESS_ALLOWED_ACE_TYPE, OBJECT_INHERIT_ACE |
            INHERIT_ONLY_ACE | NO_PROPAGATE_INHERIT_ACE,
            DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS | DESKTOP_ENUMERATE,
            SeExports->SeAliasAdminsSid, &ulLength);
    if (pace == NULL) {
        RIPMSG0(RIP_WARNING, "ConnectService: AllocAce for admin Desktop access failed");
        goto sd_error;
    }
    paceService = pace;

    /*
     * Initialize the SD
     */
    psdService = CreateSecurityDescriptor(paceService, ulLength, FALSE);
    if (psdService == NULL) {
        RIPMSG0(RIP_WARNING, "ConnectService: CreateSecurityDescriptor failed");
        goto sd_error;
    }

    ThreadLockPool(PtiCurrent(), ptuService,  &tlPoolToken);
    ThreadLockPool(PtiCurrent(), paceService, &tlPoolAceService);
    ThreadLockPool(PtiCurrent(), psdService,  &tlPoolSdService);

    /*
     * The windowstation does not exist and must be created.
     */
    try {
        InitializeObjectAttributes(&ObjService,
                                   pstrWinSta,
                                   OBJ_OPENIF,
                                   NULL,
                                   psdService);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
          Status = GetExceptionCode();
    }

    if (NT_SUCCESS(Status)) {
        hwinsta = xxxCreateWindowStation(&ObjService,
                                         KernelMode,
                                         MAXIMUM_ALLOWED,
                                         NULL,
                                         0,
                                         NULL,
                                         NULL,
                                         0);
    }

    if (hwinsta != NULL) {
        TRACE_INIT(("Service windowstation created\n"));

        /*
         * We have the windowstation, now create the desktop.  The security
         * descriptor will be inherited from the windowstation.  Save the
         * winsta handle because the access struct may be moved by the
         * desktop creation.
         */
        RtlInitUnicodeString(&strDesktop, TEXT("Default"));
        InitializeObjectAttributes(&ObjService, &strDesktop,
                OBJ_OPENIF | OBJ_CASE_INSENSITIVE, hwinsta, NULL);

        *phdesk = xxxCreateDesktop(&ObjService,
                                   KernelMode,
                                   NULL,
                                   NULL,
                                   0,
                                   MAXIMUM_ALLOWED);
        if (*phdesk == NULL) {
            /*
             * The creation failed so close the windowstation and leave.
             */
            RIPMSGF0(RIP_WARNING, "CreateDesktop('Default') failed.");

            ZwClose(hwinsta);
            hwinsta = NULL;
        } else {
            TRACE_INIT(("Default desktop in Service windowstation created\n"));
        }
    } else {
        *phdesk = NULL;
    }

    ThreadUnlockPool(PtiCurrent(), &tlPoolSdService);
    ThreadUnlockPool(PtiCurrent(), &tlPoolAceService);
    ThreadUnlockPool(PtiCurrent(), &tlPoolToken);

sd_error:
    if (ptuService != NULL) {
        UserFreePool(ptuService);
    }

    if (paceService != NULL) {
        UserFreePool(paceService);
    }

    if (psdService != NULL) {
        UserFreePool(psdService);
    }

    return hwinsta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\spb.c ===
/**************************** Module Header ********************************\
* Module Name: spb.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Save Popup Bits (SPB) support routines.
*
* History:
* 18-Jul-1991 DarrinM   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* FBitsTouch
*
* This routine checkes to see if the rectangle *lprcDirty in pwndDirty
* invalidates any bits in the SPB structure at *pspb.
*
* pwndDirty "touches" pwndSpb if:
*   1. pwndDirty is visible AND:
*   2. pwndDirty == or descendent of pwndSpb, and pwndSpb is a LOCKUPDATE
*      spb.
*   3. pwndDirty is pwndSpb's parent.  (e.g., drawing in the
*      desktop window, behind a dialog box).
*   4. A parent of pwndDirty is the sibling of pwndSpb, and the parent
*      is lower in the zorder.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL FBitsTouch(
    PWND   pwndDirty,
    LPRECT lprcDirty,
    PSPB   pspb,
    DWORD  flags)
{
    PWND    pwndSpb,
            pwndDirtySave;
    int     fSpbLockUpdate;

    /*
     * When no window is passed in, skip all the window-related stuff and
     * go directly to check the rectangle.
     */
    if (pwndDirty == NULL)
        goto ProbablyTouch;

    /*
     * If pwndDirty or its parents are invisible,
     * then it can't invalidate any SPBs
     */
    if (!IsVisible(pwndDirty))
        return FALSE;

    pwndSpb = pspb->spwnd;
    fSpbLockUpdate = pspb->flags & SPB_LOCKUPDATE;
    if (fSpbLockUpdate) {

        /*
         * If the guy is drawing through a locked window via
         * DCX_LOCKWINDOWUPDATE and the spb is a LOCKUPDATE SPB, then
         * don't do any invalidation of the SPB.  Basically we're trying
         * to avoid having the tracking rectangle invalidate the SPB
         * since it's drawn via a WinGetClipPS() ps.
         */
        if (flags & DCX_LOCKWINDOWUPDATE)
            return FALSE;
    }

    /*
     * If pwndDirty is pwndSpb's immediate parent (e.g., drawing in the
     * desktop window behind a dialog box), then we may touch: do the
     * intersection.
     */
    if (pwndDirty == pwndSpb->spwndParent)
        goto ProbablyTouch;

    /*
     * We know that pwndDirty != pwndSpb->spwndParent.
     * Now find the parent of pwndDirty that is a sibling of pwndSpb.
     */
    pwndDirtySave = pwndDirty;

    while (pwndSpb->spwndParent != pwndDirty->spwndParent) {
        pwndDirty = pwndDirty->spwndParent;

        /*
         * If we get to the top of the tree, it's because:
         *  1.  pwndSpb == pwndDesktop
         *  2.  pwndDirty is a parent of pwndSpb
         *  3.  pwndDirty == pwndDesktop
         *  4.  pwndDirty is a child of some other desktop
         *  5.  pwndSpb and pwndDirty aren't siblings
         *
         * In all these cases, pwndDirty can't touch pwndSpb.
         */
        if (pwndDirty == NULL)
            return FALSE;
    }

    /*
     * If pwndSpb is the same as pwndDirty, then it will invalidate
     * only if the SPB is LOCKUPDATE.
     *
     * Non-LOCKUPDATE SPB's can't be invalidated by their
     * own windows, but LOCKUPDATE SPB's can.
     */
    if (pwndDirty == pwndSpb) {
        if (!fSpbLockUpdate)
            return FALSE;

        /*
         * If pwndSpb itself was drawn in, then we can't
         * try subtracting children.
         */
        if (pwndDirtySave == pwndSpb)
            goto ProbablyTouch;

        /*
         * We want to calculate the immediate child of pwndSpb
         * on the path from pwndDirty to pwndSpb, so we can
         * subtract off the rectangles of the children of pwndSpb
         * in case there are intervening windows.
         */
        while (pwndSpb != pwndDirtySave->spwndParent) {
            pwndDirtySave = pwndDirtySave->spwndParent;
        }

        /*
         * The SubtractIntervening loop subtracts the
         * window rects starting from pwndSpb and ending
         * at the window before pwndDirty, so set up
         * our variables appropriately.
         */
        pwndDirty = pwndDirtySave;
        pwndSpb = pwndSpb->spwndChild;

    } else {
        /*
         * Now compare the Z order of pwndDirty and pwndSpb.
         * If pwndDirty is above pwndSpb, then the SPB can't be touched.
         */
        pwndDirtySave = pwndDirty;

        /*
         * Compare the Z order by searching starting at pwndDirty,
         * moving DOWN the Z order list.  If we encounter pwndSpb,
         * then pwndDirty is ABOVE or EQUAL to pwndSpb.
         */
        for ( ; pwndDirty != NULL; pwndDirty = pwndDirty->spwndNext) {
            if (pwndDirty == pwndSpb) {
                return FALSE;
            }
        }
        pwndDirty = pwndDirtySave;

        /*
         * We don't want to subtract the SPB window itself
         */
        pwndSpb = pwndSpb->spwndNext;
    }

    /*
     * Subtract Intervening rectangles.
     * pwndDirty is below pwndSpb.  If there are any intervening
     * windows, subtract their window rects from lprcDirty to see if pwndDirty
     * is obscured.
     */
    while (pwndSpb && pwndSpb != pwndDirty) {
        /*
         * If this window has a region selected, hwndDirty may draw through
         * it even though it has a full rectangle! We can't subtract its
         * rect from the dirty rect in this case.
         */
        if (    TestWF(pwndSpb, WFVISIBLE) &&
                !pwndSpb->hrgnClip &&
                !TestWF(pwndSpb, WEFLAYERED) &&
                !SubtractRect(lprcDirty, lprcDirty, &pwndSpb->rcWindow)) {

            return FALSE;
        }

        pwndSpb = pwndSpb->spwndNext;
    }

    // fall through
ProbablyTouch:

    /*
     * If the rectangles don't intersect, there is no invalidation.
     * (we make this test relatively late because it's expensive compared
     * to the tests above).
     * Otherwise, *lprcDirty now has the area of bits not obscured
     * by intervening windows.
     */

    return IntersectRect(lprcDirty, lprcDirty, &pspb->rc);
}

/***************************************************************************\
* SpbCheckRect2
*
* Subtracts lprc in pwnd from pspb's region if lprc touches pspb.
*
* Returns FALSE if there is a memory allocation error, or if lprc
* contains psbp's region; otherwise, returns TRUE.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL SpbCheckRect2(
    PSPB   pspb,
    PWND   pwnd,
    LPRECT lprc,
    DWORD  flags)
{
    RECT rcTouch = *lprc;

    /*
     * See if lprc touches any saved bits, taking into account what
     * window the drawing is occuring in.
     */
    if (FBitsTouch(pwnd, &rcTouch, pspb, flags)) {

        /*
         * If no SPB region exists, make one for the whole thing
         */
        if (!pspb->hrgn && SetOrCreateRectRgnIndirectPublic(
                &pspb->hrgn, &pspb->rc) == ERROR) {

            goto Error;
        }

        /*
         * Subtract the rectangle that is invalid from the SPB region
         */
        SetRectRgnIndirect(ghrgnSCR, &rcTouch);
        switch (SubtractRgn(pspb->hrgn, pspb->hrgn, ghrgnSCR)) {
        case ERROR:
        case NULLREGION:
            goto Error;

        default:
            break;
        }
    }

    return TRUE;

Error:
    FreeSpb(pspb);
    return FALSE;
}

/***************************************************************************\
* SpbTransfer
*
* Validate the SPB rectangle from a window's update region, after
* subtracting the window's update region from the SPB.
*
* NOTE: Although SpbTransfer calls xxxInternalInvalidate, it doesn't
* specify any flags that will cause immediate updating.  Therefore the
* critsect isn't left and we don't consider this an 'xxx' routine.
* Also, no revalidation is necessary.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL SpbTransfer(
    PSPB pspb,
    PWND pwnd,
    BOOL fChildren)
{
    RECT rc;

    /*
     * If the window has an update region...
     */
    if (pwnd->hrgnUpdate != NULL) {

        /*
         * Invalidate its update region rectangle from the SPB
         */
        if (pwnd->hrgnUpdate > HRGN_FULL) {
            GreGetRgnBox(pwnd->hrgnUpdate, &rc);
        } else {
            rc = pwnd->rcWindow;
        }

        /*
         * Intersect the update region bounds with the parent client rects,
         * to make sure we don't invalidate more than we need to.  If
         * nothing to validate, return TRUE (because SPB is probably not empty)
         * These RDW_ flags won't cause the critical section to be left, nor
         * will they provoke WinEvent notifications.
         */
        if (IntersectWithParents(pwnd, &rc)) {
            BEGINATOMICCHECK();

            xxxInternalInvalidate(pwnd,
                                  ghrgnSPB2,
                                  RDW_VALIDATE | RDW_NOCHILDREN);

            ENDATOMICCHECK();

            /*
             * If the SPB vanished, return FALSE.
             */
            if (!SpbCheckRect2(pspb, pwnd, &rc, DCX_WINDOW))
                return FALSE;
        }
    }

    if (fChildren) {
        for (pwnd = pwnd->spwndChild; pwnd != NULL; pwnd = pwnd->spwndNext) {
            if (!SpbTransfer(pspb, pwnd, TRUE)) {
                return FALSE;
            }
        }
    }

    return TRUE;
}

/***************************************************************************\
* CreateSpb
*
* This function, called after the window is created but before it is visible,
* saves the contents of the screen where the window will be drawn in a SPB
* structure, and links the structure into a linked list of SPB structures.
* popup bits. This routine is called from SetWindowPos.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID CreateSpb(
    PWND pwnd,
    UINT flags,
    HDC  hdcScreen)
{
    PSPB    pspb;
    int     fSpbLockUpdate;

    /*
     * Non-LOCKWINDOWUPDATE SPBs can only be created for top-level windows.
     *
     * This is because of the way that the display driver RestoreBits function
     * works.  It can put bits down in places that aren't even part of the
     * window's visrgn, and these bits need to be invalidated.  The
     * SetWindowPos() code to handle this case only knows how to invalidate
     * one of windows (i.e., the window's immediate parent), but all levels
     * need to get invalidated.  See also the comments in wmswp.c, near the
     * call to RestoreSpb().
     *
     * For example: the Q&E app brings up a copyright dialog that is a child
     * of its main window.  While this is up, the user alt-f alt-l to execute
     * the file login command, which brings up another dialog that is a child
     * of the desktop.  When the copyright dialog goes away, the display driver
     * restores bits on top of the second dialog.  The SWP code knows to
     * invalidate the bogus stuff in the main window, but not in the desktop.
     *
     * LOCKUPDATE SPBs are fine, because they don't call RestoreBits.
     */
    fSpbLockUpdate = flags & SPB_LOCKUPDATE;
    if (    !fSpbLockUpdate             &&
            pwnd->spwndParent != NULL   &&
            pwnd->spwndParent != PWNDDESKTOP(pwnd)) {

        return;
    }

    /*
     * We go and check all the existing DCs at this point, to handle the
     * case where we're saving an image of a window that has a "dirty"
     * DC, which would eventually invalidate our saved image (but which
     * is really okay).
     */
    if (AnySpbs()) {

        SpbCheck();

    } else {

        PDCE pdce;

        /*
         * Reset the dirty areas of all of the DC's and enable
         * bounds accumulation.  We're creating a SPB now.  This
         * is only done if there are no other SPB's in the list.
         */
        GreLockDisplay(gpDispInfo->hDev);

        for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

            if (pdce->DCX_flags & DCX_REDIRECTED)
                continue;

            GreGetBounds(pdce->hdc, NULL, GGB_ENABLE_WINMGR);
        }

        GreUnlockDisplay(gpDispInfo->hDev);
    }

    /*
     * Create the save popup bits structure
     */
    pspb = (PSPB)UserAllocPoolWithQuota(sizeof(SPB), TAG_SPB);
    if (!pspb)
        return;

    pspb->spwnd = NULL;
    pspb->rc    = pwnd->rcWindow;

    /*
     * Clip to the screen
     */
    if (!IntersectRect(&pspb->rc, &pspb->rc, &gpDispInfo->rcScreen))
        goto BMError;

    pspb->hrgn  = NULL;
    pspb->hbm   = NULL;
    pspb->flags = flags;
    Lock(&(pspb->spwnd), pwnd);

    if (!fSpbLockUpdate) {

        RECT rc = pspb->rc;

        if (!SYSMET(SAMEDISPLAYFORMAT)) {
            PMONITOR pMonitor = _MonitorFromRect(&pspb->rc, MONITOR_DEFAULTTOPRIMARY);
            RECT rcT;

            /*
             * If the intersection with the monitor isn't the entire visible
             * window rectangle, then bail!  We don't save SPBs for windows
             * that span multiple monitors.  Since we do a lot of work to
             * pin dialogs and menus, there won't be too many of these
             * babies.
             */
            if (SubtractRect(&rcT, &pspb->rc, &pMonitor->rcMonitor) &&
                    GreRectInRegion(gpDispInfo->hrgnScreen, &rcT))
                goto BMError2;

            /*
             * Clip to the window's monitor
             */
            if (!IntersectRect(&pspb->rc, &pspb->rc, &pMonitor->rcMonitor))
                goto BMError2;

            /*
             * dont save bits in a mixed bitdepth situtation
             * we cant create the exactly correct format bitmap
             * in all cases (555/565, and Paletized) so as
             * a cop-out dont save bitmaps at all (on secondaries)
             * in mixed bit-depth.
             *
             * the correct fix is to create a compatible
             * bitmap for the monitor device and directly
             * BitBlt() from/to the device (pMonitor->hdcMonitor)
             * but this involves too much code at this time.
             */
            if (pMonitor != gpDispInfo->pMonitorPrimary)
                goto BMError2;
        }

        /*
         * If this window is a regional window, don't use driver save
         * bits. Because it can only restore an entire rectangle,
         * invalid region is calculated assuming the old vis rgn was
         * rectangular. For regional windows, this would end up always
         * invalidating the area of (rcWindow - hrgnWindow) every
         * time an spb would be used. On the other hand, the invalid
         * area calculated when not using driver save bits is perfect,
         * because the restore blt can be correctly clipped to begin with.
         */
        if ((pwnd->hrgnClip == NULL) &&
            (pspb->ulSaveId = GreSaveScreenBits(gpDispInfo->hDev,
                                                SS_SAVE,
                                                0,
                                                (RECTL *)&rc))) {

            /*
             * Remember that we copied this bitmap into on board memory.
             */
            pspb->flags |= SPB_SAVESCREENBITS;

        } else {
            HBITMAP hbmSave;
            BOOL    bRet;

            /*
             * The following delta byte-aligns the screen bitmap
             */
            int dx = pspb->rc.left & 0x0007;
            int cx = pspb->rc.right - pspb->rc.left;
            int cy = pspb->rc.bottom - pspb->rc.top;

            /*
             * NOTE: we don't care about setting up a visrgn in
             * hdcScreen, because BitBlt ignores it on reads.
             */
            pspb->hbm = GreCreateCompatibleBitmap(hdcScreen, cx + dx, cy);
            if (!pspb->hbm)
                goto BMError2;

            hbmSave = (HBITMAP)GreSelectBitmap(ghdcMem, pspb->hbm);
            if (!hbmSave)
                goto BMError2;

            /*
             * Copy the contents of the screen to the bitmap in the
             * save popup bits structure.  If we ever find we run
             * into problems with the screen access check we can
             * do a bLockDisplay, give this process permission, do
             * the BitBlt and then take away permission.  GDI
             * accesses the screen and that bit only under the
             * display semaphore so it is safe.  Alternatively
             * if it is too hard to change this processes permission
             * here we could do it in GDI by marking the psoSrc
             * readable temporarily while completing the operation
             * and then setting it back to unreadable when done.
             * Or we could just fail it like the CreateCompatibleDC
             * failed and force a redraw.  Basically we can't add
             * 3K of code in GDI to do a BitBlt that just does 1
             * test differently for this 1 place in User.
             *
             */
            bRet = GreBitBlt(ghdcMem,
                             dx,
                             0,
                             cx,
                             cy,
                             hdcScreen,
                             pspb->rc.left,
                             pspb->rc.top,
                             0x00CC0000,
                             0);

            GreSelectBitmap(ghdcMem, hbmSave);

            if (!bRet)
                goto BMError2;

            GreSetBitmapOwner(pspb->hbm, OBJECT_OWNER_PUBLIC);
        }

        /*
         * Mark that the window has an SPB.
         */
        SetWF(pwnd, WFHASSPB);

        /*
         * non-LOCKUPDATE SPBs are not invalidated by
         * drawing in pspb->spwnd, so start the SPB validation
         * loop below at the sibling immediately below us.
         */
        pwnd = pwnd->spwndNext;
    }

    /*
     * Link the new save popup bits structure into the list.
     */
    pspb->pspbNext = gpDispInfo->pspbFirst;
    gpDispInfo->pspbFirst = pspb;

    /*
     * Here we deal with any update regions that may be
     * pending in windows underneath the SPB.
     *
     * For all windows that might affect this SPB:
     *    - Subtract the SPB rect from the update region
     *    - Subtract the window from the SPB
     *
     * Note that we use pspb->spwnd here, in case it has
     * no siblings.
     *
     * ghrgnSPB2 is the region that is used inside of SpbTransfer to
     * validate window update regions. Intersect with the window clipping
     * region, if it exists. Don't want to intersect with the spb rect if
     * a clipping region exists because we'll end up validating more than
     * we want to validate.
     */
    SetRectRgnIndirect(ghrgnSPB2, &pspb->rc);
    if (pspb->spwnd->hrgnClip != NULL) {

        /*
         * If we get an error bail since an error might result in more
         * being validated than we want. Since the below code is only an
         * optimizer, this is ok: the window will remain invalid and will
         * draw, thereby invalidating the SPB like usual.
         */
        if (IntersectRgn(ghrgnSPB2,
                         ghrgnSPB2,
                         pspb->spwnd->hrgnClip) == ERROR) {
            return;
        }
    }

    if (pspb->spwnd->spwndParent == NULL ||
            SpbTransfer(pspb, pspb->spwnd->spwndParent, FALSE)) {

        /*
         * Do the same for the siblings underneath us...
         */
        for ( ; pwnd != NULL; pwnd = pwnd->spwndNext) {
            if (!SpbTransfer(pspb, pwnd, TRUE))
                break;
        }
    }

    return;

BMError2:
    /*
     * Error creating the bitmap: clean up and return.
     */
    if (pspb->hbm)
        GreDeleteObject(pspb->hbm);

    Unlock(&pspb->spwnd);
    // fall-through

BMError:
    UserFreePool(pspb);
}

/***************************************************************************\
* RestoreSpb
*
* Restores the bits associated with pwnd's SPB onto the screen, clipped
* to hrgnUncovered if possible.
*
* Upon return, hrgnUncovered is modified to contain the part of hrgnUncovered
* that must be invalidated by the caller.  FALSE is returned if the area
* to be invalidated is empty.
*
* NOTE: Because the device driver SaveBitmap() function can not clip, this
* function may write bits into an area of the screen larger than the passed-in
* hrgnUncovered.  In this case, the returned invalid region may be larger
* than the passed-in hrgnUncovered.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

UINT RestoreSpb(
    PWND pwnd,
    HRGN hrgnUncovered,
    HDC  *phdcScreen)
{
    PSPB pspb;
    UINT uInvalidate;
    HRGN hrgnRestorable;

    /*
     * Note that we DON'T call SpbCheck() here --
     * SpbCheck() is called by zzzBltValidBits().
     */
    pspb = FindSpb(pwnd);

    /*
     * Assume all of hrgnUncovered was restored, and there's nothing
     * for our caller to invalidate.
     */
    uInvalidate = RSPB_NO_INVALIDATE;
    hrgnRestorable = hrgnUncovered;

    /*
     * First determine whether or not there is any area at all to restore.
     * If hrgnUncovered & pspb->hrgn is empty, then all of hrgnUncovered
     * needs to be invalidated, and there's nothing to restore.
     */
    if (pspb->hrgn != NULL) {
        /*
         * At least some of hrgnUncovered needs to be invalidated.
         */
        uInvalidate = RSPB_INVALIDATE;

        /*
         * Calculate the true area of bits to be restored.  If it becomes
         * empty, then just free the SPB without changing hrgnUncovered,
         * which is the area that must be invalidated.
         */
        hrgnRestorable = ghrgnSPB1;
        switch (IntersectRgn(hrgnRestorable, hrgnUncovered, pspb->hrgn)) {
        case ERROR:
        case NULLREGION:
            goto Error;

        default:
            break;
        }
    }

    if (pspb->flags & SPB_SAVESCREENBITS) {

        RECT rc = pspb->rc;

        /*
         * Since the restore frees the onboard memory, clear this
         * bit so FreeSpb() won't try to free it again (regardless of
         * whether we get an error or not)
         */
        pspb->flags &= ~SPB_SAVESCREENBITS;
        if (!(GreSaveScreenBits(gpDispInfo->hDev,
                                SS_RESTORE,
                                pspb->ulSaveId,
                                (RECTL *)&rc))) {
            goto Error;
        }

        /*
         * The SS_RESTORE call will always restore the entire SPB
         * rectangle, part of which may fall outside of hrgnUncovered.
         * The area that must be invalidated by our caller is simply
         * the SPB rectangle minus the area of restorable bits.
         *
         * If this region is not empty, then the SPB was not completely
         * restored, so we must return FALSE.
         */
        SetRectRgnIndirect(ghrgnSPB2, &pspb->rc);
        if (SubtractRgn(hrgnUncovered, ghrgnSPB2, hrgnRestorable) != NULLREGION) {
            uInvalidate = RSPB_INVALIDATE_SSB;
        }
    } else {

        HDC     hdcScreen;
        HBITMAP hbmSave;

        /*
         * In the unlikely event we need a screen DC and one wasn't passed in,
         * get it now.  If we get one, we return the handle in *phdcScreen
         * so that our caller can release it later.
         */
        if (!*phdcScreen) {
            *phdcScreen = gpDispInfo->hdcScreen;
        }

        hdcScreen = *phdcScreen;

        hbmSave = (HBITMAP)GreSelectBitmap(ghdcMem, pspb->hbm);
        if (!hbmSave)
            goto Error;

        /*
         * Be sure to clip to the area of restorable bits.
         */

        GreSelectVisRgn(hdcScreen, hrgnRestorable, SVR_COPYNEW);

        GreBitBlt(hdcScreen,
                  pspb->rc.left, pspb->rc.top,
                  pspb->rc.right - pspb->rc.left,
                  pspb->rc.bottom - pspb->rc.top,
                  ghdcMem,
                  pspb->rc.left & 0x0007,
                  0,
                  SRCCOPY,
                  0);

        GreSelectBitmap(ghdcMem, hbmSave);

        /*
         * Now compute the area to be invalidated for return.
         * This is simply the original hrgnUncovered - hrgnRestorable
         */
        SubtractRgn(hrgnUncovered, hrgnUncovered, hrgnRestorable);
    }

    if (pwnd->hrgnClip == NULL || !IsVisible(pwnd))
        FreeSpb(pspb);

    return uInvalidate;

Error:
    FreeSpb(pspb);
    return RSPB_INVALIDATE;
}



/***************************************************************************\
* LockWindowUpdate2 (API)
*
* Locks gspwndLockUpdate and it's children from updating.  If
* gspwndLockUpdate is NULL, then all windows will be unlocked.  When
* unlocked, the portions of the screen that would have been written to
* are invalidated so they get repainted. TRUE is returned if the routine
* is successful.
*
* If called when another app has something locked, then this function fails.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL LockWindowUpdate2(
    PWND pwndLock,
    BOOL fThreadOverride)
{
    PSPB pspb;
    BOOL fInval;
    HRGN hrgn;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    if (    /*
             * If we're full screen right now, fail this call.
             */
            TEST_PUDF(PUDF_LOCKFULLSCREEN)

            ||

            /*
             * If the screen is already locked, and it's being locked
             * by some other app, then fail.  If fThreadOverride is set
             * then we're calling internally and it's okay to cancel
             * someone elses LockUpdate.
             */
            (   gptiLockUpdate != NULL &&
                gptiLockUpdate != PtiCurrent() &&
                !fThreadOverride)) {
    UserAssert(IsWinEventNotifyDeferredOK());

        RIPERR0(ERROR_SCREEN_ALREADY_LOCKED,
                RIP_WARNING,
                "LockWindowUpdate failed because screen is locked by another application.");

        return FALSE;
    }

    if ((pwndLock != NULL) == (gptiLockUpdate != NULL)) {
        if (!fThreadOverride) {
            RIPERR1(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "LockWindowUpdate failed because it is already %s.",
                    (pwndLock != NULL) ? "locked" : "unlocked");
        }

        return FALSE;
    }

    /*
     * This must be done while holding the screen critsec.
     * Deadlock if we callback during this, so defer WinEvent notifications
     */
    DeferWinEventNotify();
    GreLockDisplay(gpDispInfo->hDev);

    if (pwndLock != NULL) {
        /*
         * We're about to make pwndLock and its siblings invisible:
         * go invalidate any other affected SPBs.
         */
        SpbCheckPwnd(pwndLock);

        CreateSpb(pwndLock, SPB_LOCKUPDATE, NULL);

        Lock(&(gspwndLockUpdate), pwndLock);
        gptiLockUpdate = ptiCurrent;

        zzzInvalidateDCCache(pwndLock, IDC_DEFAULT);

    } else {
        /*
         * Flush any accumulated rectangles and invalidate spbs.
         */
        SpbCheck();

        /*
         * Save this in a local before we set it to NULL
         */
        pwndLock = gspwndLockUpdate;

        gptiLockUpdate = NULL;
        Unlock(&gspwndLockUpdate);

        zzzInvalidateDCCache(pwndLock, IDC_DEFAULT);

        /*
         * Assume SPB doesn't exist, or couldn't be created, and that we
         * must invalidate the entire window.
         */
        fInval = TRUE;
        hrgn = HRGN_FULL;

        /*
         * Find the LOCKUPDATE spb in the list, and if present calculate
         * the area that has been invalidated, if any.
         */
        for (pspb = gpDispInfo->pspbFirst; pspb != NULL; pspb = pspb->pspbNext) {

            if (pspb->flags & SPB_LOCKUPDATE) {

                if (pspb->hrgn == NULL) {

                    /*
                     * If no invalid area, then no invalidation needed.
                     */
                    fInval = FALSE;

                } else {

                    /*
                     * Subtract SPB valid region from SPB rectangle, to
                     * yield invalid region.
                     */
                    hrgn = ghrgnSPB1;
                    SetRectRgnIndirect(hrgn, &pspb->rc);

                    /*
                     * If spb rect minus the spb valid rgn is empty,
                     * then there is nothing to invalidate.
                     */
                    fInval = SubtractRgn(hrgn, hrgn, pspb->hrgn) != NULLREGION;
                }

                FreeSpb(pspb);

                /*
                 * Exit this loop (there can be only one LOCKUPDATE spb)
                 */
                break;
            }
        }

        if (fInval) {
            /*
             * When unlocking a Layered window (or a child of a layered
             * window), we need to invalidate that layered window specifically
             * or the window will ignore the invalidation request.  For regular
             * windows, we invalidate the desktop instead.
             */
            PWND pwndInvalidate;
            if ((pwndInvalidate = GetStyleWindow(pwndLock, WEFLAYERED)) == NULL) {
                pwndInvalidate = PWNDDESKTOP(pwndLock);
            }

            BEGINATOMICCHECK();
            // want to prevent WinEvent notifies, but this make break asserts
            DeferWinEventNotify();
            xxxInternalInvalidate(pwndInvalidate,
                               hrgn,
                               RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
            zzzEndDeferWinEventNotify();
            ENDATOMICCHECK();
        }

        /*
         * Invalidate any other SPBs affected by the fact that this window
         * and its children are being made visible.
         */
        SpbCheckPwnd(pwndLock);
    }

    GreUnlockDisplay(gpDispInfo->hDev);
    zzzEndDeferWinEventNotify();

    return TRUE;
}

/***************************************************************************\
* FindSpb
*
* Returns a pointer to the SPB structure associated with the specified
* window or NULL if there is no associated structure.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

PSPB FindSpb(
    PWND pwnd)
{
    PSPB pspb;

    /*
     * Walk through the list of save popup bits looking for a match on
     * window handle.
     */
    for (pspb = gpDispInfo->pspbFirst; pspb != NULL; pspb = pspb->pspbNext) {

        if (pspb->spwnd == pwnd && !(pspb->flags & SPB_LOCKUPDATE))
            break;
    }

    return pspb;
}

/***************************************************************************\
* SpbCheck
*
* Modifies all of the save popup bits structures to reflect changes on the
* screen. This function walks through all of the DC's, and if the DC is
* dirty, then the dirty area is removed from the associated save popup bits
* structure.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID SpbCheck(VOID)
{
    PDCE pdce;
    RECT rcBounds;

    if (AnySpbs()) {

        GreLockDisplay(gpDispInfo->hDev);

        /*
         * Walk through all of the DC's, accumulating dirty areas.
         */
        for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

            /*
             * Only check valid cache entries...
             */
            if (pdce->DCX_flags & (DCX_INVALID | DCX_DESTROYTHIS))
                continue;

            SpbCheckDce(pdce);
        }

        /*
         * Subtact out DirectDraw dirty rect from all the SPB's. The call to
         * GreGetDirectDrawBounds will also reset the accumulated bounds.
         */
        if (GreGetDirectDrawBounds(gpDispInfo->hDev, &rcBounds)) {
            SpbCheckRect(NULL, &rcBounds, 0);
        }

        GreUnlockDisplay(gpDispInfo->hDev);
    }
}

/***************************************************************************\
* SpbCheckDce
*
* This function retrieves the dirty area of a DC and removes the area from
* the list of SPB structures. The DC is then marked as clean.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID SpbCheckDce(
    PDCE pdce)
{
    RECT rc;

    if (pdce->DCX_flags & DCX_REDIRECTED)
        return;

    /*
     * Query the dirty bounds rectangle.  Doing this clears the bounds
     * as well.
     */
    if (GreGetBounds(pdce->hdc, &rc, 0)) {

        if (pdce->pMonitor != NULL) {
            /*
             * Convert the bounds rect to screen coords.
             */
            OffsetRect(&rc, pdce->pMonitor->rcMonitor.left,
                    pdce->pMonitor->rcMonitor.top);
        }

        /*
         * Intersect the returned rectangle with the window rectangle
         * in case the guy was drawing outside his window
         */
        if (IntersectRect(&rc, &rc, &(pdce->pwndOrg)->rcWindow))
            SpbCheckRect(pdce->pwndOrg, &rc, pdce->DCX_flags);
    }
}

/***************************************************************************\
* SpbCheckRect
*
* This function removes the passed rectangle from the SPB structures which
* touch it.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID SpbCheckRect(
    PWND   pwnd,
    LPRECT lprc,
    DWORD  flags)
{
    PSPB pspb, pspbNext;

    /*
     * If this window isn't visible, we're done.
     */
    if (!IsVisible(pwnd))
        return;

    for (pspb = gpDispInfo->pspbFirst; pspb != NULL; pspb = pspbNext) {

        /*
         * Get the pointer to the next save popup bits structure now
         * in case SpbCheckRect2() frees the current one.
         */
        pspbNext = pspb->pspbNext;

        /*
         * In win3.1 they used to exit the function if this function
         * returned false.  This meant that if one of the spbs was freed
         * the rest of the spbs would not be invalidated.
         */
        SpbCheckRect2(pspb, pwnd, lprc, flags);
    }
}

/***************************************************************************\
* SpbCheckPwnd
*
* This routine checks to see if the window rectangle of PWND affects any SPBs.
* It is called if pwnd or its children are being hidden or shown without
* going through WinSetWindowPos().
*
* Any SPBs for children of pwnd are destroyed.
*
* It must be called while pwnd is still visible.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID SpbCheckPwnd(
    PWND pwnd)
{
    PSPB pspb;
    PWND pwndSpb;
    PSPB pspbNext;

    /*
     * First blow away any SPBs owned by this window or its children.
     */
    for (pspb = gpDispInfo->pspbFirst; pspb != NULL; pspb = pspbNext) {

        /*
         * Get pspbNext now in case we free the SPB
         */
        pspbNext = pspb->pspbNext;

        /*
         * If pspb->spwnd is == pwnd or a child of pwnd, then free the SPB
         */
        for (pwndSpb = pspb->spwnd; pwndSpb; pwndSpb = pwndSpb->spwndParent) {

            if (pwnd == pwndSpb)
                FreeSpb(pspb);
        }
    }

    /*
     * Then see if any other SPBs are affected...
     */
    if (gpDispInfo->pspbFirst != NULL) {
        SpbCheckRect(pwnd, &pwnd->rcWindow, 0);
    }
}

/***************************************************************************\
* FreeSpb
*
* This function deletes the bitmap and region assocaited with a save popup
* bits structure and then unlinks and destroys the spb structure itself.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID FreeSpb(
    PSPB pspb)
{
    PSPB *ppspb;
    PDCE pdce;

    if (pspb == NULL)
        return;

    /*
     * Delete the bitmap.  If saved in screen memory, make special call.
     */
    if (pspb->flags & SPB_SAVESCREENBITS) {
        GreSaveScreenBits(gpDispInfo->hDev, SS_FREE, pspb->ulSaveId, NULL);
    } else if (pspb->hbm != NULL) {
        GreDeleteObject(pspb->hbm);
    }

    /*
     * Destroy the region.
     */
    if (pspb->hrgn != NULL){
        GreDeleteObject(pspb->hrgn);
    }

    /*
     * Forget that there is an attached SPB.
     */
    if (pspb->spwnd != NULL) {
        ClrWF(pspb->spwnd, WFHASSPB);
        Unlock(&pspb->spwnd);
    }

    /*
     * Unlink the spb.
     */
    ppspb = &gpDispInfo->pspbFirst;
    while (*ppspb != pspb) {
        ppspb = &(*ppspb)->pspbNext;
    }

    *ppspb = pspb->pspbNext;

    /*
     * Free the save popup bits structure.
     */
    UserFreePool(pspb);

    /*
     * If we no longer have any SPBs then turn off window MGR
     * bounds collection.
     */
    if (!AnySpbs()) {

        GreLockDisplay(gpDispInfo->hDev);

        /*
         * Reset the dirty areas of all of the DC's.  NULL means reset.
         */
        for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

            if (pdce->DCX_flags & DCX_REDIRECTED)
                continue;

            GreGetBounds(pdce->hdc, NULL, GGB_DISABLE_WINMGR);
        }

        GreUnlockDisplay(gpDispInfo->hDev);
    }

}

/***************************************************************************\
* FreeAllSpbs
*
* This function deletes all spb-bitmaps.
*
* History:
* 07-Oct-1995 ChrisWil  Ported from Chicago.
\***************************************************************************/

VOID FreeAllSpbs(void)
{

    while(AnySpbs()) {
        FreeSpb(gpDispInfo->pspbFirst);
    }

    gpDispInfo->pspbFirst = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\snapshot.c ===
/****************************** Module Header ******************************\
* Module Name: snapshot.c
*
* Screen/Window SnapShotting Routines
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 26-Nov-1991 DavidPe   Ported from Win 3.1 sources
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxSnapWindow
*
* Effects: Snaps either the desktop hwnd or the active front most window. If
* any other window is specified, we will snap it but it will be clipped.
*
\***************************************************************************/

BOOL xxxSnapWindow(
    PWND pwnd)
{
    PTHREADINFO    ptiCurrent;
    RECT           rc;
    HDC            hdcScr = NULL;
    HDC            hdcMem = NULL;
    BOOL           fRet;
    HBITMAP        hbmOld;
    HBITMAP        hbm;
    HANDLE         hPal;
    LPLOGPALETTE   lppal;
    int            palsize;
    int            iFixedPaletteEntries;
    BOOL           fSuccess;
    PWND           pwndT;
    TL             tlpwndT;
    PWINDOWSTATION pwinsta;
    TL             tlpwinsta;

    CheckLock(pwnd);

    UserAssert(pwnd != NULL);

    ptiCurrent = PtiCurrent();

    /*
     * If this is a thread of winlogon, don't do the snapshot.
     */
    if (PsGetCurrentProcessId() == gpidLogon) {
        return FALSE;
    }

    /*
     * Get the affected windowstation
     */
    if (!NT_SUCCESS(ReferenceWindowStation(
            PsGetCurrentThread(),
            NULL,
            WINSTA_READSCREEN,
            &pwinsta,
            TRUE)) ||
            pwinsta->dwWSF_Flags & WSF_NOIO) {
        return FALSE;
    }

    /*
     * If the window is on another windowstation, do nothing.
     */
    if (pwnd->head.rpdesk->rpwinstaParent != pwinsta) {
        return FALSE;
    }

    /*
     * Get the parent of any child windows.
     */
    while (TestWF(pwnd, WFCHILD)) {
        pwnd = pwnd->spwndParent;
        UserAssert(pwnd != NULL);
    }

    /*
     * Lock the windowstation before we leave the critical section
     */
    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    /*
     * Open the clipboard and empty it.
     *
     * pwndDesktop is made the owner of the clipboard, instead of the
     * currently active window; -- SANKAR -- 20th July, 1989 --
     */
    pwndT = ptiCurrent->rpdesk->pDeskInfo->spwnd;
    ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);
    fSuccess = _OpenClipboard(pwndT, NULL);
    ThreadUnlock(&tlpwndT);

    if (!fSuccess) {
        ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);
        return FALSE;
    }

    xxxEmptyClipboard(pwinsta);

    /*
     * Use the whole window.
     */
    CopyRect(&rc, &pwnd->rcWindow);

    /*
     * Only snap what is on the screen.
     */
    if (!IntersectRect(&rc, &rc, &gpDispInfo->rcScreen)) {
        fRet = FALSE;
        goto SnapExit;
    }

    rc.right -= rc.left;
    rc.bottom -= rc.top;

    /*
     * Figure out how far offset from window origin visible part is
     */
    if (pwnd != PWNDDESKTOP(pwnd)) {
        rc.left -= pwnd->rcWindow.left;
        rc.top -= pwnd->rcWindow.top;
    }

    /*
     * Get the entire window's DC.
     */
    hdcScr = _GetWindowDC(pwnd);
    if (!hdcScr)
        goto MemoryError;

    /*
     * Create the memory DC.
     */
    hdcMem = GreCreateCompatibleDC(hdcScr);
    if (!hdcMem)
        goto MemoryError;

    /*
     * Create the destination bitmap.  If it fails, then attempt
     * to create a monochrome bitmap.
     * Did we have enough memory?
     */

    if (SYSMET(SAMEDISPLAYFORMAT)) {
        hbm = GreCreateCompatibleBitmap(hdcScr, rc.right, rc.bottom);
    } else {
        hbm = GreCreateBitmap(rc.right, rc.bottom, 1, gpDispInfo->BitCountMax, NULL);
    }

    if (!hbm) {
        hbm = GreCreateBitmap(rc.right, rc.bottom, 1, 1, NULL);
        if (!hbm)
            goto MemoryError;
    }

    /*
     * Select the bitmap into the memory DC.
     */
    hbmOld = GreSelectBitmap(hdcMem, hbm);

    /*
     * Snap!!!
     * Check the return value because the process taking the snapshot
     * may not have access to read the screen.
     */
    fRet = GreBitBlt(hdcMem, 0, 0, rc.right, rc.bottom, hdcScr, rc.left, rc.top, SRCCOPY | CAPTUREBLT, 0);

    /*
     * Restore the old bitmap into the memory DC.
     */
    GreSelectBitmap(hdcMem, hbmOld);

    /*
     * If the blt failed, leave now.
     */
    if (!fRet) {
        goto SnapExit;
    }

    _SetClipboardData(CF_BITMAP, hbm, FALSE, TRUE);

    /*
     * If this is a palette device, let's throw the current system palette
     * into the clipboard also.  Useful if the user just snapped a window
     * containing palette colors...
     */
    if (TEST_PUSIF(PUSIF_PALETTEDISPLAY)) {
        int i;
        int iPalSize;

        palsize = GreGetDeviceCaps(hdcScr, SIZEPALETTE);

        /*
         * Determine the number of system colors.
         */
        if (GreGetSystemPaletteUse(hdcScr) == SYSPAL_STATIC)
            iFixedPaletteEntries = GreGetDeviceCaps(hdcScr, NUMRESERVED);
        else
            iFixedPaletteEntries = 2;

        lppal = (LPLOGPALETTE)UserAllocPoolWithQuota(
                (LONG)(sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * palsize),
                TAG_CLIPBOARD);

        if (lppal != NULL) {
            lppal->palVersion = 0x300;
            lppal->palNumEntries = (WORD)palsize;

            if (GreGetSystemPaletteEntries(hdcScr,
                                           0,
                                           palsize,
                                           lppal->palPalEntry)) {

                iPalSize = palsize - iFixedPaletteEntries / 2;

                for (i = iFixedPaletteEntries / 2; i < iPalSize; i++) {

                    /*
                     * Any non system palette enteries need to have the NOCOLLAPSE
                     * flag set otherwise bitmaps containing different palette
                     * indices but same colors get messed up.
                     */
                    lppal->palPalEntry[i].peFlags = PC_NOCOLLAPSE;
                }

                if (hPal = GreCreatePalette(lppal))
                    _SetClipboardData(CF_PALETTE, hPal, FALSE, TRUE);
            }

            UserFreePool(lppal);
        }
    }
    PlayEventSound(USER_SOUND_SNAPSHOT);

    fRet = TRUE;

SnapExit:

    /*
     * Release the window/client DC.
     */
     if (hdcScr) {
         _ReleaseDC(hdcScr);
     }

    xxxCloseClipboard(pwinsta);
    Unlock(&pwinsta->spwndClipOwner);

    /*
     * Delete the memory DC.
     */
    if (hdcMem) {
        GreDeleteDC(hdcMem);
    }

    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    return fRet;

MemoryError:
    /*
     * Display an error message box.
     */
    ClientNoMemoryPopup();
    fRet = FALSE;
    goto SnapExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\srvmsg.c ===
/****************************** Module Header ******************************\
* Module Name: srvmsg.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Includes the mapping table for messages when calling the client.
*
* 04-11-91 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define SfnDDEINIT               SfnDWORD
#define SfnKERNELONLY            SfnDWORD

#ifdef FE_SB
/*
 * SfnEMGETSEL, SfnSETSEL, SfnGBGETEDITSEL
 */
#define SfnEMGETSEL              SfnOPTOUTLPDWORDOPTOUTLPDWORD
#define SfnEMSETSEL              SfnDWORD
#define SfnCBGETEDITSEL          SfnOPTOUTLPDWORDOPTOUTLPDWORD
#endif // FE_SB

#define MSGFN(func) Sfn ## func
#define FNSCSENDMESSAGE SFNSCSENDMESSAGE
#include <messages.h>

/***************************************************************************\
* fnINLBOXSTRING
*
* Takes a lbox string - a string that treats lParam as a string pointer or
* a DWORD depending on LBS_HASSTRINGS and ownerdraw.
*
* 04-12-91 ScottLu      Created.
\***************************************************************************/

LRESULT SfnINLBOXSTRING(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam,
    PROC xpfn,
    DWORD dwSCMSFlags,
    PSMS psms)
{
    DWORD dw;

    /*
     * See if the control is ownerdraw and does not have the LBS_HASSTRINGS
     * style.  If so, treat lParam as a DWORD.
     */
    if (!RevalidateHwnd(HW(pwnd))) {
        return 0L;
    }
    dw = pwnd->style;

    if (!(dw & LBS_HASSTRINGS) &&
            (dw & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE))) {

        /*
         * Treat lParam as a dword.
         */
        return SfnDWORD(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
    }

    /*
     * Treat as a string pointer.   Some messages allowed or had certain
     * error codes for NULL so send them through the NULL allowed thunk.
     * Ventura Publisher does this
     */
    switch (msg) {
        default:
            return SfnINSTRING(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
            break;

        case LB_FINDSTRING:
            return SfnINSTRINGNULL(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
            break;
    }
}


/***************************************************************************\
* SfnOUTLBOXSTRING
*
* Returns an lbox string - a string that treats lParam as a string pointer or
* a DWORD depending on LBS_HASSTRINGS and ownerdraw.
*
* 04-12-91 ScottLu      Created.
\***************************************************************************/

LRESULT SfnOUTLBOXSTRING(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam,
    PROC xpfn,
    DWORD dwSCMSFlags,
    PSMS psms)
{
    DWORD dw;
    BOOL bNotString;
    DWORD dwRet;
    TL tlpwnd;

    /*
     * See if the control is ownerdraw and does not have the LBS_HASSTRINGS
     * style.  If so, treat lParam as a DWORD.
     */
    if (!RevalidateHwnd(HW(pwnd))) {
        return 0L;
    }
    dw = pwnd->style;

    /*
     * See if the control is ownerdraw and does not have the LBS_HASSTRINGS
     * style.  If so, treat lParam as a DWORD.
     */
    bNotString =  (!(dw & LBS_HASSTRINGS) &&
            (dw & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)));

    /*
     * Make this special call which'll know how to copy this string.
     */
    ThreadLock(pwnd, &tlpwnd);
    dwRet = ClientGetListboxString(pwnd, msg, wParam,
            (PLARGE_UNICODE_STRING)lParam,
            xParam, xpfn, dwSCMSFlags, bNotString, psms);
    ThreadUnlock(&tlpwnd);
    return dwRet;
}


/***************************************************************************\
* fnINCBOXSTRING
*
* Takes a lbox string - a string that treats lParam as a string pointer or
* a DWORD depending on CBS_HASSTRINGS and ownerdraw.
*
* 04-12-91 ScottLu      Created.
\***************************************************************************/

LRESULT SfnINCBOXSTRING(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam,
    PROC xpfn,
    DWORD dwSCMSFlags,
    PSMS psms)
{
    DWORD dw;

    /*
     * See if the control is ownerdraw and does not have the CBS_HASSTRINGS
     * style.  If so, treat lParam as a DWORD.
     */
    if (!RevalidateHwnd(HW(pwnd))) {
        return 0L;
    }
    dw = pwnd->style;

    if (!(dw & CBS_HASSTRINGS) &&
            (dw & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))) {

        /*
         * Treat lParam as a dword.
         */
        return SfnDWORD(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
    }

    /*
     * Treat as a string pointer.   Some messages allowed or had certain
     * error codes for NULL so send them through the NULL allowed thunk.
     * Ventura Publisher does this
     */
    switch (msg) {
        default:
            return SfnINSTRING(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
            break;

        case CB_FINDSTRING:
            return SfnINSTRINGNULL(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
            break;
    }
}


/***************************************************************************\
* fnOUTCBOXSTRING
*
* Returns an lbox string - a string that treats lParam as a string pointer or
* a DWORD depending on CBS_HASSTRINGS and ownerdraw.
*
* 04-12-91 ScottLu      Created.
\***************************************************************************/

LRESULT SfnOUTCBOXSTRING(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam,
    PROC xpfn,
    DWORD dwSCMSFlags,
    PSMS psms)
{
    DWORD dw;
    BOOL bNotString;
    DWORD dwRet;
    TL tlpwnd;

    /*
     * See if the control is ownerdraw and does not have the CBS_HASSTRINGS
     * style.  If so, treat lParam as a DWORD.
     */

    if (!RevalidateHwnd(HW(pwnd))) {
        return 0L;
    }
    dw = pwnd->style;

    bNotString = (!(dw & CBS_HASSTRINGS) &&
            (dw & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)));

    /*
     * Make this special call which'll know how to copy this string.
     */
    ThreadLock(pwnd, &tlpwnd);
    dwRet = ClientGetListboxString(pwnd, msg, wParam,
            (PLARGE_UNICODE_STRING)lParam,
            xParam, xpfn, dwSCMSFlags, bNotString, psms);
    ThreadUnlock(&tlpwnd);
    return dwRet;
}


/***************************************************************************\
* fnPOWERBROADCAST
*
* Make sure we send the correct message when we resume.
*
* History:
* 02-Dec-1996 JerrySh   Created.
* 26-Nov-2001 JasonSch  Added code to validate pwnd.
\***************************************************************************/
LRESULT SfnPOWERBROADCAST(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam,
    PROC xpfn,
    DWORD dwSCMSFlags,
    PSMS psms)
{
    if (!RevalidateHwnd(HW(pwnd))) {
        return 0L;
    }

    switch (wParam) {
    case PBT_APMQUERYSUSPEND:
        SetWF(pwnd, WFGOTQUERYSUSPENDMSG);
        break;
    case PBT_APMQUERYSUSPENDFAILED:
        if (!TestWF(pwnd, WFGOTQUERYSUSPENDMSG))
            return 0;
        ClrWF(pwnd, WFGOTQUERYSUSPENDMSG);
        break;
    case PBT_APMSUSPEND:
        ClrWF(pwnd, WFGOTQUERYSUSPENDMSG);
        SetWF(pwnd, WFGOTSUSPENDMSG);
        break;
    case PBT_APMRESUMESUSPEND:
    case PBT_APMRESUMECRITICAL:
        
        //
        // If we're resuming and we never got a suspend message.
        // Here we convert our message into a critical resume.
        //
        if( !TestWF(pwnd, WFGOTSUSPENDMSG) ) {
            wParam = PBT_APMRESUMECRITICAL;
        }

        //
        // Now clear any 'suspend' messages that our
        // window may have previously recieved.
        //
        ClrWF(pwnd, WFGOTQUERYSUSPENDMSG);
        ClrWF(pwnd, WFGOTSUSPENDMSG);
        break;
    
    }

    return SfnDWORD(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\sprite.c ===
/****************************** Module Header ******************************\
* Module Name: sprite.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Windows Layering (Sprite) support.
*
* History:
* 12/05/97      vadimg      created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef MOUSE_IP

#define MOUSE_SONAR_RADIUS_INIT         100
#define MOUSE_SONAR_LINE_WIDTH          4
#define MOUSE_SONAR_RADIUS_DELTA        20
#define MOUSE_SONAR_RADIUS_TIMER        50
#define COLORKEY_COLOR          RGB(255, 0, 255)

VOID DrawSonar(HDC hdc);

#endif

#ifdef REDIRECTION

/***************************************************************************\
* UserGetRedirectionBitmap
*
\***************************************************************************/
HBITMAP UserGetRedirectionBitmap(
    HWND hwnd)
{
    HBITMAP hbm;
    PWND pwnd;

    EnterCrit();

    if ((pwnd = RevalidateHwnd(hwnd)) == NULL) {
        return NULL;
    }

    hbm = GetRedirectionBitmap(pwnd);

    LeaveCrit();

    return hbm;
}

/***************************************************************************\
* SetRedirectionMode
*
\***************************************************************************/
BOOL SetRedirectionMode(
    PBWL pbwl,
    PPROCESSINFO ppi)
{
    HWND *phwnd;
    PWND pwndT;
    BOOL fRet = TRUE;

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        if ((pwndT = RevalidateHwnd(*phwnd)) == NULL) {
            continue;
        }

        if (TestWF(pwndT, WFVISIBLE) && (ppi == NULL || GETPTI(pwndT)->ppi != ppi)) {
            if (SetRedirectedWindow(pwndT, REDIRECT_EXTREDIRECTED)) {
                SetWF(pwndT, WEFEXTREDIRECTED);
            } else {
                fRet = FALSE;
                break;
            }
        }
    }

    return fRet;
}

/***************************************************************************\
* UnsetRedirectionMode
*
\***************************************************************************/
VOID UnsetRedirectionMode(
    PBWL pbwl,
    PPROCESSINFO ppi)
{
    HWND *phwnd;
    PWND pwndT;

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        if ((pwndT = RevalidateHwnd(*phwnd)) == NULL) {
            continue;
        }

        if (TestWF(pwndT, WFVISIBLE) && ppi == NULL || GETPTI(pwndT)->ppi != ppi) {
            UnsetRedirectedWindow(pwndT, REDIRECT_EXTREDIRECTED);
            ClrWF(pwndT, WEFEXTREDIRECTED);
        }
    }
}

/***************************************************************************\
* xxxSetRedirectionMode
*
\***************************************************************************/
BOOL xxxSetRedirectionMode(
    BOOL fEnable,
    PDESKTOP pDesk,
    PTHREADINFO pti,
    PPROCESSINFO ppi)
{
    PBWL pbwl;
    PWND pwndDesktop   = pDesk->pDeskInfo->spwnd;

    pbwl = BuildHwndList(pwndDesktop->spwndChild, BWL_ENUMLIST, pti);
    if (pbwl == NULL) {
        return FALSE;
    }

    if (fEnable) {
        if (!SetRedirectionMode(pbwl, ppi)) {
            UnsetRedirectionMode(pbwl, ppi);
        }
    } else {
        UnsetRedirectionMode(pbwl, ppi);
    }
    FreeHwndList(pbwl);

    GreEnableDirectDrawRedirection(gpDispInfo->hDev, fEnable);
    xxxBroadcastDisplaySettingsChange(PtiCurrent()->rpdesk, FALSE);

    pwndDesktop = PtiCurrent()->rpdesk->pDeskInfo->spwnd;
    BEGINATOMICCHECK();
    xxxInternalInvalidate(pwndDesktop, HRGN_FULL, RDW_INVALIDATE |
            RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
    ENDATOMICCHECK();

    return TRUE;
}

/***************************************************************************\
* xxxSetProcessRedirectionMode
*
\***************************************************************************/
BOOL xxxSetProcessRedirectionMode(
    BOOL fEnable,
    PPROCESSINFO ppi)
{
    PTHREADINFO pti = ppi->ptiList;
    TL tl;

    while (pti != NULL)  {
        ThreadLockPti(PtiCurrent(), pti, &tl);
        if (!xxxSetRedirectionMode(fEnable, pti->rpdesk, pti, NULL)) {
            ThreadUnlockPti(PtiCurrent(), &tl);
            return FALSE;
        }
        pti = pti->ptiSibling;
        ThreadUnlockPti(PtiCurrent(), &tl);
    }

    return TRUE;
}

/***************************************************************************\
* xxxSetDesktopRedirectionMode
*
\***************************************************************************/
BOOL xxxSetDesktopRedirectionMode(
    BOOL fEnable,
    PDESKTOP pDesk,
    PPROCESSINFO ppi)
{
    return xxxSetRedirectionMode(fEnable, pDesk, NULL, ppi);
}

#endif

/***************************************************************************\
* IncrementRedirectedCount
*
\***************************************************************************/
VOID IncrementRedirectedCount(
    PWND pwnd)
{
    if (TestWF(pwnd, WFVISIBLE)) {
        gnVisibleRedirectedCount++;
        if (gnVisibleRedirectedCount == 1) {
            InternalSetTimer(gTermIO.spwndDesktopOwner,
                             IDSYS_LAYER,
                             100,
                             xxxSystemTimerProc,
                             TMRF_SYSTEM | TMRF_PTIWINDOW);
        }
    }
}

/***************************************************************************\
* DecrementRedirectedCount
*
\***************************************************************************/
VOID DecrementRedirectedCount(
    PWND pwnd)
{
    if (TestWF(pwnd, WFVISIBLE)) {
        if (gnVisibleRedirectedCount > 0) {
            gnVisibleRedirectedCount--;
            if (gnVisibleRedirectedCount == 0) {
                _KillSystemTimer(gTermIO.spwndDesktopOwner, IDSYS_LAYER);
            }
        }
    }
}

/***************************************************************************\
* CreateRedirectionBitmap
*
* 10/1/1998        vadimg      created
\***************************************************************************/
HBITMAP CreateRedirectionBitmap(
    PWND pwnd)
{
    HBITMAP hbm;

    UserAssert(pwnd->rcWindow.right >= pwnd->rcWindow.left);
    UserAssert(pwnd->rcWindow.bottom >= pwnd->rcWindow.top);

    /*
     * Make sure the (0,0) case doesn't fail, since the window really
     * can be sized this way.
     */
    if ((hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen,
            max(pwnd->rcWindow.right - pwnd->rcWindow.left, 1),
            max(pwnd->rcWindow.bottom - pwnd->rcWindow.top, 1) |
            CCB_NOVIDEOMEMORY)) == NULL) {
        RIPMSG0(RIP_WARNING, "CreateRedirectionBitmap: bitmap create failed");
        return NULL;
    }

    if (!GreSetBitmapOwner(hbm, OBJECT_OWNER_PUBLIC) ||
            !GreMarkUndeletableBitmap(hbm) ||
            !SetRedirectionBitmap(pwnd, hbm)) {
        RIPMSG0(RIP_WARNING, "CreateRedirectionBitmap: bitmap set failed");
        GreMarkDeletableBitmap(hbm);
        GreDeleteObject(hbm);
        return NULL;
    }

    SetWF(pwnd, WEFPREDIRECTED);

    /*
     * Force the window to redraw if we could recreate the bitmap since
     * the redirection bitmap we just allocated doesn't contain anything
     * yet.
     */
    BEGINATOMICCHECK();
    xxxInternalInvalidate(pwnd,
                          HRGN_FULL,
                          RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
    ENDATOMICCHECK();

    IncrementRedirectedCount(pwnd);

    return hbm;
}

/***************************************************************************\
* ConvertRedirectionDCs
*
* 11/19/1998        vadimg      created
\***************************************************************************/
VOID ConvertRedirectionDCs(
    PWND pwnd,
    HBITMAP hbm)
{
    PDCE pdce;

    GreLockDisplay(gpDispInfo->hDev);

    for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {
        if (pdce->DCX_flags & DCX_DESTROYTHIS) {
            continue;
        }

        if (!(pdce->DCX_flags & DCX_INUSE)) {
            continue;
        }

        if (!_IsDescendant(pwnd, pdce->pwndOrg)) {
            continue;
        }

        /*
         * Only normal DCs can be redirected. Redirection on monitor
         * specific DCs is not supported.
         */
        if (pdce->pMonitor != NULL) {
            continue;
        }

        SET_OR_CLEAR_FLAG(pdce->DCX_flags, DCX_REDIRECTED, (hbm != NULL));

        UserVerify(GreSelectRedirectionBitmap(pdce->hdc, hbm));

        InvalidateDce(pdce);
    }

    GreUnlockDisplay(gpDispInfo->hDev);
}

/***************************************************************************\
* UpdateRedirectedDC
*
* 11/19/1998        vadimg      created
\***************************************************************************/
VOID UpdateRedirectedDC(
    PDCE pdce)
{
    RECT rcBounds;
    PWND pwnd;
    SIZE size;
    POINT pt;
    HBITMAP hbm, hbmOld;
    PREDIRECT prdr;

    UserAssert(pdce->DCX_flags & DCX_REDIRECTED);

    /*
     * Check to see if any drawing has been done into this DC
     * that should be transferred to the sprite.
     */
    if (!GreGetBounds(pdce->hdc, &rcBounds, 0)) {
        return;
    }

    pwnd = GetStyleWindow(pdce->pwndOrg, WEFPREDIRECTED);
    UserAssert(pwnd);
    prdr = (PREDIRECT)_GetProp(pwnd, PROP_LAYER, TRUE);

#ifdef REDIRECTION
    BEGINATOMICCHECK();
    xxxWindowEvent(EVENT_SYSTEM_REDIRECTEDPAINT,
                   pwnd,
                   MAKELONG(rcBounds.left, rcBounds.top),
                   MAKELONG(rcBounds.right, rcBounds.bottom),
                   WEF_ASYNC);
    ENDATOMICCHECK();
#endif

    if (TestWF(pwnd, WEFCOMPOSITED)) {
        if (TestWF(pwnd, WEFPCOMPOSITING)) {
            UnionRect(&prdr->rcUpdate, &prdr->rcUpdate, &rcBounds);
        } else {
            HRGN hrgn;

            OffsetRect(&rcBounds, pwnd->rcWindow.left, pwnd->rcWindow.top);
            hrgn = GreCreateRectRgnIndirect(&rcBounds);

            BEGINATOMICCHECK();
            xxxInternalInvalidate(pwnd,
                                  hrgn,
                                  RDW_ALLCHILDREN | RDW_INVALIDATE |
                                      RDW_ERASE | RDW_FRAME);
            ENDATOMICCHECK();

            GreDeleteObject(hrgn);
        }
    } else if (TestWF(pwnd, WEFLAYERED)) {
        hbm = prdr->hbm;

        hbmOld = GreSelectBitmap(ghdcMem, hbm);

        size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
        size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

        pt.x = pt.y = 0;
        GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL, NULL,
                &size, ghdcMem, &pt, 0, NULL, ULW_DEFAULT_ATTRIBUTES, &rcBounds);

        GreSelectBitmap(ghdcMem, hbmOld);
    }
}

/***************************************************************************\
* DeleteRedirectionBitmap
*
\***************************************************************************/
VOID DeleteRedirectionBitmap(
    PWND pwnd,
    HBITMAP hbm)
{
    GreMarkDeletableBitmap(hbm);
    GreDeleteObject(hbm);
    DecrementRedirectedCount(pwnd);
}

/***************************************************************************\
* RemoveRedirectionBitmap
*
* 9/23/1998        vadimg      created
\***************************************************************************/
VOID RemoveRedirectionBitmap(
    PWND pwnd)
{
    HBITMAP hbm;

    /*
     * Delete the backing bitmap for this layered window.
     */
    if ((hbm = GetRedirectionBitmap(pwnd)) == NULL) {
        return;
    }

    UserAssert(TestWF(pwnd, WEFPREDIRECTED));
    ClrWF(pwnd, WEFPREDIRECTED);

    ConvertRedirectionDCs(pwnd, NULL);
    SetRedirectionBitmap(pwnd, NULL);
    DeleteRedirectionBitmap(pwnd, hbm);
}

/***************************************************************************\
* _GetLayeredWindowAttributes
*
* 3/14/2000        jstall      created
\***************************************************************************/
BOOL _GetLayeredWindowAttributes(
    PWND pwnd,
    COLORREF *pcrKey,
    BYTE *pbAlpha,
    DWORD *pdwFlags)
{
    BLENDFUNCTION bf;

    UserAssert(pcrKey != NULL);
    UserAssert(pbAlpha != NULL);
    UserAssert(pdwFlags != NULL);

    if (!TestWF(pwnd, WEFLAYERED)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "GetLayeredWindowAttributes: not a sprite 0x%p",
                pwnd);
        return FALSE;
    }

    /*
     * Check that the window has a redirection bitmap and is marked as
     * layered through WS_EX_LAYERED.  If the window is layered through
     * UpdateLayeredWindow, this function should fail.
     */
    if ((GetRedirectionFlags(pwnd) & REDIRECT_LAYER) == 0 ||
        !TestWF(pwnd, WEFLAYERED)) {

        return FALSE;
    }

    if (GreGetSpriteAttributes(gpDispInfo->hDev, PtoHq(pwnd), NULL, pcrKey, &bf, pdwFlags)) {
        *pbAlpha = bf.SourceConstantAlpha;

        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* _SetLayeredWindowAttributes
*
* 9/24/1998        vadimg      created
\***************************************************************************/
BOOL _SetLayeredWindowAttributes(
    PWND pwnd,
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags)
{
    BOOL bRet;
    BLENDFUNCTION blend;
    HBITMAP hbm;

    if (!TestWF(pwnd, WEFLAYERED)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "SetLayeredWindowAttributes: not a sprite 0x%p",
                pwnd);
        return FALSE;
    }

    if ((hbm = GetRedirectionBitmap(pwnd)) == NULL) {
        if (!SetRedirectedWindow(pwnd, REDIRECT_LAYER)) {
            return FALSE;
        }
    }

    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = bAlpha;

    dwFlags |= ULW_NEW_ATTRIBUTES; // Notify gdi that these are new attributes

    if (hbm != NULL) {
        HBITMAP hbmOld;
        SIZE size;
        POINT ptSrc = {0,0};

        hbmOld = GreSelectBitmap(ghdcMem, hbm);

        size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
        size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

        bRet =  GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL,
            NULL, &size, ghdcMem, &ptSrc, crKey, &blend, dwFlags, NULL);

        GreSelectBitmap(ghdcMem, hbmOld);
    } else {
        bRet =  GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL,
            NULL, NULL, NULL, NULL, crKey, &blend, dwFlags, NULL);
    }

    return bRet;
}

/***************************************************************************\
* RecreateRedirectionBitmap
*
* 10/1/1998        vadimg      created
\***************************************************************************/
BOOL RecreateRedirectionBitmap(
    PWND pwnd)
{
    HBITMAP hbm, hbmNew, hbmMem, hbmMem2;
    BITMAP bm, bmNew;
    int cx, cy;
    PDCE pdce;

    /*
     * No need to do anything if this layered window doesn't have
     * a redirection bitmap.
     */
    if ((hbm = GetRedirectionBitmap(pwnd)) == NULL) {
        return FALSE;
    }

    UserAssert(TestWF(pwnd, WEFPREDIRECTED));

    /*
     * Try to create a new redirection bitmap with the new size. If failed,
     * delete the old one and remove it from the window property list.
     */
    if ((hbmNew = CreateRedirectionBitmap(pwnd)) == NULL) {
        RemoveRedirectionBitmap(pwnd);
        return FALSE;
    }

    /*
     * Make sure that the display is locked, so that nobody can be drawing
     * into the redirection DCs while we're switching bitmaps under them.
     */
    UserAssert(GreIsDisplayLocked(gpDispInfo->hDev));

    /*
     * Get the size of the old bitmap to know how much to copy.
     */
    GreExtGetObjectW(hbm, sizeof(bm), (LPSTR)&bm);
    GreExtGetObjectW(hbmNew, sizeof(bmNew), (LPSTR)&bmNew);

    /*
     * Copy the bitmap from the old bitmap into the new one.
     */
    hbmMem = GreSelectBitmap(ghdcMem, hbm);
    hbmMem2 = GreSelectBitmap(ghdcMem2, hbmNew);

    cx = min(bm.bmWidth, bmNew.bmWidth);
    cy = min(bm.bmHeight, bmNew.bmHeight);

    GreBitBlt(ghdcMem2, 0, 0, cx, cy, ghdcMem, 0, 0, SRCCOPY | NOMIRRORBITMAP, 0);

    /*
     * Find layered DCs that are in use corresponding to this window and
     * replace the old redirection bitmap by the new one.
     */
    for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {
        if (pdce->DCX_flags & DCX_DESTROYTHIS) {
            continue;
        }

        if (!(pdce->DCX_flags & DCX_REDIRECTED) || !(pdce->DCX_flags & DCX_INUSE)) {
            continue;
        }

        if (!_IsDescendant(pwnd, pdce->pwndOrg)) {
            continue;
        }

        UserVerify(GreSelectRedirectionBitmap(pdce->hdc, hbmNew));
    }

    GreSelectBitmap(ghdcMem, hbmMem);
    GreSelectBitmap(ghdcMem2, hbmMem2);

    /*
     * Finally, delete the old redirection bitmap.
     */
    DeleteRedirectionBitmap(pwnd, hbm);

    return TRUE;
}

/***************************************************************************\
* ResetRedirectedWindows
*
\***************************************************************************/
VOID ResetRedirectedWindows(
    VOID)
{
    PHE phe, pheMax;
    PWND pwnd;

    GreLockDisplay(gpDispInfo->hDev);

    pheMax = &gSharedInfo.aheList[giheLast];
    for (phe = gSharedInfo.aheList; phe <= pheMax; phe++) {
        if (phe->bType != TYPE_WINDOW) {
            continue;
        }

        pwnd = (PWND)phe->phead;
        if (!TestWF(pwnd, WEFPREDIRECTED)) {
            continue;
        }

        RecreateRedirectionBitmap(pwnd);

        /*
         * Recreate the sprite so the surfaces are at the proper color depth.
         */
        if (TestWF(pwnd, WEFLAYERED)) {
            COLORREF cr;
            BLENDFUNCTION blend;
            DWORD dwFlags;

            GreGetSpriteAttributes(gpDispInfo->hDev, PtoHq(pwnd), NULL,
                    &cr, &blend, &dwFlags);

            GreDeleteSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL);

            if (GreCreateSprite(gpDispInfo->hDev, PtoHq(pwnd), &pwnd->rcWindow)) {
                _SetLayeredWindowAttributes(pwnd, cr, blend.SourceConstantAlpha,
                        dwFlags);
            } else {
                RemoveRedirectionBitmap(pwnd);
                ClrWF(pwnd, WEFLAYERED);
            }
        }
    }

    GreUnlockDisplay(gpDispInfo->hDev);
}

/***************************************************************************\
* UnsetLayeredWindow
*
* 1/30/1998   vadimg          created
\***************************************************************************/
VOID UnsetLayeredWindow(
    PWND pwnd)
{
    HWND hwnd = PtoHq(pwnd);

    UnsetRedirectedWindow(pwnd, REDIRECT_LAYER);

    /*
     * If the window is still visible, leave the sprite bits on the screen.
     */
    if (TestWF(pwnd, WFVISIBLE)) {
        GreUpdateSprite(gpDispInfo->hDev,
                        hwnd,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        ULW_NOREPAINT,
                        NULL);
    }

    /*
     * Delete the sprite object.
     */
    if (!GreDeleteSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL)) {
        RIPMSG1(RIP_WARNING, "xxxSetLayeredWindow failed 0x%p", pwnd);
    }
    ClrWF(pwnd, WEFLAYERED);

    /*
     * Make sure the window gets painted if visible.
     *
     * RAID 143578.
     * Should consider to jiggle the mouse. Remove IDC_NOMOUSE when
     * SetFMouseMoved and thus InvalidateDCCache don't leave crit.
     * This is because the hit-testing by a window may change when it
     * transitions the layering state.
     */
    if (TestWF(pwnd, WFVISIBLE)) {
        BEGINATOMICCHECK();
        zzzInvalidateDCCache(pwnd, IDC_DEFAULT | IDC_NOMOUSE);
        ENDATOMICCHECK();
    }
}

/***************************************************************************\
* xxxSetLayeredWindow
*
* 12/05/97      vadimg      wrote
\***************************************************************************/
HANDLE xxxSetLayeredWindow(
    PWND pwnd,
    BOOL fRepaintBehind)
{
    HANDLE hsprite;
    SIZE size;

    CheckLock(pwnd);

#ifndef CHILD_LAYERING
    if (!FTopLevel(pwnd)) {
        RIPMSG1(RIP_WARNING, "xxxSetLayeredWindow: not top-level 0x%p", pwnd);
        return NULL;
    }
#endif

    UserAssertMsg1(!TestWF(pwnd, WEFLAYERED),
                   "xxxSetLayeredWindow: already layered 0x%p",
                   pwnd);

    size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
    size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

    hsprite = GreCreateSprite(gpDispInfo->hDev, PtoHq(pwnd), &pwnd->rcWindow);
    if (hsprite == NULL) {
        RIPMSG1(RIP_WARNING, "xxxSetLayeredWindow failed 0x%p", pwnd);
        return NULL;
    }

    SetWF(pwnd, WEFLAYERED);
    TrackLayeredZorder(pwnd);

    /*
     * Invalidate the DC cache because changing the sprite status
     * may change the visrgn for some windows.
     *
     * RAID 143578.
     * Should jiggle the mouse. Remove IDC_NOMOUSE when
     * SetFMouseMoved and thus InvalidateDCCache don't leave crit.
     * This is because the hit-testing by a window may change when it
     * transitions the layering state.
     */
    BEGINATOMICCHECK();
    zzzInvalidateDCCache(pwnd, IDC_DEFAULT | IDC_NOMOUSE);
    ENDATOMICCHECK();

    /*
     * For the dynamic promotion to a sprite, put the proper bits into
     * the sprite itself by doing ULW with the current screen content
     * and into the background by invalidating windows behind.  There
     * might be some dirty bits if the window is partially obscured, but
     * they will be refreshed as soon as the app calls ULW on its own.
     */
    if (TestWF(pwnd, WFVISIBLE)) {
        if (fRepaintBehind) {
            POINT pt;

            pt.x = pwnd->rcWindow.left;
            pt.y = pwnd->rcWindow.top;

            _UpdateLayeredWindow(pwnd, gpDispInfo->hdcScreen, &pt, &size,
                    gpDispInfo->hdcScreen, &pt, 0, NULL, ULW_OPAQUE);
        }
    } else {
        /*
         * No need to repaint behind if the window is still invisible.
         */
        fRepaintBehind = FALSE;
    }

    /*
     * This must be done after the DC cache is invalidated, because
     * the xxxUpdateWindows call will redraw some stuff.
     */
    if (fRepaintBehind) {
        HRGN hrgn = GreCreateRectRgnIndirect(&pwnd->rcWindow);
        xxxRedrawWindow(NULL, NULL, hrgn,
                RDW_INVALIDATE | RDW_FRAME | RDW_ERASE | RDW_ALLCHILDREN);
        xxxUpdateWindows(pwnd, hrgn);
        GreDeleteObject(hrgn);
    }
    return hsprite;
}

/***************************************************************************\
* UserVisrgnFromHwnd
*
* Calculate a non-clipchildren visrgn for sprites. This function must be
* called while inside the USER critical section.
*
* 12/05/97      vadimg      wrote
\***************************************************************************/

BOOL UserVisrgnFromHwnd(HRGN *phrgn, HWND hwnd)
{
    PWND pwnd;
    DWORD dwFlags;
    RECT rcWindow;
    BOOL fRet;

    CheckCritIn();

    if ((pwnd = RevalidateHwnd(hwnd)) == NULL) {
        RIPMSG0(RIP_WARNING, "VisrgnFromHwnd: invalid hwnd");
        return FALSE;
    }

    /*
     * So that we don't have to recompute the layered window's visrgn
     * every time the layered window is moved, we compute the visrgn once
     * as if the layered window covered the entire screen.  GDI will
     * automatically intersect with this region whenever the sprite moves.
     */
    rcWindow = pwnd->rcWindow;
    pwnd->rcWindow = gpDispInfo->rcScreen;

    /*
     * Since we use DCX_WINDOW, only rcWindow needs to be faked and saved.
     * Never specify DCX_REDIRECTEDBITMAP here. See comments in CalcVisRgn().
     */
    dwFlags = DCX_WINDOW | DCX_LOCKWINDOWUPDATE;
    if (TestWF(pwnd, WFCLIPSIBLINGS))
        dwFlags |= DCX_CLIPSIBLINGS;

    fRet = CalcVisRgn(phrgn, pwnd, pwnd, dwFlags);

    pwnd->rcWindow = rcWindow;

    return fRet;
}

/***************************************************************************\
* SetRectRelative
\***************************************************************************/

void SetRectRelative(PRECT prc, int dx, int dy, int dcx, int dcy)
{
    prc->left += dx;
    prc->top += dy;
    prc->right += (dx + dcx);
    prc->bottom += (dy + dcy);
}

/***************************************************************************\
* xxxUpdateLayeredWindow
*
* 1/20/1998   vadimg          created
\***************************************************************************/

BOOL _UpdateLayeredWindow(
    PWND pwnd,
    HDC hdcDst,
    POINT *pptDst,
    SIZE *psize,
    HDC hdcSrc,
    POINT *pptSrc,
    COLORREF crKey,
    BLENDFUNCTION *pblend,
    DWORD dwFlags)
{
    int dx, dy, dcx, dcy;
    BOOL fMove = FALSE, fSize = FALSE;

    /*
     * Verify that we're called with a real layered window.
     */
    if (!TestWF(pwnd, WEFLAYERED) ||
            GetRedirectionBitmap(pwnd) != NULL) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING,
                "_UpdateLayeredWindow: can't call on window 0x%p", pwnd);
        return FALSE;
    }

    if (!GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, hdcDst, pptDst,
            psize, hdcSrc, pptSrc, crKey, pblend, dwFlags, NULL)) {
        RIPMSG1(RIP_WARNING, "_UpdateLayeredWindow: !UpdateSprite 0x%p", pwnd);
        return FALSE;
    }

    /*
     * Figure out relative adjustments in position and size.
     */
    if (pptDst != NULL) {
        dx = pptDst->x - pwnd->rcWindow.left;
        dy = pptDst->y - pwnd->rcWindow.top;
        if (dx != 0 || dy != 0) {
            fMove = TRUE;
        }
    } else {
        dx = 0;
        dy = 0;
    }
    if (psize != NULL) {
        dcx = psize->cx - (pwnd->rcWindow.right - pwnd->rcWindow.left);
        dcy = psize->cy - (pwnd->rcWindow.bottom - pwnd->rcWindow.top);
        if (dcx != 0 || dcy != 0) {
            fSize = TRUE;
        }
    } else {
        dcx = 0;
        dcy = 0;
    }

    if (fMove || fSize) {
        /*
         * Adjust the client rect position and size relative to
         * the window rect.
         */
        SetRectRelative(&pwnd->rcWindow, dx, dy, dcx, dcy);
        SetRectRelative(&pwnd->rcClient, dx, dy, dcx, dcy);

        /*
         * Since the client rect could be smaller than the window
         * rect make sure the client rect doesn't underflow!
         */
        if ((dcx < 0) && (pwnd->rcClient.left < pwnd->rcWindow.left)) {
            pwnd->rcClient.left = pwnd->rcWindow.left;
            pwnd->rcClient.right = pwnd->rcWindow.left;
        }
        if ((dcy < 0) && (pwnd->rcClient.top < pwnd->rcWindow.top)) {
            pwnd->rcClient.top = pwnd->rcWindow.top;
            pwnd->rcClient.bottom = pwnd->rcWindow.top;
        }

       /*
        * RAID 143578.
        * The shape of the layered window may have changed and thus
        * ideally we should jiggle the mouse. Currently, that would
        * make us leave the critical section which we don't want to do.
        *
        * SetFMouseMoved();
        */
    }

    return TRUE;
}

/***************************************************************************\
* DeleteFadeSprite
\***************************************************************************/

PWND DeleteFadeSprite(void)
{
    PWND pwnd = NULL;

    if (gfade.dwFlags & FADE_WINDOW) {
        if ((pwnd = RevalidateHwnd(gfade.hsprite)) != NULL) {
            if (TestWF(pwnd, WEFLAYERED)) {
                UnsetLayeredWindow(pwnd);
            }
        } else {
            RIPMSG0(RIP_WARNING, "DeleteFadeSprite: hwnd no longer valid");
        }
    } else {
        GreDeleteSprite(gpDispInfo->hDev, NULL, gfade.hsprite);
    }
    gfade.hsprite = NULL;
    return pwnd;
}

/***************************************************************************\
* UpdateFade
*
* 2/16/1998   vadimg          created
\***************************************************************************/

void UpdateFade(POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc,
        BLENDFUNCTION *pblend)
{
    PWND pwnd;

    if (gfade.dwFlags & FADE_WINDOW) {
        if ((pwnd = RevalidateHwnd(gfade.hsprite)) != NULL) {
            _UpdateLayeredWindow(pwnd, NULL, pptDst, psize, hdcSrc,
                     pptSrc, 0, pblend, ULW_ALPHA);
        }
    } else {
#ifdef MOUSE_IP
        DWORD dwShape = ULW_ALPHA;

        if (gfade.dwFlags & FADE_COLORKEY) {
            dwShape = ULW_COLORKEY;
        }
        GreUpdateSprite(gpDispInfo->hDev, NULL, gfade.hsprite, NULL,
                pptDst, psize, hdcSrc, pptSrc, gfade.crColorKey, pblend, dwShape, NULL);
#else
        GreUpdateSprite(gpDispInfo->hDev, NULL, gfade.hsprite, NULL,
                pptDst, psize, hdcSrc, pptSrc, 0, pblend, ULW_ALPHA, NULL);
#endif
    }
}

/***************************************************************************\
* CreateFade
*
* 2/5/1998   vadimg          created
\***************************************************************************/

HDC CreateFade(PWND pwnd, RECT *prc, DWORD dwTime, DWORD dwFlags)
{
    SIZE size;

    /*
     * Bail if there is a fade animation going on already.
     */
    if (gfade.hbm != NULL) {
        RIPMSG0(RIP_WARNING, "CreateFade: failed, fade not available");
        return NULL;
    }

    /*
     * Create a cached compatible DC.
     */
    if (gfade.hdc == NULL) {
        gfade.hdc = GreCreateCompatibleDC(gpDispInfo->hdcScreen);
        if (gfade.hdc == NULL) {
            return NULL;
        }
    } else {
        /*
         * Reset the hdc before reusing it.
         */
        GreSetLayout(gfade.hdc , -1, 0);
    }

    /*
     * A windowed fade must have window position and size, so
     * prc passed in is disregarded.
     */
    UserAssert((pwnd == NULL) || (prc == NULL));

    if (pwnd != NULL) {
        prc = &pwnd->rcWindow;
    }

    size.cx = prc->right - prc->left;
    size.cy = prc->bottom - prc->top;

    if (pwnd == NULL) {
        gfade.hsprite = GreCreateSprite(gpDispInfo->hDev, NULL, prc);
    } else {
        gfade.dwFlags |= FADE_WINDOW;
        gfade.hsprite = HWq(pwnd);

        BEGINATOMICCHECK();
        xxxSetLayeredWindow(pwnd, FALSE);
        ENDATOMICCHECK();
    }

    if (gfade.hsprite == NULL)
        return FALSE;

    /*
     * Create a compatible bitmap for this size animation.
     */
    gfade.hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, size.cx, size.cy);
    if (gfade.hbm == NULL) {
        DeleteFadeSprite();
        return NULL;
    }

    GreSelectBitmap(gfade.hdc, gfade.hbm);

    /*
     * Mirror the hdc if it will be used to fade a mirrored window.
     */
    if ((pwnd != NULL) && TestWF(pwnd, WEFLAYOUTRTL)) {
        GreSetLayout(gfade.hdc , -1, LAYOUT_RTL);
    }

    /*
     * Since this isn't necessarily the first animation and the hdc could
     * be set to public, make sure the owner is the current process. This
     * way this process will be able to draw into it.
     */
    GreSetDCOwner(gfade.hdc, OBJECT_OWNER_CURRENT);

    /*
     * Initialize all other fade animation data.
     */
    gfade.ptDst.x = prc->left;
    gfade.ptDst.y = prc->top;
    gfade.size.cx = size.cx;
    gfade.size.cy = size.cy;
    gfade.dwTime = dwTime;
    gfade.dwFlags |= dwFlags;
#ifdef MOUSE_IP
    if (gfade.dwFlags & FADE_COLORKEY) {
        gfade.crColorKey = COLORKEY_COLOR;
    } else {
        gfade.crColorKey = 0;
    }
#endif

    return gfade.hdc;
}

/***************************************************************************\
* ShowFade
*
* GDI says that for alpha fade-out it's more efficient to do the first
* show as opaque alpha instead of using ULW_OPAQUE.
\***************************************************************************/

#define ALPHASTART 40

VOID ShowFade(
    VOID)
{
    BLENDFUNCTION blend;
    POINT ptSrc;
    BOOL fShow;

    UserAssert(gfade.hdc != NULL);
    UserAssert(gfade.hbm != NULL);

    if (gfade.dwFlags & FADE_SHOWN) {
        return;
    }

    fShow = (gfade.dwFlags & FADE_SHOW);
    ptSrc.x = ptSrc.y = 0;
    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = fShow ? ALPHASTART : (255 - ALPHASTART);
    UpdateFade(&gfade.ptDst, &gfade.size, gfade.hdc, &ptSrc, &blend);

    gfade.dwFlags |= FADE_SHOWN;
}

/***************************************************************************\
* StartFade
*
* 2/5/1998   vadimg          created
\***************************************************************************/
VOID StartFade(
    VOID)
{
    DWORD dwTimer = 10;
    DWORD dwElapsed;

    UserAssert(gfade.hdc != NULL);
    UserAssert(gfade.hbm != NULL);

    /*
     * Set dc and bitmap to public so the desktop thread can use them.
     */
    GreSetDCOwner(gfade.hdc, OBJECT_OWNER_PUBLIC);
    GreSetBitmapOwner(gfade.hbm, OBJECT_OWNER_PUBLIC);

    /*
     * If it's not already shown, do the initial update that makes copy of
     * the source. All other updates will only need to change the alpha value.
     */
    ShowFade();

    /*
     * Get the start time for the fade animation.
     */
    dwElapsed = (gfade.dwTime * ALPHASTART + 255) / 255;
    gfade.dwStart = NtGetTickCount() - dwElapsed;

    /*
     * Set the timer in the desktop thread. This will insure that the
     * animation is smooth and won't get stuck if the current thread hangs.
     */
#ifdef MOUSE_IP
    if (gfade.dwFlags & FADE_SONAR) {
        /*
         * Sonar requires slower timer.
         */
        dwTimer = MOUSE_SONAR_RADIUS_TIMER;
    }
#endif

    InternalSetTimer(gTermIO.spwndDesktopOwner,
                     IDSYS_FADE,
                     dwTimer,
                     xxxSystemTimerProc,
                     TMRF_SYSTEM | TMRF_PTIWINDOW);
}

/***************************************************************************\
* StopFade
*
* 2/5/1998   vadimg          created
\***************************************************************************/
VOID StopFade(
    VOID)
{
    DWORD dwRop = SRCCOPY;
    PWND pwnd;

    UserAssert(gfade.hdc != NULL);
    UserAssert(gfade.hbm != NULL);

    /*
     * Stop the fade animation timer.
     */
    _KillSystemTimer(gTermIO.spwndDesktopOwner, IDSYS_FADE);

    pwnd = DeleteFadeSprite();

    /*
     * If showing and the animation isn't completed, blt the last frame.
     */
    if (!(gfade.dwFlags & FADE_COMPLETED) && (gfade.dwFlags & FADE_SHOW)) {
        int x, y;
        HDC hdc;

        /*
         * For a windowed fade, make sure we observe the current visrgn.
         */
        if (pwnd != NULL) {
            hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_CACHE);
            x = 0;
            y = 0;
        } else {
            hdc = gpDispInfo->hdcScreen;
            x = gfade.ptDst.x;
            y = gfade.ptDst.y;
        }

        /*
         * If the destination DC is RTL mirrored, then BitBlt call should mirror the
         * content, since we want the menu to preserve it text (i.e. not to
         * be flipped). [samera]
         */
        if (GreGetLayout(hdc) & LAYOUT_RTL) {
            dwRop |= NOMIRRORBITMAP;
        }
        GreBitBlt(hdc, x, y, gfade.size.cx, gfade.size.cy, gfade.hdc, 0, 0, dwRop, 0);
        _ReleaseDC(hdc);
    }

    /*
     * Clean up the animation data.
     */
    GreSelectBitmap(gfade.hdc, GreGetStockObject(PRIV_STOCK_BITMAP));
    GreCleanDC(gfade.hdc);
    GreSetDCOwner(gfade.hdc, OBJECT_OWNER_PUBLIC);
    GreDeleteObject(gfade.hbm);

    gfade.hbm = NULL;
    gfade.dwFlags = 0;
}

/***************************************************************************\
* AnimateFade
*
* 2/5/1998   vadimg          created
\***************************************************************************/
VOID AnimateFade(
    VOID)
{
    DWORD dwTimeElapsed;
    BLENDFUNCTION blend;
    BYTE bAlpha;
    BOOL fShow;

    UserAssert(gfade.hdc != NULL);
    UserAssert(gfade.hbm != NULL);

    dwTimeElapsed = NtGetTickCount() - gfade.dwStart;

    /*
     * If exceeding the allowed time, stop the animation now.
     */
    if (dwTimeElapsed > gfade.dwTime) {
        StopFade();
        return;
    }

    fShow = (gfade.dwFlags & FADE_SHOW);

    /*
     * Calculate new alpha value based on time elapsed.
     */
    if (fShow) {
        bAlpha = (BYTE)((255 * dwTimeElapsed) / gfade.dwTime);
    } else {
        bAlpha = (BYTE)(255 * (gfade.dwTime - dwTimeElapsed) / gfade.dwTime);
    }

    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = bAlpha;

 #ifdef MOUSE_IP
    if (gfade.dwFlags & FADE_SONAR) {
        DrawSonar(gfade.hdc);
        UpdateFade(&gfade.ptDst, &gfade.size, gfade.hdc, (LPPOINT)&gZero.pt, NULL);
        giSonarRadius -= MOUSE_SONAR_RADIUS_DELTA;
    } else {
        UpdateFade(NULL, NULL, NULL, NULL, &blend);
    }

    /*
     * Check if finished animating the fade.
     */
    if ((fShow && bAlpha == 255) || (!fShow && bAlpha == 0) || ((gfade.dwFlags & FADE_SONAR) && giSonarRadius < 0)) {
        gfade.dwFlags |= FADE_COMPLETED;
        StopFade();
    }
#else
    UpdateFade(NULL, NULL, NULL, NULL, &blend);

    /*
     * Check if finished animating the fade.
     */
    if ((fShow && bAlpha == 255) || (!fShow && bAlpha == 0)) {
        gfade.dwFlags |= FADE_COMPLETED;
        StopFade();
    }
#endif
}

/***************************************************************************\
* SetRedirectedWindow
*
* 1/27/99      vadimg      wrote
\***************************************************************************/
BOOL SetRedirectedWindow(
    PWND pwnd,
    UINT uFlags)
{
    HBITMAP hbmNew = NULL;
    PREDIRECT prdr;
    PCLS pcls;

    if (!TestWF(pwnd, WEFPREDIRECTED)) {
        /*
         * Setup the window for Redirection.  This will create a new bitmap to
         * redirect drawing into, and then converting all HDC's to that window
         * to draw into that bitmap.  The contents of the bitmap will be copied
         * to the screen in UpdateRedirectedDC().
         */

        UserAssert(GetRedirectionBitmap(pwnd) == NULL);


        /*
         * NOTE: We can only redirect windows that don't use CS_CLASSDC or
         * CS_PARENTDC.  This is because we need to setup a new to draw into
         * that is not the screen HDC.  When we do this, we explicitely mark
         * the DC with DCX_REDIRECTED.
         *
         * In the case of CS_CLASSDC or CS_PARENTDC, that DC may be shared
         * between a redirected window and a non-redirected window, causing a
         * conflict.
         *
         * This is not a problem for CS_OWNDC, since the window has its own
         * HDC that will not be shared.  It does however require that we setup
         * redirection after this HDC is already built.  This behavior was
         * changed in Whistler (NT 5.1).
         */

        pcls = pwnd->pcls;
        if (TestCF2(pcls, CFPARENTDC) || TestCF2(pcls, CFCLASSDC)) {
            RIPMSG0(RIP_WARNING, "Cannot enable redirection on CS_PARENTDC, or CS_CLASSDC window");
            return FALSE;
        }

        if ((hbmNew = CreateRedirectionBitmap(pwnd)) == NULL) {
            return FALSE;
        }

        ConvertRedirectionDCs(pwnd, hbmNew);
    }

    prdr = _GetProp(pwnd, PROP_LAYER, TRUE);
    prdr->uFlags |= uFlags;

#if DBG
    prdr->pwnd = pwnd;
#endif

    return TRUE;
}

/***************************************************************************\
* UnsetRedirectedWindow
*
* 1/27/1999        vadimg      created
\***************************************************************************/
VOID UnsetRedirectedWindow(
    PWND pwnd,
    UINT uFlags)
{
    if (TestWF(pwnd, WEFPREDIRECTED)) {
        PREDIRECT prdr = _GetProp(pwnd, PROP_LAYER, TRUE);

        prdr->uFlags &= ~uFlags;

        if (prdr->uFlags != 0) {
            return;
        }

        RemoveRedirectionBitmap(pwnd);
    }
}

#ifdef CHILD_LAYERING

/***************************************************************************\
* GetNextLayeredWindow
*
* Preorder traversal of the window tree to find the next layering window
* below in zorder than pwnd. We need this because sprites are stored in a
* linked list. Note that this algorithm is iterative which is cool!
\***************************************************************************/
PWND GetNextLayeredWindow(
    PWND pwnd)
{
    while (TRUE) {
        if (pwnd->spwndChild != NULL) {
            pwnd = pwnd->spwndChild;
        } else if (pwnd->spwndNext != NULL) {
            pwnd = pwnd->spwndNext;
        } else {

            do {
                pwnd = pwnd->spwndParent;

                if (pwnd == NULL) {
                    return NULL;
                }

            } while (pwnd->spwndNext == NULL);

            pwnd = pwnd->spwndNext;
        }

        if (TestWF(pwnd, WEFLAYERED)) {
            return pwnd;
        }
    }
}
#endif

/***************************************************************************\
* GetStyleWindow
*
\***************************************************************************/
PWND GetStyleWindow(
    PWND pwnd,
    DWORD dwStyle)
{
    while (pwnd != NULL) {
        if (TestWF(pwnd, dwStyle)) {
            break;
        }

        pwnd = pwnd->spwndParent;
    }

    return pwnd;
}

/***************************************************************************\
* TrackLayeredZorder
*
* Unlike USER, GDI stores sprites from bottom to top.
\***************************************************************************/
VOID TrackLayeredZorder(
    PWND pwnd)
{
#ifdef CHILD_LAYERING

    PWND pwndT = GetNextLayeredWindow(pwnd);

#else

    PWND pwndT = pwnd->spwndNext;

    while (pwndT != NULL) {
        if (TestWF(pwndT, WEFLAYERED)) {
            break;
        }

        pwndT = pwndT->spwndNext;
    }

#endif

    GreZorderSprite(gpDispInfo->hDev, PtoHq(pwnd), PtoH(pwndT));
}

/***************************************************************************\
* GetRedirectionBitmap
*
\***************************************************************************/
HBITMAP GetRedirectionBitmap(
    PWND pwnd)
{
    PREDIRECT prdr = _GetProp(pwnd, PROP_LAYER, TRUE);

    if (prdr != NULL) {
        return prdr->hbm;
    }

    return NULL;
}

/***************************************************************************\
* SetRedirectionBitmap
*
\***************************************************************************/
BOOL SetRedirectionBitmap(
    PWND pwnd,
    HBITMAP hbm)
{
    PREDIRECT prdr;

    if (hbm == NULL) {
        prdr = (PREDIRECT)InternalRemoveProp(pwnd, PROP_LAYER, TRUE);
        if (prdr != NULL) {
            UserFreePool(prdr);
        }
    } else {
        prdr = _GetProp(pwnd, PROP_LAYER, TRUE);
        if (prdr == NULL) {
            if ((prdr = (PREDIRECT)UserAllocPool(sizeof(REDIRECT),
                    TAG_REDIRECT)) == NULL) {
                return FALSE;
            }

            if (!InternalSetProp(pwnd, PROP_LAYER, (HANDLE)prdr, PROPF_INTERNAL)) {
                UserFreePool(prdr);
                return FALSE;
            }
        } else {
            DeleteMaybeSpecialRgn(prdr->hrgnComp);
        }

        prdr->hbm = hbm;
        prdr->uFlags = 0;
        prdr->hrgnComp = NULL;
        SetRectEmpty(&prdr->rcUpdate);
    }

    return TRUE;
}


#ifdef MOUSE_IP
CONST RECT grcSonar = {0, 0, MOUSE_SONAR_RADIUS_INIT * 2, MOUSE_SONAR_RADIUS_INIT * 2};

VOID DrawSonar(
    HDC hdc)
{
    HBRUSH  hbrBackground;
    HBRUSH  hbrRing, hbrOld;
    HPEN    hpen, hpenOld;

    hbrBackground = GreCreateSolidBrush(COLORKEY_COLOR);
    if (hbrBackground == NULL) {
        RIPMSG0(RIP_WARNING, "DrawSonar: failed to create background brush.");
        return;
    }
    FillRect(hdc, &grcSonar, hbrBackground);

    /*
     * Pen for the edges.
     */
    hpen = GreCreatePen(PS_SOLID, 0, RGB(255, 255, 255), NULL);
    if (hpen == NULL) {
        RIPMSG0(RIP_WARNING, "DrawSonar: failed to create pen.");
        goto return1;
    }
    hpenOld = GreSelectPen(hdc, hpen);

    /*
     * Draw the ring.
     */
    hbrRing = GreCreateSolidBrush(RGB(128, 128, 128));
    if (hbrRing == NULL) {
        goto return2;
    }
    hbrOld = GreSelectBrush(hdc, hbrRing);

    NtGdiEllipse(hdc, MOUSE_SONAR_RADIUS_INIT - giSonarRadius, MOUSE_SONAR_RADIUS_INIT - giSonarRadius,
                 MOUSE_SONAR_RADIUS_INIT + giSonarRadius, MOUSE_SONAR_RADIUS_INIT + giSonarRadius);

    /*
     * Draw innter hollow area (this draws inner edge as well).
     */
    GreSelectBrush(hdc, hbrBackground);
    NtGdiEllipse(hdc, MOUSE_SONAR_RADIUS_INIT - giSonarRadius + MOUSE_SONAR_LINE_WIDTH,
                      MOUSE_SONAR_RADIUS_INIT - giSonarRadius + MOUSE_SONAR_LINE_WIDTH,
                      MOUSE_SONAR_RADIUS_INIT + giSonarRadius - MOUSE_SONAR_LINE_WIDTH,
                      MOUSE_SONAR_RADIUS_INIT + giSonarRadius - MOUSE_SONAR_LINE_WIDTH);

    /*
     * Clean up things.
     */
    GreSelectBrush(hdc, hbrOld);
    UserAssert(hbrRing);
    GreDeleteObject(hbrRing);
return2:
    GreSelectPen(hdc, hpenOld);
    if (hpen) {
        GreDeleteObject(hpen);
    }

return1:
    if (hbrBackground) {
        GreDeleteObject(hbrBackground);
    }
}

/***************************************************************************\
* SonarAction
*
\***************************************************************************/
BOOL StartSonar(
    VOID)
{
    HDC hdc;
    RECT rc;

    UserAssert(TestUP(MOUSESONAR));

    gptSonarCenter = gpsi->ptCursor;

    /*
     * LATER: Is this the right thing?
     */
    if (gfade.dwFlags) {
        /*
         * Some other animation is going on.
         * Stop it first.
         */
        UserAssert(!TestFadeFlags(FADE_SONAR));
        StopSonar();
        UserAssert(gfade.dwFlags == 0);
    }

    rc.left = gptSonarCenter.x - MOUSE_SONAR_RADIUS_INIT;
    rc.right = gptSonarCenter.x + MOUSE_SONAR_RADIUS_INIT;
    rc.top = gptSonarCenter.y - MOUSE_SONAR_RADIUS_INIT;
    rc.bottom = gptSonarCenter.y + MOUSE_SONAR_RADIUS_INIT;

    giSonarRadius = MOUSE_SONAR_RADIUS_INIT;

    hdc = CreateFade(NULL, &rc, CMS_SONARTIMEOUT, FADE_SONAR | FADE_COLORKEY);
    if (hdc == NULL) {
        RIPMSG0(RIP_WARNING, "StartSonar: failed to create a new sonar.");
        return FALSE;
    }

    /*
     * Start sonar animation.
     */
    DrawSonar(hdc);
    StartFade();
    AnimateFade();

    return TRUE;
}

VOID StopSonar(
    VOID)
{
    UserAssert(TestUP(MOUSESONAR));

    StopFade();
    giSonarRadius = -1;
}

#endif  // MOUSE_IP

/***************************************************************************\
* GetRedirectionFlags
*
* GetRedirectionFlags returns the current redirection flags for a given
* window.
*
* 2/8/2000      JStall          created
\***************************************************************************/
UINT GetRedirectionFlags(
    PWND pwnd)
{
    PREDIRECT prdr = _GetProp(pwnd, PROP_LAYER, TRUE);
    if (prdr != NULL) {
        return prdr->uFlags;
    }

    return 0;
}


/***************************************************************************\
* xxxPrintWindow
*
* xxxPrintWindow uses redirection to get a complete bitmap of a window. If
* the window already has a redirection bitmap, the bits will be directly
* copied. If the window doesn't have a redirection bitmap, it will be
* temporarily redirected, forcibly redrawn, and then returned to its
* previous state.
*
* 2/8/2000      JStall          created
\***************************************************************************/
BOOL xxxPrintWindow(
    PWND pwnd,
    HDC hdcBlt,
    UINT nFlags)
{
    HDC hdcSrc;
    SIZE sizeBmpPxl;
    POINT ptOffsetPxl;
    BOOL fTempRedir;
    BOOL fSuccess;

    CheckLock(pwnd);

    /*
     * Determine the area of the window to copy.
     */
    if ((nFlags & PW_CLIENTONLY) != 0) {
        /*
         * Only get the client area
         */
        ptOffsetPxl.x = pwnd->rcWindow.left - pwnd->rcClient.left;
        ptOffsetPxl.y = pwnd->rcWindow.top - pwnd->rcClient.top;
        sizeBmpPxl.cx = pwnd->rcClient.right - pwnd->rcClient.left;
        sizeBmpPxl.cy = pwnd->rcClient.bottom - pwnd->rcClient.top;
    } else {
        /*
         * Return the entire window
         */
        ptOffsetPxl.x = 0;
        ptOffsetPxl.y = 0;
        sizeBmpPxl.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
        sizeBmpPxl.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;
    }

    /*
     * Redirect the window so that we can get the bits.  Since this flag never
     * is turned on outside this function call, always safe to turn it on here.
     */
    fTempRedir = (GetRedirectionFlags(pwnd) == 0);

    if (!SetRedirectedWindow(pwnd, REDIRECT_PRINT)) {
        /*
         * Unable to redirect the window, so can't get the bits.
         */

        fSuccess = FALSE;
        goto Done;
    } else {
        fSuccess = TRUE;
    }

    if (fTempRedir) {
        xxxUpdateWindow(pwnd);
    }

    hdcSrc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_CACHE);
    GreBitBlt(hdcBlt, 0, 0, sizeBmpPxl.cx, sizeBmpPxl.cy,
            hdcSrc, ptOffsetPxl.x, ptOffsetPxl.y, SRCCOPY | NOMIRRORBITMAP, 0);
    _ReleaseDC(hdcSrc);

    /*
     * Cleanup
     */
    UnsetRedirectedWindow(pwnd, REDIRECT_PRINT);

Done:
    return fSuccess;
}


/***************************************************************************\
* xxxEnumTurnOffCompositing
*
* xxxEnumTurnOffCompositing() is called for each window, giving an
* opportunity to turn off WS_EX_COMPOSITED for that window.
*
* 8/21/2000     JStall          created
\***************************************************************************/

BOOL APIENTRY xxxEnumTurnOffCompositing(PWND pwnd, LPARAM lParam)
{
    CheckLock(pwnd);

    UNREFERENCED_PARAMETER(lParam);

    if (TestWF(pwnd, WEFCOMPOSITED)) {
        DWORD dwStyle = (pwnd->ExStyle & ~WS_EX_COMPOSITED) & WS_EX_ALLVALID;
        xxxSetWindowStyle(pwnd, GWL_EXSTYLE, dwStyle);
    }

    return TRUE;
}


/***************************************************************************\
* xxxTurnOffCompositing
*
* xxxTurnOffCompositing() turns off WS_EX_COMPOSITED for (optionally a
* PWND and) its children.  This is used when reparenting under
* a parent-chain that has WS_EX_COMPOSITED already turned on.  If we don't
* turn off WS_EX_COMPOSITED for the children, it takes extra bitmaps and the
* compositing will not properly work.
*
* 8/21/2000     JStall          created
\***************************************************************************/
VOID xxxTurnOffCompositing(
    PWND pwndStart,
    BOOL fChild)
{
    TL tlpwnd;
    UINT nFlags = BWL_ENUMCHILDREN;

    CheckLock(pwndStart);

    /*
     * If they want to skip over the wnd itself and start with this WND's
     * child, we need to get and lock that child.  We will unlock it when
     * finished.  We also need to mark BWL_ENUMLIST so that we will enumerate
     * all of the children.
     */
    if (fChild) {
        pwndStart = pwndStart->spwndChild;
        if (pwndStart == NULL) {
            return;
        }
        nFlags |= BWL_ENUMLIST;

        ThreadLockAlways(pwndStart, &tlpwnd);
    }


    /*
     * Enumerate the windows.
     */
    xxxInternalEnumWindow(pwndStart, xxxEnumTurnOffCompositing, 0, nFlags);

    if (fChild) {
        ThreadUnlock(&tlpwnd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\sysmet.c ===
/****************************** Module Header ******************************\
* Module Name: sysmet.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* System metrics APIs and support routines.
*
* History:
* 24-Sep-1990 DarrinM   Generated stubs.
* 12-Feb-1991 JimA      Added access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* _SwapMouseButton (API)
*
* History:
* 24-Sep-1990 DarrinM   Generated stubs.
* 25-Jan-1991 DavidPe   Did the real thing.
* 12-Feb-1991 JimA      Added access check
\***************************************************************************/

BOOL APIENTRY _SwapMouseButton(
    BOOL fSwapButtons)
{
    BOOL            fSwapOld;
    PPROCESSINFO    ppiCurrent = PpiCurrent();

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    RETURN_IF_ACCESS_DENIED(ppiCurrent->amwinsta,
                            WINSTA_READATTRIBUTES | WINSTA_WRITEATTRIBUTES,
                            FALSE);

    if (!(ppiCurrent->W32PF_Flags & W32PF_IOWINSTA)) {
        RIPERR0(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION,
                RIP_WARNING,
                "SwapMouseButton invalid on a non-interactive WindowStation.");

        return FALSE;
    }

    fSwapOld = SYSMET(SWAPBUTTON);
    SYSMET(SWAPBUTTON) = fSwapButtons;

    /*
     * Give xxxButtonEvent a hint that a mouse button event may have to be
     * left/right swapped to correspond with our current async key state.
     * Toggle the global since an even number of SwapMouseButtons has no effect.
     */
    if (fSwapButtons != fSwapOld) {
        gbMouseButtonsRecentlySwapped = !gbMouseButtonsRecentlySwapped;
    }

    /*
     * Return previous state
     */
    return fSwapOld;
}

/***************************************************************************\
* _SetDoubleClickTime (API)
*
* History:
* 24-Sep-1990 DarrinM   Generated stubs.
* 25-Jan-1991 DavidPe   Did the real thing.
* 12-Feb-1991 JimA      Added access check
* 16-May-1991 MikeKe    Changed to return BOOL
\***************************************************************************/

BOOL APIENTRY _SetDoubleClickTime(
    UINT dtTime)
{
    PWINDOWSTATION pwinsta = PpiCurrent()->rpwinsta;

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if (!CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    if (!dtTime) {
        dtTime = 500;
    } else if (dtTime > 5000) {
        dtTime = 5000;
    }

    gdtDblClk         = dtTime;
    gpsi->dtLBSearch = dtTime * 4;            // dtLBSearch   =  4  * gdtDblClk
    gpsi->dtScroll   = gpsi->dtLBSearch / 5;  // dtScroll     = 4/5 * gdtDblClk
    /*
     * This value should be set through SPI_SETMENUSHOWDELAY
     *   gdtMNDropDown     = gpsi->dtScroll;        // gdtMNDropDown = 4/5 * gdtDblClk
     */

    /*
     * Recalculate delays for tooltip windows on all desktops.
     */
    if (pwinsta != NULL) {
        PDESKTOP pdesk;
        for (pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {
            InitTooltipDelay((PTOOLTIPWND)pdesk->spwndTooltip);
        }
    }

    return TRUE;
}

/***************************************************************************\
* SetSysColor()
*
* Changes the value of a system color, and updates the brush.  Tries to
* recover in case of an error.
*
* History:
\***************************************************************************/
VOID SetSysColor(
    UINT  icol,
    DWORD rgb,
    UINT  uOptions
    )
{

    gpsi->argbSystemUnmatched[icol] = rgb;

    if ((uOptions & SSCF_SETMAGICCOLORS) && gpDispInfo->fAnyPalette) {
        union {
            DWORD rgb;
            PALETTEENTRY pe;
        } peMagic;

        peMagic.rgb = rgb;

        /*
         *  when any of the 3D colors are changing, call GDI to
         *  set the apropiate "magic" color
         *
         *  the four magic colors are reserved like so
         *
         *  8       - UI color (3D shadow)
         *  9       - UI color (3D face)
         *
         *  F6      - UI color (3D hilight)
         *  F7      - UI color (desktop)
         *
         *  NOTE (3D hilight) inverts to (3D shadow)
         *       (3D face)    inverts to sys gray
         *
         */

        switch (icol)
        {
        case COLOR_3DSHADOW:
            GreSetMagicColors(gpDispInfo->hdcScreen, peMagic.pe, 8);
            break;

        case COLOR_3DFACE:
            GreSetMagicColors(gpDispInfo->hdcScreen, peMagic.pe, 9);
            break;

        case COLOR_3DHILIGHT:
            GreSetMagicColors(gpDispInfo->hdcScreen, peMagic.pe, 246);
            break;

        case COLOR_DESKTOP:
            GreSetMagicColors(gpDispInfo->hdcScreen, peMagic.pe, 247);
            break;
        }
    }

    if (uOptions & SSCF_16COLORS) {
        /*
         * Force solid colors for all elements in 16 color or less modes.
         */
        rgb = GreGetNearestColor(gpDispInfo->hdcScreen, rgb);
    } else if (uOptions & SSCF_FORCESOLIDCOLOR) {
        /*
         * Force solid colors for certain window elements.
         */
        switch (icol) {

        /*
         * These can be dithers
         */
        case COLOR_DESKTOP:
        case COLOR_ACTIVEBORDER:
        case COLOR_INACTIVEBORDER:
        case COLOR_APPWORKSPACE:
        case COLOR_INFOBK:
        case COLOR_GRADIENTACTIVECAPTION:
        case COLOR_GRADIENTINACTIVECAPTION:
            break;

        default:
            rgb = GreGetNearestColor(gpDispInfo->hdcScreen, rgb);
            break;
        }
    }

    gpsi->argbSystem[icol] = rgb;
    if (SYSHBRUSH(icol) == NULL) {
        /*
         * This is the first time we're setting up the system colors.
         * We need to create the brush
         */
        SYSHBRUSH(icol) = GreCreateSolidBrush(rgb);
        GreMarkUndeletableBrush(SYSHBRUSH(icol));
        GreSetBrushOwnerPublic(SYSHBRUSH(icol));
        GreSetBrushGlobal(SYSHBRUSH(icol));
    } else {
        GreSetSolidBrush(SYSHBRUSH(icol), rgb);
    }
}

/***************************************************************************\
* xxxSetSysColors (API)
*
*
* History:
* 12-Feb-1991 JimA      Created stub and added access check
* 22-Apr-1991 DarrinM   Ported from Win 3.1 sources.
* 16-May-1991 MikeKe    Changed to return BOOL
\***************************************************************************/
BOOL APIENTRY xxxSetSysColors(PUNICODE_STRING pProfileUserName,
    int      cicol,
    PUINT    picolor,
    COLORREF *prgb,
    UINT     uOptions
    )
{
    int      i;
    UINT     icol;
    COLORREF rgb;

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((uOptions & SSCF_NOTIFY) && !CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    if (GreGetDeviceCaps(gpDispInfo->hdcScreen, NUMCOLORS) <= 16) {
        uOptions |= SSCF_16COLORS;
    }

    if (uOptions & SSCF_SETMAGICCOLORS) {
        /*
         * Set the Magic colors first
         */
        for(i = 0; i < cicol; i++) {
            icol = picolor[i];
            rgb = prgb[i];
            if (    icol == COLOR_3DFACE ||
                    icol == COLOR_3DSHADOW ||
                    icol == COLOR_3DHILIGHT ||
                    icol == COLOR_DESKTOP) {

                SetSysColor(icol, rgb, uOptions);
            }
        }
    }

    for (i = 0; i < cicol; i++) {

        icol = *picolor++;
        rgb  = *prgb++;

        if (icol >= COLOR_MAX)
            continue;

        if ((uOptions & SSCF_SETMAGICCOLORS) &&
               (icol == COLOR_3DFACE ||
                icol == COLOR_3DSHADOW ||
                icol == COLOR_3DHIGHLIGHT ||
                icol == COLOR_DESKTOP)) {
            continue;
        }

        SetSysColor(icol, rgb, uOptions);
    }

    if (uOptions & SSCF_NOTIFY) {

        /*
         * Recolor all the current desktop
         */
        RecolorDeskPattern();

        /*
         * Render the system bitmaps in new colors before we broadcast
         */

        xxxSetWindowNCMetrics(pProfileUserName,NULL, FALSE, -1);


        /*
         * Notify everyone that the colors have changed.
         */
        xxxSendNotifyMessage(PWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0L);

        /*
         * Just redraw the entire screen.  Trying to just draw the parts
         * that were changed isn't worth it, since Control Panel always
         * resets every color anyway.
         *
         * Anyway, it could get messy, sending apps NCPAINT messages without
         * accumulating update regions too.
         */
        xxxRedrawScreen();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\ssend.c ===
/****************************** Module Header ******************************\
* Module Name: ssend.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Server side sending stubs
*
* 07-06-91 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CALLBACKPROC 1
#define SERVERSIDE 1

#include "callback.h"

#define SENDSIDE 1

#define CBBUFSIZE   512

#define PADSIZE     (sizeof(ULONG_PTR) - 1)

/*
 * Callback setup and control macros
 */
#define SMESSAGECALL(api) \
LRESULT Sfn ## api(      \
    PWND pwnd,           \
    UINT msg,            \
    WPARAM wParam,       \
    LPARAM lParam,       \
    ULONG_PTR xParam,     \
    PROC xpfnProc,       \
    DWORD dwSCMSFlags,   \
    PSMS psms)

#define SETUP(api)  \
    api ## MSG m;                                           \
    api ## MSG *mp = &m;                                    \
    BYTE Buffer[CBBUFSIZE];                                 \
    PCALLBACKSTATUS pcbs;                                   \
    ULONG cbCBStatus;                                       \
    ULONG_PTR retval;                                        \
    NTSTATUS Status;

#define SETUPDC(api)  \
    SETUP(api)                         \
    int iDC = 0;                       \
    HDC     hdcUse;                    \
    HBITMAP hbmDCGray = NULL;


#define SETUPPWND(api) \
    api ## MSG m;                                               \
    api ## MSG *mp = &m;                                        \
    BYTE Buffer[CBBUFSIZE];                                     \
    PCALLBACKSTATUS pcbs;                                       \
    ULONG cbCBStatus;                                           \
    ULONG_PTR retval;                                           \
    NTSTATUS Status;                                            \
    TL tlpwnd;                                                  \
    CALLBACKWND cbwin;                                          \
    PTHREADINFO pti = PtiCurrent();                             \
    PWND pwndClient = pwnd ? (PWND)((PBYTE)pwnd - pti->ulClientDelta) : NULL; \
    UserAssert(pti->ulClientDelta != 0);

#define CALC_SIZE_IN(cb, pstr) \
    cb = (pstr)->Length + sizeof(WCHAR);  \
    if ((pstr)->bAnsi && !fAnsiReceiver)  \
        cb *= sizeof(WCHAR);

#define CALC_SIZE_OUT(cb, pstr) \
    cb = (pstr)->MaximumLength + sizeof(WCHAR); \
    if ((pstr)->bAnsi && !fAnsiReceiver)        \
        cb *= sizeof(WCHAR);

#ifdef FE_SB // CALC_SIZE_OUT_STRING()
#define CALC_SIZE_OUT_STRING(cb, pstr) \
    cb = (pstr)->MaximumLength + sizeof(WCHAR); \
    if (!(PtiCurrent()->TIF_flags & TIF_ANSILENGTH)) { \
        if ((pstr)->bAnsi && !fAnsiReceiver)           \
            cb *= sizeof(WCHAR);                       \
    }
#endif // FE_SB

#ifdef FE_SB // CALC_SIZE_STRING_OUT()
#define CALC_SIZE_STRING_OUT(cchText)                                                 \
    try {                                                                             \
        (cchText) = CalcOutputStringSize(pcbs,(cchText),fAnsiSender,fAnsiReceiver);   \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        (cchText) = 0; \
        MSGERROR(); \
    }
#endif // FE_SB

#define BEGINSEND(api) \
    mp = &m; \
    Buffer;  \
    {

#define BEGINSENDCAPTURE(api, cCapturePointers, cCaptureBytes, fInput) \
    if (cCapturePointers) {                             \
        mp = AllocCallbackMessage(sizeof(m),            \
                (cCapturePointers),                     \
                (cCaptureBytes),                        \
                Buffer,                                 \
                fInput);                                \
        if (mp == NULL)                                 \
            goto errorexitnofreemp;                     \
    } else {                                            \
        m.CaptureBuf.cbCallback = sizeof(m);            \
        m.CaptureBuf.cbCapture = 0;                     \
        m.CaptureBuf.cCapturedPointers = 0;             \
        mp = &m;                                        \
    }                                                   \
    {                                                   \
        PTHREADINFO ptiCurrent = PtiCurrent();          \
        TL tlPool;                                      \
                                                        \
        if (mp != &m && (PVOID)mp != (PVOID)Buffer)     \
            ThreadLockPool(ptiCurrent, mp, &tlPool);

#define BEGINSENDCAPTUREVOIDDC(api, cCapturePointers, cCaptureBytes, fInput)  \
    hdcUse = CreateCompatiblePublicDC(hdc,&hbmDCGray);                        \
    if (hdcUse == (HDC)NULL) {                                                \
        return;                                                               \
    }                                                                         \
    BEGINSENDCAPTURE(api, cCapturePointers, cCaptureBytes, fInput);           \

#define BEGINSENDCAPTUREDC(api, cCapturePointers, nCount, fInput)         \
    hdcUse = CreateCompatiblePublicDC(hdc,&hbmDCGray);                    \
    if (hdcUse == (HDC)NULL) {                                            \
        return FALSE;                                                     \
    }                                                                     \
    BEGINSENDCAPTURE(api, cCapturePointers, max(pstrSrc->MaximumLength,   \
    ((nCount + 1) * sizeof(WCHAR))), fInput);                             \
    

#define LOCKPWND()                                          \
    ThreadLock(pwnd, &tlpwnd);                              \
    try {                                                   \
        cbwin = pti->pClientInfo->CallbackWnd;              \
        pti->pClientInfo->CallbackWnd.pwnd = pwndClient;    \
        pti->pClientInfo->CallbackWnd.hwnd = HW(pwnd);      \
        pti->pClientInfo->CallbackWnd.pActCtx = ((pwnd == NULL) ? NULL : pwnd->pActCtx); \
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {     \
        ThreadUnlock(&tlpwnd);                              \
        MSGERROR();                                         \
    }



#define UNLOCKPWND()                                        \
    ThreadUnlock(&tlpwnd);                                  \
    try {                                                   \
        pti->pClientInfo->CallbackWnd = cbwin;              \
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {     \
        MSGERROR();                                         \
    }

#define MAKECALL(api) \
    UserAssert(!(PtiCurrent()->TIF_flags & TIF_INCLEANUP)); \
    LeaveCrit();                                            \
    Status = KeUserModeCallback(                            \
        FI_ ## api,                                         \
        mp,                                                 \
        sizeof(*mp),                                        \
        &pcbs,                                              \
        &cbCBStatus);                                       \
    EnterCrit();

#define MAKECALLCAPTURE(api) \
    UserAssert(!(PtiCurrent()->TIF_flags & TIF_INCLEANUP)); \
    LeaveCrit();                                            \
    Status = (DWORD)KeUserModeCallback(                     \
        FI_ ## api,                                         \
        mp,                                                 \
        mp->CaptureBuf.cbCallback,                          \
        &pcbs,                                              \
        &cbCBStatus);                                       \
    EnterCrit();

#define MAKECALLCAPTUREDC(api)                              \
        iDC = GreSaveDC(hdc);                               \
        MAKECALLCAPTURE(api)                                \
        GreRestoreDC(hdc, iDC);                             \
        iDC = 0;                                            \
        if ((hdcUse != hdc) && NT_SUCCESS(Status)) {        \
            GreBitBlt(hdc,                                  \
                      0,                                    \
                      0,                                    \
                      gpDispInfo->cxGray,                   \
                      gpDispInfo->cyGray,                   \
                      hdcUse,                               \
                      0,                                    \
                      0,                                    \
                      SRCCOPY,                              \
                      0);                                   \
        }

#define CHECKRETURN() \
    if (!NT_SUCCESS(Status) ||                              \
            cbCBStatus != sizeof(*pcbs)) {                  \
        goto errorexit;                                     \
    }                                                       \
    try {                                                   \
        retval = ProbeAndReadStructure(&pcbs->retval, ULONG_PTR); \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }

#define ENDSEND(type, error) \
        return (type)retval;               \
        goto errorexit;                    \
    }                                      \
errorexit:                                 \
   return (type)error

#define CLEANUPSENDCAPTURECOMMONDC() \
   if(iDC) {                                                    \
       GreRestoreDC(hdc, iDC);                                  \
   }                                                            \
   if (hdcUse != hdc) {                                         \
       GreDeleteDC(hdcUse);                                     \
       GreDeleteObject(hbmDCGray);                              \
   }                                                            \

#define BEGIN_ENDSENDCAPTURE(type, error) \
exit:
#define _ENDSENDCAPTURE(type, error) \
        if (mp != &m && (PVOID)mp != (PVOID)Buffer) {           \
            if (mp->CaptureBuf.pvVirtualAddress) {              \
                NTSTATUS Status;                                \
                SIZE_T ulRegionSize = 0;                        \
                                                                \
                Status = ZwFreeVirtualMemory(NtCurrentProcess(),\
                        &mp->CaptureBuf.pvVirtualAddress,       \
                        &ulRegionSize,                          \
                        MEM_RELEASE);                           \
                UserAssert(NT_SUCCESS(Status));                 \
            }                                                   \
            ThreadUnlockAndFreePool(ptiCurrent, &tlPool);       \
        }                                                       \
        return (type)retval;                                    \
        goto errorexit;                                         \
    }                                                           \
errorexit:                                                      \
   retval = error;                                              \
   goto exit;                                                   \
errorexitnofreemp:
#define END_ENDSENDCAPTURE(type, error) \
       return (type)error


#define ENDSENDCAPTUREDC(type, error) \
        BEGIN_ENDSENDCAPTURE(type, error); \
        CLEANUPSENDCAPTURECOMMONDC(); \
        _ENDSENDCAPTURE(type, error); \
        CLEANUPSENDCAPTURECOMMONDC(); \
        END_ENDSENDCAPTURE(type, error)

#define ENDSENDCAPTURE(type, error) \
        BEGIN_ENDSENDCAPTURE(type, error); \
        _ENDSENDCAPTURE(type, error); \
        END_ENDSENDCAPTURE(type, error)


#ifdef FE_SB // ENDSENDCAPTUREOUTSTRING()
#define ENDSENDCAPTUREOUTSTRING(type, error) \
exit:                                                           \
        if (mp != &m && (PVOID)mp != (PVOID)Buffer) {           \
            if (mp->CaptureBuf.pvVirtualAddress) {              \
                NTSTATUS Status;                                \
                SIZE_T ulRegionSize = 0;                        \
                                                                \
                Status = ZwFreeVirtualMemory(NtCurrentProcess(),\
                        &mp->CaptureBuf.pvVirtualAddress,       \
                        &ulRegionSize,                          \
                        MEM_RELEASE);                           \
                UserAssert(NT_SUCCESS(Status));                 \
            }                                                   \
            ThreadUnlockAndFreePool(ptiCurrent, &tlPool);       \
        }                                                       \
        if (bInflateWParam)                                     \
            PtiCurrent()->TIF_flags &= ~TIF_ANSILENGTH;         \
        return (type)retval;                                    \
        goto errorexit;                                         \
    }                                                           \
errorexit:                                                      \
   retval = error;                                              \
   goto exit;                                                   \
errorexitnofreemp:                                              \
   if (bInflateWParam)                                          \
       PtiCurrent()->TIF_flags &= ~TIF_ANSILENGTH;              \
   return (type)error
#endif // FE_SB

#define BEGIN_ENDSENDCAPTUREVOID() \
errorexit:
#define _ENDSENDCAPTUREVOID() \
        if (mp != &m && (PVOID)mp != (PVOID)Buffer) {           \
            if (mp->CaptureBuf.pvVirtualAddress) {              \
                NTSTATUS Status;                                \
                SIZE_T ulRegionSize = 0;                        \
                                                                \
                Status = ZwFreeVirtualMemory(NtCurrentProcess(),\
                        &mp->CaptureBuf.pvVirtualAddress,       \
                        &ulRegionSize,                          \
                        MEM_RELEASE);                           \
                UserAssert(NT_SUCCESS(Status));                 \
            }                                                   \
            ThreadUnlockAndFreePool(ptiCurrent, &tlPool);       \
        }                                                       \
        return;                                                 \
    }                                                           \
errorexitnofreemp:
#define END_ENDSENDCAPTUREVOID() \
   return

#define ENDSENDCAPTUREVOIDDC() \
        BEGIN_ENDSENDCAPTUREVOID(); \
        CLEANUPSENDCAPTURECOMMONDC(); \
        _ENDSENDCAPTUREVOID(); \
        CLEANUPSENDCAPTURECOMMONDC(); \
        END_ENDSENDCAPTUREVOID()

#define ENDSENDCAPTUREVOID() \
        BEGIN_ENDSENDCAPTUREVOID(); \
        CLEANUPSENDCAPTURECOMMON(); \
        _ENDSENDCAPTUREVOID(); \
        CLEANUPSENDCAPTURECOMMON(); \
        END_ENDSENDCAPTUREVOID()


#define ENDSENDVOID() \
    }                 \
    return

#define MSGERROR() goto errorexit

#ifdef FE_SB // CHECKRETURN1() & ENDSEND1()
#define CHECKRETURN1() \
    if (!NT_SUCCESS(Status) ||                              \
            cbCBStatus != sizeof(*pcbs)) {                  \
        goto errorexit1;                                    \
    }                                                       \
    try {                                                   \
        retval = ProbeAndReadStructure(&pcbs->retval, ULONG_PTR); \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }

#define ENDSEND1(type, error) \
        return (type)retval;               \
        goto errorexit1;                   \
    }                                      \
errorexit1:                                \
   return (type)error

#define MSGERROR1() goto errorexit1
#endif // FE_SB

/*
 * Callback IN parameter macros
 */
#define MSGDATA() (mp)

#define COPYSTRUCTOPT(x) \
        MSGDATA()->p ## x = (p ## x); \
        if (p ## x) MSGDATA()->x = *(p ## x);

#define COPYCONSTRECTSTRUCTOPT(x) \
        MSGDATA()->p ## x = (LPRECT)(p ## x); \
        if (p ## x) MSGDATA()->x = *(p ## x);

#define COPYBYTES(p, cb) \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf, p, cb, &mp->p))) \
        goto errorexit;

#define COPYBYTESOPT(p, cb) \
    if (p) {                                                                    \
        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf, p, cb, &mp->p)))   \
            goto errorexit;                                                     \
    } else {                                                                    \
        mp->p = NULL;                                                           \
    }

#define LARGECOPYBYTES(p, cb) \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf, p, cb, &mp->p))) \
        goto errorexit;

#define LARGECOPYBYTES2(src, cb, dest) \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf, src, cb, &mp->dest))) \
        goto errorexit;

#define COPYSTRING(s) \
    mp->s.Length = (p ## s)->Length;                                                \
    mp->s.MaximumLength = (p ## s)->MaximumLength;                                  \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                            \
                                        (p ## s)->Buffer,                           \
                                        (p ## s)->Length + sizeof(WCHAR),           \
                                        &mp->s.Buffer)))                            \
        goto errorexit;

#define COPYSTRINGOPT(s) \
    if (p ## s) {                                                                   \
        mp->s.Length = (p ## s)->Length;                                            \
        mp->s.MaximumLength = (p ## s)->MaximumLength;                              \
        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                        \
                                            (p ## s)->Buffer,                       \
                                            (p ## s)->Length + sizeof(WCHAR),       \
                                            &mp->s.Buffer)))                        \
            goto errorexit;                                                         \
    } else {                                                                        \
        mp->s.Length = 0;                                                           \
        mp->s.Buffer = NULL;                                                        \
    }

#define COPYSTRINGID(s) \
    mp->s.Length = (p ## s)->Length;                                                \
    mp->s.MaximumLength = (p ## s)->MaximumLength;                                  \
    if (mp->s.MaximumLength) {                                                      \
        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                        \
                                            (p ## s)->Buffer,                       \
                                            (p ## s)->Length + sizeof(WCHAR),       \
                                            &mp->s.Buffer)))                        \
            goto errorexit;                                                         \
    } else {                                                                        \
        mp->s.Buffer = (p ## s)->Buffer;                                            \
    }

#define LARGECOPYSTRINGLPWSTR(ps, psz) \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                            \
                                        (ps)->Buffer,                               \
                                        (ps)->Length + sizeof(WCHAR),               \
                                        (PVOID *)&mp->psz)))                        \
        goto errorexit;

#define LARGECOPYSTRINGLPSTR(ps, psz) \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                            \
                                        (ps)->Buffer,                               \
                                        (ps)->Length + 1,                           \
                                        (PVOID *)&mp->psz)))                        \
        goto errorexit;

#define LARGECOPYSTRINGLPWSTRA(ps, psz) \
    if (!NT_SUCCESS(CaptureAnsiCallbackData(&mp->CaptureBuf,                        \
                                        (ps)->Buffer,                               \
                                        ((ps)->Length / sizeof(WCHAR)) + 1,         \
                                        (PVOID *)&mp->psz)))                        \
        goto errorexit;

#define LARGECOPYSTRINGLPSTRW(ps, psz) \
    if (!NT_SUCCESS(CaptureUnicodeCallbackData(&mp->CaptureBuf,                     \
                                        (ps)->Buffer,                               \
                                        ((ps)->Length + 1) * sizeof(WCHAR),         \
                                        (PVOID *)&mp->psz)))                        \
        goto errorexit;                                                             \

#define LARGECOPYSTRINGLPWSTROPT(ps, psz) \
    if (ps) {                                                                       \
        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                        \
                                            (ps)->Buffer,                           \
                                            (ps)->Length + sizeof(WCHAR),           \
                                            (PVOID *)&mp->psz)))                    \
            goto errorexit;                                                         \
    } else {                                                                        \
        mp->psz = NULL;                                                             \
    }

#define LARGECOPYSTRINGLPSTROPT(ps, psz) \
    if (ps) {                                                                       \
        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                        \
                                            (ps)->Buffer,                           \
                                            (ps)->Length + sizeof(UCHAR),           \
                                            (PVOID *)&mp->psz)))                    \
            goto errorexit;                                                         \
    } else {                                                                        \
        mp->psz = NULL;                                                             \
    }

#define LARGECOPYSTRINGLPWSTROPTA(ps, psz) \
    if (ps) {                                                                       \
        if (!NT_SUCCESS(CaptureAnsiCallbackData(&mp->CaptureBuf,                    \
                                            (ps)->Buffer,                           \
                                            ((ps)->Length / sizeof(WCHAR)) + 1,     \
                                            (PVOID *)&mp->psz)))                    \
            goto errorexit;                                                         \
    } else {                                                                        \
        mp->psz = NULL;                                                             \
    }

/*
 * Wrappers to determine whether copy out should be done.
 */
#define BEGINCOPYOUT() \
    if ((psms == NULL || ((psms->flags & (SMF_SENDERDIED | SMF_REPLY)) == 0)) \
            && !(dwSCMSFlags & SCMS_FLAGS_INONLY)) {

#define ENDCOPYOUT() \
    }

/*
 * Callback OUT paramter macros
 */
#define OUTSTRUCT(pstruct, type) \
    try {                                                                   \
        *(pstruct) = ProbeAndReadStructure(((type *)pcbs->pOutput), type);  \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }

/*
 * flags field with mask (propagate back bits in mask only)
 */
#define OUTBITMASK(pstruct, type, mask) \
    try {                                                                   \
        type flags = ProbeAndReadStructure(((type *)pcbs->pOutput), type);  \
        COPY_FLAG(*(pstruct), flags, mask);                                 \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }

#ifdef FE_SB // COPYOUTLPWSTRLIMIT()
// should we insert IS_DBCS_ENABLED() in COPYOUTLPWSTRLIMIT ?
#define COPYOUTLPWSTRLIMIT(pstr, cch) \
    try {                                                                   \
        retval = CalcOutputStringSize(pcbs,(DWORD)retval,pstr->bAnsi,fAnsiReceiver); \
        CopyOutputString(pcbs, pstr, cch, fAnsiReceiver);                   \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }
#else
#define COPYOUTLPWSTRLIMIT(pstr, cch) \
    try {                                                                   \
        CopyOutputString(pcbs, pstr, cch, fAnsiReceiver);                   \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }
#endif // FE_SB

#define RESERVEBYTES(cb, dest, cbdest) \
    if (!NT_SUCCESS(AllocateCallbackData(&mp->CaptureBuf,   \
            cb, (PVOID *)&mp->dest)))                       \
        goto errorexit;                                     \
    mp->cbdest = cb;

/***************************************************************************\
* AllocCallbackMessage
*
* Allocates a callback message from pool memory and reserves space
* for arguments to captured later.
*
* 03-13-95 JimA             Created.
\***************************************************************************/

PVOID AllocCallbackMessage(
    DWORD cbBaseMsg,
    DWORD cPointers,
    SIZE_T cbCapture,
    PBYTE pStackBuffer,
    BOOL fInput)
{
    PCAPTUREBUF pcb;

    if (cPointers == 0)
        return NULL;

    /*
     * Compute allocation sizes
     */
    cbBaseMsg = (cbBaseMsg + PADSIZE) & ~PADSIZE;
    cbBaseMsg += (cPointers * sizeof(PVOID));
    cbCapture = (cbCapture + (PADSIZE * cPointers)) & ~PADSIZE;

    /*
     * If the captured data is greater than a page, place it
     * in a section.  Otherwise, put the message and the
     * data in a single block of pool
     */
    if (cbCapture > CALLBACKSTACKLIMIT) {
        NTSTATUS Status;

        /*
         * Allocate the message buffer
         */
        pcb = UserAllocPoolWithQuota(cbBaseMsg, TAG_CALLBACK);
        if (pcb == NULL)
            return NULL;

        /*
         * Allocate the virtual memory
         */
        pcb->pvVirtualAddress = NULL;
        Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
                &pcb->pvVirtualAddress, 0, &cbCapture,
                MEM_COMMIT, PAGE_READWRITE);
        if (!NT_SUCCESS(Status)) {
            RIPMSG2(RIP_WARNING, "AllocCallbackMessage: ZwAllocateVirtualMemory failed. Status:%#lx. Size:%#lx",
                    Status, cbCapture);
            UserFreePool(pcb);
            return NULL;
        }
        pcb->pbFree = pcb->pvVirtualAddress;
        pcb->cbCallback = cbBaseMsg;
    } else {

        /*
         * If the message is too big to save on the stack, allocate
         * the buffer from pool.
         */
        if (cbBaseMsg + cbCapture > CBBUFSIZE) {
            pcb = UserAllocPoolWithQuota((ULONG)(cbBaseMsg + cbCapture), TAG_CALLBACK);
            if (pcb == NULL)
                return NULL;
        } else {
            pcb = (PCAPTUREBUF)pStackBuffer;
        }
        pcb->pbFree = (PBYTE)pcb + cbBaseMsg;
        pcb->pvVirtualAddress = NULL;

        /*
         * If this callback is passing data to the client, include the
         * captured data in the message.  Otherwise, only pass the message.
         */
        if (fInput)
            pcb->cbCallback = cbBaseMsg + (ULONG)cbCapture;
        else
            pcb->cbCallback = cbBaseMsg;
    }

    /*
     * Initialize the capture buffer
     */
    pcb->cbCapture = (ULONG)cbCapture;
    pcb->cCapturedPointers = 0;
    pcb->offPointers = cbBaseMsg - (cPointers * sizeof(PVOID));

    return (PVOID)pcb;
}


/***************************************************************************\
* CaptureCallbackData
*
* Captures data into a callback structure.
*
* 03-13-95 JimA             Created.
\***************************************************************************/

NTSTATUS CaptureCallbackData(
    PCAPTUREBUF pcb,
    PVOID pData,
    DWORD cbData,
    PVOID *ppDest)
{
    PBYTE pbBuffer;

    /*
     * If the data pointer is NULL, the out pointer will be
     * NULL
     */
    if (pData == NULL) {
        *ppDest = NULL;
        return STATUS_SUCCESS;
    }

    /*
     * Allocate space from the message buffer
     */
    if (cbData > pcb->cbCapture) {
        return STATUS_BUFFER_OVERFLOW;
    }

    pbBuffer = pcb->pbFree;
    pcb->pbFree = pbBuffer + ((cbData + PADSIZE) & ~PADSIZE);

    try {
        RtlCopyMemory(pbBuffer, pData, cbData);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_ACCESS_VIOLATION;
    }

    /*
     * Fix up offsets to data.  If the data is going into a section
     * use the real pointer and don't compute offsets.
     */
    if (pcb->pvVirtualAddress)
        *ppDest = pbBuffer;
    else {
        *ppDest = (PBYTE)(pbBuffer - (PBYTE)pcb);
        ((LPDWORD)((PBYTE)pcb + pcb->offPointers))[pcb->cCapturedPointers++] =
                (DWORD)((PBYTE)ppDest - (PBYTE)pcb);
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* AllocateCallbackData
*
* Allocates space from a callback structure.
*
* 05-08-95 JimA             Created.
\***************************************************************************/

NTSTATUS AllocateCallbackData(
    PCAPTUREBUF pcb,
    DWORD cbData,
    PVOID *ppDest)
{
    PBYTE pbBuffer;

    /*
     * Allocate space from the message buffer
     */
    if (cbData > pcb->cbCapture) {
        return STATUS_BUFFER_OVERFLOW;
    }

    pbBuffer = pcb->pbFree;
    pcb->pbFree = pbBuffer + ((cbData + PADSIZE) & ~PADSIZE);

    /*
     * Fix up offsets to data.  If the data is going into a section
     * use the real pointer and don't compute offsets.
     */
    if (pcb->pvVirtualAddress)
        *ppDest = pbBuffer;
    else {
        *ppDest = (PBYTE)(pbBuffer - (PBYTE)pcb);
        ((LPDWORD)((PBYTE)pcb + pcb->offPointers))[pcb->cCapturedPointers++] =
                (DWORD)((PBYTE)ppDest - (PBYTE)pcb);
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* CaptureAnsiCallbackData
*
* Converts Unicode to ANSI data and captures the result
* into a callback structure.
*
* 03-13-95 JimA             Created.
\***************************************************************************/

NTSTATUS CaptureAnsiCallbackData(
    PCAPTUREBUF pcb,
    PVOID pData,
    DWORD cbData,
    PVOID *ppDest)
{
    PBYTE pbBuffer;
    ULONG nCharsInAnsiString;

    /*
     * If the data pointer is NULL, the out pointer will be
     * NULL
     */
    if (pData == NULL) {
        *ppDest = NULL;
        return STATUS_SUCCESS;
    }

    /*
     * Allocate space from the message buffer
     */
#ifdef FE_SB // CaptureAnsiCallbackData()
    /*
     * Reserve enough space for DBCS.
     */
    if ((cbData * sizeof(WORD)) > pcb->cbCapture) {
#else
    if (cbData > pcb->cbCapture) {
#endif // FE_SB
        return STATUS_BUFFER_OVERFLOW;
    }

    pbBuffer = pcb->pbFree;

    /*
     * Convert the unicode string to ANSI
     */
    try {
#ifdef FE_SB // CaptureAnsiCallbackData()
        /*
         * Enough space for keep DBCS string.
         */
        if (!NT_SUCCESS(RtlUnicodeToMultiByteN(
                        (PCH)pbBuffer,
                        IS_DBCS_ENABLED() ? cbData * DBCS_CHARSIZE : cbData,
                        &nCharsInAnsiString,
                        (PWCH)pData,
                        cbData * sizeof(WCHAR)
                        ))) {
#else
        if (!NT_SUCCESS(RtlUnicodeToMultiByteN(
                        (PCH)pbBuffer,
                        cbData,
                        &nCharsInAnsiString,
                        (PWCH)pData,
                        cbData * sizeof(WCHAR)
                        ))) {
#endif // FE_SB
            return STATUS_UNSUCCESSFUL;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_ACCESS_VIOLATION;
    }

    /*
     * Translation succeeded.
     */
#ifdef FE_SB // CaptureAnsiCallbackData()
    /*
     * nCharsInAnsiString is actual bytes wriiten in message area.
     */
    pcb->pbFree = pbBuffer + ((nCharsInAnsiString + PADSIZE) & ~PADSIZE);
    pcb->cbCapture -= nCharsInAnsiString;
#else
    pcb->pbFree = pbBuffer + ((cbData + PADSIZE) & ~PADSIZE);
    pcb->cbCapture -= cbData;
#endif // FE_SB

    /*
     * Fix up offsets to data.  If the data is going into a section
     * use the real pointer and don't compute offsets.
     */
    if (pcb->pvVirtualAddress)
        *ppDest = pbBuffer;
    else {
        *ppDest = (PBYTE)(pbBuffer - (PBYTE)pcb);
        ((LPDWORD)((PBYTE)pcb + pcb->offPointers))[pcb->cCapturedPointers++] =
                (DWORD)((PBYTE)ppDest - (PBYTE)pcb);
    }

    return STATUS_SUCCESS;
}


/***************************************************************************\
* CaptureUnicodeCallbackData
*
* Converts ANSI to Unicode data and captures the result
* into a callback structure.
*
* 03-31-95 JimA             Created.
\***************************************************************************/

NTSTATUS CaptureUnicodeCallbackData(
    PCAPTUREBUF pcb,
    PVOID pData,
    DWORD cbData,
    PVOID *ppDest)
{
    PBYTE pbBuffer;
    ULONG nCharsInUnicodeString;

    /*
     * If the data pointer is NULL, the out pointer will be
     * NULL
     */
    if (pData == NULL) {
        *ppDest = NULL;
        return STATUS_SUCCESS;
    }

    /*
     * Allocate space from the message buffer
     */
    if (cbData > pcb->cbCapture) {
        return STATUS_BUFFER_OVERFLOW;
    }

    pbBuffer = pcb->pbFree;

    /*
     * Convert the ANSI string to unicode
     */
    try {
        if (!NT_SUCCESS(RtlMultiByteToUnicodeN(
                            (PWCH)pbBuffer,
                            cbData,
                            &nCharsInUnicodeString,
                            (PCH)pData,
                            cbData / sizeof(WCHAR)
                            ))) {
            return STATUS_UNSUCCESSFUL;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_ACCESS_VIOLATION;
    }

    /*
     * Translation succeeded.
     */
    pcb->pbFree = pbBuffer + ((cbData + PADSIZE) & ~PADSIZE);
    pcb->cbCapture -= cbData;

    /*
     * Fix up offsets to data.  If the data is going into a section
     * use the real pointer and don't compute offsets.
     */
    if (pcb->pvVirtualAddress)
        *ppDest = pbBuffer;
    else {
        *ppDest = (PBYTE)(pbBuffer - (PBYTE)pcb);
        ((LPDWORD)((PBYTE)pcb + pcb->offPointers))[pcb->cCapturedPointers++] =
                (DWORD)((PBYTE)ppDest - (PBYTE)pcb);
    }

    return STATUS_SUCCESS;
}


/***************************************************************************\
* CopyOutputString
*
* Copies a callback output string to the output buffer and performs
* any necessary ANSI/Unicode translation.
*
* Copies up to cchLimit characters, possibly including a null terminator.
*
* A null terminator is placed in pstr->Buffer only if the number of (non-null)
* characters obtained is less than cchLimit.
* pstr->Length may be set larger than necessary: ie: it may sometimes indicate
* a string longer than that which is null terminated. This is a deficiency in
* the current implementation.
*
* 05-08-95 JimA             Created.
\***************************************************************************/

VOID CopyOutputString(
    PCALLBACKSTATUS pcbs,
    PLARGE_STRING pstr,
    UINT cchLimit,
    BOOL fAnsi)
{
    UINT cch;

    ProbeForRead(pcbs->pOutput, pcbs->cbOutput,
            fAnsi ? sizeof(BYTE) : sizeof(WORD));
    if (!pstr->bAnsi) {
        if (fAnsi) {
            cch = MBToWCS((LPSTR)pcbs->pOutput, (UINT)pcbs->retval,
                    (LPWSTR *)&pstr->Buffer, cchLimit, FALSE);
            if (cch < cchLimit) {
                /*
                 * Add a null terminator and ensure an accurate pstr->Length
                 */
                ((LPWSTR)pstr->Buffer)[cch] = 0;
                cchLimit = cch;
            }
        } else {
            cchLimit = wcsncpycch(pstr->Buffer, (LPWSTR)pcbs->pOutput, cchLimit);
            // wcsncpy(pstr->Buffer, (LPWSTR)pcbs->pOutput, cchLimit);
        }
        pstr->Length = cchLimit * sizeof(WCHAR);
    } else {
        if (fAnsi) {
            cchLimit = strncpycch((LPSTR)pstr->Buffer,
            // strncpy((LPSTR)pstr->Buffer,
                    (LPSTR)pcbs->pOutput, cchLimit);
        } else {
            cch = WCSToMB((LPWSTR)pcbs->pOutput, (UINT)pcbs->retval,
                    (LPSTR *)&pstr->Buffer, cchLimit, FALSE);
            if (cch < cchLimit) {
                /*
                 * Add a null terminator and ensure an accurate pstr->Length
                 */
                ((LPSTR)pstr->Buffer)[cch] = 0;
                cchLimit = cch;
            }
        }
        pstr->Length = cchLimit;
    }
}

#ifdef FE_SB // CalcOutputStringSize()
/***************************************************************************\
* CalcOutputStringSize()
*
* Copies a callback output string to the output buffer and performs
* any necessary ANSI/Unicode translation.
*
* 03-14-96 HideyukN             Created.
\***************************************************************************/

DWORD CalcOutputStringSize(
    PCALLBACKSTATUS pcbs,
    DWORD cchText,
    BOOL fAnsiSender,
    BOOL fAnsiReceiver)
{
    ULONG cch;

    ProbeForRead(pcbs->pOutput, pcbs->cbOutput,
            fAnsiReceiver ? sizeof(BYTE) : sizeof(WORD));
    if (!fAnsiSender) {
        if (fAnsiReceiver) {
            RtlMultiByteToUnicodeSize(&cch,(LPSTR)pcbs->pOutput,cchText);
            cch /= sizeof(WCHAR);
        } else {
            cch = cchText;
        }
    } else {
        if (fAnsiReceiver) {
            cch = cchText;
        } else {
            RtlUnicodeToMultiByteSize(&cch,(LPWSTR)pcbs->pOutput,cchText * sizeof(WCHAR));
        }
    }

    return ((DWORD)cch);
}
#endif // FE_SB

/**************************************************************************\
*
* include the stub definition file
*
\**************************************************************************/

#include "ntcb.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\srvhook.c ===
/****************************** Module Header ******************************\
* Module Name: srvhook.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Server side of hook calls and callbacks.
*
* 05-09-91 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

LRESULT fnHkINLPCBTCREATESTRUCT(UINT msg, WPARAM wParam, LPCBT_CREATEWND pcbt,
    PROC xpfnProc, BOOL bAnsi);

/***************************************************************************\
* xxxHkCallHook
*
* This is the server-side stub that calls to the client to call the actual
* hook function.
*
* History:
* 05-09-91 ScottLu      Rewrote to make all hooks work client/server!
* 01-28-91 DavidPe      Created.
\***************************************************************************/

LRESULT xxxHkCallHook(
    PHOOK phk,
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT nRet;
    PROC pfnHk, pfnHookProc;
    PPFNCLIENT ppfnClient;
    PCWPSTRUCTEX pcwp;
    PCWPRETSTRUCTEX pcwpret;
    PCLIENTINFO pci;
    ULONG_PTR dwHookData;
    ULONG_PTR dwFlags;
    struct tagSMS *psms;
#ifdef LATER
    /*
     * WindowsBug 246329
     * The code was supposed to prevent the backdoor
     * for the surprise foreground change.
     * However, the implementation below locks the
     * entire system, preventing the legit, expected
     * foreground change too. It's obvious on MP systems.
     * E.g. in the case global hooks such as
     * GETMESSAGEHOOK are installed, the chances are
     * pretty high.
     * For this time being, instead of making the lock
     * per process or per thread, we decided to simply
     * disable the foreground lock during the hook
     * callback.
     */
    TL tlSFWLock;
    BOOL fLockForeground;
#endif

    DbgValidateHooks(phk, phk->iHook);
    /*
     * Only low level hooks are allowed in the RIT context.
     * Also asssert that the hook is not destroyed
     */
#ifdef REDIRECTION
    UserAssert((PtiCurrent() != gptiRit)
               || (phk->iHook == WH_MOUSE_LL)
               || (phk->iHook == WH_KEYBOARD_LL)
               || (phk->iHook == WH_HITTEST));
#else
    UserAssert((PtiCurrent() != gptiRit)
               || (phk->iHook == WH_MOUSE_LL)
               || (phk->iHook == WH_KEYBOARD_LL));
#endif // REDIRECTION

    /*
     * While we're still inside the critical section make sure the
     * hook hasn't been 'freed'.  If so just return 0.
     */
    if (phk->offPfn != 0) {
        pfnHookProc = PFNHOOK(phk);
    } else {
        return 0;
    }

    ppfnClient = (phk->flags & HF_ANSI) ? &gpsi->apfnClientA :
            &gpsi->apfnClientW;

#ifdef LATER    // per 246329
    /*
     * LATER5.0 GerardoB. This might generate some hate reactions but I'm
     *  not sure we want people hooking just to steal the foreground.
     * Prevent hookprocs from other processes from switching the foreground
     */
    fLockForeground = (GETPTI(phk)->ppi != PpiCurrent());
    if (fLockForeground) {
        ThreadLockSFWLockCount(&tlSFWLock);
    }
#endif

    switch(phk->iHook) {
    case WH_CALLWNDPROC:
    case WH_CALLWNDPROCRET:
       if (phk->iHook == WH_CALLWNDPROC) {
          pcwp = (PCWPSTRUCTEX)lParam;
          psms = pcwp->psmsSender;
       } else {
          pcwpret = (PCWPRETSTRUCTEX)lParam;
          psms = pcwpret->psmsSender;
       }

        /*
         * If the sender has died or timed out, don't call the
         * hook because any memory the message points to may be invalid.
         */
        if (psms != NULL && (psms->flags & (SMF_SENDERDIED | SMF_REPLY))) {
            nRet = 0;
            break;
        }

        /*
         * This is the hardest of the hooks because we need to thunk through
         * the message hooks in order to deal with synchronously sent messages
         * that point to structures - to get the structures passed across
         * alright, etc.
         *
         * This will call a special client-side routine that'll rebundle the
         * arguments and call the hook in the right format.
         *
         * Currently, the message thunk callbacks to the client-side don't take
         * enough parameters to pass wParam (which == fInterThread send msg).
         * To do this, call one of two functions.
         */
        pci = GetClientInfo();
        if (phk->iHook == WH_CALLWNDPROC) {
            pfnHk = ppfnClient->pfnHkINLPCWPSTRUCT;
        } else {
            pfnHk = ppfnClient->pfnHkINLPCWPRETSTRUCT;
            try {
                pci->dwHookData = pcwpret->lResult;
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                nRet = 0;
                break;
            }
        }

        /*
         * Save current hook state.
         */
        try {
            dwFlags = pci->CI_flags & CI_INTERTHREAD_HOOK;
            dwHookData = pci->dwHookData;

            if (wParam) {
                pci->CI_flags |= CI_INTERTHREAD_HOOK;
            } else {
                pci->CI_flags &= ~CI_INTERTHREAD_HOOK;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            nRet = 0;
            break;
        }
        if (phk->iHook == WH_CALLWNDPROC) {
           nRet = ScSendMessageSMS(
               PW(pcwp->hwnd),
               pcwp->message,
               pcwp->wParam,
               pcwp->lParam,
               (ULONG_PTR)pfnHookProc, pfnHk,
               (phk->flags & HF_ANSI) ?
                       (SCMS_FLAGS_ANSI|SCMS_FLAGS_INONLY) :
                       SCMS_FLAGS_INONLY,
               psms);
        } else {
            nRet = ScSendMessageSMS(
                PW(pcwpret->hwnd),
                pcwpret->message,
                pcwpret->wParam,
                pcwpret->lParam,
                (ULONG_PTR)pfnHookProc, pfnHk,
                (phk->flags & HF_ANSI) ?
                        (SCMS_FLAGS_ANSI|SCMS_FLAGS_INONLY) :
                        SCMS_FLAGS_INONLY,
                psms);
        }
        /*
         * Restore previous hook state.
         */
        try {
            pci->CI_flags ^= ((pci->CI_flags ^ dwFlags) & CI_INTERTHREAD_HOOK);
            pci->dwHookData = dwHookData;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            nRet = 0;
        }
        break;
    case WH_CBT:
        /*
         * There are many different types of CBT hooks!
         */
        switch(nCode) {
        case HCBT_CLICKSKIPPED:
            goto MouseHook;
            break;

        case HCBT_CREATEWND:
            /*
             * This hook type points to a CREATESTRUCT, so we need to
             * be fancy with it's thunking, because a CREATESTRUCT contains
             * a pointer to CREATEPARAMS which can be anything...  so
             * funnel this through our message thunks.
             */
            nRet = fnHkINLPCBTCREATESTRUCT(
                    MAKELONG((WORD)nCode, (WORD)phk->iHook),
                    wParam,
                    (LPCBT_CREATEWND)lParam,
                    pfnHookProc,
                    (phk->flags & HF_ANSI) ? TRUE : FALSE);
            break;

#ifdef REDIRECTION
        case HCBT_GETCURSORPOS:

            /*
             * This hook type points to a POINT structure, so it's pretty
             * simple.
             */
            nRet = fnHkINLPPOINT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                    wParam, (LPPOINT)lParam, (ULONG_PTR)pfnHookProc,
                    ppfnClient->pfnDispatchHook);
            break;
#endif // REDIRECTION

        case HCBT_MOVESIZE:

            /*
             * This hook type points to a RECT structure, so it's pretty
             * simple.
             */
            nRet = fnHkINLPRECT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                    wParam, (LPRECT)lParam, (ULONG_PTR)pfnHookProc,
                    ppfnClient->pfnDispatchHook);
            break;

        case HCBT_ACTIVATE:
            /*
             * This hook type points to a CBTACTIVATESTRUCT
             */
            nRet = fnHkINLPCBTACTIVATESTRUCT(MAKELONG((UINT)nCode,
                    (UINT)phk->iHook), wParam, (LPCBTACTIVATESTRUCT)lParam,
                    (ULONG_PTR)pfnHookProc, ppfnClient->pfnDispatchHook);
            break;

        default:

            /*
             * The rest of the cbt hooks are all dword parameters.
             */
            nRet = fnHkINDWORD(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                    wParam, lParam, (ULONG_PTR)pfnHookProc,
                    ppfnClient->pfnDispatchHook, &phk->flags);
            break;
        }
        break;

    case WH_FOREGROUNDIDLE:
        /*
         * These are dword parameters and are therefore real easy.
         *
         */
        nRet = fnHkINDWORD(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, lParam, (ULONG_PTR)pfnHookProc,
                ppfnClient->pfnDispatchHook, &phk->flags);
        break;

    case WH_SHELL:

        if (nCode == HSHELL_GETMINRECT) {
            /*
             * This hook type points to a RECT structure, so it's pretty
             * simple.
             */
            nRet = fnHkINLPRECT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                    wParam, (LPRECT)lParam, (ULONG_PTR)pfnHookProc,
                    ppfnClient->pfnDispatchHook);
            break;
        }

        /*
         * Otherwise fall through to the simple case of DWORD below
         */

    case WH_KEYBOARD:
        /*
         * These are dword parameters and are therefore real easy.
         */
        nRet = fnHkINDWORD(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, lParam, (ULONG_PTR)pfnHookProc,
                ppfnClient->pfnDispatchHook, &phk->flags);
        break;

    case WH_MSGFILTER:
    case WH_SYSMSGFILTER:
    case WH_GETMESSAGE:
        /*
         * These take an lpMsg as their last parameter.  Since these are
         * exclusively posted parameters, and since nowhere on the server
         * do we post a message with a pointer to some other structure in
         * it, the lpMsg structure contents can all be treated verbatim.
         */
        nRet = fnHkINLPMSG(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPMSG)lParam, (ULONG_PTR)pfnHookProc,
                ppfnClient->pfnDispatchHook,
                (phk->flags & HF_ANSI) ? TRUE : FALSE, &phk->flags);
        break;

    case WH_JOURNALPLAYBACK:

#ifdef HOOKBATCH
        /*
         * If this hook has cached playback info then we need to grab
         * the info out of the cache.
         */

        if (phk->cEventMessages) {
            if (nCode == HC_GETNEXT) {
                LPEVENTMSG pEventMsg;
                pEventMsg = (LPEVENTMSG)lParam;

                if (phk->flags & HF_NEEDHC_SKIP)
                    phk->iCurrentEvent++;

                if (phk->iCurrentEvent < phk->cEventMessages) {
                    *pEventMsg = phk->aEventCache[phk->iCurrentEvent];
                } else {

                    /*
                     * Free the cache set if it is still around
                     */
                    if (phk->aEventCache) {
                        UserFreePool(phk->aEventCache);
                        phk->aEventCache = NULL;
                    }
                    phk->cEventMessages = 0;
                    phk->iCurrentEvent = 0;

                    goto MakeClientJournalPlaybackCall;
                }

                /*
                 * Return the time and zero the batched time so if we sleep
                 * this time we won't sleep again next time
                 */
                nRet = pEventMsg->time;
                if (nRet)
                    phk->aEventCache[phk->iCurrentEvent].time = 0;
            } else if (nCode == HC_SKIP) {
                phk->iCurrentEvent++;
                nRet = 0;
            }

        } else {
#endif // HOOKBATCH
            /*
             * In order to avoid a client/server transition for HC_SKIP we
             * piggy-back it on top of the next journal playback event and
             * send it from there.
             */
// MakeClientJournalPlaybackCall:
            nRet = fnHkOPTINLPEVENTMSG(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                    (WPARAM)PtoHq(phk), (LPEVENTMSG)lParam, (ULONG_PTR)pfnHookProc,
                    ppfnClient->pfnDispatchHook);
#ifdef HOOKBATCH
        }

        /*
         * Determine if we received a cached set of events if so then store
         * them away off of the hook.
         * paramL will be the number of events.
         * paramH will be the array of events.
         */
        if ((nCode == HC_GETNEXT) && (((LPEVENTMSG)lParam)->message == 0x12341234)) {
            NTSTATUS Status;
            LPEVENTMSG pEventMsg = (LPEVENTMSG)lParam;

            /*
             * We should not be getting another cached set if we aren't
             * done with the first set
             */
            UserAssert((phk->cEventMessages == 0) ||
                    (phk->cEventMessages >= phk->iCurrentEvent));
            UserAssert((pEventMsg->paramL < 500) && (pEventMsg->paramL > 1));

            /*
             * Free the last cache set if it is still around
             */
            if (phk->aEventCache) {
                UserFreePool(phk->aEventCache);
                phk->aEventCache = NULL;
            }

            if (phk->aEventCache = LocalAlloc(LPTR,
                    pEventMsg->paramL*sizeof(EVENTMSG))) {
                PETHREAD Thread = PsGetCurrentThread();

                Status = ZwReadVirtualMemory(Thread->Process->ProcessHandle,
                        (PVOID)pEventMsg->paramH, phk->aEventCache,
                        pEventMsg->paramL*sizeof(EVENTMSG), NULL);

                if (NT_SUCCESS(Status)) {
                    phk->cEventMessages = pEventMsg->paramL;
                    phk->iCurrentEvent = 0;

                    /*
                     * Fill in the real EventMsg for this message
                     */
                    *pEventMsg = phk->aEventCache[0];
                    phk->aEventCache[0].time = 0;
                }

            } else {
                phk->cEventMessages = 0;
                phk->iCurrentEvent = 0;
            }
        }
#endif // HOOKBATCH

        phk->flags &= ~HF_NEEDHC_SKIP;
        break;

    case WH_JOURNALRECORD:

        nRet = fnHkOPTINLPEVENTMSG(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPEVENTMSG)lParam, (ULONG_PTR)pfnHookProc,
                ppfnClient->pfnDispatchHook);
        break;

    case WH_DEBUG:
        /*
         * This takes an lpDebugHookStruct.
         */
        nRet = fnHkINLPDEBUGHOOKSTRUCT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPDEBUGHOOKINFO)lParam, (ULONG_PTR)pfnHookProc,
                ppfnClient->pfnDispatchHook);
        break;

    case WH_KEYBOARD_LL:
        /*
         * This takes an lpKbdHookStruct.
         */
        nRet = fnHkINLPKBDLLHOOKSTRUCT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPKBDLLHOOKSTRUCT)lParam,
                (ULONG_PTR)pfnHookProc, ppfnClient->pfnDispatchHook);
        break;

    case WH_MOUSE_LL:
        /*
         * This takes an lpMsllHookStruct.
         */
        nRet = fnHkINLPMSLLHOOKSTRUCT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPMSLLHOOKSTRUCT)lParam,
                (ULONG_PTR)pfnHookProc, ppfnClient->pfnDispatchHook);
        break;

    case WH_MOUSE:
        /*
         * This takes an lpMouseHookStructEx.
         */
MouseHook:
        nRet = fnHkINLPMOUSEHOOKSTRUCTEX(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPMOUSEHOOKSTRUCTEX)lParam,
                (ULONG_PTR)pfnHookProc, ppfnClient->pfnDispatchHook, &phk->flags);
        break;

#ifdef REDIRECTION
    case WH_HITTEST:
        /*
         * This takes an lpHTHookStruct.
         */
        nRet = fnHkINLPHTHOOKSTRUCT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPHTHOOKSTRUCT)lParam,
                (ULONG_PTR)pfnHookProc, ppfnClient->pfnDispatchHook);
        break;
#endif // REDIRECTION

    }

#ifdef LATER    // per 246329
    if (fLockForeground) {
        ThreadUnlockSFWLockCount(&tlSFWLock);
    }
#endif

    return nRet;
}

/***************************************************************************\
* fnHkINLPCWPEXSTRUCT
*
* This gets thunked through the message thunks, so it has the format
* of a c/s message thunk call.
*
* 05-09-91 ScottLu      Created.
\***************************************************************************/

LRESULT fnHkINLPCWPEXSTRUCT(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    CWPSTRUCTEX cwp;
    PCLIENTINFO pci = GetClientInfo();
    BOOL        bInterThread;

    UNREFERENCED_PARAMETER(xParam);

    cwp.hwnd = HW(pwnd);
    cwp.message = message;
    cwp.wParam = wParam;
    cwp.lParam = lParam;
    cwp.psmsSender = NULL;
    try {
        bInterThread = (pci->CI_flags & CI_INTERTHREAD_HOOK) != 0;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return 0;
    }

    return xxxCallNextHookEx(HC_ACTION, bInterThread, (LPARAM)&cwp);
}

LRESULT fnHkINLPCWPRETEXSTRUCT(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    CWPRETSTRUCTEX cwp;
    PCLIENTINFO pci = GetClientInfo();
    BOOL        bInterThread;

    UNREFERENCED_PARAMETER(xParam);

    cwp.hwnd = HW(pwnd);
    cwp.message = message;
    cwp.wParam = wParam;
    cwp.lParam = lParam;
    cwp.psmsSender = NULL;
    try {
        cwp.lResult = pci->dwHookData;
        bInterThread = (pci->CI_flags & CI_INTERTHREAD_HOOK) != 0;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return 0;
    }
    
    return xxxCallNextHookEx(HC_ACTION, bInterThread, (LPARAM)&cwp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\taskman.c ===
/****************************** Module Header ******************************\
* Module Name: taskman.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the core functions of the input sub-system
*
* History:
* 02-27-91 MikeHar      Created.
* 02-23-92 MattFe       rewrote sleeptask
* 09-07-93 DaveHart     Per-process nonpreemptive scheduler for
*                       multiple WOW VDM support.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* WakeWowTask
*
* If needed the wowtask is woken by setting its event. It is assumed that if
* any wow task is currently scheduled that it is a waste of time to wake the
* specified wow task since rescheduling will occur when the currently
* scheduled wow task enters xxxSleepTask.
*
* History:
* ????
\***************************************************************************/
VOID
WakeWowTask(
   PTHREADINFO pti)
{
   PWOWPROCESSINFO pwpi;

   pwpi = pti->ppi->pwpi;
   if (pwpi && !pwpi->ptiScheduled) {
       KeSetEvent(pti->pEventQueueServer, EVENT_INCREMENT, FALSE);
       }
}


/***************************************************************************\
* InsertTask
*
* This function removes a task from its old location and inserts
* in the proper prioritized location
*
* Find a place for this task such that it must be inserted
* after any task with greater or equal priority and must be
* before any task with higher priorty.  The higher the priority
* the less urgent the task.
*
* History:
* 19-Nov-1993 mikeke    Created
\***************************************************************************/
VOID InsertTask(
    PPROCESSINFO ppi,
    PTDB ptdbNew)
{
    PTDB *pptdb;
    PTDB ptdb;
    int nPriority;
    PWOWPROCESSINFO pwpi = ppi->pwpi;

    CheckCritIn();

    UserAssert(pwpi != NULL);

    pptdb = &pwpi->ptdbHead;
    nPriority = ptdbNew->nPriority;

    while ((ptdb = *pptdb) != NULL) {
        /*
         * Remove it from it's old location
         */
        if (ptdb == ptdbNew) {
            *pptdb = ptdbNew->ptdbNext;

            /*
             * continue to search for the place to insert it
             */
            while ((ptdb = *pptdb) != NULL) {
                if (nPriority < ptdb->nPriority) {
                    break;
                }

                pptdb = &(ptdb->ptdbNext);
            }
            break;
        }

        /*
         * if this is the place to insert continue to search for the
         * place to delete it from
         */
        if (nPriority < ptdb->nPriority) {
            do {
                if (ptdb->ptdbNext == ptdbNew) {
                    ptdb->ptdbNext = ptdbNew->ptdbNext;
                    break;
                }
                ptdb = ptdb->ptdbNext;
            } while (ptdb != NULL);
            break;
        }

        pptdb = &(ptdb->ptdbNext);
    }

    /*
     * insert the new task
     */
    ptdbNew->ptdbNext = *pptdb;
    *pptdb = ptdbNew;
}


/***************************************************************************\
* DestroyTask()
*
* History:
* 02-27-91 MikeHar      Created.
\***************************************************************************/
VOID DestroyTask(
    PPROCESSINFO ppi,
    PTHREADINFO ptiToRemove)
{
    PTDB ptdbToRemove = ptiToRemove->ptdb;
    PTDB ptdb;
    PTDB* pptdb;
    PWOWPROCESSINFO pwpi = ppi->pwpi;

    // try to catch #150446
    CheckCritIn();
    BEGINATOMICCHECK();

    UserAssert(pwpi != NULL);

    if (ptdbToRemove != NULL) {
        if (ptdbToRemove->TDB_Flags & TDBF_SETUP) {
            /*
             * This means that the WoW app was a setup app (checked in
             * SetAppCompatFlags). If so, the shell needs to be notified so
             * it can clean up potential problems caused by bad calls to
             * DDE, etc.
             */
            PDESKTOPINFO pdeskinfo = GETDESKINFO(ptiToRemove);
            if (pdeskinfo->spwndShell) {
                _PostMessage(pdeskinfo->spwndShell, DTM_SETUPAPPRAN, 0, 0);
            }
        }

        /*
         * Remove the WOW per thread info.
         */
        if (ptdbToRemove->pwti) {
            PWOWTHREADINFO *ppwti = &gpwtiFirst;
            while (*ppwti != ptdbToRemove->pwti && (*ppwti)->pwtiNext != NULL) {
                ppwti = &((*ppwti)->pwtiNext);
            }
            if (*ppwti == ptdbToRemove->pwti) {
                 *ppwti = ptdbToRemove->pwti->pwtiNext;
            }
            CLOSE_PSEUDO_EVENT(&ptdbToRemove->pwti->pIdleEvent);
            UserFreePool(ptdbToRemove->pwti);
        }

        gpsi->nEvents -= ptdbToRemove->nEvents;

        /*
         * remove it from any lists
         */
        pptdb = &pwpi->ptdbHead;
        while ((ptdb = *pptdb) != NULL) {
            /*
             * Remove it from it's old location
             */
            if (ptdb == ptdbToRemove) {
                *pptdb = ptdb->ptdbNext;
                UserAssert(ptiToRemove->ptdb == ptdbToRemove);
                UserFreePool(ptdbToRemove);
                ptiToRemove->ptdb = NULL;
                break;
            }
            pptdb = &(ptdb->ptdbNext);
        }
        UserAssert(ptdb == ptdbToRemove);
    }
    ENDATOMICCHECK();

    /*
     * If the task being destroyed is the active task, make nobody active.
     * We will go through this code path for 32-bit threads that die while
     * Win16 threads are waiting for a SendMessage reply from them.
     */
    if (pwpi->ptiScheduled == ptiToRemove) {
        pwpi->ptiScheduled = NULL;
        ExitWowCritSect(ptiToRemove, pwpi);

        /*
         * Wake next task with events, or wowexec to run the scheduler
         */
        if (pwpi->ptdbHead != NULL) {
            for (ptdb = pwpi->ptdbHead; ptdb; ptdb = ptdb->ptdbNext) {
                if (ptdb->nEvents > 0) {
                    KeSetEvent(ptdb->pti->pEventQueueServer,
                               EVENT_INCREMENT, FALSE);
                    break;
                }
            }

            if (!ptdb) {
                KeSetEvent(pwpi->pEventWowExec, EVENT_INCREMENT, FALSE);
            }
        }
    }

    UserAssert(ptiToRemove != pwpi->CSOwningThread);
}




/***************************************************************************\
* xxxSleepTask
*
* This function puts this task to sleep and wakes the next (if any)
* deserving task.
*
* BOOL   fInputIdle  - app is going idle, may do idle hooks
* HANDLE hEvent      - if nonzero, WowExec's event (client side) for
*                      virtual HW Interrupt HotPath.
* History:
* 02-27-91 MikeHar      Created.
* 02-23-91 MattFe       rewrote
* 12-17-93 Jonle        add wowexec hotpath for VirtualInterrupts
\***************************************************************************/

BOOL xxxSleepTask(
    BOOL   fInputIdle,
    HANDLE hEvent)
{
    PTDB ptdb;
    PTHREADINFO     pti;
    PPROCESSINFO    ppi;
    PWOWPROCESSINFO pwpi;
    PSMS            psms;
    NTSTATUS Status;
    int    nHandles;
    BOOLEAN bWaitedAtLeastOnce;

    /*
     * !!!
     * ClearSendMessages assumes that this function does NOT leave the
     * critical section when called with fInputIdle==FALSE and from a
     * 32bit thread!
     */

    CheckCritIn();

    pti  = PtiCurrent();
    ppi  = pti->ppi;
    pwpi = ppi->pwpi;

    /*
     *  If this task has received a message from outside of the current
     *  wow scheduler and hasn't yet replied to the message, the scheduler
     *  will deadlock because the send\receive lock counts are updated
     *  in ReplyMessage and not in receive message. Check for this
     *  condition and do the DirectedSchedukeTask that normally occurs
     *  in ReplyMessage. 16-Feb-1995 Jonle
     */
    psms = pti->psmsCurrent;
    if (psms && psms->ptiReceiver == pti &&
            psms->ptiSender && !(psms->flags & SMF_REPLY) &&
            psms->flags & (SMF_RECEIVERBUSY | SMF_RECEIVEDMESSAGE) &&
            psms->ptiSender->TIF_flags & TIF_16BIT &&
            (pwpi != psms->ptiSender->ppi->pwpi || !(pti->TIF_flags & TIF_16BIT)) ) {
        DirectedScheduleTask(psms->ptiReceiver, psms->ptiSender, FALSE, psms);
    }


    /*
     * Return immediately if we are not 16 bit (don't have a pwpi).
     */
    if (!(pti->TIF_flags & TIF_16BIT)) {
        return FALSE;
    }


    /*
     * Deschedule the current task.
     */
    if (pti == pwpi->ptiScheduled) {
        ExitWowCritSect(pti, pwpi);
        pwpi->ptiScheduled = NULL;
    }
    UserAssert(pti != pwpi->CSOwningThread);


    /*
     *  If this is wowexec calling on WowWaitForMsgAndEvent
     *  set up the WakeMask for all messages , and check for wake
     *  bits set since the last time. Reinsert wowexec, at the end
     *  of the list so other 16 bit tasks will be scheduled first.
     */
    if (pwpi->hEventWowExecClient == hEvent) {
        InsertTask(ppi, pti->ptdb);
        pti->pcti->fsWakeMask = QS_ALLINPUT | QS_EVENT;
        if (pti->pcti->fsChangeBits & pti->pcti->fsWakeMask) {
            pti->ptdb->nEvents++;
            gpsi->nEvents++;
        }
    }


    bWaitedAtLeastOnce = FALSE;

    do {

        /*
         * If nobody is Active look for the highest priority task with
         * some events pending. if MsgWaitForMultiple call don't
         * reschedule self
         */

        if (pwpi->ptiScheduled == NULL) {
rescan:
            if (pwpi->nRecvLock >= pwpi->nSendLock) {
                for (ptdb = pwpi->ptdbHead; ptdb; ptdb = ptdb->ptdbNext) {
                    if (ptdb->nEvents > 0 &&
                            !(hEvent == HEVENT_REMOVEME && ptdb->pti == pti)) {
                        pwpi->ptiScheduled = ptdb->pti;
                        break;
                    }
                }

                if (bWaitedAtLeastOnce) {
                    //
                    // If not first entry into sleep task avoid waiting
                    // more than needed, if the curr task is now scheduled.
                    //
                    if (pwpi->ptiScheduled == pti) {
                        break;
                    }

                } else {
                    //
                    // On the first entry into sleep task input is going
                    // idle if no tasks are ready to run. Call the idle
                    // hook if there is one.
                    //
                    if (fInputIdle &&
                            pwpi->ptiScheduled == NULL &&
                            IsHooked(pti, WHF_FOREGROUNDIDLE)) {

                        /*
                         * Make this the active task so that no other
                         * task will become active while we're calling
                         * the hook.
                         */
                        pwpi->ptiScheduled = pti;
                        xxxCallHook(HC_ACTION, 0, 0, WH_FOREGROUNDIDLE);

                        /*
                         * Reset state so that no tasks are active.  We
                         * then need to rescan the task list to see if
                         * a task was scheduled during the call to the
                         * hook.  Clear the input idle flag to ensure
                         * that the hook won't be called again if there
                         * are no tasks ready to run.
                         */
                        pwpi->ptiScheduled = NULL;
                        fInputIdle = FALSE;
                        goto rescan;
                    }
                }
            }


            /*
             * If there is a task ready, wake it up.
             */
            if (pwpi->ptiScheduled != NULL) {
                KeSetEvent(pwpi->ptiScheduled->pEventQueueServer,
                           EVENT_INCREMENT,
                           FALSE
                           );

            /*
             *  There is no one to wake up, but we may have to wake
             *  wowexec to service virtual hardware interrupts
             */
            } else if (ppi->W32PF_Flags & W32PF_WAKEWOWEXEC) {
                if (pwpi->hEventWowExecClient == hEvent) {
                    pwpi->ptiScheduled = pti;
                    ppi->W32PF_Flags &= ~W32PF_WAKEWOWEXEC;
                    InsertTask(ppi, pti->ptdb);
                    EnterWowCritSect(pti, pwpi);
                    UserAssert(pti == pwpi->ptiScheduled);
                    return TRUE;
                } else {
                    KeSetEvent(pwpi->pEventWowExec, EVENT_INCREMENT, FALSE);
                }
            } else if ((pti->TIF_flags & TIF_SHAREDWOW) && !bWaitedAtLeastOnce) {
                if (pwpi->hEventWowExecClient == hEvent) {
                    /*
                     * We have to call zzzWakeInputIdle only if this will
                     * awake WowExec's thread and not other thread. Bug 44060.
                     */
                    zzzWakeInputIdle(pti); // need to DeferWinEventNotify() ?? IANJA ??
                }
            }
        }

        /*
         * Return if we are a 32 bit thread, or if we were called by
         * MsgWaitForMultiple to exit the wow scheduler.
         */
        if (!(pti->TIF_flags & TIF_16BIT)) {
            return FALSE;
        } else if (hEvent == HEVENT_REMOVEME) {
            InsertTask(ppi, pti->ptdb);
            KeClearEvent(pti->pEventQueueServer);
            return FALSE;
        }

        if (pti->apEvent == NULL) {
            pti->apEvent = UserAllocPoolNonPaged(POLL_EVENT_CNT * sizeof(PKEVENT), TAG_EVENT);
            if (pti->apEvent == NULL)
                return FALSE;
        }

        /*
         * Wait for input to this thread.
         */
        pti->apEvent[IEV_TASK] = pti->pEventQueueServer;

        /*
         * Add the WowExec, handle for virtual hw interrupts
         */
        if (pwpi->hEventWowExecClient == hEvent) {
            pti->apEvent[IEV_WOWEXEC] = pwpi->pEventWowExec;
            nHandles = 2;
        } else {
            nHandles = 1;
        }

        if (pti->TIF_flags & TIF_MEOW) {
            xxxClientWOWTask16SchedNotify(WOWSCHNOTIFY_WAIT, 0);
        }

        LeaveCrit();
        Status = KeWaitForMultipleObjects(nHandles,
                                          &pti->apEvent[IEV_TASK],
                                          WaitAny,
                                          WrUserRequest,
                                          UserMode,
                                          TRUE,
                                          NULL,
                                          NULL);

        EnterCrit();

        if (pti->TIF_flags & TIF_MEOW) {
            xxxClientWOWTask16SchedNotify(WOWSCHNOTIFY_RUN, 0);
        }


        bWaitedAtLeastOnce = TRUE;

        // remember if we woke up for wowexec
        if (Status == STATUS_WAIT_1) {
            ppi->W32PF_Flags |= W32PF_WAKEWOWEXEC;
        } else if (Status == STATUS_USER_APC) {
            /*
             * ClientDeliverUserApc() delivers User-mode APCs by calling back
             * to the client and immediately returning without doing anything:
             * KeUserModeCallback will automatically deliver any pending APCs.
             */
            ClientDeliverUserApc();
        }

    } while (pwpi->ptiScheduled != pti);


    /*
     * We are the Active Task, reduce number of Events
     * Place ourselves at the far end of tasks in the same priority
     * so that next time we sleep someone else will run.
     */
    pti->ptdb->nEvents--;
    gpsi->nEvents--;
    UserAssert(gpsi->nEvents >= 0);

    InsertTask(ppi, pti->ptdb);

    ppi->W32PF_Flags &= ~W32PF_WAKEWOWEXEC;

    EnterWowCritSect(pti, pwpi);
    UserAssert(pti == pwpi->ptiScheduled);



    return FALSE;
}



/***************************************************************************\
* xxxUserYield
*
* Does exactly what Win3.1 UserYield does.
*
* History:
* 10-19-92 Scottlu      Created.
\***************************************************************************/

BOOL xxxUserYield(
    PTHREADINFO pti)
{
    PPROCESSINFO ppi = pti->ppi;

    /*
     * Deal with any pending messages. Only call it this first time if
     * this is the current running 16 bit app. In the case when starting
     * up a 16 bit app, the starter calls UserYield() to yield to the new
     * task, but at this time ppi->ptiScheduled is set to the new task.
     * Receiving messages at this point would be bad!
     */
    if (pti->TIF_flags & TIF_16BIT) {
        if (pti == ppi->pwpi->ptiScheduled) {
            xxxReceiveMessages(pti);
        }
    } else {
        xxxReceiveMessages(pti);
    }

    /*
     * If we are a 16 bit task
     * Mark our task so it comes back some time.  Also, remove it and
     * re-add it to the list so that we are the last task of our priority
     * to run.
     */
    if ((pti->TIF_flags & TIF_16BIT) && (pti->ptdb != NULL)) {
       if (pti->ptdb->nEvents == 0) {
            pti->ptdb->nEvents++;
            gpsi->nEvents++;
        }
        InsertTask(ppi, pti->ptdb);

        /*
         * Sleep.  Return right away if there are no higher priority tasks
         * in need of running.
         */
        xxxSleepTask(TRUE, NULL);

        /*
         * Deal with any that arrived since we weren't executing.
         */
        xxxReceiveMessages(pti);
    }


    return TRUE;
}


/***************************************************************************\
* DirectedScheduleTask
*
* History:
* 25-Jun-1992 mikeke    Created.
\***************************************************************************/
VOID DirectedScheduleTask(
     PTHREADINFO ptiOld,
     PTHREADINFO ptiNew,
     BOOL bSendMsg,
     PSMS psms)
{
    PWOWPROCESSINFO pwpiOld;
    PWOWPROCESSINFO pwpiNew;

    CheckCritIn();

    pwpiOld  = ptiOld->ppi->pwpi;
    pwpiNew  = ptiNew->ppi->pwpi;


    /*
     * If old task is 16 bit, reinsert the task in its wow scheduler list
     * so that it is lowest in priority. Note that ptiOld is always the
     * same as pwpiOld->ptiScheduled except when called from ReceiverDied.
     */
    if (ptiOld->TIF_flags & TIF_16BIT) {

        if (pwpiOld->ptiScheduled == ptiOld) {
            ptiOld->ptdb->nEvents++;
            gpsi->nEvents++;
            InsertTask(ptiOld->ppi, ptiOld->ptdb);
            }


        // Update the Send\Recv counts for interprocess scheduling in SleepTask

        if (pwpiOld != pwpiNew || !(ptiNew->TIF_flags & TIF_16BIT)) {
            if (bSendMsg) {
                pwpiOld->nSendLock++;
                psms->flags |= SMF_WOWSEND;
                }
            else if (pwpiOld->nRecvLock && psms->flags & SMF_WOWRECEIVE) {
                pwpiOld->nRecvLock--;
                psms->flags &= ~SMF_WOWRECEIVE;
                }
            }

        }


    /*
     *  If the new task is 16 bit, reinsert into the wow scheduler list
     *  so that it will run, if its a sendmsg raise priority of the receiver.
     *  If its a reply and the sender is waiting for this psms or the sender
     *  has a message to reply to raise priority of the sender.
     */
    if (ptiNew->TIF_flags & TIF_16BIT) {
        BOOL bRaisePriority;

        ptiNew->ptdb->nEvents++;
        gpsi->nEvents++;
        bRaisePriority = bSendMsg || psms == ptiNew->psmsSent;

        if (bRaisePriority) {
            ptiNew->ptdb->nPriority--;
            }

        InsertTask(ptiNew->ppi, ptiNew->ptdb);

        if (bRaisePriority) {
            ptiNew->ptdb->nPriority++;
            WakeWowTask(ptiNew);
            }


        // Update the Send\Recv counts for interprocess scheduling in SleepTask

        if (pwpiOld != pwpiNew || !(ptiOld->TIF_flags & TIF_16BIT)) {
            if (bSendMsg) {
                pwpiNew->nRecvLock++;
                psms->flags |= SMF_WOWRECEIVE;
                }
            else if (pwpiNew->nSendLock && psms->flags & SMF_WOWSEND) {
                pwpiNew->nSendLock--;
                psms->flags &= ~SMF_WOWSEND;
                }
            }

        }
}




/***************************************************************************\
* xxxDirectedYield
*
* History:
* 09-17-92 JimA         Created.
\***************************************************************************/
VOID xxxDirectedYield(
    DWORD dwThreadId)
{
    PTHREADINFO ptiOld;
    PTHREADINFO ptiNew;

    CheckCritIn();

    ptiOld = PtiCurrent();
    if (!(ptiOld->TIF_flags & TIF_16BIT) || !ptiOld->ppi->pwpi) {
         RIPMSG0(RIP_ERROR, "DirectedYield called from 32 bit thread!");
         return;
         }

    /*
     *  If the old task is 16 bit, reinsert the task in its wow
     *  scheduler list so that it is lowest in priority.
     */
    ptiOld->ptdb->nEvents++;
    gpsi->nEvents++;
    InsertTask(ptiOld->ppi, ptiOld->ptdb);

    /*
     * -1 supports Win 3.1 OldYield mechanics
     */
    if (dwThreadId != DY_OLDYIELD) {

        ptiNew = PtiFromThreadId(dwThreadId);
        if ((ptiNew == NULL) || (ptiNew->ppi != ptiOld->ppi)) {
             RIPMSG0(RIP_ERROR, "DirectedYield called from different process or invalid thread id!");
             return;
        }

        if (ptiNew->TIF_flags & TIF_16BIT) {
            ptiNew->ptdb->nEvents++;
            gpsi->nEvents++;
            ptiNew->ptdb->nPriority--;
            InsertTask(ptiNew->ppi, ptiNew->ptdb);
            ptiNew->ptdb->nPriority++;
        }
    }

    xxxSleepTask(TRUE, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\syscmd.c ===
/**************************** Module Header ********************************\
* Module Name: syscmd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* System Command Routines
*
* History:
* 01-25-91 IanJa   Added handle revalidation
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* xxxHandleNCMouseGuys
*
* History:
* 11-09-90 DavidPe      Ported.
\***************************************************************************/

void xxxHandleNCMouseGuys(
    PWND pwnd,
    UINT message,
    int htArea,
    LPARAM lParam)
{
    UINT syscmd;
    PWND pwndT;
    TL tlpwndT;

    CheckLock(pwnd);

    syscmd = 0xFFFF;

    switch (htArea) {

    case HTCAPTION:
        switch (message) {

        case WM_NCLBUTTONDBLCLK:
            if (TestWF(pwnd, WFMINIMIZED) || TestWF(pwnd, WFMAXIMIZED)) {
                syscmd = SC_RESTORE;
            } else if (TestWF(pwnd, WFMAXBOX)) {
                syscmd = SC_MAXIMIZE;
            }
            break;

        case WM_NCLBUTTONDOWN:
            pwndT = GetTopLevelWindow(pwnd);
            ThreadLock(pwndT, &tlpwndT);
            xxxActivateWindow(pwndT, AW_USE2);
            ThreadUnlock(&tlpwndT);
            syscmd = SC_MOVE;
            break;
        }
        break;

    case HTSYSMENU:
    case HTMENU:
    case HTHSCROLL:
    case HTVSCROLL:
        if (message == WM_NCLBUTTONDOWN || message == WM_NCLBUTTONDBLCLK) {
            switch (htArea) {
            case HTSYSMENU:
                if (message == WM_NCLBUTTONDBLCLK) {
                    syscmd = SC_CLOSE;
                    break;
                }

            /*
             *** FALL THRU **
             */

            case HTMENU:
                syscmd = SC_MOUSEMENU;
                break;

            case HTHSCROLL:
                syscmd = SC_HSCROLL;
                break;

            case HTVSCROLL:
                syscmd = SC_VSCROLL;
                break;
            }
        }
        break;
    }

    switch (syscmd) {

    case SC_MINIMIZE:
    case SC_MAXIMIZE:
    case SC_CLOSE:

        /*
         * Only do double click commands on an upclick.
         * This code is very sensitive to changes from this state.
         * Eat any mouse messages.
         */

        /*
         * Bug #152: WM_NCLBUTTONUP message missing from double click.
         * This code was broken in Windows 3.x and the test for whether
         * the mouse button was down always failed, so no mouse messages
         * were ever eaten. We'll emulate this by not even doing the test.
         *
         *
         * {
         *     PQ pqCurrent;
         *     MSG msg;
         *
         *     pqCurrent = PtiCurrent()->pq;
         *     if (TestKeyStateDown(pqCurrent, VK_LBUTTON)) {
         *         xxxCapture(PtiCurrent(), pwnd, WINDOW_CAPTURE);
         *
         *         while (TestKeyStateDown(pqCurrent, VK_LBUTTON)) {
         *             if (!xxxPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
         *                     PM_REMOVE)) {
         *                 if (!xxxSleepThread(QS_MOUSE, 0, TRUE))
         *                     break;
         *             }
         *         }
         *
         *         xxxReleaseCapture();
         *
         *     }
         * }
         *
         */

        /*
         ** FALL THRU **
         */
    case SC_SIZE:
    case SC_MOVE:
        /*
         * For SysCommands on system menu, don't do if menu item is
         * disabled.
         */
        if (TestWF(pwnd, WFSYSMENU)) {
            xxxSetSysMenu(pwnd);
            if (_GetMenuState(xxxGetSysMenuHandle(pwnd), (syscmd & 0xFFF0),
                    MF_BYCOMMAND) & MFS_GRAYED) {
                return;
            }
        }
        break;
    }

    if (syscmd != 0xFFFF) {
        xxxSendMessage(pwnd, WM_SYSCOMMAND, syscmd | htArea, lParam);
    }
}

/***************************************************************************\
* StartScreenSaver
*
* History:
* 11-12-90 MikeHar  ported.
\***************************************************************************/

void StartScreenSaver(
    BOOL bOnlyIfSecure)
{
    /*
     * If a screen saver is already running or we're in the midst of powering
     * down the machine, ignore this request.
     */
    if (gppiScreenSaver != NULL || gPowerState.fInProgress)
        return;

    if (gspwndLogonNotify != NULL) {

        if( glinp.dwFlags & LINP_POWEROFF ) {

            /*
             * If the monitor is turned off.  Tell winlogon to handle the
             * screen saver in a special manner.
             */
            _PostMessage(gspwndLogonNotify,
                    WM_LOGONNOTIFY, LOGON_INPUT_TIMEOUT, 2);
        } else {


            /*
             * Let the logon process take care of the screen saver
             */
            _PostMessage(gspwndLogonNotify,
                    WM_LOGONNOTIFY, LOGON_INPUT_TIMEOUT, bOnlyIfSecure);
        }
    }
}


/***************************************************************************\
* xxxSysCommand
*
* History:
* 11-12-90 MikeHar  ported.
* 02-07-91 DavidPe  Added Win 3.1 WH_CBT support.
\***************************************************************************/

void xxxSysCommand(
    PWND  pwnd,
    DWORD cmd,
    LPARAM lParam)
{
    UINT        htArea;
    PWND        pwndSwitch;
    PMENUSTATE  pMenuState;
    TL          tlpwnd;
    POINT       pt;
    DWORD       dw;
    PWND        pwndCapture;
    PTHREADINFO pti;

    CheckLock(pwnd);

    htArea = (UINT)(cmd & 0x0F);
    cmd -= htArea;

    /*
     * Intense hack o' death.
     */
    if (lParam == 0x00010000L)
        lParam = 0L;

    /*
     * If the system doesn't have capture (ie CLENT_CAPTURE_INTERNAL)
     * do the sys command.  Also, do the sys command for the special case
     * where the window receiving the sys command is a console window that
     * is in full screen mode.  In this case we let the sys command through.
     *
     * Also if this a SC_SCREENSAVE then we handle it anyway and
     * switching desktops will do the cancel.  SC_SCREENSAVER
     * is special so we can start the screen saver even if we are in
     * menu mode for security so NT bug 10975 Banker's Trust
     */
    pti = GETPTI(pwnd);

    /*
     * For 32bit apps (and apps on seperate queues), we need to check
     * the capture in the queue.  Otherwise, on MDI child-destruction
     * we would get the restore when they shouldn't.  This broke MSGOLF
     * who during the restore, AV'd because they assumed this wouldn't
     * happen. On 16bit shared apps, we want to check the internal
     * capture.  Otherwise, when doing 16bit drag-and-drop, we would
     * not restore the minimized window if we had a queue-capture-window.
     */

    /*
     * But... it is too broad a change to just check internal capture for all WoW apps. Some
     * apps depend on bailing out when they have capture set. (Adobe Persuasion, NT bug 68794,
     * for SC_MOVE).  So, let's restrict the hack to SC_RESTORE to keep Ole drag-and-drop working.
     * See NT bug 6109. FritzS
     */

    pwndCapture = ((pti->TIF_flags & TIF_16BIT) && (cmd == SC_RESTORE)) ? gspwndInternalCapture :
                                                 pti->pq->spwndCapture;

    if ((!pwndCapture && !TestWF(pwnd, WFDISABLED)) ||
        (pwnd == gspwndFullScreen)                  ||
        (cmd == SC_SCREENSAVE)                      ||
        (cmd == SC_MONITORPOWER)                    ||
        (cmd == SC_TASKLIST)) {

        /*
         * Perform the sys command
         */

#ifdef SYSMODALWINDOWS
        if (gspwndSysModal != NULL) {
            switch (cmd) {
            case SC_SIZE:
            case SC_MOVE:
            case SC_MINIMIZE:
            case SC_MAXIMIZE:
            case SC_NEXTWINDOW:
            case SC_PREVWINDOW:
            case SC_SCREENSAVE:
                return;
            }
        }
#endif

        /*
         * Call the CBT hook asking if it's okay to do this command.
         * If not, return from here.
         */
        if (IsHooked(PtiCurrent(), WHF_CBT) && xxxCallHook(HCBT_SYSCOMMAND,
                (DWORD)cmd, (DWORD)lParam, WH_CBT)) {
            return;
        }

        switch (cmd) {
        case SC_RESTORE:
            cmd = SW_RESTORE;
            if (TestWF(pwnd, WFMINIMIZED) || !TestWF(pwnd, WFMAXIMIZED))
                PlayEventSound(USER_SOUND_RESTOREUP);
            else
                PlayEventSound(USER_SOUND_RESTOREDOWN);
            goto MinMax;


        case SC_MINIMIZE:
            cmd = SW_MINIMIZE;

            /*
             * Are we already minimized?
             */
            if (TestWF(pwnd, WFMINIMIZED))
                break;

            PlayEventSound(USER_SOUND_MINIMIZE);

            goto MinMax;
        case SC_MAXIMIZE:
            cmd = SW_SHOWMAXIMIZED;

            /*
             * Are we already maximized?
             */
            if (TestWF(pwnd, WFMAXIMIZED))
                break;

            PlayEventSound(USER_SOUND_MAXIMIZE);
MinMax:
            xxxShowWindow(pwnd, cmd | TEST_PUDF(PUDF_ANIMATE));
            return;

        case SC_SIZE:
            {
                xxxMoveSize(pwnd, htArea, _GetMessagePos());
            }
            return;

        case SC_MOVE:
            //
            // Don't enter movesize loop unless the user is actually
            // dragging from the caption.  Otherwise, put up the system
            // menu on a minimized window.
            //

            //
            // Are we dragging with the left mouse button?
            //
            dw = _GetMessagePos();
            POINTSTOPOINT( pt, MAKEPOINTS(dw));
            if ( !htArea ||
                 xxxIsDragging(pwnd, pt, WM_LBUTTONUP)) {

                /*
                 * We are moving.  Enter move/size loop.
                 */
                {
                    xxxMoveSize(pwnd, (htArea == 0) ? WMSZ_KEYMOVE : WMSZ_MOVE, dw);
                }
            } else {

                /*
                 * Activate our window, just like we would have in
                 * MoveSize().
                 */
                xxxSetWindowPos(pwnd, PWND_TOP, 0, 0, 0, 0,
                                SWP_NOMOVE | SWP_NOSIZE);
                if (TestWF(pwnd, WFMINIMIZED)) {

                    /*
                     * Try to popup the system menu
                     */
                    xxxSendMessage(pwnd, WM_SYSCOMMAND, SC_KEYMENU,
                            (DWORD) (TestWF(pwnd, WFCHILD) ? '-' : MENUSYSMENU));
                }
            }
            return;

        case SC_CLOSE:
            xxxSendMessage(pwnd, WM_CLOSE, 0L, 0L);
            return;

        case SC_NEXTWINDOW:
        case SC_PREVWINDOW:
            xxxOldNextWindow((UINT)lParam);
            break;

        case SC_CONTEXTHELP:
            xxxHelpLoop(pwnd);
            break;

        case SC_KEYMENU:

            /*
             * A menu was selected via keyboard
             */
            pMenuState = xxxMNStartMenuState(pwnd, cmd, lParam);
            if (pMenuState != NULL) {
                UserAssert(PtiCurrent() == pMenuState->ptiMenuStateOwner);

                /*
                 * Make sure we are not fullscreen
                 */
                if (gspwndFullScreen == pwnd) {
                    PWND pwndT;
                    TL tlpwndT;

                    pwndT = _GetDesktopWindow();
                    ThreadLock(pwndT, &tlpwndT);
                    xxxMakeWindowForegroundWithState(pwndT, GDIFULLSCREEN);
                    ThreadUnlock(&tlpwndT);
                }

                pMenuState->fUnderline = TRUE;
                xxxMNKeyFilter(pMenuState->pGlobalPopupMenu, pMenuState, (UINT)lParam);
                if (!pMenuState->fModelessMenu) {
                    xxxMNEndMenuState (TRUE);
                }
            }
            /*
             * Capture must have been unlocked
             */
            UserAssert(!(PtiCurrent()->pq->QF_flags & QF_CAPTURELOCKED));
            return;

        case SC_MOUSEMENU:
        case SC_DEFAULT:

            /*
             * If the window is not foreground, eat the command to avoid
             * wasting time flashing the system menu.
             *
             * We used to check if the top level window was WFFRAMEON (so a
             * child window's system menu works like Win 3.1) but Excel's
             * (SDM) dialogs allow you to access their menus even though
             * the child and parent appear to be inactive.
             */
            if (!(GETPTI(pwnd)->pq == gpqForeground))
                return;

            /*
             * A mouse click occurred on a toplevel menu.
             */
            pMenuState = xxxMNStartMenuState(pwnd, cmd, lParam);
            if (pMenuState != NULL) {
                UserAssert(PtiCurrent() == pMenuState->ptiMenuStateOwner);
                xxxMNLoop(pMenuState->pGlobalPopupMenu, pMenuState, lParam, (cmd==SC_DEFAULT));
                if (!pMenuState->fModelessMenu) {
                    xxxMNEndMenuState (TRUE);
                }
            }
            /*
             * Capture must have been unlocked
             */
            UserAssert(!(PtiCurrent()->pq->QF_flags & QF_CAPTURELOCKED));
            return;

        case SC_VSCROLL:
        case SC_HSCROLL:
            xxxSBTrackInit(pwnd, lParam, htArea, (_GetKeyState(VK_SHIFT) < 0) ? SCROLL_DIRECT : SCROLL_NORMAL);
            return;

        case SC_TASKLIST:
//            _PostThreadMessage(gptiTasklist, WM_SYSCOMMAND, SC_TASKLIST, 0);
//            if (!FCallTray() ||
//                !CallHook(HSHELL_TASKMAN, (WPARAM) HW16(hwnd), (LPARAM) 0, WH_SHELL))

            /*
             * Winlogon will set lParam to -1 to indicate that we really want a task list,
             * not just the start menu.  We indicate this to the shell by passing a NULL
             * window ptr
             * This message is really intended for the SHELL, so give them the right
             *  to set the foreground.
             */
            if (FDoTray() && (FCallHookTray() || FPostTray(pwnd->head.rpdesk))) {
                PWND pwndTaskman = pwnd->head.rpdesk->pDeskInfo->spwndTaskman;
                if (FCallHookTray()) {
                    xxxCallHook(HSHELL_TASKMAN, (WPARAM)HWq(pwnd), (LPARAM) 0, WH_SHELL);
                }
                if ((FPostTray(pwnd->head.rpdesk)) && (pwndTaskman != NULL)) {
                    glinp.ptiLastWoken = GETPTI(pwndTaskman);
                    _PostMessage(pwndTaskman, gpsi->uiShellMsg, HSHELL_TASKMAN,
                            lParam == (ULONG)(-1) ? (LPARAM) -1 :(LPARAM)HWq(pwnd));
                }
            } else if (gptiTasklist != NULL) {
                 glinp.ptiLastWoken = gptiTasklist;
                _PostThreadMessage(gptiTasklist, WM_SYSCOMMAND, SC_TASKLIST, 0);
// LATER -- FritzS
//                HCURSOR hCursorLast;
//                static char CODESEG szTask[] = " %d %d";

//                ShowCursor(TRUE);
//                hCursorLast = SetCursor32(hCursWait, TRUE);

                // Try in the windows directory first.
//                GetWindowsDirectory(szBuff, sizeof(szBuff));
//                if (szBuff[lstrlen(szBuff) - 1] != '\\')
//                    lstrcatn(szBuff, "\\", sizeof(szBuff));
//                lstrcatn(szBuff, (LPSTR)pTaskManName, sizeof(szBuff));
//                wvsprintf(szBuff+lstrlen(szBuff), (LPSTR)szTask, (LPSTR)&lParam);

//                if (WinExec((LPSTR)szBuff, SW_SHOWNORMAL) <= 32)
//                {
//                    // If it wasn't in the windows directory then try
//                    // searching the full path.
//                    lstrcpyn(szBuff, pTaskManName, sizeof(szBuff));
//                    wvsprintf(szBuff+lstrlen(szBuff), (LPSTR)szTask, (LPSTR)&lParam);
//                    WinExec((LPSTR)szBuff, SW_SHOWNORMAL);
//                }
//
//                ShowCursor(FALSE);
//                SetCursor32(hCursorLast, TRUE);
            }

            break;

        case SC_MONITORPOWER:
            /*
             * If we're powering down the machine, or if we are switching protocol,ignore this request.
             */

            if (gPowerState.fInProgress || gfSwitchInProgress) {
                break;
            }

            switch (lParam) {
            case POWERON_PHASE:
                if ( (glinp.dwFlags & LINP_POWERTIMEOUTS) ||
                     (glinp.dwFlags & LINP_POWEROFF) ) {
                    glinp.dwFlags &= ~LINP_POWEROFF;
                    glinp.dwFlags &= ~LINP_POWERTIMEOUTS;
                    DrvSetMonitorPowerState(gpDispInfo->pmdev,
                                          PowerDeviceD0);
                }
                break;
            case LOWPOWER_PHASE:
                if ((glinp.dwFlags & LINP_LOWPOWER) == 0) {
                    glinp.dwFlags |= LINP_LOWPOWER;
                    DrvSetMonitorPowerState(gpDispInfo->pmdev,
                                          PowerDeviceD1);
                }
                break;
            case POWEROFF_PHASE:
                if ((glinp.dwFlags & LINP_POWEROFF) == 0) {
                    glinp.dwFlags |= LINP_POWEROFF;
                    DrvSetMonitorPowerState(gpDispInfo->pmdev,
                                          PowerDeviceD3);
                }
                break;
            default:
                break;
            }
            break;

        case SC_SCREENSAVE:
            pwndSwitch = RevalidateHwnd(ghwndSwitch);

            // Lock out screen save until we get another input message.

            if (pwndSwitch != NULL && pwnd != pwndSwitch) {
                _PostMessage(pwndSwitch, WM_SYSCOMMAND, SC_SCREENSAVE, 0L);
            } else {
                StartScreenSaver(FALSE);
            }
            break;

        case SC_HOTKEY:

            /*
             * Loword of the lparam is window to switch to
             */
            pwnd = ValidateHwnd((HWND)lParam);
            if (pwnd != NULL) {
                pwndSwitch = _GetLastActivePopup(pwnd);

                if (pwndSwitch != NULL)
                      pwnd = pwndSwitch;

                ThreadLockAlways(pwnd, &tlpwnd);
                xxxSetForegroundWindow(pwnd, FALSE);
                ThreadUnlock(&tlpwnd);

                if (TestWF(pwnd, WFMINIMIZED))
                    _PostMessage(pwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
            }
            break;
        }
    }
}

/***************************************************************************\
* _RegisterTasklist (Private API)
*
* History:
* 05-01-91  DavidPe     Created.
\***************************************************************************/

BOOL _RegisterTasklist(
    PWND pwndTasklist)
{
#ifdef LATER
    //
    // JimA - ??? Why do this?
    //
    PETHREAD Thread;

    Thread = PsGetCurrentThread();
    pRitCSRThread->ThreadHandle = Thread->ThreadHandle;
#endif

    gptiTasklist = GETPTI(pwndTasklist);
    ghwndSwitch = HWq(pwndTasklist);

    /*
     * Don't allow an app to call AttachThreadInput() on task man -
     * we want taskman to be unsynchronized at all times (so the user
     * can bring it up and kill other apps).
     */
    GETPTI(pwndTasklist)->TIF_flags |= TIF_DONTATTACHQUEUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\swp.c ===
/****************************** Module Header ******************************\
* Module Name: swp.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains the xxxSetWindowPos API and related functions.
*
* History:
* 20-Oct-1990 DarrinM   Created.
* 25-Jan-1991 IanJa     added window revalidation
* 11-Jul-1991 DarrinM   Replaced everything with re-ported Win 3.1 code.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CTM_NOCHANGE        0
#define CTM_TOPMOST         1
#define CTM_NOTOPMOST       2

VOID FixBogusSWP(PWND pwnd, int * px, int * py, int cx, int cy, UINT flags);
VOID PreventInterMonitorBlts(PCVR pcvr);


/***************************************************************************\
* DBGCheckSMWP
*
* SMWP can be a HM object, a cached structure or just a pool allocation
*
* History:
* 05/21/98 GerardoB     Created.
\***************************************************************************/
#if DBG
VOID DBGCheckSMWP(
    PSMWP psmwp)
{
    if (psmwp->bHandle) {
        UserAssert(psmwp->head.h != NULL);
        UserAssert(psmwp == HtoPqCat(PtoHq(psmwp)));
        UserAssert(psmwp != &gSMWP);
    } else {
        UserAssert((psmwp->head.h == NULL) && (psmwp->head.cLockObj == 0));
        if (psmwp == &gSMWP) {
            UserAssert(TEST_PUDF(PUDF_GSMWPINUSE));
        }
    }

    UserAssert(psmwp->ccvr <= psmwp->ccvrAlloc);
    UserAssert(psmwp->acvr != NULL);

}
#else
#define DBGCheckSMWP(psmwp)
#endif // DBG

/***************************************************************************\
* DestroySMWP
*
* Destroys an SMWP object.
*
* History:
* 24-Feb-1997 adams     Created.
\***************************************************************************/
VOID DestroySMWP(
    PSMWP psmwp)
{
    BOOL fFree;

    CheckCritIn();

    DBGCheckSMWP(psmwp);
    /*
     * First mark the object for destruction. This tells the locking code
     * that we want to destroy this object when the lock count goes to 0.
     * If this returns FALSE, we can't destroy the object yet.
     */
    if (psmwp->bHandle) {
        if (!HMMarkObjectDestroy(psmwp)) {
            return;
        }
        fFree = TRUE;
    } else {
        /*
         * Is this the global cached structure?
         */
        fFree = (psmwp != &gSMWP);
    }

    if (psmwp->acvr) {

        /*
         * Free any hrgnInterMonitor stuff we accumulated.
         */
        PCVR pcvr;
        int ccvr;

        for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {
            if (pcvr->hrgnInterMonitor != NULL) {
                GreDeleteObject(pcvr->hrgnInterMonitor);
            }
        }

        if (fFree) {
            UserFreePool(psmwp->acvr);
        }
    }

    /*
     * Ok to destroy ... Free the handle (which will free the object
     * and the handle).
     */
    if (psmwp->bHandle) {
        HMFreeObject(psmwp);
    } else if (fFree) {
        UserFreePool(psmwp);
    } else {
        UserAssert(TEST_PUDF(PUDF_GSMWPINUSE));
        CLEAR_PUDF(PUDF_GSMWPINUSE);
        /*
         * If acvr grew too much, shrink it.
         * Don't use realloc since we don't care about the left over data
         * [msadek], should this be ">=8" since we usually grow it from 4->8 in
         * _DeferWindowPos?
         */
        if (psmwp->ccvrAlloc > 8) {
            PCVR pcvr = UserAllocPool(4 * sizeof(CVR), TAG_SWP);
            if (pcvr != NULL) {
                UserFreePool(psmwp->acvr);
                psmwp->acvr = pcvr;
                psmwp->ccvrAlloc = 4;
            }
        }
    }
}


#define MW_FLAGS_REDRAW   (SWP_NOZORDER | SWP_NOACTIVATE)
#define MW_FLAGS_NOREDRAW (SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW)

/***************************************************************************\
* MoveWindow (API)
*
*
* History:
* 25-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL xxxMoveWindow(
    PWND pwnd,
    int  x,
    int  y,
    int  cx,
    int  cy,
    BOOL fRedraw)
{
    CheckLock(pwnd);

    if ((pwnd == PWNDDESKTOP(pwnd)) ||
        TestWF(pwnd, WFWIN31COMPAT) ||
        (pwnd->spwndParent != PWNDDESKTOP(pwnd))) {

        return xxxSetWindowPos(
                pwnd,
                NULL,
                x,
                y,
                cx,
                cy,
                (fRedraw ? MW_FLAGS_REDRAW : MW_FLAGS_NOREDRAW));
    } else {

        /*
         * BACKWARD COMPATIBILITY CODE FOR WIN 3.00 AND BELOW
         *
         * Everyone and their brother seems to depend on this behavior for
         * top-level windows. Specific examples are:
         *
         *  AfterDark help window animation
         *  Finale Speedy Note Editing
         *
         * If the window is a top-level window and fRedraw is FALSE,
         * we must call SetWindowPos with SWP_NOREDRAW CLEAR anyway so that
         * the frame and window background get drawn. We then validate the
         * entire client rectangle to avoid repainting that.
         */
        BOOL fResult = xxxSetWindowPos(pwnd,
                                       NULL,
                                       x,
                                       y,
                                       cx,
                                       cy,
                                       MW_FLAGS_REDRAW);

        if (!fRedraw) {
            xxxValidateRect(pwnd, NULL);
        }

        return fResult;
    }
}

/***************************************************************************\
* AllocateCvr
*
* History:
* 05/20/98  GerardoB    Extracted from old _BeginDeferWindowPos
\***************************************************************************/
BOOL AllocateCvr(
    PSMWP psmwp,
    int cwndHint)
{
    PCVR  acvr;

    UserAssert(cwndHint != 0);

    if (cwndHint > (INT_MAX / sizeof(CVR))) {
        return FALSE;
    }

    if (psmwp == &gSMWP) {
        UserAssert(psmwp->bHandle == FALSE);
        acvr = (PCVR)UserAllocPool(sizeof(CVR) * cwndHint, TAG_SWP);
    } else {
        acvr = (PCVR)UserAllocPoolWithQuota(sizeof(CVR) * cwndHint, TAG_SWP);
    }
    if (acvr == NULL) {
        return FALSE;
    }

    /*
     * Initialize psmwp related fields.
     * CVR array is initialized by _DeferWindowPos
     */

    psmwp->acvr      = acvr;
    psmwp->ccvrAlloc = cwndHint;
    psmwp->ccvr      = 0;
    return TRUE;
}

/***************************************************************************\
* InternalBeginDeferWindowPos
*
* History:
* 05/20/98  GerardoB    Created
\***************************************************************************/
PSMWP InternalBeginDeferWindowPos(
    int cwndHint)
{
    PSMWP psmwp;

    CheckCritIn();

    /*
     * If gSMWP in being used, allocate one.
     * Note that SMWP is zero init but CVR is not; _DeferWindowPos initializes it.
     */
    if (TEST_PUDF(PUDF_GSMWPINUSE) || (cwndHint > gSMWP.ccvrAlloc)) {
        psmwp = (PSMWP)UserAllocPoolWithQuotaZInit(sizeof(SMWP), TAG_SWP);
        if (psmwp == NULL) {
            return NULL;
        }
        if (!AllocateCvr(psmwp, cwndHint)) {
            UserFreePool(psmwp);
            return NULL;
        }
    } else {
        SET_PUDF(PUDF_GSMWPINUSE);
        psmwp = &gSMWP;
        RtlZeroMemory(&gSMWP, FIELD_OFFSET(SMWP, ccvrAlloc));
        UserAssert(gSMWP.ccvr == 0);
        UserAssert(gSMWP.acvr != NULL);
    }

    DBGCheckSMWP(psmwp);
    return psmwp;
}

/***************************************************************************\
* BeginDeferWindowPos (API)
*
* This must be called from the client side only. Internally we should
*  call InternalBeginDeferWindowPos to avoid going through the handle table
*  and perhaps even use the cached strucuture.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
PSMWP _BeginDeferWindowPos(
    int cwndHint)
{
    PSMWP psmwp;

    psmwp = (PSMWP)HMAllocObject(PtiCurrent(), NULL, TYPE_SETWINDOWPOS, sizeof(SMWP));
    if (psmwp == NULL) {
        return NULL;
    }

    if (cwndHint == 0) {
        cwndHint = 8;
    }

    if (!AllocateCvr(psmwp, cwndHint)) {
        HMFreeObject(psmwp);
        return NULL;
    }

    psmwp->bHandle = TRUE;
    DBGCheckSMWP(psmwp);

    return psmwp;
}

/***************************************************************************\
* PWInsertAfter
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/
PWND PWInsertAfter(
   HWND hwnd)
{
    PWND pwnd;

    /*
     * HWND_GROUPTOTOP and HWND_TOPMOST are the same thing.
     */
    switch ((ULONG_PTR)hwnd) {
    case (ULONG_PTR)HWND_TOP:
    case (ULONG_PTR)HWND_BOTTOM:
    case (ULONG_PTR)HWND_TOPMOST:
    case (ULONG_PTR)HWND_NOTOPMOST:
        return (PWND)hwnd;

    default:

        /*
         * Don't insert after a destroyed window!  It will cause the
         * window being z-ordered to become unlinked from it's siblings.
         */
        if (pwnd = RevalidateHwnd(hwnd)) {

            /*
             * Do not insert after a destroyed window. Put it at the
             * bottom of the list, if it is z-ordered at all.
             */
            if (TestWF(pwnd, WFDESTROYED) || pwnd->spwndParent == NULL)
                return NULL;

            UserAssert(_IsDescendant(pwnd->spwndParent, pwnd));
            return pwnd;
        }

        return NULL;
    }
}

HWND HWInsertAfter(
    PWND pwnd)
{
    /*
     * HWND_GROUPTOTOP and HWND_TOPMOST are the same thing.
     */
    switch ((ULONG_PTR)pwnd) {
    case (ULONG_PTR)HWND_TOP:
    case (ULONG_PTR)HWND_BOTTOM:
    case (ULONG_PTR)HWND_TOPMOST:
    case (ULONG_PTR)HWND_NOTOPMOST:
        return (HWND)pwnd;

    default:
        return HW(pwnd);
    }
}

/***************************************************************************\
* DeferWindowPos (API)
*
*
* History:
* 07-11-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/
PSMWP _DeferWindowPos(
    PSMWP psmwp,
    PWND  pwnd,
    PWND  pwndInsertAfter,
    int   x,
    int   y,
    int   cx,
    int   cy,
    UINT  flags)
{
    PWINDOWPOS ppos;
    PCVR       pcvr;

    DBGCheckSMWP(psmwp);
    if (psmwp->ccvr + 1 > psmwp->ccvrAlloc) {
        /*
         * Make space for 4 more windows.
         */
        DWORD dwNewAlloc = psmwp->ccvrAlloc + 4;
        if (psmwp == &gSMWP) {
            UserAssert(psmwp->bHandle == FALSE);
            pcvr = (PCVR)UserReAllocPoolWithTag(psmwp->acvr,
                                                  psmwp->ccvrAlloc * sizeof(CVR),
                                                  sizeof(CVR) * dwNewAlloc,
                                                  TAG_SWP);
        } else {
            pcvr = (PCVR)UserReAllocPoolWithQuota(psmwp->acvr,
                                                  psmwp->ccvrAlloc * sizeof(CVR),
                                                  sizeof(CVR) * dwNewAlloc,
                                                  TAG_SWP);
        }
        if (pcvr == NULL) {
            DestroySMWP(psmwp);
            return NULL;
        }

        psmwp->acvr = pcvr;
        psmwp->ccvrAlloc = dwNewAlloc;
    }

    pcvr = &psmwp->acvr[psmwp->ccvr++];
    ppos = &pcvr->pos;

    ppos->hwnd            = HWq(pwnd);
    ppos->hwndInsertAfter = (TestWF(pwnd, WFBOTTOMMOST)) ?
                                HWND_BOTTOM : HWInsertAfter(pwndInsertAfter);
    ppos->x               = x;
    ppos->y               = y;
    ppos->cx              = cx;
    ppos->cy              = cy;
    ppos->flags           = flags;

    pcvr->hrgnClip = NULL;
    pcvr->hrgnInterMonitor = NULL;

    return psmwp;
}

/***************************************************************************\
* ValidateWindowPos
*
* checks validity of SWP structure
*
* NOTE: For performance reasons, this routine is only called
*       in the DEBUG version of USER.
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL ValidateWindowPos(
    PCVR pcvr,
    PWND pwndParent)
{
    PWND pwnd;
    PWND pwndInsertAfter;
    HWND hwndInsertAfter;

    if ((pwnd = RevalidateHwnd(pcvr->pos.hwnd)) == NULL)
        return FALSE;

    /*
     * Save the pti.
     */
    pcvr->pti = GETPTI(pwnd);


    /*
     * If the SWP_NOZORDER bit is not set, validate the Insert behind window.
     */
    if (!(pcvr->pos.flags & SWP_NOZORDER)) {
        BOOL fTopLevel = (pwnd->spwndParent == PWNDDESKTOP(pwnd));
        /*
         * Do not z-order destroyed windows
         */
        if (TestWF(pwnd, WFDESTROYED))
            return FALSE;

        hwndInsertAfter = pcvr->pos.hwndInsertAfter;
        /*
         * If pwndParent is provided, we're about to link this window so we
         * need to validate LinkWindow assumptions. We have to do this since
         * we callback after determining hwndInsertAfter.
         */

        if ((hwndInsertAfter == HWND_TOPMOST) ||
            (hwndInsertAfter == HWND_NOTOPMOST)) {

            if (!fTopLevel) {
                return FALSE;
            }
        } else if (hwndInsertAfter == HWND_TOP) {
            /*
             * If pwnd is not topmost, the first child must not be topmost.
             */
            if ((pwndParent != NULL) && fTopLevel
                    && !FSwpTopmost(pwnd)
                    && (pwndParent->spwndChild != NULL)
                    && FSwpTopmost(pwndParent->spwndChild)) {

                RIPMSG2(RIP_WARNING, "ValidateWindowPos: pwnd is not SWPTopMost."
                                     " pwnd:%#p. hwndInsertAfter:%#p",
                                      pwnd, hwndInsertAfter);
                return FALSE;
            }
        } else if (hwndInsertAfter != HWND_BOTTOM) {

            /*
             * Ensure pwndInsertAfter is valid
             */
            if (((pwndInsertAfter = RevalidateHwnd(hwndInsertAfter)) == NULL) ||
                    TestWF(pwndInsertAfter, WFDESTROYED)) {

                RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING, "Invalid hwndInsertAfter (%#p)", hwndInsertAfter);

                return FALSE;
            }

            /*
             * Ensure that pwndInsertAfter is a sibling of pwnd
             */
            if (pwnd == pwndInsertAfter ||
                    pwnd->spwndParent != pwndInsertAfter->spwndParent) {
                RIPMSG2(RIP_WARNING, "hwndInsertAfter (%#p) is not a sibling "
                        "of hwnd (%#p)", hwndInsertAfter, pcvr->pos.hwnd);
                return FALSE;
            }
            /*
             * Ensure proper topmost/nontopmost insert position
             */
            if ((pwndParent != NULL) && fTopLevel) {
                if (FSwpTopmost(pwnd)) {
                    /*
                     * Check if we're trying to insert a topmost window after a non-topmost one.
                     */
                    if (!FSwpTopmost(pwndInsertAfter)) {
                        RIPMSG2(RIP_WARNING, "ValidateWindowPos: pwndInsertAfter is not SWPTopMost."
                                             " pwnd:%#p. pwndInsertAfter:%#p",
                                              pwnd, pwndInsertAfter);
                        return FALSE;
                    }
                } else {
                    /*
                     * Check if we're trying to insert a non-top most window
                     * between two top-most ones.
                     */
                    if ((pwndInsertAfter->spwndNext != NULL)
                            && FSwpTopmost(pwndInsertAfter->spwndNext)) {

                        RIPMSG2(RIP_WARNING, "ValidateWindowPos: pwndInsertAfter->spwndNext is SWPTopMost."
                                             " pwnd:%#p. pwndInsertAfter:%#p",
                                              pwnd, pwndInsertAfter);
                        return FALSE;
                    }
                }

            }

        }

        /*
         * Check that the parent hasn't changed.
         */
        if (pwndParent != NULL) {
            if (pwndParent != pwnd->spwndParent) {
                RIPMSG3(RIP_WARNING, "ValidateWindowPos: parent has changed."
                                     " pwnd:%#p. Old Parent:%#p. Current Parent:%#p",
                                      pwnd, pwndParent, pwnd->spwndParent);
                return FALSE;
            }
        }

    }

    return TRUE;
}

/***************************************************************************\
* IsStillWindowC
*
* Checks if window is valid HWNDC still, and child of proper dude.
*
* History:
\***************************************************************************/
BOOL IsStillWindowC(
    HWND hwndc)
{
    switch ((ULONG_PTR)hwndc) {
    case (ULONG_PTR)HWND_TOP:
    case (ULONG_PTR)HWND_BOTTOM:
    case (ULONG_PTR)HWND_TOPMOST:
    case (ULONG_PTR)HWND_NOTOPMOST:
        return TRUE;

    default:
        /*
         * Make sure we're going to insert after a window that's:
         *  (1) Valid
         *  (2) Peer
         */
        return (RevalidateHwnd(hwndc) != 0);
    }
}

/***************************************************************************\
* ValidateSmwp
*
* Validate the SMWP and figure out which window should get activated,
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL ValidateSmwp(
    PSMWP psmwp,
    BOOL  *pfSyncPaint)
{
    PCVR pcvr;
    PWND pwndParent;
    PWND pwndT;
    int  ccvr;

    *pfSyncPaint = TRUE;

    pwndT = RevalidateHwnd(psmwp->acvr[0].pos.hwnd);

    if (pwndT == NULL)
        return FALSE;

    pwndParent = pwndT->spwndParent;

    /*
     * Validate the passed-in WINDOWPOS structs, and find a window to activate.
     */
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        if (!ValidateWindowPos(pcvr, NULL)) {
            pcvr->pos.hwnd = NULL;
            continue;
        }

        /*
         * All windows in the pos list must have the same parent.
         * If not, yell and return FALSE.
         */
        UserAssert(IsStillWindowC(pcvr->pos.hwnd));

        UserAssert(PW(pcvr->pos.hwnd));
        if (PW(pcvr->pos.hwnd)->spwndParent != pwndParent) {
            RIPERR0(ERROR_HWNDS_HAVE_DIFF_PARENT, RIP_VERBOSE, "");
            return FALSE;
        }

        /*
         * If SWP_DEFERDRAWING is set for any of the windows, suppress
         * DoSyncPaint() call later.
         */
        if (pcvr->pos.flags & SWP_DEFERDRAWING)
            *pfSyncPaint = FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* FindValidWindowPos
*
* Some of the windows in the SMWP list may be NULL at ths point (removed
* because they'll be handled by their creator's thread) so we've got to
* look for the first non-NULL window and return it.
*
* History:
* 10-Sep-1991 DarrinM    Created.
\***************************************************************************/
PWINDOWPOS FindValidWindowPos(
    PSMWP psmwp)
{
    int i;

    for (i = 0; i < psmwp->ccvr; i++) {

        if (psmwp->acvr[i].pos.hwnd != NULL)
            return &psmwp->acvr[i].pos;
    }

    return NULL;
}

/***************************************************************************\
* GetLastNonBottomMostWindow
*
* Returns the last non bottom-most window in the z-order, NULL if
* there isn't one. When figuring out whom to insert after, we want to
* skip ourself. But when figuring out if we're already in place, we don't
* want to skip ourself on enum.
*
* History:
\***************************************************************************/
PWND GetLastNonBottomMostWindow(
    PWND pwnd,
    BOOL fSkipSelf)
{
    PWND pwndT;
    PWND pwndLast = NULL;

    for (pwndT = pwnd->spwndParent->spwndChild;
         pwndT && !TestWF(pwndT, WFBOTTOMMOST);
         pwndT = pwndT->spwndNext) {

        if (!fSkipSelf || (pwnd != pwndT))
            pwndLast = pwndT;
    }

    return pwndLast;
}

/***************************************************************************\
* ValidateZorder
*
* Checks to see if the specified window is already in the specified Z order
* position, by comparing the current Z position with the specified
* pwndInsertAfter.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL ValidateZorder(
    PCVR pcvr)
{
    PWND pwnd;
    PWND pwndPrev;
    PWND pwndInsertAfter;
    BYTE bTopmost;

    /*
     * Validate just to make sure this routine doesn't do anything bogus.
     * Its caller will actually redetect and handle the error.
     */
    UserAssert(RevalidateCatHwnd(pcvr->pos.hwnd));
    pwnd = PWCat(pcvr->pos.hwnd);      // Known to be valid at this point.

    /*
     * Don't z-order a destroyed window.
     */
    if (TestWF(pwnd, WFDESTROYED)) {
        return TRUE;
    }

    UserAssert((HMPheFromObject(pwnd)->bFlags & HANDLEF_DESTROY) == 0);

    pwndInsertAfter = PWInsertAfter(pcvr->pos.hwndInsertAfter);
    if (pcvr->pos.hwndInsertAfter != NULL && pwndInsertAfter == NULL) {
        return TRUE;
    }

    if (pwndInsertAfter == PWND_BOTTOM) {
        if (TestWF(pwnd, WFBOTTOMMOST)) {
            return (pwnd->spwndNext == NULL);
        } else {
            return (pwnd == GetLastNonBottomMostWindow(pwnd, FALSE));
        }
    }

    pwndPrev = pwnd->spwndParent->spwndChild;
    if (pwndInsertAfter == PWND_TOP) {
        return pwndPrev == pwnd;
    }

    if (TestWF(pwndInsertAfter, WFDESTROYED)) {
        return TRUE;
    }

    /*
     * When we compare the state of the window, we must use
     * the EVENTUAL state of the window that is moving, but
     * the CURRENT state of the window it's inserted behind.
     *
     * Prevent nonbottommost windows from going behind the bottommost one.
     */
    if (TestWF(pwndInsertAfter, WFBOTTOMMOST)) {
        pcvr->pos.hwndInsertAfter = HWInsertAfter(GetLastNonBottomMostWindow(pwnd, TRUE));
        return FALSE;
    }

    /*
     * If we are not topmost, but pwndInsertAfter is, OR
     * if we are topmost, but pwndInsertAfter is not,
     * we need to adjust pwndInsertAfter to be the last of
     * the topmost windows.
     */
    bTopmost = TestWF(pwnd, WEFTOPMOST);

    if (TestWF(pwnd, WFTOGGLETOPMOST))
        bTopmost ^= LOBYTE(WEFTOPMOST);

    if (bTopmost != (BYTE)TestWF(pwndInsertAfter, WEFTOPMOST)) {

        pwndInsertAfter = GetLastTopMostWindow();

        /*
         * We're correctly positioned if we're already at the bottom
         */
        if (pwndInsertAfter == pwnd) {
            return TRUE;
        }

        pcvr->pos.hwndInsertAfter = HW(pwndInsertAfter);
    }

    /*
     * Look for our previous window in the list ...
     */
    if (pwndPrev != pwnd) {
        for (; pwndPrev != NULL; pwndPrev = pwndPrev->spwndNext) {
            if (pwndPrev->spwndNext == pwnd) {
                return pwndInsertAfter == pwndPrev;
            }
        }

        /*
         * NTRAID#NTBUG9-345299-2001/04/09-jasonsch
         *
         * If we get to here, pwnd is not in the sibling list.
         * REALLY BAD NEWS!
         *
         * Changing this to a warning since we seem to handle it fine
         * and there's a shell dude hitting this. Need to revisit
         * this in Blackcomb.
         */
        RIPMSG1(RIP_WARNING, "Pwnd 0x%p not found in sibling list.", pwnd);
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* xxxCalcValidRects
*
* Based on the WINDOWPOS flags in the fs parameter in each WINDOWPOS structure,
* this routine calcs the new position and size of each window, determines if
* its changing Z order, or whether its showing or hiding. Any redundant
* flags are AND'ed out of the fs parameter. If no redrawing is needed,
* SWP_NOREDRAW is OR'ed into the flags. This is called from EndDeferWindowPos.
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL xxxCalcValidRects(
    PSMWP psmwp,
    HWND  *phwndNewActive)
{
    PCVR              pcvr;
    PWND              pwnd;
    PWND              pwndParent;
    HWND              hwnd;
    HWND              hwndNewActive = NULL;
    PWINDOWPOS        ppos;
    BOOL              fNoZorder;
    BOOL              fForceNCCalcSize;
    NCCALCSIZE_PARAMS params;
    int               cxSrc;
    int               cySrc;
    int               cxDst;
    int               cyDst;
    int               cmd;
    int               ccvr;
    int               xClientOld;
    int               yClientOld;
    int               cxClientOld;
    int               cyClientOld;
    int               xWindowOld;
    int               xWindowOldLogical;
    int               yWindowOld;
    int               cxWindowOld;
    int               cyWindowOld;
    TL                tlpwndParent;
    TL                tlpwnd;
    BOOL              fSetZeroDx=FALSE;
    BOOL              fMirroredParent = FALSE;

    /*
     * Some of the windows in the SMWP list may be NULL at ths point
     * (removed because they'll be handled by their creator's thread)
     * so we've got to look for the first non-NULL window before we can
     * execute some of the tests below. FindValidWindowPos returns NULL if
     * the list has no valid windows in it.
     */
    if ((ppos = FindValidWindowPos(psmwp)) == NULL)
        return FALSE;

    UserAssert(PW(ppos->hwnd));
    pwndParent = PW(ppos->hwnd)->spwndParent;

    UserAssert(HMRevalidateCatHandle(PtoH(pwndParent)));

    ThreadLock(pwndParent, &tlpwndParent);

    fNoZorder = TRUE;

    /*
     * Go through the SMWP list, enumerating each WINDOWPOS, and compute
     * its new window and client rectangles.
     */
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        /*
         * This loop may leave the critsect during each iteration so
         * we revalidate pos.hwnd before use.
         */
        if ((hwnd = pcvr->pos.hwnd) == NULL)
            continue;

        pwnd = RevalidateHwnd(hwnd);

        if ((pwnd == NULL) || !IsStillWindowC(pcvr->pos.hwndInsertAfter)) {
            pcvr->pos.hwnd  = NULL;
            pcvr->pos.flags = SWP_NOREDRAW | SWP_NOCHANGE;
            continue;
        }

        ThreadLockAlways(pwnd, &tlpwnd);

        /*
         * Used for 3.0 compatibility. 3.0 sent the NCCALCSIZE message even if
         * the size of the window wasn't changing.
         */
        fForceNCCalcSize = FALSE;

        if (!hwndNewActive && !(pcvr->pos.flags & SWP_NOACTIVATE))
            hwndNewActive = HWq(pwnd);

        if (!(pcvr->pos.flags & SWP_NOSENDCHANGING)) {

            PWND pwndT;

            xxxSendMessage(pwnd, WM_WINDOWPOSCHANGING, 0, (LPARAM)&pcvr->pos);


            /*
             * Don't let them change pcvr->pos.hwnd. It doesn't make sense
             * plus it'll mess us up. I'm making this RIP_ERROR because we're
             * too close to RTM (7/11/96) just to make sure that we won't
             * break anyone. This should be changed to a RIP_WARNING after we
             * ship. Use LOWORD to ignore "changes" by NTVDM.
             */
#if DBG
            if (LOWORD(pcvr->pos.hwnd) != LOWORD(hwnd)) {
                RIPMSG0(RIP_ERROR,
                        "xxxCalcValidRects: Ignoring pcvr->pos.hwnd change by WM_WINDOWPOSCHANGING");
            }
#endif
            pcvr->pos.hwnd = hwnd;

            /*
             * If the window sets again 'hwndInsertAfter' to HWND_NOTOPMOST
             * or HWND_TOPMOST, we need to set this member appropriately.
             * See CheckTopmost for details.
             */
            if (pcvr->pos.hwndInsertAfter == HWND_NOTOPMOST) {
                if (TestWF(pwnd, WEFTOPMOST)) {

                    pwndT = GetLastTopMostWindow();
                    pcvr->pos.hwndInsertAfter = HW(pwndT);

                    if (pcvr->pos.hwndInsertAfter == pcvr->pos.hwnd) {
                        pwndT = _GetWindow(pwnd, GW_HWNDPREV);
                        pcvr->pos.hwndInsertAfter = HW(pwndT);
                    }
                } else {
                    pwndT = _GetWindow(pwnd, GW_HWNDPREV);
                    pcvr->pos.hwndInsertAfter = HW(pwndT);
                }
            } else if (pcvr->pos.hwndInsertAfter == HWND_TOPMOST) {
                pcvr->pos.hwndInsertAfter = HWND_TOP;
            }
        }
        /*
         * make sure the rectangle still matches the window's region
         *
         * Remember the old window rectangle in parent coordinates
         */
        xWindowOld  = pwnd->rcWindow.left;
        yWindowOld  = pwnd->rcWindow.top;

        xWindowOldLogical = xWindowOld;

        if (pwndParent != PWNDDESKTOP(pwnd)) {
            xWindowOld -= pwndParent->rcClient.left;
            yWindowOld -= pwndParent->rcClient.top;

            fMirroredParent = (TestWF(pwndParent, WEFLAYOUTRTL) && TestwndChild(pwnd));

            if (fMirroredParent) {
                xWindowOldLogical = pwndParent->rcClient.right - pwnd->rcWindow.right;
            } else {
                xWindowOldLogical = xWindowOld;
            }
        }

        cxWindowOld = pwnd->rcWindow.right - pwnd->rcWindow.left;
        cyWindowOld = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

        /*
         * Assume the client is not moving or sizing
         */
        pcvr->pos.flags |= SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE;

        if (!(pcvr->pos.flags & SWP_NOMOVE)) {

            if (pcvr->pos.x == xWindowOldLogical && pcvr->pos.y == yWindowOld) {
                pcvr->pos.flags |= SWP_NOMOVE;
                if (fMirroredParent) {
                    fSetZeroDx = TRUE;
                }
            }

            if (TestWF(pwnd, WFMINIMIZED) && IsTrayWindow(pwnd)) {
                pcvr->pos.x = WHERE_NOONE_CAN_SEE_ME;
                pcvr->pos.y = WHERE_NOONE_CAN_SEE_ME;
            }
        } else {
            pcvr->pos.x = xWindowOldLogical;
            pcvr->pos.y = yWindowOld;
        }

        if (!(pcvr->pos.flags & SWP_NOSIZE)) {

            /*
             * Don't allow an invalid window rectangle.
             * BOGUS HACK: For Norton Antivirus, they call
             * MoveWindow at WM_CREATE Time EVEN though
             * the window is minimzed, but they assume its
             * restored at WM_CREATE time.... B#11185, t-arthb
             */
            if (TestWF(pwnd, WFMINIMIZED) &&
                _GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL)) {

                pcvr->pos.cx = SYSMET(CXMINIMIZED);
                pcvr->pos.cy = SYSMET(CYMINIMIZED);

            } else {
                if (pcvr->pos.cx < 0)
                    pcvr->pos.cx = 0;

                if (pcvr->pos.cy < 0)
                    pcvr->pos.cy = 0;
            }

            if (pcvr->pos.cx == cxWindowOld && pcvr->pos.cy == cyWindowOld) {
                pcvr->pos.flags |= SWP_NOSIZE;
                if (!TestWF(pwnd, WFWIN31COMPAT))
                    fForceNCCalcSize = TRUE;
            }
        } else {
            pcvr->pos.cx = cxWindowOld;
            pcvr->pos.cy = cyWindowOld;
        }

        if (fMirroredParent) {
            UserAssert(pwndParent != PWNDDESKTOP(pwnd));
            pcvr->pos.x = (pwndParent->rcClient.right - pwndParent->rcClient.left) - pcvr->pos.x - pcvr->pos.cx;
        }

        /*
         * If showing and already visible, or hiding and already hidden,
         * turn off the appropriate bit.
         */
        if (TestWF(pwnd, WFVISIBLE)) {
            pcvr->pos.flags &= ~SWP_SHOWWINDOW;
        } else {
            pcvr->pos.flags &= ~SWP_HIDEWINDOW;

            /*
             * If hidden, and we're NOT showing, then we won't be drawing,
             * no matter what else is going on.
             */
            if (!(pcvr->pos.flags & SWP_SHOWWINDOW))
                pcvr->pos.flags |= SWP_NOREDRAW;
        }

        /*
         * Child windows inside a composited window can't use screen to
         * screen bit copy because this can move translucent bits.
         */
        if (!TestWF(pwnd, WEFCOMPOSITED) &&
                GetStyleWindow(pwnd, WEFCOMPOSITED) != NULL) {
            pcvr->pos.flags |= SWP_NOCOPYBITS;
        }

        /*
         * Muck with the zorder for bottommost windows, again
         * See comment in DeferWindowPos
         */
        if (TestWF(pwnd, WFBOTTOMMOST)) {
            pcvr->pos.flags &= ~SWP_NOZORDER;
            pcvr->pos.hwndInsertAfter = HWND_BOTTOM;
        }

        /*
         * If we're Z-ordering, we can try to remove the Z order
         * bit, as long as all previous windows in the WINDOWPOS list
         * have SWP_NOZORDER set.
         *
         * The reason we don't do this for each window individually
         * is that a window's eventual Z order depends on changes that
         * may have occured on windows earlier in the WINDOWPOS list,
         * so we can only call ValidateZorder if none of the previous
         * windows have changed.
         */
        if (fNoZorder && !(pcvr->pos.flags & SWP_NOZORDER)) {

            /*
             * If the TOPMOST bit is changing, the Z order is "changing",
             * so don't clear the bit even if it's in the right place in the
             * list.
             */
            fNoZorder = FALSE;
            if (!TestWF(pwnd, WFTOGGLETOPMOST) && ValidateZorder(pcvr)) {
                fNoZorder = TRUE;
                pcvr->pos.flags |= SWP_NOZORDER;
            }
        }

        /*
         * If no change is occuring, or if a parent is invisible,
         * we won't be redrawing.
         */
        if (!(pcvr->pos.flags & SWP_NOREDRAW)) {
            if ((pcvr->pos.flags & SWP_CHANGEMASK) == SWP_NOCHANGE ||
                    !_FChildVisible(pwnd)) {
                pcvr->pos.flags |= SWP_NOREDRAW;
            }
        }

        /*
         * BACKWARD COMPATIBILITY HACK
         *
         * In 3.0, if a window was moving but not sizing, we'd send the
         * WM_NCCALCSIZE message anyhow. Lotus Notes 2.1 depends on this
         * in order to move its "navigation bar" when the main window moves.
         */
        if (!(pcvr->pos.flags & SWP_NOMOVE) &&
            !TestWF(pwnd, WFWIN31COMPAT) &&
            (GetAppCompatFlags(NULL) & GACF_NCCALCSIZEONMOVE)) {

            fForceNCCalcSize = TRUE;
        }

        /*
         * If the window rect is sizing, or if the frame has changed,
         * send the WM_NCCALCSIZE message and deal with valid areas.
         */
        if (((pcvr->pos.flags & (SWP_NOSIZE | SWP_FRAMECHANGED)) != SWP_NOSIZE) ||
            fForceNCCalcSize) {

            WINDOWPOS pos;

            /*
             * check for full screen main app window
             */
            if (!TestWF(pwnd, WFCHILD) && !TestWF(pwnd, WEFTOOLWINDOW)) {
                xxxCheckFullScreen(pwnd, (PSIZERECT)&pcvr->pos.x);
            }

            /*
             * Set up NCCALCSIZE message parameters (in parent coords)
             * wParam = fClientOnly = TRUE
             * lParam = &params
             */
            pos = pcvr->pos;     // Make a local stack copy
            params.lppos = &pos;

            /*
             * params.rgrc[0] = rcWindowNew = New window rectangle
             * params.rgrc[1] = rcWindowOld = Old window rectangle
             * params.rgrc[2] = rcClientOld = Old client rectangle
             */
            #define rcWindowNew params.rgrc[0]
            #define rcWindowOld params.rgrc[1]
            #define rcClientOld params.rgrc[2]

            /*
             * Set up rcWindowNew in parent relative coordinates
             */
            rcWindowNew.left   = pcvr->pos.x;
            rcWindowNew.right  = rcWindowNew.left + pcvr->pos.cx;
            rcWindowNew.top    = pcvr->pos.y;
            rcWindowNew.bottom = rcWindowNew.top + pcvr->pos.cy;

            /*
             * Set up rcWindowOld in parent relative coordinates
             */
            GetRect(pwnd, &rcWindowOld, GRECT_WINDOW | GRECT_PARENTCOORDS);

            /*
             * Set up rcClientOld in parent relative coordinates
             */
            GetRect(pwnd, &rcClientOld, GRECT_CLIENT | GRECT_PARENTCOORDS);

            /*
             * Keep around a copy of the old client position
             */
            xClientOld  = rcClientOld.left;
            cxClientOld = rcClientOld.right - rcClientOld.left;
            yClientOld  = rcClientOld.top;
            cyClientOld = rcClientOld.bottom - rcClientOld.top;

            cmd = (UINT)xxxSendMessage(pwnd, WM_NCCALCSIZE, TRUE, (LPARAM)&params);

            if (!IsStillWindowC(pcvr->pos.hwndInsertAfter)) {
                ThreadUnlock(&tlpwnd);
                ThreadUnlock(&tlpwndParent);
                return FALSE;
            }

            /*
             * Upon return from NCCALCSIZE:
             *
             * params.rgrc[0] = rcClientNew = New client rect
             * params.rgrc[1] = rcValidDst  = Destination valid rectangle
             * params.rgrc[2] = rcValidSrc  = Source valid rectangle
             */
            #undef rcWindowNew
            #undef rcWindowOld
            #undef rcClientOld

            #define rcClientNew params.rgrc[0]
            #define rcValidDst  params.rgrc[1]
            #define rcValidSrc  params.rgrc[2]

            /*
             * Calculate the distance the window contents are
             * moving. If 0 or an invalid value was returned
             * from the WM_NCCALCSIZE message, assume the
             * entire client area is valid and top-left aligned.
             */
            if (cmd < WVR_MINVALID || cmd > WVR_MAXVALID) {

                /*
                 * We don't need to copy rcValidSrc to rcClientOld,
                 * because it's already stored in rgrc[2].
                 *
                 * rcValidSrc = rcClientOld
                 */
                rcValidDst = rcClientNew;

                cmd = WVR_ALIGNTOP | WVR_ALIGNLEFT;
            }

            /*
             * Calculate the distance we'll be shifting bits...
             */
            if (TestWF(pwnd, WEFLAYOUTRTL)) {
                pcvr->dxBlt = rcValidDst.right - rcValidSrc.right;
            } else {
                pcvr->dxBlt = rcValidDst.left - rcValidSrc.left;
            }
            pcvr->dyBlt = rcValidDst.top - rcValidSrc.top;

            /*
             * Calculate new client rect size and position
             */
            pcvr->xClientNew = rcClientNew.left;
            pcvr->yClientNew = rcClientNew.top;

            pcvr->cxClientNew = rcClientNew.right - rcClientNew.left;
            pcvr->cyClientNew = rcClientNew.bottom - rcClientNew.top;

            /*
             * Figure out whether the client rectangle is moving or sizing,
             * and diddle the appropriate bit if not.
             */
            if (xClientOld != rcClientNew.left || yClientOld != rcClientNew.top)
                pcvr->pos.flags &= ~SWP_NOCLIENTMOVE;

            if (cxClientOld != pcvr->cxClientNew || cyClientOld != pcvr->cyClientNew) {
                pcvr->pos.flags &= ~SWP_NOCLIENTSIZE;
            }

            /*
             * If the caller doesn't want us to save any bits, then don't.
             */
            if (pcvr->pos.flags & SWP_NOCOPYBITS) {
AllInvalid:

                /*
                 * The entire window is invalid: Set the blt rectangle
                 * to empty, to ensure nothing gets bltted.
                 */
                SetRectEmpty(&pcvr->rcBlt);
                ThreadUnlock(&tlpwnd);
                continue;
            }

            /*
             * If we are just resizing this window without moving it and its parent
             * is mirrored then no need to copy any bits (i.e. empty pcvr->rcBlt).
             */
            if (fSetZeroDx) {
                goto AllInvalid;
            }

            /*
             * If this is a transparent window, be sure to invalidate
             * everything, because only some of the window's bits are
             * blittable.
             */
            if (TestWF(pwnd, WEFTRANSPARENT))
                goto AllInvalid;

            /*
             * If both client and window did not change size, the frame didn't
             * change, and the blt rectangle moved the same distance as the
             * rectangle, then the entire window area is valid.
             */
            if (((pcvr->pos.flags &
                    (SWP_NOSIZE | SWP_NOCLIENTSIZE | SWP_FRAMECHANGED))
                    == (SWP_NOSIZE | SWP_NOCLIENTSIZE)) &&
                    pcvr->dxBlt == (pcvr->pos.x - xWindowOld) &&
                    pcvr->dyBlt == (pcvr->pos.y - yWindowOld)) {

                goto AllValid;
            }

            /*
             * Now compute the valid blt rectangle.
             *
             * Check for horz or vert client size changes
             *
             * NOTE: Assumes WVR_REDRAW == WVR_HREDRAW | WVR_VREDRAW
             */
            if (cxClientOld != pcvr->cxClientNew) {

                if ((cmd & WVR_HREDRAW) || TestCF(pwnd, CFHREDRAW))
                    goto AllInvalid;
            }

            if (cyClientOld != pcvr->cyClientNew) {

                if ((cmd & WVR_VREDRAW) || TestCF(pwnd, CFVREDRAW))
                    goto AllInvalid;
            }

            cxSrc = rcValidSrc.right - rcValidSrc.left;
            cySrc = rcValidSrc.bottom - rcValidSrc.top;

            cxDst = rcValidDst.right - rcValidDst.left;
            cyDst = rcValidDst.bottom - rcValidDst.top;

            if ((!!(cmd & WVR_ALIGNRIGHT)) ^ (!!TestWF(pwnd, WEFLAYOUTRTL)))
                rcValidDst.left += ((TestWF(pwnd, WEFLAYOUTRTL) && (cxSrc > cxDst)) ? (cxSrc-cxDst) : (cxDst - cxSrc));

            if (cmd & WVR_ALIGNBOTTOM)
                rcValidDst.top += (cyDst - cySrc);

            /*
             * Superimpose the source on the destination, and intersect
             * the rectangles. This is done by looking at the
             * extent of the rectangles, and pinning as appropriate.
             */

            if (cxSrc < cxDst)
                rcValidDst.right = rcValidDst.left + cxSrc;

            if (cySrc < cyDst)
                rcValidDst.bottom = rcValidDst.top + cySrc;

            /*
             * Finally map the blt rectangle to screen coordinates.
             */
            pcvr->rcBlt = rcValidDst;
            if (pwndParent != PWNDDESKTOP(pwnd)) {

                OffsetRect(
                        &pcvr->rcBlt,
                        pwndParent->rcClient.left,
                        pwndParent->rcClient.top);
            }
        } else {       // if !SWP_NOSIZE or SWP_FRAMECHANGED

AllValid:

            /*
             * No client size change: Blt the entire window,
             * including the frame. Offset everything by
             * the distance the window rect changed.
             */
            if (pcvr->pos.flags & SWP_NOCOPYBITS) {
                SetRectEmpty(&pcvr->rcBlt);
            } else {
                pcvr->rcBlt.left   = pcvr->pos.x;
                pcvr->rcBlt.top    = pcvr->pos.y;

                if (pwndParent != PWNDDESKTOP(pwnd)) {
                    pcvr->rcBlt.left += pwndParent->rcClient.left;
                    pcvr->rcBlt.top += pwndParent->rcClient.top;
                }

                pcvr->rcBlt.right  = pcvr->rcBlt.left + pcvr->pos.cx;
                pcvr->rcBlt.bottom = pcvr->rcBlt.top + pcvr->pos.cy;
            }

            /*
             * Offset everything by the distance the window moved.
             */
            if (TestWF(pwnd, WEFLAYOUTRTL)) {
                pcvr->dxBlt = (pcvr->pos.x + pcvr->pos.cx) - (xWindowOld + cxWindowOld);
            } else {
                pcvr->dxBlt = pcvr->pos.x - xWindowOld;
            }

            pcvr->dyBlt = pcvr->pos.y - yWindowOld;

            /*
             * If we're moving, we need to set up the client.
             */
            if (!(pcvr->pos.flags & SWP_NOMOVE)) {
                pcvr->pos.flags &= ~SWP_NOCLIENTMOVE;

                pcvr->xClientNew = pwnd->rcClient.left + pcvr->dxBlt;
                pcvr->yClientNew = pwnd->rcClient.top + pcvr->dyBlt;
                if (pwndParent != PWNDDESKTOP(pwnd)) {
                    pcvr->xClientNew -= pwndParent->rcClient.left;
                    pcvr->yClientNew -= pwndParent->rcClient.top;
                }

                pcvr->cxClientNew = pwnd->rcClient.right - pwnd->rcClient.left;
                pcvr->cyClientNew = pwnd->rcClient.bottom - pwnd->rcClient.top;
            }
        }

        ThreadUnlock(&tlpwnd);

    }   // for (... pcvr ...)

    ThreadUnlock(&tlpwndParent);
    *phwndNewActive = hwndNewActive;

    return TRUE;
}

/***************************************************************************\
* GetLastTopMostWindow
*
* Returns the last topmost window in the window list. Returns NULL if no
* topmost windows. Used so that we can fill in the pwndInsertAfter field
* in various SWP calls.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

PWND GetLastTopMostWindow(VOID)
{
    PWND     pwndT;
    PDESKTOP pdesk = PtiCurrent()->rpdesk;

    if (pdesk == NULL)
        return NULL;

    pwndT = pdesk->pDeskInfo->spwnd->spwndChild;

    if (!pwndT || !TestWF(pwndT, WEFTOPMOST))
        return NULL;

    while (pwndT->spwndNext) {

        if (!TestWF(pwndT->spwndNext, WEFTOPMOST))
            break;

        pwndT = pwndT->spwndNext;
    }

    return pwndT;
}

/***************************************************************************\
* SetWindowPos (API)
*
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxSetWindowPos(
    PWND pwnd,
    PWND pwndInsertAfter,
    int  x,
    int  y,
    int  cx,
    int  cy,
    UINT flags)
{
    PSMWP psmwp;
    BOOL  fInval = FALSE;

#if DBG
    CheckLock(pwnd);

    switch((ULONG_PTR)pwndInsertAfter) {
    case 0x0000FFFF:
    case (ULONG_PTR)HWND_TOPMOST:
    case (ULONG_PTR)HWND_NOTOPMOST:
    case (ULONG_PTR)HWND_TOP:
    case (ULONG_PTR)HWND_BOTTOM:
        break;

    default:
        CheckLock(pwndInsertAfter);
        break;
    }
#endif

    /*
     * BACKWARD COMPATIBILITY HACKS
     *
     * Hack 1: For Win 3.0 and below, SetWindowPos() must ignore the
     * move and size flags if SWP_SHOWWINDOW or SWP_HIDEWINDOW
     * is specified. KnowledgePro is one application that depends on
     * this behavior for the positioning of its MDI icons.
     *
     * Hack 2: In 3.0, if SetWindowPos() is called with SWP_SHOWWINDOW
     * and the window is already visible, then the window was
     * completely invalidated anyway. So, we do that here too.
     *
     * NOTE: The placement of the invalidation AFTER the EndDeferWindowPos()
     * call means that if the guy is Z-ordering and showing a 3.0 window,
     * it may flash, because EndDefer calls DoSyncPaint, and we invalidate
     * again after that. Could be fixed with some major hackery in EndDefer,
     * and it's probably not worth the trouble.
     */
    if (flags & (SWP_SHOWWINDOW | SWP_HIDEWINDOW)) {

        if (!TestWF(pwnd, WFWIN31COMPAT)) {

            flags |= SWP_NOMOVE | SWP_NOSIZE;
            if ((flags & SWP_SHOWWINDOW) && TestWF(pwnd, WFVISIBLE))
                fInval = TRUE;
        }
        if (flags & SWP_SHOWWINDOW) {
            SetWF(pwnd, WEFGHOSTMAKEVISIBLE);
        } else {
            ClrWF(pwnd, WEFGHOSTMAKEVISIBLE);
        }
    }

    /*
     * MULTIMONITOR HACKS
     *
     * if a app is centering or cliping a hidden owned window
     * to the primary monitor we should center the window to the owner
     *
     * this makes apps that center/position their own dialogs
     * work when the app is on a secondary monitor.
     */
    if (    !TestWF(pwnd, WFWIN50COMPAT) &&
            gpDispInfo->cMonitors > 1 &&
            !(flags & SWP_NOMOVE) &&
            !TestWF(pwnd, WFCHILD) &&
            !TestWF(pwnd, WFVISIBLE) &&
            (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION)) &&
            pwnd->spwndOwner &&
            TestWF(pwnd->spwndOwner, WFVISIBLE) &&
            !IsRectEmpty(&pwnd->spwndOwner->rcWindow)) {

        FixBogusSWP(pwnd, &x, &y, cx, cy, flags);

    }

    if (!(psmwp = InternalBeginDeferWindowPos(1)) ||
        !(psmwp = _DeferWindowPos(psmwp,
                                  pwnd,
                                  pwndInsertAfter,
                                  x,
                                  y,
                                  cx,
                                  cy,
                                  flags))) {

        return FALSE;
    }


    if (xxxEndDeferWindowPosEx(psmwp, flags & SWP_ASYNCWINDOWPOS)) {

        if (fInval) {
            xxxRedrawWindow(
                    pwnd,
                    NULL,
                    NULL,
                    RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
        }

        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* xxxSwpActivate
*
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxSwpActivate(
    PWND pwndNewActive)
{
    PTHREADINFO pti;

    CheckLock(pwndNewActive);

    if (pwndNewActive == NULL)
        return FALSE;

    pti = PtiCurrent();

    if (TestwndChild(pwndNewActive)) {

        xxxSendMessage(pwndNewActive, WM_CHILDACTIVATE, 0, 0L);

    } else if (pti->pq->spwndActive != pwndNewActive) {

        /*
         * Remember if this window wants to be active. We are either setting
         * our own window active (most likely), or setting a window of
         * another thread active on purpose. If so that means this thread is
         * controlling this window and will probably want to set itself
         * active and foreground really soon (for example, a setup
         * program doing dde to progman). Allow this thread and the target
         * thread to do forground activates.
         *
         * Let's stop doing this for NT5 in an effort to close the number
         * of ways applications can force a foreground change. This is not
         * quite needed anyway, because:
         * -If the current thread is already in the foreground, then it doesn't need
         *  the TIF_ALLOWFOREGROUNDACTIVATE to make a foreground change.
         * -Since FRemoveForegroundActive removes this bit, the current thread
         *  will lose it anyway during the xxxActivateWindow call.
         * -But xxxActivateWindow will set it back anyway because we're activating
         *  a window from a different queue.
         * -The destination window/thread will take the foreground
         *  as a result of the xxxActivateWindow call, hence it doesn't
         *  need the bit on (if you're in the foreground, you don't need it).
         */
         #ifdef DONTDOTHISANYMORE
         if ((pti->pq == gpqForeground) && (pti != GETPTI(pwndNewActive))) {
            /*
             * Allow foreground activate on the source and dest.
             */
            pti->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxSwpActivate set TIF %#p", pti);
            GETPTI(pwndNewActive)->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxSwpActivate set TIF %#p", GETPTI(pwndNewActive));
         }
         #endif

        if (!xxxActivateWindow(pwndNewActive, AW_USE))
            return FALSE;

        /*
         * HACK ALERT: We set these bits to prevent
         * the frames from redrawing themselves in
         * the later call to DoSyncPaint().
         *
         * Prevent these captions from being repainted during
         * the DoSyncPaint(). (bobgu 6/10/87)
         */
        if (pti->pq->spwndActive != NULL)
            SetWF(pti->pq->spwndActive, WFNONCPAINT);

        if (pti->pq->spwndActivePrev != NULL)
            SetWF(pti->pq->spwndActivePrev, WFNONCPAINT);

        return TRUE;    // Indicate that we diddled these bits
    }

    return FALSE;
}

/***************************************************************************\
* xxxImeWindowPosChanged
*
* Send IME private message to update the composition window position
*
\***************************************************************************/

VOID xxxImeWindowPosChanged(
    PSMWP psmwp)
{
    PBWL    pbwl;
    PHWND   phwnd;
    PWND    pwndDesktop = _GetDesktopWindow();
    PTHREADINFO ptiCurrent = PtiCurrent();

    if (pwndDesktop == NULL) {
        return;
    }

    pbwl = BuildHwndList(pwndDesktop->spwndChild, BWL_ENUMLIST, ptiCurrent);
    if (pbwl == NULL) {
        return;
    }

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; ++phwnd) {
        PWND pwndIme = ValidateHwnd(*phwnd);

        TAGMSG1(DBGTAG_IMM, "ImePosC: pwndIme=%p", pwndIme);

        /*
         * If the thread is going away, just bail out.
         */
        if (ptiCurrent->TIF_flags & TIF_INCLEANUP) {
            break;
        }

        if (pwndIme && pwndIme->head.pti == ptiCurrent &&
                pwndIme->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {
            HWND hwnd;
            PWND pwnd;

            TAGMSG1(DBGTAG_IMM, "ImePosC: OK, pwndIme=%p is one of us.", pwndIme);

            try {
                hwnd = ProbeAndReadStructure(((PIMEWND)pwndIme)->pimeui, IMEUI).hwndIMC;
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                continue;
            }

            pwnd = RevalidateHwnd(hwnd);

            TAGMSG2(DBGTAG_IMM, "ImePosC: hwndImc=%p and its pwnd=%p", hwnd, pwnd);

            /*
             * Search upward
             */
            while (pwnd && pwnd != pwndDesktop) {
                PCVR    pcvr;
                int     ccvr;

                hwnd = HWq(pwnd);
                for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {
                    if (hwnd == pcvr->pos.hwnd) {
                        TAGMSG1(DBGTAG_IMM, "ImePosC: pwnd=%p in the SWP list.", pwnd);
                        /*
                         * Send this private message if the window's size changes
                         * or the window moves. I.e.
                         * when (flag & (SWP_NOSIZE | SWP_NOMOVE)) != (SWP_NOSIZE | SWP_NOMOVE).
                         */
                        if (~pcvr->pos.flags & (SWP_NOSIZE | SWP_NOMOVE)) {
                            TL tl;

                            TAGMSG1(DBGTAG_IMM, "ImePosC: pwnd=%p is gonna move or resize.", pwnd);

                            ThreadLockAlwaysWithPti(ptiCurrent, pwndIme, &tl);
                            xxxSendMessage(pwndIme, WM_IME_SYSTEM, IMS_WINDOWPOS, 0);
                            ThreadUnlock(&tl);
                        }
                        break;
                    }
                }

                if (ccvr >= 0) {
                    break;
                }

                pwnd = pwnd->spwndParent;
            }
        }
    }

    FreeHwndList(pbwl);
}


/***************************************************************************\
* xxxSendChangedMsgs
*
* Send WM_WINDOWPOSCHANGED messages as needed
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxSendChangedMsgs(
    PSMWP psmwp)
{
    PWND pwnd;
    PCVR pcvr;
    int  ccvr;
    TL   tlpwnd;

    /*
     * Send all the messages that need to be sent...
     */
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        if (pcvr->pos.hwnd == NULL)
            continue;

        /*
         * If the window's state didn't change, don't send the message.
         */
        if ((pcvr->pos.flags & SWP_CHANGEMASK) == SWP_NOCHANGE)
            continue;

        if ((pwnd = RevalidateHwnd(pcvr->pos.hwnd)) == NULL) {
            RIPMSG0(RIP_WARNING, "xxxSendChangedMsgs: window went away in middle");
            pcvr->pos.flags = SWP_NOREDRAW | SWP_NOCHANGE;
            pcvr->pos.hwnd  = NULL;
            continue;
        }

        if (!IsStillWindowC(pcvr->pos.hwndInsertAfter)) {
            pcvr->pos.hwnd = NULL;
            continue;
        }

        /*
         * Send the WM_WINDOWPOSCHANGED message...
         *
         * Make a frame copy of the WINDOWPOS, because the pcvr
         * info may get reused if SetWindowPos()
         * is called by the message handler: see the comments in
         * AllocSmwp().
         *
         * WM_SIZE, WM_MOVE and WM_SHOW messages are sent by the
         * DefWindowProc() WM_WINDOWPOSCHANGED message processing.
         *
         * Note: It's okay to destroy the window while processing this
         * message, since this is the last call made by the window manager
         * with the window handle before returning from SetWindowPos().
         * This also means we don't have to revalidate the pwnd.
         */
        ThreadLockAlways(pwnd, &tlpwnd);

        if (TestCF(pwnd, CFDROPSHADOW) && !(GetAppCompatFlags2ForPti(GETPTI(pwnd), VERMAX) & GACF2_NOSHADOW)) {
            if (pcvr->pos.flags & SWP_HIDEWINDOW) {
                xxxRemoveShadow(pwnd);
            } else if (pcvr->pos.flags & SWP_SHOWWINDOW) {
                BOOL fAddShadow = TRUE;
                /*
                 * We don't want to add a shadow to menus that are being slid
                 * out because they don't use AnimateWindow and do not create
                 * a window rgn to clip inside during the animation. This means
                 * that even if we keep the shadow in sync with the menu, it
                 * won't be visible because it is actually z-ordered below the
                 * menu.
                 */

                if ((GETFNID(pwnd) == FNID_MENU) && (!TestALPHA(MENUFADE)) && TestEffectUP(MENUANIMATION)) {
                    fAddShadow = FALSE;
                }

                if (fAddShadow) {
                    xxxAddShadow(pwnd);
                }
            } else {

                if (!(pcvr->pos.flags & SWP_NOSIZE) ||
                        (pcvr->pos.flags & SWP_FRAMECHANGED)) {
                    UpdateShadowShape(pwnd);
                } else if (!(pcvr->pos.flags & SWP_NOMOVE)) {
                    MoveShadow(pwnd);
                }

                if (!(pcvr->pos.flags & SWP_NOZORDER)) {
                    xxxUpdateShadowZorder(pwnd);
                }
            }
        }

        xxxSendMessage(pwnd, WM_WINDOWPOSCHANGED, 0, (LPARAM)&pcvr->pos);

        /*
         * Only send a shape change when moving/sizing/minimizing/restoring/
         * maximizing (or framechange for NetMeeting to detect SetWindowRgn)
         */
        if (!(pcvr->pos.flags & SWP_NOCLIENTMOVE) ||
            !(pcvr->pos.flags & SWP_NOCLIENTSIZE) ||
             (pcvr->pos.flags & SWP_STATECHANGE) ||
             (pcvr->pos.flags & SWP_FRAMECHANGED)) {
            xxxWindowEvent(EVENT_OBJECT_LOCATIONCHANGE, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
        }
        ThreadUnlock(&tlpwnd);
    }   // for (... pcvr ...)

    if (IS_IME_ENABLED()) {
        xxxImeWindowPosChanged(psmwp);
    }
}

/***************************************************************************\
* AsyncWindowPos
*
* This functions pulls from the passed-in SMWP all windows not owned by the
* current thread and passes them off to their owners to be handled. This
* eliminates synchronization where thread B won't get a chance to paint
* until thread A has completed painting (or at least returned from handling
* painting-related messages). Such synchronizations are bad because they
* can cause threads of unrelated process to hang each other.
*
* History:
* 09-10-91 darrinm      Created.
\***************************************************************************/
VOID AsyncWindowPos(
    PSMWP psmwp)
{
    BOOL        fFinished;
    PCVR        pcvrFirst;
    PCVR        pcvr;
    PCVR        pcvrT;
    int         ccvrRemaining;
    int         ccvr;
    int         chwnd;
    PTHREADINFO ptiT;
    PTHREADINFO ptiCurrent;
    PSMWP       psmwpNew;

    pcvrFirst = psmwp->acvr;
    ccvrRemaining = psmwp->ccvr;

    ptiCurrent = PtiCurrent();

    while (TRUE) {

        fFinished = TRUE;

        /*
         * Loop through all windows in the SMWP list searching for windows
         * owned by other threads. Return if none are found.
         */
        for (; ccvrRemaining != 0; pcvrFirst++, ccvrRemaining--) {

            if (pcvrFirst->pos.hwnd == NULL)
                continue;

            ptiT = pcvrFirst->pti;
            if (ptiT->pq != ptiCurrent->pq) {
                fFinished = FALSE;
                break;
            }
        }

        if (fFinished) {
            return;
        }

        /*
         * We've found a window of another thread. Count how many other
         * windows in the list are owned by the same thread so we can
         * allocate a CVR array for them.
         */
        chwnd = 0;

        for (pcvr = pcvrFirst, ccvr = ccvrRemaining; --ccvr >= 0; pcvr++) {

            if (pcvr->pos.hwnd == NULL)
                continue;

            if (pcvr->pti->pq == ptiT->pq)
                chwnd++;
        }

        /*
         * Allocate temp SMWP/CVR structure to be passed to the other thread.
         */
        psmwpNew = (PSMWP)UserAllocPool(sizeof(SMWP) + (sizeof(CVR) * chwnd),
                                        TAG_SWP);

        /*
         * Even if we can't allocate memory to pass the SMWP to another
         * thread we still need to remove its windows from the current list.
         */
        if (psmwpNew == NULL) {

            for (pcvr = pcvrFirst; chwnd != 0; pcvr++) {

                if (pcvr->pti->pq == ptiT->pq) {
                    pcvr->pos.hwnd = NULL;
                    chwnd--;
                }
            }

            continue;
        }

        psmwpNew->ccvr = chwnd;
        psmwpNew->acvr = (PCVR)((PBYTE)psmwpNew + sizeof(SMWP));

        for (pcvr = pcvrFirst, pcvrT = psmwpNew->acvr; chwnd != 0; pcvr++) {

            if (pcvr->pos.hwnd == NULL)
                continue;

            /*
             * Copy the appropriate CVR structs into our temp array.
             */
            if (pcvr->pti->pq == ptiT->pq) {

                *pcvrT++ = *pcvr;
                chwnd--;

                /*
                 * Remove this window from the list of windows to be handled
                 * by the current thread.
                 */
                pcvr->pos.hwnd = NULL;
            }
        }

        /*
         * This lets the other thread know it needs to do some windowposing.
         * The other thread is responsible for freeing the temp SMWP/CVR array.
         */
        if (!PostEventMessage(ptiT, ptiT->pq, QEVENT_SETWINDOWPOS, NULL, 0,
                (WPARAM)psmwpNew, (LPARAM)ptiT)) {
            // IANJA RIP only to catch what was previously a bug: psmwpNew not freed
            RIPMSG1(RIP_WARNING, "PostEventMessage swp to pti %#p failed", ptiT);
            UserFreePool(psmwpNew);
        }
    }

}

/***************************************************************************\
* xxxProcessSetWindowPosEvent
*
* This function is called from xxxProcessEvent (QUEUE.C) to respond to
* posted QEVENT_SETWINDOWPOS events which originate at the AsyncWindowPos
* function above.
*
* History:
* 10-Sep-1991 DarrinM   Created.
\***************************************************************************/

VOID xxxProcessSetWindowPosEvent(
    PSMWP psmwpT)
{
    PSMWP psmwp;

    /*
     * Create a bonafide SMWP/CVR array that xxxEndDeferWindowPos can use
     * and later free.
     */
    if ((psmwp = InternalBeginDeferWindowPos(psmwpT->ccvr)) == NULL) {
        UserFreePool(psmwpT);
        return;
    }

    /*
     * Copy the contents of the temp SMWP/CVR array into the real one.
     */
    RtlCopyMemory(psmwp->acvr, psmwpT->acvr, sizeof(CVR) * psmwpT->ccvr);
    psmwp->ccvr = psmwpT->ccvr;

    /*
     * Complete the MultWindowPos operation now that we're on the correct
     * context.
     */
    xxxEndDeferWindowPosEx(psmwp, FALSE);

    /*
     * Free the temp SMWP/CVR array.
     */
    UserFreePool(psmwpT);
}

#define SWP_BOZO ( SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE )

/***************************************************************************\
* DBGValidateSibblingZOrder
*
* History:
* 04/01/98 GerardoB Created
\***************************************************************************/
#if DBG
VOID DBGValidateSibblingZOrder(
    PWND pwndParent)
{
    PWND pwndT = pwndParent->spwndChild;
    /*
     * Check that the sibbling list looks OK right now
     * We don't really care about the z-order of message windows.
     */
    if ((pwndT != NULL) && (pwndParent != PWNDMESSAGE(pwndParent))) {
        BOOL fFoundNonTopMost = !TestWF(pwndT, WEFTOPMOST);
        while (pwndT != NULL) {
            if (TestWF(pwndT, WEFTOPMOST)) {
                UserAssert(!fFoundNonTopMost);
            } else {
                fFoundNonTopMost = TRUE;
            }
            pwndT = pwndT->spwndNext;
        }
    }
}
#else
#define DBGValidateSibblingZOrder(pwndParent)
#endif // DBG

/***************************************************************************\
* zzzChangeStates
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID zzzChangeStates(
    PWND     pwndParent,
    PSMWP    psmwp)
{
    int  ccvr;
    PCVR pcvr;
    PWND pwnd;
    TL tlpwnd;
    TL tlpwndParent;
    int czorder = 0;

    BEGINATOMICCHECK();
    ThreadLockAlways(pwndParent, &tlpwndParent);

    /*
     * Check that the sibbling list looks OK right now
     *
     * Here's the reason why this DBG code is commented out:
     * Owned windows are always expected to be on top of the owner.
     * However, an app can call SetWindowPos and insert the ownee after
     * the owner. IME somehow does this too.
     * This causes us to have A to be inserted after B and later in the
     * windowpos array, B to be inserted somewhere else. Hence, A won't be in the
     * expected position, because B will be moved after A is inserted.
     * In other words, a window in hwndInsertAfter must not appear later
     * as a hwnd to be z-ordered. Ownees below owners cause this situation.
     */
    // DBGValidateSibblingZOrder(pwndParent);


    /*
     * Now change the window states
     */
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        if (pcvr->pos.hwnd == NULL)
            continue;

        UserAssert(0 == (pcvr->pos.flags & SWP_NOTIFYALL));

        pwnd = RevalidateHwnd(pcvr->pos.hwnd);

        if ((pwnd == NULL) || !IsStillWindowC(pcvr->pos.hwndInsertAfter)) {
            RIPMSG0(RIP_WARNING, "zzzChangeStates: Window went away in middle");
            pcvr->pos.flags = SWP_NOREDRAW | SWP_NOCHANGE;
            pcvr->pos.hwnd  = NULL;
        }

#if DBG
        /*
         * This can happen when we get re-entered during a callback or mulitple
         * threads are z-ordering the same window. The tray does stuff like this.
         * We would need to keep the toggle state in the windowpos structure to
         * have each call have its own state.
         */
        if (TestWF(pwnd, WFTOGGLETOPMOST) && (pcvr->pos.flags & SWP_NOZORDER)) {
            RIPMSG0(RIP_WARNING, "zzzChangeState: WFTOGGLETOPMOST should not be set");
        }
#endif

        /*
         * Check to se if there is any state to change. If not, just
         * continue.
         */
        if ((pcvr->pos.flags & SWP_CHANGEMASK) == SWP_NOCHANGE) {
            pcvr->pos.flags |= SWP_NOREDRAW;
            continue;
        }

        /*
         * Change the window region if needed.
         *
         * Before we do anything, check to see if we're only Z-ordering.
         * If so, then check to see if we're already in the right place,
         * and if so, clear the ZORDER flag.
         *
         * We have to make this test in the state-change loop if previous
         * windows in the WINDOWPOS list were Z-ordered, since the test depends
         * on any ordering that may have happened previously.
         *
         * We don't bother to do this redundancy check if there are
         * other bits set, because the amount of time saved in that
         * case is about as much as the amount of time it takes to
         * test for redundancy.
         */
        if (((pcvr->pos.flags & SWP_CHANGEMASK) ==
             (SWP_NOCHANGE & ~SWP_NOZORDER))) {

            /*
             * If the window's Z order won't be changing, then
             * we can clear the ZORDER bit and set NOREDRAW.
             */
            if ((!TestWF(pwnd, WFTOGGLETOPMOST)) && ValidateZorder(pcvr)) {

                /*
                 * The window's already in the right place:
                 * Set SWP_NOZORDER bit, set SWP_NOREDRAW,
                 * and destroy the visrgn that we created earlier.
                 */
                pcvr->pos.flags |= SWP_NOZORDER | SWP_NOREDRAW;

                if (pcvr->hrgnVisOld) {
                    GreDeleteObject(pcvr->hrgnVisOld);
                    pcvr->hrgnVisOld = NULL;
                }
                continue;
            }
        }

        /*
         * Change the window state, as appropriate...
         */
        if ((pcvr->pos.flags &
            (SWP_NOMOVE | SWP_NOSIZE | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)) !=
            (SWP_NOMOVE | SWP_NOSIZE | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)) {

            PCARET pcaret = &PtiCurrent()->pq->caret;
            BOOL fRecreateRedirectionBitmap = FALSE;
            int dxWindow, dyWindow, xOldWindow, yOldWindow;

            if (TestWF(pwnd, WEFPREDIRECTED)) {
                int cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
                int cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

                if (cx != pcvr->pos.cx || cy != pcvr->pos.cy) {
                    fRecreateRedirectionBitmap = TRUE;
                }
            }

            /*
             * Set up the new window and client rectangles.
             */
            xOldWindow = pwnd->rcWindow.left;
            yOldWindow = pwnd->rcWindow.top;
            pwnd->rcWindow.left   = pcvr->pos.x;
            pwnd->rcWindow.top    = pcvr->pos.y;
            if (pwndParent != PWNDDESKTOP(pwnd)) {
                pwnd->rcWindow.left += pwndParent->rcClient.left;
                pwnd->rcWindow.top += pwndParent->rcClient.top;
            }
            dxWindow = pwnd->rcWindow.left - xOldWindow;
            dyWindow = pwnd->rcWindow.top - yOldWindow;

            pwnd->rcWindow.right  = pwnd->rcWindow.left + pcvr->pos.cx;
            pwnd->rcWindow.bottom = pwnd->rcWindow.top + pcvr->pos.cy;

            if (pwnd->rcWindow.right < pwnd->rcWindow.left) {
                RIPMSG1(RIP_WARNING, "SWP: cx changed for pwnd %#p", pwnd);
                pwnd->rcWindow.right = pwnd->rcWindow.left;
            }

            if (pwnd->rcWindow.bottom < pwnd->rcWindow.top) {
                RIPMSG1(RIP_WARNING, "SWP: cy changed for pwnd %#p", pwnd);
                pwnd->rcWindow.bottom = pwnd->rcWindow.top;
            }

            /*
             * If the client moved relative to its parent,
             * offset the caret by the amount that rcBlt moved
             * relative to the client rect.
             */
            if (pwnd == pcaret->spwnd) {

                /*
                 * Calculate the distance the contents of the client area
                 * is moving, in client-relative coordinates.
                 *
                 * Calculates dBlt + (old position - new position)
                 */
                int dx = pcvr->dxBlt + pwnd->rcClient.left - pcvr->xClientNew;
                int dy = pcvr->dyBlt + pwnd->rcClient.top - pcvr->yClientNew;

                if (pwndParent != PWNDDESKTOP(pwnd))
                {
                    dx -= pwndParent->rcClient.left;
                    dy -= pwndParent->rcClient.top;
                }

                if ((dx | dy) != 0) {
                    pcaret->x += dx;
                    pcaret->y += dy;
                }
            }

            /*
             * Set up the new client rect
             * coordinates provided.
             */
            pwnd->rcClient.left   = pcvr->xClientNew;
            pwnd->rcClient.top    = pcvr->yClientNew;
            if (pwndParent != PWNDDESKTOP(pwnd))
            {
                pwnd->rcClient.left += pwndParent->rcClient.left;
                pwnd->rcClient.top += pwndParent->rcClient.top;
            }

            pwnd->rcClient.right  = pwnd->rcClient.left + pcvr->cxClientNew;
            pwnd->rcClient.bottom = pwnd->rcClient.top + pcvr->cyClientNew;

            /*
             * If the window becomes smaller than the monitor, the system
             * allows it to be moved (see SetSysMenu) and so we must remove
             * the monitor region.
             */
            if (TestWF(pwnd, WFMAXFAKEREGIONAL) && IsSmallerThanScreen(pwnd)) {
                SelectWindowRgn(pwnd, NULL);
            }

            /*
             * If the layered window is resizing, try to resize the
             * redirection bitmap associated with it.
             */
            if (fRecreateRedirectionBitmap) {
                RecreateRedirectionBitmap(pwnd);
            }


            if ((dxWindow != 0) || (dyWindow != 0)) {
                if ((pwnd->hrgnClip > HRGN_FULL) && (!TestWF(pwnd, WFMAXFAKEREGIONAL))) {
#ifdef LATER
                    /*
                     * LATER: The original USER code was offsetting the window
                     * region by dxBlt and dyBlt. This had problems for using
                     * window regions when hiding and showing the menus, so
                     * dxWindow and dyWindow were added (correctly). However,
                     * we should be aware of all of the places these values
                     * don't agree to make sure that we don't introduce
                     * regressions. Unfortunately in Whistler, we were
                     * periodically getting too much spew, and didn't have time
                     * to fully track down each of these cases.
                     */


                    /*
                     * Change position of window region, if it has one
                     * and it isn't a monitor region for a maximized window
                     */
                    if ((dxWindow != pcvr->dxBlt) || (dyWindow != pcvr->dyBlt)) {
                        /*
                         * If not moving by the same amount as the PCVR indicates,
                         * give a warning. This is normal when calling xxxSetMenu(),
                         * but we need to know if it is called in other situations.
                         */
                        RIPMSG1(RIP_WARNING, "SWP: (dxWindow != dxBlt) || (dyWindow != dyBlt) for pwnd %#p", pwnd);
                    }
#endif



                    GreOffsetRgn(pwnd->hrgnClip, dxWindow, dyWindow);
                }
            }


            /*
             * Offset the absolute positions of the window's update region,
             * and the position and update regions of its children.
             */
            if ((pcvr->dxBlt | pcvr->dyBlt) != 0) {
                if (pwnd->hrgnUpdate > HRGN_FULL) {
                    GreOffsetRgn(pwnd->hrgnUpdate, pcvr->dxBlt, pcvr->dyBlt);
                }
                OffsetChildren(pwnd, pcvr->dxBlt, pcvr->dyBlt, NULL);

                /*
                 * Change the position of the sprite associated with
                 * this window.
                 */
                if (TestWF(pwnd, WEFLAYERED)) {
                    POINT ptPos = {pcvr->pos.x, pcvr->pos.y};

                    GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL,
                            &ptPos, NULL, NULL, NULL, 0, NULL, 0, NULL);
                }
            }
        }

        /*
         * Change the Z order if the flag is set. Revalidate
         * hwndInsertAfter to make sure that it is still valid
         */
        if (!(pcvr->pos.flags & SWP_NOZORDER)) {

            if (ValidateWindowPos(pcvr, pwndParent)) {

                UnlinkWindow(pwnd, pwndParent);

                LinkWindow(pwnd,
                           PWInsertAfter(pcvr->pos.hwndInsertAfter),
                           pwndParent);
                czorder++;

                /*
                 * HACK ALERT MERGE
                 *
                 * ValidateZOrder() depends on rational, consistent setting of the
                 * WEFTOPMOST bit in order for it to work properly. What this means
                 * is that we can't set or clear these bits ahead of time based on
                 * where the window is moving to: instead we have to change the bit
                 * after we've moved it. Enter the WFTOGGLETOPMOST bit: That bit
                 * is set in ZOrderByOwner() based on what the topmost bit will
                 * eventually be set to. To maintain a consistent state, we make
                 * any changes AFTER the window has been Z-ordered.
                 */
                if (TestWF(pwnd, WFTOGGLETOPMOST)) {
                    PBYTE pb;

                    ClrWF(pwnd, WFTOGGLETOPMOST);
                    pb = ((BYTE *)&pwnd->state);
                    pb[HIBYTE(WEFTOPMOST)] ^= LOBYTE(WEFTOPMOST);
                }
            } else {
                pcvr->pos.flags |= SWP_NOZORDER;
                ClrWF(pwnd, WFTOGGLETOPMOST);
            }
        }


        /*
         * Handle SWP_HIDEWINDOW and SWP_SHOWWINDOW, by clearing or setting
         * the WS_VISIBLE bit.
         */
        UserAssert(pwndParent != NULL);
        ThreadLockAlways(pwnd, &tlpwnd);
        if (pcvr->pos.flags & SWP_SHOWWINDOW) {

            /*
             * Window is showing. If this app is still in startup mode,
             * (still starting), give the the app starting cursor 5 more
             * seconds.
             */
            if (GETPTI(pwnd)->ppi->W32PF_Flags & W32PF_APPSTARTING)
                zzzCalcStartCursorHide((PW32PROCESS)GETPTI(pwnd)->ppi, 5000);

            /*
             * Set the WS_VISIBLE bit.
             */
            SetVisible(pwnd, SV_SET);

            zzzWindowEvent(EVENT_OBJECT_SHOW, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, WEF_USEPWNDTHREAD);

            if (IsTrayWindow(pwnd)) {

#ifdef HUNGAPP_GHOSTING
                if((GETFNID(pwnd) == FNID_GHOST)) {
                    if(TestWF(pwnd, WFFRAMEON)) {
                        psmwp->bShellNotify = TRUE;
                        pcvr->pos.flags |= SWP_NOTIFYACTIVATE;
                    }
                }
                else
#endif  // HUNGAPP_GHOSTING
                {
                    psmwp->bShellNotify = TRUE;
                    pcvr->pos.flags |= TestWF(pwnd, WFFRAMEON) ? SWP_NOTIFYACTIVATE|SWP_NOTIFYCREATE: SWP_NOTIFYCREATE;
                }
            } else if (TestWF(pwnd, WFFULLSCREEN)) {
                /*
                 * Wake up the tray so it can notice that there is now
                 * a fullscreen visible window. This deals with bugs
                 * 32164, 141563, and 150217.
                 */
                psmwp->bShellNotify = TRUE;
                pcvr->pos.flags |= SWP_NOTIFYFS;
            }

            /*
             * If we're redrawing, create an SPB for this window if
             * needed.
             */
            if (!(pcvr->pos.flags & SWP_NOREDRAW) ||
                    (pcvr->pos.flags & SWP_CREATESPB)) {

                /*
                 * ONLY create an SPB if this window happens to be
                 * on TOP of all others. NOTE: We could optimize this by
                 * passing in the new vis rgn to CreateSpb() so that the
                 * non-visible part of the window is automatically
                 * invalid in the SPB.
                 */
                /*
                 * Make sure this window's desktop is on top !
                 */
                if (TestCF(pwnd, CFSAVEBITS) &&
                        pwnd->head.rpdesk == grpdeskRitInput) {

                    /*
                     * If this window is the topmost VISIBLE window,
                     * then we can create an SPB.
                     */
                    PWND pwndT;
                    RECT rcT;

                    for (pwndT = pwnd->spwndParent->spwndChild ;
                         pwndT;
                         pwndT = pwndT->spwndNext) {

                        if (pwndT == pwnd) {
                            CreateSpb(pwnd, FALSE, gpDispInfo->hdcScreen);
                            break;
                        }

                        if (TestWF(pwndT, WFVISIBLE)) {

                            /*
                             * Does this window intersect the SAVEBITS
                             * window at all?  If so, bail out.
                             */
                            if (IntersectRect(&rcT,
                                              &pwnd->rcWindow,
                                              &pwndT->rcWindow)) {
                                break;
                            }
                        }
                    }
                }
            }

        } else if (pcvr->pos.flags & SWP_HIDEWINDOW) {

            /*
             * for people like MS-Access 2.0 who SetWindowPos( SWP_BOZO
             * and blow away themselves on the shell, then lets
             * just ignore their plea to be removed from the tray
             */
            if (((pcvr->pos.flags & SWP_BOZO ) != SWP_BOZO) &&
                IsTrayWindow(pwnd)
#ifdef HUNGAPP_GHOSTING
                && (GETFNID(pwnd) != FNID_GHOST)
#endif // HUNGAPP_GHOSTING
                ) {
                psmwp->bShellNotify = TRUE;
                pcvr->pos.flags |= SWP_NOTIFYDESTROY;
            }

            /*
             * Clear the WS_VISIBLE bit.
             */
            SetVisible(pwnd, SV_UNSET | SV_CLRFTRUEVIS);

            zzzWindowEvent(EVENT_OBJECT_HIDE, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
        }

        /*
         * BACKWARD COMPATIBILITY HACK
         *
         * Under 3.0, window frames were always redrawn, even if
         * SWP_NOREDRAW was specified. If we've gotten this far
         * and we're visible, and SWP_NOREDRAW was specified, set
         * the WFSENDNCPAINT bit.
         *
         * Apps such as ABC Flowcharter and 123W assume this.
         * Typical offending code is MoveWindow(pwnd, ..., FALSE);
         * followed by InvalidateRect(pwnd, NULL, TRUE);
         */
        if (TestWF(pwnd, WFVISIBLE)) {
            if ((pcvr->pos.flags & SWP_STATECHANGE) ||
                (!TestWF(pwnd, WFWIN31COMPAT) && (pcvr->pos.flags & SWP_NOREDRAW))) {

                SetWF(pwnd, WFSENDNCPAINT);
            }
        }

        /*
         * If this window has a clipping region set it now
         */
        if (pcvr->hrgnClip != NULL) {
            SelectWindowRgn(pwnd, pcvr->hrgnClip);
        }
        ThreadUnlock(&tlpwnd);
    }

    /*
     * Check that the sibbling list looks OK now that we're done
     */
  //  DBGValidateSibblingZOrder(pwndParent);

    if (czorder) {
        zzzWindowEvent(EVENT_OBJECT_REORDER, pwndParent, OBJID_CLIENT, INDEXID_CONTAINER, 0);
    }

    ThreadUnlock(&tlpwndParent);

    ENDATOMICCHECK();
}

/***************************************************************************\
* SwpCalcVisRgn
*
* This routine calculates a non-clipchildren visrgn for pwnd into hrgn.
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL SwpCalcVisRgn(
    PWND pwnd,
    HRGN hrgn)
{
    /*
     * If this window is invisible, then
     * the visrgn will be empty, so return FALSE.
     */
    if (!TestWF(pwnd, WFVISIBLE))
        return FALSE;

    /*
     * Otherwise do it the hard way...
     */
    return CalcVisRgn(&hrgn,
                      pwnd,
                      pwnd,
                      (TestWF(pwnd, WFCLIPSIBLINGS) ?
                          (DCX_CLIPSIBLINGS | DCX_WINDOW) : (DCX_WINDOW)));
}

/***************************************************************************\
* CombineOldNewVis
*
* ORs or DIFFs hrgnOldVis and hrgnNewVis, depending on crgn, and the
* RE_* bits of fsRgnEmpty. Basically, this routine handles the optimization
* where if either region is empty, the other can be copied. Returns FALSE
* if the result is empty.
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL CombineOldNewVis(
    HRGN hrgn,
    HRGN hrgnVisOld,
    HRGN hrgnVisNew,
    UINT crgn,
    UINT fsRgnEmpty)
{
    switch (fsRgnEmpty & (RE_VISOLD | RE_VISNEW)) {
    case RE_VISOLD:

        /*
         * If we're calculating old - new and old is empty, then result is
         * empty. Otherwise, result is new.
         */
        if (crgn == RGN_DIFF)
            return FALSE;

        CopyRgn(hrgn, hrgnVisNew);
        break;

    case RE_VISNEW:

        /*
         * New is empty: result will be the old.
         */
        CopyRgn(hrgn, hrgnVisOld);
        break;

    case RE_VISNEW | RE_VISOLD:

        /*
         * Both empty: so's the result.
         */
        return FALSE;

    case 0:

        /*
         * Neither are empty: do the real combine.
         */
        switch (GreCombineRgn(hrgn, hrgnVisOld, hrgnVisNew, crgn)) {
        case NULLREGION:
        case ERROR:
            return FALSE;

        default:
            break;
        }
        break;
    }

    return TRUE;
}

/***************************************************************************\
* BltValidInit
*
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int BltValidInit(
    PSMWP psmwp)
{
    int  ccvr;
    int  cIter = 0;
    PCVR pcvr;
    PWND pwnd;
    BOOL fChangeState = FALSE;

    /*
     * Before we change any window state, calculate the old visrgn
     */
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        UINT flags = pcvr->pos.flags;

        /*
         * Make sure this is initialized to NULL; we may be sticking something
         * in it, and we want to know later if we need to free that thing.
         */
        pcvr->hrgnVisOld = NULL;

        if (pcvr->pos.hwnd == NULL)
            continue;

        pwnd = RevalidateHwnd(pcvr->pos.hwnd);

        if ((pwnd == NULL) || !IsStillWindowC(pcvr->pos.hwndInsertAfter)) {
            pcvr->pos.hwnd  = NULL;
            pcvr->pos.flags = SWP_NOREDRAW | SWP_NOCHANGE;
            continue;
        }

        /*
         * Before we change any window's state, ensure that any SPBs
         * over the window's old location are invalidated if necessary.
         * This must be done because no WM_PAINT messages will be
         * sent to anyone for the covered area if the area is obscured
         * by other windows.
         */
        if (AnySpbs() && !(flags & SWP_NOREDRAW))
            SpbCheckRect(pwnd, &pwnd->rcWindow, DCX_WINDOW);

        /*
         * Count the number of passes through the loop
         */
        cIter++;

        /*
         * Remember if any SWPs need their state changed.
         */
        if ((flags & SWP_CHANGEMASK) != SWP_NOCHANGE)
            fChangeState = TRUE;

        /*
         * If we're not redrawing, no need to calculate visrgn
         */
        if (pcvr->pos.flags & SWP_NOREDRAW)
            continue;

        if (!SYSMET(SAMEDISPLAYFORMAT))
            PreventInterMonitorBlts(pcvr);

        pcvr->fsRE       = 0;
        pcvr->hrgnVisOld = CreateEmptyRgn();

        if (pcvr->hrgnVisOld == NULL ||
            !SwpCalcVisRgn(pwnd, pcvr->hrgnVisOld)) {

            pcvr->fsRE = RE_VISOLD;
        }
    }

    return (fChangeState ? cIter : 0);
}

/***************************************************************************\
* zzzBltValidBits
*
* NOTE: Although zzzBltValidBits calls 'xxxInternalInvalidate' it does not
* specify any of the flags that will cause immediate updating. This means
* that it does not actually leave the critsect and therefore is not an 'xxx'
* routine and doesn't have to bother with revalidation.
*
* This is the routine that blts the windows around on the screen, taking
* into account SPBs.
*
* Here is the basic algebra going on here:
*
* ASSUMES: - rcBlt is aligned to the DESTINATION
*          - offset() offsets from source to destination
*
* 1. hrgnSrc = offset(rcBlt) & hrgnVisOld
*
*    Source region is the blt rectangle aligned with the old visrgn,
*    intersected with the old visrgn.
*
* 2. hrgnDst = rcBlt & hrgnVisNew
*
*    Dest region is the blt rectangle intersected with the new visrgn.
*
* 3. ghrgnValid = offset(hrgnSrc) & hrgnDst
*
*    Valid area is the intersection of the destination with the source
*    superimposed on the destination.
*
* 3.1 ghrgnValid = ghrgnValid - hrgnInterMonitor
*
*    Subtract out any pieces that are moving across monitors.
*
* 4. ghrgnValid -= ghrgnValidSum
*
*    This step takes into account the possibility that another window's
*    valid bits were bltted on top of this windows valid bits. So, as we
*    blt a window's bits, we accumulate where it went, and subtract it
*    from subsequent window's valid area.
*
* 5. ghrgnInvalid = (hrgnSrc | hrgnDst) - ghrgnValid
*
* 6. ghrgnInvalid += RestoreSpb(ghrgnInvalid) (sort of)
*
*    This is the wild part, because of the grungy way that the device
*    driver SaveBits() routine works. We call RestoreSpb() with
*    a copy of ghrgnInvalid. If the SPB valid region doesn't intersect
*    ghrgnInvalid, RestoreSpb() does nothing. But if it DOES intersect,
*    it blts down the ENTIRE saved SPB bitmap, which may include area
*    of the old window position that IS NOT part of ghrgnValid!
*
*    To correct for this, ghrgnValid is adjusted by subtracting off
*    the ghrgnInvalid computed by RestoreSpb, if it modified it.
*
* 7. ghrgnInvalidSum |= ghrgnInvalid
*
*    We save up the sum of all the invalid areas, and invalidate the
*    whole schmear in one fell swoop at the end.
*
* 8. ghrgnValidSum |= ghrgnValid
*
*    We keep track of the valid areas so far, which are subtracted
*    in step 4.
*
* The actual steps occur in a slightly different order than above, and
* there are numerous optimizations that are taken advantage of (the
* most important having to do with hiding and showing, and complete
* SPB restoration).
*
* Returns TRUE if some drawing was done, FALSE otherwise.
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL zzzBltValidBits(
    PSMWP    psmwp)
{
    int        ccvr;
    int        cIter;
    PCVR       pcvr;
    PWND       pwnd;
    PWND       pwndParent;
    PWND       pwndT;
    PWINDOWPOS ppos;
    HRGN       hrgnInvalidate;
    UINT       fsRgnEmpty;
    UINT       fsSumEmpty;
    int        cwndShowing;
    BOOL       fSyncPaint = FALSE;
    BOOL       fInvalidateLayers = FALSE;
    HDC        hdcScreen = NULL;

    DeferWinEventNotify();
    GreLockDisplay(gpDispInfo->hDev);

    /*
     * Compute old visrgns and count total CVRs in list. A side-effect of
     * BltValidInit is that revalidates all the windows in the SMWP array.
     */


    if ((cIter = BltValidInit(psmwp)) == 0) {

CleanupAndExit:

        /*
         * Go through the cvr list and free the regions that BltValidInit()
         * created.
         */
        for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

            if (pcvr->hrgnVisOld) {
                GreDeleteObject(pcvr->hrgnVisOld);
                pcvr->hrgnVisOld = NULL;
            }
        }

        goto UnlockAndExit;
    }

    /*
     * We left the crit sect since last time we validated the smwp. Validate
     * it again, and find the first WINDOWPOS structure with a non-NULL
     * hwnd in it.
     */
    ppos = NULL;
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        /*
         * Revalidate window and if it's invalid, NULL it out in the WINDOWPOS
         * struct.
         */
        pwnd = RevalidateHwnd(pcvr->pos.hwnd);

        if ((pwnd == NULL)              ||
            (pwnd->spwndParent == NULL) ||
            !IsStillWindowC(pcvr->pos.hwndInsertAfter)) {

            pcvr->pos.hwnd  = NULL;
            pcvr->pos.flags = SWP_NOREDRAW | SWP_NOCHANGE;
            continue;
        }

        /*
         * Remember the first WINDOWPOS structure that has a non-NULL
         * hwnd.
         */
        if (ppos == NULL)
            ppos = &pcvr->pos;
    }

    if (ppos == NULL)
        goto CleanupAndExit;

    UserAssert(PW(ppos->hwnd));
    pwndParent = PW(ppos->hwnd)->spwndParent;
    UserAssert(pwndParent);

    /*
     * Go account for any dirty DCs at this point, to ensure that:
     *      - any drawing done before we create an SPB will not
     *        later invalidate that SPB
     *      - the SPB regions reflect the true state of the screen,
     *        so that we don't validate parts of windows that are dirty.
     *
     * We must make this call before we change any window state.
     */
    if (AnySpbs())
        SpbCheck();

    /*
     * Change the window states
     */
    zzzChangeStates(pwndParent, psmwp);

    /*
     * move window bits around
     *
     * Invalidate the DCs for the siblings of this window.
     *
     * If our parent is not clipchildren, then we don't need to
     * invalidate its DCs. If it IS clipchildren, its client visrgn
     * will be changing, so we must invalidate it too.
     *
     * Note, because IDC_MOVEBLT is set, final completion of WNDOBJ
     * notification is delayed until GreClientRgnDone is called.
     * This final notification does not happen until after the
     * window move blts have completed.
     */
    zzzInvalidateDCCache(pwndParent,
                      IDC_MOVEBLT |
                      (TestWF(pwndParent, WFCLIPCHILDREN) ?
                          IDC_CLIENTONLY : IDC_CHILDRENONLY));

    /*
     * Now, do the bltting or whatever that is required.
     */
    fsSumEmpty = RE_VALIDSUM | RE_INVALIDSUM;
    hrgnInvalidate = ghrgnInvalidSum;

    /*
     * Init count of windows being shown with SWP_SHOWWINDOW
     * for our backward compatibility hack later.
     */
    cwndShowing = 0;

    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        /*
         * Decrement loop count. When cIter is 0, then
         * we're on the last pass through the loop.
         */
        cIter--;

        if (pcvr->pos.hwnd == NULL)
            continue;

        /*
         * If we're not redrawing, try the next one.
         */
        if (pcvr->pos.flags & SWP_NOREDRAW)
            continue;

        /*
         * Some drawing has been done
         */
        fSyncPaint = TRUE;

        pwnd = PW(pcvr->pos.hwnd);

        fsRgnEmpty = pcvr->fsRE;

        /*
         * Sprites should not be invalidated or cause invalidation.
         */
#ifdef REDIRECTION
        if (TestWF(pwnd, WEFLAYERED) || TestWF(pwnd, WEFEXTREDIRECTED)) {
#else // REDIRECTION
        if (TestWF(pwnd, WEFLAYERED)) {
#endif // REDIRECTION

            if (GetRedirectionBitmap(pwnd) == NULL)
                goto InvalidEmpty;

            /*
             * Sizing or showing uncovers new bits for a window, so
             * do the normal invalidation in this case. When sizing makes a
             * window smaller setting fInvalidateLayers to TRUE has the side
             * effect of allowing other layered windows to be invalidated.
             * Ideally, it should only allow invlalidating just the windows
             * that resized or showed. This would be a bunch of work, but we
             * should consider it for later.
             */
            if ((pcvr->pos.flags & SWP_NOSIZE) &&
                    (pcvr->pos.flags & (SWP_SHOWWINDOW | SWP_FRAMECHANGED)) == 0) {
                goto InvalidEmpty;
            } else {
                fInvalidateLayers = TRUE;
            }
        }

        /*
         * Calculate the new visrgn
         */
        if (!SwpCalcVisRgn(pwnd, ghrgnVisNew))
            fsRgnEmpty |= RE_VISNEW;

        /*
         * If the window is obscured by another window with an SPB,
         * we have to ensure that that SPB gets invalidated properly
         * since the app may not be getting a WM_PAINT msg or anything
         * to invalidate the bits.
         */
        if (AnySpbs())
            SpbCheckRect(pwnd, &pwnd->rcWindow, DCX_WINDOW);

        /*
         * Calculate ghrgnValid:
         *
         * ghrgnValid = OffsetRgn(rcBlt, -dxBlt, -dyBlt) & hrgnVisOld
         * ghrgnValid = ghrgnValid - ghrgnValidSum
         * OffsetRgn(ghrgnValid, dxBlt, dyBlt);
         * ghrgnValid = ghrgnValid - hrgnUpdate
         * ghrgnValid = ghrgnValid & hrgnVisNew;
         *
         * If either the old or new visrgns are empty, there
         * can be no valid bits...
         */
        if (fsRgnEmpty & (RE_VISOLD | RE_VISNEW))
            goto ValidEmpty;

        /*
         * If the entire window is already completely invalid, blow out.
         */
        if (pwnd->hrgnUpdate == HRGN_FULL)
            goto ValidEmpty;

        /*
         * If the blt rectangle is empty, there can be no valid bits.
         */
        if ((pcvr->rcBlt.right <= pcvr->rcBlt.left) ||
            (pcvr->rcBlt.bottom <= pcvr->rcBlt.top)) {

            goto ValidEmpty;
        }

        GreSetRectRgn(ghrgnSWP1,
                      pcvr->rcBlt.left - pcvr->dxBlt,
                      pcvr->rcBlt.top - pcvr->dyBlt,
                      pcvr->rcBlt.right - pcvr->dxBlt,
                      pcvr->rcBlt.bottom - pcvr->dyBlt);

        switch (IntersectRgn(ghrgnValid, ghrgnSWP1, pcvr->hrgnVisOld)) {
        case NULLREGION:
        case ERROR:
            goto ValidEmpty;
            break;
        }

        if (!(fsSumEmpty & RE_VALIDSUM)) {
            switch (SubtractRgn(ghrgnValid, ghrgnValid, ghrgnValidSum)) {
            case NULLREGION:
            case ERROR:
                goto ValidEmpty;
                break;
            }
        }

        if ((pcvr->dxBlt | pcvr->dyBlt) != 0)
            GreOffsetRgn(ghrgnValid, pcvr->dxBlt, pcvr->dyBlt);

        /*
         * Now subtract off the update regions of ourself and any
         * non-clipchildren parents...
         */
        pwndT = pwnd;

        do {

            if (pwndT->hrgnUpdate == HRGN_FULL)
                goto ValidEmpty;

            if (pwndT->hrgnUpdate != NULL) {
                switch (SubtractRgn(ghrgnValid, ghrgnValid, pwndT->hrgnUpdate)) {
                case NULLREGION:
                case ERROR:
                    goto ValidEmpty;
                    break;
                }
            }

            pwndT = pwndT->spwndParent;

        } while (pwndT && !TestWF(pwndT, WFCLIPCHILDREN));

        /*
         * Subtract out the intermonitor blt pieces.
         */
        if (pcvr->hrgnInterMonitor != NULL) {
            switch (SubtractRgn(ghrgnValid, ghrgnValid, pcvr->hrgnInterMonitor)) {
                case NULLREGION:
                case ERROR:
                    goto ValidEmpty;
            }
        }

        switch (IntersectRgn(ghrgnValid, ghrgnValid, ghrgnVisNew)) {
        case NULLREGION:
        case ERROR:

ValidEmpty:

            fsRgnEmpty |= RE_VALID;
            break;
        }

        /*
         * Before we restore the restore bits over part of our
         * image, we need to first copy any valid bits to their
         * final destination.
         */
        if (!(fsRgnEmpty & RE_VALID) && ((pcvr->dxBlt | pcvr->dyBlt) != 0)) {

            if (hdcScreen == NULL)
                hdcScreen = gpDispInfo->hdcScreen;

            GreSelectVisRgn(hdcScreen, ghrgnValid, SVR_COPYNEW);

#ifdef _WINDOWBLT_NOTIFICATION_
/*
 * Define _WINDOWBLT_NOTIFICATION_ to turn on Window BLT notification.
 * This notification will set a special flag in the SURFOBJ passed to
 * drivers when the DrvCopyBits operation is called to move a window.
 *
 * See also:
 *      ntgdi\gre\maskblt.cxx
 */
            NtGdiBitBlt(hdcScreen,
                        pcvr->rcBlt.left,
                        pcvr->rcBlt.top,
                        pcvr->rcBlt.right - pcvr->rcBlt.left,
                        pcvr->rcBlt.bottom - pcvr->rcBlt.top,
                        hdcScreen,
                        pcvr->rcBlt.left - pcvr->dxBlt,
                        pcvr->rcBlt.top - pcvr->dyBlt,
                        SRCCOPY,
                        0,
                        GBB_WINDOWBLT);
#else
            GreBitBlt(hdcScreen,
                      pcvr->rcBlt.left,
                      pcvr->rcBlt.top,
                      pcvr->rcBlt.right - pcvr->rcBlt.left,
                      pcvr->rcBlt.bottom - pcvr->rcBlt.top,
                      hdcScreen,
                      pcvr->rcBlt.left - pcvr->dxBlt,
                      pcvr->rcBlt.top - pcvr->dyBlt,
                      SRCCOPY,
                      0);
#endif
        }

        /*
         * Now take care of any SPB bit restoration we need to do.
         *
         * Calculate the region to clip the RestoreSpb() output to:
         *
         * ghrgnInvalid = hrgnVisOld - hrgnVisNew
         */
        if (TestWF(pwnd, WFHASSPB)    &&
            !(fsRgnEmpty & RE_VISOLD) &&
            CombineOldNewVis(ghrgnInvalid, pcvr->hrgnVisOld, ghrgnVisNew, RGN_DIFF, fsRgnEmpty)) {

            UINT retRSPB;

            /*
             * Perform SPB bits restore. We pass RestoreSpb() the region of
             * the part of the SPB that got uncovered by this window rearrangement.
             * It tries to restore as much of this area as it can from the SPB,
             * and returns the area that could not be restored from the SPB.
             *
             * The device driver's SaveBitmap() function does not clip at all
             * when it restores bits, which means that it might write bits
             * in an otherwise valid area. This means that the invalid area
             * returned by RestoreSpb() may actually be LARGER than the original
             * hrgnSpb passed in.
             *
             * RestoreSpb() returns TRUE if some part of ghrgnInvalid needs
             * to be invalidated.
             */
            if ((retRSPB = RestoreSpb(pwnd, ghrgnInvalid, &hdcScreen)) == RSPB_NO_INVALIDATE) {

                /*
                 * If hrgnVisNew is empty, then we know the whole invalid
                 * area is empty.
                 */
                if (fsRgnEmpty & RE_VISNEW)
                    goto InvalidEmpty;

            } else if (retRSPB == RSPB_INVALIDATE_SSB) {

                /*
                 * If RestoreSpb actually invalidated some area and we already
                 * have a ghrgnValidSum then subtract the newly invalidated area
                 * Warning this region subtract is not in the Win 3.1 code but
                 * they probably did not have the problem as severe because their
                 * drivers were limited to one level of SaveScreenBits
                 */
                if (!(fsSumEmpty & RE_VALIDSUM))
                    SubtractRgn(ghrgnValidSum, ghrgnValidSum, ghrgnInvalid);
            }

            /*
             * ghrgnInvalid += hrgnVisNew
             */
            if (!(fsRgnEmpty & RE_VISNEW))
                UnionRgn(ghrgnInvalid, ghrgnInvalid, ghrgnVisNew);

            /*
             * Some of the area we calculated as valid may have gotten
             * obliterated by the SPB restore. To ensure this isn't
             * the case, subtract off the ghrgnInvalid returned by RestoreSpb.
             */
            // LATER mikeke VALIDSUM / ghrgnValid mismatch
            if (!(fsRgnEmpty & RE_VALIDSUM)) {
                switch (SubtractRgn(ghrgnValid, ghrgnValid, ghrgnInvalid)) {
                case NULLREGION:
                case ERROR:
                    fsRgnEmpty |= RE_VALIDSUM;
                    break;
                }
            }

        } else {

            /*
             * No SPB. Simple ghrgnInvalid calculation is:
             *
             * ghrgnInvalid = hrgnVisNew + hrgnVisOld;
             */
            if (pcvr->hrgnVisOld == NULL) {

                /*
                 * If we couldn't create hrgnVisOld, then
                 * invalidate the entire parent
                 */
                SetRectRgnIndirect(ghrgnInvalid, &pwndParent->rcWindow);
            } else {

                if (!CombineOldNewVis(ghrgnInvalid,
                                      pcvr->hrgnVisOld,
                                      ghrgnVisNew,
                                      RGN_OR,
                                      fsRgnEmpty)) {

                    goto InvalidEmpty;
                }
            }
        }

        /*
         * Update ghrgnValidSum
         *
         * ghrgnValidSum += ghrgnValid
         */
        if (!(fsRgnEmpty & RE_VALID)) {

            /*
             * If the sum region is empty, then COPY instead of OR
             */
            if (fsSumEmpty & RE_VALIDSUM)
                CopyRgn(ghrgnValidSum, ghrgnValid);
            else
                UnionRgn(ghrgnValidSum, ghrgnValid, ghrgnValidSum);
            fsSumEmpty &= ~RE_VALIDSUM;
        }

        /*
         * Subtract ghrgnValidSum from ghrgnInvalid if non-empty,
         * otherwise use ghrgnValid. Note, ghrgnValid has been OR'ed
         * into ghrgnValidSum already.
         */
        if (!(fsSumEmpty & RE_VALIDSUM) || !(fsRgnEmpty & RE_VALID)) {
            switch (SubtractRgn(ghrgnInvalid, ghrgnInvalid,
                    !(fsSumEmpty & RE_VALIDSUM) ? ghrgnValidSum : ghrgnValid)) {
            case NULLREGION:
            case ERROR:
InvalidEmpty:
                fsRgnEmpty |= RE_INVALID;
                break;
            }
        }

        /*
         * If there are any SPB bits left over, it wasn't just created
         * (SWP_SHOWWINDOW), and an operation occured that invalidates
         * the spb bits, get rid of the spb. A move, size, hide, or
         * zorder operation will invalidate the bits. Note that we do this
         * outside of the SWP_NOREDRAW case in case the guy set that flag
         * when he had some SPB bits lying around.
         */
        if (TestWF(pwnd, WFHASSPB) && !(pcvr->pos.flags & SWP_SHOWWINDOW) &&
                (pcvr->pos.flags &
                (SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW))
                != (SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER)) {

            FreeSpb(FindSpb(pwnd));
        }

        /*
         * Finally, free up hrgnVisOld.
         */
        if (pcvr->hrgnVisOld) {
            GreDeleteObject(pcvr->hrgnVisOld);
            pcvr->hrgnVisOld = NULL;
        }

        /*
         * BACKWARD COMPATIBILITY HACK
         *
         * In 3.0, a ShowWindow() NEVER invalidated any of the children.
         * It would invalidate the parent and the window being shown, but
         * no others.
         *
         * We only apply hack (a) to 3.0 apps when all the windows involved
         * are doing a SWP_SHOWWINDOW: if any aren't, then we have to make
         * sure the siblings are invalidated too. So, we count the windows
         * doing a SHOWWINDOW and compare it to the total count in the CVR.
         */
        if (!TestWF(pwnd, WFWIN31COMPAT) && (pcvr->pos.flags & SWP_SHOWWINDOW))
            cwndShowing++;

        /*
         * Update ghrgnInvalidSum:
         *
         * ghrgnInvalidSum += ghrgnInvalid
         */
        if (!(fsRgnEmpty & RE_INVALID)) {

            /*
             * BACKWARD COMPATIBILITY HACK
             *
             * In many cases including ShowWindow, CS_V/HREDRAW,
             * SWP_NOCOPYBITS, etc, 3.0 always invalidated the window with
             * (HRGN)1, regardless of how it was clipped by children, siblings,
             * or parents. Besides being more efficient, this caused child
             * windows that would otherwise not get update regions to get
             * invalidated -- see the hack notes in InternalInvalidate2.
             *
             * This is a performance hack (usually) because (HRGN)1 can save
             * a lot of region calculations in the normal case. So, we do this
             * for 3.1 apps as well as 3.0 apps.
             *
             * We detect the case as follows: invalid area not empty,
             * valid area empty, and new visrgn not empty.
             */
            if ((fsRgnEmpty & RE_VALID) && !(fsRgnEmpty & RE_VISNEW)) {

                /*
                 * With the parameters we use InternalInvalidate() does
                 * not leave the critical section
                 */
                BEGINATOMICCHECK();
                xxxInternalInvalidate(pwnd,
                                     HRGN_FULL,
                                     RDW_INVALIDATE |
                                     RDW_FRAME      |
                                     RDW_ERASE      |
                                     RDW_ALLCHILDREN);
                ENDATOMICCHECK();
            }

            /*
             * If the sum region is empty, then COPY instead of OR
             */
            if (fsSumEmpty & RE_INVALIDSUM) {

                /*
                 * HACK ALERT:
                 * If this is the last pass through the loop (cIter == 0)
                 * and ghrgnInvalidSum is currently empty,
                 * then instead of copying ghrgnInvalid to ghrgnInvalidSum,
                 * just set hrgnInvalidate to ghrgnInvalid. This saves
                 * a region copy in the single-window case.
                 */
                if (cIter == 0) {
                    hrgnInvalidate = ghrgnInvalid;
                } else {
                    CopyRgn(ghrgnInvalidSum, ghrgnInvalid);
                }

            } else {

                UnionRgn(ghrgnInvalidSum, ghrgnInvalid, ghrgnInvalidSum);
            }

            fsSumEmpty &= ~RE_INVALIDSUM;
        }
    } // for (... pcvr ...)

    /*
     * Now, invalidate as needed.
     */
    if (!(fsSumEmpty & RE_INVALIDSUM)) {

        /*
         * BACKWARD COMPATIBILITY HACK (see above)
         *
         * If all the windows involved were being shown, then
         * invalidate the parent ONLY -- don't enumerate any children.
         * (the windows involved have already been invalidated above).
         * This hack is only applied to 3.0 apps (see above).
         */

        /*
         * More hack-o-rama. On Win3.1, the desktop paint would only
         * repaint those portions inside the rect returned from GetClipBox().
         * Dialogs with spbs outside the rect returned from GetClipBox() would
         * not get their spbs invalidated until later, when you clicked on
         * them to make them active. The only dialog that wouldn't really loose
         * its bits is the control panel desktop dialog, which would restore
         * its bad bits when it went away (in certain configurations). On
         * NT, the desktop would repaint and then the dialog would go away.
         * On Win3.1, the dialog would go away and then the desktop would
         * repaint. On NT, because of preemption and little differences in
         * painting order between applications, there was an opportunity to
         * put bad bits on the screen, on Win3.1 there wasn't.
         *
         * Now... the below code that passes RDW_NOCHILDREN only gets executed
         * if the app is marked as a win3.0 app (latest CorelDraw, also wep
         * freecell demonstrates the same problem). This code would get
         * executed when a dialog got shown. So for a win3.0 app, spb would get
         * saved, the dialog would get shown, the desktop invalidated, the
         * desktop would paint, the spb would get clobbered. In short, when
         * a win3.0 app would put up a dialog, all spbs would get freed because
         * of the new (and correct) way the desktop repaints.
         *
         * So the desktop check hack will counter-act the invalidate
         * RDW_NOCHILDREN case if all windows are hiding / showing and the
         * desktop is being invalidated. Note that in the no RDW_NOCHILDREN
         * case, the invalid area gets distributed to the children first (in
         * this case, children of the desktop), so if the children cover the
         * desktop, the desktop won't get any invalid region, which is what
         * we want. - scottlu
         */

        /*
         * With the parameters we use InternalInvalidate() does not leave
         * the critical section
         */

        DWORD dwFlags = RDW_INVALIDATE | RDW_ERASE;
        if (cwndShowing == psmwp->ccvr &&
                pwndParent != PWNDDESKTOP(pwndParent)) {
            dwFlags |= RDW_NOCHILDREN;
        } else {
            dwFlags |= RDW_ALLCHILDREN;
        }
        if (fInvalidateLayers) {
            dwFlags |= RDW_INVALIDATELAYERS;
        }

        BEGINATOMICCHECK();
        xxxInternalInvalidate(pwndParent, hrgnInvalidate, dwFlags);
        ENDATOMICCHECK();
    }

    /*
     * Since zzzInvalidateDCCache was called with IDC_MOVEBLT specified,
     * we must complete the WNDOBJ notification with a call to
     * GreClientRgnDone.
     *
     * Note: in zzzInvalidateDCCache, it is necessary to call
     * GreClientRgnUpdated even if gcountPWO is 0. However,
     * GreClientRgnDone only does something if gcountPWO is non-zero,
     * so we can optimize slightly.
     */
    if (gcountPWO != 0) {
        GreClientRgnDone(GCR_WNDOBJEXISTS);
    }

UnlockAndExit:

    /*
     * If necessary, release the screen DC
     */
    if (hdcScreen != NULL) {

        /*
         * Reset the visrgn before we go...
         */
        GreSelectVisRgn(hdcScreen, NULL, SVR_DELETEOLD);

        /*
         * Make sure that the drawing we did in this DC does not affect
         * any SPBs. Clear the dirty rect.
         */
        GreGetBounds(hdcScreen, NULL, 0);     // NULL means reset
    }

    /*
     * All the dirty work is done. Ok to leave the critsects we entered
     * earlier and dispatch any deferred Window Event notifications.
     */
    GreUnlockDisplay(gpDispInfo->hDev);
    zzzEndDeferWinEventNotify();

    return fSyncPaint;
}

/***************************************************************************\
* xxxHandleWindowPosChanged
*
* DefWindowProc() HandleWindowPosChanged handler.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxHandleWindowPosChanged(
    PWND pwnd,
    PWINDOWPOS ppos)
{
    CheckLock(pwnd);

    if (!(ppos->flags & SWP_NOCLIENTMOVE)) {
        POINT   pt;
        PWND    pwndParent;

        pt.x = pwnd->rcClient.left;
        pt.y = pwnd->rcClient.top;

        pwndParent = pwnd->spwndParent;
        UserAssert(pwndParent);

        if (pwndParent != PWNDDESKTOP(pwnd)) {
            pt.x -= pwndParent->rcClient.left;
            pt.y -= pwndParent->rcClient.top;
        }

        xxxSendMessage(
                pwnd,
                WM_MOVE,
                FALSE,
                MAKELONG(pt.x, pt.y));
    }

    if ((ppos->flags & SWP_STATECHANGE) || !(ppos->flags & SWP_NOCLIENTSIZE)) {

        if (TestWF(pwnd, WFMINIMIZED))
            xxxSendSizeMessage(pwnd, SIZEICONIC);
        else if (TestWF(pwnd, WFMAXIMIZED))
            xxxSendSizeMessage(pwnd, SIZEFULLSCREEN);
        else
            xxxSendSizeMessage(pwnd, SIZENORMAL);
    }
}

/***************************************************************************\
* PWND GetRealOwner(pwnd)
*
* Returns the owner of pwnd, normalized so that it shares the same parent
* of pwnd.
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

PWND GetRealOwner(
    PWND pwnd)
{
    PWND pwndParent = pwnd->spwndParent;

    /*
     * A frame window owned by itself is "unowned"
     */
    if (pwnd != pwnd->spwndOwner && (pwnd = pwnd->spwndOwner) != NULL) {

        /*
         * The NULL test is in case the owner is higher than the
         * passed in window (e.g. your owner IS your parent)
         */
        while (pwnd != NULL && pwnd->spwndParent != pwndParent)
            pwnd = pwnd->spwndParent;
    }

    return pwnd;
}

/***************************************************************************\
*
* Starting at pwnd (or pwndParent->spwndChild if pwnd == NULL), find
* next window owned by pwndOwner
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/
PWND NextOwnedWindow(
    PWND pwnd,
    PWND pwndOwner,
    PWND pwndParent)
{
    if (pwnd == NULL) {
        pwnd = pwndParent->spwndChild;

        /*
         * In xxxCreateWindowEx(), we callback the window proc while the
         * window is still not linked yet to the window tree. If it is the
         * first child of its parent, then the window spwndParent will point
         * to the parent while the parent spwndChild will still be NULL. If
         * the window proc called ShowWindow() or SetWindowPos() in response
         * to those early callbacks, we will end up here with broken window
         * tree. The right fix is to never call back while the window tree
         * is in an intermediate state (i.e. linking the window to the tree
         * before any callback) but this seem scary to change now because of
         * app compat.
         *
         * Windows Bug #482192.
         */
        if (pwnd == NULL) {
            RIPMSG1(RIP_WARNING,
                    "Window tree structure broken at pwnd: 0x%p",
                    pwndParent);
            return NULL;
        }

        goto loop;
    }

    while ((pwnd = pwnd->spwndNext) != NULL) {
loop:
        /*
         * If owner of pwnd is pwndOwner, break out of here.
         */
        if (pwndOwner == GetRealOwner(pwnd)) {
            break;
        }
    }

    return pwnd;
}

/***************************************************************************\
*
* Recursively enumerate owned windows starting from pwndRoot,
* to set the state of WEFTOPMOST. Doesn't actually diddle
* this bit yet: the work gets done in zzzChangeStates():
* instead we just set the WFTOGGLETOPMOST bit as appropriate.
*
* We can't diddle the state until the Z order changes are done,
* or else GetTopMostWindow() and the like will do the wrong thing.
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

VOID SetTopmost(
    PWND pwndRoot,
    BOOL fTopmost)
{
    PWND pwnd;

    /*
     * If the new state is different than the current state,
     * then set the TOGGLETOPMOST bit, so it'll get toggled
     * in ChangeStates().
     */
    UserAssert((fTopmost == TRUE) || (fTopmost == FALSE));
    if (!!TestWF(pwndRoot, WEFTOPMOST) ^ fTopmost) {
        SetWF(pwndRoot, WFTOGGLETOPMOST);
    } else {
        ClrWF(pwndRoot, WFTOGGLETOPMOST);
    }

    pwnd = NULL;
    while (pwnd = NextOwnedWindow(pwnd, pwndRoot, pwndRoot->spwndParent)) {
                  SetTopmost(pwnd, fTopmost);
    }

}

/*
 * LATER: (hiroyama) #88810
 * The IME code here broke the US regression test, so backing it up until we
 * hit the problem on NT.
 */
#ifdef LATER
/***************************************************************************\
 * IsBottomIMEWindow()
 *
 * returns TRUE if pwnd is IME window and its toplevel window is BOTTOMMOST
 *
 * Ported: 18-Apr-1997 Hiroyama     from Memphis
\***************************************************************************/
BOOL IsBottomIMEWindow(
    PWND pwnd)
{
    if (TestCF(pwnd, CFIME) ||
            (pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])) {
        PWND pwndT2 = pwnd;
        PWND pwndTopOwner = pwnd;
        PWND pwndDesktop;

        if (grpdeskRitInput == NULL || grpdeskRitInput->pDeskInfo == NULL) {
            // Desktop is being created or not yet created
            RIPMSG1(RIP_WARNING, "IsBottomIMEWindow: Desktop is being created or not yet created. pwnd=%#p\n",
                    pwnd);
            return FALSE;
        }

        pwndDesktop = grpdeskRitInput->pDeskInfo->spwnd;

        UserAssert(pwndDesktop);

        /*
         * search the toplevel owner window of the IME window.
         */
        while (pwndT2 && (pwndT2 != pwndDesktop)) {
            pwndTopOwner = pwndT2;
            pwndT2 = pwndT2->spwndOwner;
        }
        /*
         * TRUE if the toplevel owner window of the IME window is BOTTOMMOST
         */
        return (BOOL)(TestWF(pwndTopOwner, WFBOTTOMMOST));
    }
    return FALSE;
}

/***************************************************************************\
 * ImeCheckBottomIMEWindow()
 *
 * returns TRUE if pwndT->spwndNext's owner is BOTTOMMOST
 *
 * Ported: 18-Apr-1997 Hiroyama     from Memphis
\***************************************************************************/
BOOL ImeCheckBottomIMEWindow(
    PWND pwndT)
{
    /*
     * pwnd is IME window and its toplevel window is BOTTOMMOST
     */
    PWND pwndDesktop;
    PWND pwndT2 = pwndT->spwndNext;
    PWND pwndTopOwner = pwndT2;

    UserAssert(grpdeskRipInput != NULL && grpdeskRitInput->pDeskInfo != NULL);
    pwndDesktop = grpdeskRitInput->pDeskInfo->spwnd;

    /*
     * check if toplevel owner window of pwnd->spwndNext is bottommost
     */
    while (pwndT2 && (pwndT2 != pwndDesktop)) {
        pwndTopOwner = pwndT2;
        pwndT2 = pwndT2->spwndOwner;
    }

    if (pwndTopOwner && TestWF(pwndTopOwner, WFBOTTOMMOST)) {
        /*
         * yes, pwndT is the last one whose toplevel window is *not* BOTTOMMOST
         */
        return TRUE;
    }

    return FALSE;
}
#endif  // LATER

/***************************************************************************\
* CalcForegroundInsertAfter
*
* Calculates where to zorder a window that doesn't belong to the foreground
* thread and is not topmost but wants to come to the top. This routine
* calculates what "top" means under those conditions.
*
* 14-Sep-1992 ScottLu       Created.
\***************************************************************************/

PWND CalcForegroundInsertAfter(
    PWND pwnd)
{
    PWND        pwndInsertAfter, pwndInsertAfterSave;
    PWND        pwndT;
    PTHREADINFO ptiTop;
#ifdef LATER    // see #88810
    BOOLEAN     fImeOwnerIsBottom = FALSE;
#endif

    /*
     * If we're allowing this application to make this top
     * level window foreground active, then this app may
     * not be foreground yet, but we want any windows it
     * zorders to appear on top because it is probably about
     * to activate them (this is a guess!) If this is the case,
     * let it do what it wants. A good example of this is an
     * application like toolbook that creates a window without a
     * caption, doesn't activate it, and wants that to appear on top.
     */

    if (TestWF(pwnd, WFBOTTOMMOST)) {
        pwndInsertAfter = GetLastNonBottomMostWindow(pwnd, TRUE);
    } else {
        pwndInsertAfter = GetLastTopMostWindow();
#ifdef LATER    // see #88810
        if (IS_IME_ENABLED()) {
            fImeOwnerIsBottom = IsBottomIMEWindow(pwnd);
            if (fImeOwnerIsBottom) {
                for (pwndT = pwndInsertAfter; pwndT; pwndT = pwndT->spwndNext) {
                    if (ImeCheckBottomIMEWindow(pwndT)) {
                        /*
                         * toplevel owner of pwndT->spwndNext is BOTTOMMOST
                         */
                        break;
                    }
                    pwndInsertAfter = pwndT;
                }
            }
        }
#endif  // LATER
    }


    if (!TestwndChild(pwnd)) {
//    if (hwnd->hwndParent == hwndDesktop)  -- Chicago conditional FritzS

        if ((GETPTI(pwnd)->TIF_flags & TIF_ALLOWFOREGROUNDACTIVATE) ||
                (GETPTI(pwnd)->ppi->W32PF_Flags & W32PF_ALLOWFOREGROUNDACTIVATE)) {

            return pwndInsertAfter;
        }
    }

    /*
     * If there is no foreground thread or this pwnd is of the foreground
     * thread, then let it come to the top.
     */
    if (gpqForeground == NULL)
        return pwndInsertAfter;

    if (GETPTI(pwnd)->pq == gpqForeground)
        return pwndInsertAfter;

    /*
     * This thread is not of the foreground queue, so search for a window
     * of this thread to zorder above.
     */
    pwndT = ((pwndInsertAfter == NULL) ?
            pwnd->spwndParent->spwndChild :
            pwndInsertAfter);

    /*
     * Remember the top insert after in case this first loop
     * fails to find a window
     */
    pwndInsertAfterSave = pwndInsertAfter;

    for (; pwndT != NULL; pwndT = pwndT->spwndNext) {

        /*
         * This window wants to come to the top if possible.
         * If we're passing our own window, get out of this loop:
         * by now we already have pwndInsertAfter set up to the
         * last available window to insert after.
         */
        if ((pwndT == pwnd) || TestWF(pwndT, WFBOTTOMMOST))
            break;

        /*
         * If this window isn't owned by this thread, continue.
         */
        if (GETPTI(pwndT) != GETPTI(pwnd)) {
            pwndInsertAfter = pwndT;
            continue;
        }

        /*
         * Don't want a window zordering below one of its top most windows
         * if it isn't foreground.
         */
        if (TestWF(pwndT, WEFTOPMOST)) {
            pwndInsertAfter = pwndT;
            continue;
        }

#ifdef LATER    // see #88810
        // FE_IME
        if (fImeOwnerIsBottom && ImeCheckBottomIMEWindow(pwndT)) {
            /*
             * owner of pwndT->spwndNext is BOTTOMMOST
             * so pwndT is the last one whose owner is not bottommost.
             */
            pwndInsertAfter = pwndT;
            continue;
        }
        // end FE_IME
#endif

        /*
         * Ok to change zorder of top level windows because of
         * invisible windows laying around, but not children:
         * applications would go nuts if we did this.
         */
        if (!TestwndChild(pwndT)) {
            if (!TestWF(pwndT, WFVISIBLE)) {
                pwndInsertAfter = pwndT;
                continue;
            }
        }

        break;
    }

    /*
     * If we didn't find a window in the previous loop,
     * it means that the thread has no
     * other sibling windows, so we need to put it after the
     * foreground window (foreground thread). Search for the
     * first unowned window of the foreground app to zorder
     * after.
     */
    if ((pwndT == NULL) || TestWF(pwndT, WFBOTTOMMOST)) {
        /*
         * This is our first guess in case nothing works out.
         */
        pwndInsertAfter = pwndInsertAfterSave;

        /*
         * Start below the last topmost or from the top if no
         * topmost windows.
         */
        if ((pwndT = pwndInsertAfter) == NULL)
            pwndT = pwnd->spwndParent->spwndChild;

        /*
         * ptiTop is the pti of the active window in the foreground queue!
         */
        ptiTop = NULL;
        if (gpqForeground->spwndActive != NULL)
            ptiTop = GETPTI(gpqForeground->spwndActive);

        for (; pwndT != NULL; pwndT = pwndT->spwndNext) {

            if (TestWF(pwndT, WFBOTTOMMOST))
                break;

            /*
             * If not the top most thread, continue.
             */
            if (GETPTI(pwndT) != ptiTop)
                continue;

            /*
             * Found one of the foreground thread. Remember this
             * as the next best guess. Try to find an unowned
             * visible window, which would indicate the main
             * window of the foreground thread. If owned,
             * continue.
             */
            if (pwndT->spwndOwner != NULL) {
                pwndInsertAfter = pwndT;
                continue;
            }

            /*
             * Unowned and of the foreground thread. Is it visible?
             * If not, get out of here.
             */
            if (!TestWF(pwndT, WFVISIBLE))
                continue;
#ifdef LATER    // see #88810
            // FE_IME
            if (fImeOwnerIsBottom && ImeCheckBottomIMEWindow(pwndT)) {
                continue;
            }
            // end FE_IME
#endif

            /*
             * Best possible match so far: unowned visible window
             * of the foreground thread.
             */
            pwndInsertAfter = pwndT;
        }
    }

    UserAssert(pwnd != pwndInsertAfter);

    return pwndInsertAfter;
}

/***************************************************************************\
* GetTopMostInsertAfter
*
* We don't want any one to get in front of a hard error box, except menus,
* screen savers, etc.
*
* Don't call it directly, use the GETTOPMOSTINSERTAFTER macro to avoid
* the call when there is no hard error box up (gHardErrorHandler.pti == NULL).
*
* 04-25-96 GerardoB Created
\***************************************************************************/
PWND GetTopMostInsertAfter(
    PWND pwnd)
{
    PWND pwndT;
    PTHREADINFO ptiCurrent;
    PDESKTOP pdesk;
    WORD wfnid;

    /*
     * If you hit this assertion, you're probably not using the
     * GETTOPMOSTINSERTAFTER macro to make this call.
     */
    UserAssert(gHardErrorHandler.pti != NULL);

    /*
     * pwnd: Menu and switch (ALT-TAB) windows can go on top.
     */
    wfnid = GETFNID(pwnd);
    if ((wfnid == FNID_MENU) || (wfnid == FNID_SWITCH)) {
        return NULL;
    }

    /*
     * pti: If this is the error handler thread, don't bother any longer.
     *      Screen saver can go on top too.
     */
    ptiCurrent = PtiCurrent();
    UserAssert(ptiCurrent != NULL);

    if (ptiCurrent == gHardErrorHandler.pti || (ptiCurrent->ppi->W32PF_Flags & W32PF_SCREENSAVER)) {
        return NULL;
    }

    /*
     * pdesk: Leave the logon desktop alone.
     *        Make sure the hard error box is on this desktop
     */
    pdesk = ptiCurrent->rpdesk;
    UserAssert(pdesk != NULL);
    UserAssert(pdesk->rpwinstaParent);
    UserAssert(pdesk->rpwinstaParent->pTerm);

    if ((pdesk == grpdeskLogon)
            || (pdesk != gHardErrorHandler.pti->rpdesk)) {
        return NULL;
    }

    /*
     * Walk the window list looking for the hard error box.
     * Start searching from the current desktop's first child.
     * Note that the harderror box migth not be created yet.
     */
    UserAssert(pdesk->pDeskInfo);
    UserAssert(pdesk->pDeskInfo->spwnd);

    for (pwndT = pdesk->pDeskInfo->spwnd->spwndChild;
            pwndT != NULL; pwndT = pwndT->spwndNext) {

        /*
         * Hard error boxes are always top most.
         */
        if (!TestWF(pwndT, WEFTOPMOST)) {
            break;
        }

        /*
         * If this window was created by the hard error handler thread,
         * then this is it.
         */
        if (gHardErrorHandler.pti == GETPTI(pwndT)) {
            return pwndT;
        }
    }

    return NULL;
}

/***************************************************************************\
*
* This routine maps the special HWND_* values of ppos->hwndInsertAfter,
* and returns whether or not the window's owner group should be labelled
* TOPMOST or not, or left alone.
*
* Here are the TOPMOST rules. If pwndInsertAfter is:
*
* 1. HWND_BOTTOM == (HWND)1:
*
*    The group is made non-TOPMOST.
*
* 2. HWND_TOPMOST == (HWND)-1:
*
*    hwndInsertAfter is set to HWND_TOP, and the group is made TOPMOST.
*
* 3. HWND_NOTOPMOST == (HWND)-2:
*
*    Treated same as HWND_TOP, except that the TOPMOST bit is cleared.
*    and the entire group is made non-topmost.
*    Used to make a topmost window non-topmost, but still leave it at
*    the top of the non-topmost pile.
*    The group is not changed if the window is already non-topmost.
*
* 4. HWND_TOP == (HWND)NULL:
*
*    pwndInsertAfter is set to the last TOPMOST window if pwnd
*    is not itself TOPMOST. If pwnd IS TOPMOST, then pwndInsertAfter
*    remains HWND_TOP.
*
* 5. A TOPMOST window:
*
*    If a window is being inserted among the TOPMOST windows, then
*    the group becomes topmost too, EXCEPT if it's being inserted behind
*    the bottom-most topmost window: in that case the window retains
*    its current TOPMOST bit.
*
* 6. A non-TOPMOST window:
*
*    If a window is being inserted among non-TOPMOST windows, the group is made
*    non-TOPMOST and inserted there.
*
* Whenever a group is made TOPMOST, only that window and its ownees are made
* topmost. When a group is made NOTOPMOST, the entire window is made non-topmost.
*
* This routine must NOT set SWP_NOZORDER if the topmost state is changing:
* this would prevent the topmost bits from getting toggled in ChangeStates.
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

int CheckTopmost(
    PWINDOWPOS ppos)
{
    PWND pwnd, pwndInsertAfter, pwndT;

    /*
     * BACKWARD COMPATIBILITY HACK
     *
     * If we're activating a window and Z-ordering too, we must ignore the
     * specified Z order and bring the window to the top, EXCEPT in the
     * following conditions:
     *
     * 1. The window is already active (in which case, the activation code
     *    will not be bringing the window to the top)
     *
     * 2. HWND_TOP or HWND_NOTOPMOST is specified. This allows us to
     *    activate and move to topmost or nontopmost at the same time.
     *
     * NOTE: It would have been possible to modify ActivateWindow() to
     * take a flag to prevent it from ever doing the BringWindowToTop,
     * thus allowing SetWindowPos() to properly honor pwndInsertBehind
     * AND activation, but this change was considered too late in the
     * game -- there could be problems with existing 3.1 apps, such as
     * PenWin, etc.
     */
    pwnd = PW(ppos->hwnd);
    if (!(ppos->flags & SWP_NOACTIVATE) &&
            !(ppos->flags & SWP_NOZORDER) &&
             (ppos->hwndInsertAfter != HWND_TOPMOST &&
             ppos->hwndInsertAfter != HWND_NOTOPMOST) &&
             (pwnd != GETPTI(pwnd)->pq->spwndActive)) {
        ppos->hwndInsertAfter = HWND_TOP;
    }

    /*
     * If we're not Z-ordering, don't do anything.
     */
    if (ppos->flags & SWP_NOZORDER) {
        return CTM_NOCHANGE;
    }

    if (ppos->hwndInsertAfter == HWND_BOTTOM) {
        return CTM_NOTOPMOST;
    } else if (ppos->hwndInsertAfter == HWND_NOTOPMOST) {
        /*
         * If currently topmost, move to top of non-topmost list.
         * Otherwise, no change.
         *
         * Note that we don't set SWP_NOZORDER -- we still need to
         * check the TOGGLETOPMOST bits in ChangeStates()
         */
        if (TestWF(pwnd, WEFTOPMOST)) {

            pwndT = GetLastTopMostWindow();
            ppos->hwndInsertAfter = HW(pwndT);

            if (ppos->hwndInsertAfter == ppos->hwnd) {
                pwndT = _GetWindow(pwnd, GW_HWNDPREV);
                ppos->hwndInsertAfter = HW(pwndT);
            }

        } else {

            pwndT = _GetWindow(pwnd, GW_HWNDPREV);
            ppos->hwndInsertAfter = HW(pwndT);
        }

        return CTM_NOTOPMOST;

    } else if (ppos->hwndInsertAfter == HWND_TOPMOST) {
        pwndT = GETTOPMOSTINSERTAFTER(pwnd);
        if (pwndT != NULL) {
            ppos->hwndInsertAfter = HW(pwndT);
        } else {
            ppos->hwndInsertAfter = HWND_TOP;
        }

        return CTM_TOPMOST;

    } else if (ppos->hwndInsertAfter == HWND_TOP) {
        /*
         * If we're not topmost, position ourself after
         * the last topmost window. Otherwise, make sure
         * that no one gets in front of a hard error box.
         */
        if (TestWF(pwnd, WEFTOPMOST)) {
            pwndT = GETTOPMOSTINSERTAFTER(pwnd);
            if (pwndT != NULL) {
                ppos->hwndInsertAfter = HW(pwndT);
            }
            return CTM_NOCHANGE;
        }

        /*
         * Calculate the window to zorder after for this window, taking
         * into account foreground status.
         */
        pwndInsertAfter = CalcForegroundInsertAfter(pwnd);
        ppos->hwndInsertAfter = HW(pwndInsertAfter);

        return CTM_NOCHANGE;
    }

    /*
     * If we're being inserted after the last topmost window,
     * then don't change the topmost status.
     */
    pwndT = GetLastTopMostWindow();
    if (ppos->hwndInsertAfter == HW(pwndT))
        return CTM_NOCHANGE;

    /*
     * Otherwise, if we're inserting a TOPMOST among non-TOPMOST,
     * or vice versa, change the status appropriately.
     */
    if (TestWF(PW(ppos->hwndInsertAfter), WEFTOPMOST)) {

        if (!TestWF(pwnd, WEFTOPMOST)) {
            return CTM_TOPMOST;
        }

        pwndT = GETTOPMOSTINSERTAFTER(pwnd);
        if (pwndT != NULL) {
            ppos->hwndInsertAfter = HW(pwndT);
        }

    } else {

        if (TestWF(pwnd, WEFTOPMOST))
            return CTM_NOTOPMOST;
    }

    return CTM_NOCHANGE;
}

/***************************************************************************\
* IsOwnee(pwndOwnee, pwndOwner)
*
* Returns TRUE if pwndOwnee is owned by pwndOwner
*
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

BOOL IsOwnee(
    PWND pwndOwnee,
    PWND pwndOwner)
{
    PWND pwnd;

    while (pwndOwnee != NULL) {

        /*
         * See if pwndOwnee is a child of pwndOwner...
         */
        for (pwnd = pwndOwnee; pwnd != NULL; pwnd = pwnd->spwndParent) {
            if (pwnd == pwndOwner)
                return TRUE;
        }

        /*
         * If the window doesn't own itself, then set the owner
         * to itself.
         */
        pwndOwnee = (pwndOwnee->spwndOwner != pwndOwnee ?
                pwndOwnee->spwndOwner : NULL);
    }

    return FALSE;
}

/***************************************************************************\
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

BOOL IsBehind(
    PWND pwnd,
    PWND pwndReference)
{

    /*
     * Starting at pwnd, move down until we reach the end of the window
     * list, or until we reach pwndReference. If we encounter pwndReference,
     * then pwnd is above pwndReference, so return FALSE. If we get to the
     * end of the window list, pwnd is behind, so return TRUE.
     */
    if (pwndReference == (PWND)HWND_TOP)
        return TRUE;

    if (pwndReference == (PWND)HWND_BOTTOM)
        return FALSE;

    for ( ; pwnd != NULL; pwnd = pwnd->spwndNext) {
        if (pwnd == pwndReference)
            return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
*
* Add pwnd to the SMWP. pwndChange is the "real" pwnd being repositioned
* and pwndInsertAfter is the place where it's being inserted.
*
* pwndTopInsert is the window handle where the top of the owner tree should be
* inserted. The special value of (HWND)-2 is used to indicate recursion, in
* which case newly added SWPs are added to the previous element.
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

PSMWP AddSelfAndOwnees(
    PSMWP psmwp,
    PWND  pwnd,
    PWND  pwndChange,
    PWND  pwndInsertAfter,
    int   iTop)
{
    PWND pwndChgOwnee;
    PWND pwndT;
    BOOL fChgOwneeInserted;
    CVR  *pcvr;

    /*
     * The general idea here is to first add our ownees, then add ourself.
     * When we add our ownees though, we add them as appropriate based
     * on the pwndInsertAfter parameter.
     *
     * Find out if any of our ownees are on a direct path between pwndChange
     * and the root of the owner tree. If one is, then its Z order relative
     * to its owner-siblings will be changing. If none are, then
     * we want to add our ownees to the list in their current order.
     */
    pwndChgOwnee = pwndChange;
    while (pwndChgOwnee != NULL) {

        pwndT = GetRealOwner(pwndChgOwnee);

        if (pwnd == pwndT)
            break;

        pwndChgOwnee = pwndT;
    }

    /*
     * Now enumerate all other ownees, and insert them in their
     * current order.
     */
    fChgOwneeInserted = FALSE;
    pwndT = NULL;
    while ((pwndT = NextOwnedWindow(pwndT, pwnd, pwnd->spwndParent)) != NULL) {

        /*
         * If these siblings are to be reordered, compare the sibling's
         * current Z order with pwndInsertAfter.
         */
        if (pwndChgOwnee == NULL) {

            /*
             * No Z change for our ownees: just add them in their current order
             */
            psmwp = AddSelfAndOwnees(psmwp, pwndT, NULL, NULL, iTop);

        } else {

            /*
             * If we haven't already inserted the ChgOwnee, and the
             * enumerated owner-sibling is behind pwndInsertAfter, then
             * add ChgOwnee.
             */
            if (!fChgOwneeInserted && IsBehind(pwndT, pwndInsertAfter)) {

                psmwp = AddSelfAndOwnees(psmwp,
                                         pwndChgOwnee,
                                         pwndChange,
                                         pwndInsertAfter,
                                         iTop);

                if (psmwp == NULL)
                    return NULL;

                fChgOwneeInserted = TRUE;
            }

            if (pwndT != pwndChgOwnee) {

                /*
                 * Not the change ownee: add it in its current order.
                 */
                psmwp = AddSelfAndOwnees(psmwp, pwndT, NULL, NULL, iTop);
            }
        }

        if (psmwp == NULL)
            return NULL;
    }

    /*
     * If we never added the change ownee in the loop, add it now.
     */
    if ((pwndChgOwnee != NULL) && !fChgOwneeInserted) {

        psmwp = AddSelfAndOwnees(psmwp,
                                 pwndChgOwnee,
                                 pwndChange,
                                 pwndInsertAfter,
                                 iTop);

        if (psmwp == NULL)
            return NULL;
    }

    /*
     * Finally, add this window to the list.
     */
    psmwp = _DeferWindowPos(psmwp, pwnd, NULL,
            0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    if (psmwp == NULL)
        return NULL;

    /*
     * If we aren't inserting the topmost entry,
     * link this entry to the previous one.
     * The topmost entry will get set by our caller.
     */
    if (iTop != psmwp->ccvr - 1) {
        pcvr = &psmwp->acvr[psmwp->ccvr - 1];
        pcvr->pos.hwndInsertAfter = (pcvr - 1)->pos.hwnd;
    }
    return psmwp;
}

/***************************************************************************\
*
* ZOrderByOwner2 - Add the current window and all it owns to the SWP list,
* and arrange them in the new Z ordering. Called only if the Z order of the
* window is changing.
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

PSMWP ZOrderByOwner2(
    PSMWP psmwp,
    int   iTop)
{
    PWND       pwndT;
    PWND       pwndOwnerRoot;
    PWND       pwndTopInsert;
    PWINDOWPOS ppos;
    PWND       pwnd;
    PWND       pwndInsertAfter;
    BOOL       fHasOwnees;

    ppos = &psmwp->acvr[iTop].pos;

    /*
     * If inside message box processing, not Z ordering,
     * or if SWP_NOOWNERZORDER specified, all done.
     */
    // LATER 04-Mar-1992 MikeKe
    // do we have a substitue for fMessageBox
    if ((ppos->flags & SWP_NOZORDER) ||
        (ppos->flags & SWP_NOOWNERZORDER)) {

        return psmwp;
    }

    pwnd = PW(ppos->hwnd);
    pwndInsertAfter = PWInsertAfter(ppos->hwndInsertAfter);

    fHasOwnees = (NextOwnedWindow(NULL, pwnd, pwnd->spwndParent) != NULL);

    /*
     * If the window isn't owned, and it doesn't own any other window,
     * do nothing.
     */
    if (!pwnd->spwndOwner && !fHasOwnees)
        return psmwp;

    /*
     * Find the unowned window to start building the tree from.
     * This is easy: just zip upwards until we find a window with no owner.
     */
    pwndOwnerRoot = pwndT = pwnd;
    while ((pwndT = GetRealOwner(pwndT)) != NULL)
        pwndOwnerRoot = pwndT;

    /*
     * We need to calculate what pwndInsertAfter should be for
     * the first (topmost) window of the SWP list.
     *
     * If pwndInsertAfter is part of the owner tree we'll be building,
     * then we want to reorder windows within the owner group, so the
     * entire group should maintain it's relative order.
     *
     * If pwndInsertAfter is part of another owner tree, then we want
     * the whole group relative to that.
     *
     * If pwndInsertAfter is HWND_BOTTOM, then we want the whole
     * group to go to the bottom, so we position it relative to
     * the bottom most window that is not part of the tree. We also
     * want to put pwnd on the bottom relative to its owner siblings.
     *
     * If pwndInsertAfter is HWND_TOP, then bring the whole group
     * to the top, as well as bringing pwnd to the top relative to its
     * owner siblings.
     *
     * Assume the topmost of group is same as topmost
     * (true for all cases except where rearranging subtree of group)
     */
    pwndTopInsert = pwndInsertAfter;
    if (pwndInsertAfter == (PWND)HWND_TOP) {

        /*
         * Bring the whole group to the top: nothing fancy to do.
         */

    } else if (pwndInsertAfter == (PWND)HWND_BOTTOM) {

        /*
         * Put the whole group on the bottom. pwndTopInsert should
         * be the bottommost window unowned by pwndOwnerRoot.
         */
        for (pwndT = pwnd->spwndParent->spwndChild;
                (pwndT != NULL) && !TestWF(pwndT, WFBOTTOMMOST); pwndT = pwndT->spwndNext) {

            /*
             * If it's not owned, then this is the bottommost so far.
             */
            if (!IsOwnee(pwndT, pwndOwnerRoot))
                pwndTopInsert = pwndT;
        }

        /*
         * If there were no other windows not in our tree,
         * then there is no Z ordering change to be done.
         */
        if (pwndTopInsert == (PWND)HWND_BOTTOM)
            ppos->flags |= SWP_NOZORDER;

    } else {

        /*
         * pwndInsertAfter is a window. Compute pwndTopInsert
         */
        if (IsOwnee(pwndInsertAfter, pwndOwnerRoot)) {

            /*
             * SPECIAL CASE: If we do not own any windows, and we're
             * being moved within our owner group in such a way that
             * we remain above our owner, then no other windows will
             * be moving with us, and we can just exit
             * without building our tree. This can save a LOT of
             * extra work, especially with the MS apps CBT tutorials,
             * which do this kind of thing a lot.
             */
            if (!fHasOwnees) {

                /*
                 * Make sure we will still be above our owner by searching
                 * for our owner starting from pwndInsertAfter. If we
                 * find our owner, then pwndInsertAfter is above it.
                 */
                for (pwndT = pwndInsertAfter; pwndT != NULL;
                        pwndT = pwndT->spwndNext) {

                    if (pwndT == pwnd->spwndOwner)
                        return psmwp;
                }
            }

            /*
             * Part of same group: Find out which window the topmost
             * of the group is currently inserted behind.
             */
            pwndTopInsert = (PWND)HWND_TOP;
            for (pwndT = pwnd->spwndParent->spwndChild; pwndT != NULL;
                    pwndT = pwndT->spwndNext) {

                if (IsOwnee(pwndT, pwndOwnerRoot))
                    break;

                pwndTopInsert = pwndT;
            }
        }
    }

    /*
     * Okay, now go recursively build the owned window list...
     */
    if (!(ppos->flags & SWP_NOZORDER)) {

        /*
         * First "delete" the last entry (the one we're sorting with)
         */
        psmwp->ccvr--;

        psmwp = AddSelfAndOwnees(psmwp,
                                 pwndOwnerRoot,
                                 pwnd,
                                 pwndInsertAfter,
                                 iTop);

        /*
         * Now set the place where the whole group is going.
         */
        if (psmwp != NULL)
            psmwp->acvr[iTop].pos.hwndInsertAfter = HW(pwndTopInsert);
    }

    return psmwp;
}

/***************************************************************************\
* TrackBackground
*
* Adjust zorder if we're crossing a TOPMOST boundary. Make sure that a
* non-topmost window in a background thread doesn't come in front of
* non-topmost windows in the foreground thread.
\***************************************************************************/

BOOL TrackBackground(WINDOWPOS *ppos, PWND pwndPrev, PWND pwnd)
{
    PWND pwndT;

    if (pwndPrev == NULL)
        return FALSE;

    /*
     * Is this window foreground? If so, let it go. For wow apps,
     * check to see if any thread of the process is foreground.
     */
    if (GETPTI(pwnd)->TIF_flags & TIF_16BIT) {

        if (gptiForeground == NULL)
            return FALSE;

        if (GETPTI(pwnd)->ppi == gptiForeground->ppi)
            return FALSE;

    } else {

        if (GETPTI(pwnd) == gptiForeground)
            return FALSE;
    }

    /*
     * Make sure the previous window is either staying or becoming
     * topmost. If not, continue: no top most boundary.
     */
    if (!FSwpTopmost(pwndPrev))
        return FALSE;

    /*
     * Is the current window already top-most? If so then don't
     * calculate a special insert after. If we don't check for
     * this, then pwnd's insert after may be calculated as what
     * pwnd already is, if pwnd is the last top most window. That
     * would cause window links to get corrupted.
     */
    if (TestWF(pwnd, WEFTOPMOST))
        return FALSE;

    /*
     * Doing this assign prevents this routine from being called
     * twice, since HW() is a conditional macro.
     */
    pwndT = CalcForegroundInsertAfter(pwnd);
    ppos->hwndInsertAfter = HW(pwndT);
    return TRUE;
}

/***************************************************************************\
* TrackZorder, TrackZorderHelper
*
* Set up hwndInsertAfter links to point to the previous window in the
* CVR array and partition them in TOPMOST and non-TOPMOST chains.
*
* 05/16/97      vadimg      created
\***************************************************************************/
VOID TrackZorderHelper(
    WINDOWPOS *ppos,
    HWND *phwnd)
{
    /*
     * phwnd (hwndTopmost or hwndRegular) have been initialized to NULL before
     * the beginning of the scan. This way the first hwndInsertAfter that
     * we process remains with the value that was previously calculated.
     */
    if (*phwnd != NULL) {

#if DBG
        if (ppos->hwndInsertAfter != *phwnd) {
            RIPMSG0(RIP_WARNING, "TrackZorder: modified hwndInsertAfter");
        }
#endif

        ppos->hwndInsertAfter = *phwnd;
    }
    *phwnd = ppos->hwnd;
}

PWND TrackZorder(
    WINDOWPOS* ppos,
    PWND pwndPrev,
    HWND *phwndTop,
    HWND *phwndReg)
{
    PWND pwnd = PW(ppos->hwnd);

    if (pwnd == NULL)
        return NULL;

    if (TrackBackground(ppos, pwndPrev, pwnd)) {
        *phwndReg = ppos->hwnd;
    } else if (FSwpTopmost(pwnd)) {
        TrackZorderHelper(ppos, phwndTop);
    } else {
        TrackZorderHelper(ppos, phwndReg);
    }

    return pwnd;
}

/***************************************************************************\
* ZOrderByOwner
*
* This routine Z-Orders windows by their owners.
*
* LATER
* This code currently assumes that all of the window handles are valid
*
* History:
* 04-Mar-1992 MikeKe      from win31
\***************************************************************************/

PSMWP ZOrderByOwner(
    PSMWP psmwp)
{
    int         i;
    PWND        pwnd;
    PWND        pwndT;
    WINDOWPOS   pos;
    PTHREADINFO ptiT;
    HRGN        hrgnClipSave;

    /*
     * Some of the windows in the SMWP list may be NULL at ths point
     * (removed because they'll be handled by their creator's thread)
     * so we've got to look for the first non-NULL window before we can
     * execute some of the tests below. FindValidWindowPos returns NULL if
     * the list has no valid windows in it.
     */
    if (FindValidWindowPos(psmwp) == NULL)
        return psmwp;

    /*
     * For each SWP in the array, move it to the end of the array
     * and generate its entire owner tree in sorted order.
     */
    for (i = psmwp->ccvr; i-- != 0; ) {

        int       iScan;
        int       iTop;
        int       code;
        WINDOWPOS *ppos;
        HWND      hwndTopmost;
        HWND      hwndRegular;

        if (psmwp->acvr[0].pos.hwnd == NULL)
            continue;

        code = CheckTopmost(&psmwp->acvr[0].pos);

        /*
         * Make a local copy for later...
         *
         * Why don't we copy all CVR fields? This seems pretty hard to maintain.
         * Perhaps because most of them haven't been used yet....
         *
         */
        pos  = psmwp->acvr[0].pos;
        ptiT = psmwp->acvr[0].pti;
        hrgnClipSave = psmwp->acvr[0].hrgnClip;

        /*
         * Move the CVR to the end (if it isn't already)
         */
        iTop = psmwp->ccvr - 1;

        if (iTop != 0) {

            RtlCopyMemory(&psmwp->acvr[0],
                          &psmwp->acvr[1],
                          iTop * sizeof(CVR));

            psmwp->acvr[iTop].pos = pos;
            psmwp->acvr[iTop].pti = ptiT;
            psmwp->acvr[iTop].hrgnClip = hrgnClipSave;
        }

        if ((psmwp = ZOrderByOwner2(psmwp, iTop)) == NULL)
            break;

        /*
         * Deal with WEFTOPMOST bits. If we're SETTING the TOPMOST bits,
         * we want to set them for this window and
         * all its owned windows -- the owners stay unchanged. If we're
         * CLEARING, though, we need to enumerate ALL the windows, since
         * they all need to lose the topmost bit when one loses it.
         *
         * Note that since a status change doesn't necessarily mean that
         * the true Z order of the windows have changed, so ZOrderByOwner2
         * may not have enumerated all of the owned and owner windows.
         * So, we enumerate them separately here.
         */
        if (code != CTM_NOCHANGE) {
            PWND pwndRoot = PW(pos.hwnd);
#if DBG
            PWND pwndOriginal = pwndRoot;
#endif

            /*
             * Make sure we're z-ordering this window, or settting topmost
             * is bad.
             */
            UserAssert(!(pos.flags & SWP_NOZORDER));

            /*
             * If we're CLEARING the topmost, then we want to enumerate
             * the owners and ownees, so start our enumeration at the root.
             */
            if (code == CTM_NOTOPMOST) {

                while (pwnd = GetRealOwner(pwndRoot))
                    pwndRoot = pwnd;
            }

#if DBG
            if ((pos.flags & SWP_NOOWNERZORDER)
                && ((pwndOriginal != pwndRoot)
                    || (NextOwnedWindow(NULL, pwndRoot, pwndRoot->spwndParent) != NULL))) {
                /*
                 * We're not doing owner z-order but pwndOriginal has an owner and/or
                 * owns some windows. The problem is, SetTopMost always affects the
                 * whole owner/ownee group. So we might end up with WFTOGGLETOPMOST
                 * windows that won't be z-ordered. It has always been like that.
                 */
                RIPMSG2(RIP_WARNING, "ZOrderByOwner: Topmost change while using SWP_NOOWNERZORDER."
                                     " pwndRoot:%p  pwndOriginal:%p",
                                     pwndRoot, pwndOriginal);
            }
#endif

            SetTopmost(pwndRoot, code == CTM_TOPMOST);
        }

        /*
         * Now scan the list forwards (from the bottom of the
         * owner tree towards the root) looking for the window
         * we were positioning originally (it may have been in
         * the middle of the owner tree somewhere). Update the
         * window pos structure stored there with the original
         * information (though the z-order info is retained from
         * the sort).
         */
        pwnd = NULL;
        hwndTopmost = hwndRegular = NULL;
        for (iScan = iTop; iScan != psmwp->ccvr; iScan++) {

            ppos = &psmwp->acvr[iScan].pos;

            if (ppos->hwnd == pos.hwnd) {
                ppos->x      = pos.x;
                ppos->y      = pos.y;
                ppos->cx     = pos.cx;
                ppos->cy     = pos.cy;
                ppos->flags ^= ((ppos->flags ^ pos.flags) & ~SWP_NOZORDER);
                psmwp->acvr[iScan].hrgnClip = hrgnClipSave;
            }

            pwndT = pwnd;
            pwnd  = TrackZorder(ppos, pwndT, &hwndTopmost, &hwndRegular);
        }
    }

    return psmwp;
}

/***************************************************************************\
* xxxEndDeferWindowPosEx
*
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL xxxEndDeferWindowPosEx(
    PSMWP psmwp,
    BOOL  fAsync)
{
    PWND        pwndNewActive;
    PWND        pwndParent;
    PWND        pwndActive;
    PWND        pwndActivePrev;
    HWND        hwndNewActive;
    PWINDOWPOS  pwp;
    BOOL        fClearBits;
    BOOL        fSyncPaint;
    UINT        cVisWindowsPrev;
    PTHREADINFO ptiCurrent = PtiCurrent();
    TL          tlpwndNewActive;
    TL          tlpwndParent;
    TL          tlcuSMWP;
    BOOL        fForegroundPrev;

    UserAssert(IsWinEventNotifyDeferredOK());

    DBGCheckSMWP(psmwp);
    if (psmwp->bHandle) {
        CheckLock(psmwp);
    }

    /*
     * Validate the window pos structures and find a window to activate.
     */
    if ((psmwp->ccvr != 0) && ValidateSmwp(psmwp, &fSyncPaint)) {

        if ((pwp = FindValidWindowPos(psmwp)) == NULL)
            goto lbFinished;

        /*
         * Make sure to stop at the mother desktop window. In Win95
         * a SetWindowPos() on a desktop window will have a NULL parent
         * window. This is not true in NT, but our mother desktop
         * window does have a NULL rpdesk, so check it too.
         */
        UserAssert(PW(pwp->hwnd));
        pwndParent = PW(pwp->hwnd)->spwndParent;
        if (pwndParent == NULL || pwndParent->head.rpdesk == NULL)
            goto lbFinished;

        /*
         * Usually all window positioning happens synchronously across threads.
         * This is because apps expect that behavior now - if it was async,
         * callers could not expect the state to be set once the api returned.
         * This is not the semantics of SetWindowPos(). The downside of this
         * synchronicity is that a SetWindowPos() on an hwnd created by another
         * thread will cause the caller to wait for that thread - even if that
         * thread is hung. That's what you get.
         *
         * We don't want task manager to hang though, no matter who else is
         * hung, so when taskman calls, it calls a special entry point for
         * tiling / cascading, which does SetWindowPos() asynchronously -
         * by posting an event in each thread's queue that makes it set its
         * own window position - that way if the thread is hung, who cares -
         * it doesn't effect taskman.
         *
         * Do async window pos positioning before zorder by owner so that
         * we retain any cross thread ownership relationships synchronously.
         */
        if (fAsync) {
            AsyncWindowPos(psmwp);
        }

        /*
         * If needed, Z order the windows by owner.
         * This may grow the SMWP, if new CVRs are added.
         */
        if (pwndParent == PWNDDESKTOP(pwndParent)) {

            if ((psmwp = ZOrderByOwner(psmwp)) == NULL) {
                return FALSE;
            } else if (fAsync) {
                if (!ValidateSmwp(psmwp, &fSyncPaint)) {
                    goto lbFinished;
                }
                /*
                 * ZOrderByOwner() could possibly add other thread windows to the
                 * list. Filter them again else we would hung.
                 */
                 AsyncWindowPos(psmwp);
            }
        }

        ThreadLockAlwaysWithPti(ptiCurrent, pwndParent, &tlpwndParent);
        ThreadLockPoolCleanup(ptiCurrent, psmwp, &tlcuSMWP, DestroySMWP);

        /*
         * Calc new window positions.
         */
        if (xxxCalcValidRects(psmwp, &hwndNewActive)) {

            int i;

            pwndNewActive = RevalidateHwnd(hwndNewActive);

            ThreadLockWithPti(ptiCurrent, pwndNewActive, &tlpwndNewActive);

            cVisWindowsPrev = ptiCurrent->cVisWindows;
            fForegroundPrev = (ptiCurrent == gptiForeground);

            /*
             * The call to zzzBltValidBits will leave the critical section
             * if there are any notifications to make.
             */
            UserAssert(IsWinEventNotifyDeferredOK());
            if (!zzzBltValidBits(psmwp))
                fSyncPaint = FALSE;
            UserAssert(IsWinEventNotifyDeferredOK());

            if (psmwp->bShellNotify) {
                for (i = psmwp->ccvr; i-- != 0; ) {
                    /*
                     * Loop through the windows, looking for notifications.
                     */

                    if (0 == (psmwp->acvr[i].pos.flags & SWP_NOTIFYALL))
                        continue;

                    if (psmwp->acvr[i].pos.flags & SWP_NOTIFYCREATE) {
                          PostShellHookMessages(HSHELL_WINDOWCREATED,
                                    (LPARAM)psmwp->acvr[i].pos.hwnd);

                          xxxCallHook(HSHELL_WINDOWCREATED,
                            (WPARAM)psmwp->acvr[i].pos.hwnd,
                            (LPARAM)0,
                            WH_SHELL);
                    }

                    if (psmwp->acvr[i].pos.flags & SWP_NOTIFYDESTROY) {
                        PostShellHookMessages(HSHELL_WINDOWDESTROYED,
                                      (LPARAM)psmwp->acvr[i].pos.hwnd);

                        xxxCallHook(HSHELL_WINDOWDESTROYED,
                            (WPARAM)psmwp->acvr[i].pos.hwnd,
                            (LPARAM)0,
                            WH_SHELL);
                    }

                    if (psmwp->acvr[i].pos.flags & SWP_NOTIFYACTIVATE) {
                        PWND pwnd = RevalidateHwnd(psmwp->acvr[i].pos.hwnd);
                        if (pwnd != NULL){
                            TL tlpwnd;
                            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);
                            xxxSetTrayWindow(pwnd->head.rpdesk, pwnd, NULL);
                            ThreadUnlock(&tlpwnd);
                        }
                    }

                    if (psmwp->acvr[i].pos.flags & SWP_NOTIFYFS) {
                        xxxSetTrayWindow(ptiCurrent->rpdesk, STW_SAME, NULL);
                    }
                }
            }


            /*
             * If this process went from some windows to no windows visible
             * and it was in the foreground, then let its next activate
             * come to the foreground.
             */
            if (fForegroundPrev && cVisWindowsPrev && !ptiCurrent->cVisWindows) {

                ptiCurrent->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
                TAGMSG1(DBGTAG_FOREGROUND, "xxxEndDeferWindowPosEx set TIF %#p", ptiCurrent);

                /*
                 * Also if any apps were in the middle of starting when
                 * this happened, allow them to foreground activate again.
                 */
                RestoreForegroundActivate();
            }

            /*
             * Deal with any activation...
             */
            fClearBits = FALSE;
            if (pwndNewActive != NULL) {
                fClearBits = xxxSwpActivate(pwndNewActive);
            }

            /*
             * Now draw frames and erase backgrounds of all the windows
             * involved.
             */
            UserAssert(pwndParent);
            if (fSyncPaint) {
                xxxDoSyncPaint(pwndParent, DSP_ENUMCLIPPEDCHILDREN);
            }

            ThreadUnlock(&tlpwndNewActive);

            /*
             * If SwpActivate() set the NONCPAINT bits, clear them now.
             */
            if (fClearBits) {
                if (pwndActive = ptiCurrent->pq->spwndActive) {
                    ClrWF(pwndActive, WFNONCPAINT);
                }

                if (pwndActivePrev = ptiCurrent->pq->spwndActivePrev) {
                    ClrWF(pwndActivePrev, WFNONCPAINT);
                }
            }

            /*
             * Send WM_WINDOWPOSCHANGED messages
             */
            xxxSendChangedMsgs(psmwp);
        }

        ThreadUnlockPoolCleanup(ptiCurrent, &tlcuSMWP);
        ThreadUnlock(&tlpwndParent);
    }

lbFinished:

    /*
     * All done. Free everything up and return.
     */
    DestroySMWP(psmwp);
    return TRUE;
}


/***************************************************************************\
* IncVisWindows
* DecVisWindows
*
* These routines deal with incrementing/decrementing the visible windows
* on the thread.
*
\***************************************************************************/
#if DBG

BOOL gfVisVerify = FALSE;

VOID VerifycVisWindows(
    PWND pwnd)
{
    BOOL fShowMeTheWindows = FALSE;
    PTHREADINFO pti = GETPTI(pwnd);
    PWND pwndNext;
    UINT uVisWindows = 0;

    if (!gfVisVerify) {
        return;
    }

    /*
     * Make sure the count makes sense
     */
    if ((int)pti->cVisWindows < 0) {
        RIPMSG0(RIP_ERROR, "VerifycVisWindows: pti->cVisWindows underflow!");
        fShowMeTheWindows = TRUE;
    }

    /*
     * This window might be owned by a desktop-less service
     */
    if (pti->rpdesk == NULL || (pti->TIF_flags & TIF_SYSTEMTHREAD)) {
        return;
    }

    /*
     * Child windows don't affect cVisWindows
     */
    if (!FTopLevel(pwnd)) {
        return;
    }

ShowMeTheWindows:
    /*
     * We're going to count all the windows owned by this pti
     * that should be included in cVisWindows.
     */
    pwndNext = pti->rpdesk->pDeskInfo->spwnd;
    /*
     * If this is a top level window, start with the first child.
     * If not, it should be a desktop thread window.
     */
    if (pwndNext == pwnd->spwndParent) {
        pwndNext = pwndNext->spwndChild;
    } else if (pwndNext->spwndParent != pwnd->spwndParent) {
        RIPMSG1(RIP_WARNING, "VerifycVisWindows: Non top level window:%#p", pwnd);
        return;
    }

    if (fShowMeTheWindows) {
        RIPMSG1(RIP_WARNING, "VerifycVisWindows: Start window walk at:%#p", pwndNext);
    }

    /*
     * Count the visble-not-minimized windows owned by this pti.
     */
    while (pwndNext != NULL) {
        if (pti == GETPTI(pwndNext)) {
            if (fShowMeTheWindows) {
                RIPMSG1(RIP_WARNING, "VerifycVisWindows: pwndNext:%#p", pwndNext);
            }
            if (!TestWF(pwndNext, WFMINIMIZED)
                    && TestWF(pwndNext, WFVISIBLE)) {

                uVisWindows++;

                if (fShowMeTheWindows) {
                    RIPMSG1(RIP_WARNING, "VerifycVisWindows: Counted:%#p", pwndNext);
                }
            }
        }
        pwndNext = pwndNext->spwndNext;
    }

    /*
     * It must match.
     */
    if (pti->cVisWindows != uVisWindows) {
        RIPMSG2(RIP_WARNING, "VerifycVisWindows: pti->cVisWindows:%#lx. uVisWindows:%#lx",
                pti->cVisWindows, uVisWindows);

        /*
         * Disable going through the list and make the error into a warning.
         * There are many loopholes as to how the cVisWindow count may get
         * messed up. See bug 109807.
         */
        fShowMeTheWindows = TRUE;

        if (!fShowMeTheWindows) {
            fShowMeTheWindows = TRUE;
            uVisWindows = 0;
            goto ShowMeTheWindows;
        }
    }
}
#endif

/***************************************************************************\
* FVisCountable
*
* Desktops and top-level i.e. whose parent is the desktop) non-minimized
* windows should be counted in the per-thread visible window counts.
\***************************************************************************/
BOOL FVisCountable(
    PWND pwnd)
{
    if (!TestWF(pwnd, WFDESTROYED)) {
        if ((GETFNID(pwnd) == FNID_DESKTOP) ||
                (FTopLevel(pwnd) && !TestWF(pwnd, WFMINIMIZED))) {
            return TRUE;
        }
    }

    return FALSE;
}

/***************************************************************************\
* IncVisWindows
*
\***************************************************************************/
VOID IncVisWindows(
    PWND pwnd)
{
    if (FVisCountable(pwnd)) {
        GETPTI(pwnd)->cVisWindows++;
    }

    if (TestWF(pwnd, WEFPREDIRECTED)) {
        gnVisibleRedirectedCount++;
        if (gnVisibleRedirectedCount == 1) {
            InternalSetTimer(gTermIO.spwndDesktopOwner,
                             IDSYS_LAYER,
                             100,
                             xxxSystemTimerProc,
                             TMRF_SYSTEM | TMRF_PTIWINDOW);
        }
    }

#if DBG
    if (!ISTS()) {
        VerifycVisWindows(pwnd);
    }
#endif
}

/***************************************************************************\
* cDecVis
*
* An inline that allows debug code to decrement the vis window count
* without doing verification right away. Also alled by DecVisWindows
* to do the actual work.
\***************************************************************************/
__inline VOID cDecVis(
    PWND pwnd)
{
    UserAssert(pwnd != NULL);

    if (FVisCountable(pwnd)) {
        GETPTI(pwnd)->cVisWindows--;
    }

    if (TestWF(pwnd, WEFPREDIRECTED)) {
        if (gnVisibleRedirectedCount > 0) {
            gnVisibleRedirectedCount--;
            if (gnVisibleRedirectedCount == 0) {
                _KillSystemTimer(gTermIO.spwndDesktopOwner, IDSYS_LAYER);
            }
        }
    }
}

/***************************************************************************\
* DecVisWindows
*
\***************************************************************************/
VOID DecVisWindows(
    PWND pwnd)
{
    cDecVis(pwnd);

#if DBG
    if (!ISTS()) {
        VerifycVisWindows(pwnd);
    }
#endif
}

/***************************************************************************\
* SetMiminize
*
* This routine must be used to flip the WS_MIMIMIZE style bit.
* It adjusts the cVisWindows count if appropriate.
*
* 06/06/96  GerardoB Created
\***************************************************************************/
VOID SetMinimize(
    PWND pwnd,
    UINT uFlags)
{
    /*
     * Note that Dec and IncVisWindows check the WFMINIMIZED flag, so the order
     * in which we set/clear the flag and call these functions is important.
     *
     * If the window is not WFVISIBLE, cVisWindows must not change.
     */
    if (uFlags & SMIN_SET) {
        UserAssert(!TestWF(pwnd, WFMINIMIZED));
        if (TestWF(pwnd, WFVISIBLE)) {
            /*
             * Decrement the count because the window is not minimized
             * and visible, and we're about to mark it as minimized.
             */

#if DBG
            cDecVis(pwnd);
#else
            DecVisWindows(pwnd);
#endif
        }
        SetWF(pwnd, WFMINIMIZED);

#if DBG
        VerifycVisWindows(pwnd);
#endif
    } else {
        UserAssert(TestWF(pwnd, WFMINIMIZED));
        ClrWF(pwnd, WFMINIMIZED);
        if (TestWF(pwnd, WFVISIBLE)) {
            /*
             * Increment the count because the window is visible
             * and it's no longer marked as minimized.
             */
            IncVisWindows(pwnd);
        }
    }
}

/***************************************************************************\
* SetVisible
*
* This routine must be used to set or clear the WS_VISIBLE style bit.
* It also handles the setting or clearing of the WF_TRUEVIS bit.
*
* Note that we don't check if the window is already in the (in)visible
* state before setting/clearing the WFVISIBLE bit and calling
* Inc/DecVisWindows. If the window is already in the given state and
* someone calls SetVisible to change into the same state, the VisCount
* will get out of sync. This could happen, for example, if someone
* passed two SWP_SHOWWINDOW for the same hwnd CVR's in the same
* EndDeferWindowPos call. It would be ideal to do the check here, but
* most of the time the caller does the check and we don't want to
* penalize everybody just because of the weird cases.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
VOID SetVisible(
    PWND pwnd,
    UINT flags)
{
#ifdef REDIRECTION
    PDESKTOP pdesk = pwnd->head.rpdesk;
#endif

    if (flags & SV_SET) {
        if (TestWF(pwnd, WFINDESTROY)) {
            RIPMSG1(RIP_WARNING, "SetVisible: show INDESTROY 0x%p", pwnd);
        }

        if (TestWF(pwnd, WFVISIBLE)) {
            RIPMSG1(RIP_WARNING, "SetVisible: already visible 0x%p", pwnd);
        } else {
            SetWF(pwnd, WFVISIBLE);
            IncVisWindows(pwnd);

#ifdef REDIRECTION
            if (((pdesk != NULL && (pdesk->dwDTFlags & DF_REDIRECTED)
                && !(GETPTI(pwnd)->ppi->dwRedirection & PF_REDIRECTIONHOST))
                || (GETPTI(pwnd)->ppi->dwRedirection & PF_REDIRECTED))
                &&  FTopLevel(pwnd)) {
                SetRedirectedWindow(pwnd, REDIRECT_EXTREDIRECTED);
                SetWF(pwnd, WEFEXTREDIRECTED);
            }
#endif
        }
    } else {
        if (flags & SV_CLRFTRUEVIS) {
            ClrFTrueVis(pwnd);
        }

        if (TestWF(pwnd, WFDESTROYED)) {
            RIPMSG1(RIP_WARNING, "SetVisible: hide DESTROYED 0x%p", pwnd);
        }

        if (TestWF(pwnd, WFVISIBLE)) {
            ClrWF(pwnd, WFVISIBLE);
            DecVisWindows(pwnd);

#ifdef REDIRECTION
            if (((pdesk != NULL && (pdesk->dwDTFlags & DF_REDIRECTED)
                && !(GETPTI(pwnd)->ppi->dwRedirection & PF_REDIRECTIONHOST))
                || (GETPTI(pwnd)->ppi->dwRedirection & PF_REDIRECTED))
                &&  FTopLevel(pwnd)) {
                UnsetRedirectedWindow(pwnd, REDIRECT_EXTREDIRECTED);
                ClrWF(pwnd, WEFEXTREDIRECTED);
            }
#endif
        } else {
            RIPMSG1(RIP_WARNING, "SetVisible: already hidden 0x%p", pwnd);
        }
    }
}

/***************************************************************************\
* IsMaxedRect
*
* Determines if a window is "maximizing" to a certain area
*
* History:
\***************************************************************************/
BOOL IsMaxedRect(
    LPRECT      lprcWithin,
    PCSIZERECT  psrcMaybe)
{
    return(psrcMaybe->x <= lprcWithin->left                      &&
           psrcMaybe->y <= lprcWithin->top                       &&
           psrcMaybe->cx >= lprcWithin->right - lprcWithin->left &&
           psrcMaybe->cy >= lprcWithin->bottom - lprcWithin->top);
}

/***************************************************************************\
* xxxCheckFullScreen
*
* Sees if a window is really fullscreen or just a maximized window in
* disguise. If the latter, it will be forced to the proper maximized
* size.
*
* This is called from both CalcValidRects() and CreateWindowEx().
*
* History:
\***************************************************************************/
BOOL xxxCheckFullScreen(
    PWND        pwnd,
    PSIZERECT   psrc)
{
    BOOL            fYielded = FALSE;
    PMONITOR        pMonitor;
    PMONITOR        pMonitorPrimary;
    TL              tlpMonitor;
    RECT            rc;
    BOOL            fIsPrimary;


    CheckLock(pwnd);

    /*
     * SINCE THIS IS ONLY CALLED IN 2 PLACES, make the checks there
     * instead of the overhead of calling this function in time critical
     * places.
     *
     * If 3 or more places call it, put the child/toolwindow checks here
     */
    UserAssert(!TestWF(pwnd, WFCHILD));
    UserAssert(!TestWF(pwnd, WEFTOOLWINDOW));

    pMonitorPrimary = GetPrimaryMonitor();
    if (gpDispInfo->cMonitors == 1) {
        pMonitor = pMonitorPrimary;
    } else {
        /*
         * In multiple monitor mode, windows that take up the entire
         * virtual screen are not considered 'full screen'. 'Full screen'
         * means full single monitor only. This detection is so that any
         * docked bars--tray, office'95 tools--can get out of the way for
         * the application.
         *
         * There are only three types of windows that ought to go full
         * virtual screen. None of them need the tray et al. to get out of
         * the way:
         *      (1) Normal app windows that want a lot of space
         *          * Those guys just activate and deactivate normally.
         *      (2) Desktop windows
         *          * Shell, User desktop sit behind everything else.
         *      (3) Screen savers, demos, etc.
         *          * These guys should be WS_EX_TOPMOST to ensure they sit
         *            over everybody.
         */
        if (IsMaxedRect(&gpDispInfo->rcScreen, psrc))
            return fYielded;

        RECTFromSIZERECT(&rc, psrc);
        pMonitor = _MonitorFromRect(&rc, MONITOR_DEFAULTTOPRIMARY);
    }

    fIsPrimary = (pMonitor == pMonitorPrimary);
    ThreadLockAlways(pMonitor, &tlpMonitor);

    if (IsMaxedRect(&pMonitor->rcWork, psrc)) {
        if (TestWF(pwnd, WFMAXIMIZED)) {
            SetWF(pwnd, WFREALLYMAXIMIZABLE);

            if (gpDispInfo->cMonitors > 1) {
                /*
                 * This is for XL '95 going fullscreen when already maxed. It
                 * always uses the primary display. Let's hack them, and any
                 * other old app that tries to move its truly maximized window.
                 * They will be clipped otherwise by our fake regional stuff.
                 */
                PMONITOR pMonitorReal;

                pMonitorReal = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
                if (pMonitorReal != pMonitor && fIsPrimary) {
                    /*
                     * Transfer over the shape to the REAL monitor.
                     */
                    psrc->x += pMonitorReal->rcMonitor.left;
                    psrc->y  += pMonitorReal->rcMonitor.top;
                    psrc->cx -= (pMonitor->rcMonitor.right - pMonitor->rcMonitor.left) +
                        (pMonitorReal->rcMonitor.right - pMonitorReal->rcMonitor.left);

                    psrc->cy -= (pMonitor->rcMonitor.bottom - pMonitor->rcMonitor.top) +
                        (pMonitorReal->rcMonitor.bottom - pMonitorReal->rcMonitor.top);

                    ThreadUnlock(&tlpMonitor);
                    pMonitor = pMonitorReal;
                    fIsPrimary = FALSE;
                    ThreadLockAlways(pMonitor, &tlpMonitor);
                }
            }
        }

        if (    TestWF(pwnd, WFMAXIMIZED) &&
                TestWF(pwnd, WFMAXBOX)    &&
                (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION))) {

            if (    psrc->y + SYSMET(CYCAPTION) <= pMonitor->rcMonitor.top &&
                    psrc->y + psrc->cy >= pMonitor->rcMonitor.bottom) {

                if (!TestWF(pwnd, WFFULLSCREEN)) {
                    /*
                     * Only want to do full screen stuff on the tray
                     * monitor.
                     */
                    fYielded = xxxAddFullScreen(pwnd, pMonitor);
                }
            } else {
                int iRight;
                int iBottom;
                int dxy;

                if (TestWF(pwnd, WFFULLSCREEN)) {
                    fYielded = xxxRemoveFullScreen(pwnd, pMonitor);
                }

                /*
                 * Despite the code in GetMinMaxInfo() to fix up
                 * the max rect, we still have to hack old apps.
                 * Word '95 & XL '95 do weird things when going to/from
                 * full screen when maximized already.
                 *
                 * NOTE:  you can have more than one docked bar on a
                 * monitor. Win '95 code doesn't work right in that
                 * case.
                 */
                dxy = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
                dxy *= SYSMET(CXBORDER);

                psrc->x = pMonitor->rcWork.left - dxy;
                psrc->y = pMonitor->rcWork.top - dxy;

                dxy *= 2;
                iRight = pMonitor->rcWork.right - pMonitor->rcWork.left + dxy;
                iBottom = pMonitor->rcWork.bottom - pMonitor->rcWork.top + dxy;

                /*
                 * Let console windows maximze smaller than defaults.
                 */
                if (pwnd->pcls->atomClassName == gatomConsoleClass) {
                    psrc->cx = min(iRight, psrc->cx);
                    psrc->cy = min(iBottom, psrc->cy);
                } else {
                    psrc->cx = iRight;

                    /*
                     * B#14012 save QuickLink II that wants 4 pixels hanging off
                     * the screen for every edge except the bottom edge, which
                     * they only want to overhang by 2 pixels -- jeffbog 5/17/95
                     *
                     * BUT THIS CODE DOESN'T WORK FOR MULTIPLE MONITORS, so don't
                     * do it on secondary dudes. Else, XL '95 flakes out.
                     */
                    if (fIsPrimary && !TestWF(pwnd, WFWIN40COMPAT)) {
                        psrc->cy = min(iBottom, psrc->cy);
                    } else {
                        psrc->cy = iBottom;
                    }
                }
            }
        } else if (IsMaxedRect(&pMonitor->rcMonitor, psrc)) {
            fYielded = xxxAddFullScreen(pwnd, pMonitor);
        }
    } else {
        if (TestWF(pwnd, WFMAXIMIZED)) {
            ClrWF(pwnd, WFREALLYMAXIMIZABLE);
        }

        fYielded = xxxRemoveFullScreen(pwnd, pMonitor);
    }

    ThreadUnlock(&tlpMonitor);
    return fYielded;
}

/***************************************************************************\
* ClrFTrueVis
*
* Called when making a window invisible. This routine destroys any update
* regions that may exist, and clears the WF_TRUEVIS of all windows below
* the passed in window.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
VOID ClrFTrueVis(
    PWND pwnd)
{
    /*
     * Destroy pwnd and its children's update regions.
     * We do this here to guarantee that a hidden window
     * and its children don't have update regions.
     *
     * This fixes bugs when destroying windows that have
     * update regions (SendDestroyMessages) among others
     * and allows us to simplify SetParent(). This was
     * deemed better than hacking DoPaint() and/or
     * DestroyWindow().
     *
     * We can stop recursing when we find a window that doesn't
     * have the visible bit set, because by definition it won't
     * have any update regions below it (this routine will have been called)
     */
    if (NEEDSPAINT(pwnd)) {

        DeleteMaybeSpecialRgn(pwnd->hrgnUpdate);

        ClrWF(pwnd, WFINTERNALPAINT);

        pwnd->hrgnUpdate = NULL;
        DecPaintCount(pwnd);
    }

    for (pwnd = pwnd->spwndChild; pwnd != NULL; pwnd = pwnd->spwndNext) {

        /*
         * pwnd->fs &= ~WF_TRUEVIS;
         */
        if (TestWF(pwnd, WFVISIBLE))
            ClrFTrueVis(pwnd);
    }
}

/***************************************************************************\
* OffsetChildren
*
* Offsets the window and client rects of all children of hwnd.
* Also deals with the children's update regions and SPB rects.
*
* History:
* 22-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
VOID OffsetChildren(
    PWND   pwnd,
    int    dx,
    int    dy,
    LPRECT prcHitTest)
{
    RECT    rc;
    PWND    pwndStop;

    if (!pwnd->spwndChild)
        return;

    pwndStop = pwnd;
    pwnd = pwndStop->spwndChild;
    for (;;) {
        /*
         * Skip windows that don't intersect prcHitTest...
         */
        if (prcHitTest && !IntersectRect(&rc, prcHitTest, &pwnd->rcWindow))
            goto NextWindow;

        pwnd->rcWindow.left   += dx;
        pwnd->rcWindow.right  += dx;
        pwnd->rcWindow.top    += dy;
        pwnd->rcWindow.bottom += dy;

        pwnd->rcClient.left   += dx;
        pwnd->rcClient.right  += dx;
        pwnd->rcClient.top    += dy;
        pwnd->rcClient.bottom += dy;

        if (pwnd->hrgnUpdate > HRGN_FULL && !TestWF(pwnd, WFMAXFAKEREGIONAL)) {
            GreOffsetRgn(pwnd->hrgnUpdate, dx, dy);
        }

        /*
         * Change position of window region, if it has one
         */
        if (pwnd->hrgnClip != NULL)
            GreOffsetRgn(pwnd->hrgnClip, dx, dy);

        if (TestWF(pwnd, WFHASSPB))
            OffsetRect(&(FindSpb(pwnd))->rc, dx, dy);

#ifdef CHILD_LAYERING
        if (TestWF(pwnd, WEFLAYERED)) {
            POINT ptPos = {pwnd->rcWindow.left, pwnd->rcWindow.top};

            GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL,
                    &ptPos, NULL, NULL, NULL, 0, NULL, 0, NULL);
        }
#endif // CHILD_LAYERING

        /*
         * Recurse into the child tree if there are children.
         */
        if (pwnd->spwndChild) {
            pwnd = pwnd->spwndChild;
            continue;
        }

NextWindow:
        if (pwnd->spwndNext) {
            /*
             * Recurse to the next sibling in the list.
             */
            pwnd = pwnd->spwndNext;
        } else {
            for (;;) {
                /*
                 * We're at the end of the sibling window list.
                 * Go to the parent's next window.
                 */
                pwnd = pwnd->spwndParent;
                if (pwnd == pwndStop)
                    return;

                if (pwnd->spwndNext) {
                    pwnd = pwnd->spwndNext;
                    break;
                }
            }
        }
    }
}

/***************************************************************************\
* SetWindowRgn
*
* Parameters:
*     hwnd    --  Window handle
*     hrgn    --  Region to set into window. NULL can be accepted.
*     fRedraw --  TRUE to go through SetWindowPos() and calculate
*                 update regions correctly. If the window is visible
*                 this will usually be TRUE.
*
* Returns:
*     TRUE for success, FALSE for failure
*
* Comments:
*     This is a very simple routine to set a window region. It goes through
*     SetWindowPos() to get perfect update region calculation, and to deal
*     with other related issues like vis rgn change & dc invalidation,
*     display lock holding, spb invalidation, etc. Also since it sends
*     WM_WINDOWPOSCHANGING & WM_WINDOWPOSCHANGED, we'll be able to expand
*     SetWindowPos() in the future to take hrgns directly for efficient
*     window state change control (like setting the rect and region at
*     the same time, among others) without harming compatibility.
*
*     hrgn is in window rect coordinates (not client rect coordinates).
*     Once set, hrgn is owned by the system. A copy is not made!
*
* 30-Jul-1994 ScottLu   Created.
\***************************************************************************/

#define SWR_FLAGS_REDRAW   (SWP_NOCHANGE | SWP_FRAMECHANGED | SWP_NOACTIVATE)
#define SWR_FLAGS_NOREDRAW (SWP_NOCHANGE | SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOREDRAW)

BOOL xxxSetWindowRgn(
    PWND pwnd,
    HRGN hrgn,
    BOOL fRedraw)
{
    PSMWP psmwp;
    HRGN  hrgnClip = NULL;
    BOOL  bRet = FALSE;

    /*
     * Validate the region handle. We did this for 3.51, so
     * we better do it for later versions. Our validation will
     * make a copy of the clip-rgn and send it through to the
     * SetWIndowRgn code. Once this is set in the kernel, we
     * will return to the client and the old region will be deleted
     * there.
     *
     * If the region passed in is NULL, then we get rid of the
     * current retion. Map it to HRGN_FULL so that SetWindowPos()
     * can tell this is what the caller wants.
     */
    if (hrgn) {

        if ((hrgnClip = UserValidateCopyRgn(hrgn)) == NULL) {

#if DBG
            RIPMSG0(RIP_WARNING, "xxxSetWindowRgn: Failed to create region!");
#endif
            goto swrClean;
        }
        MirrorRegion(pwnd, hrgnClip, FALSE);
    } else {

        hrgnClip = HRGN_FULL;
    }

    /*
     * Get a psmwp, and put the region in it, correctly offset.
     * Use SWP_FRAMECHANGED with acts really as a "empty" SetWindowPos
     * that still sends WM_WINDOWPOSCHANGING and CHANGED messages.
     * SWP_NOCHANGE ensures that we don't size, move, activate, zorder.
     */
    if (psmwp = InternalBeginDeferWindowPos(1)) {

        /*
         * psmwp gets freed automatically if this routine fails.
         */
        if (psmwp = _DeferWindowPos(
                psmwp,
                pwnd,
                PWND_TOP,
                0,
                0,
                0,
                0,
                fRedraw ? SWR_FLAGS_REDRAW : SWR_FLAGS_NOREDRAW)) {

            /*
             * Do the operation. Note that hrgn is still in window coordinates.
             * SetWindowPos() will change it to screen coordinates before
             * selecting into the window.
             */
            psmwp->acvr[0].hrgnClip = hrgnClip;
            bRet = xxxEndDeferWindowPosEx(psmwp, FALSE);
        }
    }

    /*
     * If the call failed, then delete our region we created. A FALSE
     * return means it should've never made it to the xxxSelectWindowRgn
     * call, so everything should be as it was.
     */
    if (!bRet && (hrgnClip != HRGN_FULL)) {

swrClean:

        GreDeleteObject(hrgnClip);
    }

    return bRet;
}

/***************************************************************************\
* SelectWindowRgn
*
* This routine does the work of actually selecting in the window region.
*
* 30-Jul-1994 ScottLu   Created.
\***************************************************************************/
VOID SelectWindowRgn(
    PWND pwnd,
    HRGN hrgnClip)
{
    /*
     * If there is a region already there, delete it becausea new one is
     * being set. For maximized windows in multiple monitor mode, we
     * always use the monitor HRGN. We don't make a copy. This way, when
     * the hrgn changes because of monitor config, the window's monitor
     * region automatically gets updated. Clever huh?  Also saves memory.
     */
    if (pwnd->hrgnClip != NULL) {
        if (TestWF(pwnd, WFMAXFAKEREGIONAL)) {
            ClrWF(pwnd, WFMAXFAKEREGIONAL);
        } else {
            /*
             * Do NOT select in a monitor region if the window is normally
             * regional. The MinMaximize code will always pass HRGN_MONITOR
             * to us no matter what. But when we get here, bail out and
             * don't destroy the app's region if it has one.
             */
            if (hrgnClip == HRGN_MONITOR)
                return;

            GreDeleteObject(pwnd->hrgnClip);
        }

        pwnd->hrgnClip = NULL;
    }

    /*
     * NULL or HRGN_FULL means "set to NULL". If we have a real region,
     * use it. USER needs to own it, and it needs to be in screen
     * coordinates.
     */
    if (hrgnClip > HRGN_FULL) {

        if (hrgnClip == HRGN_MONITOR) {
            PMONITOR pMonitor;

            /*
             * Use the monitor region if the window is really maxed
             * on a monitor. It's already happened by the time we get here,
             * if so. And xxxCheckFullScreen will clear the reallymaximed
             * style for a maximized window if it doesn't cover the whole
             * max area.
             */
            UserAssert(pwnd->spwndParent == PWNDDESKTOP(pwnd));

            if (!TestWF(pwnd, WFMAXIMIZED) || !TestWF(pwnd, WFREALLYMAXIMIZABLE))
                return;

            /*
             * Do nothing for windows off screen.
             */
            pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTONULL);
            if (!pMonitor)
                return;

            hrgnClip = pMonitor->hrgnMonitor;
            SetWF(pwnd, WFMAXFAKEREGIONAL);
        } else {
            if (pwnd != PWNDDESKTOP(pwnd)) {
                GreOffsetRgn(hrgnClip, pwnd->rcWindow.left, pwnd->rcWindow.top);
            }

            GreSetRegionOwner(hrgnClip, OBJECT_OWNER_PUBLIC);
        }

        pwnd->hrgnClip = hrgnClip;
    }
}


/***************************************************************************\
* TestRectBogus
*
* Returns TRUE if the window rect [x,y,cx,cy] is centered or
* clipped to the monitor or work rect [prc], FALSE otherwise.
*
* History:
* 26-Mar-1997 adams     Created.
\***************************************************************************/

#define SLOP_X 8
#define SLOP_Y 8

BOOL
TestRectBogus(RECT * prc, int x, int y, int cx, int cy)
{
    //
    //  check for a fullscreen (or offscreen) window
    //
    if (    x  <= prc->left &&
            y  <= prc->top &&
            cx >= (prc->right  - prc->left) &&
            cy >= (prc->bottom - prc->top)) {

        // rect is fullscreen
        return FALSE;
    }

    //
    //  check for the window being centered to the work area
    //  use <= for y to catch dialogs centered "high"
    //  (like the network logon dialog)
    //
    if (    abs(x - (prc->right + prc->left - cx) / 2) <= SLOP_X &&
            abs(y - (prc->bottom + prc->top - cy) / 2) <= SLOP_Y ) {

        // rect centered
        return TRUE;
    }

    //
    //  check for the window being cliped to the work area
    //
    if (    x == prc->left ||
            y == prc->top ||
            x == (prc->right - cx) ||
            y == (prc->bottom - cy)) {

        // rect is clipped
        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* IsRectBogus
*
* Returns TRUE if the window rect [x,y,cx,cy] is centered or
* clipped to the monitor or work rect of the primary monitor.
*
* History:
* 26-Mar-1997 adams     Created.
\***************************************************************************/
BOOL
IsRectBogus(
    int x,
    int y,
    int cx,
    int cy)
{
    PMONITOR pMonitorPrimary = GetPrimaryMonitor();

    return TestRectBogus(&pMonitorPrimary->rcWork, x, y, cx, cy) ||
           TestRectBogus(&pMonitorPrimary->rcMonitor, x, y, cx, cy);
}



/***************************************************************************\
* FixBogusSWP
*
* Detects if a rect is being centered or clipped to the primary monitor,
* and centers it in its owner's window if so. This prevents apps that
* are not multimon aware from having their "main" window displayed on
* one monitor but their dialogs moved to the primary monitor
* because they believe the dialog is offscreen.
*
* History:
* 26-Mar-1997 adams     Created.
\***************************************************************************/
VOID
FixBogusSWP(
    PWND pwnd,
    int * px,
    int * py,
    int cx,
    int cy,
    UINT flags)
{
    PMONITOR pMonitor;

    pMonitor = _MonitorFromWindow(pwnd->spwndOwner, MONITOR_DEFAULTTONEAREST);

    //
    // only check for a bogus SWP if the owner is not on the primary
    //
    if (pMonitor != GetPrimaryMonitor()) {
        //
        // get the current size if SWP_NOSIZE is set
        //
        if (flags & SWP_NOSIZE) {
            cx = pwnd->rcWindow.right  - pwnd->rcWindow.left;
            cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;
        }

        //
        // see if the app is trying to center or clip the window
        //
        if (IsRectBogus(*px, *py, cx, cy))
        {
            RECT rc;

#if DBG
            int oldX = *px;
            int oldY = *py;
#endif

            //
            // the app wants to center/clip the window
            // we will have to do it for them.
            //
            // get the window rect of the parent and
            // intersect that with the work area of
            // the owning monitor, then center the
            // window to this rect.
            //
            IntersectRect(&rc, &pMonitor->rcWork, &pwnd->spwndOwner->rcWindow);

            //
            // new multimonior friendly position.
            //
            *px = rc.left + (rc.right  - rc.left - cx) / 2;
            *py = rc.top  + (rc.bottom - rc.top  - cy) / 2;

            //
            // now clip to the work area.
            //
            if (*px + cx > pMonitor->rcWork.right) {
                *px = pMonitor->rcWork.right - cx;
            }

            if (*py + cy > pMonitor->rcWork.bottom) {
                *py = pMonitor->rcWork.bottom - cy;
            }

            if (*px < pMonitor->rcWork.left) {
                *px = pMonitor->rcWork.left;
            }

            if (*py < pMonitor->rcWork.top) {
                *py = pMonitor->rcWork.top;
            }

            RIPMSG0(RIP_WARNING | RIP_THERESMORE,              "SetWindowPos detected that your app is centering or clipping");
            RIPMSG0(RIP_WARNING | RIP_THERESMORE | RIP_NONAME, "a window to the primary monitor when its owner is on a different monitor.");
            RIPMSG0(RIP_WARNING | RIP_THERESMORE | RIP_NONAME, "Consider fixing your app to use the Window Manager Multimonitor APIs.");
            RIPMSG4(RIP_WARNING | RIP_NONAME,                  "SetWindowPos moved the window from (%d,%d) to (%d,%d).\n",
                                                               oldX, oldY, *px, *py);
        }
    }
}

/***************************************************************************\
* PreventInterMonitorBlts()
*
* Prevents monitor-to-monitor blts when they are different caps. This
* way we redraw the part of a window that moves to a different monitor.
* We try to blt as much as possible.
*
* We look at the source rect and what monitor owns it, and how much that
* monitor also contains of the destination rect. Then we compare that
* with the destination rect and what monitor owns that, and how much it
* contains of the source rect. The larger wins.
*
* rcBlt is in screen coordinates and is the DESTINATION.
*
* History:
* 11-11-1997    vadimg      ported from Memphis
\***************************************************************************/
VOID PreventInterMonitorBlts(
    PCVR pcvr)
{
    RECT        rcSrc;
    RECT        rcDst;
    RECT        rcSrcT;
    RECT        rcDstT;
    PMONITOR    pMonitor;

    /*
     * If the destination is empty do nothing.
     */
    if (IsRectEmpty(&pcvr->rcBlt)) {
        return;
    }

    /*
     * Get the source rect (rcBlt is the destination, dxBlt/dyBlt are the
     * distance moved from the source).
     */
    CopyOffsetRect(&rcSrc, &pcvr->rcBlt, -pcvr->dxBlt, -pcvr->dyBlt);

    /*
     * Split up the source into its monitor pieces. If the source intersects
     * a monitor, then figure out where that part will be in the destination.
     * Intersect the destination part with the same monitor. The result is
     * the amount we can blt from the source to the dest on that monitor.
     *
     * We do this for each monitor to find the biggest blt rect. We want
     * the biggest because we want to repaint as little as possible. We do
     * bail out if both the source and dest are fully contained on the same
     * monitor.
     */
    for (pMonitor = gpDispInfo->pMonitorFirst;
            pMonitor != NULL;
            pMonitor = pMonitor->pMonitorNext) {

        /*
         * We're only interested in visible monitors.
         */
        if (!(pMonitor->dwMONFlags & MONF_VISIBLE))
            continue;
        /*
         * If this monitor doesn't contain a piece of the source, we don't
         * care about it. We won't be doing a same monitor blt on it for sure.
         */
        if (!IntersectRect(&rcSrcT, &rcSrc, &pMonitor->rcMonitor))
            continue;

        /*
         * See where this rect would be in the destination.
         */
        CopyOffsetRect(&rcDst, &rcSrcT, pcvr->dxBlt, pcvr->dyBlt);

        /*
         * Intersect this rect with the same monitor rect to see what piece
         * can be safely blted on the same monitor.
         */
        IntersectRect(&rcDstT, &rcDst, &pMonitor->rcMonitor);

        /*
         * Is this piece of the source staying on this monitor?
         */
        if (EqualRect(&rcDstT, &rcDst)) {
            /*
             * This source piece is staying completely on this monitor when
             * it becomes the destination. Hence there is nothing to add
             * to our invalid sum, hrgnInterMonitor.
             */
            if (EqualRect(&rcSrcT, &rcSrc)) {
                /*
                 * The source is completely ON one monitor and moving to
                 * a location also completely ON this monitor. Great, no
                 * intermonitor blts whatsoever. We are done.
                 */
                UserAssert(pcvr->hrgnInterMonitor == NULL);
                return;
            } else {
                continue;
            }
        }

        /*
         * OK, some piece of the source is moving across monitors. Figure
         * out what it is and where that piece is in the destination. That
         * piece in the destination must be invalidated and not blted.
         */
        if (pcvr->hrgnInterMonitor == NULL) {
            pcvr->hrgnInterMonitor = CreateEmptyRgn();
        }

        /*
         * The difference between the transposed source to the dest, and the
         * real part of the dest that lies on this monitor, is the amount
         * of the source that will move across a monitor boundary. Add this
         * to our accumulated invalid region.
         *
         * rcDst is the whole source chunk, rcDstT is the part on the same
         * monitor as the source chunk.
         */
        GreSetRectRgn(ghrgnInv2, rcDst.left, rcDst.top, rcDst.right, rcDst.bottom);
        GreSetRectRgn(ghrgnGDC, rcDstT.left, rcDstT.top, rcDstT.right, rcDstT.bottom);
        SubtractRgn(ghrgnInv2, ghrgnInv2, ghrgnGDC);
        UnionRgn(pcvr->hrgnInterMonitor, pcvr->hrgnInterMonitor, ghrgnInv2);
    }

#if DBG
    VerifyVisibleMonitorCount();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\text.c ===
/****************************** Module Header ******************************\
* Module Name: text.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the MessageBox API and related functions.
*
* History:
* 10-01-90 EricK        Created.
* 11-20-90 DarrinM      Merged in User text APIs.
* 02-07-91 DarrinM      Removed TextOut, ExtTextOut, and GetTextExtentPoint stubs.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL _TextOutW(
    HDC     hdc,
    int     x,
    int     y,
    LPCWSTR lp,
    UINT    cc);

/***************************************************************************\
* xxxPSMTextOut
*
* Outputs the text and puts and _ below the character with an &
* before it. Note that this routine isn't used for menus since menus
* have their own special one so that it is specialized and faster...
*
* NOTE: A very similar routine (UserLpkPSMTextOut) exists on the client
*       side in drawtext.c.  Any non-kernel specific changes to this
*       routine most likely need to be made in UserLpkPSMTextOut as well.
*
* History:
* 11-13-90 JimA         Ported to NT.
* 30-Nov-1992 mikeke    Client side version
* 8-Apr-1998 MCostea    Added dwFlags
\***************************************************************************/

void xxxPSMTextOut(
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR lpsz,
    int cch,
    DWORD dwFlags)
{
    int cx;
    LONG textsize, result;
    /*
     * In the kernel we have a limited amount of stack. So it should be a stack
     * variable in user mode and static in kernel mode where it is thread safe
     * since we are in the crit section.
     */
    static WCHAR achWorkBuffer[255];
    WCHAR *pchOut = achWorkBuffer;
    TEXTMETRICW textMetric;
    SIZE size;
    RECT rc;
    COLORREF color;
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    if (CALL_LPK(ptiCurrent)) {
        /*
         * A user mode LPK is installed for layout and shaping.
         * Perform callback and return.
         */
        UNICODE_STRING ustrStr;

        RtlInitUnicodeString(&ustrStr, lpsz);
        xxxClientPSMTextOut(hdc, xLeft, yTop, &ustrStr, cch, dwFlags);
        return;
    }

    if (cch > sizeof(achWorkBuffer)/sizeof(WCHAR)) {
        pchOut = (WCHAR*)UserAllocPool((cch+1) * sizeof(WCHAR), TAG_RTL);
        if (pchOut == NULL)
            return;
    }

    result = GetPrefixCount(lpsz, cch, pchOut, cch);

    if (!(dwFlags & DT_PREFIXONLY)) {
        _TextOutW(hdc, xLeft, yTop, pchOut, cch - HIWORD(result));
    }

    /*
     * Any true prefix characters to underline?
     */
    if (LOWORD(result) == 0xFFFF || dwFlags & DT_HIDEPREFIX) {
        if (pchOut != achWorkBuffer)
            UserFreePool(pchOut);
        return;
    }

    if (!_GetTextMetricsW(hdc, &textMetric)) {
        textMetric.tmOverhang = 0;
        textMetric.tmAscent = 0;
    }

    /*
     * For proportional fonts, find starting point of underline.
     */
    if (LOWORD(result) != 0) {

        /*
         * How far in does underline start (if not at 0th byte.).
         */
        GreGetTextExtentW(hdc, (LPWSTR)pchOut, LOWORD(result), &size, GGTE_WIN3_EXTENT);
        xLeft += size.cx;

        /*
         * Adjust starting point of underline if not at first char and there is
         * an overhang.  (Italics or bold fonts.)
         */
        xLeft = xLeft - textMetric.tmOverhang;
    }

    /*
     * Adjust for proportional font when setting the length of the underline and
     * height of text.
     */
    GreGetTextExtentW(hdc, (LPWSTR)(pchOut + LOWORD(result)), 1, &size, GGTE_WIN3_EXTENT);
    textsize = size.cx;

    /*
     * Find the width of the underline character.  Just subtract out the overhang
     * divided by two so that we look better with italic fonts.  This is not
     * going to effect embolded fonts since their overhang is 1.
     */
    cx = LOWORD(textsize) - textMetric.tmOverhang / 2;

    /*
     * Get height of text so that underline is at bottom.
     */
    yTop += textMetric.tmAscent + 1;

    /*
     * Draw the underline using the foreground color.
     */
    SetRect(&rc, xLeft, yTop, xLeft+cx, yTop+1);
    color = GreSetBkColor(hdc, GreGetTextColor(hdc));
    GreExtTextOutW(hdc, xLeft, yTop, ETO_OPAQUE, &rc, TEXT(""), 0, NULL);
    GreSetBkColor(hdc, color);

    if (pchOut != achWorkBuffer) {
        UserFreePool(pchOut);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\timers.c ===
/****************************** Module Header ******************************\
* Module Name: timers.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the user timer APIs and support routines.
*
* History:
* 12-Nov-1990 DarrinM   Created.
* 08-Apr-1992 DarrinM   Switched to PM/Win3-like ScanTimers model.
\***************************************************************************/

#define _TIMERS 1      // uses a LARGE_INTEGER
#include "precomp.h"
#pragma hdrstop


/*
 * Make sure that if we return a timer id that it is a WORD value. This
 * will ensure that WOW doesn't need to handle-translate return values
 * from SetTimer().
 *
 * Start with a large number so that FindTimer() doesn't find a timer we
 * calculated with a low cTimerId if the app happens to pass in NULL pwnd
 * and a low id (like 1).
 */
#define TIMERID_MAX   0x7FFF
#define TIMERID_MIN   0x100

#define ELAPSED_MAX  0x7FFFFFFF

#define SYSRIT_TIMER  (TMRF_SYSTEM | TMRF_RIT)

WORD cTimerId = TIMERID_MAX;

/***************************************************************************\
* _SetTimer (API)
*
* This API will start the specified timer.
*
* History:
* 15-Nov-1990 DavidPe   Created.
\***************************************************************************/
UINT_PTR _SetTimer(
    PWND         pwnd,
    UINT_PTR     nIDEvent,
    UINT         dwElapse,
    TIMERPROC_PWND pTimerFunc)
{
    /*
     * Prevent apps from setting a Timer with a window proc to another app
     */
    if (pwnd && (PpiCurrent() != GETPTI(pwnd)->ppi)) {

        RIPERR1(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Calling SetTimer with window of another process %lX",
                pwnd);

        return 0;
    }

    return InternalSetTimer(pwnd, nIDEvent, dwElapse, pTimerFunc, 0);
}

/***************************************************************************\
* _SetSystemTimer
*
* This API will start start a system timer which will generate WM_SYSTIMER
* messages rather than WM_TIMER
*
* History:
* 15-Nov-1990 DavidPe   Created.
* 21-Jan-1991 IanJa     Prefix '_' denotes export function (not API)
\***************************************************************************/

UINT_PTR _SetSystemTimer(
    PWND         pwnd,
    UINT_PTR     nIDEvent,
    DWORD        dwElapse,
    TIMERPROC_PWND pTimerFunc)
{
    /*
     * Prevent apps from setting a Timer with a window proc to another app
     */
    if (pwnd && PpiCurrent() != GETPTI(pwnd)->ppi) {
        RIPERR1(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Calling SetSystemTimer with window of another process 0x%p",
                pwnd);

        return 0;
    }

    return InternalSetTimer(pwnd, nIDEvent, dwElapse, pTimerFunc, TMRF_SYSTEM);
}

/***************************************************************************\
* FreeTimer
*
* This function does the actual unlinking and freeing of the timer structure.
* I pulled it out of FindTimer() so it could be shared with DestroyQueues-
* Timers.
* Sets *pptmr to point to the next TIMER struct (NULL if none)
*
* History:
* 15-Feb-1991 DarrinM   Pulled from FindTimer().
\***************************************************************************/

VOID FreeTimer(
    PTIMER ptmr) {

    CheckCritIn();

    /*
     * Mark it for destruction.  If it the object is locked it can't
     * be freed right now.
     */
    if (!HMMarkObjectDestroy((PVOID)ptmr))
        return;

    /*
     * If this timer was just about to be processed, decrement
     * the ready-count since we're blowing it off.
     */
    if (ptmr->flags & TMRF_READY)
        DecTimerCount(ptmr->pti);

    /*
     * Unlock the window
     */
    Unlock(&ptmr->spwnd);

    /*
     * Unlink this timer
     */
    if (ptmr->ptmrPrev) {
        ptmr->ptmrPrev->ptmrNext = ptmr->ptmrNext;
    } else {
        gptmrFirst = ptmr->ptmrNext;
    }

    if (ptmr->ptmrNext) {
        ptmr->ptmrNext->ptmrPrev = ptmr->ptmrPrev;
    }

    /*
     * Free up the TIMER structure.
     */
    HMFreeObject((PVOID)ptmr);
}


/***************************************************************************\
* FindTimer
*
* This function will find a timer that matches the parameters.  We also
* deal with killing timers here since it's easier to remove items from
* the list while we're scanning it.
*
* History:
* 15-Nov-1990 DavidPe   Created.
\***************************************************************************/

PTIMER FindTimer(
    PWND pwnd,
    UINT_PTR nID,
    UINT flags,
    BOOL fKill)
{
    PTIMER ptmr;

    ptmr = gptmrFirst;

    while (ptmr != NULL) {

        /*
         * Is this the timer we're looking for?
         */
        if ((ptmr->spwnd == pwnd) &&
            (ptmr->nID == nID)    &&
            (ptmr->flags & SYSRIT_TIMER) == (flags & SYSRIT_TIMER)) {

            /*
             * Are we being called from KillTimer()? If so, destroy the
             * timer.  return != 0 because *pptmr is gone.
             */
            if (fKill) {
                FreeTimer(ptmr);
                return (PTIMER)TRUE;
            }

            /*
             * Found the timer, break out of the loop.
             */
            break;
        }

        /*
         * No, try the next one.
         */
        ptmr = ptmr->ptmrNext;
    }

    return ptmr;
}

/***************************************************************************\
* InternalSetTimer
*
* This is the guts of SetTimer that actually gets things going.
*
* NOTE (darrinm): Technically there is a bit of latency (the time it takes
* between SetTimer's NtSetEvent and when the RIT wakes up and calls ScanTimers)
* between when SetTimer is called and when the counter starts counting down.
* This is uncool but it should be a very short amount of time because the RIT
* is high-priority.  If it becomes a problem I know how to fix it.
*
* History:
* 15-Nov-1990 DavidPe      Created.
\***************************************************************************/

UINT_PTR InternalSetTimer(
    PWND         pwnd,
    UINT_PTR     nIDEvent,
    UINT         dwElapse,
    TIMERPROC_PWND pTimerFunc,
    UINT         flags)
{
    LARGE_INTEGER liT = {1, 0};
    PTIMER        ptmr;
    PTHREADINFO   ptiCurrent;

    CheckCritIn();

    /*
     * Assert if someone tries to set a timer after cleanup initiated.
     */
    if (gbCleanupInitiated) {
        RIPMSGF0(RIP_ERROR, "Too late to create a timer.");
        return 0;
    }

    /*
     * We need to make sure dwElapse isn't too big. NtUserSetTimer ensures
     * that no app passes in zero for the timeout value; let's assert here
     * that that remains the case, and that no one internally does this.
     */
    UserAssert(dwElapse != 0);
    if (dwElapse > ELAPSED_MAX) {
        RIPMSGF1(RIP_WARNING,
                 "Timer period (0x%x) is too big",
                 dwElapse);

        dwElapse = ELAPSED_MAX;
    }

    /*
     * Attempt to first locate the timer, then create a new one
     * if one isn't found.
     */
    if ((ptmr = FindTimer(pwnd, nIDEvent, flags, FALSE)) == NULL) {

        /*
         * Not found.  Create a new one.
         */
        ptmr = (PTIMER)HMAllocObject(NULL, NULL, TYPE_TIMER, sizeof(TIMER));
        if (ptmr == NULL) {
            return 0;
        }

        ptmr->spwnd = NULL;

        if (pwnd == NULL) {
            WORD timerIdInitial = cTimerId;

            /*
             * Pick a unique, unused timer ID.
             */
            do {
                if (--cTimerId <= TIMERID_MIN) {
                    cTimerId = TIMERID_MAX;
                }

                if (cTimerId == timerIdInitial) {
                    /*
                     * Flat out of timers bud.
                     */
                    HMFreeObject(ptmr);
                    return 0;
                }
            } while (FindTimer(NULL, cTimerId, flags, FALSE) != NULL);

            ptmr->nID = (UINT)cTimerId;
        } else {
            ptmr->nID = nIDEvent;
        }

        /*
         * Link the new timer into the front of the list.
         * Handily this works even when gptmrFirst is NULL.
         */
        ptmr->ptmrNext = gptmrFirst;
        ptmr->ptmrPrev = NULL;
        if (gptmrFirst) {
            gptmrFirst->ptmrPrev = ptmr;
        }
        gptmrFirst = ptmr;
    } else {
        /*
         * If this timer was just about to be processed, decrement
         * cTimersReady since we're resetting it.
         */
        if (ptmr->flags & TMRF_READY) {
            DecTimerCount(ptmr->pti);
        }
    }

    /*
     * If pwnd is NULL, create a unique id by
     * using the timer handle.  RIT timers are 'owned' by the RIT pti
     * so they are not deleted when the creating pti dies.
     *
     * We used to record the pti as the pti of the window if one was
     * specified.  This is not what Win 3.1 does and it broke 10862
     * where some merge app was setting the timer on winword's window
     * it it still expected to get the messages not winword.
     *
     * MS Visual C NT was counting on this bug in the NT 3.1 so if
     * a thread sets a timer for a window in another thread in the
     * same process the timer goes off in the thread of the window.
     * You can see this by doing a build in msvcnt and the files being
     * compiled do not show up.
     */
    ptiCurrent = (PTHREADINFO)(W32GetCurrentThread()); /*
                                                        * This will be NULL
                                                        * for a non-GUI thread.
                                                        */

    if (pwnd == NULL) {

        if (flags & TMRF_RIT) {
            ptmr->pti = gptiRit;
        } else {
            ptmr->pti = ptiCurrent;
            UserAssert(ptiCurrent);
        }

    } else {

        /*
         * As enforced in the API wrappers.  We shouldn't get here
         * any other way for an app timer.
         *
         * Always use pti of the window when TMRF_PTIWINDOW is passed in.
         */
        if ((ptiCurrent->TIF_flags & TIF_16BIT) && !(flags & TMRF_PTIWINDOW)) {
            ptmr->pti = ptiCurrent;
            UserAssert(ptiCurrent);
        } else {
            ptmr->pti = GETPTI(pwnd);
        }
    }

    /*
     * Initialize the timer-struct.
     *
     * NOTE: The ptiOptCreator is used to identify a JOURNAL-timer.  We
     *       want to allow these timers to be destroyed when the creator
     *       thread goes away.  For other threads that create timers across
     *       threads, we do not want to destroy these timers when the
     *       creator goes away.  Currently, we're only checking for a
     *       TMRF_RIT.  However, in the future we might want to add this
     *       same check for TMRF_SYSTEM.
     */
    Lock(&(ptmr->spwnd), pwnd);

    ptmr->cmsCountdown  = ptmr->cmsRate = dwElapse;
    ptmr->flags         = flags | TMRF_INIT;
    ptmr->pfn           = pTimerFunc;
    ptmr->ptiOptCreator = (flags & TMRF_RIT ? ptiCurrent : NULL);

    /*
     * Force the RIT to scan timers.
     *
     * N.B. The following code sets the raw input thread timer to expire
     *      at the absolute time 1 which is very far into the past. This
     *      causes the timer to immediately expire before the set timer
     *      call returns.
     */
    if (ptiCurrent == gptiRit) {
        /*
         * Don't let RIT timer loop reset the master timer - we already have.
         */
        gbMasterTimerSet = TRUE;
    }

    UserAssert(gptmrMaster);
    KeSetTimer(gptmrMaster, liT, NULL);

    /*
     * Windows 3.1 returns the timer ID if non-zero, otherwise it returns 1.
     */
    return (ptmr->nID == 0 ? 1 : ptmr->nID);
}

/***************************************************************************\
* _KillTimer (API)
*
* This API will stop a timer from sending WM_TIMER messages.
*
* History:
* 15-Nov-1990 DavidPe   Created.
\***************************************************************************/

BOOL _KillTimer(
    PWND pwnd,
    UINT_PTR nIDEvent)
{
    return KillTimer2(pwnd, nIDEvent, FALSE);
}

/***************************************************************************\
* _KillSystemTimer
*
* This API will stop a system timer from sending WM_SYSTIMER messages.
*
* History:
* 15-Nov-1990 DavidPe   Created.
* 21-Jan-1991 IanJa     Prefix '_' denotes export function (not API)
\***************************************************************************/

BOOL _KillSystemTimer(
    PWND pwnd,
    UINT_PTR nIDEvent)
{
    return KillTimer2(pwnd, nIDEvent, TRUE);
}

/***************************************************************************\
* KillTimer2
*
* This is the guts of KillTimer that actually kills the timer.
*
* History:
* 15-Nov-1990 DavidPe       Created.
\***************************************************************************/

BOOL KillTimer2(
    PWND pwnd,
    UINT_PTR nIDEvent,
    BOOL fSystemTimer)
{
    /*
     * Call FindTimer() with fKill == TRUE.  This will
     * basically delete the timer.
     */
    return (FindTimer(pwnd,
                      nIDEvent,
                      (fSystemTimer ? TMRF_SYSTEM : 0),
                      TRUE) != NULL);
}

/***************************************************************************\
* DestroyQueuesTimers
*
* This function scans through all the timers and destroys any that are
* associated with the specified queue.
*
* History:
* 15-Feb-1991 DarrinM   Created.
\***************************************************************************/

VOID DestroyThreadsTimers(
    PTHREADINFO pti)
{
    PTIMER ptmr;

    ptmr = gptmrFirst;

    while (ptmr != NULL) {

        /*
         * Is this one of the timers we're looking for?  If so, destroy it.
         */
        if (ptmr->pti == pti || ptmr->ptiOptCreator == pti) {
            PTIMER ptmrNext = ptmr->ptmrNext;
            FreeTimer(ptmr);
            ptmr = ptmrNext;
        } else {
            ptmr = ptmr->ptmrNext;
        }
    }
}

/***************************************************************************\
* DestroyWindowsTimers
*
* This function scans through all the timers and destroys any that are
* associated with the specified window.
*
* History:
* 04-Jun-1991 DarrinM       Created.
\***************************************************************************/

VOID DestroyWindowsTimers(
    PWND pwnd)
{
    PTIMER ptmr;

    ptmr = gptmrFirst;

    while (ptmr != NULL) {

        /*
         * Is this one of the timers we're looking for?  If so, destroy it.
         */
        if (ptmr->spwnd == pwnd) {
            PTIMER ptmrNext = ptmr->ptmrNext;
            FreeTimer(ptmr);
            ptmr = ptmrNext;
        } else {
            ptmr = ptmr->ptmrNext;
        }
    }
}

/***************************************************************************\
* DoTimer
*
* This function gets called from xxxPeekMessage() if the QS_TIMER bit is
* set.  If this timer is okay with the filter specified the appropriate
* WM_*TIMER message will be placed in 'pmsg' and the timer will be reset.
*
* History:
* 15-Nov-1990 DavidPe   Created.
* 27-NOv-1991 DavidPe   Changed to move 'found' timers to end of list.
\***************************************************************************/

BOOL DoTimer(
    PWND pwndFilter)
{
    PTHREADINFO pti;
    PTIMER      ptmr;
    PTIMER      ptmrNext;
    PQMSG       pqmsg;

    CheckCritIn();

    pti = PtiCurrent();

    /*
     * Search for a timer that belongs to this queue.
     */
    ptmr = gptmrFirst;

    while (ptmr != NULL) {

        /*
         * Has this timer gone off and is it one we're looking for?
         */
        if ((ptmr->flags & TMRF_READY) &&
            (ptmr->pti == pti)         &&
            CheckPwndFilter(ptmr->spwnd, pwndFilter)) {

            /*
             * We found an appropriate timer. Put it in the app's queue and
             * return success.
             */
            if ((pqmsg = AllocQEntry(&pti->mlPost)) != NULL) {

                /*
                 * Store the message and set the QS_POSTMESSAGE bit so the
                 * thread knows it has a message.
                 */
                StoreQMessage(pqmsg,
                              ptmr->spwnd,
                              (UINT)((ptmr->flags & TMRF_SYSTEM) ?
                                      WM_SYSTIMER : WM_TIMER),
                              (WPARAM)ptmr->nID,
                              (LPARAM)ptmr->pfn,
                              0, 0, 0);
#ifdef REDIRECTION
                StoreQMessagePti(pqmsg, pti);
#endif // REDIRECTION
                SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);
            }

            /*
             * Reset this timer.
             */
            ptmr->flags &= ~TMRF_READY;
            DecTimerCount(ptmr->pti);

            /*
             * If there are other timers in the system move this timer
             * to the end of the list so other timers in for this queue
             * get a chance to go off.
             */
            ptmrNext = ptmr->ptmrNext;
            if (ptmrNext != NULL) {

                /*
                 * Remove ptmr from its place in the list.
                 */
                if (ptmr->ptmrPrev) {
                    ptmr->ptmrPrev->ptmrNext = ptmr->ptmrNext;
                } else
                    gptmrFirst = ptmr->ptmrNext;

                ptmrNext->ptmrPrev = ptmr->ptmrPrev;

                /*
                 * Move to the last TIMER of the list.
                 */
                while (ptmrNext->ptmrNext != NULL)
                    ptmrNext = ptmrNext->ptmrNext;

                /*
                 * Insert this timer at the end.
                 */
                ptmrNext->ptmrNext = ptmr;
                ptmr->ptmrPrev = ptmrNext;
                ptmr->ptmrNext     = NULL;
            }

            return TRUE;
        }

        ptmr = ptmr->ptmrNext;
    }

    return FALSE;
}

/***************************************************************************\
* DecTimerCount
*
* This routine decrements cTimersReady and clears QS_TIMER if the count
* goes down to zero.
*
* History:
* 21-Jan-1991 DavidPe   Created.
\***************************************************************************/

VOID DecTimerCount(
    PTHREADINFO pti)
{
    CheckCritIn();

    if (--pti->cTimersReady == 0)
        pti->pcti->fsWakeBits &= ~QS_TIMER;
}

/***************************************************************************\
* JournalTimer
*
*
* History:
* 04-Mar-1991 DavidPe       Created.
\***************************************************************************/

VOID JournalTimer(
    PWND  pwnd,
    UINT  message,
    UINT_PTR nID,
    LPARAM lParam)
{
    PTHREADINFO pti;

    DBG_UNREFERENCED_PARAMETER(pwnd);
    DBG_UNREFERENCED_PARAMETER(message);
    DBG_UNREFERENCED_PARAMETER(nID);

    /*
     * We've already entered the critical section.
     */
    if (pti = ((PTIMER)lParam)->ptiOptCreator)
        WakeSomeone(pti->pq, pti->pq->msgJournal, NULL);

    return;
}

/***************************************************************************\
* SetJournalTimer
*
* Sets an NT timer that goes off in 'dt' milliseconds and will wake
* up 'pti' at that time.  This is used in journal playback code to
* simulate the timing in which events were originally given to the system.
*
* History:
* 04-Mar-1991 DavidPe       Created.
\***************************************************************************/

void SetJournalTimer(
    DWORD dt,
    UINT  msgJournal)
{
    static UINT_PTR idJournal = 0;

    PtiCurrent()->pq->msgJournal = msgJournal;

    /*
     * Remember idJournal - because TMRF_ONESHOT timers stay in the timer
     * list - by remembering the idJournal, we always reuse the same timer
     * rather than creating new ones always.
     */
    idJournal = InternalSetTimer(NULL,
                                 idJournal,
                                 dt,
                                 JournalTimer,
                                 TMRF_RIT | TMRF_ONESHOT);
}

/***************************************************************************\
* StartTimers
*
* Prime the timer pump by starting the cursor restoration timer.
*
* History:
* 02-Apr-1992 DarrinM   Created.
\***************************************************************************/

UINT_PTR StartTimers(VOID)
{
    /*
     * Let GDI know that it can start settings timers on the RIT.
     */
    GreStartTimers();

    /*
     * TMRF_RIT timers are called directly from ScanTimers -- no nasty
     * thread switching for these boys.
     */
    return InternalSetTimer(NULL, 0, 1000, xxxHungAppDemon, TMRF_RIT);
}


/***************************************************************************\
* TimersProc
*
* Deal with the timers. Called from RawInputThread.
*
* History:
* 11-11-1996 CLupu   Created.
\***************************************************************************/
VOID TimersProc(
    VOID)
{
    DWORD dmsSinceLast, cmsCur, dmsNextTimer;
    LARGE_INTEGER liT;
    PTIMER ptmr;

    EnterCrit();

    /*
     * Calculate how long it was since the last time we processed timers so
     * we can subtract that much time from each timer's countdown value.
     */
    cmsCur = NtGetTickCount();
    dmsSinceLast = ComputePastTickDelta(cmsCur, gcmsLastTimer);
    gcmsLastTimer = cmsCur;

    /*
     * dmsNextTimer is the time delta before the next
     * timer should go off.  As we loop through the
     * timers below this will shrink to the smallest
     * cmsCountdown value in the list.
     */
    dmsNextTimer = ELAPSED_MAX;
    ptmr = gptmrFirst;
    gbMasterTimerSet = FALSE;
    while (ptmr != NULL) {

        /*
         * ONESHOT timers go to a WAITING state after
         * they go off. This allows us to leave them
         * in the list but keep them from going off
         * over and over.
         */
        if (ptmr->flags & TMRF_WAITING) {
            ptmr = ptmr->ptmrNext;
            continue;
        }

        /*
         * The first time we encounter a timer we don't
         * want to set it off, we just want to use it to
         * compute the shortest countdown value.
         */
        if (ptmr->flags & TMRF_INIT) {
            ptmr->flags &= ~TMRF_INIT;

        } else {
            /*
             * If this timer is going off, wake up its
             * owner.
             */
            if (ptmr->cmsCountdown > dmsSinceLast) {
                ptmr->cmsCountdown -= dmsSinceLast;
            } else {
                UserAssert(ptmr->cmsRate <= ELAPSED_MAX);
                ptmr->cmsCountdown = ptmr->cmsRate;

                /*
                 * If the timer's owner hasn't handled the
                 * last time it went off yet, throw this event
                 * away.
                 */
                if (!(ptmr->flags & TMRF_READY)) {
                    /*
                     * A ONESHOT timer goes into a WAITING state
                     * until SetTimer is called again to reset it.
                     */
                    if (ptmr->flags & TMRF_ONESHOT)
                        ptmr->flags |= TMRF_WAITING;

                    /*
                     * RIT timers have the distinction of being
                     * called directly and executing serially with
                     * with incoming timer events.
                     * NOTE: RIT timers get called while we're
                     * inside the critical section.
                     */
                    if (ptmr->flags & TMRF_RIT) {
                        TL tlTimer;

                        ThreadLock(ptmr, &tlTimer);
                        /*
                         * May set gbMasterTimerSet
                         */
                        (ptmr->pfn)(NULL,
                                    WM_SYSTIMER,
                                    ptmr->nID,
                                    (LPARAM)ptmr);

                        if (HMIsMarkDestroy(ptmr)) {
                            ptmr = ptmr->ptmrNext;
                            ThreadUnlock(&tlTimer);
                            continue;
                        }
                        ThreadUnlock(&tlTimer);

                    } else {
                        ptmr->flags |= TMRF_READY;
                        ptmr->pti->cTimersReady++;
                        SetWakeBit(ptmr->pti, QS_TIMER);
                    }
                }
            }
        }

        /*
         * Remember the shortest time left of the timers.
         */
        if (ptmr->cmsCountdown < dmsNextTimer) {
            dmsNextTimer = ptmr->cmsCountdown;
        }

        /*
         * Advance to the next timer structure.
         */
        ptmr = ptmr->ptmrNext;
    }

    if (!gbMasterTimerSet) {
        /*
         * Time in NT should be negative to specify a relative
         * time. It's also in hundred nanosecond units so multiply
         * by 10000  to get the right value from milliseconds.
         */
        liT.QuadPart = Int32x32To64(-10000, dmsNextTimer);
        KeSetTimer(gptmrMaster, liT, NULL);
    }

    LeaveCrit();
}

/***************************************************************************\
*  xxxSystemTimerProc()
*
*  11/15/96 GerardoB  Created
\***************************************************************************/
VOID xxxSystemTimerProc(PWND pwnd, UINT msg, UINT_PTR id, LPARAM lParam)
{
    CheckLock(pwnd);
    UNREFERENCED_PARAMETER(msg);
    UNREFERENCED_PARAMETER(id);
    UNREFERENCED_PARAMETER(lParam);

    switch (id) {
        case IDSYS_LAYER: {
            PDCE pdce;

            UserAssert(gnVisibleRedirectedCount > 0);

            for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

                if (pdce->DCX_flags & (DCX_INVALID | DCX_DESTROYTHIS))
                    continue;

                if ((pdce->DCX_flags & DCX_REDIRECTED) && (pdce->DCX_flags & DCX_INUSE)) {
                    UpdateRedirectedDC(pdce);
                }
            }
        }
        return;

        case IDSYS_FADE:
            AnimateFade();
            return;

        case IDSYS_FLASHWND:
            xxxFlashWindow(pwnd, FLASHW_TIMERCALL, 0);
            return;

        case IDSYS_WNDTRACKING: {
            /*
             * If the active track window hasn't changed,
             *  it's time to active it.
             * spwndTrack can be NULL if it got destroyed but we haven't
             *  destroyed the timer.yet
             */
            PTHREADINFO pti = GETPTI(pwnd);
            UserAssert(TestUP(ACTIVEWINDOWTRACKING));

            if ((pti->rpdesk->spwndTrack != NULL)
                    && (pwnd == GetActiveTrackPwnd(pti->rpdesk->spwndTrack, NULL))) {

                pti->pq->QF_flags |= (QF_ACTIVEWNDTRACKING | QF_MOUSEMOVED);

#ifdef REDIRECTION
                /*
                 * Should we call the hit test hook here ?
                 */
                PushMouseMove(pti->pq, gpsi->ptCursor);
#endif // REDIRECTION

                SetWakeBit(pti, QS_MOUSEMOVE);
            }
        }
        break;

        case IDSYS_MOUSEHOVER: {
            PTHREADINFO pti = GETPTI(pwnd);
            PDESKTOP pdesk = pti->rpdesk;
            /*
             * If hover hasn't been canceled, the mouse is still on
             *  this window and the point is still on the rect, then
             *  it's hover time!
             */
            if ((pdesk->dwDTFlags & DF_TRACKMOUSEHOVER)
                    && (HWq(pwnd) == HWq(pdesk->spwndTrack)
                    && PtInRect(&pdesk->rcMouseHover, gpsi->ptCursor))) {

                UINT message;
                WPARAM wParam;
                POINT pt = gpsi->ptCursor;

                if (pdesk->htEx == HTCLIENT) {
                    message = WM_MOUSEHOVER;
                    wParam = (WPARAM)GetMouseKeyFlags(pti->pq);
                    if (TestWF(pwnd, WEFLAYOUTRTL)) {
                        pt.x = pwnd->rcClient.right - pt.x - 1;
                    } else {
                        pt.x -= pwnd->rcClient.left;
                    }
                    pt.y -= pwnd->rcClient.top;
                } else {
                    message = WM_NCMOUSEHOVER;
                    /*
                     * Map the extended hit test code to a public one.
                     */
                    wParam = (WPARAM)LOWORD(pdesk->htEx);
                    if ((wParam >= HTEXMENUFIRST) && (wParam <= HTEXMENULAST)) {
                        wParam = (WPARAM)HTMENU;
                    } else if ((wParam >= HTEXSCROLLFIRST) && (wParam <= HTEXSCROLLLAST)) {
                        wParam = (WPARAM)(HIWORD(pdesk->htEx) ? HTVSCROLL : HTHSCROLL);
                    }
                }

                _PostMessage(pwnd, message, wParam, MAKELPARAM(pt.x, pt.y));

                pdesk->dwDTFlags &= ~DF_TRACKMOUSEHOVER;
                break;
            }
        }
        return;


        default:
            RIPMSG1(RIP_ERROR, "xxxSystemTimerProc: unexpected id: 0x%x", id);
            break;
    }

    /*
     * If we fell through, the timer's got to go.
     */
    _KillSystemTimer(pwnd, id);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\tooltips.c ===
/****************************** Module Header ******************************\
* Module Name: tooltips.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Implements system tooltips.
*
* History:
* 25-Aug-1996 vadimg    created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define TT_XOFFSET          2
#define TT_YOFFSET          1
#define TTT_SHOW            1
#define TTT_HIDE            2
#define TTT_ANIMATE         3
#define TT_ANIMATEDELAY     20

#define TTF_POSITIVE        0x00000001

#define bitsizeof(x) (sizeof(x) * 8)

LONG GreGetBitmapBits(HBITMAP, ULONG, PBYTE, PLONG);
DWORD CalcCaptionButton(PWND pwnd, int hit, LPWORD pcmd, LPRECT prcBtn, LPWORD pbm);
int HitTestScrollBar(PWND pwnd, int ht, POINT pt);
BOOL xxxHotTrackSB(PWND pwnd, int htEx, BOOL fDraw);

__inline void ZeroTooltip(PTOOLTIPWND pttwnd)
{
    RtlZeroMemory((PBYTE)pttwnd + (sizeof(TOOLTIPWND) - sizeof(TOOLTIP)),
            sizeof(TOOLTIP));
}

/***************************************************************************\
* GetTooltipDC
*
* 2/3/1998   vadimg          created
\***************************************************************************/

HDC GetTooltipDC(PTOOLTIPWND pttwnd)
{
    HDC hdc = _GetDCEx((PWND)pttwnd, NULL, DCX_WINDOW | DCX_CACHE |
            DCX_USESTYLE);

    if (hdc == NULL)
        return NULL;

    GreSelectFont(hdc, ghStatusFont);
    return hdc;
}

/***************************************************************************\
* InitTooltipAnimation
*
* Creates memory bitmap and DC for use by system tooltips. Gets the screen
* DC used throughout.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void InitTooltipAnimation(PTOOLTIPWND pttwnd)
{
    HDC hdc = GetTooltipDC(pttwnd);

    if ((pttwnd->hdcMem = GreCreateCompatibleDC(hdc)) == NULL) {
        return;
    }
    _ReleaseDC(hdc);
    GreSetDCOwner(pttwnd->hdcMem, OBJECT_OWNER_PUBLIC);
}

/***************************************************************************\
* DestroyTooltipBitmap
*
\***************************************************************************/

void DestroyTooltipBitmap(PTOOLTIPWND pttwnd)
{
    if (pttwnd->hbmMem == NULL)
        return;

    GreSelectBitmap(pttwnd->hdcMem, GreGetStockObject(PRIV_STOCK_BITMAP));
    GreDeleteObject(pttwnd->hbmMem);
    pttwnd->hbmMem = NULL;
}

/***************************************************************************\
* CreateTooltipBitmap
*
\***************************************************************************/

BOOL CreateTooltipBitmap(PTOOLTIPWND pttwnd, UINT cx, UINT cy)
{
    HDC hdc;

    if (pttwnd->hdcMem == NULL) {
        RIPMSG0(RIP_WARNING, "CreateTooltipBitmap: pttwnd->hdcMem is NULL");
        return FALSE;
    }

    DestroyTooltipBitmap(pttwnd);

    hdc = GetTooltipDC(pttwnd);
    pttwnd->hbmMem = GreCreateCompatibleBitmap(hdc, cx, cy);
    _ReleaseDC(hdc);

    if (pttwnd->hbmMem == NULL) {
        RIPMSG0(RIP_WARNING, "CreateTooltipBitmap: hbmMem is NULL");
        return FALSE;
    }
    GreSelectBitmap(pttwnd->hdcMem, pttwnd->hbmMem);
    return TRUE;
}

/***************************************************************************\
* CleanupTooltipAnimation
*
* Deletes memory bitmap and DC for use by system tooltips. Release the
* screen DC.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void CleanupTooltipAnimation(PTOOLTIPWND pttwnd)
{
    DestroyTooltipBitmap(pttwnd);

    if (pttwnd->hdcMem != NULL) {
        GreSetDCOwner(pttwnd->hdcMem, OBJECT_OWNER_CURRENT);
        GreDeleteDC(pttwnd->hdcMem);
    }
}

/***************************************************************************\
* TooltipAnimate
*
* Perform one frame of window animation. Just a simplified version of
* the AnimateWindow API.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

BOOL TooltipAnimate(PTOOLTIPWND pttwnd)
{
    int y, yMem, yReal, ny, iy, cx, cy;
    DWORD dwElapsed;
    HDC hdc;
    BOOL fRet = FALSE;

    if (pttwnd->pstr == NULL)
        return TRUE;

    hdc = GetTooltipDC(pttwnd);
    cx = pttwnd->rcWindow.right - pttwnd->rcWindow.left;
    cy = pttwnd->rcWindow.bottom - pttwnd->rcWindow.top;
    dwElapsed = NtGetTickCount() - pttwnd->dwAnimStart;
    iy = MultDiv(cy, dwElapsed, CMS_TOOLTIP);

    if (dwElapsed > CMS_TOOLTIP || iy == cy) {
        GreBitBlt(hdc, 0, 0, cx, cy, pttwnd->hdcMem, 0, 0, SRCCOPY | NOMIRRORBITMAP, 0);
        fRet = TRUE;
        goto Cleanup;
    } else if (pttwnd->iyAnim == iy) {
        goto Cleanup;
    }

    if (pttwnd->dwFlags & TTF_POSITIVE) {
        y = 0;
        ny = 0;
    } else {
        y = cy;
        ny = -1;
    }

    yReal = y + ny * iy;
    yMem = (pttwnd->dwFlags & TTF_POSITIVE) ? cy - iy : 0;
    pttwnd->iyAnim = iy;

    GreBitBlt(hdc, 0, yReal, cx, iy, pttwnd->hdcMem, 0, yMem, SRCCOPY | NOMIRRORBITMAP, 0);

Cleanup:
    _ReleaseDC(hdc);
    return fRet;
}

/***************************************************************************\
* GetCursorHeight
*
* This is tricky. We need to get the actual cursor size from the hotspot
* down to the end. There is no API in windows to do this, CYCURSOR is
* just the metric for the size of the bitmap, the cursor starts at the top
* of the bitmap and may be smaller than the bitmap itself.
*
* 12-Sep-96 vadimg      ported from common controls
\***************************************************************************/

int GetCursorHeight(void)
{
    int iAnd, iXor, dy = 16;
    WORD wMask[128];
    ICONINFO ii;
    BITMAP bm;
    PCURSOR pcur;
    long lOffset = 0;

    if ((pcur = PtiCurrent()->pq->spcurCurrent) == NULL) {
        return dy;
    }

    if (!_InternalGetIconInfo(pcur, &ii, NULL, NULL, NULL, FALSE)) {
        return dy;
    }

    if (!GreExtGetObjectW(ii.hbmMask, sizeof(bm), (LPSTR)&bm)) {
        goto Bail;
    }

    /*
     * Use the AND mask to get the cursor height if the XOR mask is there.
     */
    if (!GreGetBitmapBits(ii.hbmMask, sizeof(wMask), (BYTE*)wMask, &lOffset)) {
        goto Bail;
    }

    iAnd = (int)(bm.bmWidth * bm.bmHeight / bitsizeof(WORD));

    if (ii.hbmColor == NULL) {
        /*
         * if no color (XOR) bitmap, then the hbmMask is a double height bitmap
         * with the cursor and the mask stacked.
         */

        iXor = iAnd - 1;
        iAnd /= 2;
    } else {
        iXor = 0;
    }

    if (iAnd >= sizeof(wMask)) {
        iAnd = sizeof(wMask) - 1;
    }

    if (iXor >= sizeof(wMask)) {
        iXor = 0;
    }

    for (iAnd--; iAnd >= 0; iAnd--) {
        if ((iXor != 0 && wMask[iXor--] != 0) || wMask[iAnd] != 0xFFFF) {
            break;
        }
    }

    /*
     * Compute the distance between the pointer's lowest point and hotspot.
     */
    dy = (iAnd + 1) * bitsizeof(WORD) / (int)bm.bmWidth - (int)ii.yHotspot;

Bail:
    if (ii.hbmColor) {
        GreDeleteObject(ii.hbmColor);
    }

    if (ii.hbmMask) {
        GreDeleteObject(ii.hbmMask);
    }

    return dy;
}

/***************************************************************************\
* TooltipGetPosition
*
* Get the tooltip position on the screen taking into account the size of
* the tooltip and the screen. The TTF_POSITIVE flag determines if positive
* or negative animation is used.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

BOOL TooltipGetPosition(PTOOLTIPWND pttwnd, SIZE *psize, POINT *ppt)
{
    PMONITOR    pMonitor;

    *ppt = gpsi->ptCursor;
    pMonitor = _MonitorFromPoint(*ppt, MONITOR_DEFAULTTONULL);
    if (pMonitor == NULL) {
        return FALSE;
    }

    if (ppt->y + psize->cy >= pMonitor->rcMonitor.bottom) {
        ppt->y = ppt->y - psize->cy;
        pttwnd->dwFlags &= ~TTF_POSITIVE;
    } else {
        ppt->y += GetCursorHeight();
        pttwnd->dwFlags |= TTF_POSITIVE;
    }

    if (ppt->x + psize->cx >= pMonitor->rcMonitor.right) {
        ppt->x = pMonitor->rcMonitor.right - psize->cx;
    }

    if (ppt->x < pMonitor->rcMonitor.left) {
        ppt->x = pMonitor->rcMonitor.left;
    }

    return TRUE;
}

/***************************************************************************\
* xxxTooltipGetSize
*
* Estimate the size of the tooltip window based on the size of the text.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void xxxTooltipGetSize(PTOOLTIPWND pttwnd, SIZE *psize)
{
    HDC hdc;

    CheckLock(pttwnd);

    hdc = GetTooltipDC(pttwnd);

    if (CALL_LPK(PtiCurrentShared())) {
        xxxClientGetTextExtentPointW(hdc, pttwnd->pstr, wcslen(pttwnd->pstr), psize);
    } else {
        GreGetTextExtentW(hdc, pttwnd->pstr, wcslen(pttwnd->pstr),
                psize, GGTE_WIN3_EXTENT);
    }

    _ReleaseDC(hdc);
    psize->cx += SYSMET(CXEDGE) + 2 * SYSMET(CXBORDER) * TT_XOFFSET;
    psize->cy += SYSMET(CYEDGE) + 2 * SYSMET(CYBORDER) * TT_YOFFSET;
}

/***************************************************************************\
* xxxTooltipRender
*
* Render the tooltip window into the provided DC.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void xxxTooltipRender(PTOOLTIPWND pttwnd, HDC hdc)
{
    COLORREF crBk;
    UINT uFlags;
    RECT rc;

    CheckLock(pttwnd);

    if (pttwnd->pstr == NULL)
        return;

    GreSelectFont(hdc, ghStatusFont);
    GreSetTextColor(hdc, gpsi->argbSystem[COLOR_INFOTEXT]);
    crBk = gpsi->argbSystem[COLOR_INFOBK];

    CopyOffsetRect(&rc, &pttwnd->rcClient, -pttwnd->rcClient.left,
           -pttwnd->rcClient.top);

    /*
     * We don't want dithered colors, so FillRect with the nearest color.
     */
    if (crBk == GreGetNearestColor(hdc, crBk)) {
        GreSetBkColor(hdc, crBk);
        uFlags = ETO_OPAQUE;
    } else {
        FillRect(hdc, &rc, SYSHBR(INFOBK));
        GreSetBkMode(hdc, TRANSPARENT);
        uFlags = ETO_CLIPPED;
    }

    if (CALL_LPK(PtiCurrentShared())) {
        xxxClientExtTextOutW(hdc, SYSMET(CXBORDER) * TT_XOFFSET,
                SYSMET(CYBORDER) * TT_YOFFSET, uFlags, &rc, pttwnd->pstr,
                wcslen(pttwnd->pstr), NULL);
    } else {
        GreExtTextOutW(hdc, SYSMET(CXBORDER) * TT_XOFFSET,
                SYSMET(CYBORDER) * TT_YOFFSET, uFlags, &rc, pttwnd->pstr,
                wcslen(pttwnd->pstr), NULL);
    }
}

/***************************************************************************\
* FindNcHitEx
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

int FindNCHitEx(PWND pwnd, int ht, POINT pt)
{
    /*
     * Bug 263057 joejo
     * It seems that pwnd->spmenu can be released and set to null,
     * without the WFMPRESENT flag being cleared. Make sure that
     * we have a good pwnd->spmenu before continuing.
     */
    if (ht == HTMENU && pwnd->spmenu && TestWF(pwnd, WFMPRESENT)) {
        PMENU spmenu = pwnd->spmenu;
        PITEM pitem;
        int nItem;

        nItem = MNItemHitTest(spmenu, pwnd, pt);
        if (nItem >= 0) {
            pitem = (PITEM)&spmenu->rgItems[nItem];
            switch ((ULONG_PTR)pitem->hbmp) {
            case (ULONG_PTR)HBMMENU_SYSTEM:
                ht = HTMDISYSMENU;
                break;
            case (ULONG_PTR)HBMMENU_MBAR_RESTORE:
                ht = HTMDIMAXBUTTON;
                break;
            case (ULONG_PTR)HBMMENU_MBAR_MINIMIZE:
            case (ULONG_PTR)HBMMENU_MBAR_MINIMIZE_D:
                ht = HTMDIMINBUTTON;
                break;
            case (ULONG_PTR)HBMMENU_MBAR_CLOSE:
            case (ULONG_PTR)HBMMENU_MBAR_CLOSE_D:
                ht = HTMDICLOSE;
                break;
            case (ULONG_PTR)HBMMENU_CALLBACK:
                ht = HTERROR;
                break;
            default:
                ht = HTMENUITEM;
                break;
            }
        }
        return MAKELONG(ht, nItem);
    } else if (ht == HTVSCROLL && TestWF(pwnd, WFVPRESENT)) {
        return MAKELONG(HitTestScrollBar(pwnd, TRUE, pt), 1);
    } else if (ht == HTHSCROLL && TestWF(pwnd, WFHPRESENT)) {
        return MAKELONG(HitTestScrollBar(pwnd, FALSE, pt), 0);
    }

    return ht;
}

/***************************************************************************\
* KillTooltipTimer
*
* Kill the timer and zero out the timer id.
\***************************************************************************/
void KillTooltipTimer (PTOOLTIPWND pttwnd)
{
    UINT uTID = pttwnd->uTID;
    if (uTID != 0) {
        pttwnd->uTID = 0;
        _KillTimer((PWND)pttwnd, uTID);
    }
}
/***************************************************************************\
* SetTooltipTimer
*
\***************************************************************************/
void SetTooltipTimer (PTOOLTIPWND pttwnd, UINT uTID, UINT uDelay)
{
    KillTooltipTimer(pttwnd);
    pttwnd->uTID = uTID;
    InternalSetTimer((PWND)pttwnd, uTID, uDelay, NULL, 0);
}
/***************************************************************************\
* xxxResetTooltip
*
* Hide the tooltip, kill the timer, and zero out most of the struct members.
\***************************************************************************/

void xxxResetTooltip(PTOOLTIPWND pttwnd)
{
    KillTooltipTimer(pttwnd);

    CheckLock(pttwnd);

    if (TestWF(pttwnd, WFVISIBLE)) {
        PWND spwndMessage;
        TL tlpwnd;

        xxxSetWindowPos((PWND)pttwnd, NULL, 0, 0, 0, 0, SWP_NOSIZE |
                SWP_NOMOVE | SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER);

        spwndMessage = PWNDMESSAGE(pttwnd);
        ThreadLockAlways(spwndMessage, &tlpwnd);
        xxxSetParent((PWND)pttwnd, spwndMessage);
        ThreadUnlock(&tlpwnd);
    }

    ZeroTooltip(pttwnd);
    pttwnd->head.rpdesk->dwDTFlags &= ~DF_TOOLTIP;
}

/***************************************************************************\
* xxxShowTooltip
*
* Show the tooltip window.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

BOOL xxxShowTooltip(PTOOLTIPWND pttwnd)
{
    SIZE size;
    POINT pt;
    DWORD dwFlags;

    CheckLock(pttwnd);

    if (pttwnd->pstr == NULL)
        return FALSE;

    if (pttwnd->pstr == gszCAPTIONTOOLTIP) {

        PWND pwnd = PtiCurrent()->rpdesk->spwndTrack;
        /*
         * The window text might have changed in callbacks, retrieve it now
         */
        if (pwnd && TestWF(pwnd, WEFTRUNCATEDCAPTION) && pwnd->strName.Length) {
            wcsncpycch(gszCAPTIONTOOLTIP, pwnd->strName.Buffer, CAPTIONTOOLTIPLEN-1);
            gszCAPTIONTOOLTIP[CAPTIONTOOLTIPLEN-1] = 0;
        } else {
            return FALSE;
        }
    }

    xxxTooltipGetSize(pttwnd, &size);

    if (!TooltipGetPosition(pttwnd, &size, &pt)) {
        return FALSE;
    }

    dwFlags = SWP_CREATESPB | SWP_SHOWWINDOW | SWP_NOACTIVATE;
    if (TestEffectUP(TOOLTIPANIMATION)) {
        dwFlags |= SWP_NOREDRAW;
    }

    xxxSetWindowPos((PWND)pttwnd, PWND_TOP, pt.x, pt.y,
                    size.cx, size.cy, dwFlags);

    return TRUE;
}

/***************************************************************************\
* xxxTooltipHandleTimer
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

BOOL xxxTooltipHandleTimer(PTOOLTIPWND pttwnd, UINT uTID)
{
    BOOL fReturn = TRUE;

    switch(uTID) {
        case TTT_SHOW: {
            /*
             * Move the tooltip window to the desktop so it can
             *  be shown. Then show it.
             */
            PWND pwndDesktop = PWNDDESKTOP(pttwnd);
            TL tlpwnd;

            ThreadLockAlways(pwndDesktop, &tlpwnd);
            if (xxxSetParent((PWND)pttwnd, pwndDesktop) == NULL) {
                fReturn = FALSE;
            } else {
                fReturn = xxxShowTooltip(pttwnd);
            }
            ThreadUnlock(&tlpwnd);
            break;
        }

        case TTT_ANIMATE:
           /*
            * If animation is completed, set timer to hide
            */
           if (TooltipAnimate(pttwnd)) {
               SetTooltipTimer(pttwnd, TTT_HIDE, pttwnd->dwHideDelay);
           }
           break;

        case TTT_HIDE:
           /*
            * Hide it
            */
           xxxResetTooltip(pttwnd);
           break;
    }

    return fReturn;
}
/***************************************************************************\
* xxxTooltipWndProc
*
* The actual WndProc for the tooltip window.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

LRESULT xxxTooltipWndProc(PWND pwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    PTOOLTIPWND pttwnd;

    CheckLock(pwnd);
    VALIDATECLASSANDSIZE(pwnd, uMsg, wParam, lParam, FNID_TOOLTIP, WM_NCCREATE);
    pttwnd = (PTOOLTIPWND)pwnd;

    switch(uMsg) {
    case WM_TIMER:
        xxxTooltipHandleTimer(pttwnd, (UINT)wParam);
        break;

    case WM_PAINT:
        xxxBeginPaint(pwnd, &ps);
        xxxTooltipRender(pttwnd, ps.hdc);
        xxxEndPaint(pwnd, &ps);
        break;

    case WM_PRINTCLIENT:
        xxxTooltipRender(pttwnd, (HDC)wParam);
        break;

    case WM_ERASEBKGND:
        break;

    case WM_NCCREATE:
        InitTooltipDelay(pttwnd);
        InitTooltipAnimation(pttwnd);
        goto CallDWP;

    case WM_NCDESTROY:
        CleanupTooltipAnimation(pttwnd);
        GETPDESK(pttwnd)->dwDTFlags &= ~DF_TOOLTIP;
        goto CallDWP;

    case WM_WINDOWPOSCHANGED:
        if (((LPWINDOWPOS)lParam)->flags & SWP_SHOWWINDOW) {
            HDC hdc;
            int cx;
            int cy;

            if (!TestEffectUP(TOOLTIPANIMATION)) {
                SetTooltipTimer(pttwnd, TTT_HIDE, pttwnd->dwHideDelay);
                goto CallDWP;
            }

            hdc = NULL;
            cx = pttwnd->rcWindow.right - pttwnd->rcWindow.left;
            cy = pttwnd->rcWindow.bottom - pttwnd->rcWindow.top;

            /*
             * At this point we're sure that the window is showing and the size
             * has been changed and we're in the context of the desktop thread.
             */
            if (TestALPHA(TOOLTIPFADE)) {
                hdc = CreateFade((PWND)pttwnd, NULL, CMS_TOOLTIP,
                        FADE_SHOW | FADE_TOOLTIP);
            } else {
                if (CreateTooltipBitmap(pttwnd, cx, cy)) {
                    hdc = pttwnd->hdcMem;
                }
            }

            if (hdc == NULL) {
                SetTooltipTimer(pttwnd, TTT_HIDE, 0);
                goto CallDWP;
            }

            xxxSendMessage((PWND)pttwnd, WM_PRINT, (WPARAM)hdc,
                    PRF_CLIENT | PRF_NONCLIENT | PRF_CHILDREN | PRF_ERASEBKGND);

            /*
             * Start animation timer
             */

            if (TestFadeFlags(FADE_TOOLTIP)) {
                StartFade();
                SetTooltipTimer(pttwnd, TTT_HIDE, pttwnd->dwHideDelay);
            } else {
                pttwnd->dwAnimStart = NtGetTickCount();
                SetTooltipTimer(pttwnd, TTT_ANIMATE, TT_ANIMATEDELAY);
            }
        } else if (((LPWINDOWPOS)lParam)->flags & SWP_HIDEWINDOW) {
            if (TestFadeFlags(FADE_TOOLTIP)) {
                StopFade();
            } else {
                DestroyTooltipBitmap(pttwnd);
            }
        }
        goto CallDWP;

    default:
CallDWP:
        return xxxDefWindowProc(pwnd, uMsg, wParam, lParam);
    }

    return 0;
}

/***************************************************************************\
* IsTrackedHittest
*
* Should we be tracking this hittest code? Return the track string if yes.
* If on caption returning the window strName.Buffer could
* make the system bugcheck if there is a SetWindowText in the callback.
\***************************************************************************/
LPWSTR IsTooltipHittest(PWND pwnd, UINT ht)
{
    switch (ht) {
    case HTMINBUTTON:
        if (TestWF(pwnd, WFMINBOX)) {
            return (TestWF(pwnd, WFMINIMIZED)) ? gszRESUP : gszMIN;
        }
        break;

    case HTMAXBUTTON:
        if (TestWF(pwnd, WFMAXBOX)) {
            return (TestWF(pwnd, WFMAXIMIZED)) ? gszRESDOWN : gszMAX;
        }
        break;

    case HTCLOSE:
    case HTMDICLOSE:
        return gszSCLOSE;

/*  Commented out due to TandyT ...
    case HTSYSMENU:
    case HTMDISYSMENU:
        return gszSMENU;
*/
    case HTHELP:
        return gszHELP;

    case HTMDIMINBUTTON:
        return gszMIN;

    case HTMDIMAXBUTTON:
        return gszRESDOWN;

    case HTCAPTION:
        /*
         * We only show the caption tooltip if the window text
         * doesn't fit entirely on the caption.  We will fill
         * gszCAPTIONTOOLTIP right before showing the text
         */
        if (TestWF(pwnd, WEFTRUNCATEDCAPTION)) {
            return gszCAPTIONTOOLTIP;
        }
        break;

    default:
        break;
    }
    return NULL;
}

/***************************************************************************\
* xxxHotTrackMenu
*
* Hot-track a menu item in the menu bar.
\***************************************************************************/
BOOL xxxHotTrackMenu(PWND pwnd, UINT nItem, BOOL fDraw)
{
    PMENU pmenu = pwnd->spmenu;
    PITEM pItem;
    HDC   hdc;
    UINT  oldAlign;
    TL tlpmenu;

    CheckLock(pwnd);

    /*
     * The window may have lied about the hit-test code on
     * WM_NCHITTEST. Make sure it does indeed have a menu.
     */
    if (!TestWF(pwnd, WFMPRESENT) || pmenu == NULL)
        return FALSE;

    if (nItem >= pmenu->cItems) {
        RIPMSG0(RIP_WARNING, "xxxHotTrackMenu: menu too large");
        return FALSE;
    }

    pItem = &pmenu->rgItems[nItem];

    /*
     * Make sure we draw on the right spot
     */
    ThreadLock(pmenu, &tlpmenu);
    xxxMNRecomputeBarIfNeeded(pwnd, pmenu);
    ValidateThreadLocks(NULL, PtiCurrent()->ptl, (ULONG_PTR)&tlpmenu, TRUE);

    if (fDraw) {
        if (TestMFS(pItem, MF_GRAYED)) {
            ThreadUnlock(&tlpmenu);
            return FALSE;
        }
        SetMFS(pItem, MFS_HOTTRACK);
    } else {
        ClearMFS(pItem, MFS_HOTTRACK);
    }

    hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    GreSelectBrush(hdc, SYSHBR(MENUTEXT));
    GreSelectFont(hdc, ghMenuFont);

    oldAlign = GreGetTextAlign(hdc);
    if (pmenu->rgItems && TestMFT(pmenu->rgItems, MFT_RIGHTORDER))
        GreSetTextAlign(hdc, oldAlign | TA_RTLREADING);

    /*
     * When the item is not owner draw, xxxDrawMenuItem does not
     * call back and does not leave the critical section.
     */
    xxxDrawMenuItem(hdc, pmenu, pItem, 0);
    GreSetTextAlign(hdc, oldAlign);
    ThreadUnlock(&tlpmenu);

    _ReleaseDC(hdc);
    return TRUE;
}


/***************************************************************************\
* HotTrackCaption
*
* Hot-track a caption button.
\***************************************************************************/

#ifdef COLOR_HOTTRACKING

BOOL xxxHotTrackCaption(PWND pwnd, int ht, BOOL fDraw)
{
    DWORD dwWhere;
    int   x, y;
    WORD  bm, cmd;
    RECT  rcBtn;
    HDC   hdc;

    CheckLock(pwnd);

    if (!TestWF(pwnd, WFCPRESENT))
        return FALSE;

    dwWhere = xxxCalcCaptionButton(pwnd, ht, &cmd, &rcBtn, &bm);
    x = GET_X_LPARAM(dwWhere);
    y = GET_Y_LPARAM(dwWhere);

    if (!cmd)
        return FALSE;

    hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    BitBltSysBmp(hdc, x, y, bm + (fDraw ? DOBI_HOT : 0));
    _ReleaseDC(hdc);
    return TRUE;
}

#endif // COLOR_HOTTRACKING

/***************************************************************************\
* xxxHotTrack
*
\***************************************************************************/

BOOL xxxHotTrack(PWND pwnd, int htEx, BOOL fDraw)
{
    int ht = LOWORD(htEx);

    CheckLock(pwnd);

    switch(ht) {
#ifdef COLOR_HOTTRACKING
    case HTMINBUTTON:
    case HTMAXBUTTON:
    case HTHELP:
    case HTCLOSE:
        return xxxHotTrackCaption(pwnd, ht, fDraw);

    case HTSCROLLUP:
    case HTSCROLLDOWN:
    case HTSCROLLUPPAGE:
    case HTSCROLLDOWNPAGE:
    case HTSCROLLTHUMB:
        return xxxHotTrackSB(pwnd, htEx, fDraw);

    case HTMDIMINBUTTON:
    case HTMDIMAXBUTTON:
    case HTMDICLOSE:
#endif // COLOR_HOTTRACKING
    case HTMENUITEM:
        return xxxHotTrackMenu(pwnd, HIWORD(htEx), fDraw);

    }

    return FALSE;
}

/***************************************************************************\
* xxxCreateTooltip
*
* Call this to show a new tooltip with a new string and delay.
\***************************************************************************/

BOOL xxxCreateTooltip(PTOOLTIPWND pttwnd, LPWSTR pstr)
{
    CheckLock(pttwnd);

    /*
     * Store new text
     */
    pttwnd->pstr = pstr;
    /*
     * If already visible, hide it and show it in new place.
     *  Otherwise, set timer to show.
     */
    if (TestWF(pttwnd, WFVISIBLE)) {
        xxxSetWindowPos((PWND)pttwnd, NULL, 0, 0, 0, 0, SWP_NOSIZE |
                SWP_NOMOVE | SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSENDCHANGING);
        return xxxShowTooltip(pttwnd);
    } else {
        SetTooltipTimer(pttwnd, TTT_SHOW, pttwnd->dwShowDelay);
    }

    return TRUE;
}

/***************************************************************************\
* xxxTrackMouseMove
*
* This is the entry point for the system tooltips and hot-tracking.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void xxxTrackMouseMove(PWND pwnd, int htEx, UINT message)
{
    BOOL fNewpwndTrack;
    DWORD dwDTCancel = 0;
    TL tlpwnd;
    LPWSTR pstr;
    PDESKTOP pdesk = PtiCurrent()->rpdesk;
    PTHREADINFO ptiTrack;


#if DBG
    /*
     * Let's warn if this function gets reenterd so we can make sure
     * nothing bad will follow. This should be a rare situation.
     * Look in gptiReEntered to find out who is already here.
     */
    static UINT gcReEntered = 0;
    static PTHREADINFO gptiReEntered;
    if(gcReEntered++ != 0){
      RIPMSG2(RIP_WARNING, "Reentered xxxTrackMouseMove; previous thread was %#p, current thread is %#p", gptiReEntered, PtiCurrent());
    }
    gptiReEntered = PtiCurrent();

    CheckLock(pwnd);

    /*
     * We must be on an interactive window station.
     */
    if (pdesk->rpwinstaParent != NULL &&
            pdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO) {
        RIPMSG0(RIP_ERROR, "Can't use tooltips on non-interactive winsta");
    }

     {
        static POINT pt = {0, 0};

#ifdef UNDONE
        /*
         * We might have taken a guess on the hit test (see FindNCHitEx)
         *  so if we're at the same point and same window, something
         *  might be fishy
         */
        if ((pt.x == gpsi->ptCursor.x)
                    && (pt.y == gpsi->ptCursor.y)
                    && (pdesk->spwndTrack == pwnd)) {
            RIPMSG1(RIP_WARNING, "xxxTrackMouseMove: Same point & window. %#p", pwnd);
        }
#endif

        /*
         * Something is supposed to have changed or we're wasting time
         */
        UserAssert((pt.x != gpsi->ptCursor.x)
                    || (pt.y != gpsi->ptCursor.y)
                    || (pdesk->spwndTrack != pwnd)
                    || (pdesk->htEx != htEx)
                    || (message != WM_MOUSEMOVE));
        /*
         * Remember last tracked point
         */
        pt = gpsi->ptCursor;
     }
    /*
     * pwnd is supposed to be on the current thread and queue
     */
    UserAssert(PtiCurrent() == GETPTI(pwnd));
    UserAssert(PtiCurrent()->pq == GETPTI(pwnd)->pq);
#endif

    /*
     * Have we switched windows?
     */
    fNewpwndTrack = (pdesk->spwndTrack != pwnd);
    /*
     * If no tracking is taking place, just go set the new
     *  tracking state
     */
    if (!(pdesk->dwDTFlags & DF_MOUSEMOVETRK)) {
        goto SetNewState;
    }
    /*
     * Potentially while we leave the critical section below in
     * xxxCancelMouseMoveTracking, spwndTrack could be destroyed and unlocked
     * and then we go and create the tooltip. This would mean that
     * DF_TOOLTIPACTIVE (part of DF_MOUSEMOVETRK test above) would be set,
     * but pdesk->spwndTrack would be NULL and we can AV dereferencing
     * pdesk->spwndTrack below. Prevent this by making the check here.
     */
    if (pdesk->spwndTrack == NULL) {
        goto SetNewState;
    }

    /*
     * Nuke hottracking and deactivate tooltip state, if any.
     * Do it sychronously if we're tracking on the current queue;
     *  Otherwise, post an event and let it happen later.
     */
    ptiTrack = GETPTI(pdesk->spwndTrack);
    if  (PtiCurrent()->pq == ptiTrack->pq) {
        dwDTCancel |= DF_HOTTRACKING;
    } else if (pdesk->dwDTFlags & (DF_HOTTRACKING | DF_TOOLTIPACTIVE)) {
        PostEventMessage(ptiTrack, ptiTrack->pq,
                        QEVENT_CANCELMOUSEMOVETRK,
                        pdesk->spwndTrack,
                        pdesk->dwDTFlags,
                        pdesk->htEx, DF_HOTTRACKING);
       /*
        * Paranoid assertion. If we're switching queues, we must
        *  be switching windows. Did we just go through
        *  ReattachThreads?
        */
        UserAssert(pwnd != pdesk->spwndTrack);
        pdesk->dwDTFlags &= ~(DF_HOTTRACKING | DF_TOOLTIPACTIVE);
    }
    /*
     * If we're on the client area or the user clicked,
     *  nuke the tooltip (if any).
     * Since we might want to re-show the tooltip, we don't nuke it
     *  now if we swichted windows (we'll nuke it later if needed)
     */
    if ((htEx == HTCLIENT) || (message != WM_MOUSEMOVE)) {
        dwDTCancel |= DF_TOOLTIPACTIVE;
    }
    /*
     * If we switched windows or crossed client/nonclinet boundaries,
     *  end track mouse leave/hover.
     */
    if (fNewpwndTrack || ((pdesk->htEx == HTCLIENT) ^ (htEx == HTCLIENT))) {
        dwDTCancel |= DF_TRACKMOUSEEVENT;
    }
    /*
     * Cancel whatever is active and needs to go away
     */
    ThreadLockAlways(pdesk->spwndTrack, &tlpwnd);
    xxxCancelMouseMoveTracking(pdesk->dwDTFlags,
                           pdesk->spwndTrack,
                           pdesk->htEx,
                           dwDTCancel);
    ThreadUnlock(&tlpwnd);
    pdesk->dwDTFlags &= ~dwDTCancel;



SetNewState:
    /*
     * Hottracking/tooltip on mouse move if on NC hitest and enabled
     */
    if ((htEx != HTCLIENT) && (message == WM_MOUSEMOVE) && TestEffectUP(HOTTRACKING)) {
        /*
         * Hottrack the new hit test area
         */
        if (xxxHotTrack(pwnd, htEx, TRUE)) {
            pdesk->dwDTFlags |= DF_HOTTRACKING;
        }

        /*
         * Remove/set the tool tip.
         * We always do this synchronously because it doesn't mess
         *  with pwnd's or spwnTrack's queue
         */
        if ((pstr = IsTooltipHittest(pwnd, LOWORD(htEx))) != NULL) {
            PTOOLTIPWND pttwnd = (PTOOLTIPWND)pdesk->spwndTooltip;
            ThreadLockAlways(pttwnd, &tlpwnd);
            if (xxxCreateTooltip(pttwnd, pstr)) {
                pdesk->dwDTFlags |= DF_TOOLTIP;
            }
            ThreadUnlock(&tlpwnd);
        } else  {
            PTOOLTIPWND pttwnd = (PTOOLTIPWND)pdesk->spwndTooltip;
            ThreadLockAlways(pttwnd, &tlpwnd);
            xxxResetTooltip(pttwnd);
            ThreadUnlock(&tlpwnd);
        }
    } /* if (htEx != HTCLIENT) */


    ValidateThreadLocks(NULL, PtiCurrent()->ptl, (ULONG_PTR)&pwnd, TRUE);

    /*
     * Update new track window if needed.
     */
    if (fNewpwndTrack) {
        PWND pwndActivate;

         Lock(&pdesk->spwndTrack, pwnd);
        /*
         * Active window tracking.
         * If there is non-zero timeout, get the window we're supposed to activate
         *  and set the timer. Otherwise, set the queue flag so
         *  xxxActiveWindowTracking can do its thing.
         */
         if ((message == WM_MOUSEMOVE) && TestUP(ACTIVEWINDOWTRACKING)) {
             if (UP(ACTIVEWNDTRKTIMEOUT) != 0) {
                 pwndActivate = GetActiveTrackPwnd(pwnd, NULL);
                 if (pwndActivate != NULL) {
                     InternalSetTimer(pwndActivate, IDSYS_WNDTRACKING,
                                     UP(ACTIVEWNDTRKTIMEOUT),
                                     xxxSystemTimerProc, TMRF_SYSTEM);
                 }
             } else {
                 PtiCurrent()->pq->QF_flags |= QF_ACTIVEWNDTRACKING;
             } /* if (TestUP(ACTIVEWNDTRKZORDER)) */
         } /* if (TestUP(ACTIVEWINDOWTRACKING)) */

    }

    /*
     * Save new hit test code
     */
    pdesk->htEx = htEx;

#if DBG
    --gcReEntered;
#endif
}

/***************************************************************************\
* xxxCancelMouseMoveTracking
*
* History
* 12/07/96 GerardoB  Created
\***************************************************************************/
void xxxCancelMouseMoveTracking (DWORD dwDTFlags, PWND pwndTrack, int htEx, DWORD dwDTCancel)
{

    CheckLock(pwndTrack);
    /*
     * Hottracking
     */
    if ((dwDTFlags & DF_HOTTRACKING) && (dwDTCancel & DF_HOTTRACKING)) {
        /*
         * The current state must be owned by the current queue.
         * Otherwise, we're about to do an inter-queue cancelation.
         */
        UserAssert(PtiCurrent()->pq == GETPTI(pwndTrack)->pq);

        xxxHotTrack(pwndTrack, htEx, FALSE);
    }

    /*
     * Tooltips
     */
    if ((dwDTFlags & DF_TOOLTIPSHOWING) && (dwDTCancel & DF_TOOLTIP)) {
        PTOOLTIPWND pttwnd = (PTOOLTIPWND)PWNDTOOLTIP(pwndTrack);
        TL tlpwnd;

        ThreadLockAlways(pttwnd, &tlpwnd);
        xxxResetTooltip(pttwnd);
        ThreadUnlock(&tlpwnd);
    }

    /*
     * Mouse Leave
     */
    if ((dwDTFlags & DF_TRACKMOUSELEAVE) && (dwDTCancel & DF_TRACKMOUSELEAVE)) {
        _PostMessage(pwndTrack,
                     ((htEx == HTCLIENT) ? WM_MOUSELEAVE : WM_NCMOUSELEAVE),
                     0, 0);
    }

    /*
     * Mouse Hover
     */
    if ((dwDTFlags & DF_TRACKMOUSEHOVER) && (dwDTCancel & DF_TRACKMOUSEHOVER)) {
        _KillSystemTimer(pwndTrack, IDSYS_MOUSEHOVER);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\tmswitch.c ===
/****************************** Module Header ******************************\
* Module Name: tmswitch.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 29-May-1991 DavidPe   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * COOLSWITCHTRACE is used to trace problems
 * in the CoolSwitch window
 */
#undef COOLSWITCHTRACE


#define ALT_F6          2
#define ALT_ESCAPE      1

#define FDIR_FORWARD    0
#define FDIR_BACKWARD   1


/*
 *  Win95 hard codes the size of the icon matrix, the size of
 *  the icons, the highlight border and the icon spacing
 */
#define CXICONSLOT      43
#define CYICONSLOT      43
#define CXICONSIZE      32
#define CYICONSIZE      32

/*
 * Pointer to the start of the SwitchInfo list.
 */
PSWINFO gpswiFirst;


VOID xxxPaintIconsInSwitchWindow(PWND, PSWINFO, HDC, INT, INT, INT, BOOL, BOOL, PICON);

/***************************************************************************\
* Getpswi
*
* 04-29-96 GerardoB  Created
\***************************************************************************/
__inline PSWINFO Getpswi(
    PWND pwnd)
{
    UserAssert(GETFNID(pwnd) == FNID_SWITCH);
    return TestWF(pwnd, WFDESTROYED) ? NULL : ((PSWITCHWND)pwnd)->pswi;
}

/***************************************************************************\
* Setpswi
*
* 04-29-96 GerardoB  Created
\***************************************************************************/
__inline VOID Setpswi(
    PWND pwnd,
    PSWINFO pswi)
{
    UserAssert(GETFNID(pwnd) == FNID_SWITCH);
    ((PSWITCHWND)pwnd)->pswi = pswi;
}

/***************************************************************************\
* DSW_GetTopLevelCreatorWindow
\***************************************************************************/
PWND DSW_GetTopLevelCreatorWindow(
    PWND pwnd)
{
    UserAssert(pwnd != NULL);

    if (pwnd != NULL) {
        while (pwnd->spwndOwner) {
            pwnd = pwnd->spwndOwner;
        }
    }

    return pwnd;
}

/***************************************************************************\
* GetNextQueueWindow
*
* This routine is used to implement the Alt+Esc feature.  This feature lets
* the user switch between windows for different applications (a.k.a. "Tasks")
* currently running.  We keep track of the most recently active window in
* each task.  This routine starts with the window passed and searches for the
* next window, in the "top-level" window list, that is from a different task
* than the one passed.  We then return the most recenly active window from
* that task (or the window we found if the most recently active has been
* destroyed or is currently disabled or hidden).  This routine returns NULL
* if no other enabled, visible window for another task can be found.
*
* History:
* 30-May-1991 DavidPe   Ported from Win 3.1 sources.
\***************************************************************************/
PWND _GetNextQueueWindow(
    PWND pwnd,
    BOOL fPrev, /* 1 backward 0 forward */
    BOOL fAltEsc)
{
    PWND        pwndAltTab;
    PWND        pwndNext;
    PWND        pwndT;
    PWND        pwndDesktop;
    BOOL        bBeenHereAlready = FALSE;

    /*
     * If the window we receive is Null then use the last topmost window
     */
    if (!pwnd) {
        pwnd = GetLastTopMostWindow();
        if (!pwnd) {
            return NULL;
        }
    }

    pwndAltTab = gspwndAltTab;

    pwnd = pwndNext = GetTopLevelWindow(pwnd);
    if (!pwndNext) {
        return NULL;
    }

    /*
     * Get the window's desktop
     */
    if ((pwndDesktop = pwndNext->spwndParent) == NULL) {
        pwndDesktop = grpdeskRitInput->pDeskInfo->spwnd;
        pwnd = pwndNext = pwndDesktop->spwndChild;
    }

    while (TRUE) {

        if (pwndNext == NULL)
            return NULL;

        /*
         *  Get the next window
         */
        pwndNext = _GetWindow(pwndNext, fPrev ? GW_HWNDPREV : GW_HWNDNEXT);

        if (!pwndNext) {

            pwndNext = fPrev ? _GetWindow(pwndDesktop->spwndChild, GW_HWNDLAST)
                             : pwndDesktop->spwndChild;
            /*
             * To avoid searching the child chain forever, bale out if we get
             * to the end (beginning) of the chain twice.
             * This happens if pwnd is a partially destroyed window that has
             * been unlinked from its siblings but not yet unlinked from the
             * parent. (Happens while sending WM_NCDESTROY in xxxFreeWindow)
             */
            if (bBeenHereAlready) {
                RIPMSG1(RIP_WARNING, "pwnd %#p is no longer a sibling", pwnd);
                return NULL;
            }

            bBeenHereAlready = TRUE;
        }

        /*
         *  If we have gone all the way around with no success, return NULL.
         */
        if (!pwndNext || (pwndNext == pwnd))
            return NULL;

        /*
         *  Ignore the following windows:
         *      Switch window
         *      Tool Windows
         *      NoActivate Windows
         *      Hidden windows
         *      Disabled windows
         *      Topmost windows if via Alt+Esc
         *      Bottommost windows if via Alt+Esc
         *
         *  If we're doing Alt-Esc processing, we have to skip topmost windows.
         *
         *  Because topmost windows don't really go to the back when we
         *  send them there, alt-esc would never enumerate non-topmost windows.
         *  So, although we're allowed to start enumeration at a topmost window,
         *  we only allow enumeration of non-topmost windows, so the user can
         *  enumerate his presumably more important applications.
         */
        if ((pwndNext != pwndAltTab) &&
// BradG - Win95 is missing the check for Tool Windows
            (!TestWF(pwndNext, WEFTOOLWINDOW)) &&
            (!TestWF(pwndNext, WEFNOACTIVATE)) &&
            (TestWF(pwndNext, WFVISIBLE)) &&
            ((pwndNext->spwndLastActive == NULL) || (!TestWF(pwndNext->spwndLastActive, WFDISABLED)) &&
            (!fAltEsc || (!TestWF(pwndNext, WEFTOPMOST) && !TestWF(pwndNext, WFBOTTOMMOST))))) {
            /*
             * If this window is owned, don't return it unless it is the most
             * recently active window in its owner/ownee group.
             */
            /*
             *  Hard loop to find top level owner
             */
            for (pwndT = pwndNext; pwndT->spwndOwner; pwndT = pwndT->spwndOwner)
                ;

            /*
             *  Don't return it unless it is the most recently active
             *  window in its owner/ownee group.
             */
            if (pwndNext == pwndT->spwndLastActive)
                return pwndNext;
        }
    }
}

/***************************************************************************\
*
* SwitchToThisWindow()
*
* This function was added specifically for Win386.  It is called to tell
* USER that a particular window has been switched to via Alt+Tab or
* Alt+Esc in the Win386 environment.  They call this function to maintain
* Z-ordering and consistent operation of these two functions.  This function
* must be exported, but need not be documented.
*
* The parameter fTab is TRUE if this window is to be switched to via an
* Alt/Ctl+Tab key sequence otherwise it must be FALSE.
*
* History:
* 04-Feb-1991 DarrinM   Created.
\***************************************************************************/

VOID xxxSwitchToThisWindow(
    PWND pwnd,
    BOOL fAltTab)
{
    CheckLock(pwnd);

    /*
     *  If we need to, push old window to the bottom.
     */
    if (gpqForeground && !fAltTab) {

        BOOL fPush;
        PWND pwndActive;
        TL   tlpwndActive;

        /*
         *  if ALT-ESC, and the window brought forward is the next one in the
         *  list, we must be rotating the zorder forward, so push the current
         *  window to the back
         */
        pwndActive = gpqForeground->spwndActive;
        fPush = pwndActive && _GetNextQueueWindow(pwndActive, FDIR_FORWARD, !fAltTab);
        if (fPush && !TestWF(pwndActive, WEFTOPMOST) && !TestWF(pwndActive, WFBOTTOMMOST)) {
            ThreadLock(pwndActive, &tlpwndActive);
            xxxSetWindowPos(pwndActive, PWND_BOTTOM, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_ASYNCWINDOWPOS);
            ThreadUnlock(&tlpwndActive);
        }
    }

    /*
     *  Switch this new window to the foreground
     *  This window can go away during the SetForeground call if it isn't
     *  on the thread calling SwitchToThisWindow()!
     */
    xxxSetForegroundWindow(pwnd, TRUE);

    /*
     * Restore minimized windows if the Alt+Tab case
     */
    if (fAltTab && TestWF(pwnd,WFMINIMIZED)) {

        /*
         * We need to package up a special 'posted' queue message here.  This
         * ensures that this message gets processed after the asynchronous
         * activation event occurs (via SetForegroundWindow).
         */
        PostEventMessage(GETPTI(pwnd), GETPTI(pwnd)->pq,
                         QEVENT_POSTMESSAGE, pwnd, WM_SYSCOMMAND,
                         SC_RESTORE, 0 );
    }
}

/***************************************************************************\
* NextPrevTaskIndex
*
* History:
* 01-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

INT NextPrevTaskIndex(
    PSWINFO pswInfo,
    INT     iIndex,
    INT     iCount,
    BOOL    fNext)
{
    UserAssert(iCount <= pswInfo->iTotalTasks);

    if (fNext) {
        iIndex += iCount;
        if (iIndex >= pswInfo->iTotalTasks) {
            iIndex -= pswInfo->iTotalTasks;
        }
    } else {
        iIndex -= iCount;
        if (iIndex < 0) {
            iIndex += pswInfo->iTotalTasks;
        }
    }

    UserAssert((iIndex >= 0) && (iIndex < pswInfo->iTotalTasks));
    return iIndex;
}

/***************************************************************************\
* NextPrevPhwnd
*
* Given a pointer to one entry in the window list, this can return
* the pointer to the next/prev entry in a circular list fashion.
*
* History:
* 01-Jun-1995 BradG     Ported from Win95
\***************************************************************************/
PHWND NextPrevPhwnd(
    PSWINFO pswInfo,
    PHWND   phwnd,
    BOOL    fNext)
{
    PBWL  pbwl;
    PHWND phwndStart;
    PHWND phwndLast;

    pbwl = pswInfo->pbwl;
    phwndStart = &(pbwl->rghwnd[0]);
    phwndLast = pswInfo->phwndLast;

    UserAssert(*phwndLast == (HWND)1);   // Last entry must have a 1.
    UserAssert(phwndStart < phwndLast);  // There must be atleast one entry.
    UserAssert(phwnd != phwndLast);      // Can't be passing in an invalid entry.

    if (fNext) {
        phwnd++;
        if (phwnd == phwndLast) {
            phwnd = phwndStart;
        }
    } else {
        if (phwnd == phwndStart) {
            phwnd = phwndLast - 1;  // we have atleast one valid entry.
        } else {
            phwnd--;
        }
    }

    return phwnd;
}

/***************************************************************************\
* _IsTaskWindow
*
* History:
* 01-Jun-95 BradG       Ported from Win95
\***************************************************************************/

BOOL _IsTaskWindow(
    PWND pwnd,
    PWND pwndActive)
{
    /*
     *  Following windows do not qualify to be shown in task list:
     *  Switch  Window, Hidden windows (unless they are the active
     *  window), Disabled windows, Kanji Conv windows.
     *
     *  Also, check for a combobox popup list which has the top-most
     *  style (it's spwndLastActive will be NULL).
     */
    UserAssert(pwnd != NULL);
    return( (TestWF(pwnd, WEFAPPWINDOW)
                || (!TestWF(pwnd, WEFTOOLWINDOW) && !TestWF(pwnd, WEFNOACTIVATE))) &&
            (TestWF(pwnd, WFVISIBLE) || (pwnd == pwndActive)) &&
            (!(pwnd->spwndLastActive && TestWF(pwnd->spwndLastActive, WFDISABLED))));
}

/***************************************************************************\
* RemoveNonTaskWindows()
*
* Given a list of Windows, this walks down the list and removes the
* windows that do not qualify to be shown in the Task-Switch screen.
* This also shrinks the list when it removes some entries.
* Returns the total number of "tasks" (windows) qualified and remained
* in the list. The last entry will have a 1 as usual.
* It also returns a pointer to this last entry via params. It also
* returns the index of the Currently active task via params.
*
* History:
* 01-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

INT _RemoveNonTaskWindows(
    PBWL  pbwl,
    PWND  pwndActive,
    LPINT lpiActiveTask,
    PHWND *pphwndLast)
{
    INT   iTaskCount = 0;
    PHWND phwnd;
    PWND  pwnd;
    PWND  pwndUse;
    PWND  pwndOwnee;
    PHWND phwndHole;

    *lpiActiveTask = -1;

    /*
     * Walk down the window list and do the following:
     *   1. Remove all entries that do not qualify to be shown in the task list.
     *   2. Count the total number of windows that qualify.
     *   3. Get the pointer to the entry that contains current active window.
     *   4. Get the pointer to the last dummy entry (that has 1 in it)
     */
    for (phwndHole = phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        pwnd = RevalidateHwnd(*phwnd);
        if (!pwnd) {
            continue;
        }

        if (_IsTaskWindow(pwnd, pwndActive)) {
            pwndUse = pwnd;

            /*
             * First let's find the task-list owner of this window.
             */
            while (!TestWF(pwndUse, WEFAPPWINDOW) && pwndUse->spwndOwner) {
                pwndOwnee = pwndUse;
                pwndUse = pwndUse->spwndOwner;
                if (TestWF(pwndUse, WEFTOOLWINDOW)) {
                    /*
                     * If this is the owner of a top level property sheet,
                     *  show the property sheet.
                     */
                    if (TestWF(pwndOwnee, WEFCONTROLPARENT) && (pwndUse->spwndOwner == NULL)) {
                        pwndUse = pwnd;
                    } else {
                        pwndUse = NULL;
                    }
                    break;
                }
            }

            if (!pwndUse || !pwndUse->spwndLastActive) {
                continue;
            }

            /*
             *  walk up from the last active window 'til we find a valid task
             *  list window or until we run out of windows in the ownership
             *  chain
             */
            for (pwndUse = pwndUse->spwndLastActive; pwndUse; pwndUse = pwndUse->spwndOwner)
                if (_IsTaskWindow(pwndUse, pwndActive))
                    break;

            /*
             *  if we ran out of windows in the ownership chain then use the
             *  owned window itself -- or if we didn't run out of the ownership
             *  chain, then only include this window if it's the window in the
             *  ownership chain that we just found (VB will love us for it !)
             *  -- jeffbog -- 4/20/95 -- Win95C B#2821
             */
            if (!pwndUse || (pwndUse == pwnd)) {

                /*
                 *  Do we have any holes above this? If so, move this handle to
                 *  that hole.
                 */
                if (phwndHole < phwnd) {

                    /*
                     * Yes! There is a hole. Let us move the valid
                     * handle there.
                     */
                    *phwndHole = *phwnd;
                }

                if (pwndActive == pwnd)
                    *lpiActiveTask = iTaskCount;
                iTaskCount++;
                phwndHole++;  // Move to the next entry.
            }

            /*
             *  Else, leave it as a hole for later filling.
             */
        }
    }

    *phwndHole = (HWND)1;
    *pphwndLast = phwndHole;

    return iTaskCount;
}

/***************************************************************************\
* DrawSwitchWndHilite()
*
* This draws or erases the Hilite we draw around the icon to show which
* task we are going to switch to.
* This also updates the name on the Task title window.
*
* History:
* 01-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

VOID DrawSwitchWndHilite(
    PSWINFO pswInfo,
    HDC     hdcSwitch,
    int     iCol,
    int     iRow,
    BOOL    fShow)
{
    BOOL        fGetAndReleaseIt;
    RECT        rcTemp;

    /*
     *  Draw or erase the hilite depending on "fShow".
     */
    if (fGetAndReleaseIt = (hdcSwitch == NULL))
        hdcSwitch = _GetDCEx(gspwndAltTab, NULL, DCX_USESTYLE);

    rcTemp.left   = pswInfo->ptFirstRowStart.x + iCol * CXICONSLOT;
    rcTemp.top    = pswInfo->ptFirstRowStart.y + iRow * CYICONSLOT;
    rcTemp.right  = rcTemp.left + CXICONSLOT;
    rcTemp.bottom = rcTemp.top + CYICONSLOT;

    DrawFrame(hdcSwitch,
              &rcTemp,
              2,
              DF_PATCOPY | ((fShow ? COLOR_HIGHLIGHT : COLOR_3DFACE) << 3));


    /*
     *  Update the Task title window.
     */
    if (fShow) {
        WCHAR    szText[CCHTITLEMAX];
        INT      cch;
        COLORREF clrOldText, clrOldBk;
        PWND     pwnd;
        RECT     rcRect;
        HFONT    hOldFont;
        INT      iLeft;
        ULONG_PTR dwResult = 0;

        clrOldText = GreSetTextColor(hdcSwitch, SYSRGB(BTNTEXT));
        clrOldBk   = GreSetBkColor(hdcSwitch, SYSRGB(3DFACE));
        hOldFont = GreSelectFont(hdcSwitch, gpsi->hCaptionFont);


        /*
         * Validate this window handle; This could be some app that terminated
         * in the background and the following line will GP fault in that case;
         * BOGUS: We should handle it some other better way.
         */
        pwnd = RevalidateHwnd( *(pswInfo->phwndCurrent) );
        if (pwnd) {
            /*
             *  Get the window's title.
             */
            if (pwnd->strName.Length) {
                cch = TextCopy(&pwnd->strName, szText, CCHTITLEMAX);
            } else {
                *szText = TEXT('\0');
                cch = 0;
            }

            /*
             *  Draw the text
             */
            CopyRect(&rcRect, &pswInfo->rcTaskName);
            iLeft = rcRect.left;
            FillRect(hdcSwitch, &rcRect, SYSHBR(3DFACE));
            /*
             * If an lpk is installed let it draw the text.
             */
            if (CALL_LPK(PtiCurrentShared())) {
                TL    tlpwnd;
                LPKDRAWSWITCHWND LpkDrawSwitchWnd;

                RtlInitLargeUnicodeString(&LpkDrawSwitchWnd.strName, szText, (UINT)-1);
                LpkDrawSwitchWnd.rcRect = rcRect;

                ThreadLock(pwnd, &tlpwnd);
                xxxSendMessageTimeout(pwnd, WM_LPKDRAWSWITCHWND, (WPARAM)hdcSwitch,
                        (LPARAM)&LpkDrawSwitchWnd, SMTO_ABORTIFHUNG, 100, &dwResult);
                ThreadUnlock(&tlpwnd);
            } else {
                DRAWTEXTPARAMS  dtp;

                dtp.cbSize = sizeof(dtp);
                dtp.iLeftMargin = 0;
                dtp.iRightMargin = 0;
                DrawTextEx(hdcSwitch, szText, cch, &rcRect, DT_NOPREFIX | DT_END_ELLIPSIS | DT_SINGLELINE, &dtp );
            }
        }

        GreSelectFont(hdcSwitch, hOldFont);
        GreSetBkColor(hdcSwitch, clrOldBk);
        GreSetTextColor(hdcSwitch, clrOldText);
    }

    if (fGetAndReleaseIt)
        _ReleaseDC(hdcSwitch);
}

/***************************************************************************\
* DrawIconCallBack
*
* This function is called by a Windows app returning his icon.
*
* History:
* 17-Jun-1993 mikesch       Created.
\***************************************************************************/

VOID CALLBACK DrawIconCallBack(
    HWND    hwnd,
    UINT    uMsg,
    ULONG_PTR dwData,
    LRESULT lResult)
{
    PWND pwndAltTab;

    /*
     *  dwData is the pointer to the switch window handle.
     *  If this Alt+Tab instance is still active, we need to derive this
     *  window's index in the bwl array, otherwise, we are receiving an icon
     *  for an old Alt+Tab window.
     */
    pwndAltTab = RevalidateHwnd((HWND)dwData);
    if (pwndAltTab && TestWF(pwndAltTab, WFVISIBLE)) {

        PSWINFO pswCurrent;
        PICON   pIcon;
        PHWND   phwnd;
        PWND    pwnd;
        PWND    pwndT;
        INT     iStartTaskIndex;
        TL      tlpwndAltTab;

        /*
         *  Derive this window's index in the BWL array
         */
        if ((pwnd = RevalidateHwnd(hwnd)) == NULL)
            return;

        /*
         *  Get the switch window info
         */
        pswCurrent = Getpswi(pwndAltTab);
        if (!pswCurrent)
            return;

        for (iStartTaskIndex = 0, phwnd=&(pswCurrent->pbwl->rghwnd[0]); *phwnd != (HWND)1; phwnd++, iStartTaskIndex++) {
            /*
             *  Because we list the active window in the Switch Window, the
             *  hwnd here might not be the same, so we also need to walk back
             *  to the top-level window to see if this is the right entry
             *  in the list.
             */
            for(pwndT = RevalidateHwnd(*phwnd); pwndT; pwndT = pwndT->spwndOwner) {
                if (pwnd == pwndT)
                    goto DrawIcon;
            }
        }
        return;

        /*
         *  Convert the App's HICON into a PICON, or if the App did not return
         *  an icon, use the Windows default icon.
         */
DrawIcon:
        pIcon = NULL;
        if (lResult)
            pIcon = HMValidateHandleNoRip((HCURSOR)lResult, TYPE_CURSOR);

        if (!pIcon)
            pIcon = SYSICO(WINLOGO);

        /*
         *  Paint this icon in the Alt+Tab window.
         */
        ThreadLockAlways(pwndAltTab, &tlpwndAltTab);
        xxxPaintIconsInSwitchWindow(pwndAltTab,
                                    pswCurrent,
                                    NULL,
                                    iStartTaskIndex,
                                    0,
                                    1,
                                    FALSE,
                                    FALSE,
                                    pIcon);
        ThreadUnlock(&tlpwndAltTab);
    }

    UNREFERENCED_PARAMETER(uMsg);
}

/***************************************************************************\
* TSW_CalcRowAndCol
*
* History:
* 01-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

BOOL TSW_CalcRowAndCol(
    PSWINFO pswInfo,
    INT     iTaskIndex,
    LPINT   lpiRow,
    LPINT   lpiCol)
{
    INT iDiff;
    INT iRow;

    /*
     *  Calculate how far is the given task from the first task shown
     *  on the switch window.
     */
    if ((iDiff = (iTaskIndex - pswInfo->iFirstTaskIndex)) < 0)
        iDiff += pswInfo->iTotalTasks;

    /*
     *  Calculate the Row and if this lies outside the switch window, return FALSE
     */
    if ((iRow = iDiff / pswInfo->iNoOfColumns) >= pswInfo->iNoOfRows)
        return FALSE;

    /*
     *  Return the Row and column where this task lies.
     */
    *lpiRow = iRow;
    *lpiCol = iDiff - (iRow * pswInfo->iNoOfColumns);

    return TRUE;  // This task lies within the switch window.
}

/***************************************************************************\
* xxxPaintIconsInSwitchWindow()
*
* This can simply paint the icons in the switch window or Scroll the
* whole window UP/DOWN and then paint the remaining area;
*   * If fScroll is TRUE, then the second, third and fourth params are ignored.
*   * If hIcon is passed in, then we're being called by DrawIconCallBack and
*       iStartRow parameter is ignored in this case.
*
* History:
* 02-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

VOID xxxPaintIconsInSwitchWindow(
    PWND    pwndAltTab,
    PSWINFO pswInfo,
    HDC     hdc,
    INT     iStartTaskIndex,
    INT     iStartRow,
    INT     iNoOfIcons,
    BOOL    fScroll,
    BOOL    fUp,
    PICON   pIcon)
{
    INT   cx, cy, xStart;
    PHWND phwnd;
    BOOL  fGetAndReleaseIt;
    INT   iColumnIndex = 0;
    RECT  rcScroll;
    PWND  pwnd;
    TL    tlpwnd;
    HICON hIcon;
    RECT  rcIcon;

    CheckLock(pwndAltTab);

    /*
     *  If we were not supplied a DC, get ghwndSwitch's and set a flag
     *  so we remember to release it.
     */
    if (fGetAndReleaseIt = (hdc == NULL))
        hdc = _GetDCEx(pwndAltTab, NULL, DCX_USESTYLE);

    cx = pswInfo->ptFirstRowStart.x;
    cy = pswInfo->ptFirstRowStart.y;

    if (fScroll) {

        rcScroll.left   = cx;
        rcScroll.top    = cy;
        rcScroll.right  = cx + CXICONSLOT * pswInfo->iNoOfColumns;
        rcScroll.bottom = cy + CYICONSLOT * pswInfo->iNoOfRows;

        _ScrollDC(hdc,
                  0,
                  (fUp ? -CYICONSLOT : CYICONSLOT),
                  &rcScroll,
                  &rcScroll,
                  NULL,
                  NULL);

        iStartRow = (fUp ? pswInfo->iNoOfRows - 1 : 0);
        iNoOfIcons = pswInfo->iNoOfColumns;
        iStartTaskIndex = (fUp ? NextPrevTaskIndex(pswInfo, pswInfo->iFirstTaskIndex,
                  (pswInfo->iNoOfRows - 1) * pswInfo->iNoOfColumns, TRUE) :
                   pswInfo->iFirstTaskIndex);
    }

    if (pIcon) {
        /*
         *  If pIcon is given, this is to paint just one icon during callback.
         */
// BradG - Win95 Assert
        UserAssert(iNoOfIcons == 1);

        /*
         *  Due to earlier scrolling, the row number would have changed. So,
         *  recalc the row and column from the iStartTaskIndex given.
         */
        if (!TSW_CalcRowAndCol(pswInfo, iStartTaskIndex, &iStartRow, &iColumnIndex))
            goto Cleanup;
    }

    xStart = cx += (CXICONSLOT - CXICONSIZE) / 2;
    cx += iColumnIndex * CXICONSLOT;
    cy += ((CYICONSLOT - CYICONSIZE) / 2) + iStartRow * CYICONSLOT;
    phwnd = &(pswInfo->pbwl->rghwnd[iStartTaskIndex]);

    /*
     *  Draw all the icons one by one.
     */
    while (iNoOfIcons--) {
        /*
         *  If the Alt+Key is no longer down, abort painting icons.
         */
        if ((pswInfo->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
                (!pswInfo->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0))
            goto Cleanup;

        /*
         *  Check if this window is still alive. (Some task could have
         *  terminated in the background)
         */
        if (pwnd = RevalidateHwnd(*phwnd)) {
            /*
             *  Find the window's top-level owner
             */
            pwnd = DSW_GetTopLevelCreatorWindow(pwnd);

            /*
             *  If we don't have an icon, find one
             */
            if (!pIcon) {
                /*
                 *  Try window icon
                 */
                hIcon = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), PROPF_INTERNAL);
                if (hIcon) {
                    pIcon = (PICON)HMValidateHandleNoRip(hIcon, TYPE_CURSOR);
                }

                /*
                 * If we don't have an icon yet, try the class icon
                 */
                if (!pIcon) {
                    pIcon = pwnd->pcls->spicn;
                }

                /*
                 * If we don't have an icon yet, use WM_QUERYDRAGICON to ask
                 * 3,x apps for their icon.
                 */
                if (!pIcon && !TestWF(pwnd, WFWIN40COMPAT)) {
                    /*
                     *  The callback routine will paint the icon for
                     *  us, so just leave pIcon set to NULL
                     */
                    ThreadLock(pwnd, &tlpwnd);
                    xxxSendMessageCallback(pwnd, WM_QUERYDRAGICON, 0, 0,
                            (SENDASYNCPROC)DrawIconCallBack,
                            HandleToUlong(PtoH(pwndAltTab)), FALSE);
                    ThreadUnlock(&tlpwnd);
                } else {
                    /*
                     *  If we can't find an icon, so use the Windows icon
                     */
                    if (!pIcon) {
                        pIcon = SYSICO(WINLOGO);
                    }
                }
            }
        }

        if (pIcon) {
            _DrawIconEx(hdc, cx, cy, pIcon, SYSMET(CXICON), SYSMET(CYICON),
                0, SYSHBR(3DFACE), DI_NORMAL);
        } else if (fScroll) {
            /*
             *  NOT IN WIN95
             *
             *  No icon was available, do while we are waiting for the
             *  application to paint it's icon, we need to "erase" the
             *  background in case we have scrolled the window.
             */
            rcIcon.left = cx;
            rcIcon.top = cy;
            rcIcon.right = cx + SYSMET(CXICON);
            rcIcon.bottom = cy + SYSMET(CYICON);
            FillRect(hdc, &rcIcon, SYSHBR(3DFACE));
        }

        /*
         *  Check if we are done.
         */
        if (iNoOfIcons <= 0)
            break;

        /*
         *  Reset hIcon for the next run through the loop
         */
        pIcon = NULL;

        /*
         *  Move all pointers to the next task/icon.
         */
        phwnd = NextPrevPhwnd(pswInfo, phwnd, TRUE); // Get next.

        /*
         *  Is it going to be in the same row; then adjust cx and cy.
         */
        if (++iColumnIndex >= pswInfo->iNoOfColumns) {
            iColumnIndex = 0;
            cx = xStart;        // Move to first column
            cy += CYICONSLOT;   // Move to next row.
            iStartRow++;
        } else {
            /*
             *  else, adjust cx;
             */
            cx += CXICONSLOT;
        }

        iStartTaskIndex = NextPrevTaskIndex(pswInfo, iStartTaskIndex, 1, TRUE);
    }

Cleanup:
    if (fGetAndReleaseIt)
        _ReleaseDC(hdc);
}

/***************************************************************************\
* PaintSwitchWindow
*
* History:
* 02-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

VOID xxxPaintSwitchWindow(
    PWND pwndSwitch)
{
    LPRECT  lprcRect;
    RECT    rcRgn;
    HDC     hdcSwitch;
    PSWINFO pswCurrent;
    CheckLock(pwndSwitch);

    /*
     *  If our window isn't visible, return
     */
    if (!TestWF(pwndSwitch, WFVISIBLE))
        return;

    /*
     *  Get the switch window information
     */
    pswCurrent = Getpswi(pwndSwitch);
    if (!pswCurrent)
        return;

    /*
     * Get the Switch windows DC so we can paint with it
     */
    hdcSwitch = _GetDCEx(pwndSwitch, NULL, DCX_USESTYLE );

    /*
     *  Paint the background of the Switch Screen.
     */
    if ((pswCurrent->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
            (!pswCurrent->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0))
        goto PSWExit;

    lprcRect = &(pswCurrent->rcTaskName);
    _GetClientRect(pwndSwitch, lprcRect);
    FillRect(hdcSwitch, lprcRect, SYSHBR(3DFACE));

    /*
     * Store this "caption" area back into the current switch
     * window data structure.
     */
    InflateRect(lprcRect, -(gcxCaptionFontChar << 1), -(gcyCaptionFontChar));
    lprcRect->top = lprcRect->bottom - gcyCaptionFontChar;

    /*
     *  Draw the sunken edge for showing the task names.
     */
    if ((pswCurrent->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
            (!pswCurrent->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0))
        goto PSWExit;
    CopyInflateRect(&rcRgn, lprcRect, gcxCaptionFontChar >> 1, gcyCaptionFontChar >> 1);
    DrawEdge(hdcSwitch, &rcRgn, EDGE_SUNKEN, BF_RECT);

    /*
     *  Paint the icons
     */
    if ((pswCurrent->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
            (!pswCurrent->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0))
        goto PSWExit;

    xxxPaintIconsInSwitchWindow(pwndSwitch,
                                pswCurrent,
                                hdcSwitch,
                                pswCurrent->iFirstTaskIndex,
                                0,
                                pswCurrent->iTasksShown,
                                FALSE,
                                FALSE,
                                NULL);

    /*
     *  So, just draw the hilite.
     */
    if ((pswCurrent->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
            (!pswCurrent->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0))
        goto PSWExit;

    DrawSwitchWndHilite(pswCurrent,
                        hdcSwitch,
                        pswCurrent->iCurCol,
                        pswCurrent->iCurRow,
                        TRUE);

    /*
     *  Release the switch windows DC
     */
PSWExit:
    _ReleaseDC(hdcSwitch);
}

/***************************************************************************\
* SwitchWndCleanup()
*
* Clean up all the mem allocated etc.,
*
* History:
* 07-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

VOID SwitchWndCleanup(
    PSWINFO *ppswInfo)
{
    UserAssert(ppswInfo != NULL);
    UserAssert(*ppswInfo != NULL);

    /*
     *  First of all free the Window list.
     */
    if ((*ppswInfo)->pbwl)
        FreeHwndList((*ppswInfo)->pbwl);
    UserFreePool(*ppswInfo);
    *ppswInfo = NULL;
}

/***************************************************************************\
* AddSwitchWindowInfo
*
* 09-12-01 MSadek  Created
\***************************************************************************/
VOID AddSwitchWindowInfo(
    PSWINFO pswInfo)
{
    CheckCritIn();
    pswInfo->pswiNext = gpswiFirst;
    gpswiFirst = pswInfo;
}

/***************************************************************************\
* RemoveSwitchWindowInfo
*
* 09-12-01 MSadek  Created
\***************************************************************************/
VOID RemoveSwitchWindowInfo(
    PSWINFO *ppswInfo)
{
    PSWINFO* ppswi;
    PSWINFO pswiT;

    CheckCritIn();

    for (ppswi = &gpswiFirst; *ppswi != NULL; ppswi = &(*ppswi)->pswiNext) {
        pswiT = *ppswi;
        if (pswiT == *ppswInfo) {
            *ppswi = pswiT->pswiNext;
            SwitchWndCleanup(ppswInfo);
        }

        if (*ppswi == NULL) {
            break;
        }
    }
}

/***************************************************************************\
* RemoveThreadSwitchWindowInfo
*
* 09-12-01 MSadek  Created
\***************************************************************************/
VOID RemoveThreadSwitchWindowInfo(
    PTHREADINFO pti)
{
    PSWINFO* ppswi;
    PSWINFO pswiT;

    CheckCritIn();

    for (ppswi = &gpswiFirst; *ppswi != NULL; ppswi = &(*ppswi)->pswiNext) {
        pswiT = *ppswi;
        if (pswiT->pti == pti) {
            *ppswi = pswiT->pswiNext;
            SwitchWndCleanup(&pswiT);
        }

        if (*ppswi == NULL) {
            break;
        }
    }
}

/***************************************************************************\
* InitSwitchWndInfo
*
* This function allocs and Initializes all the data structures
* required the build and show the tasks in the system.
* If there is insufficient mem, then this find the next window to switch
* to and returns it. In this case, we will behave as if the end user hit
* ALT+ESC. The SWitchScreen will not comeup in this case.
* If there is only one task in the whole system, then this function
* fails and returns a NULL. (No ALT+TAB processing is required).
* Otherwise, it allocs one SwitchWndInfo struc, fills it up and returns
* the window we gonna switch to.
*
* History:
* 02-Jun-95 BradG       Ported from Win95
\***************************************************************************/
PWND InitSwitchWndInfo(
    PSWINFO *   lppswInfo,
    PWND        pwndCurActive,
    BOOL        fPrev)
{
    PBWL            pbwl;
    INT             iTotalTasks;
    INT             iCols, iRows, iIconsInLastRow;
    INT             iDiff;
    PHWND           phwndLast;
    PSWINFO         pswInfo;
    INT             iIconIndex;
    INT             iCurRow, iCurCol;
    INT             cxSwitch, cySwitch;
    INT             iFirstRowIcons;
    INT             iActiveTask;
    PWND            pwnd = NULL;
    PTHREADINFO     ptiCurrent = PtiCurrent();
    PDESKTOPINFO    pdeskinfo = GETDESKINFO(ptiCurrent);
    PMONITOR        pMonitor = GetPrimaryMonitor();

    /*
     *  Initialize the list
     */
    *lppswInfo = (PSWINFO)NULL;

    /*
     *  Build the Window list of all the top level windows.
     */
#if 0
    if (!(pbwl = BuildHwndList(NULL, BWL_ENUMLIST | BWL_ALLDESKTOPS, NULL)))
        goto ReturnNextWnd;
#else
// BradG - HACK, enumerate on current desktop!
//   For the long run, we will need to enumerate all desktops
//   This will be tricky because we need to check the security of
//   each desktop, thus needing the user's security "token".
    if (!(pbwl = BuildHwndList(pdeskinfo->spwnd->spwndChild, BWL_ENUMLIST, NULL))) {
#ifdef COOLSWITCHTRACE
        DbgPrint("CoolSwitch: BuildHwndList failed (contact bradg).\n");
        UserAssert(pbwl != NULL);
#endif
        goto ReturnNextWnd;
    }
#endif

    /*
     *  Walk down the list and remove all non-task windows from the list.
     *  Replace those hwnds with 0.
     */
    if ((iTotalTasks = _RemoveNonTaskWindows(pbwl, pwndCurActive, &iActiveTask, &phwndLast)) < 2) {
        if (iTotalTasks == 1) {
            /*
             *  If we have only one window and it's in full screen mode, we will
             *  return the shell window so the can switch back to GDI mode.
             */
            pwnd = RevalidateHwnd(pbwl->rghwnd[0]);
            if (pwnd && GetFullScreen(pwnd) == FULLSCREEN && pwndCurActive == pwnd)
                pwnd = pdeskinfo->spwndShell;

        } else {
            pwnd = pdeskinfo->spwndShell;
        }
#ifdef COOLSWITCHTRACE
        DbgPrint("CoolSwitch: Not enough windows to switch.\n");
#endif
        goto FreeAndReturnNextWnd;  // If there isn't even two tasks, no switch wnd processing.
    }

    /*
     *  Allocate the Switch Info structure.  If we don't have enough
     *  memory, act as if we are doing Alt+Esc.
     */
    if (!(pswInfo = (PSWINFO)UserAllocPoolWithQuota(sizeof(SWITCHWNDINFO), TAG_ALTTAB))) {
#ifdef COOLSWITCHTRACE
        DbgPrint("CoolSwitch: UserAllocPool failed on 0x%X bytes (contact bradg).\n", sizeof(SWITCHWNDINFO));
        UserAssert(pswInfo != NULL);
#endif
        goto FreeAndReturnNextWnd;  // Unable to alloc SwitchWndInfo struct.
    }

    pswInfo->pti         = ptiCurrent;
    pswInfo->pbwl        = pbwl;
    pswInfo->phwndLast   = phwndLast;
    pswInfo->iTasksShown = pswInfo->iTotalTasks = iTotalTasks;

    /*
     *  Get the next/prev window that must become active.
     */
    iIconIndex = NextPrevTaskIndex(pswInfo, iActiveTask, 1, !fPrev);
    pswInfo->phwndCurrent = &(pbwl->rghwnd[iIconIndex]);

    iCols = min(gnFastAltTabColumns, iTotalTasks);
    iRows = iTotalTasks / iCols;  // Truncation might occur.

    iIconsInLastRow = iTotalTasks - iRows * iCols;
    iRows += (iIconsInLastRow ? 1 : 0);  // Take care of earlier truncation.

    /*
     *  Restrict the number of rows to just MAXROWSALLOWED (3)
     */
    if (iRows > gnFastAltTabRows) {
        iRows = gnFastAltTabRows;
        pswInfo->fScroll = TRUE;    // We need to scroll.
        iIconsInLastRow = iCols;
        pswInfo->iTasksShown = iCols * iRows;
    } else {
        pswInfo->fScroll = FALSE;
    }

    pswInfo->iNoOfColumns = iCols;
    pswInfo->iNoOfRows    = iRows;

    if (iIconsInLastRow == 0)
       iIconsInLastRow = pswInfo->iNoOfColumns; // Last Row is full.
    pswInfo->iIconsInLastRow = iIconsInLastRow;

    /*
     *  Find out Row and Col where the next/prev icon will lie.
     */
    if (iIconIndex >= (iRows * iCols)) {
        /*
         *  Next Icon lies outside. Bring it to the center.
         */
        iCurRow = (iRows >> 2) + 1;
        iCurCol = (iCols >> 2) + 1;
        iDiff = (iIconIndex - ((iCurRow * iCols) + iCurCol));
    } else {
        iDiff = 0;
        iCurRow = iIconIndex / iCols;
        iCurCol = iIconIndex - (iCurRow * iCols);
    }

    pswInfo->iFirstTaskIndex = iDiff;
    pswInfo->iCurRow         = iCurRow;
    pswInfo->iCurCol         = iCurCol;

    /*
     *  Calculate the Switch Window Dimensions.
     */
    cxSwitch = min(
            pMonitor->rcMonitor.right - pMonitor->rcMonitor.left,
            gnFastAltTabColumns * CXICONSLOT +
                CXICONSIZE / 2 +
                6 * gpsi->gclBorder * SYSMET(CXBORDER) +
                gcxCaptionFontChar);

    cySwitch = min(
            pMonitor->rcMonitor.bottom - pMonitor->rcMonitor.top,
            iRows * CYICONSLOT +
                CYICONSIZE +
                gcyCaptionFontChar * 2 +
                gcyCaptionFontChar / 2);

    /*
     *  Find the number of icons in first row
     */
    if (iRows == 1) {
        iFirstRowIcons = iIconsInLastRow;
    } else {
        iFirstRowIcons = iCols;
    }

    /*
     *  Center the icons based on the number of icons in first row.
     */
    pswInfo->ptFirstRowStart.x = (cxSwitch - 4*gpsi->gclBorder*SYSMET(CXBORDER) - iFirstRowIcons * CXICONSLOT) >> 1;
    pswInfo->ptFirstRowStart.y = (CYICONSIZE >> 1);

    pswInfo->cxSwitch = cxSwitch;
    pswInfo->cySwitch = cySwitch;

    AddSwitchWindowInfo(pswInfo);
    *lppswInfo = pswInfo;

    return RevalidateHwnd(*(pswInfo->phwndCurrent));  // Success!


    /*
     *  When there is insufficient mem to create the reqd structures, we simply
     *  return the next window. We make the phwndInfo as NULL. So, we won't
     *  attempt to draw the switch window.
     */

FreeAndReturnNextWnd:
    FreeHwndList(pbwl);
ReturnNextWnd:
    if (pwnd)
        return(pwnd);

    return(_GetNextQueueWindow(pwndCurActive, _GetKeyState(VK_SHIFT) < 0, FALSE));
}

/***************************************************************************\
* xxxMoveSwitchWndHilite()
*
* This moves the Hilite to the next/prev icon.
* Checks if this move results in a scrolling. If it does, then
* make sure scroll occurs.
* Else, erase hilite from the current icon;
* Then draw hilite on the new Icon.
* fPrev indicates whether you want the prev task or next.
*
* History:
* 02-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

HWND xxxMoveSwitchWndHilite(
    PWND    pwndSwitch,
    PSWINFO pswInfo,
    BOOL    fPrev)
{
    INT  iCurCol, iCurRow;
    INT  iMaxColumns;
    BOOL fLastRow;
    BOOL fNeedToScroll = FALSE;
    HDC  hdc;
    HWND hwnd;

    CheckLock(pwndSwitch);
    UserAssert(IsWinEventNotifyDeferredOK());

    iCurCol = pswInfo->iCurCol;
    iCurRow = pswInfo->iCurRow;

    /*
     *  Find out the new postion (row and column) of hilite.
     */
    if (fPrev) {
        if (iCurCol > 0) {
            /*
             *  Move cursor to prev column on the same row.
             */
            iCurCol--;
        } else {
            /*
             *  Try to move to the previous row.
             */
            if (iCurRow > 0) {
                /*
                 *  Move to the last column on the previous row.
                 */
                iCurRow--;
                iCurCol = pswInfo->iNoOfColumns - 1;
            } else {
                /*
                 *  We are already at (0,0); See if we need to scroll.
                 */
                if (pswInfo->fScroll) {
                    /*
                     * Time to scroll; Scroll by one Row;
                     * Repaint the whole window.
                     */
                    fNeedToScroll = TRUE;
                    pswInfo->iFirstTaskIndex = NextPrevTaskIndex(pswInfo, pswInfo->iFirstTaskIndex,
                      pswInfo->iNoOfColumns, FALSE);
                    iCurCol = pswInfo->iNoOfColumns - 1;
                } else {
                    /*
                     *  Move the hilite to the last icon shown.
                     */
                    iCurRow = pswInfo->iNoOfRows - 1;
                    iCurCol = pswInfo->iIconsInLastRow - 1;
                }
            }
        }

    } else {
        /*
         *  !fPrev
         *  Get the number of columns in the current row.
         */
        if (fLastRow = (iCurRow == (pswInfo->iNoOfRows - 1))) // Are we at the last row?
            iMaxColumns = pswInfo->iIconsInLastRow;
        else
            iMaxColumns = pswInfo->iNoOfColumns;

        /*
         *  Are we at the last column yet?
         */
        if (iCurCol < (iMaxColumns - 1)) {
            /*
             *  No! Move to the right.
             */
            iCurCol++;
        } else {
            /*
             *  We are at the last column.
             *  If we are not at last row, then move to next row.
             */
            if (!fLastRow) {
                iCurCol = 0;
                iCurRow++;
            } else {
                /*
                 *  We are at the last row, last col;
                 *  See if we need to scroll.
                 */
                if (pswInfo->fScroll) {
                    fNeedToScroll = TRUE;
                    pswInfo->iFirstTaskIndex = NextPrevTaskIndex(pswInfo, pswInfo->iFirstTaskIndex,
                          pswInfo->iNoOfColumns, TRUE);
                    iCurCol = 0;
                } else {
                    /*
                     *  Move to the top left corner (0, 0).
                     */
                    iCurRow = iCurCol = 0;
                }
            }
        }
    }

    /*
     *  Move the phwnd to the next/prev
     */
    pswInfo->phwndCurrent = NextPrevPhwnd(pswInfo, pswInfo->phwndCurrent, !fPrev);

    /*
     *  Remove Hilite from the current location.
     */
    hdc = _GetDCEx(pwndSwitch, NULL, DCX_USESTYLE);
    DrawSwitchWndHilite(pswInfo, hdc, pswInfo->iCurCol, pswInfo->iCurRow, FALSE);

    pswInfo->iCurRow = iCurRow;
    pswInfo->iCurCol = iCurCol;
    hwnd = (*(pswInfo->phwndCurrent));

    /*
     *  Repaint if needed.
     */
    if (fNeedToScroll)
        xxxPaintIconsInSwitchWindow(pwndSwitch, pswInfo, hdc, pswInfo->iFirstTaskIndex, 0, 0, TRUE, !fPrev, NULL);

    /*
     *  Draw Hilite at the new location.
     */
    DrawSwitchWndHilite(pswInfo, hdc, iCurCol, iCurRow, TRUE);

    _ReleaseDC(hdc);


    xxxWindowEvent(EVENT_OBJECT_FOCUS, pwndSwitch, OBJID_CLIENT,
        iCurRow * pswInfo->iNoOfColumns + iCurCol + 1, WEF_USEPWNDTHREAD);

    return hwnd;
}

/***************************************************************************\
* xxxShowSwitchWindow()
*
* Show the switch Window.
* Returns: TRUE if succeeded.   FALSE, if the window was not shown because
* of the pre-mature release of ALT key. The selection has been made already.
*
* History:
* 07-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

BOOL xxxShowSwitchWindow(
        PWND        pwndAltTab)
{
    PSWINFO pswInfo;
    PMONITOR pMonitorSwitch = GetPrimaryMonitor();
    CheckLock(pwndAltTab);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     *  Get the switch window information
     */
    pswInfo = Getpswi(pwndAltTab);
    if (pswInfo == NULL) {
        return FALSE;
    }

    /*
     *  If the key is not down, don't bother to display Switch Window.
     */
    if ((pswInfo->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
            (!pswInfo->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0)) {
#ifdef COOLSWITCHTRACE
        DbgPrint("CoolSwitch: Not displaying window because VM_MENU is up (contact bradg).\n");
#endif
        return FALSE;
    }

    /*
     *  Bring and position the window on top.
     */
    xxxSetWindowPos(pwndAltTab, PWND_TOPMOST, 0,0,0,0,
        SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE | SWP_NOREDRAW );

    if (!TestWF(pwndAltTab, WFVISIBLE)) {
        xxxSetWindowPos(
            pwndAltTab,
            PWND_TOPMOST,
            (pMonitorSwitch->rcWork.left + pMonitorSwitch->rcWork.right - pswInfo->cxSwitch) / 2,
            (pMonitorSwitch->rcWork.top + pMonitorSwitch->rcWork.bottom - pswInfo->cySwitch) / 2,
            pswInfo->cxSwitch,
            pswInfo->cySwitch,
            SWP_SHOWWINDOW | SWP_NOACTIVATE);
    }

#ifdef COOLSWITCHTRACE
    UserAssert(TestWF(pwndAltTab, WFVISIBLE));
#endif
    xxxUpdateWindow(pwndAltTab);

    xxxWindowEvent(EVENT_SYSTEM_SWITCHSTART, pwndAltTab, OBJID_CLIENT,
            0, WEF_USEPWNDTHREAD);

    xxxWindowEvent(EVENT_OBJECT_FOCUS, pwndAltTab, OBJID_CLIENT,
            pswInfo->iCurRow * pswInfo->iNoOfColumns + pswInfo->iCurCol + 1,
            WEF_USEPWNDTHREAD);

    return TRUE;
}

/***************************************************************************\
*
*  xxxSwitchWndProc()
*
\***************************************************************************/

LRESULT xxxSwitchWndProc(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam)
{
    TL          tlpwndActivate;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    VALIDATECLASSANDSIZE(pwnd, message, wParam, lParam, FNID_SWITCH, WM_CREATE);

    switch (message) {
    case WM_CREATE:
        /*
         * When the queue was created, the cursor was set to the wait cursor.
         * We want to use the normal one.
         */
        zzzSetCursor(pwnd->pcls->spcur);
        break;

    case WM_CLOSE:
        /*
         *  Hide this window without activating anyone else.
         */
        xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0, SWP_HIDEWINDOW |
                SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);

        /*
         * Get us out of Alt+Tab mode.  Since the alttab information
         * is stored in the gptiRit->pq, we will reference that insteatd
         * of the current-thread.
         */
        xxxCancelCoolSwitch();
        break;

    case WM_ERASEBKGND:
    case WM_FULLSCREEN:
        ThreadLockWithPti(ptiCurrent, pwnd, &tlpwndActivate);
        xxxPaintSwitchWindow(pwnd);
        ThreadUnlock(&tlpwndActivate);
        return 0;

    case WM_DESTROY:
        {
            /*
             *  Get the switch window info for this window
             */
            PSWINFO pswCurrent = Getpswi(pwnd);


            if (pswCurrent) {
                RemoveSwitchWindowInfo(&pswCurrent);
                Setpswi(pwnd, NULL);
            }
        }
        break;
    }

    return xxxDefWindowProc(pwnd, message, wParam, lParam);
}

/***************************************************************************\
* xxxCancelCoolSwitch
*
* This functions destroys the cool switch window and removed the INALTTAB
* mode flag from the specified queue.
*
* History:
* 18-Sep-1995 BradG     Created
\***************************************************************************/
VOID xxxCancelCoolSwitch(
    void)
{
    CheckCritIn();
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     *  Destroy the Cool Switch window
     */
    if (gspwndAltTab != NULL) {
        PWND pwnd = gspwndAltTab;
        /*
         * Make sure that the thread calling this is the same thread which
         * created the alttab window. Otherwise, we could end up with this
         * window floating around until the calling process dies. Remember,
         * we can't destroy windows across different threads.
         */
        if (gspwndAltTab->head.pti != PtiCurrent()) {
            return;
        }

        xxxWindowEvent(EVENT_SYSTEM_SWITCHEND, gspwndAltTab, OBJID_CLIENT,
            0, WEF_USEPWNDTHREAD);
        if (Unlock(&gspwndAltTab)) {
            xxxDestroyWindow(pwnd);
        }
    }
}

/***************************************************************************\
* xxxNextWindow
*
* This function does the processing for the alt-tab/esc/F6 UI.
*
* History:
* 30-May-1991 DavidPe       Created.
\***************************************************************************/

VOID xxxNextWindow(
    PQ    pq,
    DWORD wParam)
{
    PWND        pwndActivateNext;
    PWND        pwndCurrentActivate, pwndCurrentTopFocus;
    int         fDir;
    TL          tlpwndCurrentTopFocus;
    TL          tlpwndActivateNext;
    TL          tlpwndCurrentActivate;
    TL          tlpwndT;
    PSWINFO     pswCurrent;
    ULONG_PTR    dwResult;
    BOOL        fNonRit = FALSE;
    PTHREADINFO ptiCurrent = PtiCurrent();

    UserAssert(!IsWinEventNotifyDeferred());

    if (pq == NULL)
        return;

    fDir = (_GetAsyncKeyState(VK_SHIFT) < 0) ? FDIR_BACKWARD : FDIR_FORWARD;

    pwndCurrentTopFocus = GetTopLevelWindow(pq->spwndFocus);
    /*
     *  NOTE: As of NT 4.0 the slow Alt+Tab functionality now officially acts
     *  like Alt+Esc with the exception that Alt+Tab will activate the window
     *  where Alt+Esc will not.
     */
    switch (wParam) {

    case VK_TAB:

        if (gspwndAltTab == NULL) {

            PWND pwndSwitch;
            TL   tlpSwitchInfo;

            /*
             *  We are entering Alt+Tab for the first time, we need to
             *  initialize the Switch Window structure and if needed
             *  create and display the Alt+Tab window.  We have two special
             *  cases: (1) The user does not want to use the Switch window,
             *  (2) The initialize switch window fails thus we will act
             *  just like slow Alt+Tab
             */

            /*
             * Since Alt+Shift is the default hotkey for keyboard layout switching,
             * Alt+Shift+Tab may cause a KL switching while AltTab window is up.
             * To prevent it, we'd better reset the global toggle key state here,
             * so that xxxScanSysQueue will not confuse when it handles keyup messages.
             */
            gLangToggleKeyState = KLT_NONE;

            /*
             * Mouse buttons sometimes get stuck down due to hardware glitches,
             * usually due to input concentrator switchboxes or faulty serial
             * mouse COM ports, so clear the global button state here just in case,
             * otherwise we may not be able to change focus with the mouse.
             * Also do this in zzzCancelJournalling (Ctr-Esc, Ctrl-Alt-Del, etc.)
             */
#if DBG
            if (gwMouseOwnerButton)
                RIPMSG1(RIP_WARNING,
                        "gwMouseOwnerButton=%x, being forcibly cleared\n",
                        gwMouseOwnerButton);
#endif
            gwMouseOwnerButton = 0;

            /*
             *  Determine the current active window.
             */
            Lock(&gspwndActivate, pq->spwndActive);
            if (gspwndActivate == NULL) {
                Lock(&gspwndActivate, grpdeskRitInput->pDeskInfo->spwnd->spwndChild);
            }

            if (!gspwndActivate) {
                return;
            }

            ThreadLockWithPti(ptiCurrent, pwndCurrentTopFocus, &tlpwndCurrentTopFocus);

            /*
             *  Make a local copy of gspwndActivate and lock it because xxxFreeWindow will
             *  unlock if it is the window being freed.
             */
            pwndCurrentActivate = gspwndActivate;
            ThreadLockAlwaysWithPti(ptiCurrent, pwndCurrentActivate, &tlpwndCurrentActivate);

            /*
             *   Cancel the active window's mode
             */
            xxxSendMessageTimeout(pwndCurrentActivate, WM_CANCELMODE, 0, 0, SMTO_ABORTIFHUNG, 100, &dwResult);

            /*
             *  Initialize the Switch Window data structure, if we
             *  succeed create and display the window, otherwise act
             *  like slow Alt+Tab.
             */
            pwndActivateNext = InitSwitchWndInfo(&pswCurrent, pwndCurrentActivate, fDir);

            ThreadLockWithPti(ptiCurrent, pwndActivateNext, &tlpwndActivateNext);

            if (pswCurrent == NULL) {
                /*
                 *  Couldn't initialize our switch window data structure, so we
                 *  will act like Alt+Esc.
                 */
                goto DoSlowAltTab;
            }

            if (pwndActivateNext == NULL) {
                RemoveSwitchWindowInfo(&pswCurrent);
                ThreadUnlock(&tlpwndActivateNext);
                ThreadUnlock(&tlpwndCurrentActivate);
                ThreadUnlock(&tlpwndCurrentTopFocus);
                Unlock(&gspwndActivate);
                return;
            }

            ThreadLockPoolCleanup(ptiCurrent, &pswCurrent, &tlpSwitchInfo, RemoveSwitchWindowInfo);

            /*
             * Since we are in the RIT, test the physical state of the keyboard
             */
            pswCurrent->fJournaling = FALSE;

            /*
             *  Create the Alt+Tab window
             */
            pwndSwitch =
                  xxxNVCreateWindowEx( WS_EX_TOOLWINDOW | WS_EX_WINDOWEDGE | WS_EX_DLGMODALFRAME,
                      (PLARGE_STRING)SWITCHWNDCLASS, NULL,
                      WS_POPUP | WS_BORDER | WS_DISABLED,
                      0, 0, 10, 10, NULL, NULL, NULL, NULL, VER40);

            if (gspwndAltTab != NULL) {
                RIPMSG0(RIP_WARNING, "xxxNextWindow: Creating a new switch window while one already exists.");

                _PostMessage(gspwndAltTab, WM_CLOSE, 0, 0);
            }

            Lock(&gspwndAltTab, pwndSwitch);

            ThreadUnlockPool(ptiCurrent, &tlpSwitchInfo);

            if (gspwndAltTab == NULL) {
                /*
                 *  Could not create the cool switch window, do the Alt+Esc thing
                 */
#ifdef COOLSWITCHTRACE
                DbgPrint("CoolSwitch: Could not create window (contact bradg).\n");
                UserAssert(gspwndAltTab != NULL);
#endif
                RemoveSwitchWindowInfo(&pswCurrent);
                goto DoSlowAltTab;
            }

            /*
             *  Save the pointer to the switch window info structure
             */
            Setpswi(gspwndAltTab, pswCurrent);
            /*
             *  Set gspwndActivate so the RIT knows what window we would like
             *  it to activate.
             */
            Lock(&gspwndActivate, pwndActivateNext);

            /*
             * Make sure that our rit queue has the correct pdesk
             */
            if (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD) {
                xxxSetThreadDesktop(NULL, grpdeskRitInput); // DeferWinEventNotify() ?? IANJA ??
            }

            /*
             * If we're currently full screen tell console to switch to
             * the desktop to GDI mode; we can't do this on the RIT because
             * it can be slow.
             */
            if (gspwndFullScreen != grpdeskRitInput->pDeskInfo->spwnd) {
                ThreadLockWithPti(ptiCurrent, grpdeskRitInput->pDeskInfo->spwnd, &tlpwndT);
                xxxSendNotifyMessage(grpdeskRitInput->pDeskInfo->spwnd, WM_FULLSCREEN, GDIFULLSCREEN, (LPARAM)HW(grpdeskRitInput->pDeskInfo->spwnd));
                ThreadUnlock(&tlpwndT);
            }

            /*
             *  Show the Alt+Tab window.  If it returns FALSE this means
             *  the ALT key has been released, so there is no need to
             *  paint the icons.
             */
            ThreadLockAlwaysWithPti(ptiCurrent, gspwndAltTab, &tlpwndT);
            xxxShowSwitchWindow(gspwndAltTab);
            ThreadUnlock(&tlpwndT);

            /*
             *  Exit now because the Switch window will have been
             *  already updated.
             */
            ThreadUnlock(&tlpwndActivateNext);
            ThreadUnlock(&tlpwndCurrentActivate);
            ThreadUnlock(&tlpwndCurrentTopFocus);

        } else {
            /*
             * We come here to do the actual switching and/or updating of
             * the switch window when in Alt+Tab mode.
             */
            PWND    pwndSwitch;
            TL      tlpwndSwitch;
            HWND    hwndActivateNext;
            HWND    hwndStop;

            if (!(pwndSwitch = gspwndAltTab)) {

                goto DoAltEsc;

            } else {
                /*
                 *  Move the hilight rect to the next/prev task.  It is possible
                 *  that some tasks were destoryed, so we need to skip those.
                 */
                ThreadLockAlwaysWithPti(ptiCurrent, pwndSwitch, &tlpwndSwitch);
                hwndStop = NULL;
                do {
                    pswCurrent = Getpswi(pwndSwitch);
                    if (pswCurrent == NULL) {
                        ThreadUnlock(&tlpwndSwitch);
                        goto DoAltEsc;
                    }
                    hwndActivateNext = xxxMoveSwitchWndHilite(pwndSwitch, pswCurrent, fDir);
                    if (!hwndStop) {
                        hwndStop = hwndActivateNext;
                    } else {
                        if (hwndStop == hwndActivateNext) {
                            pwndActivateNext = NULL;
                            break;
                        }
                    }
                    pwndActivateNext = RevalidateHwnd(hwndActivateNext);
                } while (!pwndActivateNext);
                ThreadUnlock(&tlpwndSwitch);
                Lock(&gspwndActivate, pwndActivateNext);
                if (!gspwndActivate) {
                    /*
                     *  No Window to activate, bail out of Alt+Tab mode
                     */
                    xxxCancelCoolSwitch();
                }
            }
        }
        break;

DoAltEsc:
    case VK_ESCAPE:
        /*
         *  NOTE: The RIT doesn't use gspwndActivate to activate the window when
         *        processing Alt+Esc, we just use it here as a convenient
         *        variable.  The actual activation takes place below.
         */
        pwndCurrentActivate = pq->spwndActive;
        if (pwndCurrentActivate == NULL) {
            pwndCurrentActivate = pq->ptiKeyboard->rpdesk->pDeskInfo->spwnd->spwndChild;
            if (pwndCurrentActivate == NULL) {
                return;
            }
        }

        ThreadLockWithPti(ptiCurrent, pwndCurrentTopFocus, &tlpwndCurrentTopFocus);

        ThreadLockAlwaysWithPti(ptiCurrent, pwndCurrentActivate, &tlpwndCurrentActivate);

        /*
         *   Cancel the active window's mode
         */
        xxxSendMessageTimeout(pwndCurrentActivate, WM_CANCELMODE, 0, 0, SMTO_ABORTIFHUNG, 100, &dwResult);

        /*
         * Determine the next window to activate
         */
        pwndActivateNext = _GetNextQueueWindow(pwndCurrentActivate, fDir, TRUE);
        ThreadLockWithPti(ptiCurrent, pwndActivateNext, &tlpwndActivateNext);

        /*
         * If we're going forward through the windows, move the currently
         * active window to the bottom so we'll do the right thing when
         * we go backwards.
         */
        if (pwndActivateNext != pwndCurrentActivate) {
DoSlowAltTab:
            if (pwndActivateNext) {

                /*
                 * We're about to activate another window while the ALT key is down,
                 *  so let the current focus window know that it doesn't need the
                 *  menu underlines anymore
                 */
                if ((pwndCurrentTopFocus != NULL) && (pwndCurrentTopFocus->spmenu != NULL)) {
                    ClearMF(pwndCurrentTopFocus->spmenu, MFUNDERLINE);
                }

                if (fDir == FDIR_FORWARD) {
                    /*
                     * For Alt+ESC only move the window to the bottom if it's
                     * not a top most window
                     */
                    if (!TestWF(pwndCurrentActivate, WEFTOPMOST)) {
                        xxxSetWindowPos(pwndCurrentActivate, PWND_BOTTOM, 0, 0, 0, 0,
                                SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE |
                                SWP_DEFERDRAWING | SWP_NOSENDCHANGING |
                                SWP_ASYNCWINDOWPOS);
                    }
                }

                /*
                 * The ALT key is down, so this window needs menu underlines
                 */
                if (pwndActivateNext->spmenu != NULL) {
                    SetMF(pwndActivateNext->spmenu, MFUNDERLINE);
                }


                /*
                 * This little ugly hack will cause xxxSetForegroundWindow2()
                 * to send out an activation messages to a queue that is
                 * already the active queue allowing us to change the active
                 * window on that queue.
                 */
                if (gpqForeground == GETPTI(pwndActivateNext)->pq)
                    gpqForeground = NULL;

                /*
                 * Make the selected window thread the owner of the last input;
                 *  since he's next, he owns the ALT-ESC.
                 */
                glinp.ptiLastWoken = GETPTI(pwndActivateNext);

                xxxSetForegroundWindow2(pwndActivateNext, NULL,
                        (wParam == VK_TAB) ? SFW_SWITCH | SFW_ACTIVATERESTORE : SFW_SWITCH);

                /*
                 * Win3.1 calls SetWindowPos() with activate, which z-orders
                 * first regardless, then activates. Our code relies on
                 * xxxActivateThisWindow() to z-order, and it'll only do
                 * it if the window does not have the child bit set (regardless
                 * that the window is a child of the desktop).
                 *
                 * To be compatible, we'll just force z-order here if the
                 * window has the child bit set. This z-order is asynchronous,
                 * so this'll z-order after the activate event is processed.
                 * That'll allow it to come on top because it'll be foreground
                 * then. (Grammatik has a top level window with the child
                 * bit set that wants to be come the active window).
                 */
                if (wParam == VK_TAB && TestWF(pwndActivateNext, WFCHILD)) {
                    xxxSetWindowPos(pwndActivateNext, (PWND)HWND_TOP, 0, 0, 0, 0,
                            SWP_NOSIZE | SWP_NOMOVE | SWP_ASYNCWINDOWPOS);
                }
            }
        }
        ThreadUnlock(&tlpwndActivateNext);
        ThreadUnlock(&tlpwndCurrentActivate);
        ThreadUnlock(&tlpwndCurrentTopFocus);
        break;

    case VK_F6:
        if ((pwndCurrentActivate = pq->spwndActive) == NULL)
            pwndCurrentActivate = pq->ptiKeyboard->rpdesk->pDeskInfo->spwnd->spwndChild;

        pwndActivateNext = pwndCurrentActivate;

        /*
         * HACK! console sessions are all one thread but we want them
         * to act like different threads so if its a console thread (csrss.exe)
         * then ALT-F6 does nothing just like in Win 3.1
         * Note: we never get called with wParam == VK_F6 anyway. Win NT 3.51
         * doesn't seem to either, but Windows '95 does.  BUG?? (IanJa)
         */
        if (!(GETPTI(pwndActivateNext)->TIF_flags & TIF_CSRSSTHREAD)) {
            /*
             * on a alt-f6, we want to keep the switch within the thread.
             * We may want to rethink this because this will look strange
             * when you alt-f6 on a multi-threaded app we will not rotate
             * through the windows on the different threads.  This works
             * fine on Win 3.x because it is single threaded.
             */
            do {
                pwndActivateNext = NextTopWindow(pq->ptiKeyboard, pwndActivateNext, NULL,
                        fDir ? NTW_PREVIOUS : 0);
            } while( (pwndActivateNext != NULL) &&
                    (GETPTI(pwndActivateNext) != pq->ptiKeyboard));

            if (pwndActivateNext != NULL) {

                if (pwndActivateNext != pwndCurrentActivate) {
                    /*
                     * We're about to activate another window while the ALT key is down,
                     *  so let the current focus window know that it doesn't need the
                     *  menu underlines anymore
                     */
                    pwndCurrentTopFocus = GetTopLevelWindow(pq->spwndFocus);
                    if ((pwndCurrentTopFocus != NULL) && (pwndCurrentTopFocus->spmenu != NULL)) {
                        ClearMF(pwndCurrentTopFocus->spmenu, MFUNDERLINE);
                    }
                    /*
                     * The ALT key is down, so this window needs menu underlines
                     */
                    if (pwndActivateNext->spmenu != NULL) {
                        SetMF(pwndActivateNext->spmenu, MFUNDERLINE);
                    }
                }


                ThreadLockAlwaysWithPti(ptiCurrent, pwndActivateNext, &tlpwndActivateNext);
                xxxSetWindowPos(pwndActivateNext, PWND_BOTTOM, 0, 0, 0, 0,
                        SWP_DEFERDRAWING | SWP_NOSENDCHANGING | SWP_NOCHANGE |
                        SWP_ASYNCWINDOWPOS);
                xxxSetForegroundWindow2(pwndActivateNext, NULL, SFW_SWITCH);
                ThreadUnlock(&tlpwndActivateNext);
            }
        }
        break;
    }
}

/***************************************************************************\
* xxxOldNextWindow
*
* This function does the processing for the alt-tab/esc/F6 UI.
*
* History:
* 03-17-92  DavidPe     Ported from Win 3.1 sources
\***************************************************************************/
VOID xxxOldNextWindow(
    UINT flags)
{
    MSG         msg;
    HWND        hwndSel;
    PWND        pwndNewSel;
    PWND        pwndSel;
    BOOL        fType = 0;
    BOOL        fDrawIcon;
    WORD        vk;
    TL          tlpwndT;
    TL          tlpwndSel;
    TL          tlpwndSwitch;
    PSWINFO     pswCurrent;
    PWND        pwndSwitch;
    HWND        hwndStop;
    HWND        hwndNewSel;
    PTHREADINFO ptiCurrent = PtiCurrent();

    /*
     * Don't allow entering this routine when we're already in the AltTab
     * mode. The AltTab window may have been created via xxxNextWindow.
     */
    if (gspwndAltTab != NULL) {
        return;
    }

    if ((pwndSel = ptiCurrent->pq->spwndActive) == NULL)
        return;

    ThreadLockWithPti(ptiCurrent, pwndSel, &tlpwndSel);
    xxxCapture(ptiCurrent, pwndSel, SCREEN_CAPTURE);

    vk = (WORD)flags;
    msg.wParam = (UINT)flags;

    pwndNewSel = NULL;

    if (vk == VK_TAB) {

        TL tlpSwitchInfo;

        /*
         *  Initialize the Switch window data structures
         */
        pwndNewSel = InitSwitchWndInfo(&pswCurrent,
                                       pwndSel,
                                       _GetKeyState(VK_SHIFT) < 0);

        if (pswCurrent == NULL) {
            /*
             * We were unable to initialize the data structure used by
             * the Switch window, so we will act like Alt+Esc.
             */
        } else {
            PWND pwndSwitch;

            /*
             * We are doing a journal playback do use _GetKeyState to
             * test the keyboard.
             */
            pswCurrent->fJournaling = TRUE;

            ThreadLockPoolCleanup(ptiCurrent, &pswCurrent, &tlpSwitchInfo, RemoveSwitchWindowInfo);

            pwndSwitch =
                 xxxNVCreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_WINDOWEDGE | WS_EX_DLGMODALFRAME,
                                     (PLARGE_STRING)SWITCHWNDCLASS,
                                     NULL,
                                     WS_POPUP | WS_BORDER | WS_DISABLED,
                                     0,
                                     0,
                                     10,
                                     10,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     VER40);
            if (gspwndAltTab != NULL) {
                RIPMSGF0(RIP_WARNING,
                         "Creating a new switch window while one already exists.");

                _PostMessage(gspwndAltTab, WM_CLOSE, 0, 0);
            }

            ThreadUnlockPool(ptiCurrent, &tlpSwitchInfo);

            Lock(&gspwndAltTab, pwndSwitch);

            if (!(pwndSwitch = gspwndAltTab)) {
                RemoveSwitchWindowInfo(&pswCurrent);
            } else {
                /*
                 * Lock the switch window.
                 */
                ThreadLockAlwaysWithPti(ptiCurrent, pwndSwitch, &tlpwndSwitch);

                /*
                 *  Save the switch window info
                 */
                Setpswi(pwndSwitch, pswCurrent);

// Don't we need to switch from full screen mode if needed?
#if 0
                /*
                 * If we're currently full screen tell console to switch to
                 * the desktop to GDI mode; we can't do this on the RIT because
                 * it can be slow.
                 */
                if (gspwndFullScreen != grpdeskRitInput->pDeskInfo->spwnd) {
                    ThreadLockWithPti(pti, grpdeskRitInput->pDeskInfo->spwnd, &tlpwndT);
                    xxxSendNotifyMessage(grpdeskRitInput->pDeskInfo->spwnd, WM_FULLSCREEN, GDIFULLSCREEN, (LONG)HW(grpdeskRitInput->pDeskInfo->spwnd));
                    ThreadUnlock(&tlpwndT);
                }
#endif

                /*
                 *  Show the switch window, this also will paint the window
                 */
                xxxShowSwitchWindow(gspwndAltTab);
                ThreadUnlock(&tlpwndSwitch);
            }
        }

    }

    if (!pwndNewSel)
        goto StartTab;

    pwndSel = pwndNewSel;

    while (TRUE) {

        hwndSel = PtoH(pwndSel);
        /*
         * Wait for a message without getting it out of the queue.
         */
        while (!xxxPeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE | PM_NOYIELD))
            xxxWaitMessage();

        if ((pwndSel = RevalidateHwnd(hwndSel)) == NULL)
            pwndSel = ptiCurrent->pq->spwndActive;

        if (_CallMsgFilter(&msg, MSGF_NEXTWINDOW)) {
            /*
             * Swallow the message if the hook processed it
             */
            xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
            continue;
        }

        /*
         * If we are doing Alt+Tab and some other key comes in (other than
         * tab, escape or shift), then bomb out of this loop and leave that
         * key in the queue.
         */
        if ((msg.message == WM_SYSKEYDOWN) && gspwndAltTab != NULL) {

            vk = (WORD)msg.wParam;

            if ((vk != VK_TAB) && (vk != VK_ESCAPE) && (vk != VK_SHIFT)) {
                pwndSel = ptiCurrent->pq->spwndActive;
                fType = 0;
                goto Exit;
            }
        }

        switch (msg.message) {

        case WM_CANCELJOURNAL:
            /*
             *  If journalling was canceled we need to exit our loop and
             *  remove the Alt+Tab window.  We don't want to remove this
             *  meesage because we want the app to know that journalling
             *  was canceled.
             */

            /* > > >  F A L L   T H R O U G H  < < < */
        case WM_HOTKEY:
            /*
             * When pressing ALT-CTL-ESC-DEL on the logon desktop
             * We eat WM_KEYUP and the queue for the wiinlogon thread will be empty so will be stuck
             * in xxxWaitMessage() forever till the user do a mouse click where we will exit the loop in the below case statement.
             * consider WM_HOTKEY as a valid exit case.
             * [msadek -- 03/17/2001, bug# 337206]
             */

            /* > > >  F A L L   T H R O U G H  < < < */
        case WM_LBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_RBUTTONDOWN:
        case WM_RBUTTONUP:
        case WM_MBUTTONDOWN:
        case WM_MBUTTONUP:
        case WM_XBUTTONDOWN:
        case WM_XBUTTONUP:
            /*
             * If mouse message, cancel and get out of loop.
             */
            pwndSel = ptiCurrent->pq->spwndActive;
            fType = 0;
            goto Exit;

        case WM_KEYUP:
        case WM_KEYDOWN:
        case WM_SYSCHAR:
        case WM_SYSKEYUP:
        case WM_MOUSEMOVE:
            /*
             * Swallow the message
             */
            hwndSel = PtoH(pwndSel);
            xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);

            if ((pwndSel = RevalidateHwnd(hwndSel)) == NULL)
                pwndSel = ptiCurrent->pq->spwndActive;

            if (msg.message == WM_KEYUP || msg.message == WM_SYSKEYUP) {

                vk = (WORD)msg.wParam;

                /*
                 * If alt-tab up, then exit.
                 */
                if (vk == VK_MENU) {
                    /*
                     * If doing Alt+Esc, wait for up of ESC to get out.
                     */
                    if (gspwndAltTab == NULL)
                        break;

                    fType = 0;
                    goto Exit;

                } else if (vk == VK_ESCAPE || vk == VK_F6) {
                    /*
                     * Get out on up transition of ESC or F6 keys.
                     */
                    if (gspwndAltTab != NULL) {

                        pwndSel = ptiCurrent->pq->spwndActive;
                        fType = 0;

                    } else {

                        fType = ((vk == VK_ESCAPE) ? ALT_ESCAPE : ALT_F6);
                    }

                    goto Exit;
                }

            } else if (msg.message == WM_KEYDOWN) {
                /*
                 *  Exit out loop is a stray key stroke comes through.  In
                 *  particular look for VK_CONTROL.
                 */
                pwndSel = ptiCurrent->pq->spwndActive;
                fType = 0;
                goto Exit;
            }
            break;

        case WM_SYSKEYDOWN:
            vk = (WORD)msg.wParam;

            switch (vk) {

            case VK_SHIFT:
            case VK_TAB:
            case VK_ESCAPE:
            case VK_F6:

                hwndSel = PtoH(pwndSel);
                xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);

                if ((pwndSel = RevalidateHwnd(hwndSel)) == NULL)
                    pwndSel = ptiCurrent->pq->spwndActive;

                if (!(vk == VK_TAB))
                    break;
StartTab:
                if (vk == VK_ESCAPE) {
                    pwndNewSel = _GetNextQueueWindow(
                            pwndSel,
                            _GetKeyState(VK_SHIFT) < 0,
                            TRUE);

                    if (pwndNewSel == NULL)
                        break;

                    fType = ALT_ESCAPE;
                    pwndSel = pwndNewSel;

                    /*
                     * Wait until ESC goes up to activate new window.
                     */
                    break;
                }
                if (vk == VK_F6) {

                    PWND pwndFirst;
                    PWND pwndSaveSel = pwndSel;

                    /*
                     * Save the first returned window to act as a limit
                     * to the search because NextTopWindow will return NULL
                     * only if pwndSel is the only window that meets its
                     * selection criteria.
                     *
                     * This prevents a hang that can occur in winword or
                     * excel when then Alt-F4-F6 key combination is hit
                     * and unsaved changes exist.
                     */
                    pwndFirst = pwndNewSel = (PWND)NextTopWindow(ptiCurrent, pwndSel, NULL,
                            _GetKeyState(VK_SHIFT) < 0 ? NTW_PREVIOUS : 0);

                    while (TRUE) {

                        /*
                         * If pwndNewSel is NULL, pwndSel is the only candidate.
                         */
                        if (pwndNewSel == NULL)
                            break;

                        pwndSel = pwndNewSel;

                        /*
                         * If the window is on the same thread, wait until
                         * F6 goes up to activate new window.
                         */
                        if (GETPTI(pwndSel) == ptiCurrent)
                            break;

                        pwndNewSel = (PWND)NextTopWindow(ptiCurrent, pwndSel, NULL,
                                _GetKeyState(VK_SHIFT) < 0 ? NTW_PREVIOUS : 0);

                        /*
                         * If we've looped around, use the original window.
                         * Wait until F6 goes up to activate new window.
                         */
                        if (pwndNewSel == pwndFirst) {
                            pwndSel = pwndSaveSel;
                            break;
                        }
                    }
                    break;
                }

                /*
                 * Here for the Alt+Tab case
                 */
                if ((pwndSwitch = gspwndAltTab) != NULL) {
                    ThreadLockWithPti(ptiCurrent, pwndSwitch, &tlpwndSwitch);
                    hwndStop = NULL;
                    do {

                        pswCurrent = Getpswi(pwndSwitch);
                        if (pswCurrent == NULL) {
                            break;
                        }
                        hwndNewSel = xxxMoveSwitchWndHilite(
                                pwndSwitch,
                                pswCurrent,
                                _GetKeyState(VK_SHIFT) < 0);

                        if (!hwndStop) {
                            hwndStop = hwndNewSel;
                        } else {
                            if (hwndStop == hwndNewSel) {
                                pwndNewSel = NULL;
                                break;
                            }
                        }
                        pwndNewSel = RevalidateHwnd(hwndNewSel);
                    } while (!pwndNewSel);
                    ThreadUnlock(&tlpwndSwitch);
                    pwndSel = pwndNewSel;

                } else {

                    pwndNewSel = _GetNextQueueWindow(
                            pwndSel,
                            _GetKeyState(VK_SHIFT) < 0,
                            FALSE);

                    if (pwndNewSel && pwndNewSel != pwndSel) {

                        if (!TestWF(pwndSel, WEFTOPMOST)) {
                            /*
                             *  Force the old window to the bottom
                             */
                            ThreadLockWithPti(ptiCurrent, pwndSel, &tlpwndT);
                            xxxSetWindowPos(pwndSel,
                                            PWND_BOTTOM,
                                            0,
                                            0,
                                            0,
                                            0,
                                            SWP_NOMOVE             |
                                                SWP_NOSIZE         |
                                                SWP_NOACTIVATE     |
                                                SWP_DEFERDRAWING   |
                                                SWP_NOSENDCHANGING |
                                                SWP_ASYNCWINDOWPOS);
                            ThreadUnlock(&tlpwndT);
                        }

                        pwndSel = pwndNewSel; // Will be revalidated at top of loop
                    }
                }
                break;

            default:
                goto Exit;
            }
            break;

        default:
            hwndSel = PtoH(pwndSel);
            xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
            xxxTranslateMessage(&msg, 0);
            xxxDispatchMessage(&msg);

            if ((pwndSel = RevalidateHwnd(hwndSel)) == NULL)
                pwndSel = ptiCurrent->pq->spwndActive;

            break;
        }
    }

Exit:
    xxxReleaseCapture();

    fDrawIcon = (gspwndAltTab != NULL);

    /*
     * If this is an Alt-Escape we also have to send the current window
     * to the bottom.
     */
    if (fType == ALT_ESCAPE) {

        PWND pwndActive;

        if (gpqForeground) {

            pwndActive = gpqForeground->spwndActive;

            if (pwndActive && (pwndActive != pwndSel)) {
                ThreadLockWithPti(ptiCurrent, pwndActive, &tlpwndT);
                xxxSetWindowPos(pwndActive,
                                PWND_BOTTOM,
                                0,
                                0,
                                0,
                                0,
                                SWP_NOMOVE             |
                                    SWP_NOSIZE         |
                                    SWP_NOACTIVATE     |
                                    SWP_DEFERDRAWING   |
                                    SWP_NOSENDCHANGING |
                                    SWP_ASYNCWINDOWPOS);
                ThreadUnlock(&tlpwndT);
            }
        }
    }

    if (pwndSel) {
        ThreadLockWithPti(ptiCurrent, pwndSel, &tlpwndT);
        xxxSetForegroundWindow(pwndSel, FALSE);

        if (TestWF(pwndSel, WFMINIMIZED)) {

            if ((fType == 0) && fDrawIcon)
                _PostMessage(pwndSel, WM_SYSCOMMAND, (UINT)SC_RESTORE, 0);

        }
        ThreadUnlock(&tlpwndT);
    }

    /*
     * destroy the alt-tab window
     */
    xxxCancelCoolSwitch();

    ThreadUnlock(&tlpwndSel);
}

/*****************************************************************************\
*
* GetAltTabInfo()   -   Active Accessibility API for OLEACC
*
* This succeeds if we are currently in alt-tab mode.
*
\*****************************************************************************/
BOOL WINAPI
_GetAltTabInfo(
    int iItem,
    PALTTABINFO pati,
    LPWSTR ccxpwszItemText,
    UINT cchItemText OPTIONAL,
    BOOL bAnsi)
{
    PSWINFO pswCurrent;

    if (!gspwndAltTab || ((pswCurrent = Getpswi(gspwndAltTab)) == NULL)) {
        RIPERR0(ERROR_NOT_FOUND, RIP_WARNING, "no Alt-Tab window");
        return FALSE;
    }

    /*
     * Fill in general information
     */
    pati->cItems = pswCurrent->iTotalTasks;
    pati->cColumns = pswCurrent->iNoOfColumns;
    pati->cRows = pswCurrent->iNoOfRows;

    pati->iColFocus = pswCurrent->iCurCol;
    pati->iRowFocus = pswCurrent->iCurRow;

    pati->cxItem = CXICONSLOT;
    pati->cyItem = CYICONSLOT;
    pati->ptStart = pswCurrent->ptFirstRowStart;

    /*
     * Fill in specific information if asked.
     */
    if (cchItemText && (iItem >= 0)) {
        PWND pwndCur;

        pwndCur = NULL;

        try {
            if ((iItem < pswCurrent->iTotalTasks) &&
                    (pwndCur = RevalidateHwnd(pswCurrent->pbwl->rghwnd[iItem]))) {
                if (bAnsi) {
                    LPSTR ccxpszItemText = (LPSTR)ccxpwszItemText;
                    ULONG cch;
                    RtlUnicodeToMultiByteN(ccxpszItemText, cchItemText - 1,
                            &cch, pwndCur->strName.Buffer, pwndCur->strName.Length);
                    ccxpszItemText[cch] = '\0';
                } else {
                    TextCopy(&pwndCur->strName, ccxpwszItemText, cchItemText);
                }
            } else {
                // no such item
                NullTerminateString(ccxpwszItemText, bAnsi);
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\usergdi.c ===
/****************************** Module Header ******************************\
* Module Name: timers.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains GDI-callable exports from user. No user code
* should call any of these routines.
*
* History:
* 3-Jun-1998 AndrewGo   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* UserSetTimer
*
* GDI-callable routine to enable a system timer on the RIT.
*
* 6/2/98 AndrewGo  Created
\***************************************************************************/
UINT_PTR UserSetTimer(
    UINT dwElapse,
    PVOID pTimerFunc)
{
    UINT_PTR id;
    PTIMER ptmr;

    /*
     * GDI may call during ChangeDisplaySettings, in which case the
     * critical section will already be held. GDI may also call during
     * CreateDC("Device"), in which case the critical section will not
     * already be held.
     */
    BEGIN_REENTERCRIT();

    /*
     * If the RIT hasn't been started yet, let GDI know this by returning
     * failure. Once we've initialized the RIT, we'll let GDI know
     * that GDI can start its timers by calling GreStartTimers().
     */
    if (gptmrMaster) {
        id = InternalSetTimer(NULL, 0, dwElapse, (TIMERPROC_PWND) pTimerFunc, TMRF_RIT);

        /*
         * We don't want cleanup to be done on thread termination. Rather
         * than creating a new flag and adding more code to InternalSetTimer,
         * we disable cleanup by modifying the timer directly.
         */
        if (id) {
            ptmr = FindTimer(NULL, id, TMRF_RIT, FALSE);
            UserAssert(ptmr);
            ptmr->ptiOptCreator = NULL;
        }
    } else {
        id = 0;
    }

    END_REENTERCRIT();

    return id;
}

/***************************************************************************\
* UserKillTimer
*
* 6/2/98 AndrewGo  Created
\***************************************************************************/
VOID UserKillTimer(
    UINT_PTR nID)
{
    /*
     * GDI may call during ChangeDisplaySettings, in which case the
     * critical section will already be held. GDI may also call any
     * time its PDEV reference counts go to zero, in which case the
     * critical section will not already be held.
     */
    BEGIN_REENTERCRIT();

    KILLRITTIMER(NULL, nID);

    END_REENTERCRIT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\update.c ===
/****************************** Module Header ******************************\
* Module Name: update.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the APIs used to invalidate, validate, and force
* updating of windows.
*
* History:
* 27-Oct-1990 DarrinM   Created.
* 25-Jan-1991 IanJa     Revalidation added
* 16-Jul-1991 DarrinM   Recreated from Win 3.1 sources.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Local Constants.
 */
#define UW_ENUMCHILDREN 0x0001
#define UW_RECURSED     0x0004

#define RIR_OUTSIDE     0
#define RIR_INTERSECT   1
#define RIR_INSIDE      2

#define RDW_IGNOREUPDATEDIRTY 0x8000


/***************************************************************************\
* xxxInvalidateRect (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxInvalidateRect(
    PWND   pwnd,
    LPRECT lprcInvalid,
    BOOL   fErase)
{
    CheckLock(pwnd);

    /*
     * BACKWARD COMPATIBILITY HACK
     *
     * In Windows 3.0 and less, ValidateRect/InvalidateRect() call with
     * hwnd == NULL always INVALIDATED and ERASED the entire desktop, and
     * synchronously sent WM_ERASEBKGND and WM_NCPAINT messages before
     * returning.  The Rgn() calls did not have this behavior.
     */
    if (pwnd == NULL) {
        return xxxRedrawWindow(
                pwnd,
                NULL,
                NULL,
                RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE | RDW_ERASENOW);
    } else {
        return xxxRedrawWindow(
                pwnd,
                lprcInvalid,
                NULL,
                fErase ? RDW_INVALIDATE | RDW_ERASE : RDW_INVALIDATE);
    }
}

/***************************************************************************\
* xxxValidateRect (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxValidateRect(
    PWND   pwnd,
    LPRECT lprcValid)
{
    CheckLock(pwnd);

    /*
     * BACKWARD COMPATIBILITY HACK
     *
     * In Windows 3.0 and less, ValidateRect/InvalidateRect() call with
     * hwnd == NULL always INVALIDATED and ERASED the entire desktop, and
     * synchronously sent WM_ERASEBKGND and WM_NCPAINT messages before
     * returning.  The Rgn() calls did not have this behavior.
     */
    if (pwnd == NULL) {
        return xxxRedrawWindow(
                pwnd,
                NULL,
                NULL,
                RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE | RDW_ERASENOW);
    } else {
        return xxxRedrawWindow(pwnd, lprcValid, NULL, RDW_VALIDATE);
    }
}

/***************************************************************************\
* xxxInvalidateRgn (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxInvalidateRgn(
    PWND pwnd,
    HRGN hrgnInvalid,
    BOOL fErase)
{
    CheckLock(pwnd);

    return xxxRedrawWindow(
            pwnd,
            NULL,
            hrgnInvalid,
            fErase ? RDW_INVALIDATE | RDW_ERASE : RDW_INVALIDATE);
}

/***************************************************************************\
* xxxValidateRgn (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxValidateRgn(
    PWND pwnd,
    HRGN hrgnValid)
{
    CheckLock(pwnd);

    return xxxRedrawWindow(pwnd, NULL, hrgnValid, RDW_VALIDATE);
}

/***************************************************************************\
* SmartRectInRegion
*
* This routine is similar to RectInRegion, except that it also determines
* whether or not *lprc is completely within hrgn or not.
*
* RIR_OUTSIDE   - no intersection
* RIR_INTERSECT - *lprc intersects hrgn, but not completely inside
* RIR_INSIDE    - *lprc is completely within hrgn.
*
* LATER:
* It would be MUCH faster to put this functionality into GDI's RectInRegion
* call (a la PM's RectInRegion)
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

UINT SmartRectInRegion(
    HRGN   hrgn,
    LPRECT lprc)
{
    RECT rc;

    if (!GreRectInRegion(hrgn, lprc))
        return RIR_OUTSIDE;

    /*
     * Algorithm: if the intersection of hrgn and *lprc is the
     * same as *lprc, then *lprc is completely within hrgn.
     *
     * If the region is a rectangular one, then do it the easy way.
     */
    if (GreGetRgnBox(hrgn, &rc) == SIMPLEREGION) {

        if (!IntersectRect(&rc, &rc, lprc))
            return RIR_OUTSIDE;

        if (EqualRect(lprc, &rc))
            return RIR_INSIDE;

    } else {

        SetRectRgnIndirect(ghrgnInv2, lprc);

        switch (IntersectRgn(ghrgnInv2, ghrgnInv2, hrgn)) {

        case SIMPLEREGION:
            GreGetRgnBox(ghrgnInv2, &rc);
            if (EqualRect(lprc, &rc))
                return RIR_INSIDE;
            break;

#define RECTINREGION_BUG
#ifdef RECTINREGION_BUG

        /*
         * NOTE: RectInRegion has a BUG, where it sometimes returns TRUE
         * even if the rectangles of a region touch only on the edges
         * with no overlap.  This will result in an empty region after
         * the combination above.
         */
        case NULLREGION:
            return RIR_OUTSIDE;
            break;
#endif

        default:
            break;
        }
    }

    return RIR_INTERSECT;
}

/***************************************************************************\
* PixieHack
*
* BACKWARD COMPATIBILITY HACK
*
* In 3.0, WM_NCPAINT messages would be sent to any child window that was
* inside the bounding rectangle of a window management operation involving
* any other child, even if the intersection of that region with the child
* is empty.
*
* Some apps such as Pixie 2.3 and CA Cricket Presents rely on this to ensure
* that their tool windows stay on top of other child windows.  When the tool
* window gets a WM_NCPAINT, it brings itself to the top of the pile.
*
* Borland ObjectVision depends on getting the WM_NCPAINT after an
* invalidation of its parent window in an area that include the non-client
* area of the child.  When it recieves the WM_NCPAINT, it must get a
* clip region of HRGN_FULL, or nothing gets drawn.
*
* History:
* 02-Mar-1992 MikeKe    Ported from Win 3.1 sources.
\***************************************************************************/

VOID PixieHack(
    PWND   pwnd,
    LPRECT prcBounds)
{
    /*
     * If a child intersects the update region, and it isn't already
     * getting an NCPAINT, then make sure it gets one later.
     *
     * Don't apply this hack to top level windows.
     */
    if ((pwnd != _GetDesktopWindow()) &&
        TestWF(pwnd, WFCLIPCHILDREN)  &&
        !TestWF(pwnd, WFMINIMIZED)) {

        RECT rc;

        for (pwnd = pwnd->spwndChild; pwnd; pwnd = pwnd->spwndNext) {

            /*
             * If the window isn't already getting an NCPAINT message,
             * and it has a caption, and it's inside the bounding rect,
             * make sure it gets a WM_NCPAINT with wParam == HRGN_FULL.
             */
            if (!TestWF(pwnd, WFSENDNCPAINT)                      &&
                (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION)) &&
                IntersectRect(&rc, prcBounds, &pwnd->rcWindow)) {

                /*
                 * Sync paint count is incremented when
                 * (senderasebkgnd | sendncpaint) goes from 0 to != 0.
                 * (should make a routine out of this!)
                 */
                SetWF(pwnd, WFSENDNCPAINT);

                /*
                 * Force HRGN_FULL clip rgn.
                 */
                SetWF(pwnd, WFPIXIEHACK);
            }
        }
    }
}

/***************************************************************************\
* xxxRedrawWindow (API)
*
* Forward to xxxInvalidateWindow if the window is visible.
*
* BACKWARD COMPATIBILITY HACK
*
* In Windows 3.0 and less, ValidateRect/InvalidateRect() call with pwnd == NULL
* always INVALIDATED and ERASED all windows, and synchronously sent
* WM_ERASEBKGND and WM_NCPAINT messages before returning.  The Rgn() calls
* did not have this behavior. This case is handled in
* InvalidateRect/ValidateRect.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxRedrawWindow(
    PWND   pwnd,
    LPRECT lprcUpdate,
    HRGN   hrgnUpdate,
    DWORD  flags)
{
    CheckLock(pwnd);

    /*
     * Always map NULL to the desktop.
     */
    if (pwnd == NULL) {
        pwnd = PtiCurrent()->rpdesk->pDeskInfo->spwnd;
    }

    UserAssert(pwnd != NULL);

    if (IsVisible(pwnd)) {

        TL   tlpwnd;
        HRGN hrgn = hrgnUpdate;

        if (flags & (RDW_VALIDATE | RDW_INVALIDATE)) {

            /*
             * Create a (in)validate region in client window coordinates.
             */
            if (hrgn == NULL) {
                if (!lprcUpdate) {
                    hrgn = HRGN_FULL;
                } else {
                    hrgn = ghrgnInv0;

                    if (TestWF(pwnd, WEFLAYOUTRTL)) {
                        MirrorClientRect(pwnd, lprcUpdate);
                    }

                    if (pwnd == PWNDDESKTOP(pwnd)) {
                        SetRectRgnIndirect(hrgn, lprcUpdate);
                    } else {
                        GreSetRectRgn(
                                hrgn,
                                lprcUpdate->left + pwnd->rcClient.left,
                                lprcUpdate->top + pwnd->rcClient.top,
                                lprcUpdate->right + pwnd->rcClient.left,
                                lprcUpdate->bottom + pwnd->rcClient.top);
                    }
                }
            } else {
                /*
                 * If necessary, make a copy of the passed-in region, because
                 * we'll be trashing it...
                 */
                if (hrgn != HRGN_FULL) {
                    CopyRgn(ghrgnInv0, hrgn);
                    MirrorRegion(pwnd, ghrgnInv0, TRUE);
                    hrgn = ghrgnInv0;
                }

                if (pwnd != PWNDDESKTOP(pwnd)) {
                    GreOffsetRgn(hrgn, pwnd->rcClient.left, pwnd->rcClient.top);
                }
            }
        }

        ThreadLock(pwnd, &tlpwnd);
        xxxInternalInvalidate(pwnd, hrgn, flags | RDW_REDRAWWINDOW);
        ThreadUnlock(&tlpwnd);
    }

    return TRUE;
}

/***************************************************************************\
* InternalInvalidate2
*
* (In)validates hrgn in pwnd and in child windows of pwnd. Child windows
* also subtract their visible region from hrgnSubtract.
*
* pwnd         - The window to (in)validate.
* hrng         - The region to (in)validate.
* hrgnSubtract - The region to subtract the visible region of
*                 child windows from.
* prcParents   - Contains the intersection of pwnd's client or window rect
*                 with the client rectangles of its parents. May just be
*                 the window's client or window rect.
*
* flags        - RDW_ flags.
*
* Returns FALSE if hrgnSubtract becomes a NULLREGION, TRUE otherwise.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL InternalInvalidate2(
    PWND   pwnd,
    HRGN   hrgn,
    HRGN   hrgnSubtract,
    LPRECT prcParents,
    DWORD  flags)
{
    /*
     * NOTE: Uses ghrgnInv2
     */
    RECT  rcOurShare;
    DWORD flagsChildren;
    PWND  pwndT;

    /*
     * This routine is called recursively down the parent/child chain.
     * Remember if on the way one of the windows has a clipping region.
     * This info is used later on to optimize out a loop in the common
     * case.
     */
    if (pwnd->hrgnClip != NULL) {
        flags |= RDW_HASWINDOWRGN;
    }

    /*
     * If we recurse, make sure our children subtract themselves off.
     */
    flagsChildren = flags | RDW_SUBTRACTSELF;
    CopyRect(&rcOurShare, &pwnd->rcWindow);

    /*
     * If we're invalidating, we only want to deal with the part of
     * our window rectangle that intersects our parents.
     * This way, we don't end up validating or invalidating more than our
     * fair share. If we're completely obscured by our parents, then there is
     * nothing to do.
     *
     * We don't perform this intersection if we're validating, because there
     * are cases where a child and its update region may exist but be obscured
     * by parents, and we want to make sure validation will work in these
     * cases.  ScrollWindow() can cause this when children are offset, as can
     * various 3.0 compatibility hacks.
     */

    if (flags & RDW_INVALIDATE) {
        /*
         * Don't subtract out any sprite windows from the invalid region.
         * Behave as if it's not there.  However, always allow layered window
         * invalidation when RDW_INVALIDATELAYERS is passed in.
         */
#ifdef REDIRECTION
        if ((TestWF(pwnd, WEFLAYERED) || TestWF(pwnd, WEFEXTREDIRECTED)) &&
#else // REDIRECTION
        if ((TestWF(pwnd, WEFLAYERED)) &&
#endif // REDIRECTION
                !(flags & RDW_INVALIDATELAYERS))
            return TRUE;

        if (!IntersectRect(&rcOurShare, &rcOurShare, prcParents)) {

            /*
             * BACKWARD COMPATIBILITY HACK: If hrgn is (HRGN)1, we need to
             * invalidate ALL child windows, even if they're not visible.  This
             * is a bummer, because it'll result in all sorts of repaints that
             * aren't necessary.
             *
             * Various apps, including WordStar for Windows and WaveEdit,
             * depend on this behavior.  Here's how WaveEdit relies on this: it
             * has a CS_HDREDRAW | CS_VREDRAW window, that moves its children
             * around with MoveWindow( ..., fRedraw = FALSE).  The windows
             * not part of the new client area didn't get invalidated.
             */
            if (!TestWF(pwnd, WFWIN31COMPAT) && (hrgn == HRGN_FULL)) {

                /*
                 * For purposes of hit-testing, our share is our window
                 * rectangle.  However, we don't want to diddle the region
                 * passed to us, because by rights we're really clipped out!
                 */
                flags &= ~RDW_SUBTRACTSELF;
                flagsChildren &= ~RDW_SUBTRACTSELF;

            } else {
                return TRUE;
            }
        }

        /*
         * If our window rect doesn't intersect the valid/invalid region,
         * nothing further to do.
         */
        if (hrgn > HRGN_FULL) {

            switch (SmartRectInRegion(hrgn, &rcOurShare)) {
            case RIR_OUTSIDE:
                return TRUE;

            case RIR_INTERSECT:

                /*
                 * The update region can be within the window rect but not
                 * touch the window region; in this case we don't want this
                 * update region to be distributed to this window. If this
                 * is the case, return TRUE as if RIR_OUTSIDE.
                 *
                 * If RDW_HASWINDOWRGN is set, either this window or
                 * one of its parents has a window clipping region. This
                 * flag is just an optimization so that this loop isn't
                 * executed all the time.
                 *
                 * A future optimization may be to calculate this parent
                 * clipped region as part of recursion like prcParents is
                 * calculated. It is not super important though because this
                 * case rarely happens (a window with a region), and even
                 * more rare, a regional window that is a child of a regional
                 * window parent.
                 */
                if (flags & RDW_HASWINDOWRGN) {

                    /*
                     * Clip to the window's clipping region and parents!
                     * If we don't clip to parents, we may get a case where
                     * a child clips out some update region that was meant to
                     * go to a sibling of the parent.
                     */
                    SetRectRgnIndirect(ghrgnInv2, &rcOurShare);
                    for (pwndT = pwnd; pwndT != NULL; pwndT = pwndT->spwndParent) {

                        if (pwndT->hrgnClip != NULL) {

                            /*
                             * An error at this stage would possibly result
                             * in more being subtracted out of the clipping
                             * region that we'd like.
                             */
                            IntersectRgn(ghrgnInv2, ghrgnInv2, pwndT->hrgnClip);
                        }
                    }

                    if (IntersectRgn(ghrgnInv2, ghrgnInv2, hrgn) == NULLREGION)
                        return TRUE;
                }
                break;

            case RIR_INSIDE:
                /*
                 * If the rectangle is completely within hrgn, then we can use
                 * HRGN_FULL, which is much faster and easier to deal with.
                 *
                 * COMPAT HACK:  There are some apps (PP, MSDRAW) that depend
                 * on some weirdities of the 3.0 GetUpdateRect in order to
                 * paint properly.  Since this stuff hinges on whether the
                 * update region is 1 or a real region, we need to simulate
                 * when 3.0 would generate a HRGN(1) update region.  The
                 * following optimization was not made in 3.0, so we yank it
                 * in 3.1 for these apps.  (win31 bugs 8235,10380)
                 */
                if (!(GetAppCompatFlags(GETPTI(pwnd)) & GACF_NOHRGN1))
                    hrgn = HRGN_FULL;
                break;
            }
        }

        /*
         * While we are in the middle of compositing, no invalidation should
         * happen, or it will mess up our painting order. This is because on
         * this compositing pass we may validate some of the new invalid area
         * and the invalid area that didn't get validated will bleed through
         * on the next compositing pass. So we will remember an accumulated
         * invalid area which will really get invalidated once the compositing
         * pass is completed.
         */
        if (TestWF(pwnd, WEFPCOMPOSITING)) {
            PREDIRECT prdr = _GetProp(pwnd, PROP_LAYER, TRUE);

            if (prdr != NULL) {
                HRGN hrgnComp = prdr->hrgnComp;

                if (hrgnComp == NULL) {
                    if ((hrgnComp = CreateEmptyRgnPublic()) == NULL) {
                        hrgnComp = HRGN_FULL;
                    }
                }

                SetRectRgnIndirect(ghrgnInv2, &rcOurShare);

                if (hrgnComp != HRGN_FULL) {
                    GreCombineRgn(hrgnComp, hrgnComp, ghrgnInv2, RGN_OR);
                }

                prdr->hrgnComp = hrgnComp;

                if (SubtractRgn(hrgnSubtract, hrgnSubtract, ghrgnInv2) == NULLREGION) {
                    return FALSE;
                }

                return TRUE;
            }
        }
    }

    /*
     * If not CLIPCHILDREN, go diddle the update region BEFORE our clipped
     * children have done their thing to hrgnSubtract. Otherwise,
     * we'll diddle after we recurse.
     */
    if (!TestWF(pwnd, WFCLIPCHILDREN)) {
        InternalInvalidate3(pwnd, hrgn, flags);
    }

    /*
     * If this is a GACF_ALWAYSSENDNCPAINT app, take care of it...
     */
    if (TestWF(pwnd, WFALWAYSSENDNCPAINT))
        PixieHack(pwnd, &rcOurShare);

    /*
     * Recurse on our children if necessary.
     *
     * By default, our children are enumerated if we are not CLIPCHILDREN.
     * Don't bother with children if we're minimized.
     */
    if ((pwnd->spwndChild != NULL) &&
        !TestWF(pwnd, WFMINIMIZED) &&
        !(flags & RDW_NOCHILDREN)  &&
        ((flags & RDW_ALLCHILDREN) || !TestWF(pwnd, WFCLIPCHILDREN))) {

        RECT rcChildrenShare;
        PWND pwndChild;

        /*
         * If we're invalidating, make sure our children
         * erase and frame themselves. Also, tell children to subtract
         * themselves from hrgnSubtract.
         */
        if (flags & RDW_INVALIDATE) {
            flagsChildren |= RDW_ERASE | RDW_FRAME;
        }

        /*
         * Our children are clipped to our client rect, so reflect
         * that in the rectangle we give them.
         */
        if (IntersectRect(&rcChildrenShare, &rcOurShare, &pwnd->rcClient) ||
            (!TestWF(pwnd, WFWIN31COMPAT) && (hrgn == HRGN_FULL))) {

            for (pwndChild = pwnd->spwndChild; pwndChild != NULL;
                    pwndChild = pwndChild->spwndNext) {

                if (!TestWF(pwndChild, WFVISIBLE))
                    continue;

                if (!InternalInvalidate2(pwndChild,
                                         hrgn,
                                         hrgnSubtract,
                                         &rcChildrenShare,
                                         flagsChildren)) {

                    /*
                     * The children swallowed the region:
                     * If there are no update region related things
                     * to do then we can just return with FALSE
                     */
                    if (!(flags & (RDW_INTERNALPAINT | RDW_NOINTERNALPAINT)))
                        return FALSE;

                    /*
                     * We have to enumerate the rest of the children because
                     * one of the RDW_NO/INTERNALPAINT bits is set.  Since
                     * there's no longer any update region to worry about,
                     * strip out the update region bits from the parent
                     * and child fiags.  Also, tell the children not to
                     * bother subtracting themselves from the region.
                     */
                    flags &= ~(RDW_INVALIDATE |
                               RDW_ERASE      |
                               RDW_FRAME      |
                               RDW_VALIDATE   |
                               RDW_NOERASE    |
                               RDW_NOFRAME);

                    flagsChildren &= ~(RDW_INVALIDATE |
                                       RDW_ERASE      |
                                       RDW_FRAME      |
                                       RDW_VALIDATE   |
                                       RDW_NOERASE    |
                                       RDW_NOFRAME    |
                                       RDW_SUBTRACTSELF);
                }
            }
        }
    }

    /*
     * Go diddle the update region  (AFTER our clipped children may have
     * done their thing to hrgnSubtract)
     */
    if (TestWF(pwnd, WFCLIPCHILDREN))
        InternalInvalidate3(pwnd, hrgn, flags);

    /*
     * If we're invalidating and we're supposed to,
     * try to subtract off our window area from the region.
     *
     * This way our parent and our siblings below us will not
     * get any update region for areas that don't need one.
     */
    if (flags & RDW_SUBTRACTSELF) {

        /*
         * Subtract our visible region from the update rgn only if:
         * a) we're not a transparent window
         * b) we are clipsiblings
         * c) we're validating OR our parent is clipchildren.
         *
         * The check for validation is a backward-compatibility hack: this
         * is what 3.0 did, so this is what we do here.
         *
         * BACKWARD COMPATIBILITY HACK
         *
         * In 3.0, we subtracted this window from the update rgn if it
         * was clipsiblings, even if the parent was not clipchildren.
         * This causes a compatibility problem for Lotus Notes 3.1: it
         * has a combobox dropdown in a dialog that is a WS_CLIPSIBLING
         * sibling of the other dialog controls, which are not WS_CLIPSIBLINGs.
         * The dialog is not WS_CLIPCHILDREN.  What happens is that a listbox
         * underneath the dropdown also gets a paint msg (since we didn't
         * do this subtraction), and, since it's not CLIPSIBLINGS, it
         * obliterates the dropdown.
         *
         * This is a very obscure difference, and it's too late in the
         * project to make this change now, so we're leaving the code as is
         * and using a compatibility hack to enable the 3.0-compatible
         * behavior.  It's quite likely that this code works the way it does
         * for other compatibility reasons.  Sigh (neilk).
         */
        if (!TestWF(pwnd, WEFTRANSPARENT) &&
            TestWF(pwnd, WFCLIPSIBLINGS)  &&
            ((flags & RDW_VALIDATE) ||
                 ((pwnd->spwndParent != NULL) &&
                 (TestWF(pwnd->spwndParent, WFCLIPCHILDREN) ||
                 (GetAppCompatFlags(GETPTI(pwnd)) & GACF_SUBTRACTCLIPSIBS))))) {

            /*
             * Intersect with our visible area.
             *
             * Don't worry about errors: an error will result in more, not less
             * area being invalidated, which is okay.
             */
            SetRectRgnIndirect(ghrgnInv2, &rcOurShare);

            /*
             * If RDW_HASWINDOWRGN is set, either this window or
             * one of its parents has a window clipping region. This
             * flag is just an optimization so that this loop isn't
             * executed all the time.
             */
            if (flags & RDW_HASWINDOWRGN) {

                /*
                 * Clip to the window's clipping region and parents!
                 * If we don't clip to parents, we may get a case where
                 * a child clips out some update region that was meant to
                 * go to a sibling of the parent.
                 */
                for (pwndT = pwnd; pwndT != NULL; pwndT = pwndT->spwndParent) {

                    if (pwndT->hrgnClip != NULL) {

                        /*
                         * An error at this stage would possibly result in more
                         * being subtracted out of the clipping region that
                         * we'd like.
                         */
                        IntersectRgn(ghrgnInv2, ghrgnInv2, pwndT->hrgnClip);
                    }
                }
            }


#if 1
            /*
             * TEMP HACK!!! RE-ENABLE this code when regions work again
             */
            if (SubtractRgn(hrgnSubtract, hrgnSubtract, ghrgnInv2) == NULLREGION)
                return FALSE;
#else
            {
            DWORD iRet;

            iRet = SubtractRgn(hrgnSubtract, hrgnSubtract, ghrgnInv2);

            if (iRet == NULLREGION)
                return FALSE;

            if (iRet == SIMPLEREGION) {
                RECT rcSub;
                GreGetRgnBox(hrgnSubtract, &rcSub);
                if (rcSub.left > rcSub.right)
                    return FALSE;
            }
            }
#endif



        }
    }

    return TRUE;
}

/***************************************************************************\
* InternalInvalidate3
*
* Adds or subtracts hrgn to the windows update region and sets appropriate
* painting state flags.
*
* pwnd  - The window.
* hrng  - The region to add to the update region.
* flags - RDW_ flags.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID InternalInvalidate3(
    PWND  pwnd,
    HRGN  hrgn,
    DWORD flags)
{
    BOOL fNeededPaint;

    fNeededPaint = NEEDSPAINT(pwnd);

    if (flags & (RDW_INVALIDATE | RDW_INTERNALPAINT | RDW_ERASE | RDW_FRAME)) {

        if (flags & RDW_INTERNALPAINT)
            SetWF(pwnd, WFINTERNALPAINT);

        if (flags & RDW_INVALIDATE) {

            /*
             * Make sure that the NONCPAINT bit is cleared
             * to ensure that the caption will redraw when we update.
             */
            ClrWF(pwnd, WFNONCPAINT);

            /*
             * If another app is invalidating this window, then set the
             * UPDATEDIRTY flag.
             *
             * Solves critical section where thread A draws, then validates,
             * but thread B goes and invalidates before A validates.
             * See comments later in RDW_VALIDATE code.
             */
            if (GETPTI(pwnd) != PtiCurrent()) {

                SetWF(pwnd, WFUPDATEDIRTY);

                /*
                 * Paint order problem, see paint.c
                 */
                if (TestWF(pwnd, WFWMPAINTSENT)) {
                    SetWF(pwnd, WFDONTVALIDATE);
                }
            }

            /*
             * BACKWARD COMPATIBILITY HACK
             *
             * In 3.0, InvalidateRect(pwnd, NULL, FALSE) would always
             * clear the WFSENDERASEBKGND flag, even if it was previously
             * set from an InvalidateRect(pwnd, NULL, TRUE).  This is bogus,
             * because it can cause you to "lose" WM_ERASEBKGND messages, but
             * AttachMate Extra (and maybe other apps) depend on this behavior.
             */
            if ((hrgn == HRGN_FULL) && !TestWF(pwnd, WFWIN31COMPAT))
                ClrWF(pwnd, WFSENDERASEBKGND);

            if (flags & RDW_ERASE)
                SetWF(pwnd, WFSENDERASEBKGND);

            if ((flags & (RDW_FRAME | RDW_ERASE)) && !TestWF(pwnd, WEFTRANSPARENT))
                SetHungFlag(pwnd, WFREDRAWIFHUNG);

            if (flags & RDW_FRAME)
                SetWF(pwnd, WFSENDNCPAINT);

            /*
             * If window is already completely invalidated,
             * no need to do any further invalidation.
             */
            if (pwnd->hrgnUpdate != HRGN_FULL) {

                if (hrgn == HRGN_FULL) {
InvalidateAll:
                    DeleteMaybeSpecialRgn(pwnd->hrgnUpdate);
                    pwnd->hrgnUpdate = HRGN_FULL;

                } else {
                    if (pwnd->hrgnUpdate == NULL) {

                        if (!(pwnd->hrgnUpdate = CreateEmptyRgnPublic()))
                            goto InvalidateAll;

                        if (CopyRgn(pwnd->hrgnUpdate, hrgn) == ERROR)
                            goto InvalidateAll;

                    } else {   // pwnd->hrgnUpdate is a region

                        if (UnionRgn(pwnd->hrgnUpdate,
                                     pwnd->hrgnUpdate,
                                     hrgn) == ERROR) {

                            goto InvalidateAll;
                        }
                    }
                }
            }
        }

        if (!fNeededPaint && NEEDSPAINT(pwnd))
            IncPaintCount(pwnd);

    } else if (flags & (RDW_VALIDATE | RDW_NOINTERNALPAINT | RDW_NOERASE | RDW_NOFRAME)) {

        /*
         * Validation:
         *
         * Do not allow validation if this window has been invalidated from
         * another process - because this window may be validating just
         * after another process invalidated, thereby validating invalid
         * bits.
         *
         * Sometimes applications draw stuff, then validate what they drew.
         * If another app invalidated some area during the drawing operation,
         * then it will need another paint message.
         *
         * This wouldn't be necessary if people validated BEFORE they drew.
         */
        if (TestWF(pwnd, WFUPDATEDIRTY) && !(flags & RDW_IGNOREUPDATEDIRTY))
            return;

        if (flags & RDW_NOINTERNALPAINT)
            ClrWF(pwnd, WFINTERNALPAINT);

        if (flags & RDW_VALIDATE) {

            if (flags & RDW_NOERASE)
                ClrWF(pwnd, WFSENDERASEBKGND);

            if (flags & RDW_NOFRAME) {
                ClrWF(pwnd, WFSENDNCPAINT);
                ClrWF(pwnd, WFPIXIEHACK);
            }

            if (flags & (RDW_NOERASE | RDW_NOFRAME))
                ClearHungFlag(pwnd, WFREDRAWIFHUNG);

            if (pwnd->hrgnUpdate != NULL) {

                /*
                 * If WFSENDNCPAINT is set, then all or part of the
                 * window border still needs to be drawn.  This means
                 * that we must subtract off the client rectangle only.
                 * Convert HRGN_FULL to the client region.
                 */
                if (TestWF(pwnd, WFSENDNCPAINT) && (hrgn == HRGN_FULL)) {
                    hrgn = ghrgnInv2;
                    CalcWindowRgn(pwnd, hrgn, TRUE);
                }

                if (hrgn == HRGN_FULL) {
ValidateAll:

                    /*
                     * We're validating the entire window.  Just
                     * blow away the update region.
                     */
                    DeleteMaybeSpecialRgn(pwnd->hrgnUpdate);
                    pwnd->hrgnUpdate = (HRGN)NULL;

                    /*
                     * No need to erase the background...
                     */
                    ClrWF(pwnd, WFSENDERASEBKGND);
                    ClearHungFlag(pwnd, WFREDRAWIFHUNG);

                } else {

                    /*
                     * Subtracting some region from pwnd->hrgnUpdate.
                     * Be sure pwnd->hrgnUpdate is a real region.
                     */
                    if (pwnd->hrgnUpdate == HRGN_FULL) {

                        /*
                         * If the WFSENDNCPAINT bit is set,
                         * the update region must include the entire window
                         * area.  Otherwise it includes only the client.
                         */
                        pwnd->hrgnUpdate = CreateEmptyRgnPublic();

                        /*
                         * If the creation failed, punt by
                         * invalidating the entire window.
                         */
                        if (pwnd->hrgnUpdate == NULL)
                            goto InvalidateAll;

                        if (CalcWindowRgn(pwnd,
                                          pwnd->hrgnUpdate,
                                          !(TestWF(pwnd, WFSENDNCPAINT))) == ERROR) {

                            goto InvalidateAll;
                        }
                    }

                    /*
                     * Subtract off the region.  If we get an error,
                     * punt by invalidating everything.  If the
                     * region becomes empty, then validate everything.
                     */
                    switch (SubtractRgn(pwnd->hrgnUpdate,
                                        pwnd->hrgnUpdate,
                                        hrgn)) {
                    case ERROR:
                        goto InvalidateAll;

                    case NULLREGION:
                        goto ValidateAll;
                    }
                }
            }
        }

        if (fNeededPaint && !NEEDSPAINT(pwnd))
            DecPaintCount(pwnd);
    }
}

/***************************************************************************\
* ValidateParents
*
* This routine validates hrgn from the update regions of the parent windows
* between pwnd and its first clip children parent.
* If hrgn is NULL, then the window rect (intersected with all parents)
* is validated.
*
* This routine is called when a window is being drawn in
* UpdateWindow() so that non-CLIPCHILDREN parents
* of windows being redrawn won't draw on their valid children.
*
* Returns FALSE if fRecurse is TRUE and a non-CLIPCHILDREN parent
* has an update region; otherwise, returns TRUE.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL ValidateParents(
    PWND pwnd,
    BOOL fRecurse)
{
    RECT rcParents;
    RECT rc;
    PWND pwndParent = pwnd;
    BOOL fInit = FALSE;

    /*
     * This is checking whether we are in an in-between state, just before
     * a WM_SYNCPAINT is about to arrive.  If not, then ValidateParents()
     * needs to work like it did in Win 3.1.
     */
    while (TestWF(pwndParent, WFCHILD))
        pwndParent = pwndParent->spwndParent;

    if (!TestWF(pwndParent, WFSYNCPAINTPENDING))
        fRecurse = FALSE;

    pwndParent = pwnd;

    while ((pwndParent = pwndParent->spwndParent) != NULL) {

        /*
         * Stop when we find a clipchildren parent
         */
        if (TestWF(pwndParent, WFCLIPCHILDREN))
            break;

        /*
         * Subtract the region from this parent's update region,
         * if it has one.
         */
        if (pwndParent->hrgnUpdate != NULL) {
            if (fRecurse) {
                return FALSE;
            }
            if (!fInit) {
                fInit = TRUE;

                /*
                 * Do initial setup.  If our window rectangle is
                 * completely obscured, get out.
                 */
                rc = pwnd->rcWindow;
                if (!IntersectWithParents(pwnd, &rc))
                    break;

                SetRectRgnIndirect(ghrgnInv1, &rc);

                /*
                 * If this window has a region, make sure the piece being validated
                 * is within this region.
                 */
                if (pwnd->hrgnClip != NULL) {

                    /*
                     * If we get NULLREGION back, there is nothing to validate
                     * against parents, so break out. If ERROR gets returned,
                     * there is not much we can do: the best "wrong" thing
                     * to do is just continue and validate a little more
                     * from the parent.
                     */
                    if (!IntersectRgn(ghrgnInv1, ghrgnInv1, pwnd->hrgnClip))
                        break;
                }
            }

            /*
             * Calculate the rcParents parameter to
             * pass up to InternalInvalidate2.
             */
            rcParents = pwndParent->rcWindow;

            if (!IntersectWithParents(pwndParent, &rcParents))
                break;

            InternalInvalidate2(
                    pwndParent,
                    ghrgnInv1,
                    ghrgnInv1,
                    &rcParents,
                    RDW_VALIDATE | RDW_NOCHILDREN | RDW_IGNOREUPDATEDIRTY);
        }
    }

    return TRUE;
}

/***************************************************************************\
* xxxUpdateWindow2
*
* Sends a WM_PAINT message to the window if it needs painting,
* then sends the message to its children.
*
* Always returns TRUE.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

void xxxUpdateWindow2(
    PWND  pwnd,
    DWORD flags)
{
    TL tlpwnd;

    CheckLock(pwnd);

    if (NEEDSPAINT(pwnd)) {

        /*
         * Punch a hole in our parent's update region, if we have one.
         */
        if (pwnd->hrgnUpdate) {
            if (ValidateParents(pwnd, flags & UW_RECURSED) == FALSE) {
                return;
            }
        }

        /*
         * Now that we're sending the message, clear the
         * internal paint bit if it was previously set.
         */
        if (TestWF(pwnd, WFINTERNALPAINT)) {

            ClrWF(pwnd, WFINTERNALPAINT);

            /*
             * If there is no update region, then no further paint messages
             * are pending, so we must dec the paint count.
             */
            if (pwnd->hrgnUpdate == NULL)
                DecPaintCount(pwnd);
        }

        /*
         * Set a flag indicating that a paint message was not processed
         * (but should be).
         */
        SetWF(pwnd, WFPAINTNOTPROCESSED);

        /*
         * Clear this bit, for apps (like MicroLink) that don't call
         * BeginPaint or GetUpdateRect/Rgn (but DO call ValidateRect)
         * when handling their WM_PAINT message.
         */
        ClrWF(pwnd, WFUPDATEDIRTY);

        /*
         * BACKWARD COMPATIBILITY HACK
         *
         * Win 3.0 always sent WM_PAINTICON with wParam == TRUE for no good
         * reason, and Lotus Notes has come to depend on this.
         */
        if (!TestWF(pwnd, WFWIN40COMPAT) &&
            TestWF(pwnd, WFMINIMIZED)    &&
            (pwnd->pcls->spicn != NULL)) {

            xxxSendMessage(pwnd, WM_PAINTICON, TRUE, 0L);

        } else {

            xxxSendMessage(pwnd, WM_PAINT, 0, 0L);
        }

        /*
         * If the guy didn't call BeginPaint/EndPaint(), or GetUpdateRect/Rgn
         * with fErase == TRUE, then we have to clean up for him here.
         */
        if (TestWF(pwnd, WFPAINTNOTPROCESSED)) {

            RIPMSG0(RIP_VERBOSE,
                "App didn't call BeginPaint() or GetUpdateRect/Rgn(fErase == TRUE) in WM_PAINT");

            xxxSimpleDoSyncPaint(pwnd);
        }
    }

    /*
     * For desktop window, do not force the top level window repaint at this
     * this point.  We are calling UpdateWindow() for the desktop before
     * size/move is sent for the top level windows.
     *
     * BUG: The comment above seems a bit random.  Is there really a problem?
     *      If nothing else this has to remain this way because it is
     *      how Win 3.0 worked (neilk)
     */
    if ((flags & UW_ENUMCHILDREN) && (pwnd != PWNDDESKTOP(pwnd))) {

        /*
         * Update any children...
         */
        ThreadLockNever(&tlpwnd);
        pwnd = pwnd->spwndChild;
        while (pwnd != NULL) {

            /*
             * If there is a transparent window that needs painting,
             * skip it if another window below it needs to paint.
             */
            if (TestWF(pwnd, WEFTRANSPARENT) && NEEDSPAINT(pwnd)) {

                PWND pwndT = pwnd;

                while ((pwndT = pwndT->spwndNext) != NULL) {
                    if (NEEDSPAINT(pwndT))
                        break;
                }

                if (pwndT != NULL) {
                    pwnd = pwnd->spwndNext;
                    continue;
                }
            }

            ThreadLockExchangeAlways(pwnd, &tlpwnd);
            xxxUpdateWindow2(pwnd, flags | UW_RECURSED);
            pwnd = pwnd->spwndNext;
        }

        ThreadUnlock(&tlpwnd);
    }

    return;
}

/***************************************************************************\
* xxxInternalUpdateWindow
*
* Sends a WM_PAINT message to the window if it needs painting,
* then sends the message to its children. Won't send WM_PAINT
* if the window is transparent and has siblings that need
* painting.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

void xxxInternalUpdateWindow(
    PWND pwnd,
    DWORD flags)
{
    PWND pwndComp;

    CheckLock(pwnd);

    if ((pwndComp = GetStyleWindow(pwnd, WEFCOMPOSITED)) != NULL) {
        TL tlpwnd;
        ThreadLockAlways(pwndComp, &tlpwnd);
        xxxCompositedPaint(pwndComp);
        ThreadUnlock(&tlpwnd);
        return;
    }

    /*
     * If the passed-in window is transparent and a sibling below
     * needs repainting, don't do anything.
     */
    if (TestWF(pwnd, WEFTRANSPARENT)) {

        PWND         pwndT = pwnd;
        PTHREADINFO ptiCurrent = GETPTI(pwnd);

        while ((pwndT = pwndT->spwndNext) != NULL) {

            /*
             * Make sure sibling window belongs to same app.
             */
            if (GETPTI(pwndT) != ptiCurrent)
                continue;

            if (NEEDSPAINT(pwndT))
                return;
        }
    }

    /*
     * Enumerate pwnd and all its children, sending WM_PAINTs as needed.
     */
    xxxUpdateWindow2(pwnd, flags);
}

/***************************************************************************\
* xxxInternalInvalidate
*
* (In)validates hrgnUpdate and updates the window.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxInternalInvalidate(
    PWND  pwnd,
    HRGN  hrgnUpdate,
    DWORD flags)
{
    RECT rcParents;
    HRGN hrgnSubtract;
    PWND pwndComp = NULL;
    PWND pwndSave;
    HRGN hrgnComp;

#if DBG
    if (flags & (RDW_ERASENOW | RDW_UPDATENOW)) {
        CheckLock(pwnd);
    }
#endif

    /*
     * For children of composited windows, invalidate starting from the
     * composited window itself.
     */
    if (flags & RDW_INVALIDATE) {
        if ((pwndComp = GetStyleWindow(pwnd, WEFCOMPOSITED)) != NULL) {

            if (hrgnUpdate == HRGN_FULL) {
                hrgnComp = GreCreateRectRgnIndirect(&pwnd->rcWindow);

                if (hrgnComp != NULL) {
                    hrgnUpdate = hrgnComp;
                }
            } else {
                hrgnComp = NULL;
            }

            pwndSave = pwnd;
            pwnd = pwndComp;

            flags |= RDW_ALLCHILDREN;
        }
    }

    /*
     * Allow invalidation of a layered window when someone specifically
     * invalidates it.  This will also prevent invalidation of layered
     * windows during recursive desktop invalidations.
     */
#ifdef REDIRECTION
    if (TestWF(pwnd, WEFLAYERED) || TestWF(pwnd, WEFEXTREDIRECTED)) {
#else // REDIRECTION
    if (TestWF(pwnd, WEFLAYERED)) {
#endif // REDIRECTION
        flags |= RDW_INVALIDATELAYERS;
    }

    /*
     * Ensure that hrgnSubtract is a valid region: if it's NULLREGION,
     * use the client region.
     */
    rcParents = (flags & RDW_FRAME ? pwnd->rcWindow : pwnd->rcClient);

    if (flags & (RDW_VALIDATE | RDW_INVALIDATE)) {

        hrgnSubtract = hrgnUpdate;

        if (hrgnSubtract == HRGN_FULL) {

            hrgnSubtract = ghrgnInv1;
            CalcWindowRgn(pwnd,
                          hrgnSubtract,
                          (flags & RDW_FRAME) ? FALSE : TRUE);
        }

        /*
         * Calculate the bounding rectangle of our screen real estate,
         * by intersecting with our parent rectangles.  While we're at
         * it, check the visibility of ourself and our parents.
         *
         * If we're validating we want to skip this, since there
         * are a number of cases where obscured windows may have
         * update regions to be validated -- in particular, after
         * a ScrollWindow() call where a child window was offset
         * by OffsetChildren() to a new, obscured position.  Some of
         * the 3.0 compatibility hacks also can lead to this situation.
         */
        if ((flags & RDW_INVALIDATE) && !IntersectWithParents(pwnd, &rcParents))
            return;

    } else {
        /*
         * hrgnsubtract needs to be a real region even if
         * we are not invalidating or validating.  It really doesn't
         * matter what the region is, but we set it to null so the code
         * has less degrees of freedom.
         */
        hrgnSubtract = ghrgnInv1;
        SetEmptyRgn(hrgnSubtract);
    }

    /*
     * If we're invalidating, and we're being called by the app,
     * we need to invalidate any SPBs that might be affected by
     * drawing in the client area of this window.
     * We have to do this because there is no guarantee that the
     * application will draw in an area that is invalidated
     * (e.g., if the window is completely obscured by another).
     */
    if (    (flags & (RDW_INVALIDATE | RDW_REDRAWWINDOW)) == (RDW_INVALIDATE | RDW_REDRAWWINDOW) &&
            AnySpbs()) {

        RECT rcInvalid;

        /*
         * Intersect the parent's rect with the region bounds...
         */
        GreGetRgnBox(hrgnSubtract, &rcInvalid);
        IntersectRect(&rcInvalid, &rcInvalid, &rcParents);
        SpbCheckRect(pwnd, &rcInvalid, 0);
    }

    /*
     * Now go do the recursive update region calculations...
     */
    InternalInvalidate2(pwnd, hrgnUpdate, hrgnSubtract, &rcParents, flags);

    if (pwndComp != NULL) {
        pwnd = pwndSave;

        if (hrgnComp != NULL) {
            GreDeleteObject(hrgnComp);
        }
    }

    /*
     * Finally handle any needed drawing.
     *
     * (NOTE: RDW_UPDATENOW implies RDW_ERASENOW)
     */
    if (flags & RDW_UPDATENOW) {

        xxxInternalUpdateWindow(pwnd,
                                flags & RDW_NOCHILDREN ? 0 : UW_ENUMCHILDREN);

    } else if (flags & RDW_ERASENOW) {

        UINT flagsDSP;

        if (flags & RDW_NOCHILDREN) {
            flagsDSP = 0;
        } else if (flags & RDW_ALLCHILDREN) {
            flagsDSP = DSP_ALLCHILDREN;
        } else {
            flagsDSP = DSP_ENUMCLIPPEDCHILDREN;
        }

        xxxDoSyncPaint(pwnd, flagsDSP);
    }
}

/***************************************************************************\
* UpdateWindow (API)
*
* Updates the window and all its children.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxUpdateWindow(
    PWND pwnd)
{
    CheckLock(pwnd);

    xxxInternalUpdateWindow(pwnd, UW_ENUMCHILDREN);

    /*
     * This function needs to return a value, since it is
     * called through NtUserCallHwndLock.
     */
    return TRUE;
}

/***************************************************************************\
* ExcludeUpdateRgn (API)
*
* ENTRY:    hdc - DC to exclude from
*           pwnd - window handle
*
* EXIT:     GDI region type
*
* WARNINGS: The DC is assumed to correspond to the client area of the window.
*
*           The map mode of hdc MUST be text mode (0, 0 is top left corner,
*           one pixel per unit, ascending down and to right) or things won't
*           work.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int _ExcludeUpdateRgn(
    HDC  hdc,
    PWND pwnd)
{
    POINT pt;

    if (pwnd->hrgnUpdate == NULL) {

        RECT rc;

        /*
         * Pass FALSE for fXForm since &rc isn't used.
         */
        return GreGetClipBox(hdc, &rc, FALSE);

    } else if (pwnd->hrgnUpdate == HRGN_FULL) {

        return GreIntersectClipRect(hdc, 0, 0, 0, 0);

    } else {

        /*
         * If no clip rgn exists, then subtract from a device-sized clip rgn.
         * (GetClipRgn returns clip rgn in screen coordinates).
         */
        GreGetDCOrg(hdc, &pt);
        if (GreGetRandomRgn(hdc, ghrgnInv1, 1) != 1) {
            CopyRgn(ghrgnInv1, gpDispInfo->hrgnScreen);
        } else {

            /*
             * Gets returned in dc coords - translate to screen.
             */
            GreOffsetRgn(ghrgnInv1, pt.x, pt.y);
        }

        SubtractRgn(ghrgnInv1, ghrgnInv1, pwnd->hrgnUpdate);

        /*
         * Map to dc coords before select
         */
        GreOffsetRgn(ghrgnInv1, -pt.x, -pt.y);

        return GreExtSelectClipRgn(hdc, ghrgnInv1, RGN_COPY);
    }
}

/***************************************************************************\
* GetUpdateRect (API)
*
* Returns the bounding rectangle of the update region, or an empty rectangle
* if there is no update region.  Rectangle is in client-relative coordinates.
*
* Returns TRUE if the update region is non-empty, FALSE if there is no
* update region.
*
* lprc may be NULL to query whether or not an update region exists at all
* or not.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxGetUpdateRect(
    PWND   pwnd,
    LPRECT lprc,
    BOOL   fErase)
{
    RECT rc;

    CheckLock(pwnd);

    if (fErase)
        xxxSimpleDoSyncPaint(pwnd);

    /*
     * The app is looking at the update region: okay to allow window
     * validation.
     */
    ClrWF(pwnd, WFUPDATEDIRTY);

    if (pwnd->hrgnUpdate == NULL) {

        if (lprc) {
            SetRectEmpty(lprc);
        }

        return FALSE;

    } else {

        /*
         * We must handle the case where a window has an update region,
         * but it is completely obscured by its parents.  In this case, we
         * must validate the window and all its children, and return FALSE.
         *
         * An OffsetChildren() call resulting from SetWindowPos() or
         * ScrollWindowEx() will cause this to happen.  Update regions are
         * just offset without checking their new positions to see if they
         * are obscured by the parent(s).  This is too painful to check in
         * those cases, so we instead handle it here.
         *
         * BeginPaint() handles this case correctly by returning an empty
         * rectangle, so nothing special need be done there.
         */
        if (pwnd->hrgnUpdate == HRGN_FULL) {

            rc = pwnd->rcClient;

        } else {

            switch (GreGetRgnBox(pwnd->hrgnUpdate, &rc)) {
            case ERROR:
            case NULLREGION:
                SetRectEmpty(&rc);
                break;

            case SIMPLEREGION:
            case COMPLEXREGION:
                break;
            }

            IntersectRect(&rc, &rc, &pwnd->rcClient);
        }

        if (IntersectWithParents(pwnd, &rc)) {

            if (pwnd != PWNDDESKTOP(pwnd)) {
                OffsetRect(&rc, -pwnd->rcClient.left, -pwnd->rcClient.top);
            }

            /*
             * If the window is CS_OWNDC, then we must map the returned
             * rectangle with DPtoLP, to ensure that the rectangle is
             * in the same coordinate system as the rectangle returned
             * by BeginPaint().
             *
             * BUT ONLY IF hwnd->hrgnUpdate != HRGN_FULL! For true
             * compatibility with 3.0.
             */
            if (TestCF(pwnd, CFOWNDC) &&
                (TestWF(pwnd, WFWIN31COMPAT) || pwnd->hrgnUpdate != HRGN_FULL)) {

                PDCE pdce;

                /*
                 * Look up this window's DC in the cache, and use it to
                 * map the returned rectangle.
                 */
                for (pdce = gpDispInfo->pdceFirst; pdce; pdce = pdce->pdceNext) {

                    if (pdce->pwndOrg == pwnd && !(pdce->DCX_flags & DCX_CACHE)) {
                        GreDPtoLP(pdce->hdc, (LPPOINT)&rc, 2);
                        break;
                    }
                }
            }

        } else {
           SetRectEmpty(&rc);
        }
    }

    if (lprc) {
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            MirrorClientRect(pwnd, &rc);
        }
        *lprc = rc;
    }

    /*
     * If we're in the process a dragging a full window, mark the start
     * of the application painting. This is to make sure that if the
     * application calls DefWindowProc on the WM_PAINT after painting, we
     * won't erase the newly painted areas. Visual Slick calls GetUpdateRect
     * and then DefWindowProc.
     * See other comments for xxxBeginPaint and xxxDWP_Paint.
     * 8/3/94 johannec
     *
     * NOTE: This causes other problems in vslick where some controls
     *       won't paint.  Since the app doesn't call BeginPaint/EndPaint
     *       to truly set/clear the STARTPAINT flag, we do not clear this
     *       bit. (6-27-1996 : ChrisWil).
     *
     *
     *  if (TEST_PUDF(PUDF_DRAGGINGFULLWINDOW)) {
     *      SetWF(pwnd, WFSTARTPAINT);
     *  }
     */

    return TRUE;
}

/***************************************************************************\
* GetUpdateRgn (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int xxxGetUpdateRgn(
    PWND pwnd,
    HRGN hrgn,
    BOOL fErase)
{
    RECT rc;
    int  code;
    BOOL fNotEmpty;


    CheckLock(pwnd);

    if (fErase)
        xxxSimpleDoSyncPaint(pwnd);

    /*
     * The application is looking at the update region: okay to
     * allow validation
     */
    ClrWF(pwnd, WFUPDATEDIRTY);

    if (pwnd->hrgnUpdate == NULL)
        goto ReturnEmpty;

    rc = pwnd->rcClient;
    fNotEmpty = IntersectWithParents(pwnd, &rc);

    if (pwnd->hrgnUpdate == HRGN_FULL) {

        /*
         * Since the update region may be larger than the window
         * rectangle, intersect it with the window rectangle.
         */
        if (!fNotEmpty)
            goto ReturnEmpty;

        code = SIMPLEREGION;

        /*
         * Normalize the rectangle\region relative to the unclipped window
         */
        if (pwnd != PWNDDESKTOP(pwnd)) {
            OffsetRect(&rc, -pwnd->rcClient.left, -pwnd->rcClient.top);
        }

        SetRectRgnIndirect(hrgn, &rc);

    } else {

        SetRectRgnIndirect(ghrgnInv2, &rc);
        code = IntersectRgn(hrgn, ghrgnInv2, pwnd->hrgnUpdate);

        switch (code) {
        case NULLREGION:
        case ERROR:
            goto ReturnEmpty;

        default:
            if (pwnd != PWNDDESKTOP(pwnd)) {
                GreOffsetRgn(hrgn, -pwnd->rcClient.left, -pwnd->rcClient.top);
            }
            break;
        }
    }

    MirrorRegion(pwnd, hrgn, TRUE);

    /*
     * If we're in the process a dragging a full window, mark the start
     * of the application painting. This is to make sure that if the
     * application calls DefWindowProc on the WM_PAINT after painting, we
     * won't erase the newly painted areas.
     * See other comments for xxxBeginPaint and xxxDWP_Paint.
     * 8/3/94 johannec
     *
     * NOTE: This causes other problems in vslick where some controls
     *       won't paint.  Since the app doesn't call BeginPaint/EndPaint
     *       to truly set/clear the STARTPAINT flag, we do not clear this
     *       bit. (6-27-1996 : ChrisWil).
     *
     *  if (TEST(PUDF(PUDF_DRAGGINGFULLWINDOW)) {
     *      SetWF(pwnd, WFSTARTPAINT);
     *  }
     */

    return code;

ReturnEmpty:
    SetEmptyRgn(hrgn);
    return NULLREGION;
}

/***************************************************************************\
* IntersectWithParents
*
* This routine calculates the intersection of a rectangle with the client
* rectangles of all of pwnd's parents.  Returns FALSE if the intersection
* is empty, a window is invisible, or a parent is minimized.
*
* Stop the intesesection if the window itself or any of its parents are
* layered windows, so we always have a complete bitmap of them.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL IntersectWithParents(
    PWND   pwnd,
    LPRECT lprc)
{
    if (TestWF(pwnd, WEFPREDIRECTED))
        return TRUE;

    while ((pwnd = pwnd->spwndParent) != NULL) {

        if (!TestWF(pwnd, WFVISIBLE) || TestWF(pwnd, WFMINIMIZED))
            return FALSE;

        if (!IntersectRect(lprc, lprc, &pwnd->rcClient))
            return FALSE;

        if (TestWF(pwnd, WEFPREDIRECTED))
            return TRUE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\tounicod.c ===
/****************************** Module Header ******************************\
* Module Name: tounicod.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 02-08-92 GregoryW      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 *     "To a new truth there is nothing more hurtful than an old error."
 *             - Johann Wolfgang von Goethe (1749-1832)
 */

/*
 * macros used locally to make life easier
 */
#define ISCAPSLOCKON(pf) (TestKeyToggleBit(pf, VK_CAPITAL) != 0)
#define ISNUMLOCKON(pf)  (TestKeyToggleBit(pf, VK_NUMLOCK) != 0)
#define ISSHIFTDOWN(w)   (w & 0x01)
#define ISKANALOCKON(pf) (TestKeyToggleBit(pf, VK_KANA)    != 0)

WCHAR xxxClientCharToWchar(
    IN WORD CodePage,
    IN WORD wch);

/***************************************************************************\
* _ToUnicodeEx (API)
*
* This routine provides Unicode translation for the virtual key code
* passed in.
*
* History:
* 02-10-92 GregoryW    Created.
* 01-23-95 GregoryW    Expanded from _ToUnicode to _ToUnicodeEx
\***************************************************************************/
int xxxToUnicodeEx(
    UINT wVirtKey,
    UINT wScanCode,
    CONST BYTE *pbKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wKeyFlags,
    HKL hkl)
{
    int i;
    BYTE afKeyState[CBKEYSTATE];
    DWORD dwDummy;

    /*
     * pKeyState is an array of 256 bytes, each byte representing the
     * following virtual key state: 0x80 means down, 0x01 means toggled.
     * InternalToUnicode() takes an array of bits, so pKeyState needs to
     * be translated. _ToAscii only a public api and rarely gets called,
     * so this is no big deal.
     */
    for (i = 0; i < 256; i++, pbKeyState++) {
        if (*pbKeyState & 0x80) {
            SetKeyDownBit(afKeyState, i);
        } else {
            ClearKeyDownBit(afKeyState, i);
        }

        if (*pbKeyState & 0x01) {
            SetKeyToggleBit(afKeyState, i);
        } else {
            ClearKeyToggleBit(afKeyState, i);
        }
    }

    i = xxxInternalToUnicode(wVirtKey, wScanCode, afKeyState, pwszBuff, cchBuff,
            wKeyFlags, &dwDummy, hkl);


    return i;
}

int ComposeDeadKeys(
    PKL pkl,
    PDEADKEY pDeadKey,
    WCHAR wchTyped,
    WORD *pUniChar,
    INT cChar,
    BOOL bBreak)
{
   /*
    * Attempt to compose this sequence:
    */
   DWORD dwBoth;

   TAGMSG4(DBGTAG_ToUnicode | RIP_THERESMORE,
           "ComposeDeadKeys dead '%C'(%x)+base '%C'(%x)",
           pkl->wchDiacritic, pkl->wchDiacritic,
           wchTyped, wchTyped);
   TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME | RIP_THERESMORE,
           "cChar = %d, bBreak = %d", cChar, bBreak);
   UserAssert(pDeadKey);

   if (cChar < 1) {
       TAGMSG0(DBGTAG_ToUnicode | RIP_NONAME,
               "return 0 because cChar < 1");
       return 0;
   }

   /*
    * Use the layout's built-in table for dead char composition
    */
   dwBoth = MAKELONG(wchTyped, pkl->wchDiacritic);

   if (pDeadKey != NULL) {
       /*
        * Don't let character upstrokes erase the cached dead char: else
        * if this was the dead char key again (being released after the
        * AltGr is released) the dead char would be prematurely cleared.
        */
       if (!bBreak) {
           pkl->wchDiacritic = 0;
       }
       while (pDeadKey->dwBoth != 0) {
           if (pDeadKey->dwBoth == dwBoth) {
               /*
                * found a composition
                */
               if (pDeadKey->uFlags & DKF_DEAD) {
                   /*
                    * Dead again! Save the new 'dead' key
                    */
                   if (!bBreak) {
                       pkl->wchDiacritic = (WORD)pDeadKey->wchComposed;
                   }
                   TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME,
                           "return -1 with dead char '%C'(%x)",
                           pkl->wchDiacritic, pkl->wchDiacritic);
                   return -1;
               }
               *pUniChar = (WORD)pDeadKey->wchComposed;
               TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME,
                       "return 1 with char '%C'(%x)",
                       *pUniChar, *pUniChar);
               return 1;
           }
           pDeadKey++;
       }
   }
   *pUniChar++ = HIWORD(dwBoth);
   if (cChar > 1) {
       *pUniChar = LOWORD(dwBoth);
       TAGMSG4(DBGTAG_ToUnicode | RIP_NONAME,
               "return 2 with uncomposed chars '%C'(%x), '%C'(%x)",
               *(pUniChar-1), *(pUniChar-1), *pUniChar, *pUniChar);
       return 2;
   }
   TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME | RIP_THERESMORE,
           "return 1 - only one char '%C'(%x) because cChar is 1, '%C'(%x)",
           *(pUniChar-1), *(pUniChar-1));
   TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME,
           "  the second char would have been '%C'(%x)",
           LOWORD(dwBoth), LOWORD(dwBoth));
   return 1;
}


/*
 * TranslateInjectedVKey
 *
 * Returns the number of characters (cch) translated.
 *
 * Note on VK_PACKET:
 * Currently, the only purpose of VK_PACKET is to inject a Unicode character
 * into the input stream, but it is intended to be extensible to include other
 * manipulations of the input stream (including the message loop so that IMEs
 * can be involved).  For example, we might send commands to the IME or other
 * parts of the system.
 * For Unicode character injection, we tried widening virtual keys to 32 bits
 * of the form nnnn00e7, where nnnn is 0x0000 - 0xFFFF (representing Unicode
 * characters 0x0000 - 0xFFFF) See KEYEVENTF_UNICODE.
 * But many apps truncate wParam to 16-bits (poorly ported from 16-bits?) and
 * several AV with these VKs (indexing into a table by WM_KEYDOWN wParam?) so
 * we have to cache the character in pti->wchInjected for TranslateMessage to
 * pick up (cf. GetMessagePos, GetMessageExtraInfo and GetMessageTime)
 */
int TranslateInjectedVKey(
    IN UINT uScanCode,
    OUT PWCHAR awchChars,
    IN UINT uiTMFlags)
{
    UserAssert(LOBYTE(uScanCode) == 0);
    if (!(uScanCode & KBDBREAK) || (uiTMFlags & TM_POSTCHARBREAKS)) {
        awchChars[0] = PtiCurrent()->wchInjected;
        return 1;
    }
    return 0;
}



enum {
    NUMPADCONV_OEMCP = 0,
    NUMPADCONV_HKLCP,
    NUMPADCONV_HEX_HKLCP,
    NUMPADCONV_HEX_UNICODE,
};

#define NUMPADSPC_INVALID   (-1)

int NumPadScanCodeToHex(UINT uScanCode, UINT uVirKey)
{
    if (uScanCode >= SCANCODE_NUMPAD_FIRST && uScanCode <= SCANCODE_NUMPAD_LAST) {
        int digit = aVkNumpad[uScanCode - SCANCODE_NUMPAD_FIRST];

        if (digit != 0xff) {
            return digit - VK_NUMPAD0;
        }
        return NUMPADSPC_INVALID;
    }

    if (gfInNumpadHexInput & NUMPAD_HEXMODE_HL) {
        //
        // Full keyboard
        //
        if (uVirKey >= L'A' && uVirKey <= L'F') {
            return uVirKey - L'A' + 0xa;
        }
        if (uVirKey >= L'0' && uVirKey <= L'9') {
            return uVirKey - L'0';
        }
    }

    return NUMPADSPC_INVALID;
}

/*
 * IsDbcsExemptionForHighAnsi
 *
 * returns TRUE if Unicode to ANSI conversion should be
 * done on CP 1252 (Latin-1).
 *
 * If this function is changed, winsrv's equivalent
 * routine should be changed too.
 */
BOOL IsDbcsExemptionForHighAnsi(
    WORD wCodePage,
    WORD wNumpadChar)
{
    UserAssert(HIBYTE(wNumpadChar) == 0);

    if (wCodePage == CP_JAPANESE && IS_JPN_1BYTE_KATAKANA(wNumpadChar)) {
        /*
         * If hkl is JAPANESE and NumpadChar is in KANA range,
         * NumpadChar should be handled by the input locale.
         */
        return FALSE;
    }
    else if (wNumpadChar >= 0x80 && wNumpadChar <= 0xff) {
        /*
         * Otherwise if NumpadChar is in High ANSI range,
         * use 1252 for conversion.
         */
        return TRUE;
    }

    /*
     * None of the above.
     * This case includes the compound Leading Byte and Trailing Byte,
     * which is larger than 0xff.
     */
    return FALSE;
}

#undef MODIFIER_FOR_ALT_NUMPAD

#define MODIFIER_FOR_ALT_NUMPAD(wModBit) \
    ((((wModBits) & ~KBDKANA) == KBDALT) || (((wModBits) & ~KBDKANA) == (KBDALT | KBDSHIFT)))


int xxxInternalToUnicode(
    IN  UINT   uVirtKey,
    IN  UINT   uScanCode,
    CONST IN PBYTE pfvk,
    OUT PWCHAR awchChars,
    IN  INT    cChar,
    IN  UINT   uiTMFlags,
    OUT PDWORD pdwKeyFlags,
    IN  HKL    hkl)
{
    WORD wModBits;
    WORD nShift;
    WCHAR *pUniChar;
    PVK_TO_WCHARS1 pVK;
    PVK_TO_WCHAR_TABLE pVKT;
    static WORD NumpadChar;
    static WORD VKLastDown;
    static BYTE ConvMode;   // 0 == NUMPADCONV_OEMCP
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    PKL pkl;
    PKBDTABLES pKbdTbl;
    PLIGATURE1 pLigature;

    *pdwKeyFlags = (uScanCode & KBDBREAK);

    if ((BYTE)uVirtKey == VK_UNKNOWN) {
        /*
         * WindowsBug 311712: this could be the case of
         * unrecognized scancode.
         */
        RIPMSG1(RIP_WARNING, "xxxInternalToUnicode: VK_UNKNOWN, vsc=%02x", uScanCode);
        return 0;
    }

    if ((hkl == NULL) && ptiCurrent->spklActive) {
        pkl = ptiCurrent->spklActive;
        pKbdTbl = pkl->spkf->pKbdTbl;
    } else {
        pkl = HKLtoPKL(ptiCurrent, hkl);
        if (!pkl) {
            return 0;
        }
        pKbdTbl = pkl->spkf->pKbdTbl;
    }
    UserAssert(pkl != NULL);
    UserAssert(pKbdTbl != NULL);

    pUniChar = awchChars;

    uScanCode &= (0xFF | KBDEXT);

    if (*pdwKeyFlags & KBDBREAK) {        // break code processing
        /*
         * Finalize number pad processing
         *
         */
        if (uVirtKey == VK_MENU) {
            if (NumpadChar) {
                if (ConvMode == NUMPADCONV_HEX_UNICODE) {
                    *pUniChar = NumpadChar;
                } else if (ConvMode == NUMPADCONV_OEMCP &&
                        (ptiCurrent->TIF_flags & TIF_CSRSSTHREAD)) {
                    /*
                     * Pass the OEM char to Console to be converted to Unicode
                     * there, since we don't know the OEM codepage it is using.
                     * Set ALTNUMPAD_BIT for console so it knows!
                     */
                    *pdwKeyFlags |= ALTNUMPAD_BIT;
                    *pUniChar = NumpadChar;
                } else {
                    /*
                     * Conversion based on OEMCP or current input language.
                     */
                    WORD wCodePage;

                    if (ConvMode == NUMPADCONV_OEMCP) {
                        // NlsOemCodePage is exported from ntoskrnl.exe.
                        extern __declspec(dllimport) USHORT NlsOemCodePage;

                        wCodePage = (WORD)NlsOemCodePage;
                    } else {
                        wCodePage = pkl->CodePage;
                    }
                    if (IS_DBCS_CODEPAGE(wCodePage)) {
                        if (NumpadChar & (WORD)~0xff) {
                            /*
                             * Might be a double byte character.
                             * Let's swab it so that NumpadChar has LB in LOBYTE,
                             * TB in HIBYTE.
                             */
                            NumpadChar = MAKEWORD(HIBYTE(NumpadChar), LOBYTE(NumpadChar));
                        } else if (IsDbcsExemptionForHighAnsi(wCodePage, NumpadChar)) {
                            /*
                             * FarEast hack:
                             * treat characters in High ANSI area as if they are
                             * the ones of Codepage 1252.
                             */
                            wCodePage = 1252;
                        }
                    } else {
                        /*
                         * Backward compatibility:
                         * Simulate the legacy modulo behavior for non-FarEast keyboard layouts.
                         */
                        NumpadChar &= 0xff;
                    }

                    *pUniChar = xxxClientCharToWchar(wCodePage, NumpadChar);
                }

                /*
                 * Clear Alt-Numpad state, the ALT key-release generates 1 character.
                 */
                VKLastDown = 0;
                ConvMode = NUMPADCONV_OEMCP;
                NumpadChar = 0;
                gfInNumpadHexInput &= ~NUMPAD_HEXMODE_HL;

                return 1;
            } else if (ConvMode != NUMPADCONV_OEMCP) {
                ConvMode = NUMPADCONV_OEMCP;
            }
        } else if (uVirtKey == VKLastDown) {
            /*
             * The most recently depressed key has now come up: we are now
             * ready to accept a new NumPad key for Alt-Numpad processing.
             */
            VKLastDown = 0;
        }
    }

    if (!(*pdwKeyFlags & KBDBREAK) || (uiTMFlags & TM_POSTCHARBREAKS)) {
        /*
         * Get the character modification bits.
         * The bit-mask (wModBits) encodes depressed modifier keys:
         * these bits are commonly KBDSHIFT, KBDALT and/or KBDCTRL
         * (representing Shift, Alt and Ctrl keys respectively)
         */
        wModBits = GetModifierBits(pKbdTbl->pCharModifiers, pfvk);

        /*
         * If the current shift state is either Alt or Alt-Shift:
         *
         *   1. If a menu is currently displayed then clear the
         *      alt bit from wModBits and proceed with normal
         *      translation.
         *
         *   2. If this is a number pad key then do alt-<numpad>
         *      calculations.
         *
         *   3. Otherwise, clear alt bit and proceed with normal
         *      translation.
         */

        /*
         * Equivalent code is in xxxKeyEvent() to check the
         * low level mode. If you change this code, you may
         * need to change xxxKeyEvent() as well.
         */
        if (!(*pdwKeyFlags & KBDBREAK) && MODIFIER_FOR_ALT_NUMPAD(wModBits)) {
            /*
             * If this is a numeric numpad key
             */
            if ((uiTMFlags & TM_INMENUMODE) == 0) {
                if (gfEnableHexNumpad && uScanCode == SCANCODE_NUMPAD_DOT) {
                    if ((gfInNumpadHexInput & NUMPAD_HEXMODE_HL) == 0) {
                        /*
                         * If the first key is '.', then we're
                         * entering hex input lang input mode.
                         */
                        ConvMode = NUMPADCONV_HEX_HKLCP;
                        /*
                         * Inidicate to the rest of the system
                         * we're in Hex Alt+Numpad mode.
                         */
                        gfInNumpadHexInput |= NUMPAD_HEXMODE_HL;
                        TAGMSG0(DBGTAG_ToUnicode, "NUMPADCONV_HEX_HKLCP");
                    } else {
                        goto ExitNumpadMode;
                    }
                } else if (gfEnableHexNumpad && uScanCode == SCANCODE_NUMPAD_PLUS) {
                    if ((gfInNumpadHexInput & NUMPAD_HEXMODE_HL) == 0) {
                        /*
                         * If the first key is '+', then we're
                         * entering hex UNICODE input mode.
                         */
                        ConvMode = NUMPADCONV_HEX_UNICODE;
                        /*
                         * Inidicate to the rest of the system
                         * we're in Hex Alt+Numpad mode.
                         */
                        gfInNumpadHexInput |= NUMPAD_HEXMODE_HL;
                        TAGMSG0(DBGTAG_ToUnicode, "NUMPADCONV_HEX_UNICODE");
                    } else {
                        goto ExitNumpadMode;
                    }
                } else {
                    int digit = NumPadScanCodeToHex(uScanCode, uVirtKey);

                    if (digit < 0) {
                        goto ExitNumpadMode;
                    }

                    /*
                     * Ignore repeats
                     */
                    if (VKLastDown == uVirtKey) {
                        return 0;
                    }

                    switch (ConvMode) {
                    case NUMPADCONV_HEX_HKLCP:
                    case NUMPADCONV_HEX_UNICODE:
                        /*
                         * Input is treated as hex number.
                         */
                        TAGMSG1(DBGTAG_ToUnicode, "->NUMPADCONV_HEX_*: old NumpadChar=%02x\n", NumpadChar);
                        NumpadChar = NumpadChar * 0x10 + digit;
                        TAGMSG1(DBGTAG_ToUnicode, "<-NUMPADCONV_HEX_*: new NumpadChar=%02x\n", NumpadChar);
                        break;
                    default:
                       /*
                        * Input is treated as decimal number.
                        */
                       NumpadChar = NumpadChar * 10 + digit;

                       /*
                        * Do Alt-Numpad0 processing
                        */
                       if (NumpadChar == 0 && digit == 0) {
                           ConvMode = NUMPADCONV_HKLCP;
                       }
                       break;
                    }
                }
                VKLastDown = (WORD)uVirtKey;
            } else {
ExitNumpadMode:
                /*
                 * Clear Alt-Numpad state and the ALT shift state.
                 */
                VKLastDown = 0;
                ConvMode = NUMPADCONV_OEMCP;
                NumpadChar = 0;
                wModBits &= ~KBDALT;
                gfInNumpadHexInput &= ~NUMPAD_HEXMODE_HL;
            }
        }

        /*
         * LShift/RSHift+Backspace -> Left-to-Right and Right-to-Left marker
         */
        if ((uVirtKey == VK_BACK) && (pKbdTbl->fLocaleFlags & KLLF_LRM_RLM)) {
            if (TestKeyDownBit(pfvk, VK_LSHIFT)) {
                *pUniChar = 0x200E; // LRM
                return 1;
            } else if (TestKeyDownBit(pfvk, VK_RSHIFT)) {
                *pUniChar = 0x200F; // RLM
                return 1;
            }
        } else if (((WORD)uVirtKey == VK_PACKET) && (LOBYTE(uScanCode) == 0)) {
            return TranslateInjectedVKey(uScanCode, awchChars, uiTMFlags);
        }

        /*
         * Scan through all the shift-state tables until a matching Virtual
         * Key is found.
         */
        for (pVKT = pKbdTbl->pVkToWcharTable; pVKT->pVkToWchars != NULL; pVKT++) {
            pVK = pVKT->pVkToWchars;
            while (pVK->VirtualKey != 0) {
                if (pVK->VirtualKey == (BYTE)uVirtKey) {
                    goto VK_Found;
                }
                pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);
            }
        }

        /*
         * Not found: virtual key is not a character.
         */
        goto ReturnBadCharacter;

VK_Found:
        /*
         * The virtual key has been found in table pVKT, at entry pVK
         */

        /*
         * If KanaLock affects this key and it is on: toggle KANA state
         * only if no other state is on. "KANALOK" attributes only exist
         * in Japanese keyboard layout, and only Japanese keyboard hardware
         * can be "KANA" lock on state.
         */
        if ((pVK->Attributes & KANALOK) && (ISKANALOCKON(pfvk))) {
            wModBits |= KBDKANA;
        } else {
            /*
             * If CapsLock affects this key and it is on: toggle SHIFT state
             * only if no other state is on.
             * (CapsLock doesn't affect SHIFT state if Ctrl or Alt are down).
             * OR
             * If CapsLockAltGr affects this key and it is on: toggle SHIFT
             * state only if both Alt & Control are down.
             * (CapsLockAltGr only affects SHIFT if AltGr is being used).
             */
            if ((pVK->Attributes & CAPLOK) && ((wModBits & ~KBDSHIFT) == 0) &&
                    ISCAPSLOCKON(pfvk)) {
                wModBits ^= KBDSHIFT;
            } else if ((pVK->Attributes & CAPLOKALTGR) &&
                    ((wModBits & (KBDALT | KBDCTRL)) == (KBDALT | KBDCTRL)) &&
                    ISCAPSLOCKON(pfvk)) {
                wModBits ^= KBDSHIFT;
            }
        }

        /*
         * If SGCAPS affects this key and CapsLock is on: use the next entry
         * in the table, but not is Ctrl or Alt are down.
         * (SGCAPS is used in Swiss-German, Czech and Czech 101 layouts)
         */
        if ((pVK->Attributes & SGCAPS) && ((wModBits & ~KBDSHIFT) == 0) &&
                ISCAPSLOCKON(pfvk)) {
            pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);
        }

        /*
         * Convert the shift-state bitmask into one of the enumerated
         * logical shift states.
         */
        nShift = GetModificationNumber(pKbdTbl->pCharModifiers, wModBits);

        if (nShift == SHFT_INVALID) {
            /*
             * An invalid combination of Shifter Keys
             */
            goto ReturnBadCharacter;

        } else if ((nShift < pVKT->nModifications) &&
                (pVK->wch[nShift] != WCH_NONE)) {
            /*
             * There is an entry in the table for this combination of
             * Shift State (nShift) and Virtual Key (uVirtKey).
             */
            if (pVK->wch[nShift] == WCH_DEAD) {
                /*
                 * It is a dead character: the next entry contains
                 * its value.
                 */
                pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);

                /*
                 * If the previous char was not dead return a dead character.
                 */
                if (pkl->wchDiacritic == 0) {
                    TAGMSG2(DBGTAG_ToUnicode,
                            "xxxInternalToUnicode: new dead char '%C'(%x), goto ReturnDeadCharacter",
                            pVK->wch[nShift], pVK->wch[nShift]);
                    goto ReturnDeadCharacter;
                }
                /*
                 * Else go to ReturnGoodCharacter which will attempt to
                 * compose this dead character with the previous dead char.
                 */
                /*
                 * N.B. NTBUG 6141
                 * If dead key is hit twice in sequence, Win95/98 gives
                 * two composed characters from dead chars...
                 */
                TAGMSG4(DBGTAG_ToUnicode,
                        "xxxInternalToUnicode: 2 dead chars '%C'(%x)+'%C'(%x)",
                        pkl->wchDiacritic, pkl->wchDiacritic,
                        pVK->wch[nShift], pVK->wch[nShift]);
                if (GetAppCompatFlags2(VER40) & GACF2_NOCHAR_DEADKEY) {
                    /*
                     * AppCompat 377217: Publisher calls TranslateMessage and ToUnicode for
                     * the same dead key when it's not expecting real characters.
                     * On NT4, this resulted like "pushing the dead key in the stack and
                     * no character is compossed", but on NT5 with fix to 6141,
                     * two dead keys compose real characters clearing the internal
                     * dead key cache. The app shouldn't call both TranslateMessage and ToUnicode
                     * for the same key stroke in the first place -- in a way the app was working on
                     * NT4 by just a thin luck.
                     * In any case, since the app has been shipped broadly and hard to fix,
                     * let's simulate the NT4 behavior here, but with just one level cache (not the
                     * stack).
                     */
                    goto ReturnDeadCharacter;
                }

                goto ReturnGoodCharacter;

            } else if (pVK->wch[nShift] == WCH_LGTR) {
                /*
                 * It is a ligature.  Look in ligature table for a match.
                 */
                if ((GET_KBD_VERSION(pKbdTbl) == 0) || ((pLigature = pKbdTbl->pLigature) == NULL)) {
                    /*
                     * Hey, where's the table?
                     */
                    xxxMessageBeep(0);
                    goto ReturnBadCharacter;
                }

                while (pLigature->VirtualKey != 0) {
                    int iLig = 0;
                    int cwchT = 0;

                    if ((pLigature->VirtualKey == pVK->VirtualKey) &&
                            (pLigature->ModificationNumber == nShift)) {
                        /*
                         * Found the ligature!
                         */
                        while ((iLig < pKbdTbl->nLgMax) && (cwchT < cChar)) {
                            if (pLigature->wch[iLig] == WCH_NONE) {
                                /*
                                 * End of ligature.
                                 */
                                return cwchT;
                            }
                            if (pkl->wchDiacritic != 0) {
                                int cComposed;
                                /*
                                 * Attempt to compose the previous deadkey with current
                                 * ligature character.  If this generates yet another
                                 * dead key, go round again without adding to pUniChar
                                 * or cwchT.
                                 */
                                cComposed = ComposeDeadKeys(
                                            pkl,
                                            pKbdTbl->pDeadKey,
                                            pLigature->wch[iLig],
                                            pUniChar + cwchT,
                                            cChar - cwchT,
                                            *pdwKeyFlags & KBDBREAK
                                            );
                                if (cComposed > 0) {
                                    cwchT += cComposed;
                                } else {
                                    RIPMSG2(RIP_ERROR, // we really don't expect this
                                            "InternalToUnicode: dead+lig(%x)->dead(%x)",
                                            pLigature->wch[0], pkl->wchDiacritic);
                                }
                            } else {
                                pUniChar[cwchT++] = pLigature->wch[iLig];
                            }
                            iLig++;
                        }
                        return cwchT;
                    }
                    /*
                     * Not a match, try the next entry.
                     */
                    pLigature = (PLIGATURE1)((PBYTE)pLigature + pKbdTbl->cbLgEntry);
                }
                /*
                 * No match found!
                 */
                xxxMessageBeep(0);
                goto ReturnBadCharacter;
            }

            /*
             * Match found: return the unshifted character
             */
            TAGMSG2(DBGTAG_ToUnicode,
                    "xxxInternalToUnicode: Match found '%C'(%x), goto ReturnGoodChar",
                    pVK->wch[nShift], pVK->wch[nShift]);
            goto ReturnGoodCharacter;

        } else if ((wModBits == KBDCTRL) || (wModBits == (KBDCTRL|KBDSHIFT)) ||
             (wModBits == (KBDKANA|KBDCTRL)) || (wModBits == (KBDKANA|KBDCTRL|KBDSHIFT))) {
            /*
             * There was no entry for this combination of Modification (nShift)
             * and Virtual Key (uVirtKey).  It may still be an ASCII control
             * character though:
             */
            if ((uVirtKey >= 'A') && (uVirtKey <= 'Z')) {
                /*
                 * If the virtual key is in the range A-Z we can convert
                 * it directly to a control character.  Otherwise, we
                 * need to search the control key conversion table for
                 * a match to the virtual key.
                 */
                *pUniChar = (WORD)(uVirtKey & 0x1f);
                return 1;
            } else if ((uVirtKey >= 0xFF61) && (uVirtKey <= 0xFF91)) {
                /*
                 * If the virtual key is in range FF61-FF91 (halfwidth
                 * katakana), we convert it to Virtual scan code with
                 * KANA modifier.
                 */
                *pUniChar = (WORD)(InternalVkKeyScanEx((WCHAR)uVirtKey,pKbdTbl) & 0x1f);
                return 1;
            }
        }
    }

ReturnBadCharacter:
    // pkl->wchDiacritic = 0;
    return 0;

ReturnDeadCharacter:
    *pUniChar = pVK->wch[nShift];

    /*
     * Save 'dead' key: overwrite an existing one.
     */
    if (!(*pdwKeyFlags & KBDBREAK)) {
        pkl->wchDiacritic = *pUniChar;
    }

    UserAssert(pKbdTbl->pDeadKey);

    /*
     * return negative count for dead characters
     */
    return -1;

ReturnGoodCharacter:
    if ((pKbdTbl->pDeadKey != NULL) && (pkl->wchDiacritic != 0)) {
        return ComposeDeadKeys(
                  pkl,
                  pKbdTbl->pDeadKey,
                  pVK->wch[nShift],
                  pUniChar,
                  cChar,
                  *pdwKeyFlags & KBDBREAK
                  );
    }
    *pUniChar = (WORD)pVK->wch[nShift];
    return 1;
}

SHORT InternalVkKeyScanEx(
    WCHAR wchChar,
    PKBDTABLES pKbdTbl)
{
    PVK_TO_WCHARS1 pVK;
    PVK_TO_WCHAR_TABLE pVKT;
    BYTE nShift;
    WORD wModBits;
    WORD wModNumCtrl, wModNumShiftCtrl;
    SHORT shRetvalCtrl = 0;
    SHORT shRetvalShiftCtrl = 0;

    if (pKbdTbl == NULL) {
        pKbdTbl = gspklBaseLayout->spkf->pKbdTbl;
    }

    /*
     * Ctrl and Shift-Control combinations are less favored, so determine
     * the values for nShift which we prefer not to use if at all possible.
     * This is for compatibility with Windows 95/98, which only returns a
     * Ctrl or Shift+Ctrl combo as a last resort. See bugs #78891 & #229141
     */
    wModNumCtrl = GetModificationNumber(pKbdTbl->pCharModifiers, KBDCTRL);
    wModNumShiftCtrl = GetModificationNumber(pKbdTbl->pCharModifiers, KBDSHIFT | KBDCTRL);

    for (pVKT = pKbdTbl->pVkToWcharTable; pVKT->pVkToWchars != NULL; pVKT++) {
        for (pVK = pVKT->pVkToWchars;
                pVK->VirtualKey != 0;
                pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize)) {
            for (nShift = 0; nShift < pVKT->nModifications; nShift++) {
                if (pVK->wch[nShift] == wchChar) {
                    /*
                     * A matching character has been found!
                     */
                    if (pVK->VirtualKey == 0xff) {
                        /*
                         * dead char: back up to previous line to get the VK.
                         */
                        pVK = (PVK_TO_WCHARS1)((PBYTE)pVK - pVKT->cbSize);
                    }

                    /*
                     * If this is the first Ctrl or the first Shift+Ctrl match,
                     * remember in case we don't find any better match.
                     * In the meantime, keep on looking.
                     */
                    if (nShift == wModNumCtrl) {
                        if (shRetvalCtrl == 0) {
                            shRetvalCtrl = (SHORT)MAKEWORD(pVK->VirtualKey, KBDCTRL);
                        }
                    } else if (nShift == wModNumShiftCtrl) {
                        if (shRetvalShiftCtrl == 0) {
                            shRetvalShiftCtrl = (SHORT)MAKEWORD(pVK->VirtualKey, KBDCTRL | KBDSHIFT);
                        }
                    } else {
                        /*
                         * this seems like a very good match!
                         */
                        goto GoodMatchFound;
                    }
                }
            }
        }
    }

    /*
     * Didn't find a good match: use whatever Ctrl/Shift+Ctrl match was found
     */
    if (shRetvalCtrl) {
        return shRetvalCtrl;
    }
    if (shRetvalShiftCtrl) {
        return shRetvalShiftCtrl;
    }

    /*
     * May be a control character not explicitly in the layout tables
     */
    if (wchChar < 0x0020) {
        /*
         * Ctrl+char -> char - 0x40
         */
        return (SHORT)MAKEWORD((wchChar + 0x40), KBDCTRL);
    }
    return -1;

GoodMatchFound:
    /*
     * Scan aModification[] to find nShift: the index will be a bitmask
     * representing the Shifter Keys that need to be pressed to produce
     * this Shift State.
     */
    for (wModBits = 0;
         wModBits <= pKbdTbl->pCharModifiers->wMaxModBits;
         wModBits++)
    {
        if (pKbdTbl->pCharModifiers->ModNumber[wModBits] == nShift) {
            if (pVK->VirtualKey == 0xff) {
                /*
                 * The previous entry contains the actual virtual key in this case.
                 */
                pVK = (PVK_TO_WCHARS1)((PBYTE)pVK - pVKT->cbSize);
            }
            return (SHORT)MAKEWORD(pVK->VirtualKey, wModBits);
        }
    }

    /*
     * huh? should never reach here! (IanJa)
     */
    UserAssertMsg1(FALSE, "InternalVkKeyScanEx error: wchChar = 0x%x", wchChar);
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\validate.c ===
/****************************** Module Header ******************************\
* Module Name: validate.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains functions for validating windows, menus, cursors, etc.
*
* History:
* 01-02-91 DarrinM      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * These defines are used for using the validation macros
 * StartValidateHandleMacro and EndValidateHandleMacro.
 */
#define ClientSharedInfo()  (&gSharedInfo)
#define ServerInfo()  (gpsi)

#include "wow.h"

#if DBG
    CRITSTACK  gCritStack;
#endif

#ifdef USER_PERFORMANCE
__int64   gCSTimeExclusiveWhenEntering;
#endif

/***************************************************************************\
* ValidateHwinsta
*
* Validate windowstation handle
*
* History:
* 03-29-91 JimA             Created.
* 06-20-95 JimA             Kernel-mode objects.
\***************************************************************************/
NTSTATUS ValidateHwinsta(
    HWINSTA         hwinsta,
    KPROCESSOR_MODE AccessMode,
    ACCESS_MASK     amDesired,
    PWINDOWSTATION *ppwinsta)
{
    NTSTATUS Status;

    Status = ObReferenceObjectByHandle(hwinsta,
                                       amDesired,
                                       *ExWindowStationObjectType,
                                       AccessMode,
                                       ppwinsta,
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR1(Status,
                  RIP_WARNING,
                  "ValidateHwinsta failed for 0x%p",
                  hwinsta);
    } else if ((*ppwinsta)->dwSessionId != gSessionId) {
        RIPNTERR3(STATUS_INVALID_HANDLE,
                  RIP_WARNING,
                  "SessionId %d does not match id %d for pwinsta 0x%p",
                  gSessionId,
                  (*ppwinsta)->dwSessionId,
                  *ppwinsta);

        ObDereferenceObject(*ppwinsta);
        return STATUS_INVALID_HANDLE;
    }

    return Status;
}

/***************************************************************************\
* ValidateHdesk
*
* Validate desktop handle
*
* History:
* 03-29-91 JimA             Created.
* 06-20-95 JimA             Kernel-mode objects.
\***************************************************************************/

NTSTATUS ValidateHdesk(
    HDESK           hdesk,
    KPROCESSOR_MODE AccessMode,
    ACCESS_MASK     amDesired,
    PDESKTOP*       ppdesk)
{
    NTSTATUS Status;

    Status = ObReferenceObjectByHandle(hdesk,
                                       amDesired,
                                       *ExDesktopObjectType,
                                       AccessMode,
                                       ppdesk,
                                       NULL);
    if (NT_SUCCESS(Status)) {
        if ((*ppdesk)->dwSessionId != gSessionId) {
            RIPNTERR3(STATUS_INVALID_HANDLE,
                      RIP_WARNING,
                      "SessionId %d does not match id %d for pdesk 0x%p",
                      gSessionId,
                      (*ppdesk)->dwSessionId,
                      *ppdesk);

            goto Error;
        }

        LogDesktop(*ppdesk, LDL_VALIDATE_HDESK, TRUE, (ULONG_PTR)PtiCurrent());

        if ((*ppdesk)->dwDTFlags & (DF_DESTROYED | DF_DESKWNDDESTROYED | DF_DYING)) {
            RIPNTERR1(STATUS_INVALID_HANDLE,
                      RIP_WARNING,
                      "ValidateHdesk: destroyed desktop 0x%p",
                      *ppdesk);
Error:
            ObDereferenceObject(*ppdesk);

            return STATUS_INVALID_HANDLE;
        }
    } else {
        RIPNTERR1(Status,
                  RIP_WARNING,
                  "ValidateHdesk failed for 0x%p",
                  hdesk);
    }

    return Status;
}

/***************************************************************************\
* UserValidateCopyRgn
*
* Validates a region-handle.  This essentially tries to copy the region
* in order to verify the region is valid.  If hrgn isn't a valid region,
* then the combine will fail.  We return a copy of the region.
*
* History:
* 24=Jan-1996   ChrisWil    Created.
\***************************************************************************/
HRGN UserValidateCopyRgn(
    HRGN hrgn)
{
    HRGN hrgnCopy = NULL;

    if (hrgn && (GreValidateServerHandle(hrgn, RGN_TYPE))) {
        hrgnCopy = CreateEmptyRgn();

        if (CopyRgn(hrgnCopy, hrgn) == ERROR) {
            GreDeleteObject(hrgnCopy);
            hrgnCopy = NULL;
        }
    }

    return hrgnCopy;
}

/***************************************************************************\
* ValidateHmenu
*
* Validate menu handle and open it.
*
* History:
* 03-29-91 JimA             Created.
\***************************************************************************/
PMENU ValidateHmenu(
    HMENU hmenu)
{
    PTHREADINFO pti = PtiCurrentShared();
    PMENU pmenuRet;

    pmenuRet = (PMENU)HMValidateHandle(hmenu, TYPE_MENU);

    if (pmenuRet != NULL && pmenuRet->head.rpdesk != pti->rpdesk) {
        RIPERR1(ERROR_INVALID_MENU_HANDLE,
                RIP_WARNING,
                "Invalid menu handle 0x%p",
                hmenu);
        return NULL;
    }

    return pmenuRet;
}



/***************************************************************************\
* ValidateHmonitor
*
* Validate monitor handle and open it.
*
* History:
* 03-29-91 JimA             Created.
\***************************************************************************/
PMONITOR ValidateHmonitor(
    HMONITOR hmonitor)
{
    return (PMONITOR)HMValidateSharedHandle(hmonitor, TYPE_MONITOR);
}

/*
 * The handle validation routines should be optimized for time, not size,
 * since they get called so often.
 */
#pragma optimize("t", on)

/***************************************************************************\
* IsHandleEntrySecure
*
* Validate a user handle for a restricted process bypassing the routine to
* get the handle entry.
*
* History:
* August 22, 97   CLupu      Created.
\***************************************************************************/
BOOL IsHandleEntrySecure(
    HANDLE h,
    PHE    phe)
{
    DWORD        bCreateFlags;
    PPROCESSINFO ppiOwner;
    PPROCESSINFO ppiCurrent;
    PW32JOB      pW32Job;
    DWORD        ind;
    PULONG_PTR   pgh;

    ppiCurrent = PpiCurrent();
    if (ppiCurrent == NULL) {
        return TRUE;
    }

    UserAssert(ppiCurrent->pW32Job != NULL);
    UserAssert(ppiCurrent->W32PF_Flags & W32PF_RESTRICTED);

    /*
     * Get the process that owns the handle.
     */

    bCreateFlags = gahti[phe->bType].bObjectCreateFlags;

    ppiOwner = NULL;

    if (bCreateFlags & OCF_PROCESSOWNED) {
        ppiOwner = (PPROCESSINFO)phe->pOwner;
    } else if (bCreateFlags & OCF_THREADOWNED) {
        PTHREADINFO pti = (PTHREADINFO)phe->pOwner;

        if (pti != NULL) {
            ppiOwner = pti->ppi;
        }
    }

    /*
     * If the owner is NULL then consider the handle secure.
     */
    if (ppiOwner == NULL) {
        return FALSE;
    }

    /*
     * If the handle is owned by a process in the same job, then it's secure.
     */
    if (ppiOwner->pW32Job == ppiCurrent->pW32Job) {
        return TRUE;
    }

    /*
     * The handle is not owned by the current process.
     */
    pW32Job = ppiCurrent->pW32Job;
    if (pW32Job->pgh == NULL) {
        return FALSE;
    }

    pgh = pW32Job->pgh;

    UserAssert(pW32Job->ughCrt <= pW32Job->ughMax);

    for (ind = 0; ind < pW32Job->ughCrt; ind++) {
        if (*(pgh + ind) == (ULONG_PTR)h) {
            return TRUE;
        }
    }

    return FALSE;
}


/***************************************************************************\
* ValidateHandleSecure
*
* Validate a user handle for a restricted process.
*
* History:
* July 29, 97   CLupu      Created.
\***************************************************************************/
BOOL ValidateHandleSecure(
    HANDLE h)
{
    PVOID pobj;

    CheckCritInShared();

    StartValidateHandleMacro(h)
    BeginTypeValidateHandleMacro(pobj, TYPE_GENERIC)

        if (IsHandleEntrySecure(h, phe)) {
            return TRUE;
        }

    EndTypeValidateHandleMacro
    EndValidateHandleMacro

    return FALSE;
}

/***************************************************************************\
* ValidateHwnd
*
* History:
* 08-Feb-1991 mikeke
\***************************************************************************/
PWND FASTCALL ValidateHwnd(
    HWND hwnd)
{
    StartValidateHandleMacro(hwnd)

        /*
         * Now make sure the app is passing the right handle type for this
         * api. If the handle is TYPE_FREE, this'll catch it.
         */
        if (phe->bType == TYPE_WINDOW) {
            PTHREADINFO pti = PtiCurrentShared();
            PWND pwndRet = (PWND)phe->phead;

            /*
             * This test establishes that the window belongs to the current
             * 'desktop'.. The two exceptions are for the desktop-window of
             * the current desktop, which ends up belonging to another desktop,
             * and when pti->rpdesk is NULL.  This last case happens for
             * initialization of TIF_SYSTEMTHREAD threads (ie. console windows).
             * IanJa doesn't know if we should be test TIF_CSRSSTHREAD here, but
             * JohnC thinks the whole test below is no longer required ??? LATER
             */

            if (pwndRet != NULL) {
                if (phe->bFlags & HANDLEF_DESTROY) {
                    RIPERR2(ERROR_INVALID_WINDOW_HANDLE,
                        RIP_WARNING,"ValidateHwnd, hwnd %#p, pwnd %#p already destroyed\n",
                            hwnd, pwndRet);
                    return NULL;
                }
                if (GETPTI(pwndRet) == pti ||
                       (
                        (pwndRet->head.rpdesk == pti->rpdesk ||
                         (pti->TIF_flags & TIF_SYSTEMTHREAD) ||  // | TIF_CSRSSTHREAD I think
                         GetDesktopView(pti->ppi, pwndRet->head.rpdesk) !=
                                NULL))) {

                    if (IS_THREAD_RESTRICTED(pti, JOB_OBJECT_UILIMIT_HANDLES)) {

                        /*
                         * make sure this window belongs to this process
                         */
                        if (!IsHandleEntrySecure(hwnd, phe)) {
                            RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                                    RIP_WARNING,
                                    "ValidateHwnd: Invalid hwnd (%#p) for restricted process\n",
                                    hwnd);
                            pwndRet = NULL;
                        }
                    }
                    return pwndRet;
                }
            }
        }

    EndValidateHandleMacro

    RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
            RIP_WARNING,
            "ValidateHwnd: Invalid hwnd (%#p)",
            hwnd);
    return NULL;
}

/*
 * Switch back to default optimization.
 */
#pragma optimize("", on)

/******************************Public*Routine******************************\
*
* UserCritSec routines
*
* Exposes an opaque interface to the user critical section for
* the WNDOBJ code in GRE
*
* Exposed as functions because they aren't time critical and it
* insulates GRE from rebuilding if the definitions of Enter/LeaveCrit change
*
* History:
*  Wed Sep 20 11:19:14 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#if DBG
#define GetCallStack()                                          \
{                                                               \
    gCritStack.thread  = PsGetCurrentThread();                  \
    gCritStack.nFrames = RtlWalkFrameChain(gCritStack.trace,    \
                                           MAX_STACK_CALLS,     \
                                           0);                  \
}

#define FlushCallStack()                                        \
{                                                               \
    gCritStack.thread  = NULL;                                  \
    gCritStack.nFrames = 0;                                     \
}
#else
#define GetCallStack()
#define FlushCallStack()
#endif // DBG

VOID UserEnterUserCritSec(
    VOID)
{
    EnterCrit();
}

VOID UserLeaveUserCritSec(
    VOID)
{
    LeaveCrit();
}

#if DBG
VOID UserAssertUserCritSecIn(
    VOID)
{
    _AssertCritInShared();
}

VOID UserAssertUserCritSecOut(
    VOID)
{
    _AssertCritOut();
}
#endif // DBG

BOOL UserGetCurrentDesktopId(
    DWORD* pdwDesktopId)
{
    PDESKTOP pdesktop;

    CheckCritIn();

    /*
     * PtiCurrent()->rpdesk can be NULL (in the case of thread shutdown).
     */

    pdesktop = PtiCurrent()->rpdesk;

    if (pdesktop != grpdeskRitInput) {
        RIPMSG0(RIP_WARNING, "UserGetCurrentDesktopId on wrong desktop pdesk\n");
        return FALSE;
    }

    *pdwDesktopId = pdesktop->dwDesktopId;

    return TRUE;
}

#if 0

//
// Temporary arrays used to track critsec frees
//

#define ARRAY_SIZE 20
#define LEAVE_TYPE 0xf00d0000
#define ENTER_TYPE 0x0000dead

typedef struct _DEBUG_STASHCS {
    RTL_CRITICAL_SECTION Lock;
    DWORD Type;
} DEBUG_STASHCS, *PDEBUG_STASHCS;

DEBUG_STASHCS UserSrvArray[ARRAY_SIZE];

ULONG UserSrvIndex;

VOID
DumpArray(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString,
    LPDWORD IndexAddress,
    LPDWORD ArrayAddress
    )
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    DWORD History;
    int InitialIndex;
    PDEBUG_STASHCS Array;
    BOOL b;
    PRTL_CRITICAL_SECTION CriticalSection;
    CHAR Symbol[64], Symbol2[64];
    DWORD Displacement, Displacement2;
    int Position;
    LPSTR p;

    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    p = lpArgumentString;

    History = 0;

    if (*p) {
        History = EvalExpression(p);
    }
    if (History == 0 || History >= ARRAY_SIZE) {
        History = 10;
    }

    //
    // Get the Current Index and the array.
    //

    b = ReadProcessMemory(
            hCurrentProcess,
            (LPVOID)IndexAddress,
            &InitialIndex,
            sizeof(InitialIndex),
            NULL
            );
    if (!b) {
        return;
    }

    Array = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(UserSrvArray));
    if (!Array) {
        return;
    }

    b = ReadProcessMemory(
            hCurrentProcess,
            (LPVOID)ArrayAddress,
            Array,
            sizeof(UserSrvArray),
            NULL
            );
    if (!b) {
        RtlFreeHeap(RtlProcessHeap(), 0, Array);
        return;
    }

    Position = 0;
    while (History) {
        InitialIndex--;
        if (InitialIndex < 0) {
            InitialIndex = ARRAY_SIZE - 1;
        }

        if (Array[InitialIndex].Type == LEAVE_TYPE) {
            (Print)("\n(%d) LEAVING Critical Section \n", Position);
        } else {
            (Print)("\n(%d) ENTERING Critical Section \n", Position);
        }

        CriticalSection = &Array[InitialIndex].Lock;

        if (CriticalSection->LockCount == -1) {
            (Print)("\tLockCount NOT LOCKED\n");
        } else {
            (Print)("\tLockCount %ld\n", CriticalSection->LockCount);
        }
        (Print)("\tRecursionCount %ld\n", CriticalSection->RecursionCount);
        (Print)("\tOwningThread %lx\n", CriticalSection->OwningThread );
#if DBG
        (GetSymbol)(CriticalSection->OwnerBackTrace[0], Symbol, &Displacement);
        (GetSymbol)(CriticalSection->OwnerBackTrace[1], Symbol2, &Displacement2);
        (Print)("\tCalling Address %s+%lx\n", Symbol, Displacement);
        (Print)("\tCallers Caller %s+%lx\n", Symbol2, Displacement2);
#endif // DBG
        Position--;
        History--;
    }
    RtlFreeHeap(RtlProcessHeap(), 0, Array);
}


VOID
dsrv(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
{
    DumpArray(
        hCurrentProcess,
        hCurrentThread,
        dwCurrentPc,
        lpExtensionApis,
        lpArgumentString,
        &UserSrvIndex,
        (LPDWORD)&UserSrvArray[0]
        );
}

#endif // if 0

#if DBG

/***************************************************************************\
* _EnterCrit
* _LeaveCrit
*
* These are temporary routines that are used by USER.DLL until the critsect,
* validation, mapping code is moved to the server-side stubs generated by
* SMeans' Thank compiler.
*
* History:
* 01-02-91 DarrinM      Created.
\***************************************************************************/
VOID _AssertCritIn(
    VOID)
{
    UserAssert(gpresUser != NULL);
    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresUser) == TRUE);
}

VOID _AssertDeviceInfoListCritIn(
    VOID)
{
    UserAssert(gpresDeviceInfoList != NULL);
    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresDeviceInfoList) == TRUE);
}

VOID _AssertCritInShared(
    VOID)
{
    UserAssert(gpresUser != NULL);
    UserAssert( (ExIsResourceAcquiredExclusiveLite(gpresUser) == TRUE) ||
            (ExIsResourceAcquiredSharedLite(gpresUser) == TRUE));
}

VOID _AssertCritOut(
    VOID)
{
    UserAssert(gpresUser != NULL);
    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresUser) == FALSE);
}

VOID _AssertDeviceInfoListCritOut(
    VOID)
{
    UserAssert(gpresDeviceInfoList != NULL);
    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresDeviceInfoList) == FALSE);
}

/***************************************************************************\
* BeginAtomicCheck()
* EndAtomicCheck()
*
* Routine that verify we never leave the critical section and that an
* operation is truely atomic with the possiblity of other code being run
* because we left the critical section
*
\***************************************************************************/
VOID BeginAtomicCheck(
    VOID)
{
    gdwInAtomicOperation++;
}

VOID EndAtomicCheck(
    VOID)
{
    UserAssert(gdwInAtomicOperation > 0);
    gdwInAtomicOperation--;
}

VOID BeginAtomicDeviceInfoListCheck(
    VOID)
{
    gdwInAtomicDeviceInfoListOperation++;
}

VOID EndAtomicDeviceInfoListCheck(
    VOID)
{
    UserAssert(gdwInAtomicDeviceInfoListOperation > 0);
    gdwInAtomicDeviceInfoListOperation--;
}

#define INCCRITSECCOUNT (gdwCritSecUseCount++)
#define INCDEVICEINFOLISTCRITSECCOUNT (gdwDeviceInfoListCritSecUseCount++)

#else // else DBG

#define INCCRITSECCOUNT
#define INCDEVICEINFOLISTCRITSECCOUNT

#endif // endif DBG

BOOL UserIsUserCritSecIn(
    VOID)
{
    UserAssert(gpresUser != NULL);
    return ((ExIsResourceAcquiredExclusiveLite(gpresUser) == TRUE) ||
            (ExIsResourceAcquiredSharedLite(gpresUser) == TRUE));
}

#if DBG
VOID CheckDevLockOut(
    VOID)
{
    /*
     * gpDispInfo can be NULL if Win32UserInitialize fails before allocating
     * it. hDev is initialized later in InitVideo, after the critical
     * section has been released at least once, so we better check it too.
     */
    if (gpDispInfo != NULL && gpDispInfo->hDev != NULL) {
        UserAssert(!GreIsDisplayLocked(gpDispInfo->hDev));
    }
}
#else
#define CheckDevLockOut()
#endif

VOID EnterCrit(
    VOID)
{
    CheckCritOut();
    CheckDeviceInfoListCritOut();
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(gpresUser, TRUE);
    CheckDevLockOut();
    UserAssert(!ISATOMICCHECK());
    UserAssert(gptiCurrent == NULL);
    gptiCurrent = ((PTHREADINFO)(W32GetCurrentThread()));
    INCCRITSECCOUNT;
#if defined (USER_PERFORMANCE)
    {
        __int64 i64Frecv;
        *(LARGE_INTEGER*)(&gCSTimeExclusiveWhenEntering) = KeQueryPerformanceCounter((LARGE_INTEGER*)&i64Frecv);
        InterlockedIncrement(&gCSStatistics.cExclusive);
    }
#endif // (USER_PERFORMANCE)

    GetCallStack();
}

#if DBG
VOID EnterDeviceInfoListCrit(
    VOID)
{
    CheckDeviceInfoListCritOut();
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(gpresDeviceInfoList, TRUE);
    UserAssert(!ISATOMICDEVICEINFOLISTCHECK());
    INCDEVICEINFOLISTCRITSECCOUNT;
}
#endif // DBG

VOID EnterSharedCrit(
    VOID)
{
    KeEnterCriticalRegion();
    ExAcquireResourceSharedLite(gpresUser, TRUE);
    CheckDevLockOut();
    UserAssert(!ISATOMICCHECK());
#if defined (USER_PERFORMANCE)
    InterlockedIncrement(&gCSStatistics.cShared);
#endif // (USER_PERFORMANCE)

    INCCRITSECCOUNT;
}

VOID LeaveCrit(
    VOID)
{
    INCCRITSECCOUNT;
#if DBG
    UserAssert(!ISATOMICCHECK());
    UserAssert(IsWinEventNotifyDeferredOK());
    CheckDevLockOut();
    FlushCallStack();
    gptiCurrent = NULL;
#endif // DBG

#ifdef USER_PERFORMANCE
    /*
     * A non null gCSTimeExclusiveWhenEntering means the
     * critical section is owned exclusive
     */
    if (gCSTimeExclusiveWhenEntering) {
        __int64 i64Temp, i64Frecv;

        *(LARGE_INTEGER*)(&i64Temp) = KeQueryPerformanceCounter((LARGE_INTEGER*)&i64Frecv);
        gCSStatistics.i64TimeExclusive += i64Temp - gCSTimeExclusiveWhenEntering;
        gCSTimeExclusiveWhenEntering = 0;
    }
#endif // USER_PERFORMANCE
    ExReleaseResourceLite(gpresUser);
    KeLeaveCriticalRegion();
    CheckCritOut();
}

#if DBG
VOID _LeaveDeviceInfoListCrit(
    VOID)
{
    INCDEVICEINFOLISTCRITSECCOUNT;
    UserAssert(!ISATOMICDEVICEINFOLISTCHECK());

    ExReleaseResourceLite(gpresDeviceInfoList);
    KeLeaveCriticalRegion();
    CheckDeviceInfoListCritOut();
}
#endif // DBG

VOID ChangeAcquireResourceType(
    VOID)
{

#if DBG
    FlushCallStack();
    CheckDevLockOut();
    UserAssert(!ISATOMICCHECK());
#endif // DBG

    ExReleaseResourceLite(gpresUser);
    ExAcquireResourceExclusiveLite(gpresUser, TRUE);
    gptiCurrent = ((PTHREADINFO)(W32GetCurrentThread()));

    GetCallStack();
}


#if DBG

PTHREADINFO _ptiCrit(
    VOID)
{
    UserAssert(gpresUser);
    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresUser) == TRUE);
    UserAssert(gptiCurrent);
    UserAssert(gptiCurrent == ((PTHREADINFO)(W32GetCurrentThread())));
    UserAssert(gptiCurrent);

    return gptiCurrent;
}

PTHREADINFO _ptiCritShared(
    VOID)
{
    UserAssert(W32GetCurrentThread());
    return ((PTHREADINFO)(W32GetCurrentThread()));
}

#undef KeUserModeCallback

NTSTATUS
_KeUserModeCallback (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    OUT PULONG OutputLength)
{

    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresUser) == FALSE);

    /*
     * Added this so we can detect an erroneous user mode callback
     * with a checked win32k on top of a free system.
     */
    UserAssert(PsGetCurrentThreadPreviousMode() == UserMode);

    return KeUserModeCallback(ApiNumber, InputBuffer, InputLength,
            OutputBuffer, OutputLength);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\visrgn.c ===
/****************************** Module Header ******************************\
* Module Name: visrgn.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains User's visible region ('visrgn') manipulation
* functions.
*
* History:
* 23-Oct-1990 DarrinM   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Globals used to keep track of pwnds which
 * need to be excluded from the visrgns.
 */
#define CEXCLUDERECTSMAX 30
#define CEXCLUDEPWNDSMAX 30


BOOL  gfVisAlloc;
int   gcrcVisExclude;
int   gcrcVisExcludeMax;
PWND *gapwndVisExclude;
PWND *gapwndVisDefault;

/***************************************************************************\
* SetRectRgnIndirect
*
* Sets a rect region from a rectangle.
*
* History:
* 26-Sep-1996 adams     Created.
\***************************************************************************/

BOOL
SetRectRgnIndirect(HRGN hrgn, LPCRECT lprc)
{
    return GreSetRectRgn(hrgn, lprc->left, lprc->top, lprc->right, lprc->bottom);
}



/***************************************************************************\
* CreateEmptyRgn
*
* Creates an empty region.
*
* History:
* 24-Sep-1996 adams     Created.
\***************************************************************************/

HRGN
CreateEmptyRgn(void)
{
    return GreCreateRectRgnIndirect(PZERO(RECT));
}



/***************************************************************************\
* CreateEmptyRgnPublic
*
* Creates an empty region and make it public.
*
* History:
* 24-Sep-1996 adams     Created.
\***************************************************************************/

HRGN
CreateEmptyRgnPublic(void)
{
    HRGN hrgn;

    if (hrgn = CreateEmptyRgn()) {
        UserVerify(GreSetRegionOwner(hrgn, OBJECT_OWNER_PUBLIC));
    }

    return hrgn;
}



/***************************************************************************\
* SetEmptyRgn
*
* Sets an empty region.
*
* History:
* 26-Sep-1996 adams     Created.
\***************************************************************************/

BOOL
SetEmptyRgn(HRGN hrgn)
{
    return SetRectRgnIndirect(hrgn, PZERO(RECT));
}



/***************************************************************************\
* SetOrCreateRectRgnIndirectPublic
*
* Sets a region to a rectangle, creating it and making it public
* if it is not already there.
*
* History:
* 01-Oct-1996 adams     Created.
\***************************************************************************/

HRGN
SetOrCreateRectRgnIndirectPublic(HRGN * phrgn, LPCRECT lprc)
{
    if (*phrgn) {
        UserVerify(SetRectRgnIndirect(*phrgn, lprc));
    } else if (*phrgn = GreCreateRectRgnIndirect((LPRECT) lprc)) {
        UserVerify(GreSetRegionOwner(*phrgn, OBJECT_OWNER_PUBLIC));
    }

    return *phrgn;
}


/***************************************************************************\
* ResizeVisExcludeMemory
*
*   This routine is used to resize the vis-rgn memory buffer if the count
*   is exceeded.
*
*
* History:
* 22-Oct-1994 ChrisWil  Created
* 27-Feb-1997 adams     Removed call to UserReallocPool, since the pool
*                       allocator doesn't support realloc.
\***************************************************************************/

BOOL ResizeVisExcludeMemory(VOID)
{
    int     crcNew;
    PWND    apwndNew;

    /*
     * Note (adams): a previous version of the code called UserReallocPool
     * if memory had already been allocated. Unfortunately, UserReallocPool
     * just has to allocate more memory and copy the contents, since Rtl
     * doesn't have a realloc function. If Rtl later gains a Realloc function,
     * this code should be changed to the previous version.
     */

    crcNew = gcrcVisExcludeMax + CEXCLUDEPWNDSMAX;
    apwndNew = (PWND)UserAllocPool(
            crcNew * sizeof(PWND), TAG_VISRGN);

    if (!apwndNew)
        return FALSE;

    UserAssert(gcrcVisExcludeMax == gcrcVisExclude);
    RtlCopyMemory(apwndNew, gapwndVisExclude, gcrcVisExcludeMax * sizeof(PWND));
    if (gfVisAlloc) {
        UserFreePool(gapwndVisExclude);
    } else {
        gfVisAlloc = TRUE;
    }

    gcrcVisExcludeMax = crcNew;
    gapwndVisExclude = (PWND *)apwndNew;
    return TRUE;
}



/***************************************************************************\
* ExcludeWindowRects
*   This routine checks to see if the pwnd needs to be added to the list
*   of excluded-clip-rects.  If so, it appends the pwnd to the array.  They
*   do not need to be sorted, since GreSubtractRgnRectList() sorts them
*   internally.
*
*
* History:
* 05-Nov-1992 DavidPe   Created.
* 21-Oct-1994 ChrisWil  Removed pwnd->pwndNextYX.  No longer sorts pwnds.
\***************************************************************************/

#define CheckIntersectRect(prc1, prc2)        \
    (   prc1->left < prc2->right              \
     && prc2->left < prc1->right              \
     && prc1->top < prc2->bottom              \
     && prc2->top < prc1->bottom)

#define EmptyRect(prc)                        \
    (   prc->left >= prc->right               \
     || prc->top >= prc->bottom)

BOOL ExcludeWindowRects(
    PWND   pwnd    ,
    PWND   pwndStop,
    LPRECT lprcIntersect)
{
    PRECT prc;

#if DBG
    if (pwnd != NULL && pwndStop != NULL &&
            pwnd->spwndParent != pwndStop->spwndParent) {
        RIPMSG0(RIP_ERROR, "ExcludeWindowRects: bad windows passed in");
    }
#endif

    while ((pwnd != NULL) && (pwnd != pwndStop)) {
        UserAssert(pwnd);
        prc = &pwnd->rcWindow;
        if (       TestWF(pwnd, WFVISIBLE)
#ifdef REDIRECTION
                && (TestWF(pwnd, WEFEXTREDIRECTED) == 0)
#endif // REDIRECTION
                && (TestWF(pwnd, WEFLAYERED) == 0)
                && (TestWF(pwnd, WEFTRANSPARENT) == 0)
                && CheckIntersectRect(lprcIntersect, prc)
                && !EmptyRect(prc)) {

            UserAssert(gcrcVisExclude <= gcrcVisExcludeMax);
            if (gcrcVisExclude == gcrcVisExcludeMax) {
                if (!ResizeVisExcludeMemory()) {
                    return FALSE;
                }
            }

            gapwndVisExclude[gcrcVisExclude++] = pwnd;
        }

        pwnd = pwnd->spwndNext;
    }

    return TRUE;
}



/***************************************************************************\
* CalcWindowVisRgn
*
*   This routine performs the work of calculating the VisRgn for a window.
*
*
* History:
* 02-Nov-1992 DavidPe   Created.
* 21-Oct-1992 ChrisWil  Removed pwnd->pwndNextYX.  No longer sorts pwnds.
\***************************************************************************/

BOOL CalcWindowVisRgn(
    PWND  pwnd,
    HRGN  *phrgn,
    DWORD flags)
{
    RECT rcWindow;
    PWND pwndParent;
    PWND pwndRoot;
    PWND pwndLoop;
    BOOL fClipSiblings;
    BOOL fRgnParent = FALSE;
    BOOL fResult;
    PWND apwndVisDefault[CEXCLUDEPWNDSMAX];


    /*
     * First get the initial window rectangle which will be used for
     * the basis of exclusion calculations.
     */
    rcWindow = (flags & DCX_WINDOW ? pwnd->rcWindow : pwnd->rcClient);

    /*
     * Get the parent of this window.  We start at the parent and backtrack
     * through the window-parent-list until we reach the end of the parent-
     * list.  This will give us the intersect-rectangle which is used as
     * the basis for checking intersection of the exclusion rects.
     */
    pwndRoot   = pwnd->head.rpdesk->pDeskInfo->spwnd->spwndParent;
    pwndParent = pwnd->spwndParent;

    /*
     * The parent can be NULL in the case when pwnd == pwndRoot. In other
     * cases we should figure why the parent is NULL.
     */
    if (pwndParent == NULL) {
#if DBG
        if (pwnd != pwndRoot) {
            RIPMSG0(RIP_ERROR, "CalcWindowVisRgn: pwndParent is NULL");
        }
#endif
        goto NullRegion;
    }

    while (pwndParent != pwndRoot) {

        /*
         * Don't clip layered DCs to the desktop. The surface of the layered
         * DC is the size of the window and we always want to have the image
         * of the entire window in that surface.
         */
        if ((flags & DCX_REDIRECTED) && (GETFNID(pwndParent) == FNID_DESKTOP))
            break;

        /*
         * Remember if any of the parents have a window region.
         */
        if (pwndParent->hrgnClip != NULL)
            fRgnParent = TRUE;

        /*
         * Intersect the parent's client rectangle with the window rectangle.
         */
        if (!IntersectRect(&rcWindow, &rcWindow, &pwndParent->rcClient))
            goto NullRegion;

        pwndParent = pwndParent->spwndParent;
    }

    /*
     * Initialize the VisRgn memory-buffer.  This is
     * used to hold the pwnd's.
     */
    gapwndVisDefault  = apwndVisDefault;
    gapwndVisExclude  = gapwndVisDefault;
    gcrcVisExcludeMax = ARRAY_SIZE(apwndVisDefault);
    gcrcVisExclude    = 0;

    /*
     * Build the list of exclude-rects.
     */
    fClipSiblings = (BOOL)(flags & DCX_CLIPSIBLINGS);
    pwndParent    = pwnd->spwndParent;
    pwndLoop      = pwnd;

    while (pwndParent != pwndRoot) {
        /*
         * If we reach a redirected window, we can stop excluding any
         * siblings any siblings of any parents.
         */
        if ((flags & DCX_REDIRECTED) && TestWF(pwndLoop, WEFPREDIRECTED)) {
            break;
        }

        /*
         * Exclude any siblings if necessary.
         */
        if (fClipSiblings && (pwndParent->spwndChild != pwndLoop)) {

            if (!ExcludeWindowRects(pwndParent->spwndChild,
                                    pwndLoop,
                                    &rcWindow)) {

                goto NullRegion;
            }
        }


        /*
         * Set this flag for next time through the loop...
         */
        fClipSiblings = TestWF(pwndParent, WFCLIPSIBLINGS);

        pwndLoop      = pwndParent;
        pwndParent    = pwndLoop->spwndParent;
    }

    if ((flags & DCX_CLIPCHILDREN) && (pwnd->spwndChild != NULL)) {

        if (!ExcludeWindowRects(pwnd->spwndChild, NULL, &rcWindow)) {
            goto NullRegion;
        }
    }

    /*
     * If there are rectangles to exclude call GDI to create
     * a region excluding them from the window rectangle.  If
     * not simply call GreSetRectRgn().
     */
    if (gcrcVisExclude > 0) {

        RECT  arcVisRects[CEXCLUDERECTSMAX];
        PRECT arcExclude;
        int   i;
        int   ircVisExclude  = 0;
        int   irgnVisExclude = 0;

        /*
         * If we need to exclude more rectangles than fit in
         * the pre-allocated buffer, obviously we have to
         * allocate one that's big enough.
         */

        if (gcrcVisExclude <= CEXCLUDERECTSMAX) {
            arcExclude = arcVisRects;
        } else {
            arcExclude = (PRECT)UserAllocPoolWithQuota(
                    sizeof(RECT) * gcrcVisExclude, TAG_VISRGN);

            if (!arcExclude)
                goto NullRegion;
        }

        /*
         * Now run through the list and put the
         * window rectangles into the array for the call
         * to CombineRgnRectList().
         */
        for (i = 0; i < gcrcVisExclude; i++) {

            /*
             * If the window has a clip-rgn associated with
             * it, then re-use gpwneExcludeList[] entries for
             * storing them.
             */
            if (gapwndVisExclude[i]->hrgnClip != NULL) {

                gapwndVisExclude[irgnVisExclude++] = gapwndVisExclude[i];
                continue;
            }

            /*
             * This window doesn't have a clipping region; remember its
             * rect for clipping purposes.
             */
            arcExclude[ircVisExclude++] = gapwndVisExclude[i]->rcWindow;
        }

        if (*phrgn == NULL)
            *phrgn = CreateEmptyRgn();

        if (ircVisExclude != 0) {
            GreSubtractRgnRectList(*phrgn,
                                   &rcWindow,
                                   arcExclude,
                                   ircVisExclude);
        } else {
            SetRectRgnIndirect(*phrgn, &rcWindow);
        }

        for (i = 0; i < irgnVisExclude; i++) {

            SetRectRgnIndirect(ghrgnInv2, &gapwndVisExclude[i]->rcWindow);
            IntersectRgn(ghrgnInv2, ghrgnInv2, gapwndVisExclude[i]->hrgnClip);

            if (SubtractRgn(*phrgn, *phrgn, ghrgnInv2) == NULLREGION)
                break;
        }

        if (arcExclude != arcVisRects) {
            UserFreePool((HLOCAL)arcExclude);
        }

    } else {

        /*
         * If the window was somehow destroyed, then we will return
         * a null-region.  Emptying the rect will accomplish this.
         */
        if (TestWF(pwnd, WFDESTROYED)) {
            SetRectEmpty(&rcWindow);
        }

        /*
         * If there weren't any rectangles to exclude, simply call
         * GreSetRectRgn() with the window rectangle.
         */
        SetOrCreateRectRgnIndirectPublic(phrgn, &rcWindow);
    }

    /*
     * Clip out this window's window region
     */
    if (pwnd->hrgnClip != NULL) {
        IntersectRgn(*phrgn, *phrgn, pwnd->hrgnClip);
    }

    /*
     * Clip out parent's window regions, if there are any.
     */
    if (fRgnParent) {

        PWND pwndT;

        for (pwndT = pwnd->spwndParent;
                pwndT != pwndRoot;
                pwndT = pwndT->spwndParent) {

            if (pwndT->hrgnClip != NULL) {

                if (IntersectRgn(*phrgn, *phrgn, pwndT->hrgnClip) == NULLREGION)
                    break;
            }
        }
    }

    fResult = TRUE;
    // fall-through

Cleanup:
    if (gfVisAlloc) {
        UserFreePool((HLOCAL)gapwndVisExclude);
        gfVisAlloc = FALSE;
    }

    return fResult;

NullRegion:
    SetOrCreateRectRgnIndirectPublic(phrgn, PZERO(RECT));
    fResult = FALSE;
    goto Cleanup;
}

/***************************************************************************\
* CalcVisRgn
*
* Will return FALSE if the pwndOrg is not visible, TRUE otherwise.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL CalcVisRgn(
    HRGN  *phrgn,
    PWND  pwndOrg,
    PWND  pwndClip,
    DWORD flags)
{
    PDESKTOP    pdesk;

    UserAssert(pwndOrg != NULL);

    /*
     * If the window's not visible or is not an active desktop,
     * or if the clip window is in the process of being destroyed,
     * the visrgn is empty.
     */
    pdesk = pwndOrg->head.rpdesk;
    
    UserAssert(pdesk);
    
    /*
     * Make sure this happens in the IO windowstation
     */
#if DBG
    if (grpdeskRitInput != NULL) {
        UserAssert(pdesk->rpwinstaParent == grpdeskRitInput->rpwinstaParent ||
                   !IsVisible(pwndOrg));
    }
#endif // DBG
    /*
     * For redirected windows, if it is on the non I/O desktop, we still need
     * to pass the application a non empty region in order to update the bitmap
     * Otherwise, the bitmap will never got the chance to be updated and we will end up
     * rendering a black window region (for the case of layered windows) by the time
     * we switch to this desktop. (see bug# 287315). Note that this will not render the window on the screen 
     * because the call to CalcVisRgn from UserVisrgnFromHwnd() should never specify 
     * DCX_REDIRECTEDBITMAP.
     */
#if DBG
   if (!TestWF(pwndOrg, WEFPREDIRECTED)) {
       UserAssert(!(flags & DCX_REDIRECTEDBITMAP));
   }
#endif 
    if (!IsVisible(pwndOrg) || 
        ((pdesk != grpdeskRitInput) && !(flags & DCX_REDIRECTEDBITMAP))) {
        goto EmptyRgn;
    }

    /*
     * If LockWindowUpdate() has been called, and this window is a child
     * of the lock window, always return an empty visrgn.
     */
    if ((gspwndLockUpdate != NULL)     &&
        !(flags & DCX_LOCKWINDOWUPDATE)         &&
        _IsDescendant(gspwndLockUpdate, pwndOrg)) {

        goto EmptyRgn;
    }

    /*
     * Now go compute the visrgn for pwndClip.
     */
    return CalcWindowVisRgn(pwndClip, phrgn, flags);

EmptyRgn:
    SetOrCreateRectRgnIndirectPublic(phrgn, PZERO(RECT));
    return FALSE;
}

/***************************************************************************\
* CalcWindowRgn
*
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int CalcWindowRgn(
    PWND pwnd,
    HRGN hrgn,
    BOOL fClient)
{
    SetRectRgnIndirect(hrgn, (fClient) ? &pwnd->rcClient : &pwnd->rcWindow);

    /*
     * If the window has a region, then intersect the rectangle region with
     * that. If this is low on memory, it'll propagate ERROR back.
     */
    if (pwnd->hrgnClip != NULL) {
        return IntersectRgn(hrgn, hrgn, pwnd->hrgnClip);
    }

    return SIMPLEREGION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\userk.h ===
/****************************** Module Header ******************************\
* Module Name: userk.h
*
* Copyright (c) 1985 - 2001, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used exclusively by the User
* kernel-mode code.
*
* History:
* 04-28-91 DarrinM      Created from PROTO.H, MACRO.H, and STRTABLE.H
* 01-25-95 JimA         Prepped for kernel-mode
\***************************************************************************/

#ifndef _USERK_
#define _USERK_

#ifndef _WINBASE_
#include <wbasek.h>
#endif // _WINBASE_

#include <csrmsg.h>
#include <heap.h>

/*
 * BltColor() flags.
 */
#define BC_INVERT             0x00000001
#define BC_NOMIRROR           0x00000002

#define MIRRORED_HDC(hdc)     (GreGetLayout(hdc) & LAYOUT_RTL)

#define OEMRESOURCE 1

#define CCACHEDCAPTIONS 5

#define GETMOUSETRAILS()        (IsRemoteConnection() ? 0 : gMouseTrails)
#define MOUSE_TRAILS_FREQ       50

#include <winnls.h>
#include <wincon.h>

#include <winuser.h>
#include <winuserp.h>
#include <wowuserp.h>
#include "ntddvdeo.h"

#ifdef GENERIC_INPUT
#include <hidpddi.h>
#include <hidpi.h>
#include <hidclass.h>
#endif

#include <user.h>

PTHREADINFO _ptiCrit(VOID);
PTHREADINFO _ptiCritShared(VOID);
extern PTHREADINFO gptiCurrent;

#if DBG
    #define PtiCurrent()  _ptiCrit()
    #define PtiCurrentShared() _ptiCritShared()
#else // DBG
    #define PtiCurrent()  (gptiCurrent)
    #define PtiCurrentShared() ((PTHREADINFO)(W32GetCurrentThread()))
#endif // DBG

extern HANDLE CsrApiPort;

#if DBG
    VOID CheckPtiSysPeek(int where, PQ pq, ULONG_PTR newIdSysPeek);
    VOID CheckSysLock(int where, PQ pq, PTHREADINFO pti);
#else
    #define CheckPtiSysPeek(where, pq, newIdSysPeek)
    #define CheckSysLock(where, pq, pti)
#endif

/*
 * ShutdownProcessRoutine return values
 */
#define SHUTDOWN_KNOWN_PROCESS   1
#define SHUTDOWN_UNKNOWN_PROCESS 2
#define SHUTDOWN_CANCEL          3

/*
 * Macros to get address of current thread and process information.
 */

#define PpiCurrent() ((PPROCESSINFO)(W32GetCurrentProcess()))

#define PtiFromThread(Thread) ((PTHREADINFO)(PsGetThreadWin32Thread(Thread)))

#if DBG
    #define GetNestedCallsCounter() (PtiCurrentShared()->cNestedCalls)
#else
    #define GetNestedCallsCounter()
#endif

#define PpiFromProcess(Process)                                           \
        ((PPROCESSINFO)(PsGetProcessWin32Process(Process)))

#define ISCSRSS() (PsGetCurrentProcess() == gpepCSRSS)

BOOL CSTPush(UINT uThreadID, PVOID pParam, HANDLE UniqueProcessId, BOOL bRemoteThreadStack);

VOID CSTCleanupStack(BOOL bRemoteThreadStack);

__inline BOOL InitCreateSystemThreadsMsg(
    PUSER_API_MSG pMsg,
    UINT ThreadID,
    PVOID pVoid,
    HANDLE UniqueProcessId,
    BOOL bRemoteThread)
{
    UserAssert(CsrApiPort != NULL);

    if (!CSTPush(ThreadID, pVoid, UniqueProcessId, bRemoteThread)) {
        return FALSE;
    }

    pMsg->h.u1.s1.DataLength  = (USHORT)(sizeof(USER_API_MSG) - sizeof(PORT_MESSAGE));
    pMsg->h.u1.s1.TotalLength = (USHORT)sizeof(USER_API_MSG);
    pMsg->h.u2.ZeroInit = 0;
    pMsg->CaptureBuffer = NULL;
    pMsg->ApiNumber = CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX, UserpCreateSystemThreads);
    pMsg->u.CreateSystemThreads.bRemoteThread = bRemoteThread;

    return TRUE;
}

NTSTATUS OpenEffectiveToken(
    PHANDLE phToken);

NTSTATUS GetProcessLuid(
    PETHREAD Thread OPTIONAL,
    PLUID LuidProcess);

BOOLEAN IsRestricted(
    PETHREAD Thread);

NTSTATUS InitSystemThread(
    PUNICODE_STRING pstrThreadName);

#define INITCLIENTINFO(pti)                                         \
{                                                                   \
    try {                                                           \
        pti->pClientInfo->dwExpWinVer = pti->dwExpWinVer;           \
        pti->pClientInfo->dwTIFlags   = pti->TIF_flags;             \
                                                                    \
        pti->pClientInfo->lpClassesRegistered = NULL;               \
                                                                    \
        if (pti->spklActive) {                                      \
            pti->pClientInfo->CodePage = pti->spklActive->CodePage; \
            pti->pClientInfo->hKL = pti->spklActive->hkl;           \
        } else {                                                    \
            pti->pClientInfo->CodePage = CP_ACP;                    \
            pti->pClientInfo->hKL = 0;                              \
        }                                                           \
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {             \
        Status = GetExceptionCode();                                \
        goto Error;                                                 \
    }                                                               \
}

PKEVENT CreateKernelEvent(
    IN EVENT_TYPE Type,
    IN BOOLEAN State);

NTSTATUS ProtectHandle(
    IN HANDLE       Handle,
    IN POBJECT_TYPE pObjectType,
    IN BOOLEAN      Protect);

__inline VOID FreeKernelEvent(PVOID* pp)
{
    UserFreePool(*pp);
    *pp = NULL;
}


extern BOOL  gfSwitchInProgress;
extern PKEVENT gpevtVideoportCallout;

__inline VOID SetConsoleSwitchInProgress(BOOL fSwitchInProgress)
{
    gfSwitchInProgress = fSwitchInProgress;
    if (fSwitchInProgress) {
        KeResetEvent(gpevtVideoportCallout);
    } else {
        KeSetEvent(gpevtVideoportCallout, EVENT_INCREMENT, FALSE);
    }
}

/*
 * Object types exported from the kernel.
 */
extern POBJECT_TYPE *ExWindowStationObjectType;
extern POBJECT_TYPE *ExDesktopObjectType;
extern POBJECT_TYPE *ExEventObjectType;
extern POBJECT_TYPE *IoDriverObjectType;

#ifndef DWORD_ALIGN
#define DWORD_ALIGN(x) ( ((x) + 3) & ~3)
#endif // !DWORD_ALIGN

/*
 * Private probing macros
 */

#if defined(_X86_)
#define DATAALIGN sizeof(BYTE)
#define CHARALIGN sizeof(BYTE)
#else
#define DATAALIGN sizeof(DWORD)
#define CHARALIGN sizeof(WCHAR)
#endif

#define ProbeForReadBuffer(Address, Count, Alignment) {                     \
    if ((ULONG)(Count) > (ULONG)(MAXULONG / sizeof(*(Address)))) {          \
        ExRaiseAccessViolation();                                           \
    }                                                                       \
    ProbeForRead(Address, (ULONG)(Count) * sizeof(*(Address)), Alignment);  \
}

#define ProbeForWriteBuffer(Address, Count, Alignment) {                    \
    if ((ULONG)(Count) > (ULONG)(MAXULONG / sizeof(*(Address)))) {          \
        ExRaiseAccessViolation();                                           \
    }                                                                       \
    ProbeForWrite(Address, (ULONG)(Count) * sizeof(*(Address)), Alignment); \
}

#define ProbeAndReadSize(Address)                         \
    (((Address) >= (SIZE * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile SIZE * const)MM_USER_PROBE_ADDRESS) : (*(volatile SIZE *)(Address)))


#define ProbeAndReadBlendfunction(Address)                         \
    (((Address) >= (BLENDFUNCTION * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile BLENDFUNCTION * const)MM_USER_PROBE_ADDRESS) : (*(volatile BLENDFUNCTION *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadPoint(
//     IN PPOINT Address
//     )
//
//--

#define ProbePoint(Address)                                \
    (((Address) >= (POINT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DWORD * const)MM_USER_PROBE_ADDRESS) : (*(volatile DWORD *)(Address)))

#define ProbeAndReadPoint(Address)                         \
    (((Address) >= (POINT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile POINT * const)MM_USER_PROBE_ADDRESS) : (*(volatile POINT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadRect(
//     IN PRECT Address
//     )
//
//--

#define ProbeRect(Address)                                \
    (((Address) >= (RECT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DWORD * const)MM_USER_PROBE_ADDRESS) : (*(volatile DWORD *)(Address)))

#define ProbeAndReadRect(Address)                         \
    (((Address) >= (RECT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile RECT * const)MM_USER_PROBE_ADDRESS) : (*(volatile RECT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadMessage(
//     IN PMSG Address
//     )
//
//--

#define ProbeMessage(Address)                            \
    (((Address) >= (MSG * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DWORD * const)MM_USER_PROBE_ADDRESS) : (*(volatile DWORD *)(Address)))

#define ProbeAndReadMessage(Address)                     \
    (((Address) >= (MSG * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MSG * const)MM_USER_PROBE_ADDRESS) : (*(volatile MSG *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadLargeString(
//     IN PLARGE_STRING Address
//     )
//
//--

#define ProbeAndReadLargeString(Address)                          \
    (((Address) >= (LARGE_STRING * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile LARGE_STRING * const)MM_USER_PROBE_ADDRESS) : (*(volatile LARGE_STRING *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadWindowPlacement(
//     IN PWINDOWPLACEMENT Address
//     )
//
//--

#define ProbeAndReadWindowPlacement(Address)                         \
    (((Address) >= (WINDOWPLACEMENT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile WINDOWPLACEMENT * const)MM_USER_PROBE_ADDRESS) : (*(volatile WINDOWPLACEMENT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadMenuItem(
//     IN PMENUITEMINFO Address
//     )
//
//--

#define ProbeAndReadMenuItem(Address)                             \
    (((Address) >= (MENUITEMINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MENUITEMINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile MENUITEMINFO *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadMenuInfo(
//     IN PMENUINFO Address
//     )
//
//--

#define ProbeAndReadMenuInfo(Address)                             \
    (((Address) >= (MENUINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MENUINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile MENUINFO *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadScrollInfo(
//     IN PSCROLLINFO Address
//     )
//
//--

#define ProbeAndReadScrollInfo(Address)                         \
    (((Address) >= (SCROLLINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile SCROLLINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile SCROLLINFO *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadPopupParams(
//     IN PTPMPARAMS Address
//     )
//
//--

#define ProbeAndReadPopupParams(Address)                       \
    (((Address) >= (TPMPARAMS * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile TPMPARAMS * const)MM_USER_PROBE_ADDRESS) : (*(volatile TPMPARAMS *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadPaintStruct(
//     IN PPAINTSTRUCT Address
//     )
//
//--

#define ProbeAndReadPaintStruct(Address)                         \
    (((Address) >= (PAINTSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile PAINTSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile PAINTSTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCreateStruct(
//     IN PCREATESTRUCTW Address
//     )
//
//--

#define ProbeAndReadCreateStruct(Address)                          \
    (((Address) >= (CREATESTRUCTW * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CREATESTRUCTW * const)MM_USER_PROBE_ADDRESS) : (*(volatile CREATESTRUCTW *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadMDICreateStruct(
//     IN PMDICREATESTRUCT Address
//     )
//
//--

#define ProbeAndReadMDICreateStruct(Address)                         \
    (((Address) >= (MDICREATESTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MDICREATESTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile MDICREATESTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCopyDataStruct(
//     IN PCOPYDATASTRUCT Address
//     )
//
//--

#define ProbeAndReadCopyDataStruct(Address)                         \
    (((Address) >= (COPYDATASTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile COPYDATASTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile COPYDATASTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCompareItemStruct(
//     IN PCOMPAREITEMSTRUCT Address
//     )
//
//--

#define ProbeAndReadCompareItemStruct(Address)                         \
    (((Address) >= (COMPAREITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile COMPAREITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile COMPAREITEMSTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadDeleteItemStruct(
//     IN PDELETEITEMSTRUCT Address
//     )
//
//--

#define ProbeAndReadDeleteItemStruct(Address)                         \
    (((Address) >= (DELETEITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DELETEITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile DELETEITEMSTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadHelp(
//     IN PHLP Address
//     )
//
//--

#define ProbeAndReadHelp(Address)                        \
    (((Address) >= (HLP * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile HLP * const)MM_USER_PROBE_ADDRESS) : (*(volatile HLP *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadHelpInfo(
//     IN PHELPINFO Address
//     )
//
//--

#define ProbeAndReadHelpInfo(Address)                         \
    (((Address) >= (HELPINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile HELPINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile HELPINFO *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadDrawItemStruct(
//     IN PDRAWITEMSTRUCT Address
//     )
//
//--

#define ProbeAndReadDrawItemStruct(Address)                         \
    (((Address) >= (DRAWITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DRAWITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile DRAWITEMSTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadHookInfo(
//     IN PDEBUGHOOKINFO Address
//     )
//
//--

#define ProbeAndReadHookInfo(Address)                              \
    (((Address) >= (DEBUGHOOKINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DEBUGHOOKINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile DEBUGHOOKINFO *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCBTActivateStruct(
//     IN PCBTACTIVATESTRUCT Address
//     )
//
//--

#define ProbeAndReadCBTActivateStruct(Address)                         \
    (((Address) >= (CBTACTIVATESTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CBTACTIVATESTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile CBTACTIVATESTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadKbdHook(
//     IN PKBDHOOKSTRUCT Address
//     )
//
//--

#define ProbeAndReadKbdHook(Address)                               \
    (((Address) >= (KBDLLHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile KBDLLHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile KBDLLHOOKSTRUCT *)(Address)))
//++
//
// BOOLEAN
// ProbeAndReadMsllHook(
//     IN PMSLLHOOKSTRUCT Address
//     )
//
//--

#define ProbeAndReadMsllHook(Address)                               \
    (((Address) >= (MSLLHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MSLLHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile MSLLHOOKSTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadMouseHook(
//     IN PMOUSEHOOKSTRUCTEX Address
//     )
//
//--

#define ProbeAndReadMouseHook(Address)                               \
    (((Address) >= (MOUSEHOOKSTRUCTEX * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MOUSEHOOKSTRUCTEX * const)MM_USER_PROBE_ADDRESS) : (*(volatile MOUSEHOOKSTRUCTEX *)(Address)))


#ifdef REDIRECTION

//++
//
// BOOLEAN
// ProbeAndReadHTHook(
//     IN PHTHOOKSTRUCT Address
//     )
//
//--

#define ProbeAndReadHTHook(Address)                               \
    (((Address) >= (HTHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile HTHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile HTHOOKSTRUCT *)(Address)))

#endif // REDIRECTION

//++
//
// BOOLEAN
// ProbeAndReadCBTCreateStruct(
//     IN PCBT_CREATEWND Address
//     )
//
//--

#define ProbeAndReadCBTCreateStruct(Address)                       \
    (((Address) >= (CBT_CREATEWND * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CBT_CREATEWND * const)MM_USER_PROBE_ADDRESS) : (*(volatile CBT_CREATEWND *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadTrackMouseEvent(
//     IN LPTRACKMOUSEEVENT Address
//     )
//
//--

#define ProbeAndReadTrackMouseEvent(Address) \
    (((Address) >= (TRACKMOUSEEVENT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile TRACKMOUSEEVENT * const)MM_USER_PROBE_ADDRESS) : (*(volatile TRACKMOUSEEVENT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadWindowPos(
//     IN PWINDOWPOS Address
//     )
//
//--

#define ProbeAndReadWindowPos(Address) \
    (((Address) >= (WINDOWPOS * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile WINDOWPOS * const)MM_USER_PROBE_ADDRESS) : (*(volatile WINDOWPOS *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCursorFind(
//     IN PCURSORFIND Address
//     )
//
//--

#define ProbeAndReadCursorFind(Address) \
    (((Address) >= (CURSORFIND * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CURSORFIND * const)MM_USER_PROBE_ADDRESS) : (*(volatile CURSORFIND *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadSetClipBData(
//     IN PSETCLIPBDATA Address
//     )
//
//--

#define ProbeAndReadSetClipBData(Address) \
    (((Address) >= (SETCLIPBDATA * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile SETCLIPBDATA * const)MM_USER_PROBE_ADDRESS) : (*(volatile SETCLIPBDATA *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadBroadcastSystemMsgParams(
//     IN LPBROADCASTSYSTEMMSGPARAMS Address
//     )
//
//--

#define ProbeAndReadBroadcastSystemMsgParams(Address) \
    (((Address) >= (BROADCASTSYSTEMMSGPARAMS * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile BROADCASTSYSTEMMSGPARAMS * const)MM_USER_PROBE_ADDRESS) : (*(volatile BROADCASTSYSTEMMSGPARAMS *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCursorData(
//     IN PCURSORDATA Address
//     )
//
//--

#define ProbeAndReadCursorData(Address) \
    (((Address) >= (CURSORDATA * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CURSORDATA * const)MM_USER_PROBE_ADDRESS) : (*(volatile CURSORDATA *)(Address)))

//++
//
// BOOLEAN
// ProbeForReadUnicodeStringBuffer(
//     IN UNICODE_STRING String
//     )
//
//--

#if defined(_X86_)
#define ProbeForReadUnicodeStringBuffer(String)                                                          \
    if (((ULONG_PTR)((String).Buffer) & (sizeof(BYTE) - 1)) != 0) {                                   \
        ExRaiseDatatypeMisalignment();                                                            \
    } else if ((((ULONG_PTR)((String).Buffer) + ((String).Length) + sizeof(UNICODE_NULL)) < (ULONG_PTR)((String).Buffer)) ||     \
               (((ULONG_PTR)((String).Buffer) + ((String).Length) + sizeof(UNICODE_NULL)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) { \
        ExRaiseAccessViolation();                                                                 \
    } else if (((String).Length) > ((String).MaximumLength)) {                                    \
        ExRaiseAccessViolation();                                                                 \
    }
#else
#define ProbeForReadUnicodeStringBuffer(String)                                                          \
    if (((ULONG_PTR)((String).Buffer) & (sizeof(WCHAR) - 1)) != 0) {                                  \
        ExRaiseDatatypeMisalignment();                                                            \
    } else if ((((ULONG_PTR)((String).Buffer) + ((String).Length) + sizeof(UNICODE_NULL)) < (ULONG_PTR)((String).Buffer)) ||     \
               (((ULONG_PTR)((String).Buffer) + ((String).Length) + sizeof(UNICODE_NULL)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) { \
        ExRaiseAccessViolation();                                                                 \
    } else if (((String).Length) > ((String).MaximumLength)) {                                    \
        ExRaiseAccessViolation();                                                                 \
    }
#endif

#if defined(_X86_)
#define ProbeForReadUnicodeStringFullBuffer(String)                                                          \
    if (((ULONG_PTR)((String).Buffer) & (sizeof(BYTE) - 1)) != 0) {                                   \
        ExRaiseDatatypeMisalignment();                                                            \
    } else if ((((ULONG_PTR)((String).Buffer) + ((String).MaximumLength)) < (ULONG_PTR)((String).Buffer)) ||     \
               (((ULONG_PTR)((String).Buffer) + ((String).MaximumLength)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) { \
        ExRaiseAccessViolation();                                                                 \
    } else if (((String).Length) > ((String).MaximumLength)) {                                    \
        ExRaiseAccessViolation();                                                                 \
    }
#else
#define ProbeForReadUnicodeStringFullBuffer(String)                                                          \
    if (((ULONG_PTR)((String).Buffer) & (sizeof(WCHAR) - 1)) != 0) {                                  \
        ExRaiseDatatypeMisalignment();                                                            \
    } else if ((((ULONG_PTR)((String).Buffer) + ((String).MaximumLength)) < (ULONG_PTR)((String).Buffer)) ||     \
               (((ULONG_PTR)((String).Buffer) + ((String).MaximumLength)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) { \
        ExRaiseAccessViolation();                                                                 \
    } else if (((String).Length) > ((String).MaximumLength)) {                                    \
        ExRaiseAccessViolation();                                                                 \
    }
#endif

//++
//
// BOOLEAN
// ProbeForReadUnicodeStringBufferOrId(
//     IN UNICODE_STRING String
//     )
//
//--

#define ProbeForReadUnicodeStringBufferOrId(String) \
    if (IS_PTR((String).Buffer)) {           \
        ProbeForReadUnicodeStringBuffer(String);    \
    }

    //++
    //
    // BOOLEAN
    // ProbeAndReadCandidateForm(
    //     IN PCANDIDATEFORM Address
    //     )
    //
    //--

    #define ProbeAndReadCandidateForm(Address) \
        (((Address) >= (CANDIDATEFORM * const)MM_USER_PROBE_ADDRESS) ? \
            (*(volatile CANDIDATEFORM * const)MM_USER_PROBE_ADDRESS) : (*(volatile CANDIDATEFORM *)(Address)))

    //++
    //
    // BOOLEAN
    // ProbeAndReadCompositionForm(
    //     IN PCANDIDATEFORM Address
    //     )
    //
    //--

    #define ProbeAndReadCompositionForm(Address) \
        (((Address) >= (COMPOSITIONFORM * const)MM_USER_PROBE_ADDRESS) ? \
            (*(volatile COMPOSITIONFORM * const)MM_USER_PROBE_ADDRESS) : (*(volatile COMPOSITIONFORM *)(Address)))

    //++
    //
    // BOOLEAN
    // ProbeAndReadLogFontW(
    //     IN PLOGFONTA Address
    //     )
    //
    //--

    #define ProbeAndReadLogFontW(Address) \
        (((Address) >= (LOGFONTW * const)MM_USER_PROBE_ADDRESS) ? \
            (*(volatile LOGFONTW * const)MM_USER_PROBE_ADDRESS) : (*(volatile LOGFONTW *)(Address)))


//++
//
// VOID
// ProbeForWritePoint(
//     IN PPOINT Address
//     )
//
//--

#define ProbeForWritePoint(Address) {                                        \
    if ((Address) >= (POINT * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile POINT *)(Address) = *(volatile POINT *)(Address);             \
}

//++
//
// VOID
// ProbeForWriteRect(
//     IN PRECT Address
//     )
//
//--

#define ProbeForWriteRect(Address) {                                         \
    if ((Address) >= (RECT * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile RECT *)(Address) = *(volatile RECT *)(Address);               \
}

//++
//
// VOID
// ProbeForWriteMessage(
//     IN PMSG Address
//     )
//
//--

#define ProbeForWriteMessage(Address) {                                      \
    if ((Address) >= (MSG * const)MM_USER_PROBE_ADDRESS) {                   \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile MSG *)(Address) = *(volatile MSG *)(Address);                 \
}

//++
//
// VOID
// ProbeForWritePaintStruct(
//     IN PPAINTSTRUCT Address
//     )
//
//--

#define ProbeForWritePaintStruct(Address) {                                  \
    if ((Address) >= (PAINTSTRUCT * const)MM_USER_PROBE_ADDRESS) {           \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile PAINTSTRUCT *)(Address) = *(volatile PAINTSTRUCT *)(Address); \
}

//++
//
// VOID
// ProbeForWriteDropStruct(
//     IN PDROPSTRUCT Address
//     )
//
//--

#define ProbeForWriteDropStruct(Address) {                                   \
    if ((Address) >= (DROPSTRUCT * const)MM_USER_PROBE_ADDRESS) {            \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile DROPSTRUCT *)(Address) = *(volatile DROPSTRUCT *)(Address);   \
}

//++
//
// VOID
// ProbeForWriteScrollInfo(
//     IN PSCROLLINFO Address
//     )
//
//--

#define ProbeForWriteScrollInfo(Address) {                                   \
    if ((Address) >= (SCROLLINFO * const)MM_USER_PROBE_ADDRESS) {            \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile SCROLLINFO *)(Address) = *(volatile SCROLLINFO *)(Address);   \
}

//++
//
// VOID
// ProbeForWriteStyleStruct(
//     IN PSTYLESTRUCT Address
//     )
//
//--

#define ProbeForWriteStyleStruct(Address) {                                  \
    if ((Address) >= (STYLESTRUCT * const)MM_USER_PROBE_ADDRESS) {           \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile STYLESTRUCT *)(Address) = *(volatile STYLESTRUCT *)(Address); \
}

//++
//
// VOID
// ProbeForWriteMeasureItemStruct(
//     IN PMEASUREITEMSTRUCT Address
//     )
//
//--

#define ProbeForWriteMeasureItemStruct(Address) {                                       \
    if ((Address) >= (MEASUREITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                             \
    }                                                                                   \
                                                                                        \
    *(volatile MEASUREITEMSTRUCT *)(Address) = *(volatile MEASUREITEMSTRUCT *)(Address);\
}

//++
//
// VOID
// ProbeForWriteCreateStruct(
//     IN PCREATESTRUCTW Address
//     )
//
//--

#define ProbeForWriteCreateStruct(Address) {                                    \
    if ((Address) >= (CREATESTRUCTW * const)MM_USER_PROBE_ADDRESS) {            \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                     \
    }                                                                           \
                                                                                \
    *(volatile CREATESTRUCTW *)(Address) = *(volatile CREATESTRUCTW *)(Address);\
}

//++
//
// VOID
// ProbeForWriteEvent(
//     IN PEVENTMSGMSG Address
//     )
//
//--

#define ProbeForWriteEvent(Address) {                                        \
    if ((Address) >= (EVENTMSG * const)MM_USER_PROBE_ADDRESS) {              \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile EVENTMSG *)(Address) = *(volatile EVENTMSG *)(Address);       \
}

//++
//
// VOID
// ProbeForWriteWindowPlacement(
//     IN PWINDOWPLACEMENT Address
//     )
//
//--

#define ProbeForWriteWindowPlacement(Address) {                                     \
    if ((Address) >= (WINDOWPLACEMENT * const)MM_USER_PROBE_ADDRESS) {              \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile WINDOWPLACEMENT *)(Address) = *(volatile WINDOWPLACEMENT *)(Address);\
}

//++
//
// VOID
// ProbeForWriteGetClipData(
//     IN PGETCLIPBDATA Address
//     )
//
//--

#define ProbeForWriteGetClipData(Address) {                                   \
    if ((Address) >= (GETCLIPBDATA * const)MM_USER_PROBE_ADDRESS) {           \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                         \
                                                                              \
    *(volatile GETCLIPBDATA *)(Address) = *(volatile GETCLIPBDATA *)(Address);\
}

//++
//
// VOUD
// ProbeForWriteBroadcastSystemMsgParams(
//     IN LPBROADCASTSYSTEMMSGPARAMS Address
//     )
//
//--

#define ProbeForWriteBroadcastSystemMsgParams(Address) {                                                \
    if ((Address) >= (BROADCASTSYSTEMMSGPARAMS * const)MM_USER_PROBE_ADDRESS) {                         \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                                             \
    }                                                                                                   \
                                                                                                        \
    *(volatile BROADCASTSYSTEMMSGPARAMS *)(Address) = *(volatile BROADCASTSYSTEMMSGPARAMS *)(Address);  \
}

//++
//
// VOID
// ProbeForWriteMDINextMenu(
//     IN PMDINEXTMENU Address
//     )
//
//--

#define ProbeForWriteMDINextMenu(Address) {                                  \
    if ((Address) >= (MDINEXTMENU * const)MM_USER_PROBE_ADDRESS) {           \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile MDINEXTMENU *)(Address) = *(volatile MDINEXTMENU *)(Address); \
}

//++
//
// VOID
// ProbeForWritePoint5(
//     IN PPOINT5 Address
//     )
//
//--

#define ProbeForWritePoint5(Address) {                                     \
    if ((Address) >= (POINT5 * const)MM_USER_PROBE_ADDRESS) {              \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile POINT5 *)(Address) = *(volatile POINT5 *)(Address);\
}

//++
//
// VOID
// ProbeForWriteNCCalcSize(
//     IN PNCCALCSIZE_PARAMS Address
//     )
//
//--

#define ProbeForWriteNCCalcSize(Address) {                                     \
    if ((Address) >= (NCCALCSIZE_PARAMS * const)MM_USER_PROBE_ADDRESS) {              \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile NCCALCSIZE_PARAMS *)(Address) = *(volatile NCCALCSIZE_PARAMS *)(Address);\
}

//++
//
// VOID
// ProbeForWriteWindowPos(
//     IN PWINDOWPOS Address
//     )
//
//--

#define ProbeForWriteWindowPos(Address) {                                     \
    if ((Address) >= (WINDOWPOS * const)MM_USER_PROBE_ADDRESS) {              \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile WINDOWPOS *)(Address) = *(volatile WINDOWPOS *)(Address);\
}

#define ProbeForWriteComboBoxInfo(Address) {                                        \
    if ((Address) >= (COMBOBOXINFO * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile COMBOBOXINFO *)(Address) = *(volatile COMBOBOXINFO *)(Address);      \
}

#define ProbeForWriteScrollBarInfo(Address) {                                       \
    if ((Address) >= (SCROLLBARINFO * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile SCROLLBARINFO *)(Address) = *(volatile SCROLLBARINFO *)(Address);    \
}


    //++
    //
    // VOID
    // ProbeForWriteCandidateForm(
    //     IN PCANDIDATEFORM Address
    //     )
    //
    //--

    #define ProbeForWriteCandidateForm(Address) {                                     \
        if ((Address) >= (CANDIDATEFORM * const)MM_USER_PROBE_ADDRESS) {              \
            *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                       \
        }                                                                             \
                                                                                      \
        *(volatile CANDIDATEFORM *)(Address) = *(volatile CANDIDATEFORM *)(Address);  \
    }

    //++
    //
    // VOID
    // ProbeForWriteCompositionForm(
    //     IN PCOMPOSITIONFORM Address
    //     )
    //
    //--

    #define ProbeForWriteCompositionForm(Address) {                                     \
        if ((Address) >= (COMPOSITIONFORM * const)MM_USER_PROBE_ADDRESS) {              \
            *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
        }                                                                               \
                                                                                        \
        *(volatile COMPOSITIONFORM *)(Address) = *(volatile COMPOSITIONFORM *)(Address);\
    }

    //++
    //
    // VOID
    // ProbeForWriteLogFontW(
    //     IN PLOGFONTW Address
    //     )
    //
    //--

    #define ProbeForWriteLogFontW(Address) {                                   \
        if ((Address) >= (LOGFONTW * const)MM_USER_PROBE_ADDRESS) {            \
            *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                \
        }                                                                      \
                                                                               \
        *(volatile LOGFONTW *)(Address) = *(volatile LOGFONTW *)(Address);     \
    }

//++
//
// VOID
// ProbeForWriteReconvertString(IN PRECONVERTSTRING Address)
//
//--

#define ProbeForWriteReconvertString(Address) { \
    if ((Address) >= (RECONVERTSTRING* const)MM_USER_PROBE_ADDRESS) {           \
        *(volatile ULONG* const)MM_USER_PROBE_ADDRESS = 0;                      \
    }                                                                           \
                                                                                \
    *(volatile RECONVERTSTRING*)(Address) = *(volatile RECONVERTSTRING*)(Address); \
    *((volatile BYTE*)(Address) + (Address)->dwSize) = *((volatile BYTE*)(Address) + (Address)->dwSize); \
}

#define ProbeForReadReconvertString(pReconv) \
    ProbeForRead((pReconv), (pReconv)->dwSize, 1)


//++
//
// VOID
// ProbeForWriteImeCharPosition(IN LPPrivateIMECHARPOSITION Address)
//
//--

#define ProbeForWriteImeCharPosition(Address) { \
    if ((Address) >= (PrivateIMECHARPOSITION* const)MM_USER_PROBE_ADDRESS) {    \
        *(volatile ULONG* const)MM_USER_PROBE_ADDRESS = 0;                      \
    }                                                                           \
                                                                                \
    *(volatile PrivateIMECHARPOSITION*)(Address) = *(volatile PrivateIMECHARPOSITION*)(Address); \
}



//++
//
// VOID
// ProbeAndReadMenuGetObjectInfo(
//     IN PMENUGETOBJECTINFO Address
//     )
//
//--

#define ProbeAndReadMenuGetObjectInfo(Address) \
    (((Address) >= (MENUGETOBJECTINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MENUGETOBJECTINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile MENUGETOBJECTINFO *)(Address)))


/*
 * This macro makes sure an object is thread locked. DEBUG only.
 */
#if DBG
    VOID CheckLock(PVOID pobj);
#else // DBG
    #define CheckLock(p)
#endif // DBG

/*
 * Debug macros
 */
#if DBG

    #define TRACE_INIT(str)    { if (TraceInitialization > 0) {  KdPrint(str); }}
    #define TRACE_SWITCH(str)  { if (TraceFullscreenSwitch > 0)  {  KdPrint(str); }}

    extern PCSZ apszSimpleCallNames[];

    #define TRACE(s)            TAGMSG2(DBGTAG_StubReturn, "%s, retval = %x", (s), retval)
    #define TRACEVOID(s)        TAGMSG1(DBGTAG_StubReturn, "%s", (s))

    #define TRACETHUNK(t)                                                       \
                TAGMSG3(DBGTAG_StubThunk,                                       \
                        "Thunk %s, %s(%s)",                                     \
                        (t),                                                    \
                        (xpfnProc >= FNID_START && xpfnProc <= FNID_END ?       \
                                gapszFNID[xpfnProc - FNID_START] : "Unknown"),  \
                        (msg >= WM_USER ? "WM_USER" : gapszMessage[msg]))

    #define TRACECALLBACK(s)    TAGMSG2(DBGTAG_StubCallback, "%s, retval = %x", (s), retval)

    #define TRACECALLBACKMSG(s)                                                         \
                TAGMSG4(DBGTAG_StubCallback,                                            \
                        "Callback %s, %s(%s), retval = %x",                             \
                        (s),                                                            \
                        (xpfnProc >= (PROC)FNID_START && xpfnProc <= (PROC)FNID_END ?   \
                            gapszFNID[(ULONG_PTR)xpfnProc - FNID_START] : "Unknown"),    \
                        (msg >= WM_USER ? "WM_USER" : gapszMessage[msg]),               \
                        retval)
#else // DBG

    #define TRACE_INIT(str) {}
    #define TRACE_SWITCH(str) {}
    #define TRACE(s)
    #define TRACEVOID(s)
    #define TRACETHUNK(t)
    #define TRACECALLBACK(t)
    #define TRACECALLBACKMSG(t)

#endif // DBG

/*
 * Statistics for performance counter
 */

typedef struct tagPERFINFO {
    LONG               lCount;
    LONG               lMaxCount;
    LONG               lTotalCount;
    SIZE_T             lSize;
} PERFHANDLEINFO, *PPERFHANDLEINFO;

typedef struct _HANDLEPAGE {
    ULONG_PTR iheLimit;    /* first handle index past the end of the page */
    ULONG_PTR iheFreeEven; /* first even free handle in the page -- window objects */
    ULONG_PTR iheFreeOdd;  /* first even odd handle in the page */
} HANDLEPAGE, *PHANDLEPAGE;


#if DBG || FRE_LOCK_RECORD
VOID  HMCleanUpHandleTable(VOID);
DWORD DbgDumpHandleTable(VOID);
#endif

BOOL     HMInitHandleTable(PVOID pBase);
PVOID    HMAllocObject(PTHREADINFO pti, PDESKTOP pdesk, BYTE btype, DWORD size);
BOOL     HMFreeObject(PVOID pobj);
BOOL     HMMarkObjectDestroy(PVOID pobj);
BOOL     HMDestroyObject(PVOID pobj);
PVOID FASTCALL HMAssignmentLock(PVOID *ppobj, PVOID pobj);
PVOID FASTCALL HMAssignmentUnlock(PVOID *ppobj);
void     HMDestroyUnlockedObject(PHE phe);

void     HMCleanupGrantedHandle(HANDLE h);

/*
 * Validation, handle mapping, etc.
 */
#define RevalidateHwnd(hwnd)   HMValidateHandleNoSecure(hwnd, TYPE_WINDOW)
#define RevalidateCatHwnd(hwnd)   HMValidateCatHandleNoSecure(hwnd, TYPE_WINDOW)

#define HtoPq(h)    ((PVOID)HMObjectFromHandle(h))
#define HtoPqCat(h)    ((PVOID)HMCatObjectFromHandle(h))
#define HtoP(h)     ((PVOID)HMObjectFromHandle(h))
#define HtoPCat(h)     ((PVOID)HMCatObjectFromHandle(h))
#define PW(hwnd)    ((PWND)HtoP(hwnd))
#define PWCat(hwnd)    ((PWND)HtoPCat(hwnd))
#define TID(pti)    HandleToUlong((pti) == NULL ? NULL : (PsGetThreadId((pti)->pEThread)))
#define TIDq(pti)   HandleToUlong(PsGetThreadId((pti)->pEThread))

/*
 * Assignment lock macro -> used for locking objects embedded in structures
 * and globals. Threadlocks used for locking objects across callbacks.
 */
#define Lock(ppobj, pobj) HMAssignmentLock((PVOID *)ppobj, (PVOID)pobj)
#define Unlock(ppobj)     HMAssignmentUnlock((PVOID *)ppobj)

PVOID HMUnlockObjectInternal(PVOID pobj);

#define HMUnlockObject(pobj) \
    ( (--((PHEAD)pobj)->cLockObj == 0) ? HMUnlockObjectInternal(pobj) : pobj )

VOID HMChangeOwnerThread(PVOID pobj, PTHREADINFO pti);
VOID HMChangeOwnerPheProcess(PHE phe, PTHREADINFO pti);
#define HMChangeOwnerProcess(pobj, pti) HMChangeOwnerPheProcess(HMPheFromObject(pobj), pti)

#if DBG
    VOID  HMLockObject(PVOID pobj);
    BOOL  HMRelocateLockRecord(PVOID ppobjOld, LONG_PTR cbDelta);
#else // DBG
    #define HMLockObject(p)     (((PHEAD)p)->cLockObj++)
#endif // DBG

#if DBG
    VOID ThreadLock(PVOID pobj, PTL ptl);
#else // DBG
    #define ThreadLock(_pobj_, _ptl_)          \
    {                                          \
        PTHREADINFO _pti_;                     \
        PVOID __pobj_ = (_pobj_);              \
                                               \
        _pti_ = PtiCurrent();                  \
        (_ptl_)->next = _pti_->ptl;            \
        _pti_->ptl = (_ptl_);                  \
        (_ptl_)->pobj = __pobj_;              \
        if (__pobj_ != NULL) {                \
            HMLockObject(__pobj_);            \
        }                                      \
    }
#endif // DBG

#if DBG
    #define ThreadLockAlways(_pobj_, _ptl_)    \
    {                                          \
        PVOID __pobj_ = (_pobj_);              \
        UserAssert(__pobj_ != NULL);          \
        ThreadLock(__pobj_, _ptl_);             \
    }
#else // DBG
    #define ThreadLockAlways(_pobj_, _ptl_)    \
    {                                          \
        PTHREADINFO _pti_;                     \
        PVOID __pobj_ = (_pobj_);              \
                                               \
        _pti_ = PtiCurrent();                  \
        (_ptl_)->next = _pti_->ptl;            \
        _pti_->ptl = (_ptl_);                  \
        (_ptl_)->pobj = __pobj_;              \
        HMLockObject(__pobj_);                \
    }
#endif // DBG

#if DBG
    #define ThreadLockNever(_ptl_)             \
    {                                          \
        ThreadLock(NULL, _ptl_);               \
    }
#else // DBG
    #define ThreadLockNever(_ptl_)             \
    {                                          \
        PTHREADINFO _pti_;                     \
                                               \
        _pti_ = PtiCurrent();                  \
        (_ptl_)->next = _pti_->ptl;            \
        _pti_->ptl = (_ptl_);                  \
        (_ptl_)->pobj = NULL;                  \
    }
#endif // DBG

#if DBG
    #define ThreadLockAlwaysWithPti(_pti_, _pobj_, _ptl_)  \
    {                                          \
        PVOID __pobj_ = (_pobj_);              \
        UserAssert(_pti_ == PtiCurrentShared());     \
        UserAssert(__pobj_ != NULL);          \
        ThreadLock(__pobj_, _ptl_);             \
    }
#else // DBG
    #define ThreadLockAlwaysWithPti(_pti_, _pobj_, _ptl_)  \
    {                                          \
        PVOID __pobj_ = (_pobj_);              \
        (_ptl_)->next = _pti_->ptl;            \
        _pti_->ptl = (_ptl_);                  \
        (_ptl_)->pobj = __pobj_;              \
        HMLockObject(__pobj_);                \
    }
#endif // DBG

#if DBG
    #define ThreadLockNeverWithPti(_pti_, _ptl_)    \
    {                                               \
        UserAssert(_pti_ == PtiCurrentShared());    \
        ThreadLock(NULL, _ptl_);                    \
    }
#else // DBG
    #define ThreadLockNeverWithPti(_pti_, _ptl_)    \
    {                                               \
        (_ptl_)->next = _pti_->ptl;                 \
        _pti_->ptl = (_ptl_);                       \
        (_ptl_)->pobj = NULL;                       \
    }
#endif // DBG

#if DBG
    #define ThreadLockWithPti(_pti_, _pobj_, _ptl_) \
    {                                               \
        PVOID __pobj_ = (_pobj_);              \
        UserAssert(_pti_ == PtiCurrentShared());    \
        ThreadLock(__pobj_, _ptl_);                  \
    }
#else // DBG
    #define ThreadLockWithPti(_pti_, _pobj_, _ptl_) \
    {                                               \
        PVOID __pobj_ = (_pobj_);              \
        (_ptl_)->next = _pti_->ptl;                 \
        _pti_->ptl = (_ptl_);                       \
        (_ptl_)->pobj = __pobj_;                   \
        if (__pobj_ != NULL) {                     \
            HMLockObject(__pobj_);                 \
        }                                           \
    }
#endif // DBG

#if DBG
    PVOID ThreadLockExchange(PVOID pobj, PTL ptl);
#else // DBG
    __inline PVOID ThreadLockExchange(PVOID pobj, PTL ptl)
    {
        PVOID   pobjOld;

        pobjOld = ptl->pobj;
        ptl->pobj = pobj;
        if (pobj) {
            HMLockObject(pobj);
        }

        if (pobjOld) {
            pobjOld = HMUnlockObject((PHEAD)pobjOld);
        }

        return pobjOld;
    }
#endif // DBG

#if DBG
    #define ThreadLockExchangeAlways(_pobj_, _ptl_)    \
    {                                                  \
        PVOID __pobj_ = (_pobj_);              \
        UserAssert(__pobj_ != NULL);                  \
        ThreadLockExchange(__pobj_, _ptl_);             \
    }
#else // DBG
    __inline PVOID ThreadLockExchangeAlways(PVOID pobj, PTL ptl)
    {
        PVOID   pobjOld;

        pobjOld = ptl->pobj;
        ptl->pobj = pobj;
        HMLockObject(pobj);
        if (pobjOld) {
            pobjOld = HMUnlockObject((PHEAD)pobjOld);
        }

        return pobjOld;
    }
#endif // DBG

#if DBG
    PVOID ThreadUnlock1(PTL ptl);
    #define ThreadUnlock(ptl) ThreadUnlock1(ptl)
#else // DBG
    PVOID ThreadUnlock1(VOID);
    #define ThreadUnlock(ptl) ThreadUnlock1()
#endif // DBG

/*
 * Define this only if you want to track down lock/unlock mismatches
 * for desktop objects.
 */
#ifdef LOGDESKTOPLOCKS

/*
 * This is the structure used by the desktop logging stuff.
 */
typedef struct tagLogD {
    WORD   tag;         // tag
    WORD   type;        // lock | unlock
    ULONG_PTR extra;    // extra information to identify the lock/unlock
    PVOID  trace[6];    // stack trace
} LogD, *PLogD;

/*
 * Tags for LOCK/UNLOCK REFERENCE/DEREFERENCE calls for desktop objects.
 */

#define LDU_CLS_DESKPARENT1                 1
#define LDL_CLS_DESKPARENT1                 2

#define LDU_CLS_DESKPARENT2                 3
#define LDL_CLS_DESKPARENT2                 5

#define LDU_FN_DESTROYCLASS                 6
#define LDL_FN_DESTROYCLASS                 7

#define LDU_FN_DESTROYMENU                  8
#define LDL_FN_DESTROYMENU                  9

#define LDU_FN_DESTROYTHREADINFO            10
#define LDL_FN_DESTROYTHREADINFO            11

#define LDU_FN_DESTROYWINDOWSTATION         12
#define LDL_FN_DESTROYWINDOWSTATION         13

#define LDU_DESKDISCONNECT                  14
#define LDL_DESKDISCONNECT                  15

#define LDU_DESK_DESKNEXT                   16
#define LDL_DESK_DESKNEXT1                  17

#define LDU_OBJ_DESK                        18
#define LDL_OBJ_DESK                        19
#define LDL_MOTHERDESK_DESK1                20

#define LDL_PTI_DESK                        21
#define LDL_DT_DESK                         23

#define LDU_PTI_DESK                        24

#define LDU_PPI_DESKSTARTUP1                26
#define LDU_PPI_DESKSTARTUP2                27
#define LDU_PPI_DESKSTARTUP3                28
#define LDL_PPI_DESKSTARTUP1                29
#define LDL_PPI_DESKSTARTUP2                30

#define LDU_DESKLOGON                       31
#define LDL_DESKLOGON                       32

#define LDUT_FN_FREEWINDOW                  33
#define LDLT_FN_FREEWINDOW                  34

#define LDUT_FN_DESKTOPTHREAD_DESK          35
#define LDLT_FN_DESKTOPTHREAD_DESK          36

#define LDUT_FN_DESKTOPTHREAD_DESKTEMP      37
#define LDLT_FN_DESKTOPTHREAD_DESKTEMP      38

#define LDUT_FN_SETDESKTOP                  39
#define LDLT_FN_SETDESKTOP                  40

#define LDUT_FN_NTUSERSWITCHDESKTOP         41
#define LDLT_FN_NTUSERSWITCHDESKTOP         42

#define LDUT_FN_SENDMESSAGEBSM1             43
#define LDUT_FN_SENDMESSAGEBSM2             44
#define LDLT_FN_SENDMESSAGEBSM              45

#define LDUT_FN_SYSTEMBROADCASTMESSAGE      46
#define LDLT_FN_SYSTEMBROADCASTMESSAGE      47

#define LDUT_FN_CTXREDRAWSCREEN             48
#define LDLT_FN_CTXREDRAWSCREEN             49

#define LDUT_FN_CTXDISABLESCREEN            50
#define LDLT_FN_CTXDISABLESCREEN            51

#define LD_DEREF_FN_CREATEDESKTOP1          52
#define LD_DEREF_FN_CREATEDESKTOP2          53
#define LD_DEREF_FN_CREATEDESKTOP3          54
#define LD_REF_FN_CREATEDESKTOP             55

#define LD_DEREF_FN_OPENDESKTOP             56
#define LD_REF_FN_OPENDESKTOP               57

#define LD_DEREF_FN_SETDESKTOP              58
#define LD_REF_FN_SETDESKTOP                59

#define LD_DEREF_FN_GETTHREADDESKTOP        60
#define LD_REF_FN_GETTHREADDESKTOP          61

#define LD_DEREF_FN_CLOSEDESKTOP1           62
#define LD_DEREF_FN_CLOSEDESKTOP2           63
#define LD_REF_FN_CLOSEDESKTOP              64

#define LD_DEREF_FN_RESOLVEDESKTOP          65
#define LD_REF_FN_RESOLVEDESKTOP            66

#define LD_DEREF_VALIDATE_HDESK1            67
#define LD_DEREF_VALIDATE_HDESK2            68
#define LD_DEREF_VALIDATE_HDESK3            69
#define LD_DEREF_VALIDATE_HDESK4            70
#define LDL_VALIDATE_HDESK                  71

#define LDUT_FN_CREATETHREADINFO1           72
#define LDUT_FN_CREATETHREADINFO2           73
#define LDLT_FN_CREATETHREADINFO            74

#define LD_DEREF_FN_SETCSRSSTHREADDESKTOP1  75
#define LD_DEREF_FN_SETCSRSSTHREADDESKTOP2  76
#define LD_REF_FN_SETCSRSSTHREADDESKTOP     77

#define LD_DEREF_FN_CONSOLECONTROL1         78
#define LD_REF_FN_CONSOLECONTROL1           79

#define LD_DEREF_FN_CONSOLECONTROL2         80
#define LD_REF_FN_CONSOLECONTROL2           81

#define LD_DEREF_FN_GETUSEROBJECTINFORMATION 82
#define LD_REF_FN_GETUSEROBJECTINFORMATION   83

#define LD_DEREF_FN_SETUSEROBJECTINFORMATION 84
#define LD_REF_FN_SETUSEROBJECTINFORMATION   85

#define LD_DEREF_FN_CREATEWINDOWSTATION     86
#define LD_REF_FN_CREATEWINDOWSTATION       87

#define LDL_TERM_DESKDESTROY1               88
#define LDL_TERM_DESKDESTROY2               89

#define LDL_MOTHERDESK_DESK2                92

#define LDL_WINSTA_DESKLIST2                93
#define LDL_WINSTA_DESKLIST1                94

#define LDL_DESKRITINPUT                    95
#define LDU_DESKRITINPUT                    96

#define LD_DEREF_FN_2CREATEDESKTOP          97

#define LDL_DESK_DESKNEXT2                  98

#define LDL_DESKSHOULDBEFOREGROUND1         99
#define LDL_DESKSHOULDBEFOREGROUND2         100
#define LDL_DESKSHOULDBEFOREGROUND3         101

#define LDL_HOOK_DESK                       102
#define LDU_HOOK_DESK                       103

#define LDU_DESKSHOULDBEFOREGROUND          105

#define LDU_MOTHERDESK_DESK                 106

void LogDesktop(PDESKTOP pdesk, DWORD tag, BOOL bLock, ULONG_PTR extra);

#else
    #define LogDesktop(pdesk, tag, bLock, extra)
#endif // LOGDESKTOPLOCKS

/*
 * Routines for referencing and assigning kernel objects.
 */
#ifdef LOGDESKTOPLOCKS
    VOID LockObjectAssignment(PVOID*, PVOID, DWORD, ULONG_PTR);
    VOID UnlockObjectAssignment(PVOID*, DWORD, ULONG_PTR);
#else
    VOID LockObjectAssignment(PVOID*, PVOID);
    VOID UnlockObjectAssignment(PVOID*);
#endif

VOID UserDereferenceObject(PVOID pobj);

#define ThreadLockObject(pobj, ptl)                                                 \
{                                                                                   \
    UserAssert(!(PpiCurrent()->W32PF_Flags & W32PF_TERMINATED));                    \
    UserAssert(pobj == NULL || OBJECT_TO_OBJECT_HEADER(pobj)->PointerCount != 0);   \
    PushW32ThreadLock(pobj, ptl, UserDereferenceObject);                            \
    if (pobj != NULL) {                                                             \
        ObReferenceObject(pobj);                                                    \
    }                                                                               \
}

#define ThreadLockExchangeObject(pobj, ptl)                                         \
{                                                                                   \
    UserAssert(!(PpiCurrent()->W32PF_Flags & W32PF_TERMINATED));                    \
    UserAssert(pobj == NULL || OBJECT_TO_OBJECT_HEADER(pobj)->PointerCount != 0);   \
    if (pobj != NULL) {                                                             \
        ObReferenceObject(pobj);                                                    \
    }                                                                               \
    ExchangeW32ThreadLock(pobj, ptl);                                               \
}

#define ThreadUnlockObject(ptl)                                                     \
{                                                                                   \
    PopAndFreeW32ThreadLock(ptl);                                                   \
}                                                                                   \

#ifdef LOGDESKTOPLOCKS

    #define UnlockWinSta(ppwinsta) \
            UnlockObjectAssignment(ppwinsta, 0, 0)

    #define LockWinSta(ppwinsta, pwinsta) \
    {                                                                                           \
        if (pwinsta != NULL)                                                                    \
        {                                                                                       \
            UserAssert(OBJECT_TO_OBJECT_HEADER(pwinsta)->Type == *ExWindowStationObjectType);   \
        }                                                                                       \
        LockObjectAssignment(ppwinsta, pwinsta, 0, 0);                                                \
    }

    #define LockDesktop(ppdesk, pdesk, tag, extra) \
    {                                                                                           \
        if (pdesk != NULL)                                                                      \
        {                                                                                       \
            UserAssert(OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);           \
        }                                                                                       \
        LockObjectAssignment(ppdesk, pdesk, tag, extra);                                        \
    }

    #define UnlockDesktop(ppdesk, tag, extra) \
            UnlockObjectAssignment(ppdesk, tag, extra)

    #define ThreadLockDesktop(pti, pdesk, ptl, tag) \
    {                                                                                           \
        UserAssert(pdesk == NULL || OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);\
        ThreadLockObject(pdesk, ptl);                                                           \
        LogDesktop(pdesk, tag, TRUE, (ULONG_PTR)PtiCurrent());                                      \
    }

    #define ThreadLockExchangeDesktop(pti, pdesk, ptl, tag) \
    {                                                                                           \
        UserAssert(pdesk == NULL || OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);\
        ThreadLockExchangeObject(pdesk, ptl);                                                   \
        LogDesktop(pdesk, tag, TRUE, (ULONG_PTR)PtiCurrent());                                  \
    }

    #define ThreadUnlockDesktop(pti, ptl, tag)                                                  \
    {                                                                                           \
        LogDesktop((PDESKTOP)(((PTL)ptl)->pobj), tag, FALSE, (ULONG_PTR)PtiCurrent());                \
        ThreadUnlockObject(ptl);                                                                \
    }

#else

    #define UnlockWinSta(ppwinsta) \
            UnlockObjectAssignment(ppwinsta)

    #define LockWinSta(ppwinsta, pwinsta) \
    {                                                                                           \
        if (pwinsta != NULL)                                                                    \
        {                                                                                       \
            UserAssert(OBJECT_TO_OBJECT_HEADER(pwinsta)->Type == *ExWindowStationObjectType);   \
        }                                                                                       \
        LockObjectAssignment(ppwinsta, pwinsta);                                                \
    }

    #define LockDesktop(ppdesk, pdesk, tag, extra) \
    {                                                                                           \
        if (pdesk != NULL)                                                                      \
        {                                                                                       \
            UserAssert(OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);           \
        }                                                                                       \
        LockObjectAssignment(ppdesk, pdesk);                                                    \
    }

    #define UnlockDesktop(ppdesk, tag, extra) \
            UnlockObjectAssignment(ppdesk)

    #define ThreadLockDesktop(pti, pdesk, ptl, tag) \
    {                                                                                           \
        UserAssert(pdesk == NULL || OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);\
        ThreadLockObject(pdesk, ptl);                                                           \
    }

    #define ThreadLockExchangeDesktop(pti, pdesk, ptl, tag) \
    {                                                                                           \
        UserAssert(pdesk == NULL || OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);\
        ThreadLockExchangeObject(pdesk, ptl);                                                   \
    }

    #define ThreadUnlockDesktop(pti, ptl, tag) ThreadUnlockObject(ptl)

#endif // LOGDESKTOPLOCKS

#define ThreadLockWinSta(pti, pwinsta, ptl) \
{                                                                                           \
    UserAssert(pwinsta == NULL || OBJECT_TO_OBJECT_HEADER(pwinsta)->Type == *ExWindowStationObjectType);\
    ThreadLockObject(pwinsta, ptl);                                                         \
}

#define ThreadLockExchangeWinSta(pti, pwinsta, ptl) \
{                                                                                           \
    UserAssert(pwinsta == NULL || OBJECT_TO_OBJECT_HEADER(pwinsta)->Type == *ExWindowStationObjectType);\
    ThreadLockExchangeObject(pwinsta, ptl);                                                 \
}

#define _ThreadLockPti(pti, pobj, ptl) LockW32Thread((PW32THREAD)pobj, ptl)
#if DBG
#define ThreadLockPti(pti, pobj, ptl) \
{ \
    if ((pobj != NULL) \
            && (pobj->TIF_flags & TIF_INCLEANUP) \
            && (pobj != PtiCurrent())) { \
        RIPMSG1(RIP_ERROR, "ThreadLockPti: dead thread %#p", pobj); \
    } \
    _ThreadLockPti(pti, pobj, ptl); \
}
#else
#define ThreadLockPti(pti, pobj, ptl) \
{ \
    _ThreadLockPti(pti, pobj, ptl); \
}
#endif

#define ThreadLockExchangePti(pobj, ptl) LockExchangeW32Thread((PW32THREAD)pobj, ptl)

#define ThreadUnlockWinSta(pti, ptl) ThreadUnlockObject(ptl)
#define ThreadUnlockPti(pti, ptl) UnlockW32Thread(ptl)

/*
 * Macros for locking pool allocations
 */
#define ThreadLockPool(_pti_, _ppool_, _ptl_)  \
        PushW32ThreadLock(_ppool_, _ptl_, UserFreePool)

#define ThreadUnlockPool(_pti_, _ptl_)  \
        PopW32ThreadLock(_ptl_)

#define ThreadUnlockAndFreePool(_pti_, _ptl_)  \
        PopAndFreeAlwaysW32ThreadLock(_ptl_)

#define ThreadLockPoolCleanup(_pti_, _ppool_, _ptl_, _pfn_)  \
        PushW32ThreadLock(_ppool_, _ptl_, _pfn_)

#define ThreadUnlockPoolCleanup(_pti_, _ptl_)  \
        PopW32ThreadLock(_ptl_)

#define ThreadUnlockAndCleanupPool(_pti_, _ptl_)  \
        PopAndFreeAlwaysW32ThreadLock(_ptl_)

#define ThreadLockDesktopHandle(_pti, _ptl_, _hdesk_)   \
        PushW32ThreadLock(_hdesk_, _ptl_, CloseProtectedHandle)

#define ThreadUnlockDesktopHandle(_ptl_)   \
        PopAndFreeAlwaysW32ThreadLock(_ptl_)

void CleanupDecSFWLockCount(PVOID pIgnore);
#define ThreadLockSFWLockCount(_ptl_) \
        { \
            IncSFWLockCount(); \
            /* Pass a fake pObj or the cleanup function won't be called */ \
            PushW32ThreadLock(&guSFWLockCount, _ptl_, CleanupDecSFWLockCount); \
        }

#define ThreadUnlockSFWLockCount(_ptl_) \
    { \
        DecSFWLockCount(); \
        PopW32ThreadLock(_ptl_); \
    }

/*
 * special handle that signifies we have a rle bitmap for the wallpaper
 */
#define HBITMAP_RLE ((HBITMAP)0xffffffff)

typedef struct tagWPINFO {
    int xsize, ysize;
    PBITMAPINFO pbmi;
    PBYTE pdata;
    PBYTE pbmfh;
} WPINFO;

/*
 * Defines used by GetMouseMovePointsEx API
 */

#define MAX_MOUSEPOINTS 64

#define PREVPOINT(i)    \
    ((i == 0) ? (MAX_MOUSEPOINTS - 1) : ((i - 1) % MAX_MOUSEPOINTS))

#define NEXTPOINT(i)    \
    ((i + 1) % MAX_MOUSEPOINTS)

#define SAVEPOINT(xc, yc, _resX, _resY, t, e)                            \
{                                                                        \
    /*                                                                   \
     * (xc, yc) is the point and (resX, resY) is the resolution          \
     */                                                                  \
    gaptMouse[gptInd].x           = MAKELONG(LOWORD(xc), LOWORD(_resX)); \
    gaptMouse[gptInd].y           = MAKELONG(LOWORD(yc), LOWORD(_resY)); \
    gaptMouse[gptInd].time        = t;                                   \
    gaptMouse[gptInd].dwExtraInfo = e;                                   \
                                                                         \
    gptInd = NEXTPOINT(gptInd);                                          \
}


/*
 * Structure used for getting the stack traces for user critical section.
 */
#define MAX_STACK_CALLS 8

typedef struct tagCRITSTACK {
struct tagCRITSTACK* pNext;
    PETHREAD         thread;
    int              nFrames;
    PVOID            trace[MAX_STACK_CALLS];
} CRITSTACK, *PCRITSTACK;


/*
 * Macros for User Server and Raw Input Thread critical sections.
 */
#if DBG
    #define KeUserModeCallback(api, pIn, cb, pOut, pcb)    _KeUserModeCallback(api, pIn, cb, pOut, pcb);
    #define CheckCritIn()                _AssertCritIn()
    #define CheckDeviceInfoListCritIn()  _AssertDeviceInfoListCritIn()
    #define CheckCritInShared()          _AssertCritInShared()
    #define CheckCritOut()               _AssertCritOut()
    #define CheckDeviceInfoListCritOut() _AssertDeviceInfoListCritOut()

    void    BeginAtomicCheck();
    void    BeginAtomicDeviceInfoListCheck();
    void    EndAtomicCheck();
    void    EndAtomicDeviceInfoListCheck();
    #define BEGINATOMICCHECK()     BeginAtomicCheck();                              \
                                    { DWORD dwCritSecUseSave = gdwCritSecUseCount;

    #define ENDATOMICCHECK()        UserAssert(dwCritSecUseSave == gdwCritSecUseCount);  \
                                    } EndAtomicCheck();
    #define BEGINATOMICDEVICEINFOLISTCHECK() \
            BeginAtomicDeviceInfoListCheck(); \
            { DWORD dwDeviceInfoListCritSecUseSave = gdwDeviceInfoListCritSecUseCount;

    #define ENDATOMICDEVICEINFOLISTCHECK() \
            UserAssert(dwDeviceInfoListCritSecUseSave == gdwDeviceInfoListCritSecUseCount);  \
            } EndAtomicDeviceInfoListCheck();

    // Use this to jump/return out of scope of dwCritSecUseSave (eg: error handling)
    #define EXITATOMICCHECK()       UserAssert(dwCritSecUseSave == gdwCritSecUseCount);  \
                                    EndAtomicCheck();
    #define ISATOMICCHECK()         (gdwInAtomicOperation != 0)
    #define ISATOMICDEVICEINFOLISTCHECK() (gdwInAtomicDeviceInfoListOperation != 0)

#else // DBG
    #define CheckCritIn()
    #define CheckDeviceInfoListCritIn()
    #define CheckCritInShared()
    #define CheckCritOut()
    #define CheckDeviceInfoListCritOut()
    #define BEGINATOMICCHECK()
    #define BEGINATOMICDEVICEINFOLISTCHECK()
    #define BeginAtomicCheck()
    #define BeginAtomicDeviceInfoListCheck()
    #define ENDATOMICCHECK()
    #define ENDATOMICDEVICEINFOLISTCHECK()
    #define EndAtomicCheck()
    #define EndAtomicDeviceInfoListCheck()
    #define EXITATOMICCHECK()
    #define ISATOMICCHECK()
    #define ISATOMICDEVICEINFOLISTCHECK()
#endif // DBG


#define DIAGNOSE_IO 1
#ifdef DIAGNOSE_IO
ULONG MonotonicTick();
#define LOGTIME(gt) gt = MonotonicTick();
#else
#define LOGTIME(gt)
#endif

/*
 * #defines used for mouse/keyboard read buffer
 */
#define MAXIMUM_ITEMS_READ      10
#define NELEM_BUTTONQUEUE       16

/*
 * Number of times to retry reading a device after a read attempt fails
 */
#define MAXIMUM_READ_RETRIES 5

typedef struct tagGENERIC_DEVICE_INFO {
#ifdef GENERIC_INPUT
    HEAD                 head;
#endif
    struct tagDEVICEINFO *pNext;
    BYTE                 type;
    BYTE                 bFlags;
    USHORT               usActions;
    BYTE                 nRetryRead;
    UNICODE_STRING       ustrName;
    HANDLE               handle;
    PVOID                NotificationEntry;
    PKEVENT              pkeHidChangeCompleted; // wake RequestDeviceChange()
    IO_STATUS_BLOCK      iosb;
    NTSTATUS             ReadStatus;

#ifdef DIAGNOSE_IO
    HANDLE               OpenerProcess;
    NTSTATUS             OpenStatus;
    NTSTATUS             AttrStatus;
    ULONG                timeStartRead;     // tick before ZwReadFile
    ULONG                timeEndRead;       // tick after ZwReadFile
    int                  nReadsOutstanding; // ZwReadFile ++, consume data --
#endif

#ifdef PRERELEASE
    UINT                 fForcedDetach : 1; // Set if the device is forced detached from TS
#endif
} GENERIC_DEVICE_INFO, *PGENERIC_DEVICE_INFO;

// valuse for GENERIC_DEVICE_INFO.type
#define DEVICE_TYPE_MOUSE    0
#define DEVICE_TYPE_KEYBOARD 1
#ifdef GENERIC_INPUT
#define DEVICE_TYPE_HID      2
#define DEVICE_TYPE_MAX      2
#else
#define DEVICE_TYPE_MAX      1
#endif

// values for GENERIC_DEVICE_INFO.usActions and SignalDeviceChange()
#define GDIAF_ARRIVED         (USHORT)0x0001 // open & start reading
#define GDIAF_QUERYREMOVE     (USHORT)0x0002 // close the device
#define GDIAF_REMOVECANCELLED (USHORT)0x0004 // reopen the device
#define GDIAF_DEPARTED        (USHORT)0x0008 // close and free the device
#define GDIAF_IME_STATUS      (USHORT)0x0010 // ???
#define GDIAF_REFRESH_MOUSE   (USHORT)0x0020 // ???
#define GDIAF_FREEME          (USHORT)0x0080 // Request to Free the DeviceInfo
#define GDIAF_PNPWAITING      (USHORT)0x0100 // a PnP thread is waiting
#define GDIAF_RETRYREAD       (USHORT)0x0200 // Retry the read
#define GDIAF_RECONNECT       (USHORT)0x0400 // The session reconnected
#ifdef GENERIC_INPUT
#define GDIAF_STARTREAD       (USHORT)0x0800 // The device needs to be started
#define GDIAF_STOPREAD        (USHORT)0x1000 // The device needs to be stopped
#endif

// values for GENERIC_DEVICE_INFO.bFlags;
#define GDIF_NOTPNP         0x01 // Not a PnP device (eg: PS/2)
#define GDIF_READING        0x02 // Read may be pending (don't free DeviceInfo).
#if DIAGNOSE_IO
#define GDIF_READERMUSTFREE 0x04 // "Free Device" while read pending
#define GDIF_PNPMUSTFREE    0x08 // "Free Device" while PnP notification pending
#endif
#define GDIF_DBGREAD        0x10 // Verbose dbg output about this device

typedef struct tagMOUSE_DEVICE_INFO {    // DEVICE_TYPE_MOUSE
    MOUSE_ATTRIBUTES     Attr;
    MOUSE_INPUT_DATA     Data[MAXIMUM_ITEMS_READ];
} MOUSE_DEVICE_INFO, *PMOUSE_DEVICE_INFO;

#ifdef GENERIC_INPUT
#define INVALID_UNIT_ID     ((USHORT)0xffff)
#define INJECTED_UNIT_ID    ((USHORT)0xfffe)
#endif


typedef struct tagKEYBOARD_DEVICE_INFO { // DEVICE_TYPE_KEYBOARD
    KEYBOARD_ATTRIBUTES  Attr;
    KEYBOARD_ID_EX IdEx;
    KEYBOARD_INPUT_DATA  Data[MAXIMUM_ITEMS_READ];
} KEYBOARD_DEVICE_INFO, *PKEYBOARD_DEVICE_INFO;

#define GET_KEYBOARD_DEVINFO_ID(pDeviceInfo)        ((pDeviceInfo)->keyboard.IdEx)
#define GET_KEYBOARD_DEVINFO_TYPE(pDeviceInfo)      ((pDeviceInfo)->keyboard.IdEx.Type)
#define GET_KEYBOARD_DEVINFO_SUBTYPE(pDeviceInfo)   ((pDeviceInfo)->keyboard.IdEx.Subtype)


#ifdef GENERIC_INPUT
/*
 * HID Descriptor
 * allocated as a handle, type == TAG_HIDDESC
 */
typedef struct tagHIDDESC {
    IO_STATUS_BLOCK iob;

    PVOID pPreparsedData;   // the size is in hidCollectionInfo.DescriptorSize
    PVOID pInputBuffer;     // the size is in hidpCaps.

    HIDP_CAPS hidpCaps;
    HID_COLLECTION_INFORMATION hidCollectionInfo;
} HIDDESC, *PHIDDESC;

/*
 * HID Top Level Collection Information
 */
typedef struct tagHID_TLC_INFO {
    LIST_ENTRY link;
    // Toplevel collection
    USHORT usUsagePage;
    USHORT usUsage;
    /*
     * Reference counters
     */
    UINT cDevices;              // # of devices currently attached
    UINT cDirectRequest;        // Reference count of direct request to this device type (# of processes)
    UINT cUsagePageRequest;     // Reference count of UsagePage only request
    UINT cExcludeRequest;       // Reference count of Exclude request
    UINT cExcludeOrphaned;      // Orphaned count of Exclude request
#if defined(GI_SINK) && defined(LATER)
    UINT cSinkable;             // LATER...
#endif
} HID_TLC_INFO, *PHID_TLC_INFO;

/*
 * HID global PageOnly request
 */
typedef struct tagHID_PAGEONLY_REQUEST {
    LIST_ENTRY link;
    USHORT usUsagePage;
    UINT cRefCount;
#if defined(GI_SINK) && defined(LATER)
    UINT cSinkable;
#endif
} HID_PAGEONLY_REQUEST, *PHID_PAGEONLY_REQUEST;

/*
 * Global HID Request
 */
typedef struct tagHID_REQUEST_TABLE {
    /*
     * HID_TLC_INFO
     */
    LIST_ENTRY TLCInfoList;
    /*
     * HID_PAGEONLY_REQUEST
     */
    LIST_ENTRY UsagePageList;

#ifdef GI_SINK
    /*
     * PROCESS_HID_TABLE
     */
    LIST_ENTRY ProcessRequestList;
#endif
} HID_REQUEST_TABLE, *PHID_REQUEST_TABLE;

extern HID_REQUEST_TABLE gHidRequestTable;
extern int gnHidProcess;

/*
 * Per process hid device request list
 */
typedef struct tagPROCESS_HID_REQUEST {
    LIST_ENTRY link;
    // Toplevel collection
    USHORT usUsagePage;
    USHORT usUsage;
#ifdef GI_SINK
    BOOL fSinkable : 1;
#endif
    BOOL fExclusiveOrphaned : 1;
    union {
        PHID_TLC_INFO    pTLCInfo;
        PHID_PAGEONLY_REQUEST   pPORequest;
        LPVOID                  ptr;
    };
    PWND spwndTarget;
} PROCESS_HID_REQUEST, *PPROCESS_HID_REQUEST;

/*
 * Per-process HID request table
 */
typedef struct tagPROCESS_HID_TABLE {
    /*
     * Link to the next process HID table.
     */
    LIST_ENTRY link;

    /*
     * Those LIST_ENTRYs point PROCESS_HID_REQUEST
     */
    LIST_ENTRY InclusionList;
    LIST_ENTRY UsagePageList;
    LIST_ENTRY ExclusionList;

    /*
     * Target windows for the legacy devices
     */
    PWND spwndTargetMouse;
    PWND spwndTargetKbd;

#ifdef GI_SINK
    /*
     * Number of Sinks in this process.
     * N.b. this does not include the legacy device sinks to
     * save clocks walking through the list, if sink requests
     * are only for the legacy devices.
     */
    int nSinks;
#endif

    /*
     * Cache of the last matching request.
     */
    PPROCESS_HID_REQUEST pLastRequest;
    USAGE UsagePageLast;
    USAGE UsageLast;

    /*
     *  Legacy Mode flags
     */
    BOOL fRawMouse : 1;
    BOOL fNoLegacyMouse : 1;
#ifdef GI_SINK
    BOOL fRawMouseSink : 1;
#endif
    BOOL fRawKeyboard : 1;
    BOOL fNoLegacyKeyboard : 1;
#ifdef GI_SINK
    BOOL fRawKeyboardSink : 1;
#endif
    BOOL fCaptureMouse : 1;     // "Own" a mouse...
    BOOL fNoHotKeys : 1;
    BOOL fAppKeys: 1;
} PROCESS_HID_TABLE, *PPROCESS_HID_TABLE;

#define TestRawInputMode(pti, mode) \
    ((pti) && (pti)->ppi && (pti)->ppi->pHidTable && (pti)->ppi->pHidTable->f##mode)

#define TestRawInputModeNoCheck(pti, mode) \
    ((pti)->ppi->pHidTable->f##mode)

#ifdef GI_SINK
typedef struct tagHID_COUNTERS {
    DWORD cKbdSinks;
    DWORD cMouseSinks;
    DWORD cHidSinks;
} HID_COUNTERS;

extern HID_COUNTERS gHidCounters;

#define IsKeyboardSinkPresent() (gHidCounters.cKbdSinks > 0)
#define IsMouseSinkPresent()    (gHidCounters.cMouseSinks > 0)
#endif


#define HID_INCLUDE     0x01
#define HID_PAGEONLY    0x02
#define HID_EXCLUDE     0x03

/*
 * HID Device info
 */
typedef struct tagHID_DEVICE_INFO {
    PHIDDESC pHidDesc;
    PHID_TLC_INFO pTLCInfo;
} HID_DEVICE_INFO, *PHID_DEVICE_INFO;

#endif  // GENERIC_INPUT

typedef struct tagDEVICEINFO {
    GENERIC_DEVICE_INFO;
    union {
        MOUSE_DEVICE_INFO    mouse;
        KEYBOARD_DEVICE_INFO keyboard;
#ifdef GENERIC_INPUT
        HID_DEVICE_INFO hid;
#endif
    };
} DEVICEINFO, *PDEVICEINFO;

typedef struct tagDEVICE_TEMPLATE {
    SIZE_T cbDeviceInfo;        // bytes to allocate for DEVICEINFO
    const GUID *pClassGUID;     // GUID of the class
    UINT   uiRegistrySection;   // Parameters for class (HKLM\SYSTEM\CurrentControlSet\Services\*\Parameters)
    LPWSTR pwszClassName;       // Class name (eg: L"mouclass")
    LPWSTR pwszDefDevName;      // Default Device Name
    LPWSTR pwszLegacyDevName;   // Legacy Device Name (eg: "PointerClassLegacy0")
    ULONG  IOCTL_Attr;          // IOCTL_*_QUERY_ATTRIBUTES
    UINT   offAttr;             // offset of *_ATTRIBUTES struct within DEVICEINFO
    ULONG  cbAttr;              // sizeof *_ATTRIBUTES struct
    UINT   offData;             // offset of *_INPUT_DATA buffer within DEVICEINFO
    ULONG  cbData;              // sizeof *_INPUT_DATA buffer
    VOID   (*DeviceRead)(PDEVICEINFO); // routine to read the device
    PKEVENT pkeHidChange;       // event to signal changes to this sort of device

#ifdef GENERIC_INPUT
    DWORD dwFlags;              // Flags...
#endif
} DEVICE_TEMPLATE, *PDEVICE_TEMPLATE;


#ifdef GENERIC_INPUT
#define DT_HID          0x00000001
#endif

extern DEVICE_TEMPLATE aDeviceTemplate[]; // in pnp.c

typedef struct tagMOUSEEVENT {
    USHORT  ButtonFlags;
    USHORT  ButtonData;
    ULONG_PTR ExtraInfo;
    POINT   ptPointer;
    LONG    time;
    BOOL    bInjected;
#ifdef GENERIC_INPUT
    HANDLE  hDevice;

    /*
     * The raw mouse information comes here.
     */
    MOUSE_INPUT_DATA rawData;
#endif
} MOUSEEVENT, *PMOUSEEVENT;


#ifdef GENERIC_INPUT
/*
 * RawInput
 */
typedef struct tagHIDDATA {
    THROBJHEAD head;
    PWND spwndTarget;
    RAWINPUT rid;   // raw input data, variable length
                    // rid needs to be the last member in HIDDATA
} HIDDATA, *PHIDDATA;

/*
 * Global request list manipulation.
 */
void InitializeHidRequestList();
void CleanupHidRequestList();

/*
 * DeviceType request
 */
VOID FreeHidTLCInfo(
    PHID_TLC_INFO pHidRequest);

/*
 * HID specific device info
 */
PHIDDESC HidCreateDeviceInfo(PDEVICEINFO pDeviceInfo);

/*
 * HID specific information (managed by HM),
 * linked from DEVICEINFO
 */
/* N.b. AllocateHidDesc is only called within hidevice.c */
void FreeHidDesc(PHIDDESC);

/*
 * The handle in WM_INPUT
 */
PHIDDATA AllocateHidData(HANDLE hDevice, DWORD dwType, DWORD dwSize, WPARAM wParam, PWND pwnd);
void FreeHidData(PHIDDATA pData);

#ifdef GI_SINK
#define GI_SINK_PARAM(x)    ,x
#else
#define GI_SINK_PARAM(x)
#endif

void FreeHidProcessRequest(
    PPROCESS_HID_REQUEST pHid,
    DWORD dwFlags,
    PPROCESS_HID_TABLE pHidTable);


/*
 * HID specific read call back (called from InputApc)
 */
VOID ProcessHidInput(PDEVICEINFO pDeviceInfo);

/*
 * API helper
 */
BOOL _RegisterRawInputDevices(PCRAWINPUTDEVICE, UINT uiNumDevices);
UINT _GetRegisteredRawInputDevices(PRAWINPUTDEVICE, PUINT puiNumDevices);

/*
 * UserCriticalSection...
 */
#define BESURE_IN_USERCRIT(cond) \
    { \
        BOOLEAN fHasToLeaveUserCrit = FALSE; \
        if ((cond) && !ExIsResourceAcquiredExclusiveLite(gpresUser)) { \
            CheckDeviceInfoListCritOut(); \
            fHasToLeaveUserCrit = TRUE; \
            EnterCrit(); \
            TAGMSG0(DBGTAG_PNP, "BESURE_IN_USERCRIT: entering the user crit"); \
        }

#define END_IN_USERCRIT() \
        if (fHasToLeaveUserCrit) { \
            CheckDeviceInfoListCritOut(); \
            TAGMSG0(DBGTAG_PNP, "END_IN_USERCRIT: leaving the user crit"); \
            LeaveCrit(); \
        }\
    }

/*
 * Acquire input device lock while making sure there is no pending PnP callout
 * requesting to process a device change.
 */
#define PNP_SAFE_DEVICECRIT_IN() \
{\
    CheckCritIn();\
    CheckDeviceInfoListCritIn();\
    while (TRUE) {\
        if (gbPnPWaiting) {\
            LeaveDeviceInfoListCrit();\
            LeaveCrit(); \
            Status = KeWaitForSingleObject(gpEventPnPWainting, Executive, KernelMode, FALSE, NULL); \
            EnterCrit();\
            EnterDeviceInfoListCrit();\
            UserAssert(Status == STATUS_SUCCESS);\
            continue;\
        } else {  \
            break; \
        } \
    }  \
}


/*
 * Check if this device type is active to read
 */
__inline DWORD HidValidExclusive(PHID_TLC_INFO pTLCInfo)
{
    UserAssert(pTLCInfo);
    UserAssert(pTLCInfo->cExcludeRequest >= pTLCInfo->cExcludeOrphaned);
    return pTLCInfo->cExcludeRequest - pTLCInfo->cExcludeOrphaned;
}

__inline BOOL HidTLCActive(PHID_TLC_INFO pTLCInfo)
{
    UserAssert(pTLCInfo);
    return pTLCInfo->cDirectRequest > 0 || pTLCInfo->cUsagePageRequest > HidValidExclusive(pTLCInfo);
}

/*
 * Allocate and free process device type request table.
 */
PPROCESS_HID_TABLE AllocateProcessHidTable(void);
void FreeProcessHidTable(PPROCESS_HID_TABLE pHidTable);

void DestroyProcessHidRequests(PPROCESSINFO ppi);
void DestroyThreadHidObjects(PTHREADINFO pti);

#if DBG
void CheckupHidLeak(void);
#endif

#endif  // GENERIC_INPUT


VOID ProcessKeyboardInput(PDEVICEINFO pDeviceInfo);
VOID ProcessMouseInput(PDEVICEINFO pDeviceInfo);
VOID RequestDeviceChange(
    PDEVICEINFO pDeviceInfo,
    USHORT usAction,
    BOOL fInDeviceInfoListCrit);

VOID NTAPI InputApc(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved);

ULONG xxxGetDeviceChangeInfo(VOID);
NTSTATUS InitializeMediaChange(HANDLE hMediaRequestEvent);
VOID CleanupMediaChange(VOID);

/*
 * Hard error information
 */
typedef struct tagHARDERRORHANDLER {
    PTHREADINFO pti;
    PQ pqAttach;
} HARDERRORHANDLER, *PHARDERRORHANDLER;

/*
 * Terminal Structure.
 *
 *   This structure is only viewable from the kernel.
 */

#define TEST_GTERMF(f)               TEST_FLAG(gdwGTERMFlags, f)
#define TEST_BOOL_GTERMF(f)          TEST_BOOL_FLAG(gdwGTERMFlags, f)
#define SET_GTERMF(f)                SET_FLAG(gdwGTERMFlags, f)
#define CLEAR_GTERMF(f)              CLEAR_FLAG(gdwGTERMFlags, f)
#define SET_OR_CLEAR_GTERMF(f, fSet) SET_OR_CLEAR_FLAG(gdwGTERMFlags, f, fSet)
#define TOGGLE_GTERMF(f)             TOGGLE_FLAG(gdwGTERMFlags, f)

#define GTERMF_MOUSE        0x00000001


#define TERMF_INITIALIZED           0x00000001
#define TERMF_NOIO                  0x00000002
#define TERMF_STOPINPUT             0x00000004
#define TERMF_DTINITSUCCESS         0x00000008
#define TERMF_DTINITFAILED          0x00000010
#define TERMF_DTDESTROYED           0x00000020
#define TERMF_MOTHERWND_CREATED     0x00000040
#define TERMF_MOTHERWND_DESTROYED   0x00000080

typedef struct tagTERMINAL {

    DWORD               dwTERMF_Flags;      // terminal flags

    /*
     * System Information
     */
    PWND                spwndDesktopOwner;  // mother desktop


    PTHREADINFO         ptiDesktop;
    PQ                  pqDesktop;

    PKEVENT             pEventTermInit;
    PKEVENT             pEventDestroyDesktop;   // Used for destroying desktops

    PDESKTOP            rpdeskDestroy;          // Desktop destroy list.

    PKEVENT             pEventInputReady;   // input ready event. This is created in
                                            // CreateTerminal. RIT and the desktop thread
                                            // will wait for it. It will be set when the
                                            // first desktop in that terminal will be created.
} TERMINAL, *PTERMINAL;

/*
 * Pool allocation tags and macros
 */

/*
 * Define tags. To add tags, add them to ntuser\kernel\ptag.lst
 */
#define DEFINE_POOLTAG(value, index) value

#define DECLARE_POOLTAG(name, value, index)

#include "ptag.h"

NTSTATUS UserCommitDesktopMemory(
    PVOID  pBase,
    PVOID *ppCommit,
    PSIZE_T pCommitSize);

NTSTATUS UserCommitSharedMemory(
    PVOID  pBase,
    PVOID *ppCommit,
    PSIZE_T pCommitSize);

PWIN32HEAP UserCreateHeap(
    HANDLE                   hSection,
    ULONG                    ulViewOffset,
    PVOID                    pvBaseAddress,
    DWORD                    dwSize,
    PRTL_HEAP_COMMIT_ROUTINE pfnCommit);

#define RECORD_STACK_TRACE_SIZE 6

/*
 * Pool allocation flags
 */

#define POOL_HEAVY_ALLOCS       0x00000001  // use HeavyAllocPool
#define POOL_CAPTURE_STACK      0x00000002  // stack traces are captured
#define POOL_FAIL_ALLOCS        0x00000004  // fail pool allocations
#define POOL_FAIL_BY_INDEX      0x00000008  // fail allocations by index
#define POOL_TAIL_CHECK         0x00000010  // append tail string
#define POOL_KEEP_FREE_RECORD   0x00000020  // keep a list with last x frees
#define POOL_KEEP_FAIL_RECORD   0x00000040  // keep a list with last x failed allocations
#define POOL_BREAK_FOR_LEAKS    0x00000080  // break on pool leaks (remote sessions)

typedef struct tagWin32AllocStats {
    SIZE_T dwMaxMem;             // max pool memory allocated
    SIZE_T dwCrtMem;             // current pool memory used
    DWORD  dwMaxAlloc;           // max number of pool allocations made
    DWORD  dwCrtAlloc;           // current pool allocations

    PWin32PoolHead pHead;        // pointer to the link list with the allocations

} Win32AllocStats, *PWin32AllocStats;

typedef struct tagPOOLRECORD {
    PVOID   ExtraData;           // the tag
    SIZE_T  size;
    PVOID   trace[RECORD_STACK_TRACE_SIZE];
} POOLRECORD, *PPOOLRECORD;

#ifdef POOL_INSTR_API

    BOOL _Win32PoolAllocationStats(
        LPDWORD  parrTags,
        SIZE_T   tagsCount,
        SIZE_T*  lpdwMaxMem,
        SIZE_T*  lpdwCrtMem,
        LPDWORD  lpdwMaxAlloc,
        LPDWORD  lpdwCrtAlloc);

#endif // POOL_INSTR_API

#ifdef POOL_INSTR

    VOID CleanupPoolAllocations(VOID);
    NTSTATUS InitPoolLimitations(VOID);
    VOID CleanUpPoolLimitations(VOID);
#else
    #define CleanupPoolAllocations()
    #define InitPoolLimitations()   STATUS_SUCCESS
    #define CleanUpPoolLimitations()

#endif // POOL_INSTR

#ifndef TRACE_MAP_VIEWS
    #define InitSectionTrace()      STATUS_SUCCESS
    #define CleanUpSections()
#else
    NTSTATUS InitSectionTrace(VOID);
    VOID CleanUpSections(VOID);
#endif // TRACE_MAP_VIEWS

extern PWIN32HEAP gpvSharedAlloc;

__inline PVOID
SharedAlloc(ULONG cb)
{
    return Win32HeapAlloc(gpvSharedAlloc, cb, 0, 0);
}

__inline BOOL
SharedFree(PVOID pv)
{
    return Win32HeapFree(gpvSharedAlloc, pv);
}

NTSTATUS CommitReadOnlyMemory(HANDLE hSection, PSIZE_T pulCommit,
                              DWORD dwCommitOffset, int* pdCommit);

/*
 * Height and Width of the desktop pattern bitmap.
 */
#define CXYDESKPATTERN      8

/***************************************************************************\
* Typedefs and Macros
*
* Here are defined all types and macros that are shared across the User's
* server-side code modules. Types and macros that are unique to a single
* module should be defined at the head of that module, not in this file.
*
\***************************************************************************/


// Window Proc Window Validation macro

#define VALIDATECLASSANDSIZE(pwnd, message, wParam, lParam, inFNID, initmessage)          \
    if ((pwnd)->fnid != (inFNID)) {                                                       \
        switch ((pwnd)->fnid) {                                                           \
        DWORD cb;                                                                         \
        case 0:                                                                           \
                                                                                          \
            if ((cb = pwnd->cbwndExtra + sizeof(WND)) < (DWORD)(CBFNID(inFNID))) {        \
                RIPMSG3(RIP_WARNING,                                                      \
                       "(%#p %lX) needs at least (%ld) window words for this proc",       \
                        pwnd, cb - sizeof(WND),                                           \
                        (DWORD)(CBFNID(inFNID)) - sizeof(WND));                           \
                return 0;                                                                 \
            }                                                                             \
            /*                                                                            \
             * If this is not the initialization message, we cannot set the fnid;         \
             *  otherwise, we'll probably fault working on this pwnd's private            \
             *  uninitialized data                                                        \
             */                                                                           \
            if ((message) != (initmessage)) {                                             \
                if (((message) != WM_NCCREATE) && ((message) != WM_NCCALCSIZE)  && ((message) != WM_GETMINMAXINFO)) {         \
                    RIPMSG3(RIP_WARNING,                                                  \
                        "Default processing message %#lx for pwnd %#p. fnid %#lx not set",\
                        (message), (pwnd), (DWORD)(inFNID));                              \
                }                                                                         \
                return xxxDefWindowProc((pwnd), (message), (wParam), (lParam));           \
            }                                                                             \
                                                                                          \
            /*                                                                            \
             * Remember what window class this window belongs to. Can't use              \
             * the real class because any app can call CallWindowProc()                   \
             * directly no matter what the class is!                                      \
             */                                                                           \
            (pwnd)->fnid = (WORD)(inFNID);                                                \
            break;                                                                        \
                                                                                          \
        default:                                                                          \
            RIPMSG3(RIP_WARNING, "Window (%#p) not of correct class; fnid = %lX not %lX", \
                    (pwnd), (DWORD)((pwnd)->fnid), (DWORD)(inFNID));                      \
                                                                                          \
            /* Fall through */                                                            \
                                                                                          \
        case (inFNID | FNID_CLEANEDUP_BIT):                                               \
        case (inFNID | FNID_DELETED_BIT):                                                 \
        case (inFNID | FNID_STATUS_BITS):                                                 \
            return 0;                                                                     \
        }                                                                                 \
    }

/*
 * Handy Region helper macros
 */
#define CopyRgn(hrgnDst, hrgnSrc) \
            GreCombineRgn(hrgnDst, hrgnSrc, NULL, RGN_COPY)
#define IntersectRgn(hrgnResult, hrgnA, hrgnB) \
            GreCombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define SubtractRgn(hrgnResult, hrgnA, hrgnB) \
            GreCombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#define UnionRgn(hrgnResult, hrgnA, hrgnB) \
            GreCombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define XorRgn(hrgnResult, hrgnA, hrgnB) \
            GreCombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)

void DeleteMaybeSpecialRgn(HRGN hrgn);

BOOL zzzInvalidateDCCache(PWND pwndInvalid, DWORD flags);

#define IDC_DEFAULT         0x0001
#define IDC_CHILDRENONLY    0x0002
#define IDC_CLIENTONLY      0x0004
#define IDC_MOVEBLT         0x0008
#define IDC_NOMOUSE         0x0010

/*
 * RestoreSpb return Flags
 */

#define RSPB_NO_INVALIDATE      0   // nothing invalidated by restore
#define RSPB_INVALIDATE         1   // restore invalidate some area
#define RSPB_INVALIDATE_SSB     2   // restore called SaveScreenBits which invalidated

// Calls Proc directly without doing any messages translation

#define SCMS_FLAGS_ANSI         0x0001
#define SCMS_FLAGS_INONLY       0x0002      // Message should be one way (hooks)

#define CallClientProcA(pwnd, msg, wParam, lParam, xpfn) \
            SfnDWORD(pwnd, msg, wParam, lParam, xpfn,          \
                ((PROC)(gpsi->apfnClientW.pfnDispatchMessage)), TRUE, NULL)
#define CallClientProcW(pwnd, msg, wParam, lParam, xpfn) \
            SfnDWORD(pwnd, msg, wParam, lParam, xpfn,          \
                ((PROC)(gpsi->apfnClientW.pfnDispatchMessage)), TRUE, NULL)
#define CallClientWorkerProc(pwnd, msg, wParam, lParam, xpfn) \
            SfnDWORD(pwnd, msg, wParam, lParam, 0, xpfn, TRUE, NULL)
#define ScSendMessageSMS(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms) \
        (((msg) & ~MSGFLAG_MASK) >= WM_USER) ? \
        SfnDWORD(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms) : \
        gapfnScSendMessage[MessageTable[msg & 0xffff].iFunction](pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms)
#define ScSendMessage(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags) \
        ScSendMessageSMS(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, NULL)

/*
 * Server-side routines for loading cursors/icons/strings/menus from server.
 */
#define SERVERSTRINGMAXSIZE  40
void RtlInitUnicodeStringOrId(PUNICODE_STRING pstrName, LPWSTR lpstrName);
int RtlLoadStringOrError(UINT, LPTSTR, int, WORD);
#define ServerLoadString(hmod, id, p, cch)\
        RtlLoadStringOrError(id, p, cch, 0)
#define ServerLoadStringEx(hmod, id, p, cch, wLang)\
        RtlLoadStringOrError(id, p, cch, wLang)

/*
 * Callback routines for loading resources from client.
 */
HANDLE xxxClientLoadImage(
    PUNICODE_STRING pstrName,
    ATOM atomModName,
    WORD wImageType,
    int cxSize,
    int cySize,
    UINT LR_flags,
    BOOL fWallpaper);

HANDLE xxxClientCopyImage(
    IN HANDLE          hImage,
    IN UINT            uImageType,
    IN int             cxDesired,
    IN int             cyDesired,
    IN UINT            LR_flags);

PMENU xxxClientLoadMenu(
    HANDLE hmod,
    PUNICODE_STRING pstrName);

int xxxClientAddFontResourceW(PUNICODE_STRING, DWORD, DESIGNVECTOR*);

VOID ClientFontSweep(VOID);
VOID ClientLoadLocalT1Fonts();
VOID ClientLoadRemoteT1Fonts();

/*
 * Server-side routine for thread initialization.
 */
NTSTATUS InitializeClientPfnArrays(
    CONST PFNCLIENT *ppfnClientA,
    CONST PFNCLIENT *ppfnClientW,
    CONST PFNCLIENTWORKER *ppfnClientWorker,
    HANDLE hModUser);

VOID SetRipFlags(DWORD);
VOID SetDbgTag(int, DWORD);


/*
 * xxxActivateWindow() commands
 */
#define AW_USE       1
#define AW_TRY       2
#define AW_SKIP      3
#define AW_TRY2      4
#define AW_SKIP2     5      /* used internally in xxxActivateWindow() */
#define AW_USE2      6      /* nc mouse activation added by craigc */

/*
 * Structure for WM_ACTIVATEAPP EnumWindows() callback.
 */
typedef struct tagAAS {
    PTHREADINFO ptiNotify;
    DWORD tidActDeact;
    UINT fActivating  : 1;
    UINT fQueueNotify : 1;
} AAS;

/*
 * Declaration for EnumWindows() callback function.
 */
BOOL xxxActivateApp(PWND pwnd, AAS *paas);

#define GETDESKINFO(pti)  ((pti)->pDeskInfo)

#define SET_TIME_LAST_READ(pti)     ((pti)->pcti->timeLastRead = NtGetTickCount())
#define GET_TIME_LAST_READ(pti)     ((pti)->pcti->timeLastRead)


/*
 * General purpose helper macros
 */
#define abs(A)      (((A) < 0)? -(A) : (A))

#define N_ELEM(a)     (sizeof(a)/sizeof(a[0]))


/*
 * General purpose access check macro
 */
#define RETURN_IF_ACCESS_DENIED(amGranted, amRequested, r) \
        if (!CheckGrantedAccess((amGranted), (amRequested))) return r

/*
 * Lock record structure for tracking locks (debug only)
 */

#define LOCKRECORD_STACK    8
#define LOCKRECORD_MARKDESTROY  IntToPtr( 0xFFFFFFFF )

typedef struct _LOCKRECORD {
    PLR    plrNext;
    DWORD  cLockObj;
    PVOID  ppobj;
    PVOID  trace[LOCKRECORD_STACK];
} LOCKRECORD;

/*
 * We limit recursion until we have only this much stack left.
 * We have to leave room for kernel interupts.
 */
#define KERNEL_STACK_MINIMUM_RESERVE  (4*1024)

/*
 * And this much of backing store in IA64.
 */
#if defined(_IA64_)
#define KERNEL_BSTORE_MINIMUM_RESERVE (4*1024)
#define GET_CURRENT_BSTORE() ((ULONG_PTR)PsGetCurrentThreadStackBase() + KERNEL_LARGE_BSTORE_SIZE - __getReg(CV_IA64_RsBSP))
#endif // _IA64_

#if DBG
#if defined(_IA64_)
#define GET_USED_BSTORE_SIZE()  (__getReg(CV_IA64_RsBSP) - (ULONG_PTR)PsGetCurrentThreadStackBase())
#define ASSERT_BSTORE()  UserAssert(GET_CURRENT_BSTORE() > KERNEL_BSTORE_MINIMUM_RESERVE)
#else // _IA64_
#define ASSERT_BSTORE()
#endif // _IA64_

#define ASSERT_STACK() \
    UserAssert(IoGetRemainingStackSize() > KERNEL_STACK_MINIMUM_RESERVE); \
    ASSERT_BSTORE()

__inline ULONG_PTR GET_USED_STACK_SIZE(
    VOID)
{
    ULONG_PTR uLocVer;
    return ((ULONG_PTR)PsGetCurrentThreadStackBase() - (ULONG_PTR)&uLocVer);
}
#endif // DBG

/*
 * The following is a LOCK structure. This structure is recorded for
 * each threadlock so unlocks can occur at cleanup time.
 */
typedef struct _LOCK {
    PTHREADINFO pti;
    PVOID pobj;
    PTL ptl;
#if DBG
    PVOID pfn;                      // for debugging purposes only
    int ilNext;                     // for debugging purposes only
    int iilPrev;                    // for debugging purposes only
#endif // DBG
} LOCK, *PLOCK;

#define NEEDSSYNCPAINT(pwnd) TestWF(pwnd, WFSENDERASEBKGND | WFSENDNCPAINT)

typedef struct tagCVR       // cvr
{
    WINDOWPOS   pos;        // MUST be first field of CVR!
    int         xClientNew; // New client rectangle
    int         yClientNew;
    int         cxClientNew;
    int         cyClientNew;
    RECT        rcBlt;
    int         dxBlt;      // Distance blt rectangle is moving
    int         dyBlt;
    UINT        fsRE;       // RE_ flags: whether hrgnVisOld is empty or not
    HRGN        hrgnVisOld; // Previous visrgn
    PTHREADINFO pti;        // The thread this SWP should be processed on
    HRGN        hrgnClip;   // Window clipping region
    HRGN        hrgnInterMonitor;  // multimon support
} CVR, *PCVR;

/*
 * CalcValidRects() "Region Empty" flag values
 * A set bit indicates the corresponding region is empty.
 */
#define RE_VISNEW       0x0001  // CVR "Region Empty" flag values
#define RE_VISOLD       0x0002  // A set bit indicates the
#define RE_VALID        0x0004  // corresponding region is empty.
#define RE_INVALID      0x0008
#define RE_SPB          0x0010
#define RE_VALIDSUM     0x0020
#define RE_INVALIDSUM   0x0040

typedef struct tagSMWP {    // smwp
    HEAD           head;
    UINT           bShellNotify:1; // The acvr list contains shell notify flags
    UINT           bHandle:1;   // This is an HM object allocation -- See -BeginDeferWindowPos
    /*
     * All fields AFTER ccvr are preserved when reusing the global SMWP structure.
     */
    int            ccvr;        // Number of CVRs in the SWMP
    int            ccvrAlloc;   // Number of actual CVRs allocated in the SMWP
    PCVR           acvr;        // Pointer to array of CVR structures
} SMWP, *PSMWP;

void DestroySMWP(PSMWP psmwp);

/*
 * Clipboard data object definition
 */
typedef struct tagCLIPDATA {
    HEAD    head;
    DWORD   cbData;
    BYTE    abData[0];
} CLIPDATA, *PCLIPDATA;

/*
 * Private User Startupinfo
 */
typedef struct tagUSERSTARTUPINFO {
    DWORD   cb;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
} USERSTARTUPINFO, *PUSERSTARTUPINFO;

/*
 * TLBLOCK structure for multiple threads locking.
 */
#define THREADS_PER_TLBLOCK 16

typedef struct tagTLBLOCK {
    struct      tagTLBLOCK *ptlBlockPrev;
    struct {
        PTHREADINFO pti;
        TL          tlpti;
        DWORD       dwFlags;
#if DBG
        DWORD       dwUnlockedCount;
#endif
    } list[THREADS_PER_TLBLOCK];
} TLBLOCK, *PTLBLOCK;

/*
 * Keyboard File object.
 */
typedef struct tagKBDFILE {
    HEAD               head;
    struct tagKBDFILE *pkfNext;   // next keyboard file
    HANDLE             hBase;     // base address of data
    PKBDTABLES         pKbdTbl;   // pointer to kbd layout data.
    ULONG              Size;      // Size of pKbdTbl
    PKBDNLSTABLES      pKbdNlsTbl; // pointer to kbd nls layout data.
    WCHAR              awchDllName[32];
#ifdef LATER
    LANGID             langId;    // Default language ID of this layout
#endif
} KBDFILE, *PKBDFILE;

/*
 * Keyboard Layout object.
 */
typedef struct tagKL {   /* kl */
    HEAD          head;
    struct tagKL *pklNext;     // next in layout cycle
    struct tagKL *pklPrev;     // prev in layout cycle
    DWORD         dwKL_Flags;  // KL_* flags
    HKL           hkl;         // (Layout ID | Base Language ID)
    KBDFILE      *spkf;        // Keyboard Layout File
    KBDFILE      *spkfPrimary; // Primary keyboard layout file
    DWORD         dwFontSigs;  // mask of FS_xxx bits - fonts that layout is good for
    UINT          iBaseCharset;// Charset value (Win95 compat) eg: ANSI_CHARSET
    WORD          CodePage;    // Windows Codepage of kbd layout, eg: 1252, 1250
    WCHAR         wchDiacritic;// Dead key saved here until next keystroke
    PIMEINFOEX    piiex;       // Extended information for IME based layout
    UINT          uNumTbl;     // number of tables in pKbdTbl
    PKBDFILE     *pspkfExtra;  // extra layout file in this
    DWORD         dwLastKbdType;
    DWORD         dwLastKbdSubType;
    DWORD         dwKLID;      // base keyboard layout ID
} KL, *PKL;

/*
 * Flag values for KL dwFlags
 */
#define KL_UNLOADED 0x20000000
#define KL_RESET    0x40000000


PKL HKLtoPKL(PTHREADINFO pti, HKL hkl);

typedef struct tagKBDLANGTOGGLE
{
    BYTE bVkey;
    BYTE bScan;
    int  iBitPosition;
} KBDLANGTOGGLE;

/*
 * These constants are derived from combinations of
 * iBitPosition (refer to the LangToggle array defined
 * in globals.c).
 */

/*
 * This bit is used for both control and alt keys
 */
#define KLT_ALT              1

/*
 * This bit is used for the left shift key
 */
#define KLT_LEFTSHIFT        2

/*
 * This combination denotes ctrl/alt and the left shift key
 */
#define KLT_ALTLEFTSHIFT     3

/*
 * This bit is used for the right shift key
 */
#define KLT_RIGHTSHIFT       4

/*
 * This combination denotes ctrl/alt and the right shift key
 */
#define KLT_ALTRIGHTSHIFT    5

/*
 * This combination denotes ctrl/alt and both the shift keys
 */
#define KLT_ALTBOTHSHIFTS    7

/*
 * This value is used to mark invalid toggle key sequence
 */
#define KLT_NONE             8


/*
 * Key Event (KE) structure
 * Stores a Virtual Key event
 */
typedef struct tagKE {
    union {
        BYTE bScanCode;    // Virtual Scan Code (Set 1)
        WCHAR wchInjected; // Unicode char from SendInput()
    };
    USHORT usFlaggedVk;    // Vk | Flags
    DWORD  dwTime;         // time in milliseconds
#ifdef GENERIC_INPUT
    HANDLE hDevice;
    KEYBOARD_INPUT_DATA data;
#endif
} KE, *PKE;

/*
 * Misc. keyboard stuff moved from oak/inc/kbd.h
 */
typedef BOOL (* KEPROC)(PKE pKe);
typedef BOOL (* NLSKEPROC)(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam);
typedef BOOL (* NLSVKFPROC)(PVK_F pVkToF, PKE pKe, ULONG_PTR dwExtraInfo);

/*
 * OEM-specific special processing (keystroke simulators and filters)
 */
extern KEPROC aKEProcOEM[];


/*
 * Key message lParam bits
 */
#define EXTENDED_BIT   0x01000000
#define DONTCARE_BIT   0x02000000
#define FAKE_KEYSTROKE 0x02000000
#define ALTNUMPAD_BIT  0x04000000 // copied from windows\inc\wincon.w

/*
 * For handy diacritics
 */
#define IDS_FROM_SCANCODE(prefix, base) \
        (0xc000 + ((0x ## prefix) >= 0xE0 ? 0x100 : 0) + (0x ## base))

//
// NLS Keyboard functions
//
VOID NlsKbdInitializePerSystem(VOID);
VOID NlsKbdSendIMENotification(DWORD dwImeOpen, DWORD dwImeConversion);

/*
 * Desktop flags.
 */
#define DF_ACTIVEONDESTROY    0x00000001
#define DF_ZOMBIE             0x00000002
#define DF_NOTRITUNLOCK       0x00000004
#define DF_QUITUNLOCK         0x00000008
#define DF_USERMODE           0x00000010
#define DF_SKIPSWITCHDESKTOP  0x00000020
#define DF_DTNONEWDESKTOP     0x00000040
#define DF_REDIRECTED         0x00000080
#define DF_DESKCREATED        0x00000100
#define DF_NEWDISPLAYSETTINGS 0x00000200
#define DF_TRACKMOUSEHOVER    0x00000400
#define DF_TRACKMOUSELEAVE    0x00000800
#define DF_TOOLTIPACTIVE      0x00001000
#define DF_TOOLTIPSHOWING     0x00002000
#define DF_HOTTRACKING        0x00004000
#define DF_DESTROYED          0x00008000
#define DF_DESKWNDDESTROYED   0x00010000
#define DF_DYING              0x00020000

#define DF_TOOLTIP            (DF_TOOLTIPACTIVE | DF_TOOLTIPSHOWING)
#define DF_TRACKMOUSEEVENT    (DF_TRACKMOUSELEAVE | DF_TRACKMOUSEHOVER)
#define DF_MOUSEMOVETRK       (DF_HOTTRACKING | DF_TOOLTIPACTIVE | DF_TRACKMOUSELEAVE | DF_TRACKMOUSEHOVER)

#define CAPTIONTOOLTIPLEN   100

/*
 * Used to identify desktops uniquely for GDI
 */

#define GW_DESKTOP_ID 1

#define DESKTOP_ALLOC_TRACE_SIZE 6

#if DBG
    typedef struct tagDbgAllocHead {
        DWORD    mark;
        DWORD    tag;
        PDESKTOP pdesk;
        SIZE_T   size;                  // the size of the allocation (doesn't include
                                        // this structure

        struct tagDbgAllocHead* pPrev;  // pointer to the previous allocation of this tag
        struct tagDbgAllocHead* pNext;  // pointer to the next allocation of this tag

#ifdef DESKTOP_ALLOC_TRACE
        PVOID  trace[DESKTOP_ALLOC_TRACE_SIZE];
#endif // DESKTOP_ALLOC_TRACE

    } DbgAllocHead, *PDbgAllocHead;
#endif // DBG

#define DTAG_CLASS              0x0001
#define DTAG_DESKTOPINFO        0x0002
#define DTAG_CLIENTTHREADINFO   0x0003
#define DTAG_TEXT               0x0004
#define DTAG_HANDTABL           0x0005
#define DTAG_SBINFO             0x0006
#define DTAG_MENUITEM           0x0007
#define DTAG_MENUTEXT           0x0008
#define DTAG_IMETEXT            0x0009
#define DTAG_PROPLIST           0x000A

/*
 * Desktop Structure.
 *
 *   This structure is only viewable from the kernel. If any desktop
 *   information is needed in the client, then they should reference off
 *   the pDeskInfo field (i.e. pti->pDeskInfo).
 */
typedef struct tagDESKTOP {

    DWORD                   dwSessionId;       // Terminal Server SessionId. This has to be first field in the structure
    PDESKTOPINFO            pDeskInfo;         // Desktop information
    PDISPLAYINFO            pDispInfo;         //

    PDESKTOP                 rpdeskNext;       // Next desktop in list
    PWINDOWSTATION           rpwinstaParent;   // Windowstation owner

    DWORD                   dwDTFlags;         // Desktop flags
    ULONG                   dwDesktopId;       // Needed by GDI to tag display devices

    PMENU                    spmenuSys;        //
    PMENU                    spmenuDialogSys;  //
    PMENU                    spmenuHScroll;
    PMENU                    spmenuVScroll;
    PWND                     spwndForeground;  //
    PWND                     spwndTray;
    PWND                     spwndMessage;
    PWND                     spwndTooltip;

    HANDLE                  hsectionDesktop;   //
    PWIN32HEAP              pheapDesktop;      //
    DWORD                   dwConsoleThreadId; //
    DWORD                   dwConsoleIMEThreadId;
    CONSOLE_CARET_INFO      cciConsole;
    LIST_ENTRY              PtiList;           //

    PWND                    spwndTrack;        // xxxTrackMouseMove data
    int                     htEx;
    RECT                    rcMouseHover;
    DWORD                   dwMouseHoverTime;


#ifdef LOGDESKTOPLOCKS
    int                     nLockCount;
    int                     nLogMax;
    int                     nLogCrt;
    PLogD                   pLog;
#endif // LOGDESKTOPLOCKS

} DESKTOP;

typedef struct tagDESKWND {
    WND   wnd;
    DWORD idProcess;
    DWORD idThread;
} DESKWND, *PDESKWND;

PVOID DesktopAlloc(PDESKTOP pdesk, UINT uSize,DWORD tag);

#define DesktopAllocAlways(pdesk, uSize, tag)   \
            Win32HeapAlloc(pdesk->pheapDesktop, uSize, tag, 0)

#define DesktopFree(pdesk, p)   Win32HeapFree(pdesk->pheapDesktop, p)

/*
 * Windowstation structure
 */
#define WSF_SWITCHLOCK          0x0001
#define WSF_OPENLOCK            0x0002
#define WSF_NOIO                0x0004
#define WSF_SHUTDOWN            0x0008
#define WSF_DYING               0x0010
#define WSF_REALSHUTDOWN        0x0020
#define WSF_CLIPBOARDCHANGED    0x0040
#define WSF_INDELAYEDRENDERING  0x0080

typedef struct tagWINDOWSTATION {
    /*
     * TS SessionId. This has to be the first field in the structure.
     */
    DWORD                dwSessionId;
    PWINDOWSTATION       rpwinstaNext;
    PDESKTOP             rpdeskList;

    PTERMINAL            pTerm;

    DWORD                dwWSF_Flags;
    struct tagKL         *spklList;

    /*
     * Clipboard variables.
     */
    PTHREADINFO          ptiClipLock;
    PTHREADINFO          ptiDrawingClipboard;
    PWND                 spwndClipOpen;
    PWND                 spwndClipViewer;
    PWND                 spwndClipOwner;
    struct tagCLIP       *pClipBase;
    int                  cNumClipFormats;
    UINT                 iClipSerialNumber;
    UINT                 iClipSequenceNumber;

    /*
     * Global Atom table.
     */
    PVOID                pGlobalAtomTable;

    LUID                 luidEndSession;
    LUID                 luidUser;
    PSID                 psidUser;

    /*
     * Pointer to the currently active desktop for the window station.
     */
#if DBG
    PDESKTOP             pdeskCurrent;
#endif
} WINDOWSTATION;

typedef struct tagCAPTIONCACHE {
    PCURSOR         spcursor;
    POEMBITMAPINFO  pOem;
#if DBG
    HICON           hico;
#endif
} CAPTIONCACHE;

/*
 * Configurable icon and cursor stuff
 */
    typedef struct tagSYSCFGICO
    {
        WORD    Id;     // configurable id (OIC_ or OCR_ value)
        WORD    StrId;  // String ID for registry key name
        PCURSOR spcur;  // perminant cursor/icon pointer
    } SYSCFGICO;

    #define SYSICO(name) (gasysico[OIC_##name##_DEFAULT - OIC_FIRST_DEFAULT].spcur)
    #define SYSCUR(name) (gasyscur[OCR_##name##_DEFAULT - OCR_FIRST_DEFAULT].spcur)


/*
 * Accelerator Table structure
 */
typedef struct tagACCELTABLE {
    PROCOBJHEAD head;
    UINT        cAccel;
    ACCEL       accel[1];
} ACCELTABLE, *LPACCELTABLE;

/*
 * Besides the desktop window used by the current thread, we also
 * need to get the desktop window of a window and the input desktop
 * window.
 */
#define PWNDDESKTOP(p)      ((p)->head.rpdesk->pDeskInfo->spwnd)
#define PWNDMESSAGE(p)      ((p)->head.rpdesk->spwndMessage)
#define PWNDTOOLTIP(p)      ((p)->head.rpdesk->spwndTooltip)

/*
 * During window destruction, even a locked window can have a
 * NULL parent so use this macro where a NULL parent is a problem.
 */
#define PWNDPARENT(p) (p->spwndParent ? p->spwndParent : PWNDDESKTOP(p))

#define ISAMENU(pwwnd)       \
        (GETFNID(pwnd) == FNID_MENU)


/* NEW MENU STUFF */
typedef struct tagPOPUPMENU
{

  DWORD  fIsMenuBar:1;       /* This is a hacked struct which refers to the
                              * menu bar associated with a app. Only true if
                              * in the root ppopupMenuStruct.
                              */
  DWORD  fHasMenuBar:1;      /* This popup is part of a series which has a
                              * menu bar (either a sys menu or top level menu
                              * bar)
                              */
  DWORD  fIsSysMenu:1;    /* The system menu is here. */
  DWORD  fIsTrackPopup:1;    /* Is TrackPopup popup menu */
  DWORD  fDroppedLeft:1;
  DWORD  fHierarchyDropped:1;/* If true, a submenu has been dropped off this popup */
  DWORD  fRightButton:1;     /* Allow right button in menu */
  DWORD  fToggle:1;          /* If TRUE, button up cancels the popup */
  DWORD  fSynchronous:1;     /* For synchronous return value of cmd chosen */
  DWORD  fFirstClick:1;      /* Keep track if this was the first click on the
                              * top level menu bar item. If the user down/up
                              * clicks on a top level menu bar item twice, we
                              * want to cancel menu mode.
                              */
  DWORD  fDropNextPopup:1;   /* Should we drop hierarchy of next menu item w/ popup? */
  DWORD  fNoNotify:1;        /* Don't send WM_ msgs to owner, except WM_COMMAND  */
  DWORD  fAboutToHide:1;     // Same purpose as fHideTimer?
  DWORD  fShowTimer:1;       // TRUE if the IDSYS_MNSHOW timer is set
  DWORD  fHideTimer:1;       // TRUE if the IDSYS_MNHIDE timer is set

  DWORD  fDestroyed:1;       /* Set when the owner menu window has been destroyed
                              *  so the popup can be freed once it's no longer needed
                              * Also set in root popupmenu when menu mode must end
                              */

  DWORD  fDelayedFree:1;    /* Avoid freeing the popup when the owner menu
                             *  window is destroyed.
                             * If set, it must be a root popupmenu or must
                             *  be linked in ppmDelayedFree
                             * This is eventually set for all hierarchical popups
                             */

  DWORD  fFlushDelayedFree:1; /* Used in root popupmenus only.
                               * Set when a hierarchical popup marked as fDelayedFree
                               *  has been destroyed.
                               */


  DWORD  fFreed:1;           /* Popup has been freed. Used for debug only */

  DWORD  fInCancel:1;        /* Popup has been passed to xxxMNCancel */

  DWORD  fTrackMouseEvent:1; /* TrackMouseEvent has been called */
  DWORD  fSendUninit:1;      /* Send WM_UNINITMENUPOPUP */
  DWORD  fRtoL:1;            /* For going backwards with the keys */
  DWORD  iDropDir:5;         /* Animation direction */


  PWND           spwndNotify;
                        /* Window who gets the notification messages. If this
                         * is a window with a menu bar, then this is the same
                         * as hwndPopupMenu.
                         */
  PWND           spwndPopupMenu;
                        /* The window associated with this ppopupMenu struct.
                         * If this is a top level menubar, then hwndPopupMenu
                         * is the window the menu bar. ie. it isn't really a
                         * popup menu window.
                         */
  PWND           spwndNextPopup;
                        /* The next popup in the hierarchy. Null if the last
                         * in chain
                         */
  PWND           spwndPrevPopup;
                        /* The previous popup in the hierarchy. NULL if at top
                         */
  PMENU          spmenu;/* The PMENU displayed in this window
                         */
  PMENU          spmenuAlternate;
                        /* Alternate PMENU. If the system menu is displayed,
                         * and a menubar menu exists, this will contain the
                         * menubar menu. If menubar menu is displayed, this
                         * will contain the system menu. Use only on top level
                         * ppopupMenu structs so that we can handle windows
                         * with both a system menu and a menu bar menu. Only
                         * used in the root ppopupMenuStruct.
                         */

  PWND           spwndActivePopup; /* This is the popup the mouse/"keyboard focus" is on */

  PPOPUPMENU     ppopupmenuRoot;

  PPOPUPMENU     ppmDelayedFree;       /* List of hierarchical popups marked
                                        *  as fDelayedFree.
                                        */

  UINT   posSelectedItem;  /* Position of the selected item in this menu */
  UINT   posDropped;

} POPUPMENU;

typedef struct tagMENUWND {
    WND wnd;
    PPOPUPMENU ppopupmenu;
} MENUWND, *PMENUWND;

/*
 * CheckPoint structure
 */
typedef struct tagCHECKPOINT {
    RECT rcNormal;
    POINT ptMin;
    POINT ptMax;
    DWORD fDragged:1;
    DWORD fWasMaximizedBeforeMinimized:1;
    DWORD fWasMinimizedBeforeMaximized:1;
    DWORD fMinInitialized:1;
    DWORD fMaxInitialized:1;
} CHECKPOINT, *PCHECKPOINT;

typedef struct tagCLIP {
    UINT    fmt;
    HANDLE  hData;
    BOOL    fGlobalHandle;
} CLIP, *PCLIP;

/*
 * DDEML instance structure
 */
typedef struct tagSVR_INSTANCE_INFO {
    THROBJHEAD head;
    struct tagSVR_INSTANCE_INFO *next;
    struct tagSVR_INSTANCE_INFO *nextInThisThread;
    DWORD afCmd;
    PWND spwndEvent;
    PVOID pcii;
} SVR_INSTANCE_INFO, *PSVR_INSTANCE_INFO;

typedef struct tagPUBOBJ {
    struct tagPUBOBJ *next;
    HANDLE hObj;
    int count;
    W32PID pid;
} PUBOBJ, *PPUBOBJ;

/*
 * Defines for Menu focus
 */
#define FREEHOLD    0
#define MOUSEHOLD  -1 /* Mouse button held down and dragging */
#define KEYBDHOLD   1

/*
 * Structure definition for messages as they exist on a Q. Same as MSG
 * structure except for the link-pointer and flags at the end.
 */
typedef struct tagQMSG {
    PQMSG           pqmsgNext;
    PQMSG           pqmsgPrev;
    MSG             msg;
    LONG_PTR        ExtraInfo;
    DWORD           dwQEvent;
    PTHREADINFO     pti;
} QMSG;

/*
 * dwQEvent values for QMSG structure.
 */
#define QEVENT_SHOWWINDOW           0x0001
#define QEVENT_CANCELMODE           0x0002
#define QEVENT_SETWINDOWPOS         0x0003
#define QEVENT_UPDATEKEYSTATE       0x0004
#define QEVENT_DEACTIVATE           0x0005
#define QEVENT_ACTIVATE             0x0006
#define QEVENT_POSTMESSAGE          0x0007
#define QEVENT_DESTROYWINDOW        0x0008
#define QEVENT_ASYNCSENDMSG         0x0009
#define QEVENT_HUNGTHREAD           0x000A
#define QEVENT_CANCELMOUSEMOVETRK   0x000B
#define QEVENT_NOTIFYWINEVENT       0x000C
#define QEVENT_RITACCESSIBILITY     0x000D
#define QEVENT_RITSOUND             0x000E
#define QEVENT_APPCOMMAND           0x000F

#define RITSOUND_UPSIREN            0x0000
#define RITSOUND_DOWNSIREN          0x0001
#define RITSOUND_LOWBEEP            0x0002
#define RITSOUND_HIGHBEEP           0x0003
#define RITSOUND_KEYCLICK           0x0004
#define RITSOUND_DOBEEP             0x0005

/*
 * xxxProcessEventMessage flags
 */
#define PEM_ACTIVATE_RESTORE        0x0001
#define PEM_ACTIVATE_NOZORDER       0x0002

typedef struct _MOVESIZEDATA {
    PWND            spwnd;
    RECT            rcDrag;
    RECT            rcDragCursor;
    RECT            rcParent;
    POINT           ptMinTrack;
    POINT           ptMaxTrack;
    RECT            rcWindow;
    int             dxMouse;
    int             dyMouse;
    int             cmd;
    int             impx;
    int             impy;
    POINT           ptRestore;
    UINT            fInitSize         : 1;    // should we initialize cursor pos
    UINT            fmsKbd            : 1;    // who knows
    UINT            fLockWindowUpdate : 1;    // whether screen was locked ok
    UINT            fTrackCancelled   : 1;    // Set if tracking ended by other thread.
    UINT            fForeground       : 1;    // whether the tracking thread is foreground
                                              //  and if we should draw the drag-rect
    UINT            fDragFullWindows  : 1;
    UINT            fOffScreen        : 1;
} MOVESIZEDATA, *PMOVESIZEDATA;

/*
 * DrawDragRect styles.
 */
#define DDR_START     0     // - start drag.
#define DDR_ENDACCEPT 1     // - end and accept
#define DDR_ENDCANCEL 2     // - end and cancel.


/*
 * Pseudo Event stuff. (fManualReset := TRUE, fInitState := FALSE)
 */

DWORD WaitOnPseudoEvent(HANDLE *phE, DWORD dwMilliseconds);

#define PSEUDO_EVENT_ON     ((HANDLE)IntToPtr( 0xFFFFFFFF ))
#define PSEUDO_EVENT_OFF    ((HANDLE)IntToPtr( 0x00000000 ))
#define INIT_PSEUDO_EVENT(ph) *ph = PSEUDO_EVENT_OFF;

#define SET_PSEUDO_EVENT(phE)                                   \
    CheckCritIn();                                              \
    if (*(phE) == PSEUDO_EVENT_OFF) *(phE) = PSEUDO_EVENT_ON;   \
    else if (*(phE) != PSEUDO_EVENT_ON) {                       \
        KeSetEvent(*(phE), EVENT_INCREMENT, FALSE);             \
        ObDereferenceObject(*(phE));                            \
        *(phE) = PSEUDO_EVENT_ON;                               \
    }

#define RESET_PSEUDO_EVENT(phE)                                 \
    CheckCritIn();                                              \
    if (*(phE) == PSEUDO_EVENT_ON) *(phE) = PSEUDO_EVENT_OFF;   \
    else if (*(phE) != PSEUDO_EVENT_OFF) {                      \
        KeClearEvent(*(phE));                                   \
    }

#define CLOSE_PSEUDO_EVENT(phE)                                 \
    CheckCritIn();                                              \
    if (*(phE) == PSEUDO_EVENT_ON) *(phE) = PSEUDO_EVENT_OFF;   \
    else if (*(phE) != PSEUDO_EVENT_OFF) {                      \
        KeSetEvent(*(phE), EVENT_INCREMENT, FALSE);             \
        ObDereferenceObject(*(phE));                            \
        *(phE) = PSEUDO_EVENT_OFF;                              \
    }

typedef struct tagMLIST {
    PQMSG pqmsgRead;        // next message to be read. This is a FIFO queue
    PQMSG pqmsgWriteLast;   // last message  added to the queue. Used mainly for coalescing
    DWORD cMsgs;            // Count of messages. Used for optimizations and to enforce a max.
} MLIST, *PMLIST;

/*
 * Message Queue structure.
 *
 * Note, if you need to add a WORD sized value,
 * do so after xbtnDblClk.
 */
typedef struct tagQ {
    MLIST       mlInput;            // raw mouse and key message list.

    PTHREADINFO ptiSysLock;         // Thread currently allowed to process input
    ULONG_PTR    idSysLock;          // Last message removed or to be removed before unlocking
    ULONG_PTR    idSysPeek;          // Last message peeked

    PTHREADINFO ptiMouse;           // Last thread to get mouse msg.
    PTHREADINFO ptiKeyboard;

    PWND        spwndCapture;
    PWND        spwndFocus;
    PWND        spwndActive;
    PWND        spwndActivePrev;

    UINT        codeCapture;        // type of captue. See *_CAP* defines in this file
    UINT        msgDblClk;          // last mouse down message removed
    WORD        xbtnDblClk;         // last xbutton down
    DWORD       timeDblClk;         // max time for next button down to be taken as double click
    HWND        hwndDblClk;         // window that got last button down
    POINT       ptDblClk;           // last button down position. See SYSMET(C?DOUBLECLK)

    BYTE        afKeyRecentDown[CBKEYSTATERECENTDOWN];
    BYTE        afKeyState[CBKEYSTATE];

    CARET       caret;

    PCURSOR     spcurCurrent;
    int         iCursorLevel;       // show/hide count. < 0 if the cursor is not visible

    DWORD       QF_flags;            // QF_ flags go here

    USHORT      cThreads;            // Count of threads using this queue
    USHORT      cLockCount;          // Count of threads that don't want this queue freed

    UINT        msgJournal;         // See SetJournalTimer. Journal message to be delivered when timer goes off
    LONG_PTR    ExtraInfo;          // Extra info for last qmsg read. See GetMessageExtraInfo
} Q;

/*
 * Used for zzzAttachThreadInput()
 */
typedef struct tagATTACHINFO {
    struct tagATTACHINFO *paiNext;
    PTHREADINFO pti1;
    PTHREADINFO pti2;
} ATTACHINFO, *PATTACHINFO;

#define POLL_EVENT_CNT 5

#define IEV_IDLE    0
#define IEV_INPUT   1
#define IEV_EXEC    2
#define IEV_TASK    3
#define IEV_WOWEXEC 4


typedef struct tagWOWTHREADINFO {
    struct tagWOWTHREADINFO *pwtiNext;
    DWORD    idTask;                // WOW task id
    ULONG_PTR idWaitObject;          // pseudo handle returned to parent
    DWORD    idParentProcess;       // process that called CreateProcess
    PKEVENT  pIdleEvent;            // event that WaitForInputIdle will wait on
} WOWTHREADINFO, *PWOWTHREADINFO;

/*
 * Task Data Block structure.
 */
typedef struct tagTDB {
    PTDB            ptdbNext;
    int             nEvents;
    int             nPriority;
    PTHREADINFO     pti;
    PWOWTHREADINFO  pwti;               // per thread info for shared Wow
    WORD            hTaskWow;           // Wow cookie to find apps during shutdown
    WORD            TDB_Flags;             //  bit 0 means setup app
} TDB;

#define TDBF_SETUP 1


/*
 * Hack message for shell to tell them a setup app is exiting.
 * This message is defined in \nt\private\shell\inc, but I really
 * don't want to introduce that dependency in the build. DavidDS
 * has put a check in that file to make sure that the value does not
 * change and refers to this usage. FritzS
 */
#define DTM_SETUPAPPRAN (WM_USER+90)

/*
 * Menu animation GDI objects.
 */
typedef struct tagMENUANIDC
{
    HDC     hdcAni;         // Scratch dc for animation
} MENUANIDC;

/*
 * Menu Control Structure
 */
typedef struct tagMENUSTATE {
    PPOPUPMENU pGlobalPopupMenu;
    DWORD   fMenuStarted : 1;
    DWORD   fIsSysMenu : 1;
    DWORD   fInsideMenuLoop : 1;
    DWORD   fButtonDown:1;
    DWORD   fInEndMenu:1;
    DWORD   fUnderline:1;               /* Shorcut key underlines are shown */
    DWORD   fButtonAlwaysDown:1;        /* The mouse has always been down since the menu started */
    DWORD   fDragging:1;                /* Dragging (in DoDragDrop) or about to */
    DWORD   fModelessMenu:1;            /* No modal loop */
    DWORD   fInCallHandleMenuMessages:1;/* processing a msg from CallHandleMM */
    DWORD   fDragAndDrop:1;             /* This menu can do drag and drop */
    DWORD   fAutoDismiss:1;             /* This menu goes away on its own if mouse is off for certain time */
    DWORD   fAboutToAutoDismiss:1;      /* Autodismiss will take place when timer goes off */
    DWORD   fIgnoreButtonUp:1;          /* Eat next button up, i.e, cancel dragging */
    DWORD   fMouseOffMenu:1;            /* Mouse is off the menu - modeless menus only */
    DWORD   fInDoDragDrop:1;            /* in a WM_MENUDODRAGDROP callback */
    DWORD   fActiveNoForeground:1;      /* A menu window is active but we're not in the foreground */
    DWORD   fNotifyByPos:1;             /* Use WM_MENUCOMMAND */
    DWORD   fSetCapture:1;              /* True if the menu mode set capture */
    DWORD   iAniDropDir:5;              /* direction of animation */

    POINT   ptMouseLast;
    int     mnFocus;
    int     cmdLast;
    PTHREADINFO ptiMenuStateOwner;

    DWORD   dwLockCount;

    struct tagMENUSTATE *pmnsPrev;      /* Previous menustate for nested/context menus */

    POINT   ptButtonDown;               /* Mouse down position (begin drag position) */
    ULONG_PTR uButtonDownHitArea;        /* Return from xxxMNFindWindowFromPoint on button down */
    UINT    uButtonDownIndex;           /* Index of the item being dragged */

    int     vkButtonDown;               /* Mouse button being dragged */

    ULONG_PTR uDraggingHitArea;          /* Last hit area while InDoDragDrop */
    UINT    uDraggingIndex;             /* Last index  */
    UINT    uDraggingFlags;             /* Gap flags */

    HDC     hdcWndAni;      // window DC while animating
    DWORD   dwAniStartTime; // starting time of animation
    int     ixAni;          // current x-step in animation
    int     iyAni;          // current y-step in animation
    int     cxAni;          // total x in animation
    int     cyAni;          // total y in animation
    HBITMAP hbmAni;         // Scratch bmp for animation.

    /*
     * Important: The following structure must be the last
     *  thing in tagMENUSTATE. MNAllocMenuState doesn't NULL out
     *  this structure
     */
    MENUANIDC;

} MENUSTATE, *PMENUSTATE;

typedef struct tagLASTINPUT {  /* linp */
    DWORD timeLastInputMessage;
    DWORD dwFlags;
    PTHREADINFO ptiLastWoken;  /* Last thread woken by key or click  */
                               /* It can be NULL                     */
    POINT ptLastClick;         /* point of the last mouse click      */
} LASTINPUT, PLASTINPUT;

#define LINP_KEYBOARD       0x00000001
#define LINP_SCREENSAVER    0x00000002
#define LINP_LOWPOWER       0x00000004
#define LINP_POWEROFF       0x00000008
#define LINP_JOURNALLING    0x00000010
#define LINP_INPUTSOURCES   (LINP_KEYBOARD | LINP_JOURNALLING)
#define LINP_POWERTIMEOUTS  (LINP_LOWPOWER | LINP_POWEROFF)
#define LINP_INPUTTIMEOUTS  (LINP_SCREENSAVER | LINP_LOWPOWER | LINP_POWEROFF)

/*
 * Menu data to be passed to xxxRealDrawMenuItem from xxxDrawState
 */
typedef struct {
    PMENU pMenu;
    PITEM pItem;
} GRAYMENU, *PGRAYMENU;

#define IS_THREAD_RESTRICTED(pti, r)                            \
    ((pti->TIF_flags & TIF_RESTRICTED) ?                        \
        (pti->ppi->pW32Job->restrictions & (r)) :               \
        FALSE)

#define IS_CURRENT_THREAD_RESTRICTED(r)                         \
    ((PtiCurrent()->TIF_flags & TIF_RESTRICTED) ?               \
        (PtiCurrent()->ppi->pW32Job->restrictions & (r)) :      \
        FALSE)

/*
 * These types are needed before they are fully defined.
 */
typedef struct tagSMS               * KPTR_MODIFIER PSMS;

/*
 * Make sure this structure matches up with W32THREAD, since they're
 * really the same thing.
 */

/*
 * NOTE -- this structure has been sorted (roughly) in order of use
 * of the fields. The x86 code set allows cheaper access to fields
 * that are in the first 0x80 bytes of a structure. Please attempt
 * to ensure that frequently-used fields are below this boundary.
 *          FritzS
 */

typedef struct tagTHREADINFO {
    W32THREAD;

//***************************************** begin: USER specific fields

    PTL             ptl;                // Listhead for thread lock list

    PPROCESSINFO    ppi;                // process info struct for this thread

    PQ              pq;                 // keyboard and mouse input queue

    PKL             spklActive;         // active keyboard layout for this thread

    PCLIENTTHREADINFO pcti;             // Info that must be visible from client

    PDESKTOP        rpdesk;
    PDESKTOPINFO    pDeskInfo;          // Desktop info visible to client
    ULONG_PTR       ulClientDelta;      // Desktop heap client delta
    PCLIENTINFO     pClientInfo;        // Client info stored in TEB

    DWORD           TIF_flags;          // TIF_ flags go here.

    PUNICODE_STRING pstrAppName;        // Application module name.

    PSMS            psmsSent;           // Most recent SMS this thread has sent
    PSMS            psmsCurrent;        // Received SMS this thread is currently processing
    PSMS            psmsReceiveList;    // SMSs to be processed

    LONG            timeLast;           // Time and ID of last message
    ULONG_PTR       idLast;

    int             exitCode;

    HDESK           hdesk;              // Desktop handle
    int             cPaintsReady;
    UINT            cTimersReady;

    PMENUSTATE      pMenuState;

    union {
        PTDB            ptdb;           // Win16Task Schedule data for WOW thread
        PWINDOWSTATION  pwinsta;        // Window station for SYSTEM thread
    };

    PSVR_INSTANCE_INFO psiiList;        // thread DDEML instance list
    DWORD           dwExpWinVer;
    DWORD           dwCompatFlags;      // The Win 3.1 Compat flags
    DWORD           dwCompatFlags2;     // new DWORD to extend compat flags for NT5+ features

    PQ              pqAttach;           // calculation variabled used in
                                        // zzzAttachThreadInput()

    PTHREADINFO     ptiSibling;         // pointer to sibling thread info

    PMOVESIZEDATA   pmsd;

    DWORD           fsHooks;                // WHF_ Flags for which hooks are installed
    PHOOK           sphkCurrent;            // Hook this thread is currently processing

    PSBTRACK        pSBTrack;

    HANDLE          hEventQueueClient;
    PKEVENT         pEventQueueServer;
    LIST_ENTRY      PtiLink;            // Link to other threads on desktop
    int             iCursorLevel;       // keep track of each thread's level
    POINT           ptLast;             // Position of last message

    PWND            spwndDefaultIme;    // Default IME Window for this thread
    PIMC            spDefaultImc;       // Default input context for this thread
    HKL             hklPrev;            // Previous active keyboard layout
    int             cEnterCount;
    MLIST           mlPost;             // posted message list.
    USHORT          fsChangeBitsRemoved;// Bits removed during PeekMessage
    WCHAR           wchInjected;        // character from last VK_PACKET
    DWORD           fsReserveKeys;      // Keys that must be sent to the active
                                        // active console window.
    PKEVENT        *apEvent;            // Wait array for xxxPollAndWaitForSingleObject
    ACCESS_MASK     amdesk;             // Granted desktop access
    UINT            cWindows;           // Number of windows owned by this thread
    UINT            cVisWindows;        // Number of visible windows on this thread

    PHOOK           aphkStart[CWINHOOKS];   // Hooks registered for this thread
    CLIENTTHREADINFO  cti;              // Use this when no desktop is available

#ifdef GENERIC_INPUT
    HANDLE          hPrevHidData;
#endif
#if DBG
    UINT            cNestedCalls;
#endif
} THREADINFO;

#define PWNDTOPSBTRACK(pwnd) (((GETPTI(pwnd)->pSBTrack)))

/*
 * The number of library module handles we can store in the dependency
 * tables. If this exceeds 32, the load mask implementation must be
 * changed.
 */
#define CLIBS           32

/*
 * Process Info structure.
 */
typedef struct tagWOWPROCESSINFO {
    struct tagWOWPROCESSINFO *pwpiNext; // List of WOW ppi's, gppiFirstWow is head
    PTHREADINFO ptiScheduled;           // current thread in nonpreemptive scheduler
    PTDB        ptdbHead;               // list of this process's WOW tasks
    PVOID       lpfnWowExitTask;        // func addr for wow exittask callback
    PKEVENT     pEventWowExec;          // WowExec Virt HWint scheduler event
    HANDLE      hEventWowExecClient;    // client handle value for wowexec
    DWORD       nSendLock;              // Send Scheduler inter process Send count
    DWORD       nRecvLock;              // Send Scheduler inter process Receive count
    PTHREADINFO CSOwningThread;         // Pseudo Wow CritSect ClientThreadId
    LONG        CSLockCount;            // Pseudo Wow CritSect LockCount
} WOWPROCESSINFO, *PWOWPROCESSINFO;

typedef struct tagDESKTOPVIEW {
    struct tagDESKTOPVIEW *pdvNext;
    PDESKTOP              pdesk;
    ULONG_PTR             ulClientDelta;
} DESKTOPVIEW, *PDESKTOPVIEW;


/*
 * number of DWORDs in ppi->pgh
 */
#define GH_SIZE  8

/*
 * The delta allocation for ppiTable array in W32JOB structure.
 */
#define JP_DELTA  4

/*
 * W32JOB structure
 */
typedef struct tagW32JOB {
    struct tagW32JOB*  pNext;           // next W32JOB structure
    PEJOB              Job;             // pointer to the EJOB structure
    PVOID              pAtomTable;      // the atom table for the job object
    DWORD              restrictions;    // UI restrictions
    UINT               uProcessCount;   // number of processes in ppiTable
    UINT               uMaxProcesses;   // how much room is in ppiTable
    PPROCESSINFO*      ppiTable;        // the array of processes contained in the job
    UINT               ughCrt;          // crt number of handles in pgh
    UINT               ughMax;          // number of handles pgh can store
    PULONG_PTR         pgh;             // the granted handles table
} W32JOB, *PW32JOB;

#ifdef REDIRECTION
#define PF_REDIRECTED            0x00000001
#define PF_REDIRECTIONHOST       0x00000002
#endif // REDIRECTION

/*
 * Make sure this structure matches up with W32PROCESS, since they're
 * really the same thing.
 */

/*
 * NOTE -- this structure has been sorted (roughly) in order of use
 * of the fields. The x86 code set allows cheaper access to fields
 * that are in the first 0x80 bytes of a structure. Please attempt
 * to ensure that frequently-used fields are below this boundary.
 */

typedef struct tagPROCESSINFO {
    W32PROCESS;
//***************************************** begin: USER specific fields
    PTHREADINFO     ptiList;                    // threads in this process
    PTHREADINFO     ptiMainThread;              // pti of "main thread"
    PDESKTOP        rpdeskStartup;              // initial desktop
    PCLS            pclsPrivateList;            // this processes' private classes
    PCLS            pclsPublicList;             // this processes' public classes
    PWOWPROCESSINFO pwpi;                       // Wow PerProcess Info

    PPROCESSINFO    ppiNext;                    // next ppi structure in start list
    PPROCESSINFO    ppiNextRunning;
    int             cThreads;                   // count of threads using this process info
    HDESK           hdeskStartup;               // initial desktop handle
    UINT            cSysExpunge;                // sys expunge counter
    DWORD           dwhmodLibLoadedMask;        // bits describing loaded hook dlls
    HANDLE          ahmodLibLoaded[CLIBS];      // process unique hmod array for hook dlls
    struct          tagWINDOWSTATION *rpwinsta; // process windowstation
    HWINSTA         hwinsta;                    // windowstation handle
    ACCESS_MASK     amwinsta;                   // windowstation accesses

    DWORD           dwHotkey;                   // hot key from progman
    HMONITOR        hMonitor;                   // monitor handle from CreateProcess
    PDESKTOPVIEW    pdvList;                    // list of desktop views
    UINT            iClipSerialNumber;          // clipboard serial number
    RTL_BITMAP      bmHandleFlags;              // per handle flags
    PCURSOR         pCursorCache;               // process cursor/icon cache
    PVOID           pClientBase;                // LEAVE THIS FOR HYDRA; offset to the shared section
    DWORD           dwLpkEntryPoints;           // user mode language pack installed

    PW32JOB         pW32Job;                    // pointer to the W32JOB structure

    DWORD           dwImeCompatFlags;           // per-process Ime Compatibility flags
    LUID            luidSession;                // logon session id
    USERSTARTUPINFO usi;                        // process startup info

#ifdef VALIDATEHANDLEQUOTA
    LONG lHandles;
#endif

    DWORD           dwLayout;                   // the default Window orientation for this process

#ifdef GENERIC_INPUT
    PPROCESS_HID_TABLE pHidTable;               // per process device request list
#endif

#ifdef REDIRECTION
    DWORD           dwRedirection;             // redirection mode for this process
#endif
} PROCESSINFO;

/*
 * Bit definitions for dwLpkEntryPoints in the processinfo structure.
 * These are passed from the client side when an lpk is registered.
 * The kernel determines when to perform callbacks based on which
 * entry points an lpk supports.
 */
#define LPK_TABBEDTEXTOUT 0x01
#define LPK_PSMTEXTOUT    0x02
#define LPK_DRAWTEXTEX    0x04
#define LPK_EDITCONTROL   0x08
#define LPK_INSTALLED     0x0f

#define CALL_LPK(ptiCurrent)  ((PpiCurrent()->dwLpkEntryPoints & LPK_INSTALLED) && \
                               !((ptiCurrent)->TIF_flags & TIF_INCLEANUP))

/*
 * This is used to send cool switch windows information
 * to the lpk
 */
typedef struct _LPKDRAWSWITCHWND {
    RECT rcRect;
    LARGE_UNICODE_STRING strName;
} LPKDRAWSWITCHWND;

/*
 * DC cache entry structure (DCE)
 *
 *   This structure identifies an entry in the DCE cache. It is
 *   usually initialized at GetDCEx() and cleanded during RelaseCacheDC
 *   calls.
 *
 *   Field
 *   -----
 *
 *   pdceNext       - Pointer to the next DCE entry.
 *
 *
 *   hdc            - GDI DC handle for the dce entry. This will have
 *                    the necessary clipping regions selected into it.
 *
 *   pwndOrg        - Identifies the window in the GetDCEx() call which owns
 *                    the DCE Entry.
 *
 *   pwndClip       - Identifies the window by which the DC is clipped to.
 *                    This is usually done for PARENTDC windows.
 *
 *   hrgnClip       - This region is set if the caller to GetDCEx() passes a
 *                    clipping region in which to intersect with the visrgn.
 *                    This is used when we need to recalc the visrgn for the
 *                    DCE entry. This will be freed at ReleaseCacheDC()
 *                    time if the flag doesn't have DCX_NODELETERGN set.
 *
 *   hrgnClipPublic - This is a copy of the (hrgnClip) passed in above. We
 *                    make a copy and set it as PUBLIC ownership so that
 *                    we can use it in computations during the UserSetDCVisRgn
 *                    call. This is necessary for Full-Hung-Draw where we
 *                    are drawing from a different process then the one
 *                    who created the (hrgnClip). This is always deleted
 *                    in the ReleaseCacheDC() call.
 *
 *   hrgnSavedVis   - This is a copy of the saved visrgn for the DCE entry.
 *
 *   flags          - DCX_ flags.
 *
 *   ptiOwner       - Thread owner of the DCE entry.
 *
 */
typedef struct tagDCE {
    PDCE                 pdceNext;
    HDC                  hdc;
    PWND                 pwndOrg;
    PWND                 pwndClip;
    HRGN                 hrgnClip;
    HRGN                 hrgnClipPublic;
    HRGN                 hrgnSavedVis;
    DWORD                DCX_flags;
    PTHREADINFO          ptiOwner;
    PMONITOR             pMonitor;
} DCE;

#define DCE_SIZE_CACHEINIT        5    // Initial number of DCEs in the cache.
#define DCE_SIZE_CACHETHRESHOLD  32    // Number of dce's as a threshold.

#define DCE_RELEASED              0    // ReleaseDC released
#define DCE_FREED                 1    // ReleaseDC freed
#define DCE_NORELEASE             2    // ReleaseDC in-use.

/*
 * CalcVisRgn DC type bits
 */
#define DCUNUSED        0x00        /* Unused cache entry */
#define DCC             0x01        /* Client area */
#define DCW             0x02        /* Window area */
#define DCSAVEDVISRGN   0x04
#define DCCLIPRGN       0x08
#define DCNOCHILDCLIP   0x10        /* Nochildern clip */
#define DCSAVEVIS       0x20        /* Save visrgn before calculating */
#define DCCACHE         0x40

 /*
 * THREAD_CODEPAGE()
 *
 * Returns the CodePage based on the current keyboard layout.
 */

#define _THREAD_CODEPAGE() (GetClientInfo()->CodePage)

_inline WORD THREAD_CODEPAGE() {
    WORD CodePage;
    try {
        CodePage = _THREAD_CODEPAGE();
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
       CodePage = PtiCurrent()->spklActive ? PtiCurrent()->spklActive->CodePage : CP_ACP;
    }
    return CodePage;
}

/*
 * Window List Structure
 */
typedef struct tagBWL {
    struct tagBWL *pbwlNext;
    HWND          *phwndNext;
    HWND          *phwndMax;
    PTHREADINFO   ptiOwner;
    HWND          rghwnd[1];
} BWL, *PBWL;

/*
 * Numbers of HWND slots to to start with and to increase by.
 */
#define BWL_CHWNDINIT      32     /* initial # slots pre-allocated */
#define BWL_CHWNDMORE       8     /* # slots to obtain when required */

#define BWL_ENUMCHILDREN    1
#define BWL_ENUMLIST        2
#define BWL_ENUMOWNERLIST   4

#define BWL_ENUMIMELAST     0x08
#define BWL_REMOVEIMECHILD  0x10

/*
 * Saved Popup Bits structure
 */
typedef struct tagSPB {
    struct tagSPB *pspbNext;
    PWND          spwnd;
    HBITMAP       hbm;
    RECT          rc;
    HRGN          hrgn;
    DWORD         flags;
    ULONG_PTR     ulSaveId;
} SPB;

#define SPB_SAVESCREENBITS  0x0001  // GreSaveScreenBits() was called
#define SPB_LOCKUPDATE      0x0002  // LockWindowUpdate() SPB
#define SPB_DRAWBUFFER      0x0004  // BeginDrawBuffer() SPB

#define AnySpbs()   (gpDispInfo->pspbFirst != NULL)     // TRUE if there are any SPBs

/*
 * Macro to check if the journal playback hook is installed.
 */
#define FJOURNALRECORD()    (GETDESKINFO(PtiCurrent())->aphkStart[WH_JOURNALRECORD + 1] != NULL)
#define FJOURNALPLAYBACK()  (GETDESKINFO(PtiCurrent())->aphkStart[WH_JOURNALPLAYBACK + 1] != NULL)

#define TESTHMODLOADED(pti, x)       ((pti)->ppi->dwhmodLibLoadedMask & (1 << (x)))
#define SETHMODLOADED(pti, x, hmod)  ((pti)->ppi->ahmodLibLoaded[x] = hmod, \
                                      (pti)->ppi->dwhmodLibLoadedMask |= (1 << (x)))
#define CLEARHMODLOADED(pti, x)      ((pti)->ppi->ahmodLibLoaded[x] = NULL, \
                                      (pti)->ppi->dwhmodLibLoadedMask &= ~(1 << (x)))
#define PFNHOOK(phk) (phk->ihmod == -1 ? (PROC)phk->offPfn : \
        (PROC)(((ULONG_PTR)(PtiCurrent()->ppi->ahmodLibLoaded[phk->ihmod])) + \
        ((ULONG_PTR)(phk->offPfn))))

/*
 * Extended structures for message thunking.
 */
typedef struct _CREATESTRUCTEX {
    CREATESTRUCT cs;
    LARGE_STRING strName;
    LARGE_STRING strClass;
} CREATESTRUCTEX, *PCREATESTRUCTEX;

typedef struct _MDICREATESTRUCTEX {
    MDICREATESTRUCT mdics;
    LARGE_STRING strTitle;
    LARGE_STRING strClass;
} MDICREATESTRUCTEX, *PMDICREATESTRUCTEX;

typedef struct _CWPSTRUCTEX {
    struct tagCWPSTRUCT;
    PSMS            psmsSender;
} CWPSTRUCTEX, *PCWPSTRUCTEX;

typedef struct _CWPRETSTRUCTEX {
    LRESULT         lResult;
    struct tagCWPSTRUCT;
    PSMS            psmsSender;
} CWPRETSTRUCTEX, *PCWPRETSTRUCTEX;

/*
 * SendMessage structure and defines.
 */
typedef struct tagSMS {   /* sms */
    PSMS            psmsNext;          // link in global psmsList
#if DBG
    PSMS            psmsSendList;      // head of queue's SendMessage chain
    PSMS            psmsSendNext;      // link in queue's SendMessage chain
#endif // DBG
    PSMS            psmsReceiveNext;   // link in queue's ReceiveList
    PTHREADINFO     ptiSender;          // sending thread
    PTHREADINFO     ptiReceiver;        // receiving thread

    SENDASYNCPROC   lpResultCallBack;   // function to receive the SendMessageCallback return value
    ULONG_PTR        dwData;             // value to be passed back to the lpResultCallBack function
    PTHREADINFO     ptiCallBackSender;  // sending thread

    LRESULT         lRet;               // message return value
    DWORD           tSent;              // time message was sent
    UINT            flags;              // SMF_ flags
    WPARAM          wParam;             // message fields...
    LPARAM          lParam;
    UINT            message;
    PWND            spwnd;
    PVOID           pvCapture;          // captured argument data
} SMS;

#define SMF_REPLY                   0x0001      // message has been replied to
#define SMF_RECEIVERDIED            0x0002      // receiver has died
#define SMF_SENDERDIED              0x0004      // sender has died
#define SMF_RECEIVERFREE            0x0008      // receiver should free sms when done
#define SMF_RECEIVEDMESSAGE         0x0010      // sms has been received
#define SMF_CB_REQUEST              0x0100      // SendMessageCallback requested
#define SMF_CB_REPLY                0x0200      // SendMessageCallback reply
#define SMF_CB_CLIENT               0x0400      // Client process request
#define SMF_CB_SERVER               0x0800      // Server process request
#define SMF_WOWRECEIVE              0x1000      // wow sched has incr recv count
#define SMF_WOWSEND                 0x2000      // wow sched has incr send count
#define SMF_RECEIVERBUSY            0x4000      // reciver is processing this msg

/*
 * InterSendMsgEx parameter used for SendMessageCallback and TimeOut
 */
typedef struct tagINTERSENDMSGEX {   /* ism */
    UINT   fuCall;                      // callback or timeout call

    SENDASYNCPROC lpResultCallBack;     // function to receive the send message value
    ULONG_PTR dwData;                    // Value to be passed back to the SendResult call back function
    LRESULT lRet;                       // return value from the send message

    UINT fuSend;                        // how to send the message, SMTO_BLOCK, SMTO_ABORTIFHUNG
    UINT uTimeout;                      // time-out duration
    PULONG_PTR lpdwResult;               // the return value for a syncornis call
} INTRSENDMSGEX, *PINTRSENDMSGEX;

#define ISM_CALLBACK        0x0001      // callback function request
#define ISM_TIMEOUT         0x0002      // timeout function request
#define ISM_REQUEST         0x0010      // callback function request message
#define ISM_REPLY           0x0020      // callback function reply message
#define ISM_CB_CLIENT       0x0100      // client process callback function

/*
 * Event structure to handle broadcasts of notification messages.
 */
typedef struct tagASYNCSENDMSG {
    WPARAM  wParam;
    LPARAM  lParam;
    UINT    message;
    HWND    hwnd;
} ASYNCSENDMSG, *PASYNCSENDMSG;

/*
 * HkCallHook() structure
 */
#define IsHooked(pti, fsHook) \
    ((fsHook & (pti->fsHooks | pti->pDeskInfo->fsHooks)) != 0)

#define IsGlobalHooked(pti, fsHook) \
    ((fsHook & pti->pDeskInfo->fsHooks) != 0)

typedef struct tagHOOKMSGSTRUCT { /* hch */
    PHOOK   phk;
    int     nCode;
    LPARAM  lParam;
} HOOKMSGSTRUCT, *PHOOKMSGSTRUCT;

/*
 * BroadcastMessage() commands.
 */
#define BMSG_SENDMSG                0x0000
#define BMSG_SENDNOTIFYMSG          0x0001
#define BMSG_POSTMSG                0x0002
#define BMSG_SENDMSGCALLBACK        0x0003
#define BMSG_SENDMSGTIMEOUT         0x0004
#define BMSG_SENDNOTIFYMSGPROCESS   0x0005

/*
 * xxxBroadcastMessage parameter used for SendMessageCallback and TimeOut
 */
typedef union tagBROADCASTMSG {   /* bcm */
     struct {                               // for callback broadcast
         SENDASYNCPROC lpResultCallBack;    // function to receive the send message value
         ULONG_PTR dwData;                   // Value to be passed back to the SendResult call back function
         BOOL bClientRequest;               // if a cliet or server callback request
     } cb;
     struct {                               // for timeout broadcast
         UINT fuFlags;                      // timeout type flags
         UINT uTimeout;                     // timeout length
         PULONG_PTR lpdwResult;              // where to put the return value
     } to;
} BROADCASTMSG, *PBROADCASTMSG;

/*
 * Internal hotkey structures and defines.
 */
typedef struct tagHOTKEY {
    PTHREADINFO pti;
    PWND    spwnd;
    WORD    fsModifiers; // MOD_SHIFT, MOD_ALT, MOD_CONTROL, MOD_WIN
    WORD    wFlags;      // MOD_SAS
    UINT    vk;
    int     id;
    struct tagHOTKEY *phkNext;
} HOTKEY, *PHOTKEY;

#define PWND_INPUTOWNER (PWND)1    // Means send WM_HOTKEY to input owner.
#define PWND_FOCUS      (PWND)NULL // Means send WM_HOTKEY to queue's pwndFocus.
#define PWND_TOP        (PWND)0
#define PWND_BOTTOM     (PWND)1
#define PWND_GROUPTOTOP ((PWND)-1)
#define PWND_TOPMOST    ((PWND)-1)
#define PWND_NOTOPMOST  ((PWND)-2)
#define PWND_BROADCAST  ((PWND)-1)

#define IDHOT_DEBUG         (-5)
#define IDHOT_DEBUGSERVER   (-6)
#define IDHOT_WINDOWS       (-7)

/*
 * xPos, yPos for WM_CONTEXTMENU from keyboard
 */
#define KEYBOARD_MENU   ((LPARAM)-1)    // Keyboard generated menu

/*
 * Capture codes
 */
#define NO_CAP_CLIENT           0   /* no capture; in client area */
#define NO_CAP_SYS              1   /* no capture; in sys area */
#define CLIENT_CAPTURE          2   /* client-relative capture */
#define WINDOW_CAPTURE          3   /* window-relative capture */
#define SCREEN_CAPTURE          4   /* screen-relative capture */
#define FULLSCREEN_CAPTURE      5   /* capture entire machine */
#define CLIENT_CAPTURE_INTERNAL 6   /* client-relative capture (Win 3.1 style; won't release) */

#define CH_HELPPREFIX   0x08

#ifdef KANJI
    #define CH_KANJI1       0x1D
    #define CH_KANJI2       0x1E
    #define CH_KANJI3       0x1F
#endif // KANJI

#define xxxRedrawScreen() \
        xxxInternalInvalidate(PtiCurrent()->rpdesk->pDeskInfo->spwnd, \
        HRGN_FULL, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN)

/*
 * Preallocated buffer for use during SetWindowPos to prevent memory
 * allocation failures.
 */
#define CCVR_WORKSPACE      4

/*
 * DrawIconCallBack data, global only for state data in tmswitch.c
 */
typedef struct tagDRAWICONCB {   /* dicb */
    PWND   pwndTop;                     // Window being drawn
    UINT   cx;                          // x offset for icon
    UINT   cy;                          // y offset for icon
} DRAWICONCB, *PDRAWICONCB;

/*
 * The following defines the components of nKeyboardSpeed
 */
#define KSPEED_MASK     0x001F          // Defines the key repeat speed.
#define KDELAY_MASK     0x0060          // Defines the keyboard delay.
#define KDELAY_SHIFT    5

/*
 * Property list checkpoint int
 */
#define PROP_CHECKPOINT     MAKEINTATOM(atomCheckpointProp)
#define PROP_DDETRACK       MAKEINTATOM(atomDDETrack)
#define PROP_QOS            MAKEINTATOM(atomQOS)
#define PROP_DDEIMP         MAKEINTATOM(atomDDEImp)
#define PROP_WNDOBJ         MAKEINTATOM(atomWndObj)
#define PROP_IMELEVEL       MAKEINTATOM(atomImeLevel)
#define PROP_LAYER          MAKEINTATOM(atomLayer)

#define WinFlags    ((WORD)(&__WinFlags))

/*
 * ntinput.c
 */
BOOL xxxInternalKeyEventDirect(
    BYTE  bVk,
    WORD  wScan,
    DWORD dwFlags,
    DWORD dwTime,
    ULONG_PTR dwExtraInfo);

UINT xxxSendInput(
    UINT    nInputs,
    LPINPUT pInputs);

BOOL _BlockInput(
    BOOL    fBlockIt);

int _GetMouseMovePointsEx(
    CONST MOUSEMOVEPOINT* ppt,
    MOUSEMOVEPOINT*       pptBuf,
    UINT                  nPoints,
    DWORD                 resolution);


VOID xxxProcessKeyEvent(
   PKE       pke,
   ULONG_PTR ExtraInformation,
   BOOL      bInjected);

VOID xxxButtonEvent(
    DWORD ButtonNumber,
    POINT ptPointer,
    BOOL  fBreak,
    DWORD time,
    ULONG_PTR ExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    BOOL  bInjected,
    BOOL  fDblClk);

VOID xxxMoveEvent(
    LONG         dx,
    LONG         dy,
    DWORD        dwFlags,
    ULONG_PTR    dwExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE       hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    DWORD        time,
    BOOL         bInjected
    );

typedef struct _RIT_INIT {
    PTERMINAL pTerm;
    PKEVENT   pRitReadyEvent;
} RIT_INIT, *PRIT_INIT;

PDEVICEINFO StartDeviceRead(PDEVICEINFO pDeviceInfo);

NTSTATUS DeviceNotify(
    IN PPLUGPLAY_NOTIFY_HDR pNotification,
    IN PDEVICEINFO pDeviceInfo);

#define MOUSE_SENSITIVITY_MIN     1
#define MOUSE_SENSITIVITY_DEFAULT 10
#define MOUSE_SENSITIVITY_MAX     20
LONG CalculateMouseSensitivity(LONG lSens);

PDEVICEINFO FreeDeviceInfo(PDEVICEINFO pMouseInfo);


__inline PTHREADINFO PtiKbdFromQ(PQ pq)
{
    if (pq->spwndActive) {
        return GETPTI(pq->spwndActive);
    }
    UserAssert(pq->ptiKeyboard);
    return pq->ptiKeyboard;
}

__inline PTHREADINFO ValidatePtiKbd(PQ pq)
{
    if (pq == NULL) {
        return NULL;
    }
    return PtiKbdFromQ(pq);
}

__inline PTHREADINFO PtiMouseFromQ(PQ pq)
{
    if (pq->spwndCapture) {
        return GETPTI(pq->spwndCapture);
    }
    UserAssert(pq->ptiMouse);
    return pq->ptiMouse;
}

__inline PTHREADINFO ValidatePtiMouse(PQ pq)
{
    if (pq == NULL) {
        return NULL;
    }
    return PtiMouseFromQ(pq);
}


VOID QueueMouseEvent(
    USHORT       ButtonFlags,
    USHORT       ButtonData,
    ULONG_PTR    ExtraInfo,
    POINT        ptMouse,
    LONG         time,
#ifdef GENERIC_INPUT
    HANDLE       hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    BOOL         bInjected,
    BOOL         bWakeRIT
    );

typedef struct {
    DWORD dwVersion;
    DWORD dwFlags;
    DWORD dwMapCount;
    DWORD dwMap[0];
} SCANCODEMAP, *PSCANCODEMAP;


#ifndef SCANCODE_NUMPAD_PLUS
#define SCANCODE_NUMPAD_PLUS    (0x4e)
#endif
#ifndef SCANCODE_NUMPAD_DOT
#define SCANCODE_NUMPAD_DOT     (0x53)
#endif

/*
 * Flag (LowLevel and HighLevel) for
 * hex Alt+Numpad mode.
 * If you need to add a new flag for gfInNumpadHexInput,
 * note the variable is BYTE.
 */
#define NUMPAD_HEXMODE_LL       (1)
#define NUMPAD_HEXMODE_HL       (2)

#define MODIFIER_FOR_ALT_NUMPAD(wModBit) \
    (((wModBits) == KBDALT) || ((wModBits) == (KBDALT | KBDSHIFT)) || \
     ((wModBits) == (KBDKANA | KBDALT)) || ((wModBits) == (KBDKANA | KBDALT | KBDSHIFT)))


BOOL UnqueueMouseEvent(PMOUSEEVENT pme);

BYTE    VKFromVSC(PKE pke, BYTE bPrefix, LPBYTE afKeyState);
BOOL    KEOEMProcs(PKE pke);
BOOL    xxxKELocaleProcs(PKE pke);
BOOL    xxxKENLSProcs(PKE pke, ULONG_PTR dwExtraInformation);

VOID    xxxKeyEvent(USHORT usVk, WORD wScanCode, DWORD time, ULONG_PTR ExtraInfo,
#ifdef GENERIC_INPUT
                    HANDLE hDevice,
                    PKEYBOARD_INPUT_DATA pkei,
#endif
                    BOOL bInjected);

typedef BITMAPINFOHEADER *PBMPHEADER, *LPBMPHEADER;

VOID xxxSimpleDoSyncPaint(PWND pwnd);
VOID xxxDoSyncPaint(PWND pwnd, DWORD flags);
VOID xxxInternalDoSyncPaint(PWND pwnd, DWORD flags);

/*
 * NOTE: the first 4 values must be as defined for backward compatibility
 * reasons. They are sent as parameters to the WM_SYNCPAINT message.
 * They used to be hard-coded constants.
 *
 * Only ENUMCLIPPEDCHILDREN, ALLCHILDREN, and NOCHECKPARENTS are passed on
 * during recursion. The other bits reflect the current window only.
 */
#define DSP_ERASE               0x0001  // Send WM_ERASEBKGND
#define DSP_FRAME               0x0002  // Send WM_NCPAINT
#define DSP_ENUMCLIPPEDCHILDREN 0x0004  // Enum children if WS_CLIPCHILDREN
#define DSP_WM_SYNCPAINT        0x0008  // Called from WM_SYNCPAINT handler
#define DSP_NOCHECKPARENTS      0x0010  // Don't check parents for update region
#define DSP_ALLCHILDREN         0x0020  // Enumerate all children.

BOOL xxxDrawAnimatedRects(
    PWND pwndClip,
    int idAnimation,
    LPRECT lprcStart,
    LPRECT lprcEnd);

typedef struct tagTIMER {
    HEAD            head;
    struct tagTIMER *ptmrNext;
    struct tagTIMER *ptmrPrev;
    PTHREADINFO     pti;
    struct tagWND * spwnd;
    UINT_PTR        nID;
    DWORD           cmsCountdown;
    DWORD           cmsRate;
    UINT            flags;
    TIMERPROC_PWND  pfn;
    PTHREADINFO     ptiOptCreator;  // Used for journal playback -- Will be NULL
                                    // if timer was created by non-GUI thread.
} TIMER, *PTIMER;

UINT_PTR InternalSetTimer(PWND pwnd, UINT_PTR nIDEvent, UINT dwElapse,
        TIMERPROC_PWND pTimerFunc, UINT flags);

VOID FreeTimer(PTIMER ptmr);

/*
 * Call FindTimer() with fKill == TRUE and TMRF_RIT. This will basically
 * delete the timer.
 */
#define KILLRITTIMER(pwnd, nID) FindTimer(pwnd, nID, TMRF_RIT, TRUE)

/*
 * Raster Ops
 */
#define PATOR 0x00FA0089L  /* destination, pattern, or */

/*
 * Message thunks.
 */
typedef LRESULT (APIENTRY *SFNSCSENDMESSAGE)(PWND, UINT, WPARAM, LPARAM,
        ULONG_PTR, PROC, DWORD, PSMS);

#define SMESSAGEPROTO(func) \
     LRESULT CALLBACK Sfn ## func(                              \
        PWND pwnd, UINT msg, WPARAM wParam, LPARAM lParam,      \
        ULONG_PTR xParam, PROC xpfnWndProc, DWORD dwSCMSFlags, PSMS psms)

SMESSAGEPROTO(SENTDDEMSG);
SMESSAGEPROTO(DDEINIT);
SMESSAGEPROTO(DWORD);
SMESSAGEPROTO(NCDESTROY);
SMESSAGEPROTO(INWPARAMCHAR);
SMESSAGEPROTO(INWPARAMDBCSCHAR);

SMESSAGEPROTO(GETTEXTLENGTHS);

SMESSAGEPROTO(GETDBCSTEXTLENGTHS);
SMESSAGEPROTO(INLPCREATESTRUCT);
SMESSAGEPROTO(INLPDROPSTRUCT);
SMESSAGEPROTO(INOUTLPPOINT5);
SMESSAGEPROTO(INOUTLPSCROLLINFO);
SMESSAGEPROTO(INOUTLPRECT);
SMESSAGEPROTO(INOUTNCCALCSIZE);
SMESSAGEPROTO(OUTLPRECT);
SMESSAGEPROTO(INLPMDICREATESTRUCT);
SMESSAGEPROTO(INLPCOMPAREITEMSTRUCT);
SMESSAGEPROTO(INLPDELETEITEMSTRUCT);
SMESSAGEPROTO(INLPHLPSTRUCT);
SMESSAGEPROTO(INLPHELPINFOSTRUCT);      // WINHELP4
SMESSAGEPROTO(INLPDRAWITEMSTRUCT);
SMESSAGEPROTO(INOUTLPMEASUREITEMSTRUCT);
SMESSAGEPROTO(INSTRING);
SMESSAGEPROTO(INPOSTEDSTRING);
SMESSAGEPROTO(INSTRINGNULL);
SMESSAGEPROTO(OUTSTRING);
SMESSAGEPROTO(INCNTOUTSTRING);
SMESSAGEPROTO(POUTLPINT);
SMESSAGEPROTO(POPTINLPUINT);
SMESSAGEPROTO(INOUTLPWINDOWPOS);
SMESSAGEPROTO(INLPWINDOWPOS);
SMESSAGEPROTO(INLBOXSTRING);
SMESSAGEPROTO(OUTLBOXSTRING);
SMESSAGEPROTO(INCBOXSTRING);
SMESSAGEPROTO(OUTCBOXSTRING);
SMESSAGEPROTO(INCNTOUTSTRINGNULL);
SMESSAGEPROTO(INOUTDRAG);
SMESSAGEPROTO(FULLSCREEN);
SMESSAGEPROTO(INPAINTCLIPBRD);
SMESSAGEPROTO(INSIZECLIPBRD);
SMESSAGEPROTO(OUTDWORDDWORD);
SMESSAGEPROTO(OUTDWORDINDWORD);
SMESSAGEPROTO(OPTOUTLPDWORDOPTOUTLPDWORD);
SMESSAGEPROTO(DWORDOPTINLPMSG);
SMESSAGEPROTO(COPYGLOBALDATA);
SMESSAGEPROTO(COPYDATA);
SMESSAGEPROTO(INDESTROYCLIPBRD);
SMESSAGEPROTO(INOUTNEXTMENU);
SMESSAGEPROTO(INOUTSTYLECHANGE);
SMESSAGEPROTO(IMAGEIN);
SMESSAGEPROTO(IMAGEOUT);
SMESSAGEPROTO(INDEVICECHANGE);
SMESSAGEPROTO(INOUTMENUGETOBJECT);
SMESSAGEPROTO(POWERBROADCAST);
SMESSAGEPROTO(LOGONNOTIFY);
SMESSAGEPROTO(IMECONTROL);
SMESSAGEPROTO(IMEREQUEST);
SMESSAGEPROTO(INLPKDRAWSWITCHWND);
SMESSAGEPROTO(OUTLPCOMBOBOXINFO);
SMESSAGEPROTO(OUTLPSCROLLBARINFO);

/***************************************************************************\
* Function Prototypes
*
* NOTE: Only prototypes for GLOBAL (across module) functions should be put
* here. Prototypes for functions that are global to a single module should
* be put at the head of that module.
*
* LATER: There's still lots of bogus trash in here to be cleaned out.
*
\***************************************************************************/

/*
 * Random prototypes.
 */
DWORD _GetWindowContextHelpId(
    PWND pwnd);

BOOL _SetWindowContextHelpId(
    PWND pwnd,
    DWORD dwContextId);

void xxxSendHelpMessage(
    PWND   pwnd,
    int    iType,
    int    iCtrlId,
    HANDLE hItemHandle,
    DWORD  dwContextId);

HPALETTE _SelectPalette(
    HDC hdc,
    HPALETTE hpalette,
    BOOL fForceBackground);

int xxxRealizePalette(
    HDC hdc);

VOID xxxFlushPalette(
    PWND pwnd);

VOID xxxBroadcastPaletteChanged(
    PWND pwnd,
    BOOL fForceDesktop);

PCURSOR SearchIconCache(
    PCURSOR         pCursorCache,
    ATOM            atomModName,
    PUNICODE_STRING pstrResName,
    PCURSOR         pCursorSrc,
    PCURSORFIND     pcfSearch);

VOID ZombieCursor(PCURSOR pcur);

BOOL IsSmallerThanScreen(PWND pwnd);

BOOL zzzSetSystemCursor(
    PCURSOR pcur,
    DWORD   id);

BOOL zzzSetSystemImage(
    PCURSOR pcur,
    PCURSOR pcurOld);

BOOL _InternalGetIconInfo(
    IN  PCURSOR                  pcur,
    OUT PICONINFO                piconinfo,
    OUT OPTIONAL PUNICODE_STRING pstrModName,
    OUT OPTIONAL PUNICODE_STRING pstrResName,
    OUT OPTIONAL LPDWORD         pbpp,
    IN  BOOL                     fInternalCursor);

VOID LinkCursor(
    PCURSOR pcur);

BOOL _SetCursorIconData(
    PCURSOR         pcur,
    PUNICODE_STRING pstrModName,
    PUNICODE_STRING pstrResName,
    PCURSORDATA     pData,
    DWORD           cbData);

PCURSOR _GetCursorFrameInfo(
    PCURSOR pcur,
    int     iFrame,
    PJIF    pjifRate,
    LPINT   pccur);

BOOL zzzSetSystemCursor(
    PCURSOR pcur,
    DWORD id);

PCURSOR _FindExistingCursorIcon(
    ATOM            atomModName,
    PUNICODE_STRING pstrResName,
    PCURSOR         pcurSrc,
    PCURSORFIND     pcfSearch);

HCURSOR _CreateEmptyCursorObject(
    BOOL fPublic);

BOOL _GetUserObjectInformation(HANDLE h,
    int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded);
BOOL _SetUserObjectInformation(HANDLE h,
    int nIndex, PVOID pvInfo, DWORD nLength);
DWORD xxxWaitForInputIdle(ULONG_PTR idProcess, DWORD dwMilliseconds,
        BOOL fSharedWow);
VOID StartScreenSaver(BOOL bOnlyIfSecure);
UINT InternalMapVirtualKeyEx(UINT wCode, UINT wType, PKBDTABLES pKbdTbl);
SHORT InternalVkKeyScanEx(WCHAR cChar, PKBDTABLES pKbdTbl);



PWND ParentNeedsPaint(PWND pwnd);
VOID SetHungFlag(PWND pwnd, WORD wFlag);
VOID ClearHungFlag(PWND pwnd, WORD wFlag);

BOOL _DdeSetQualityOfService(PWND pwndClient,
        CONST PSECURITY_QUALITY_OF_SERVICE pqosNew,
        PSECURITY_QUALITY_OF_SERVICE pqosOld);
BOOL _DdeGetQualityOfService(PWND pwndClient,
        PWND pwndServer, PSECURITY_QUALITY_OF_SERVICE pqos);

BOOL QueryTrackMouseEvent(LPTRACKMOUSEEVENT lpTME);
void CancelMouseHover(PQ pq);
void ResetMouseTracking(PQ pq, PWND pwnd);

void _SetIMEShowStatus(BOOL fShow);
BOOL _GetIMEShowStatus(VOID);

/*
 * Prototypes for internal version of APIs.
 */
PWND _FindWindowEx(PWND pwndParent, PWND pwndChild,
                              LPCWSTR pszClass, LPCWSTR pszName, DWORD dwType);
UINT APIENTRY GreSetTextAlign(HDC, UINT);
UINT APIENTRY GreGetTextAlign(HDC);

/*
 * Prototypes for validation, RIP, error handling, etc functions.
 */
PWND FASTCALL   ValidateHwnd(HWND hwnd);

NTSTATUS ValidateHwinsta(HWINSTA, KPROCESSOR_MODE, ACCESS_MASK, PWINDOWSTATION*);
NTSTATUS ValidateHdesk(HDESK, KPROCESSOR_MODE, ACCESS_MASK, PDESKTOP*);

PMENU           ValidateHmenu(HMENU hmenu);
PMONITOR        ValidateHmonitor(HMONITOR hmonitor);
HRGN            UserValidateCopyRgn(HRGN);

BOOL    ValidateHandleSecure(HANDLE h);

NTSTATUS UserJobCallout(PKWIN32_JOBCALLOUT_PARAMETERS Parm);

BOOL RemoveProcessFromJob(PPROCESSINFO ppi);


BOOL    xxxActivateDebugger(UINT fsModifiers);

void ClientDied(void);

VOID    SendMsgCleanup(PTHREADINFO ptiCurrent);
VOID    ReceiverDied(PSMS psms, PSMS *ppsmsUnlink);
LRESULT xxxInterSendMsgEx(PWND, UINT, WPARAM, LPARAM, PTHREADINFO, PTHREADINFO, PINTRSENDMSGEX );
VOID    ClearSendMessages(PWND pwnd);
PPCLS   GetClassPtr(ATOM atom, PPROCESSINFO ppi, HANDLE hModule);
BOOL    ReferenceClass(PCLS pcls, PWND pwnd);
VOID    DereferenceClass(PWND pwnd);
ULONG_PTR MapClientToServerPfn(ULONG_PTR dw);


VOID xxxReceiveMessage(PTHREADINFO);
#define xxxReceiveMessages(pti) \
    while ((pti)->pcti->fsWakeBits & QS_SENDMESSAGE) { xxxReceiveMessage((pti)); }

PBWL     BuildHwndList(PWND pwnd, UINT flags, PTHREADINFO ptiOwner);
VOID     FreeHwndList(PBWL pbwl);

#define  MINMAX_KEEPHIDDEN 0x1
#define  MINMAX_ANIMATE    0x10000

PWND     xxxMinMaximize(PWND pwnd, UINT cmd, DWORD dwFlags);
void     xxxMinimizeHungWindow(PWND pwnd);
VOID     xxxInitSendValidateMinMaxInfo(PWND pwnd, LPMINMAXINFO lpmmi);
HRGN     CreateEmptyRgn(void);
HRGN     CreateEmptyRgnPublic(void);
HRGN     SetOrCreateRectRgnIndirectPublic(HRGN * phrgn, LPCRECT lprc);
BOOL     SetEmptyRgn(HRGN hrgn);
BOOL     SetRectRgnIndirect(HRGN hrgn, LPCRECT lprc);
void     RegisterCDROMNotify(void);
NTSTATUS xxxRegisterForDeviceClassNotifications();
VOID     xxxUnregisterDeviceClassNotifications();
BOOL     xxxInitInput(PTERMINAL);
VOID     InitMice();
void     UpdateMouseInfo(void);
BOOL     OpenMouse(PDEVICEINFO pMouseInfo);
void     ProcessDeviceChanges(DWORD DeviceType);
PDEVICEINFO CreateDeviceInfo(DWORD DeviceType, PUNICODE_STRING SymbolicLinkName, BYTE bFlags);
void     InitKeyboard(void);
void     InitKeyboardState(void);
UINT     xxxHardErrorControl(DWORD, HANDLE, PDESKRESTOREDATA);

#define MAX_RETRIES_TO_OPEN 30

#define UPDATE_KBD_TYPEMATIC 1
#define UPDATE_KBD_LEDS      2

VOID     SetKeyboardRate(UINT nKeySpeed);
VOID     RecolorDeskPattern(VOID);
BOOL     xxxInitWindowStation(VOID);
VOID     zzzInternalSetCursorPos(int x, int y);
VOID     UpdateKeyLights(BOOL bInjected);
VOID     SetDebugHotKeys(VOID);
VOID     BoundCursor(LPPOINT lppt);

void     DestroyKF(PKBDFILE pkf);
VOID     DestroyKL(PKL pkl);
VOID     CleanupKeyboardLayouts(VOID);

BOOL     xxxSetDeskPattern(PUNICODE_STRING pProfileUserName,LPWSTR lpPat, BOOL fCreation);
BOOL     xxxSetDeskWallpaper(PUNICODE_STRING pProfileUserName,LPWSTR lpszFile);
HPALETTE CreateDIBPalette(LPBITMAPINFOHEADER pbmih, UINT colors);
BOOL     CalcVisRgn(HRGN* hrgn, PWND pwndOrg, PWND pwndClip, DWORD flags);

NTSTATUS xxxCreateThreadInfo(PETHREAD pEThread);

BOOL     DestroyProcessInfo(PW32PROCESS);


VOID    RawInputThread(PVOID pVoid);
HANDLE  GetRemoteProcessId(VOID);
VOID    HandleSystemThreadCreationFailure(BOOL bRemoteThread);
VOID    xxxCreateSystemThreads(BOOL bRemoteThread);

VOID     xxxDesktopThread(PTERMINAL pTerm);
VOID     ForceEmptyClipboard(PWINDOWSTATION);

NTSTATUS zzzInitTask(UINT dwExpWinVer, DWORD dwAppCompatFlags, DWORD dwUserWOWCompatFlags,
                PUNICODE_STRING pstrModName, PUNICODE_STRING pstrBaseFileName,
                DWORD hTaskWow, DWORD dwHotkey, DWORD idTask,
                DWORD dwX, DWORD dwY, DWORD dwXSize, DWORD dwYSize);
VOID    DestroyTask(PPROCESSINFO ppi, PTHREADINFO ptiToRemove);
BOOL    PostInputMessage(PQ pq, PWND pwnd, UINT message, WPARAM wParam,
                LPARAM lParam, DWORD time, ULONG_PTR dwExtraInfo);
PWND    PwndForegroundCapture(VOID);
BOOL    xxxSleepThread(UINT fsWakeMask, DWORD Timeout, BOOL fForegroundIdle);
VOID    SetWakeBit(PTHREADINFO pti, UINT wWakeBit);
VOID    WakeSomeone(PQ pq, UINT message, PQMSG pqmsg);
VOID    ClearWakeBit(PTHREADINFO pti, UINT wWakeBit, BOOL fSysCheck);
NTSTATUS xxxInitProcessInfo(PW32PROCESS);

PTHREADINFO PtiFromThreadId(DWORD idThread);
BOOL    zzzAttachThreadInput(PTHREADINFO ptiAttach, PTHREADINFO ptiAttachTo, BOOL fAttach);
BOOL    zzzReattachThreads(BOOL fJournalAttach);
PQ      AllocQueue(PTHREADINFO, PQ);
VOID    FreeQueue(PQ pq);


VOID    FreeCachedQueues(VOID);
VOID    CleanupGDI(VOID);
VOID    CleanupResources(VOID);

VOID    zzzDestroyQueue(PQ pq, PTHREADINFO pti);
PQMSG   AllocQEntry(PMLIST pml);
__inline VOID FreeQEntry(PQMSG pqmsg)
{
    extern PPAGED_LOOKASIDE_LIST QEntryLookaside;
    ExFreeToPagedLookasideList(QEntryLookaside, pqmsg);
}

VOID    DelQEntry(PMLIST pml, PQMSG pqmsg);
VOID    zzzAttachToQueue(PTHREADINFO pti, PQ pqAttach, PQ pqJournal,
        BOOL fJoiningForeground);
VOID    xxxProcessEventMessage(PTHREADINFO ptiCurrent, PQMSG pqmsg);
VOID    xxxProcessSetWindowPosEvent(PSMWP psmwpT);
VOID    xxxProcessAsyncSendMessage(PASYNCSENDMSG pmsg);
BOOL    PostEventMessage(PTHREADINFO pti, PQ pq, DWORD dwQEvent, PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);

BOOL    xxxDoPaint(PWND pwndFilter, LPMSG lpMsg);
BOOL    DoTimer(PWND pwndFilter);
BOOL    CheckPwndFilter(PWND pwnd, PWND pwndFilter);

#define WHT_IGNOREDISABLED      0x00000001

#ifdef REDIRECTION

#define WHT_FAKESPEEDHITTEST    0x00000002

PWND    xxxCallSpeedHitTestHook(POINT* ppt);
VOID    PushMouseMove(PQ pq, POINT pt);
VOID    PopMouseMove(PQ pq, POINT* ppt);

#endif // REDIRECTION

BOOL    xxxGetCursorPos(LPPOINT lpPt);
HWND    xxxWindowHitTest(PWND pwnd,  POINT pt, int *pipos, DWORD dwHitTestFlags);
HWND    xxxWindowHitTest2(PWND pwnd, POINT pt, int *pipos, DWORD dwHitTestFlags);

PWND    SpeedHitTest(PWND pwndParent, POINT pt);
VOID    xxxDeactivate(PTHREADINFO pti, DWORD tidSetForeground);

#define SFW_STARTUP             0x0001
#define SFW_SWITCH              0x0002
#define SFW_NOZORDER            0x0004
#define SFW_SETFOCUS            0x0008
#define SFW_ACTIVATERESTORE     0x0010

BOOL    xxxSetForegroundWindow2(PWND pwnd, PTHREADINFO ptiCurrent, DWORD fFlags);
VOID    SetForegroundThread(PTHREADINFO pti);
VOID    xxxSendFocusMessages(PTHREADINFO pti, PWND pwndReceive);

#define ATW_MOUSE               0x0001
#define ATW_SETFOCUS            0x0002
#define ATW_ASYNC               0x0004
#define ATW_NOZORDER            0x0008

BOOL    FBadWindow(PWND pwnd);
BOOL    xxxActivateThisWindow(PWND pwnd, DWORD tidLoseForeground, DWORD fFlags);
BOOL    xxxActivateWindow(PWND pwnd, UINT cmd);

#define NTW_PREVIOUS         1
#define NTW_IGNORETOOLWINDOW 2
PWND    NextTopWindow(PTHREADINFO pti, PWND pwnd, PWND pwndSkip, DWORD flags);

int     xxxMouseActivate(PTHREADINFO pti, PWND pwnd, UINT message, WPARAM wParam, LPPOINT lppt, int ht);
int     UT_GetParentDCClipBox(PWND pwnd, HDC hdc, LPRECT lprc);
VOID    UpdateAsyncKeyState(PQ pq, UINT wVK, BOOL fBreak);
void    PostUpdateKeyStateEvent(PQ pq);
void    ProcessUpdateKeyStateEvent(PQ pq, CONST PBYTE pbKeyState, CONST PBYTE pbRecentDown);

BOOL    InternalSetProp(PWND pwnd, LPWSTR pszKey, HANDLE hData, DWORD dwFlags);
HANDLE  InternalRemoveProp(PWND pwnd, LPWSTR pszKey, BOOL fInternal);
VOID    DeleteProperties(PWND pwnd);
CHECKPOINT *CkptRestore(PWND pwnd, LPCRECT lprcWindow);
UINT_PTR _SetTimer(PWND pwnd, UINT_PTR nIDEvent, UINT dwElapse, TIMERPROC_PWND pTimerFunc);
BOOL    KillTimer2(PWND pwnd, UINT_PTR nIDEvent, BOOL fSystemTimer);
VOID    DestroyThreadsTimers(PTHREADINFO pti);
VOID    DecTimerCount(PTHREADINFO pti);
VOID    zzzInternalShowCaret();
VOID    zzzInternalHideCaret();
VOID    zzzInternalDestroyCaret();
VOID    ChangeAcquireResourceType(VOID);
VOID    EnterCrit(VOID);
VOID    EnterSharedCrit(VOID);
VOID    LeaveCrit(VOID);
VOID    _AssertCritIn(VOID);
VOID    _AssertDeviceInfoListCritIn(VOID);
VOID    _AssertCritInShared(VOID);
VOID    _AssertCritOut(VOID);
VOID    _AssertDeviceInfoListCritOut(VOID);
NTSTATUS _KeUserModeCallback(
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    OUT PULONG OutputLength);


#define UnlockProcess           ObDereferenceObject
#define UnlockThread            ObDereferenceObject

extern ULONG gSessionId;

#if DBG
    #define ValidateProcessSessionId(pEProcess)  \
        UserAssert(PsGetProcessSessionId(pEProcess) == gSessionId)

    #define ValidateThreadSessionId(pEThread)  \
        UserAssert(PsGetThreadSessionId(pEThread) == gSessionId)
#else
    #define ValidateProcessSessionId(pEProcess)
    #define ValidateThreadSessionId(pEThread)
#endif


__inline NTSTATUS LockProcessByClientId(
    HANDLE dwProcessId,
    PEPROCESS* ppEProcess)
{
    NTSTATUS Status;

    Status = PsLookupProcessByProcessId(dwProcessId, ppEProcess);

    if (NT_SUCCESS(Status) && (PsGetProcessSessionId(*ppEProcess) != gSessionId)) {
        UnlockProcess(*ppEProcess);
        return STATUS_UNSUCCESSFUL;
    }

    return Status;
}

__inline NTSTATUS LockThreadByClientId(
    HANDLE dwThreadId,
    PETHREAD* ppEThread)
{
    NTSTATUS Status;

    Status = PsLookupThreadByThreadId(dwThreadId, ppEThread);

    if (NT_SUCCESS(Status) && (PsGetThreadSessionId(*ppEThread) != gSessionId)) {
        UnlockThread(*ppEThread);
        return STATUS_UNSUCCESSFUL;
    }

    return Status;
}

BOOL    IsSAS(BYTE vk, UINT* pfsModifiers);
BOOL    xxxDoHotKeyStuff(UINT vk, BOOL fBreak, DWORD fsReserveKeys);
PHOTKEY IsHotKey(UINT fsModifiers, UINT vk);
void    ClearCachedHotkeyModifiers(void);

/*
 * Server.c
 */
#define USER_WINDOWSECT_SIZE       512
#define USER_NOIOSECT_SIZE         128
#define USR_LOGONSECT_SIZE         128
#define USR_DISCONNECTSECT_SIZE    64
#define NOIO_DESKTOP_NUMBER        10

BOOL InitCreateUserCrit(VOID);
PMDEV InitVideo(
    BOOL bReenumerationNeeded);

/*
 * DRVSUP.C
 */
BOOL InitUserScreen();

VOID InitLoadResources();

typedef struct tagDISPLAYRESOURCE {
    WORD cyThunb;
    WORD cxThumb;
    WORD xCompressIcon;
    WORD yCompressIcon;
    WORD xCompressCursor;
    WORD yCompressCursor;
    WORD yKanji;
    WORD cxBorder;
    WORD cyBorder;
} DISPLAYRESOURCE, *PDISPLAYRESOURCE;



VOID xxxUserResetDisplayDevice(VOID);

/*
 * Object management and security
 */
#define DEFAULT_WINSTA  L"\\Windows\\WindowStations\\WinSta0"

#define POBJECT_NAME(pobj) (OBJECT_HEADER_TO_NAME_INFO(OBJECT_TO_OBJECT_HEADER(pobj)) ? \
    &(OBJECT_HEADER_TO_NAME_INFO(OBJECT_TO_OBJECT_HEADER(pobj))->Name) : NULL)

PSECURITY_DESCRIPTOR CreateSecurityDescriptor(PACCESS_ALLOWED_ACE paceList,
        DWORD cbAce, BOOLEAN fDaclDefaulted);
PACCESS_ALLOWED_ACE AllocAce(PACCESS_ALLOWED_ACE pace, BYTE bType,
        BYTE bFlags, ACCESS_MASK am, PSID psid, LPDWORD lpdwLength);
BOOL CheckGrantedAccess(ACCESS_MASK, ACCESS_MASK);
BOOL AccessCheckObject(PVOID, ACCESS_MASK, KPROCESSOR_MODE, CONST GENERIC_MAPPING *);
BOOL InitSecurity(VOID);
BOOL IsPrivileged(PPRIVILEGE_SET ppSet);
BOOL CheckWinstaWriteAttributesAccess(void);

HWINSTA xxxConnectService(PUNICODE_STRING, HDESK *);
NTSTATUS TestForInteractiveUser(PLUID pluidCaller);
NTSTATUS _UserTestForWinStaAccess( PUNICODE_STRING pstrWinSta, BOOL fInherit);
HDESK xxxResolveDesktop(HANDLE hProcess, PUNICODE_STRING pstrDesktop,
    HWINSTA *phwinsta, BOOL fInherit, BOOL* pbShutDown);

NTSTATUS xxxResolveDesktopForWOW(
    IN OUT PUNICODE_STRING pstrDesktop);

WORD xxxClientWOWGetProcModule(WNDPROC_PWND pfn);
DWORD xxxClientWOWTask16SchedNotify(DWORD NotifyParm,DWORD dwParam);

PVOID _MapDesktopObject(HANDLE h);
PDESKTOPVIEW GetDesktopView(PPROCESSINFO ppi, PDESKTOP pdesk);
VOID TerminateConsole(PDESKTOP);


/*
 * Object manager callouts for windowstations
 */
NTSTATUS DestroyWindowStation(
     PKWIN32_CLOSEMETHOD_PARAMETERS pCloseParams );

NTSTATUS FreeWindowStation(
     PKWIN32_DELETEMETHOD_PARAMETERS pDeleteParams );

NTSTATUS ParseWindowStation(
     PKWIN32_PARSEMETHOD_PARAMETERS pParseParams );

NTSTATUS OkayToCloseWindowStation(
     PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS pOkCloseParams);

NTSTATUS WindowStationOpenProcedure(
     PKWIN32_OPENMETHOD_PARAMETERS pOpenParams);

/*
 * Object manager callouts for desktops
 */
NTSTATUS DesktopOpenProcedure(
    PKWIN32_OPENMETHOD_PARAMETERS pOpenParams);

NTSTATUS MapDesktop(
     PKWIN32_OPENMETHOD_PARAMETERS pOpenParams );

NTSTATUS UnmapDesktop(
     PKWIN32_CLOSEMETHOD_PARAMETERS pCloseParams );

NTSTATUS FreeDesktop(
    PKWIN32_DELETEMETHOD_PARAMETERS pDeleteParams );

NTSTATUS ParseDesktop(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN OUT PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object);

NTSTATUS OkayToCloseDesktop(
    PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS pOkCloseParams);

/*
 * Routines pilfered from kernel32
 */
VOID UserSleep(DWORD dwMilliseconds);
BOOL UserBeep(DWORD dwFreq, DWORD dwDuration);
NTSTATUS UserRtlCreateAtomTable(ULONG NumberOfBuckets);
ATOM UserAddAtom(LPCWSTR lpAtom, BOOL bPin);
ATOM UserFindAtom(LPCWSTR lpAtom);
ATOM UserDeleteAtom(ATOM atom);
UINT UserGetAtomName(ATOM atom, LPWSTR lpch, int cchMax);

#define FindClassAtom(lpszClassName) \
    (IS_PTR(lpszClassName) ? UserFindAtom(lpszClassName) : PTR_TO_ID(lpszClassName))

/*
 * Keyboard Layouts
 */
void SetGlobalKeyboardTableInfo(PKL pklNew);
VOID ChangeForegroundKeyboardTable(PKL pklOld, PKL pklNew);
HKL  xxxLoadKeyboardLayoutEx(PWINDOWSTATION, HANDLE, HKL, UINT,
                             PKBDTABLE_MULTI_INTERNAL,
                             LPCWSTR, UINT, UINT);
HKL  xxxActivateKeyboardLayout(PWINDOWSTATION pwinsta, HKL hkl, UINT Flags, PWND pwnd);
HKL  xxxInternalActivateKeyboardLayout(PKL pkl, UINT Flags, PWND pwnd);
BOOL GetKbdLangSwitch(PUNICODE_STRING pProfileUserName);

BOOL xxxUnloadKeyboardLayout(PWINDOWSTATION, HKL);
VOID RemoveKeyboardLayoutFile(PKBDFILE pkf);
HKL  _GetKeyboardLayout(DWORD idThread);
UINT _GetKeyboardLayoutList(PWINDOWSTATION pwinsta, UINT nItems, HKL *lpBuff);
VOID xxxFreeKeyboardLayouts(PWINDOWSTATION, BOOL bUnlock);

DWORD xxxDragObject(PWND pwndParent, PWND xhwndFrom, UINT wFmt,
        ULONG_PTR dwData, PCURSOR xpcur);
BOOL xxxDragDetect(PWND pwnd, POINT pt);
BOOL xxxIsDragging(PWND pwnd, POINT ptScreen, UINT uMsg);

HKL GetActiveHKL();

#define DMI_INVERT         0x00000001
#define DMI_GRAYED         0x00000002

VOID xxxDrawMenuItem(HDC hdc, PMENU pMenu, PITEM pItem, DWORD dwFlags);
BOOL xxxRealDrawMenuItem(HDC hdc, PGRAYMENU lpGray, int cx, int cy);
VOID xxxDrawMenuBarUnderlines(PWND pwnd, BOOL fShow);
UINT MNItemHitTest(PMENU pMenu, PWND pwnd, POINT pt);


/*
 * Menu macros
 */
__inline BOOL IsRootPopupMenu(PPOPUPMENU ppopupmenu)
{
    return (ppopupmenu == ppopupmenu->ppopupmenuRoot);
}
__inline BOOL ExitMenuLoop (PMENUSTATE pMenuState, PPOPUPMENU ppopupmenu)
{
    return  (!pMenuState->fInsideMenuLoop || ppopupmenu->fDestroyed);
}
__inline PMENUSTATE GetpMenuState (PWND pwnd)
{
    return (GETPTI(pwnd)->pMenuState);
}
__inline PPOPUPMENU GetpGlobalPopupMenu (PWND pwnd)
{
    return (GetpMenuState(pwnd) ? GetpMenuState(pwnd)->pGlobalPopupMenu : NULL);
}
__inline BOOL IsInsideMenuLoop(PTHREADINFO pti)
{
    return ((pti->pMenuState != NULL) && pti->pMenuState->fInsideMenuLoop);
}
__inline BOOL IsMenuStarted(PTHREADINFO pti)
{
    return ((pti->pMenuState != NULL) && pti->pMenuState->fMenuStarted);
}
__inline PITEM MNGetToppItem(PMENU pMenu)
{
    return pMenu->rgItems + pMenu->iTop;
}
__inline BOOL MNIsItemSelected(PPOPUPMENU ppopupmenu)
{
    return ((int)ppopupmenu->posSelectedItem >= 0);
}
__inline PITEM MNGetSelectedpitem(PPOPUPMENU ppopupmenu)
{
    return ppopupmenu->spmenu->rgItems + ppopupmenu->posSelectedItem;
}
__inline BOOL MNIsScrollArrowSelected(PPOPUPMENU ppopupmenu)
{
    return ((ppopupmenu->posSelectedItem == MFMWFP_UPARROW)
            || (ppopupmenu->posSelectedItem == MFMWFP_DOWNARROW));
}
__inline BOOL IsModelessMenuNotificationWindow (PWND pwnd)
{
    PMENUSTATE pMenuState;
    return (((pMenuState = GetpMenuState(pwnd)) != NULL)
                && pMenuState->fModelessMenu
                && (pMenuState->pGlobalPopupMenu->spwndNotify == pwnd));
}
__inline BOOL IsRecursedMenuState(PMENUSTATE pMenuState, PPOPUPMENU ppopupmenu)
{
    return (pMenuState->pGlobalPopupMenu != ppopupmenu->ppopupmenuRoot);
}

__inline BOOL IsMDIItem (PITEM pitem)
{
   return (TestMFS(pitem, MFS_CACHEDBMP)
      && (pitem->hbmp != NULL)
      && (pitem->hbmp <= HBMMENU_MBARLAST));
}

/*
 * This definition for CM_MODE_TRANSITION must match the one in ntcon\inc\server.h
 */

#define CM_MODE_TRANSITION       (WM_USER+6)

#define MNXBORDER (SYSMET(CXBORDER) + SYSMET(CXEDGE))
#define MNYBORDER (SYSMET(CYBORDER) + SYSMET(CYEDGE))
#define MNXSPACE  (SYSMET(CXEDGE))
#define MNLEFTMARGIN (SYSMET(CXEDGE))

/*
 * xxxMNUpdateShownMenu flags
 */
#define MNUS_DEFAULT      0x00000001
#define MNUS_DELETE       0x00000002
#define MNUS_DRAWFRAME    0x00000004

/* This tells xxxMNItemSize that the bitamp size is not avilable */
#define MNIS_MEASUREBMP -1


/*
 * MN_SIZEWINDOW wParam flag. xxxMNUpdateShownMenu sends this
 *  message, so keep MNSW_ and MNUS_ in sync.
 */
#define MNSW_RETURNSIZE  0
#define MNSW_SIZE        MNUS_DEFAULT
#define MNSW_DRAWFRAME   MNUS_DRAWFRAME

/*
 * Animation flags (pMenuState->iAniDropDir)
 */
#define PAS_RIGHT       (TPM_HORPOSANIMATION >> TPM_FIRSTANIBITPOS)
#define PAS_LEFT        (TPM_HORNEGANIMATION >> TPM_FIRSTANIBITPOS)
#define PAS_DOWN        (TPM_VERPOSANIMATION >> TPM_FIRSTANIBITPOS)
#define PAS_UP          (TPM_VERNEGANIMATION >> TPM_FIRSTANIBITPOS)
#define PAS_OUT         0x10
#define PAS_HORZ        (PAS_LEFT | PAS_RIGHT)
#define PAS_VERT        (PAS_UP | PAS_DOWN)

#if (PAS_HORZ + PAS_VERT >= PAS_OUT)
#error PAS_ & TPM_*ANIMATION conflict.
#endif

#define CXMENU3DEDGE 1
#define CYMENU3DEDGE 1

/*
 * Scrollbar initialization types
 */
#define SCROLL_NORMAL   0
#define SCROLL_DIRECT   1
#define SCROLL_MENU     2

/*
 * movesize.c
 */
void xxxDrawDragRect(PMOVESIZEDATA pmsd, LPRECT lprc, UINT flags);
void GetMonitorMaxArea(PWND pwnd, PMONITOR pMonitor, LPRECT * pprc);

/*
 * focusact.c
 */
VOID SetForegroundPriorityProcess(PPROCESSINFO ppi, PTHREADINFO pti, BOOL fSetForegound);
VOID SetForegroundPriority(PTHREADINFO pti, BOOL fSetForeground);
void xxxUpdateTray(PWND pwnd);


//
// mnchange.c
//
void xxxMNUpdateShownMenu(PPOPUPMENU ppopup, PITEM pItem, UINT uFlags);

//
// mnkey.c
//
UINT xxxMNFindChar(PMENU pMenu, UINT ch, INT idxC, INT *lpr);
UINT MNFindItemInColumn(PMENU pMenu, UINT idxB, int dir, BOOL fRoot);

//
// mndraw.c
//
void MNAnimate(PMENUSTATE pMenuState, BOOL fIterate);
void MNDrawFullNC(PWND pwnd, HDC hdcIn, PPOPUPMENU ppopup);
void MNDrawArrow(HDC hdcIn, PPOPUPMENU ppopup, UINT uArrow);
void MNEraseBackground (HDC hdc, PMENU pmenu, int x, int y, int cx, int cy);
void MNDrawEdge(PMENU pmenu, HDC hdc, RECT * prcDraw, UINT nFlags);


//
// mnstate.c
//
PMENUSTATE xxxMNAllocMenuState(PTHREADINFO ptiCurrent, PTHREADINFO ptiNotify, PPOPUPMENU ppopupmenuRoot);
void xxxMNEndMenuState(BOOL fFreePopup);
BOOL MNEndMenuStateNotify (PMENUSTATE pMenuState);
void MNFlushDestroyedPopups (PPOPUPMENU ppopupmenu, BOOL fUnlock);
BOOL MNSetupAnimationDC (PMENUSTATE pMenuState);
BOOL MNCreateAnimationBitmap(PMENUSTATE pMenuState, UINT cx, UINT cy);
void MNDestroyAnimationBitmap(PMENUSTATE pMenuState);
PMENUSTATE xxxMNStartMenuState(PWND pwnd, DWORD cmd, LPARAM lParam);
__inline VOID LockMenuState(
    PMENUSTATE pMenuState)
{
    (pMenuState->dwLockCount)++;
}
BOOL xxxUnlockMenuState (PMENUSTATE pMenuState);

//
// menu.c
//
#if DBG
    VOID Validateppopupmenu(PPOPUPMENU ppopupmenu);
#else // DBG
    #define Validateppopupmenu(ppopupmenu)
#endif // DBG

#if DBG
    #define MNGetpItemIndex DBGMNGetpItemIndex
UINT DBGMNGetpItemIndex(PMENU pmenu, PITEM pitem);
#else // DBG
    #define MNGetpItemIndex _MNGetpItemIndex
#endif // DBG

__inline UINT _MNGetpItemIndex(
    PMENU pmenu,
    PITEM pitem)
{
    return (UINT)(((ULONG_PTR)pitem - (ULONG_PTR)pmenu->rgItems) / sizeof(ITEM));
}

VOID xxxMNDismiss(PMENUSTATE pMenuState);
PITEM MNGetpItem(PPOPUPMENU ppopup, UINT uIndex);
VOID xxxMNSetCapture(PPOPUPMENU ppopup);
VOID xxxMNReleaseCapture(VOID);
VOID MNCheckButtonDownState(PMENUSTATE pMenuState);
PWND GetMenuStateWindow(PMENUSTATE pMenuState);
PVOID LockPopupMenu(PPOPUPMENU ppopup, PMENU * pspmenu, PMENU pmenu);
PVOID UnlockPopupMenu(PPOPUPMENU ppopup, PMENU * pspmenu);
PVOID LockWndMenu(PWND pwnd, PMENU * pspmenu, PMENU pmenu);
PVOID UnlockWndMenu(PWND pwnd, PMENU * pspmenu);
UINT MNSetTimerToCloseHierarchy(PPOPUPMENU ppopup);
BOOL xxxMNSetTop(PPOPUPMENU ppopup, int iNewTop);
LRESULT xxxMenuWindowProc(PWND, UINT, WPARAM, LPARAM);
VOID xxxMNButtonUp(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT posItemHit, LPARAM lParam);
VOID xxxMNButtonDown(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT posItemHit, BOOL fClick);
PITEM xxxMNSelectItem(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT itemPos);
BOOL xxxMNSwitchToAlternateMenu(PPOPUPMENU ppopupMenu);
VOID xxxMNCancel(PMENUSTATE pMenuState, UINT uMsg, UINT cmd, LPARAM lParam);
VOID xxxMNKeyDown(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT key);
BOOL xxxMNDoubleClick(PMENUSTATE pMenuState, PPOPUPMENU ppopup, int idxItem);
VOID xxxMNCloseHierarchy(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState);
PWND xxxMNOpenHierarchy(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState);
VOID LockMFMWFPWindow (PULONG_PTR puHitArea, ULONG_PTR uNewHitArea);
VOID UnlockMFMWFPWindow (PULONG_PTR puHitArea);
BOOL IsMFMWFPWindow (ULONG_PTR uHitArea);
LONG_PTR xxxMNFindWindowFromPoint(PPOPUPMENU ppopupMenu, PUINT pIndex, POINTS screenPt);
VOID xxxMNMouseMove(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, POINTS screenPt);
int xxxMNCompute(PMENU pMenu, PWND pwndNotify, DWORD yMenuTop,
        DWORD xMenuLeft,DWORD cxMax, LPDWORD lpdwHeight);
VOID xxxMNRecomputeBarIfNeeded(PWND pwndNotify, PMENU pMenu);
VOID xxxMenuDraw(HDC hdc, PMENU pMenu);
UINT  MNFindNextValidItem(PMENU pMenu, int i, int dir, UINT flags);
VOID MNFreeItem(PMENU pMenu, PITEM pItem, BOOL fFreeItemPopup);
BOOL   xxxMNStartMenu(PPOPUPMENU ppopupMenu, int mn);
VOID MNPositionSysMenu(PWND pwnd, PMENU pSysMenu);

PITEM xxxMNInvertItem(PPOPUPMENU ppopupmenu, PMENU pMenu,int itemNumber,PWND pwndNotify, BOOL fOn);

VOID   xxxSendMenuSelect(PWND pwndNotify, PWND pwndMenu, PMENU pMenu, int idx);
#define SMS_NOMENU      (PMENU)(-1)


BOOL   xxxSetSystemMenu(PWND pwnd, PMENU pMenu);
BOOL   xxxSetDialogSystemMenu(PWND pwnd);

VOID xxxMNChar(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT character);
PPOPUPMENU MNAllocPopup(BOOL fForceAlloc);
VOID MNFreePopup(PPOPUPMENU ppopupmenu);

/*
 * Menu entry points used by the rest of USER
 */
VOID xxxMNKeyFilter(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT ch);
int  xxxMenuBarCompute(PMENU pMenu, PWND pwndNotify, DWORD yMenuTop,
        DWORD xMenuLeft, int cxMax);
VOID xxxEndMenu(PMENUSTATE pMenuState);
BOOL xxxCallHandleMenuMessages(PMENUSTATE pMenuState, PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL xxxHandleMenuMessages(LPMSG lpmsg, PMENUSTATE pMenuState, PPOPUPMENU ppopupmenu);
void xxxEndMenuLoop (PMENUSTATE pMenuState, PPOPUPMENU ppopupmenu);
int  xxxMNLoop(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, LPARAM lParam, BOOL fDblClk);
VOID xxxSetSysMenu(PWND pwnd);
PMENU xxxGetSysMenuHandle(PWND pwnd);
PMENU xxxGetSysMenu(PWND pwnd, BOOL fSubMenu);
PMENU MakeMenuRtoL(PMENU pMenu, BOOL bRtoL);
HDC CreateCompatiblePublicDC(HDC hdc, HBITMAP *pbmDCGray);
void xxxPSMTextOut(HDC hdc, int xLeft, int yTop, LPWSTR lpsz, int cch, DWORD dwFlags);
BOOL xxxPSMGetTextExtent(HDC hdc, LPWSTR lpstr, int cch, PSIZE psize);

/*
 * LPK callbacks
 */
void xxxClientPSMTextOut(HDC hdc, int xLeft, int yTop, PUNICODE_STRING lpsz, int cch, DWORD dwFlags);
int  xxxClientLpkDrawTextEx(HDC hdc, int xLeft, int yTop, LPCWSTR lpsz, int nCount,
        BOOL fDraw, UINT wFormat, LPDRAWTEXTDATA lpDrawInfo, UINT bAction, int iCharSet);
BOOL xxxClientExtTextOutW(HDC hdc, int x, int y, int flOpts, RECT *prcl,
        LPCWSTR pwsz, UINT cwc, INT *pdx);
BOOL xxxClientGetTextExtentPointW(HDC hdc, LPCWSTR lpstr, int cch, PSIZE psize);

/*
 * Menu Drag and Drop
 */
NTSTATUS xxxClientRegisterDragDrop (HWND hwnd);
NTSTATUS xxxClientRevokeDragDrop (HWND hwnd);
NTSTATUS xxxClientLoadOLE(VOID);
void xxxMNSetGapState (ULONG_PTR uHitArea, UINT uIndex, UINT uFlags, BOOL fSet);
BOOL xxxMNDragOver(POINT * ppt, PMNDRAGOVERINFO pmndoi);
BOOL xxxMNDragLeave(VOID);
void xxxMNUpdateDraggingInfo (PMENUSTATE pMenuState, ULONG_PTR uHitArea, UINT uIndex);

/*
 * Scroll bar entry points
 */
VOID xxxSBTrackInit(PWND pwnd, LPARAM lParam, int curArea, UINT uType);
VOID SBCtlSetup(PSBWND psbwnd);
void CalcSBStuff(PWND pwnd, PSBCALC pSBCalc, BOOL fVert);
void CalcSBStuff2(PSBCALC  pSBCalc, LPRECT lprc, CONST PSBDATA pw, BOOL fVert);
BOOL xxxEnableScrollBar(PWND pwnd, UINT wSBflags, UINT wArrows);
void DrawSize(PWND pwnd, HDC hdc, int cxFrame, int cyFrame);
int xxxScrollWindowEx(PWND pwnd, int dx, int dy, LPRECT prcScroll,
        LPRECT prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, DWORD flags);
void xxxDoScrollMenu(PWND pwndNotify, PWND pwndSB, BOOL fVert, LPARAM lParam);

/*
 * ICONS.C
 */
BOOL xxxInternalEnumWindow(PWND pwndNext, WNDENUMPROC_PWND lpfn, LPARAM lParam, UINT fEnumChildren);
VOID ISV_InitMinMaxInfo(PWND pwnd, PPOINT aptMinMaxWnd);
VOID ISV_ValidateMinMaxInfo(PWND pwnd, PPOINT aptMinMaxWnd);
/*
 * GETSET.C
 */
WORD  _SetWindowWord(PWND pwnd, int index, WORD value);
DWORD xxxSetWindowLong(PWND pwnd, int index, DWORD value, BOOL bAnsi);
ULONG_PTR xxxSetWindowData(PWND pwnd, int index, ULONG_PTR dwData, BOOL bAnsi);
LONG  xxxSetWindowStyle(PWND pwnd, int gwl, DWORD styleNew);
BOOL FCallerOk(PWND pwnd);

int IntersectVisRect(HDC, int, int, int, int);  // Imported from GDI
PCURSOR xxxGetWindowSmIcon(PWND pwnd, BOOL fDontSendMsg);
VOID xxxDrawCaptionBar(PWND pwnd, HDC hdc, UINT fFlags);
VOID xxxDrawScrollBar(PWND pwnd, HDC hdc, BOOL fVert);
VOID xxxTrackBox(PWND, UINT, WPARAM, LPARAM, PSBCALC);
VOID xxxTrackThumb(PWND, UINT, WPARAM, LPARAM, PSBCALC);
VOID xxxEndScroll(PWND pwnd, BOOL fCancel);
VOID xxxDrawWindowFrame(PWND pwnd, HDC hdc, UINT wFlags);
BOOL xxxInternalPaintDesktop(PWND pwnd, HDC hdc, BOOL fPaint);
VOID xxxSysCommand(PWND pwnd, DWORD cmd, LPARAM lParam);
VOID xxxHandleNCMouseGuys(PWND pwnd, UINT message, int htArea, LPARAM lParam);
void xxxCreateClassSmIcon(PCLS pcls);
HICON xxxCreateWindowSmIcon(PWND pwnd, HICON hIconBig, BOOL fCopyFromRes);
BOOL DestroyWindowSmIcon(PWND pwnd);
BOOL DestroyClassSmIcon(PCLS pcls);
UINT DWP_GetHotKey(PWND);
UINT DWP_SetHotKey(PWND, DWORD);
PWND HotKeyToWindow(DWORD);

VOID xxxDWP_DoNCActivate(PWND pwnd, DWORD dwFlags, HRGN hrgnClip);
#define NCA_ACTIVE          0x00000001
#define NCA_FORCEFRAMEOFF   0x00000002

VOID xxxDWP_ProcessVirtKey(UINT key);
BOOL xxxDWP_EraseBkgnd(PWND pwnd, UINT msg, HDC hdc);
VOID SetTiledRect(PWND pwnd, LPRECT lprc, PMONITOR pMonitor);
VOID LinkWindow(PWND pwnd, PWND pwndInsert, PWND pwndParent);
VOID UnlinkWindow(PWND pwndUnlink, PWND pwndParent);
VOID xxxDW_DestroyOwnedWindows(PWND pwndParent);
VOID xxxDW_SendDestroyMessages(PWND pwnd);
VOID xxxFreeWindow(PWND pwnd, PTL ptlpwndFree);
VOID xxxFW_DestroyAllChildren(PWND pwnd);

PHOTKEY FindHotKey(PTHREADINFO pti, PWND pwnd, int id, UINT fsModifiers, UINT vk,
        BOOL fUnregister, PBOOL pfKeysExist);

NTSTATUS _BuildNameList(
        PWINDOWSTATION pwinsta,
        PNAMELIST pNameList,
        UINT cbNameList,
        PUINT pcbNeeded);

VOID xxxHelpLoop(PWND pwnd);

NTSTATUS _BuildPropList(PWND pwnd, PROPSET aPropSet[], UINT cPropMax, PUINT pcPropReturned);
BOOL xxxSendEraseBkgnd(PWND pwnd, HDC hdcBeginPaint, HRGN hrgnUpdate);
LONG xxxSetScrollBar(PWND pwnd, int code, LPSCROLLINFO lpsi, BOOL fRedraw);
VOID IncPaintCount(PWND pwnd);
VOID DecPaintCount(PWND pwnd);
PPROP CreateProp(PWND pwnd);

/*
 * METRICS.C
 */
VOID xxxRecreateSmallIcons(PWND pwnd);

VOID   TransferWakeBit(PTHREADINFO pti, UINT message);
BOOL   SysHasKanji(VOID);
LONG   xxxBroadcastMessage(PWND, UINT, WPARAM, LPARAM, UINT, PBROADCASTMSG );

VOID   zzzSetFMouseMoved();

VOID   TimersProc(VOID);

VOID   PostMove(PQ pq);
VOID   DestroyWindowsTimers(PWND pwnd);

UINT_PTR StartTimers(VOID);

/*==========================================================================*/
/*                                                                          */
/*  Internal Function Declarations                                          */
/*                                                                          */
/*==========================================================================*/

LRESULT xxxTooltipWndProc(PWND, UINT, WPARAM, LPARAM);
LRESULT xxxSwitchWndProc(PWND, UINT, WPARAM, LPARAM);
LRESULT xxxDesktopWndProc(PWND, UINT, WPARAM, LPARAM);

LRESULT xxxSBWndProc(PSBWND, UINT, WPARAM, LPARAM);

VOID   DrawThumb2(PWND, PSBCALC, HDC, HBRUSH, BOOL, UINT);
UINT   GetWndSBDisableFlags(PWND, BOOL);

HANDLE _ConvertMemHandle(LPBYTE lpData, UINT cbData);

VOID zzzRegisterSystemThread (DWORD flags, DWORD reserved);

VOID zzzUpdateCursorImage();
void zzzCalcStartCursorHide(PW32PROCESS Process, DWORD timeAdd);
BOOL FinalUserInit();
BOOL LW_RegisterWindows(VOID);

BOOL xxxSystemParametersInfo(UINT wFlag, DWORD wParam, LPVOID lParam, UINT flags);

PWINDOWSTATION CheckClipboardAccess(VOID);
PCLIP FindClipFormat(PWINDOWSTATION pwinsta, UINT format);
BOOL InternalSetClipboardData(PWINDOWSTATION pwinsta, UINT format,
        HANDLE hData, BOOL fGlobalHandle, BOOL fIncSerialNumber);
VOID xxxDisownClipboard(PWND pwndClipOwner);

VOID CaretBlinkProc(PWND pwnd, UINT message, UINT_PTR id, LPARAM lParam);
VOID xxxRedrawFrame(PWND pwnd);
VOID xxxRedrawFrameAndHook(PWND pwnd);
VOID BltColor(HDC, HBRUSH, HDC, int, int, int, int, int, int, UINT);
VOID StoreMessage(LPMSG pmsg, PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, DWORD time);
VOID StoreQMessage(PQMSG pqmsg, PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, DWORD time, DWORD dwQEvent, ULONG_PTR dwExtraInfo);

#ifdef REDIRECTION
__inline VOID StoreQMessagePti(
    PQMSG pqmsg,
    PTHREADINFO pti)
{
    if (pqmsg->msg.message >= WM_MOUSEFIRST && pqmsg->msg.message <= WM_MOUSELAST) {
        pqmsg->msg.pt.x = LOWORD(pqmsg->msg.lParam);
        pqmsg->msg.pt.y = HIWORD(pqmsg->msg.lParam);
    } else {
        if (pti != NULL)
            pqmsg->msg.pt = pti->ptLast;
    }
    pqmsg->pti = pti;
}
#else
__inline VOID StoreQMessagePti(
    PQMSG pqmsg,
    PTHREADINFO pti)
{
    pqmsg->pti = pti;
}
#endif // REDIRECTION

VOID xxxSendSizeMessage(PWND pwnd, UINT cmdSize);

VOID xxxCheckFocus(PWND pwnd);
VOID OffsetChildren(PWND pwnd, int dx, int dy, LPRECT prcHitTest);

VOID xxxMoveSize(PWND pwnd, UINT cmdMove, DWORD wptStart);
VOID xxxShowOwnedWindows(PWND pwndOwner, UINT cmdShow, HRGN hrgnHung);
VOID xxxAdjustSize(PWND pwnd, LPINT lpcx, LPINT lpcy);

VOID xxxNextWindow(PQ pq, DWORD wParam);
VOID xxxOldNextWindow(UINT flags);
VOID xxxCancelCoolSwitch(void);
VOID RemoveThreadSwitchWindowInfo(PTHREADINFO pti);

VOID xxxCancelTracking(VOID);
VOID xxxCancelTrackingForThread(PTHREADINFO ptiCancel);
VOID xxxCapture(PTHREADINFO pti, PWND pwnd, UINT code);
UINT SystoChar(UINT message, LPARAM lParam);

PHOOK PhkFirstValid(PTHREADINFO pti, int nFilterType);
PHOOK PhkFirstGlobalValid(PTHREADINFO pti, int nFilterType);
VOID  FreeHook(PHOOK phk);
int   xxxCallHook(int, WPARAM, LPARAM, int);
LRESULT xxxCallHook2(PHOOK, int, WPARAM, LPARAM, LPBOOL);
BOOL  xxxCallMouseHook(UINT message, PMOUSEHOOKSTRUCTEX pmhs, BOOL fRemove);
VOID  xxxCallJournalRecordHook(PQMSG pqmsg);
DWORD xxxCallJournalPlaybackHook(PQMSG pqmsg);
VOID  SetJournalTimer(DWORD dt, UINT msgJournal);
VOID  FreeThreadsWindowHooks(VOID);

BOOL xxxSnapWindow(PWND pwnd);

BOOL    DefSetText(PWND pwnd, PLARGE_STRING pstrText);
PWND    DSW_GetTopLevelCreatorWindow(PWND pwnd);
VOID    xxxCalcClientRect(PWND pwnd, LPRECT lprc, BOOL fHungRedraw);
VOID    xxxUpdateClientRect(PWND pwnd);

BOOL   AllocateUnicodeString(PUNICODE_STRING pstrDst, PUNICODE_STRING pstrSrc);

HANDLE CreateDesktopHeap(PWIN32HEAP* ppheapRet, ULONG ulHeapSize);

BOOL xxxSetInternalWindowPos(PWND pwnd, UINT cmdShow, LPRECT lprcWin,
            LPPOINT lpptMin);
VOID xxxMetricsRecalc(UINT wFlags, int dx, int dy, int dyCaption, int dyMenu);

VOID xxxBroadcastDisplaySettingsChange(PDESKTOP, BOOL);


/*
 * This is for SPI_GET/SETUSERPREFERENCE.
 * Currently it's for DWORD values only. A type field will be added so all new
 * settings will be mostly handled through common SystemParametersInfo code.
 */
typedef struct tagPROFILEVALUEINFO {
    DWORD       dwValue;
    UINT        uSection;
    LPCWSTR     pwszKeyName;
} PROFILEVALUEINFO, *PPROFILEVALUEINFO;

/*
 *  SystemParametersInfo UserPreferences manipulation macros.
 *  SPI_ values in the BOOL or DWORD ranges (see winuser.w) are stored in
 *   gpdwCPUserPreferencesMask (BOOL) and gpviCPUserPreferences (DOWRD) (see kernel\globals.c).
 *  The following macros use the actual SPI_ value to determine the
 *   location of a given bit (BOOL mask) or DWORD in those  globals.
 *
 *  Macros to access DWORDs stored in gpviCPUserPreferences.
 *
 */
#define UPIsDWORDRange(uSetting)    \
            ((uSetting) >= SPI_STARTDWORDRANGE && (uSetting) < SPI_MAXDWORDRANGE)

/*
 * The first entry in gpviCPUserPreferences is reserved for the bitmask, so add 1.
 * Each setting has SPI_GET and SPI_SET, so divide by 2 to get the index
 */
#define UPDWORDIndex(uSetting)    \
            (1 + (((uSetting) - SPI_STARTDWORDRANGE) / 2))

/*
 * Macros to access BOOLs stored in gpdwCPUserPreferencesMask.
 */
#define UPIsBOOLRange(uSetting) \
    ((uSetting) >= SPI_STARTBOOLRANGE && (uSetting) < SPI_MAXBOOLRANGE)

/*
 * Each setting has SPI_GET and SPI_SET, so divide by 2 to get the index
 */
#define UPBOOLIndex(uSetting) \
    (((uSetting) - SPI_STARTBOOLRANGE) / 2)

/*
 * Returns a pointer to the DWORD that contains the bit corresponding to uSetting
 */
#define UPBOOLPointer(pdw, uSetting)    \
    (pdw + (UPBOOLIndex(uSetting) / 32))

/*
 * Returns the DWORD mask needed to test/set/clear the bit corresponding to uSetting
 */
#define UPBOOLMask(uSetting)    \
    (1 << (UPBOOLIndex(uSetting) - ((UPBOOLIndex(uSetting) / 32) * 32)))

#define TestUPBOOL(pdw, uSetting)   \
    (*UPBOOLPointer(pdw, uSetting) & UPBOOLMask(uSetting))

#define SetUPBOOL(pdw, uSetting)    \
    (*UPBOOLPointer(pdw, uSetting) |= UPBOOLMask(uSetting))

#define ClearUPBOOL(pdw, uSetting)                              \
{                                                               \
    UserAssert(UPIsBOOLRange(uSetting));                        \
    *UPBOOLPointer(pdw, uSetting) &= ~UPBOOLMask(uSetting);     \
}

/*
 * Use these macros ONLY if UPIsBOOLRange(SPI_GET ## uSetting) is TRUE
 */
#define TestUP(uSetting)    TestUPBOOL(gpdwCPUserPreferencesMask, SPI_GET ## uSetting)
#define SetUP(uSetting)     SetUPBOOL(gpdwCPUserPreferencesMask, SPI_GET ## uSetting)
#define ClearUP(uSetting)   ClearUPBOOL(gpdwCPUserPreferencesMask, SPI_GET ## uSetting)

#define IndexUP(uSetting) \
    (1 << (((uSetting) - SPI_STARTBOOLRANGE) / 2))

/*
 * Some settings (ie, UI Effects) are disabled when TestUP(UISETTINGS) is FALSE.
 */
#define TestEffectUP(uSetting)                                          \
    ((*gpdwCPUserPreferencesMask &                                      \
     (IndexUP(SPI_GET ## uSetting) | IndexUP(SPI_GETUIEFFECTS))) ==     \
     (IndexUP(SPI_GET ## uSetting) | IndexUP(SPI_GETUIEFFECTS)))

/*
 * Some UI effects have an "inverted" disabled value (ie, disabled is TRUE).
 */
#define TestEffectInvertUP(uSetting) (TestUP(uSetting) || !TestUP(UIEFFECTS))

/*
 * Some of these BOOL values are needed in the client side. This macro
 * propagates them to gpsi->PUSIFlags. Note that the SI_ value must match the
 * UPBOOLMask value for this to work fine.
 */
#define PropagetUPBOOLTogpsi(uSetting) \
    UserAssert((DWORD)(PUSIF_ ## uSetting) == (DWORD)UPBOOLMask(SPI_GET ## uSetting)); \
    COPY_FLAG(gpsi->PUSIFlags, TestUP(## uSetting), PUSIF_ ## uSetting)



/*
 * Test if a TS session is connected remotly or locally through the console
 * terminal.
 */
#define IsRemoteConnection() (gProtocolType != PROTOCOL_CONSOLE)
#define IsMultimon()  ((gpDispInfo != NULL)  && (gpDispInfo->cMonitors > 1))
#define GETCONSOLEHDEV() (gfRemotingConsole?gConsoleShadowhDev:gpDispInfo->hDev)

#ifdef IMM_PER_LOGON
BOOL UpdatePerUserImmEnabling(VOID);
#endif
BOOL xxxUpdatePerUserSystemParameters(DWORD dwFlags);
VOID SaveVolatileUserSettings(VOID);

VOID MenuRecalc(VOID);

#define UNDERLINE_RECALC    0x7FFFFFFF      // MAXINT; tells us to recalc underline position


/*
 * Library management routines.
 */
int GetHmodTableIndex(PUNICODE_STRING pstrName);
VOID AddHmodDependency(int iatom);
VOID RemoveHmodDependency(int iatom);
HANDLE xxxLoadHmodIndex(int iatom);
VOID xxxDoSysExpunge(PTHREADINFO pti);


VOID DestroyThreadsObjects(VOID);
VOID MarkThreadsObjects(PTHREADINFO pti);

VOID FreeMessageList(PMLIST pml);
VOID DestroyThreadsHotKeys(VOID);
VOID DestroyWindowsHotKeys(PWND pwnd);

VOID DestroyClass(PPCLS ppcls);
VOID PatchThreadWindows(PTHREADINFO);
VOID DestroyCacheDCEntries(PTHREADINFO);

VOID DestroyProcessesClasses(PPROCESSINFO);

/*
 *  Win16 Task Apis Taskman.c
 */

VOID InsertTask(PPROCESSINFO ppi, PTDB ptdbNew);

BOOL xxxSleepTask(BOOL fInputIdle, HANDLE);

BOOL xxxUserYield(PTHREADINFO pti);
VOID xxxDirectedYield(DWORD dwThreadId);
VOID DirectedScheduleTask(PTHREADINFO ptiOld, PTHREADINFO ptiNew, BOOL bSendMsg, PSMS psms);
VOID WakeWowTask(PTHREADINFO Pti);

/*
 *  WowScheduler assertion for multiple wow tasks running simultaneously
 */

_inline
VOID
EnterWowCritSect(
    PTHREADINFO pti,
    PWOWPROCESSINFO pwpi
)
{
   if (!++pwpi->CSLockCount) {
       pwpi->CSOwningThread = pti;
   } else {
       RIPMSG2(RIP_ERROR,
              "MultipleWowTasks running simultaneously %x %x\n",
              pwpi->CSOwningThread,
              pwpi->CSLockCount);
   }
}

_inline
VOID
ExitWowCritSect(
    PTHREADINFO pti,
    PWOWPROCESSINFO pwpi
)
{
   if (pti == pwpi->CSOwningThread) {
       pwpi->CSOwningThread = NULL;
       pwpi->CSLockCount--;
   }
}


////////////////////////////////////////////////////////////////////////////
//
// These are internal USER functions called from inside and outside the
// critical section (from server & client side). They are a private 'API'.
//
// The prototypes appear in pairs:
//    as called from outside the critsect (from client-side)
//    as called from inside the critsect (from server-side)
// there must be layer code for the 1st function of each pair which validates
// handles, enters the critsect, calls the 2nd of the pair of functions, and
// leaves the critsect again.
//
// Things may have to change when we go client server: InitPwSB() mustn't
// return a pointer to global (server) data! etc.
//
////////////////////////////////////////////////////////////////////////////

BOOL  xxxFillWindow(PWND pwndBrush, PWND pwndPaint, HDC hdc, HBRUSH hbr);
HBRUSH xxxGetControlBrush(PWND pwnd, HDC hdc, UINT msg);
HBRUSH xxxGetControlColor(PWND pwndParent, PWND pwndCtl, HDC hdc, UINT message);
PSBINFO  _InitPwSB(PWND);
BOOL  _KillSystemTimer(PWND pwnd, UINT_PTR nIDEvent);
BOOL  xxxPaintRect(PWND, PWND, HDC, HBRUSH, LPRECT);

////////////////////////////////////////////////////////////////////////////
//
// these are called from stubs.c in the client so will probably go away
//
////////////////////////////////////////////////////////////////////////////


/*
 * From CLASS.C
 */

typedef struct tagWNDCLASSVEREX {
    WNDCLASSEXW;
    LPCWSTR     lpszClassNameVer;
} WNDCLASSVEREX, *LPWNDCLASSVEREX;


PCLS InternalRegisterClassEx(
        LPWNDCLASSVEREX lpwndcls,
        WORD fnid,
        DWORD flags
        );

PCURSOR GetClassIcoCur(PWND pwnd, int index);
PCURSOR xxxSetClassIcon(PWND pwnd, PCLS pcls, PCURSOR pCursor, int gcw);
ULONG_PTR xxxSetClassData(PWND pwnd, int index, ULONG_PTR dwData, BOOL bAnsi);

/*
 * CREATEW.C
 */

#define xxxNVCreateWindowEx(dwStyle, pstrClass, pstrName, style,        \
        x, y, cx, cy, pwndParent, pmenu, hModule, pCreateParams,        \
        dwExpWinVerAndFlags)                                            \
        xxxCreateWindowEx(dwStyle, pstrClass, pstrClass, pstrName,      \
        style, x, y, cx, cy, pwndParent, pmenu, hModule, pCreateParams, \
        dwExpWinVerAndFlags, NULL)

PWND xxxCreateWindowEx(DWORD dwStyle, PLARGE_STRING pstrNVClass, PLARGE_STRING pstrClass,
        PLARGE_STRING pstrName, DWORD style, int x, int y, int cx,
        int cy, PWND pwndParent, PMENU pmenu, HANDLE hModule,
        LPVOID pCreateParams, DWORD dwExpWinVerAndFlags, PACTIVATION_CONTEXT pActCtx);
BOOL xxxDestroyWindow(PWND pwnd);

/*
 * SENDMSG.C
 */
LRESULT xxxSendMessageFF(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam, ULONG_PTR xParam);
LONG xxxSendMessageBSM(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam,
        LPBROADCASTSYSTEMMSGPARAMS pbsmParams);
LRESULT xxxSendMessageEx(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam, ULONG_PTR xParam);
LRESULT xxxSendMessage(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT xxxSendMessageTimeout(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam,
        UINT fuFlags, UINT uTimeout, PLONG_PTR lpdwResult);
BOOL xxxSendNotifyMessage(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
void QueueNotifyMessage(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL xxxSendMessageCallback(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam,
        SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData, BOOL bClientReqest );
BOOL _ReplyMessage(LRESULT lRet);
VOID UserLogError(
    PCWSTR pwszError,
    ULONG cbError,
    NTSTATUS ErrorCode);

/*
 * MN*.C
 */
int xxxTranslateAccelerator(PWND pwnd, LPACCELTABLE pat, LPMSG lpMsg);
BOOL  xxxSetMenu(PWND pwnd, PMENU pmenu, BOOL fRedraw);
VOID  ChangeMenuOwner(PMENU pMenu, PPROCESSINFO ppi);
int   xxxMenuBarDraw(PWND pwnd, HDC hdc, int cxFrame, int cyFrame);
BOOL  xxxDrawMenuBar(PWND pwnd);

UINT xxxPaintMenuBar(PWND pwnd, HDC hdc, int iLeftOffset, int iRightOffset, int iTopOffset, DWORD dwFlags);
UINT xxxCalcMenuBar(PWND pwnd, int iLeftOffset, int iRightOffset, int iTopOffset, LPCRECT prcWnd);

BOOL xxxSetMenuItemInfo(PMENU pMenu, UINT nPos, BOOL fByPosition,
    LPMENUITEMINFOW lpmii, PUNICODE_STRING pstrItem);
BOOL _SetMenuContextHelpId(PMENU pMenu, DWORD dwContextHelpId);
BOOL _SetMenuFlagRtoL(PMENU pMenu);
BOOL xxxInsertMenuItem(PMENU pMenu, UINT wIndex, BOOL fByPosition,
        LPMENUITEMINFOW lpmii, PUNICODE_STRING pstrItem);
BOOL  xxxRemoveMenu(PMENU pMenu, UINT nPos, UINT dwFlags);
BOOL  xxxDeleteMenu(PMENU pMenu, UINT nPos, UINT dwFlags);
BOOL  xxxSetMenuInfo(PMENU pMenu, LPCMENUINFO lpmi);
BOOL  xxxTrackPopupMenuEx(PMENU pmenu, UINT dwFlags, int x, int y,
        PWND pwnd, CONST TPMPARAMS *pparams);
LONG FindBestPos(int x, int y, int cx, int cy, LPRECT prcExclude,
                UINT wFlags, PPOPUPMENU ppopupmenu, PMONITOR pMonitor);
BOOL _SetMenuDefaultItem(PMENU pMenu, UINT wId, BOOL fByPosition);
int xxxMenuItemFromPoint(PWND pwnd, PMENU pMenu, POINT ptScreen);
BOOL xxxGetMenuItemRect(PWND pwnd, PMENU pMenu, UINT uIndex, LPRECT lprcScreen);
PPOPUPMENU MNGetPopupFromMenu(PMENU pMenu, PMENUSTATE *ppMenuState);
PVOID LockDesktopMenu(PMENU * ppmenu, PMENU pmenu);
PVOID UnlockDesktopMenu(PMENU * ppmenu);
#ifdef LAME_BUTTON
PMENU xxxLoadSysDesktopMenu (PMENU * ppmenu, UINT uMenuId, PWND pwnd);
#else
PMENU xxxLoadSysDesktopMenu (PMENU * ppmenu, UINT uMenuId);
#endif // LAME_BUTTON
__inline PVOID UnlockDesktopSysMenu(
    PMENU * ppmenu)
{
    ClearMF(*ppmenu, MFSYSMENU);
    return UnlockDesktopMenu(ppmenu);
}

/*
 * SHOWWIN.C
 */
BOOL xxxShowWindow(PWND pwnd, DWORD cmdShowAnimate);
BOOL _ShowWindowAsync(PWND pwnd, int cmdShow, UINT uWPFlags);
BOOL xxxShowOwnedPopups(PWND pwndOwner, BOOL fShow);

#define RDW_HASWINDOWRGN        0x8000
BOOL xxxSetWindowRgn(PWND pwnd, HRGN hrgn, BOOL fRedraw);

/*
 * SWP.C
 */
void SelectWindowRgn(PWND pwnd, HRGN hrgnClip);
PWND GetTopMostInsertAfter (PWND pwnd);

#define GETTOPMOSTINSERTAFTER(pwnd) \
    (gHardErrorHandler.pti == NULL ? NULL : GetTopMostInsertAfter(pwnd))

__inline BOOL FSwpTopmost(
   PWND pwnd)
{
    return (!!TestWF(pwnd, WEFTOPMOST) ^ !!TestWF(pwnd, WFTOGGLETOPMOST));
}


PWND PWInsertAfter(HWND hwnd);
PWND CalcForegroundInsertAfter(PWND pwnd);
BOOL xxxSetWindowPos(PWND pwnd, PWND pwndInsertAfter, int x, int y,
        int cx, int cy, UINT flags);
PSMWP InternalBeginDeferWindowPos(int cwndGuess);
BOOL AllocateCvr (PSMWP psmwp, int cwndHint);
PSMWP _BeginDeferWindowPos(int cwndGuess);
PSMWP _DeferWindowPos(PSMWP psmwp, PWND pwnd, PWND pwndInsertAfter,
        int x, int y, int cx, int cy, UINT rgf);
BOOL xxxEndDeferWindowPosEx(PSMWP psmwp, BOOL fAsync);
BOOL xxxMoveWindow(PWND pwnd, int x, int y, int cx, int cy, BOOL fRedraw);
PWND GetLastTopMostWindow(VOID);
VOID xxxHandleWindowPosChanged(PWND pwnd, PWINDOWPOS ppos);
VOID IncVisWindows(PWND pwnd);
VOID DecVisWindows(PWND pwnd);
BOOL FVisCountable(PWND pwnd);
VOID SetVisible(PWND pwnd, UINT flags);
VOID ClrFTrueVis(PWND pwnd);

VOID SetWindowState(PWND pwnd, DWORD flags);
VOID ClearWindowState(PWND pwnd, DWORD flags);

BOOL xxxUpdateWindows(PWND pwnd, HRGN hrgn);

VOID SetMinimize(PWND pwnd, UINT uFlags);
#define SMIN_CLEAR            0
#define SMIN_SET              1

PWND NextOwnedWindow(PWND pwnd, PWND pwndOwner, PWND pwndParent);

/*
 * DWP.C
 */
LRESULT xxxDefWindowProc(PWND, UINT, WPARAM, LPARAM);
LRESULT xxxRealDefWindowProc(PWND, UINT, WPARAM, LPARAM);
PWND DWP_GetEnabledPopup(PWND pwndStart);


/*
 * INPUT.C
 */
#ifdef MESSAGE_PUMP_HOOK

BOOL xxxWaitMessageEx(UINT fsWakeMask, DWORD Timeout);
__inline BOOL xxxWaitMessage(
    VOID)
{
    return xxxWaitMessageEx(QS_ALLINPUT | QS_EVENT, 0);
}
BOOL xxxRealWaitMessageEx(UINT fsWakeMask, DWORD Timeout);

#else

BOOL xxxWaitMessage(VOID);

#endif

VOID DBGValidateQueueStates(PDESKTOP pdesk);
VOID IdleTimerProc(VOID);
BOOL ValidateTimerCallback(PTHREADINFO, LPARAM);
VOID zzzWakeInputIdle(PTHREADINFO pti);
VOID SleepInputIdle(PTHREADINFO pti);
BOOL xxxInternalGetMessage(LPMSG lpmsg, HWND hwnd, UINT wMsgFilterMin,
        UINT wMsgFilterMax, UINT wRemoveMsg, BOOL fGetMessage);

#ifdef MESSAGE_PUMP_HOOK
BOOL xxxRealInternalGetMessage(LPMSG lpMsg, HWND hwndFilter, UINT msgMin,
        UINT msgMax, UINT flags, BOOL fGetMessage);
#endif

#define xxxPeekMessage(lpmsg, hwnd, wMsgMin, wMsgMax, wRemoveMsg) \
    xxxInternalGetMessage(lpmsg, hwnd, wMsgMin, wMsgMax, wRemoveMsg, FALSE)
#define xxxGetMessage(lpmsg, hwnd, wMsgMin, wMsgMax) \
    xxxInternalGetMessage(lpmsg, hwnd, wMsgMin, wMsgMax, PM_REMOVE, TRUE)
DWORD _GetMessagePos(VOID);
LRESULT xxxDispatchMessage(LPMSG lpmsg);
UINT GetMouseKeyFlags(PQ pq);
BOOL _PostMessage(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL IPostQuitMessage(PTHREADINFO pti, int nExitCode);
BOOL _PostQuitMessage(int nExitCode);
BOOL _PostThreadMessage(PTHREADINFO pti, UINT message, WPARAM wParam, LPARAM lParam);
BOOL xxxTranslateMessage(LPMSG pmsg, UINT flags);
BOOL _GetInputState(VOID);
DWORD _GetQueueStatus(UINT);
typedef VOID (CALLBACK* MSGWAITCALLBACK)(DWORD DeviceType);
DWORD xxxMsgWaitForMultipleObjects(DWORD nCount, PVOID *apObjects, MSGWAITCALLBACK pfnNonMsg, PKWAIT_BLOCK WaitBlockArray);

BOOL FHungApp(PTHREADINFO pti, DWORD dwTimeFromLastRead);
VOID xxxRedrawHungWindow(PWND pwnd, HRGN hrgnFullDrag);
VOID xxxRedrawHungWindowFrame(PWND pwnd, BOOL fActive);
VOID zzzActiveCursorTracking (PWND pwnd);
PWND GetActiveTrackPwnd(PWND pwnd, Q **ppq);
int xxxActiveWindowTracking(PWND pwnd, UINT uMsg, int iHitTest);
VOID xxxHungAppDemon(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam);

/*
 * shadow.c
 */
BOOL WindowHasShadow(PWND pwnd);
BOOL xxxAddShadow(PWND pwnd);
VOID xxxRemoveShadow(PWND pwnd);
VOID CleanupShadow(PWND pwndShadow);
VOID MoveShadow(PWND pwnd);
VOID UpdateShadowShape(PWND pwnd);
VOID xxxUpdateShadowZorder(PWND pwnd);
BOOL FAnyShadows(VOID);

/*
 * QUEUE.C
 */
__inline BOOL IsShellProcess(
    PPROCESSINFO ppi)
{
    return ((ppi->rpdeskStartup != NULL)
        && (ppi->rpdeskStartup->pDeskInfo->ppiShellProcess == ppi));
}

__inline DWORD GetAppCompatFlags2ForPti(
    PTHREADINFO pti,
    WORD wVer)
{
    if (wVer < pti->dwExpWinVer) {
        return 0;
    }

    return pti->dwCompatFlags2;
}

VOID ClearWakeMask(VOID);
VOID _AllowForegroundActivation(VOID);

ULONG GetTaskName(PTHREADINFO pti, PWSTR Buffer, ULONG BufferLength);
PQMSG FindQMsg(PTHREADINFO pti, PMLIST pml, PWND pwndFilter, UINT msgMin, UINT msgMax, BOOL bProcessAck);
VOID zzzShowStartGlass(DWORD dwTimeout);
DWORD _GetChangeBits(VOID);
NTSTATUS xxxSetCsrssThreadDesktop(PDESKTOP pdesk, PDESKRESTOREDATA pdrdRestore);
NTSTATUS xxxRestoreCsrssThreadDesktop(PDESKRESTOREDATA pdrdRestore);

PQ GetJournallingQueue(PTHREADINFO pti);
VOID ClearAppStarting (PPROCESSINFO ppi);
BOOL _GetProcessDefaultLayout(DWORD *pdwDefaultLayout);
BOOL _SetProcessDefaultLayout(DWORD dwDefaultLayout);


#ifdef HUNGAPP_GHOSTING

/*
 * GHOST.C
 */
VOID _DisableProcessWindowsGhosting(VOID);
LRESULT xxxGhostWndProc(PWND, UINT, WPARAM, LPARAM);
VOID SignalGhost(PWND pwnd);
BOOL xxxCreateGhost(PWND pwnd);
VOID RemoveGhost(PWND pwnd);
PWND FindGhost(PWND pwnd);
BOOL GhostSizedOrMoved(PWND pwnd);


#define WM_HUNGTHREAD (WM_USER + 0)
#define WM_CREATETRAILTIMER (WM_USER + 1)
#define WM_SCANGHOST (WM_USER + 2)

VOID    GhostThread(PDESKTOP pdesk);

__inline VOID SignalGhost(
    PWND pwnd)
{
    /*
     * No ghosting for applications that are debugged, since it can
     * make debugging confusing to developers.
     */
    if (TestWF(pwnd, WFMINIMIZED) ||
        (GETPTI(pwnd)->ppi->W32PF_Flags & W32PF_DISABLEWINDOWSGHOSTING) ||
        (PsGetProcessDebugPort(GETPTI(pwnd)->ppi->Process) != NULL) ||
        (GetAppCompatFlags2ForPti(GETPTI(pwnd), VERMAX) & GACF2_NOGHOST)) {
        return;
    }

    _PostMessage(PWNDDESKTOP(pwnd), WM_HUNGTHREAD, 0, (LPARAM)HWq(pwnd));
}

#endif // HUNGAPP_GHOSTING

/*
 * TMSWITCH.C
 */
VOID xxxSwitchToThisWindow(PWND pwnd, BOOL fAltTab);

/*
 * TOUNICOD.C
 */
int xxxToUnicodeEx(UINT wVirtKey, UINT wScanCode, CONST BYTE *lpKeyState,
      LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL hkl);
int xxxInternalToUnicode(UINT wVirtKey, UINT wScanCode, CONST IN PBYTE pfvk,
      OUT PWCHAR awchChars, INT cChar, UINT uiTMFlags, OUT PDWORD pdwFlags, HKL hkl);

/*
 * HOTKEYS.C
 */
BOOL _RegisterHotKey(PWND pwnd, int id, UINT fsModifiers, UINT vk);
BOOL _UnregisterHotKey(PWND pwnd, int id);

/*
 * FOCUSACT.C
 */
PWND xxxSetFocus(PWND pwnd);
#ifdef FG_HOOKLOCK
#define FG_HOOKLOCK_PARAM(x)    , x
#else
#define FG_HOOKLOCK_PARAM(x)
#endif
BOOL CanForceForeground(PPROCESSINFO ppi FG_HOOKLOCK_PARAM(PTHREADINFO pti));
BOOL xxxStubSetForegroundWindow(PWND pwnd);
BOOL xxxSetForegroundWindow(PWND pwnd, BOOL fFlash);
PWND xxxSetActiveWindow(PWND pwnd);
PWND _GetActiveWindow(VOID);
BOOL xxxAllowSetForegroundWindow(DWORD dwProcessId);
BOOL _LockSetForegroundWindow(UINT uLockCode);

/*
 * UPDATE.C
 */
BOOL xxxInvalidateRect(PWND pwnd, LPRECT lprc, BOOL fErase);
BOOL xxxValidateRect(PWND pwnd, LPRECT lprc);
BOOL xxxInvalidateRgn(PWND pwnd, HRGN hrgn, BOOL fErase);
BOOL xxxValidateRgn(PWND pwnd, HRGN hrgn);
BOOL xxxUpdateWindow(PWND pwnd);
BOOL xxxGetUpdateRect(PWND pwnd, LPRECT lprc, BOOL fErase);
int  xxxGetUpdateRgn(PWND pwnd, HRGN hrgn, BOOL fErase);
int  _ExcludeUpdateRgn(HDC hdc, PWND pwnd);
int  CalcWindowRgn(PWND pwnd, HRGN hrgn, BOOL fClient);
VOID DeleteUpdateRgn(PWND pwnd);
BOOL xxxRedrawWindow(PWND pwnd, LPRECT lprcUpdate, HRGN hrgnUpdate, DWORD flags);
BOOL IntersectWithParents(PWND pwnd, LPRECT lprc);
VOID xxxInternalInvalidate(PWND pwnd, HRGN hrgnUpdate, DWORD flags);

/*
 * WINMGR.C
 */
BOOL xxxEnableWindow(PWND pwnd, BOOL fEnable);
int xxxGetWindowText(PWND pwnd, LPWSTR psz, int cchMax);
PWND xxxSetParent(PWND pwnd, PWND pwndNewParent);
BOOL xxxFlashWindow(PWND pwnd, DWORD dwFlags, DWORD dwTimeout);
extern ATOM gaFlashWState;
__inline DWORD GetFlashWindowState(
    PWND pwnd)
{
    return HandleToUlong(_GetProp(pwnd, MAKEINTATOM(gaFlashWState), PROPF_INTERNAL));
}

__inline VOID SetFlashWindowState(
    PWND pwnd,
    DWORD dwState)
{
    InternalSetProp(pwnd, MAKEINTATOM(gaFlashWState),
                    (HANDLE)ULongToPtr(dwState), PROPF_INTERNAL | PROPF_NOPOOL);
}
__inline VOID RemoveFlashWindowState(
    PWND pwnd)
{
    InternalRemoveProp(pwnd, MAKEINTATOM(gaFlashWState), PROPF_INTERNAL);
}
BOOL _GetWindowPlacement(PWND pwnd, PWINDOWPLACEMENT pwp);
BOOL xxxSetWindowPlacement(PWND pwnd, PWINDOWPLACEMENT pwp);
BOOL ValidateParentDepth(PWND pwnd, PWND pwndParent);
BOOL ValidateOwnerDepth(PWND pwnd, PWND pwndOwner);
VOID WPUpdateCheckPointSettings (PWND pwnd, UINT uWPFlags);

/*
 * DC.C
 */
HDC  _GetDC(PWND pwnd);
HDC  _GetDCEx(PWND pwnd, HRGN hrgnClip, DWORD flags);
HDC  _GetWindowDC(PWND pwnd);
BOOL _ReleaseDC(HDC hdc);
UINT ReleaseCacheDC(HDC hdc, BOOL fEndPaint);
HDC  CreateCacheDC(PWND, DWORD, PMONITOR);
BOOL DestroyCacheDC(PDCE *, HDC);
VOID InvalidateDce(PDCE pdce);
VOID DeleteHrgnClip(PDCE pdce);
PWND WindowFromCacheDC(HDC hdc);
PWND FastWindowFromDC(HDC hdc);
VOID DelayedDestroyCacheDC(VOID);
PDCE LookupDC(HDC hdc);
HDC GetMonitorDC(PDCE pdceOrig, PMONITOR pMonitor);
BOOL GetDCOrgOnScreen(HDC hdc, LPPOINT ppt);
__inline VOID MarkDCEInvalid(
    PDCE pdce)
{
    /*
     * Clear all bits, but these.
     */
    pdce->DCX_flags &= (DCX_CACHE | DCX_REDIRECTED);

    /*
     * Mark this cache entry as invalid
     */
    pdce->DCX_flags |= DCX_INVALID;
}

BOOL MirrorRegion(PWND pwnd, HRGN hrgn, BOOL bUseClient);

/*
 * PAINT.C
 */
HDC  xxxBeginPaint(PWND pwnd, PAINTSTRUCT *lpps);
BOOL xxxEndPaint(PWND pwnd, PAINTSTRUCT *lpps);

/*
 * CAPTURE.C
 */
PWND xxxSetCapture(PWND pwnd);
BOOL xxxReleaseCapture(VOID);

/*
 * KEYBOARD.C
 */
SHORT _GetAsyncKeyState(int vk);
BOOL _SetKeyboardState(CONST BYTE *pKeyboard);
int _GetKeyboardType(int nTypeFlag);
VOID RegisterPerUserKeyboardIndicators(PUNICODE_STRING pProfileUserName);
VOID UpdatePerUserKeyboardIndicators(PUNICODE_STRING pProfileUserName);
VOID UpdatePerUserKeyboardMappings(PUNICODE_STRING pProfileUserName);

#define TestRawKeyDown(vk)     TestKeyDownBit(gafRawKeyState, vk)
#define SetRawKeyDown(vk)      SetKeyDownBit(gafRawKeyState, vk)
#define ClearRawKeyDown(vk)    ClearKeyDownBit(gafRawKeyState, vk)
#define TestRawKeyToggle(vk)   TestKeyToggleBit(gafRawKeyState, vk)
#define SetRawKeyToggle(vk)    SetKeyToggleBit(gafRawKeyState, vk)
#define ClearRawKeyToggle(vk)  ClearKeyToggleBit(gafRawKeyState, vk)
#define ToggleRawKeyToggle(vk) ToggleKeyToggleBit(gafRawKeyState, vk)

/*
 * XLATE.C
 */
int  _GetKeyNameText(LONG lParam, LPWSTR lpString, int nSize);

/*
 * TIMERS.C
 */
BOOL _KillTimer(PWND pwnd, UINT_PTR nIDEvent);
PTIMER FindTimer(PWND pwnd, UINT_PTR nID, UINT flags, BOOL fKill);
VOID xxxSystemTimerProc(PWND pwnd, UINT msg, UINT_PTR id, LPARAM lParam);


/*
 * CARET.C
 */
BOOL zzzDestroyCaret(VOID);
BOOL xxxCreateCaret(PWND, HBITMAP, int, int);
BOOL zzzShowCaret(PWND);
BOOL zzzHideCaret(PWND);
BOOL _SetCaretBlinkTime(UINT);
BOOL zzzSetCaretPos(int, int);

/*
 * MSGBEEP.C
 */
BOOL xxxOldMessageBeep(VOID);
BOOL xxxMessageBeep(UINT wType);
VOID PlayEventSound(UINT idSound);

/*
 * WINWHERE.C
 */
PWND _ChildWindowFromPointEx(PWND pwndParent, POINT pt, UINT i);
PWND xxxWindowFromPoint(POINT pt);
PWND SizeBoxHwnd(PWND pwnd);

/*
 * GETSET.C
 */
WORD  _SetWindowWord(PWND pwnd, int index, WORD value);
DWORD xxxSetWindowLong(PWND pwnd, int index, DWORD value, BOOL bAnsi);
#ifdef _WIN64
ULONG_PTR xxxSetWindowLongPtr(PWND pwnd, int index, ULONG_PTR value, BOOL bAnsi);
#else
#define xxxSetWindowLongPtr xxxSetWindowLong
#endif
#define __GetWindowLong(pwnd, index) ((LONG)(*(DWORD UNALIGNED *)((BYTE *)((pwnd) + 1) + (index))))
#define __GetWindowLongPtr(pwnd, index) ((LONG_PTR)(*(ULONG_PTR UNALIGNED *)((BYTE *)((pwnd) + 1) + (index))))
#if DBG
ULONG DBGGetWindowLong(PWND pwnd, int index);
#define _GetWindowLong DBGGetWindowLong
ULONG_PTR DBGGetWindowLongPtr(PWND pwnd, int index);
#define _GetWindowLongPtr DBGGetWindowLongPtr
#else
#define _GetWindowLong __GetWindowLong
#define _GetWindowLongPtr __GetWindowLongPtr
#endif

/*
 * CLIPBRD.C
 */
BOOL _OpenClipboard(PWND pwnd, LPBOOL lpfEmptyClient);
BOOL xxxCloseClipboard(PWINDOWSTATION pwinsta);
UINT _EnumClipboardFormats(UINT fmt);
BOOL xxxEmptyClipboard(PWINDOWSTATION pwinsta);
HANDLE xxxGetClipboardData(PWINDOWSTATION pwinsta, UINT fmt, PGETCLIPBDATA gcd);
BOOL _IsClipboardFormatAvailable(UINT fmt);
int _GetPriorityClipboardFormat(UINT *lpPriorityList, int cfmts);
PWND xxxSetClipboardViewer(PWND pwndClipViewerNew);
BOOL xxxChangeClipboardChain(PWND pwndRemove, PWND pwndNewNext);

/*
 * miscutil.c
 */
VOID SetDialogPointer(PWND pwnd, LONG_PTR lPtr);
VOID ZapActiveAndFocus(VOID);
BOOL xxxSetShellWindow(PWND pwnd, PWND pwndBkGnd);
BOOL _SetProgmanWindow(PWND pwnd);
BOOL _SetTaskmanWindow(PWND pwnd);

#define STW_SAME    ((PWND) 1)
VOID xxxSetTrayWindow(PDESKTOP pdesk, PWND pwnd, PMONITOR pMonitor);
BOOL xxxAddFullScreen(PWND pwnd, PMONITOR pMonitor);
BOOL xxxRemoveFullScreen(PWND pwnd, PMONITOR pMonitor);
BOOL xxxCheckFullScreen(PWND pwnd, PSIZERECT psrc);
BOOL IsTrayWindow(PWND);

#define FDoTray()   (SYSMET(ARRANGE) & ARW_HIDE)
#define FCallHookTray() (IsHooked(PtiCurrent(), WHF_SHELL))
#define FPostTray(p) (p->pDeskInfo->spwndTaskman)
#define FCallTray(p) (FDoTray() && ( FCallHookTray()|| FPostTray(p) ))

// ----------------------------------------------------------------------------
//
//  FTopLevel() - TRUE if window is a top level window
//
//  FHas31TrayStyles() -  TRUE if window is either full screen or has
//                        both a system menu and a caption
//                        (NOTE:  minimized windows always have captions)
//
// ----------------------------------------------------------------------------
#define FTopLevel(pwnd)         (pwnd->spwndParent == PWNDDESKTOP(pwnd))
#define FHas31TrayStyles(pwnd)    (TestWF(pwnd, WFFULLSCREEN) || \
                                  (TestWF(pwnd, WFSYSMENU | WFMINBOX) && \
                                  (TestWF(pwnd, WFCAPTION) || TestWF(pwnd, WFMINIMIZED))))
BOOL Is31TrayWindow(PWND pwnd);

/*
 * fullscr.c
 */

#if DBG

__inline VOID VerifyVisibleMonitorCount(
    VOID)
{
    extern PDISPLAYINFO gpDispInfo;
    PMONITOR pMonitor = gpDispInfo->pMonitorFirst;
    ULONG cVisMon = 0;

    while (pMonitor) {
        if (pMonitor->dwMONFlags & MONF_VISIBLE) {
            cVisMon++;
        }
        pMonitor = pMonitor->pMonitorNext;
    }

    UserAssert(cVisMon == gpDispInfo->cMonitors);
}

#else
#define VerifyVisibleMonitorCount()
#endif

BOOL xxxMakeWindowForegroundWithState(PWND, BYTE);
VOID FullScreenCleanup(VOID);
LONG xxxUserChangeDisplaySettings(
    PUNICODE_STRING pstrDeviceName,
    LPDEVMODEW pDevMode,
    PDESKTOP pdesk,
    DWORD dwFlags,
    PVOID lParam,
    MODE PreviousMode);
BOOL xxxbFullscreenSwitch(BOOL bFullscreenSwitch, HWND hwnd);


/*
 * SBAPI.C
 */
BOOL xxxShowScrollBar(PWND, UINT, BOOL);

/*
 * mngray.c
 */
BOOL xxxDrawState(HDC hdcDraw, HBRUSH hbrFore,
        LPARAM lData, int x, int y, int cx, int cy, UINT uFlags);

/*
 * SCROLLW.C
 */
BOOL _ScrollDC(HDC hdc, int dx, int dy, LPRECT prcSrc, LPRECT prcClip,
               HRGN hrgnUpdate, LPRECT prcUpdate);

/*
 * SPB.C
 */
VOID SpbCheckRect(PWND pwnd, LPRECT lprc, DWORD flags);
VOID SpbCheck(VOID);
PSPB FindSpb(PWND pwnd);
VOID FreeSpb(PSPB pspb);
VOID FreeAllSpbs(VOID);
VOID CreateSpb(PWND pwnd, UINT flags, HDC hdcScreen);
UINT RestoreSpb(PWND pwnd, HRGN hrgnUncovered, HDC *phdcScreen);
VOID SpbCheckPwnd(PWND pwnd);
VOID SpbCheckDce(PDCE pdce);
BOOL LockWindowUpdate2(PWND pwndLock, BOOL fThreadOverride);

/*
 * DRAWFRM.C
 */
BOOL BitBltSysBmp(HDC hdc, int x, int y, UINT i);

/*
 * SYSMET.c
 */
BOOL APIENTRY xxxSetSysColors(PUNICODE_STRING pProfileUserName,int count, PUINT pIndex, LPDWORD pClrVal, UINT uOptions);
VOID SetSysColor(UINT icol, DWORD rgb, UINT uOptions);

/*
 * ICONS.C
 */
UINT xxxArrangeIconicWindows(PWND pwnd);
BOOL  _SetSystemMenu(PWND pwnd, PMENU pMenu);

/*
 * RMCREATE.C
 */
PICON _CreateIconIndirect(PICONINFO piconinfo);
PCURSOR _CreateCursor(HANDLE hModule, int iXhotspot, int iYhotspot,
        int iWidth, int iHeight, LPBYTE lpANDplane, LPBYTE lpXORplane);
PICON _CreateIcon(HANDLE hModule, int iWidth, int iHeight,
        BYTE bPlanes, BYTE bBitsPixel, LPBYTE lpANDplane, LPBYTE lpXORplane);
VOID DestroyUnlockedCursor(VOID *pv);
BOOL _DestroyCursor(PCURSOR pcur, DWORD cmdDestroy);
HANDLE _CreateAcceleratorTable(LPACCEL ccxpaccel, int cbAccel);

/*
 * CURSOR.C
 */
#if DBG
    PCURSOR DbgLockQCursor(PQ pq, PCURSOR pcur);
    #define LockQCursor(pq, pcur)   DbgLockQCursor(pq, pcur)
#else
    #define LockQCursor(pq, pcur)   Lock(&pq->spcurCurrent, pcur)
#endif // DBG

PCURSOR zzzSetCursor(PCURSOR pcur);
BOOL    zzzSetCursorPos(int x, int y);
int     zzzShowCursor(BOOL fShow);
BOOL    zzzClipCursor(LPCRECT prcClip);
PCURSOR _GetCursor(VOID);
BOOL    _SetCursorContents(PCURSOR pcur, PCURSOR pcurNew);
VOID    SetPointer(BOOL fSet);
VOID    zzzHideCursorNoCapture(VOID);
#define GETPCI(pcur) ((PCURSINFO)&(pcur->CI_FIRST))

/*
 * WMICON.C
 */
BOOL _DrawIconEx(HDC hdc, int x, int y, PCURSOR pcur, int cx, int cy,
        UINT istepIfAniCur, HBRUSH hbrush, UINT diFlags) ;
BOOL BltIcon(HDC hdc, int x, int y, int cx, int cy,
        HDC hdcSrc, PCURSOR pcursor, UINT diFlag, LONG rop);

/*
 * DESKTOP.C
 */

__inline VOID xxxCleanupMotherDesktopWindow(
    PTERMINAL pTerm)
{
    PWND pwnd = pTerm->spwndDesktopOwner;

    /*
     * Hide the window first.
     */
     SetVisible(pwnd, SV_UNSET);
     pTerm->dwTERMF_Flags |= TERMF_MOTHERWND_DESTROYED;

     if(Unlock(&(pTerm->spwndDesktopOwner))) {
         xxxDestroyWindow(pwnd);
     }
}

HDESK xxxCreateDesktop(
        POBJECT_ATTRIBUTES,
        KPROCESSOR_MODE,
        PUNICODE_STRING,
        LPDEVMODEW,
        DWORD,
        DWORD);

#define CST_MAX_THREADS       30

/*
 * Flags for xxxSwitchDesktop().
 */
#define SDF_CREATENEW  0x01 /* New desktop, don't send enable/disable */
#define SDF_SLOVERRIDE 0x02 /* Don't respect WSF_SWITCHLOCK on pwinsta */

HDESK _OpenDesktop(POBJECT_ATTRIBUTES ccxObja, KPROCESSOR_MODE AccessMode, DWORD dwFlags, DWORD dwDesiredAccess, BOOL *pbShutDown);
BOOL OpenDesktopCompletion(PDESKTOP pdesk, HDESK hdesk, DWORD dwFlags, BOOL *pbShutDown);
BOOL xxxSwitchDesktop(PWINDOWSTATION pwinsta, PDESKTOP pdesk, DWORD dwFlags);
BOOL zzzSetDesktop(PTHREADINFO pti, PDESKTOP pdesk, HDESK hdesk);
HDESK _GetInputDesktop(VOID);
BOOL xxxSetThreadDesktop(HDESK hdesk, PDESKTOP pdesk);
HDESK xxxGetThreadDesktop(DWORD dwThread, HDESK hdeskConsole, KPROCESSOR_MODE AccessMode);
BOOL xxxCloseDesktop(HDESK hdesk, KPROCESSOR_MODE AccessMode);
DWORD _SetDesktopConsoleThread(PDESKTOP pdesk, DWORD dwThreadId);
VOID xxxRealizeDesktop(PWND pwnd);

/*
 * Flags for GetDesktopHeapSize().
 */
#define DHS_LOGON      0x1
#define DHS_DISCONNECT 0x2
#define DHS_NOIO       0x3

ULONG GetDesktopHeapSize(
    USHORT usFlags);

/*
 * WINSTA.C
 */
NTSTATUS CreateGlobalAtomTable(
    PVOID* ppAtomTable);

HWINSTA xxxCreateWindowStation(
    POBJECT_ATTRIBUTES ObjA,
    KPROCESSOR_MODE OwnershipMode,
    DWORD amRequest,
    HANDLE hKbdLayoutFile,
    DWORD offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    PCWSTR pwszKLID,
    UINT uKbdInputLocale);

HWINSTA _OpenWindowStation(
    POBJECT_ATTRIBUTES pObjA,
    DWORD dwDesiredAccess,
    KPROCESSOR_MODE AccessMode);

BOOL _CloseWindowStation(
    HWINSTA hwinsta);

NTSTATUS _SetProcessWindowStation(
    HWINSTA hwinsta,
    KPROCESSOR_MODE AccessMode);

PWINDOWSTATION _GetProcessWindowStation(
    HWINSTA *phwinsta);

BOOL _LockWorkStation(
    VOID);

NTSTATUS ReferenceWindowStation(
    PETHREAD Thread,
    HWINSTA hwinsta,
    ACCESS_MASK amDesiredAccess,
    PWINDOWSTATION *ppwinsta,
    BOOL fUseDesktop);

/*
 * HOOKS.C
 */
PROC zzzSetWindowsHookAW(int nFilterType, PROC pfnFilterProc, DWORD dwFlags);
BOOL zzzUnhookWindowsHookEx(PHOOK phk);
BOOL zzzUnhookWindowsHook(int nFilterType, PROC pfnFilterProc);
LRESULT xxxCallNextHookEx(int nCode, WPARAM wParam, LPARAM lParam);
BOOL _CallMsgFilter(LPMSG lpMsg, int nCode);
VOID zzzCancelJournalling(VOID);
#if DBG
VOID DbgValidateHooks(PHOOK phk, int iType);
#else
#define DbgValidateHooks(phk, iType)
#endif
BOOL _RegisterUserApiHook(PUNICODE_STRING pstrLib, ULONG_PTR offPfnInitDefWindowProc);
BOOL _UnregisterUserApiHook(VOID);
BOOL xxxLoadUserApiHook(VOID);


extern int gihmodUserApiHook;

__inline BOOL IsInsideUserApiHook(
    VOID)
{
    return gihmodUserApiHook >= 0;
}

#ifdef MESSAGE_PUMP_HOOK

BOOL _DoInitMessagePumpHook(VOID);
BOOL _DoUninitMessagePumpHook(VOID);

extern PTHREADINFO gptiCurrent;

__inline BOOL IsInsideMPH(
    VOID)
{
    PCLIENTTHREADINFO pcti = PtiCurrent()->pcti;
    return pcti->cMessagePumpHooks > 0;
}

#endif // MESSAGE_PUMP_HOOK


/*
 * SRVHOOK.C
 */
LRESULT fnHkINLPCWPEXSTRUCT(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);
LRESULT fnHkINLPCWPRETEXSTRUCT(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);

/*
 * EXITWIN.C
 */
LONG xxxClientShutdown(PWND pwnd, WPARAM wParam);
BOOL xxxRegisterUserHungAppHandlers(PFNW32ET pfnW32EndTask, HANDLE hEventWowExec);

/*
 * INIT.C
 */
BOOL CreateTerminalInput(PTERMINAL pTerm);

VOID LW_LoadProfileInitData(PUNICODE_STRING pProfileUserName);
VOID xxxODI_ColorInit(PUNICODE_STRING pProfileUserName);
HRGN InitCreateRgn(VOID);
VOID xxxUpdateSystemCursorsFromRegistry(PUNICODE_STRING pProfileUserName);
VOID xxxUpdateSystemIconsFromRegistry(PUNICODE_STRING pProfileUserName);
VOID RegisterLPK(DWORD dwLpkEntryPoints);
HBITMAP CreateCaptionStrip(VOID);

BOOL LW_BrushInit(VOID);
VOID xxxLW_LoadFonts(BOOL bRemote);

VOID _LoadCursorsAndIcons(VOID);

VOID UnloadCursorsAndIcons(VOID);

VOID IncrMBox(VOID);
VOID DecrMBox(VOID);
VOID InitAnsiOem(PCHAR pOemToAnsi, PCHAR pAnsiToOem);
int  xxxAddFontResourceW(LPWSTR lpFile, FLONG flags, DESIGNVECTOR *pdv);
VOID EnforceColorDependentSettings(VOID);


/*
 * ACCESS.C
 */
VOID xxxUpdatePerUserAccessPackSettings(PUNICODE_STRING pProfileUserName);

/*
 * inctlpan.c
 */
VOID GetWindowNCMetrics(LPNONCLIENTMETRICS lpnc);

HFONT CreateFontFromWinIni(PUNICODE_STRING pProfileUserName,LPLOGFONT lplf, UINT idFont);
VOID SetMinMetrics(PUNICODE_STRING pProfileUserName,LPMINIMIZEDMETRICS lpmin);
BOOL xxxSetWindowNCMetrics(PUNICODE_STRING pProfileUserName,LPNONCLIENTMETRICS lpnc, BOOL fSizeChange, int clNewBorder);
BOOL SetIconMetrics(PUNICODE_STRING pProfileUserName,LPICONMETRICS lpicon);
BOOL xxxSetNCFonts(PUNICODE_STRING pProfileUserName, LPNONCLIENTMETRICS lpnc);
BOOL CreateBitmapStrip(VOID);
BOOL UpdateWinIniInt(PUNICODE_STRING pProfileUserName, UINT idSection, UINT wKeyNameId, int value);

/*
 * rare.c
 */
VOID SetDesktopMetrics(VOID);
VOID SetMsgBox(PWND pwnd);

BOOL _RegisterShellHookWindow(PWND pwnd);
BOOL _DeregisterShellHookWindow(PWND pwnd);
BOOL xxxSendMinRectMessages(PWND pwnd, RECT *lpRect);
void PostShellHookMessages(UINT message, LPARAM lParam);
VOID _ResetDblClk(VOID);
VOID xxxSimulateShiftF10(VOID);
BOOL VWPLAdd(PVWPL *ppvwpl, PWND pwnd, DWORD dwThreshold);
BOOL VWPLRemove(PVWPL *ppvwpl, PWND pwnd);
PWND VWPLNext(PVWPL pvwpl, PWND pwndPrev, DWORD *pnPrev);

/*
 * DDETRACK STUFF
 */

#if DBG
VOID ValidatePublicObjectList(VOID);
VOID TraceDdeMsg(UINT msg, HWND hwndFrom, HWND hwndTo, UINT code);
#define MSG_SENT    0
#define MSG_POST    1
#define MSG_RECV    2
#define MSG_PEEK    3
#else
#define ValidatePublicObjectList()
#define TraceDdeMsg(m, h1, h2, c)
#endif // DBG

typedef struct tagFREELIST {
    struct tagFREELIST *next;
    HANDLE h;                           // CSR client side GMEM_DDESHARE handle
    DWORD flags;                        // XS_ flags describing data
} FREELIST, *PFREELIST;

typedef struct tagDDEIMP {
    SECURITY_QUALITY_OF_SERVICE qos;
    SECURITY_CLIENT_CONTEXT ClientContext;
    short cRefInit;
    short cRefConv;
} DDEIMP, *PDDEIMP;

typedef struct tagDDECONV {
    THROBJHEAD          head;           // HM header
    struct tagDDECONV   *snext;
    struct tagDDECONV   *spartnerConv;  // siamese twin
    PWND                spwnd;          // associated pwnd
    PWND                spwndPartner;   // associated partner pwnd
    struct tagXSTATE    *spxsOut;       // transaction info queue - out point
    struct tagXSTATE    *spxsIn;        // transaction info queue - in point
    struct tagFREELIST  *pfl;           // free list
    DWORD               flags;          // CXF_ flags
    struct tagDDEIMP    *pddei;         // impersonation information
} DDECONV, *PDDECONV;

typedef DWORD (FNDDERESPONSE)(PDWORD pmsg, LPARAM *plParam, PDDECONV pDdeConv);
typedef FNDDERESPONSE *PFNDDERESPONSE;

typedef struct tagXSTATE {
    THROBJHEAD          head;           // HM header
    struct tagXSTATE    *snext;
    PFNDDERESPONSE      fnResponse;     // proc to handle next msg.
    HANDLE              hClient;        // GMEM_DDESAHRE handle on client side
    HANDLE              hServer;        // GMEM_DDESHARE handle on server side
    PINTDDEINFO         pIntDdeInfo;    // DDE data being transfered
    DWORD               flags;          // XS_ flags describing transaction/data
} XSTATE, *PXSTATE;

// values for flags field

#define CXF_IS_SERVER               0x0001
#define CXF_TERMINATE_POSTED        0x0002
#define CXF_PARTNER_WINDOW_DIED     0x0004
#define CXF_INTRA_PROCESS           0x8000

BOOL xxxDDETrackSendHook(PWND pwndTo, DWORD message, WPARAM wParam, LPARAM lParam);
DWORD xxxDDETrackPostHook(PUINT pmessage, PWND pwndTo, WPARAM wParam, LPARAM *plParam, BOOL fSent);
VOID FreeDdeXact(PXSTATE pxs);

VOID xxxDDETrackGetMessageHook(PMSG pmsg);
VOID xxxDDETrackWindowDying(PWND pwnd, PDDECONV pDdeConv);
VOID FreeDdeConv(PDDECONV pDdeConv);
BOOL _ImpersonateDdeClientWindow(PWND pwndClient, PWND pwndServer);


typedef struct tagMONITORPOS
{
    RECT     rcMonitor;     /* where the monitor rect was */
    RECT     rcWork;        /* where the work rect was */
    PMONITOR pMonitor;      /* what new monitor gets its windows */
} MONITORPOS, *PMONITORPOS;

typedef struct tagMONITORRECTS
{
    int             cMonitor;   /* number of monitors */
    MONITORPOS      amp[1];     /* the monitor positions */
} MONITORRECTS, *PMONITORRECTS;


// stuctures for windows resize/ reposition on reconnect.
// when disconnecting from local console, these structures allow
// to memorize the monitors layout and windows size and positions
// on the monitors. When reconnecting back to local console, the snapshot
// is used to restore windows positions for windows that still exist.


typedef struct tagWPSNAPSHOT
{
    RECT     rcWindow;                 /* Windows rect */
    HWND     hwnd;                     /* hwnd */
} WPSNAPSHOT, *PWPSNAPSHOT;

typedef struct tagWMSNAPSHOT
{
    PMONITORRECTS   pmr;        /* Monitors and their dimensions and positions */
    PWPSNAPSHOT     pwps;       /* Windows and their dimensions and positions */
    int cWindows;               /* number of windows in pwps */
} WMSNAPSHOT, *PWMSNAPSHOT;

NTSTATUS RestoreMonitorsAndWindowsRects(VOID);
NTSTATUS SnapShotMonitorsAndWindowsRects(VOID);
VOID  CleanupMonitorsAndWindowsSnapShot(VOID);
PWPSNAPSHOT SnapshotWindowRects(int *pnWindows);

PMONITORRECTS SnapshotMonitorRects(VOID);
VOID xxxDesktopRecalc(PMONITORRECTS pmrOld);
VOID UpdateMonitorRectsSnapShot(PMONITORRECTS pmr);
BOOL IsValidMonitor(PMONITOR pMonitor);

BOOL _SetDoubleClickTime(UINT dtTime);
BOOL _SwapMouseButton(BOOL fSwapButtons);
VOID xxxDestroyThreadInfo(VOID);

BOOL _GetWindowPlacement(PWND pwnd, PWINDOWPLACEMENT pwp);

PMENU xxxGetSystemMenu(PWND pWnd, BOOL bRevert);
PMENU _CreateMenu(VOID);
PMENU _CreatePopupMenu(VOID);
BOOL  _DestroyMenu(PMENU pMenu);
DWORD _CheckMenuItem(PMENU pMenu, UINT wIDCheckItem, UINT wCheck);
DWORD xxxEnableMenuItem(PMENU pMenu, UINT wIDEnableItem, UINT wEnable);

PWND _GetNextQueueWindow(PWND pwnd, BOOL fDir, BOOL fAltEsc);

UINT_PTR _SetSystemTimer(PWND pwnd, UINT_PTR nIDEvent, DWORD dwElapse,
        TIMERPROC_PWND pTimerFunc);
BOOL   _SetClipboardData(UINT fmt, HANDLE hData, BOOL fGlobalHandle, BOOL fIncSerialNumber);
WORD   _SetClassWord(PWND pwnd, int index, WORD value);
DWORD  xxxSetClassLong(PWND pwnd, int index, DWORD value, BOOL bAnsi);
#ifdef _WIN64
ULONG_PTR xxxSetClassLongPtr(PWND pwnd, int index, ULONG_PTR value, BOOL bAnsi);
#else
#define xxxSetClassLongPtr  xxxSetClassLong
#endif
ATOM   _RegisterClassEx(LPWNDCLASSVEREX pwc,
                        PCLSMENUNAME pcmn,
                        WORD fnid,
                        DWORD dwFlags,
                        LPDWORD pdwWOW);
BOOL  xxxHiliteMenuItem(PWND pwnd, PMENU pmenu, UINT cmd, UINT flags);
HANDLE _CreateAcceleratorTable(LPACCEL paccel, int cbAccel);
HANDLE xxxGetInputEvent(DWORD dwWakeMask);
BOOL   _UnregisterClass(LPCWSTR lpszClassName, HANDLE hModule, PCLSMENUNAME pcmn);
ATOM   _GetClassInfoEx(HANDLE hModule, LPCWSTR lpszClassName, LPWNDCLASSEX pwc, LPWSTR *ppszMenuName, BOOL bAnsi);
PWND   _WindowFromDC(HDC hdc);
PCLS   _GetWOWClass(HANDLE hModule, LPCWSTR lpszClassName);
LRESULT xxxHkCallHook(PHOOK phk, int nCode, WPARAM wParam, LPARAM lParam);
PHOOK  zzzSetWindowsHookEx(HANDLE hmod, PUNICODE_STRING pstrLib,
        PTHREADINFO ptiThread, int nFilterType, PROC pfnFilterProc, DWORD dwFlags);
DWORD  GetDebugHookLParamSize(WPARAM wParam, PDEBUGHOOKINFO pdebughookstruct);
BOOL   _RegisterLogonProcess(DWORD dwProcessId, BOOL fSecure);
UINT   _LockWindowStation(PWINDOWSTATION pwinsta);
BOOL   _UnlockWindowStation(PWINDOWSTATION pwinsta);
BOOL   _SetWindowStationUser(PWINDOWSTATION pwinsta, PLUID pluidUser,
        PSID psidUser, DWORD cbsidUser);
BOOL   _SetDesktopBitmap(PDESKTOP pdesk, HBITMAP hbitmap, DWORD dwStyle);

BOOL   _SetLogonNotifyWindow(PWND pwnd);


BOOL   _RegisterTasklist(PWND pwndTasklist);
LONG_PTR _SetMessageExtraInfo(LONG_PTR);
VOID   xxxRemoveEvents(PQ pq, int nQueue, DWORD flags);

PPCLS _InnerGetClassPtr(ATOM atom, PPCLS ppclsList, HANDLE hModule);

/*
 * ntcb.h funtions.
 */
DWORD ClientGetListboxString(PWND hwnd, UINT msg,
        WPARAM wParam, PVOID lParam,
        ULONG_PTR xParam, PROC xpfn, DWORD dwSCMSFlags, BOOL bNotString, PSMS psms);
HANDLE ClientLoadLibrary(PUNICODE_STRING pstrLib, ULONG_PTR offPfnInitDefWindowProc);
BOOL ClientFreeLibrary(HANDLE hmod);

#ifdef MESSAGE_PUMP_HOOK
BOOL ClientGetMessageMPH(LPMSG msg, HWND hwndFilter, UINT msgMin, UINT msgMax, UINT flags, BOOL fGetMessage);
BOOL ClientWaitMessageExMPH(UINT fsWakeMask, DWORD Timeout);
#endif

BOOL xxxClientGetCharsetInfo(LCID lcid, PCHARSETINFO pcs);
BOOL ClientExitProcess(PFNW32ET pfn, DWORD dwExitCode);
BOOL ClientGrayString(GRAYSTRINGPROC pfnOutProc, HDC hdc,
        DWORD lpData, int nCount);
BOOL CopyFromClient(LPBYTE lpByte, LPBYTE lpByteClient, DWORD cch,
        BOOL fString, BOOL fAnsi);
BOOL CopyToClient(LPBYTE lpByte, LPBYTE lpByteClient,
        DWORD cchMax, BOOL fAnsi);
VOID ClientNoMemoryPopup(VOID);
NTSTATUS xxxClientThreadSetup(VOID);

VOID ClientDeliverUserApc(VOID);

BOOL ClientImmLoadLayout(HKL, PIMEINFOEX);
DWORD ClientImmProcessKey(HWND, HKL, UINT, LPARAM, DWORD);

NTSTATUS xxxUserModeCallback (ULONG uApi, PVOID pIn, ULONG cbIn, PVOID pOut, ULONG cbOut);
int xxxClientLoadStringW(UINT StrID, LPWSTR szText, int cch);

PCURSOR ClassSetSmallIcon(
    PCLS pcls,
    PCURSOR pcursor,
    BOOL fServerCreated);

BOOL _GetTextMetricsW(
    HDC hdc,
    LPTEXTMETRICW ptm);

int xxxDrawMenuBarTemp(
    PWND pwnd,
    HDC hdc,
    LPRECT lprc,
    PMENU pMenu,
    HFONT hFont);

BOOL xxxDrawCaptionTemp(
    PWND pwnd,
    HDC hdc,
    LPRECT lprc,
    HFONT hFont,
    PCURSOR pcursor,
    PUNICODE_STRING pstrText OPTIONAL,
    UINT flags);

WORD xxxTrackCaptionButton(
    PWND pwnd,
    UINT hit);

VOID GiveForegroundActivateRight(HANDLE hPid);
BOOL HasForegroundActivateRight(HANDLE hPid);
BOOL FRemoveForegroundActivate(PTHREADINFO pti);
VOID RestoreForegroundActivate(VOID);
VOID CancelForegroundActivate(VOID);

#define ACTIVATE_ARRAY_SIZE 5
extern HANDLE ghCanActivateForegroundPIDs[ACTIVATE_ARRAY_SIZE];

__inline VOID GiveForegroundActivateRight(
    HANDLE hPid)
{
    static int index = 0;

    TAGMSG1(DBGTAG_FOREGROUND, "Giving 0x%x foreground activate right", hPid);
    ghCanActivateForegroundPIDs[index++] = hPid;
    if (index == ACTIVATE_ARRAY_SIZE) {
        index = 0;
    }
}

__inline BOOL HasForegroundActivateRight(
    HANDLE hPid)
{
    int i = 0;

    for(; i < ACTIVATE_ARRAY_SIZE; ++i) {
            if (ghCanActivateForegroundPIDs[i] == hPid) {
                TAGMSG1(DBGTAG_FOREGROUND, "HasForegroundActivateRight: Found 0x%x", hPid);
                return TRUE;
            }
     }

     TAGMSG1(DBGTAG_FOREGROUND, "HasForegroundActivateRight: Did NOT find 0x%x", hPid);
     return FALSE;
}


#define WHERE_NOONE_CAN_SEE_ME ((int) -32000)
BOOL MinToTray(PWND pwnd);

void xxxUpdateThreadsWindows(
    PTHREADINFO pti,
    PWND pwnd,
    HRGN hrgnFullDrag);

NTSTATUS xxxQueryInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL);

NTSTATUS xxxSetInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength);

NTSTATUS GetProcessDefaultWindowOrientation(
    IN HANDLE hProcess,
    OUT DWORD *pdwDefaultOrientation);

NTSTATUS SetProcessDefaultWindowOrientation(
    IN HANDLE hProcess,
    IN DWORD dwDefaultOrientation);

NTSTATUS SetInformationProcess(
    IN HANDLE hProcess,
    IN USERPROCESSINFOCLASS ProcessInfoClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength);


NTSTATUS xxxConsoleControl(
    IN CONSOLECONTROL ConsoleControl,
    IN PVOID ConsoleInformation,
    IN ULONG ConsoleInformationLength);


/***************************************************************************\
* String Table Defines
*
* KERNEL\STRID.MC has a nice big table of strings that are meant to be
* localized. Before use, the strings are pulled from the resource table
* with LoadString, passing it one of the following string ids.
*
* NOTE: Only strings that need to be localized should be added to the
*       string table. Class name strings, etc are NOT localized.
*
* LATER: All string table entries should be reexamined to be sure they
*        conform to the note above.
*
\***************************************************************************/

#define OCR_APPSTARTING         32650

/*
 * Win Event Hook struct
 */
typedef struct tagEVENTHOOK {
    THROBJHEAD          head;                //
    struct tagEVENTHOOK *pehNext;            // Next event hook
    UINT                eventMin;            // Min event (>=) to hook
    UINT                eventMax;            // Max event (<=) to hook
    UINT                fDestroyed:1;        // If orphaned while in use
    UINT                fIgnoreOwnThread:1;  // Ignore events for installer thread
    UINT                fIgnoreOwnProcess:1; // Ignore events for installer process
    UINT                fSync:1;             // Sync event (inject DLL into each process)
    HANDLE              hEventProcess;       // Process being hooked
    DWORD               idEventThread;       // Thread being hooked
    ULONG_PTR           offPfn;              // offset event proc
    int                 ihmod;               // index of module containing event proc
    LPWSTR              pwszModulePath;      // Path of module library for global sync.
} EVENTHOOK, *PEVENTHOOK;

typedef struct tagNOTIFY {
    struct tagNOTIFY *pNotifyNext;         // Next notification
    PEVENTHOOK        spEventHook;         // Event this refers to
    DWORD             event;               // Event
    HWND              hwnd;                // hwnd to ask about it
    LONG              idObject;            // object ID
    LONG              idChild;             // child id
    DWORD             idSenderThread;      // Thread generating event
    DWORD             dwEventTime;         // Event time
    DWORD             dwWEFlags;           // WEF_DEFERNOTIFY etc.
    PTHREADINFO       ptiReceiver;         // Thread receiving event
} NOTIFY, *PNOTIFY;

VOID xxxWindowEvent(DWORD event, PWND pwnd, LONG idObject, LONG idChild, DWORD dwFlags);
#define WEF_USEPWNDTHREAD 0x0001
#define WEF_DEFERNOTIFY   0x0002
#define WEF_ASYNC         0x0004
#define WEF_POSTED        0x0008

#define DeferWinEventNotify()      CheckCritIn();          \
                                   gdwDeferWinEvent++
#define IsWinEventNotifyDeferred() (gdwDeferWinEvent > 0)
#define IsWinEventNotifyDeferredOK() (!IsWinEventNotifyDeferred() || ISATOMICCHECK())
#define zzzEndDeferWinEventNotify()                        \
        UserAssert(IsWinEventNotifyDeferred());            \
        CheckCritIn();                                     \
        if (--gdwDeferWinEvent == 0) {                     \
            if (gpPendingNotifies != NULL) { \
                xxxFlushDeferredWindowEvents();            \
            }                                              \
        }

/*
 * Only use this one for bookkeeping gdwDeferWinEvent,
 * which may be required without leaving the critical section.
 */
#define EndDeferWinEventNotifyWithoutProcessing()          \
        UserAssert(IsWinEventNotifyDeferred());            \
        CheckCritIn();                                     \
        --gdwDeferWinEvent

#define zzzWindowEvent(event, pwnd, idObject, idChild, dwFlags) \
        xxxWindowEvent(event, pwnd, idObject, idChild,          \
            IsWinEventNotifyDeferred() ? (dwFlags) | WEF_DEFERNOTIFY : (dwFlags))

VOID xxxFlushDeferredWindowEvents();

BOOL xxxClientCallWinEventProc(WINEVENTPROC pfn, PEVENTHOOK pEventHook, PNOTIFY pNotify);
void DestroyEventHook(PEVENTHOOK);
VOID FreeThreadsWinEvents(PTHREADINFO pti);

BOOL       _UnhookWinEvent(PEVENTHOOK peh);
VOID       DestroyNotify(PNOTIFY pNotify);
PEVENTHOOK xxxProcessNotifyWinEvent(PNOTIFY pNotify);
PEVENTHOOK _SetWinEventHook(DWORD eventMin, DWORD eventMax,
        HMODULE hmodWinEventProc, PUNICODE_STRING pstrLib,
        WINEVENTPROC pfnWinEventProc, HANDLE hEventProcess,
        DWORD idEventThread, DWORD dwFlags);
BOOL _GetGUIThreadInfo(PTHREADINFO pti, PGUITHREADINFO pgui);
BOOL xxxGetTitleBarInfo(PWND pwnd, PTITLEBARINFO ptbi);
BOOL xxxGetComboBoxInfo(PWND pwnd, PCOMBOBOXINFO ptbi);
DWORD xxxGetListBoxInfo(PWND pwnd);
BOOL xxxGetScrollBarInfo(PWND pwnd, LONG idObject, PSCROLLBARINFO ptbi);
PWND _GetAncestor(PWND pwnd, UINT gaFlags);
PWND _RealChildWindowFromPoint(PWND pwndParent, POINT pt);
BOOL _GetAltTabInfo(int iItem, PALTTABINFO pati,
        LPWSTR lpszItemText, UINT cchItemText, BOOL bAnsi);
BOOL xxxGetMenuBarInfo(PWND pwnd, long idObject, long idItem, PMENUBARINFO pmbi);

typedef HWND *PHWND;
typedef struct tagSwitchWndInfo *PSWINFO;

typedef struct tagSwitchWndInfo {

    PSWINFO     pswiNext;           // Pointer to the next Switch Window Info.
    PTHREADINFO pti;                // pit that allocated the strucutre.
    PBWL        pbwl;               // Pointer to the window list built.
    PHWND       phwndLast;          // Pointer to the last window in the list.
    PHWND       phwndCurrent;       // pointer to the current window.

    INT         iTotalTasks;        // Total number of tasks.
    INT         iTasksShown;        // Total tasks shown.
    BOOL        fScroll;            // Is there a need to scroll?

    INT         iFirstTaskIndex;    // Index to the first task shown.

    INT         iNoOfColumns;       // Max Number of tasks per row.
    INT         iNoOfRows;          // Max Number of rows of icons in the switch window.
    INT         iIconsInLastRow;    // Icons in last row.
    INT         iCurCol;            // Current column where hilite lies.
    INT         iCurRow;            // Current row where hilite lies.
    INT         cxSwitch;           // Switch Window dimensions.
    INT         cySwitch;
    POINT       ptFirstRowStart;    // Top left corner of the first Icon Slot.
    RECT        rcTaskName;         // Rect where Task name is displayed.
    BOOL        fJournaling;        // Determins how we check the keyboard state
} SWITCHWNDINFO, *PSWINFO;

typedef struct tagSWITCHWND {
    WND;
    PSWINFO pswi;
} SWITCHWND, *PSWITCHWND;

typedef struct tagHOTKEYSTRUCT {
    PWND  spwnd;
    DWORD key;
} HOTKEYSTRUCT, *PHOTKEYSTRUCT;

#define LANGTOGGLEKEYS_SIZE 3

/*
 * ACCF_ and PUDF_ flags share the same field. ACCF fields
 * are so named because they may later move to a differnt
 * struct.
 */
#define ACCF_DEFAULTFILTERKEYSON        0x00000001
#define ACCF_DEFAULTSTICKYKEYSON        0x00000002
#define ACCF_DEFAULTMOUSEKEYSON         0x00000004
#define ACCF_DEFAULTTOGGLEKEYSON        0x00000008
#define ACCF_DEFAULTTIMEOUTON           0x00000010
#define ACCF_DEFAULTKEYBOARDPREF        0x00000020
#define ACCF_DEFAULTSCREENREADER        0x00000040
#define ACCF_DEFAULTHIGHCONTRASTON      0x00000080
#define ACCF_ACCESSENABLED              0x00000100
#define ACCF_IGNOREBREAKCODE            0x00000400
#define ACCF_FKMAKECODEPROCESSED        0x00000800
#define ACCF_MKVIRTUALMOUSE             0x00001000
#define ACCF_MKREPEATVK                 0x00002000
#define ACCF_FIRSTTICK                  0x00004000
#define ACCF_SHOWSOUNDSON               0x00008000

/*
 * NOTE: PUDF_ANIMATE must have the same value as MINMAX_ANIMATE.
 */
#define PUDF_ANIMATE                    0x00010000

#define ACCF_KEYBOARDPREF               0x00020000
#define ACCF_SCREENREADER               0x00040000
#define PUDF_BEEP                       0x00080000  /* Warning beeps allowed?                   */
#define PUDF_DRAGFULLWINDOWS            0x00100000  /* Drag xor rect or full windows            */
#define PUDF_ICONTITLEWRAP              0x00200000  /* Wrap icon titles or just use single line */
#define PUDF_FONTSARELOADED             0x00400000
#define PUDF_POPUPINUSE                 0x00800000
#define PUDF_EXTENDEDSOUNDS             0x01000000
#define PUDF_MENUSTATEINUSE             0x02000000
#define PUDF_VDMBOUNDSACTIVE            0x04000000
#define PUDF_ALLOWFOREGROUNDACTIVATE    0x08000000
#define PUDF_DRAGGINGFULLWINDOW         0x10000000
#define PUDF_LOCKFULLSCREEN             0x20000000
#define PUDF_GSMWPINUSE                 0x40000000

#define TEST_ACCF(f)               TEST_FLAG(gdwPUDFlags, f)
#define TEST_BOOL_ACCF(f)          TEST_BOOL_FLAG(gdwPUDFlags, f)
#define SET_ACCF(f)                SET_FLAG(gdwPUDFlags, f)
#define CLEAR_ACCF(f)              CLEAR_FLAG(gdwPUDFlags, f)
#define SET_OR_CLEAR_ACCF(f, fSet) SET_OR_CLEAR_FLAG(gdwPUDFlags, f, fSet)
#define TOGGLE_ACCF(f)             TOGGLE_FLAG(gdwPUDFlags, f)

#define TEST_PUDF(f)               TEST_FLAG(gdwPUDFlags, f)
#define TEST_BOOL_PUDF(f)          TEST_BOOL_FLAG(gdwPUDFlags, f)
#define SET_PUDF(f)                SET_FLAG(gdwPUDFlags, f)
#define CLEAR_PUDF(f)              CLEAR_FLAG(gdwPUDFlags, f)
#define SET_OR_CLEAR_PUDF(f, fSet) SET_OR_CLEAR_FLAG(gdwPUDFlags, f, fSet)
#define TOGGLE_PUDF(f)             TOGGLE_FLAG(gdwPUDFlags, f)

/*
 * Power state stuff
 */

typedef struct tagPOWERSTATE {
    volatile ULONG           fInProgress:1;
    volatile ULONG           fCritical:1;
    volatile ULONG           fOverrideApps:1;
    volatile ULONG           fQueryAllowed:1;
    volatile ULONG           fUIAllowed:1;
    PKEVENT                  pEvent;
    BROADCASTSYSTEMMSGPARAMS bsmParams;
    POWERSTATEPARAMS         psParams;
    ULONG PowerStateTask;
} POWERSTATE, *PPOWERSTATE;

typedef struct _POWER_INIT {
    PVIDEO_WIN32K_CALLBACKS_PARAMS Params;
    PKEVENT   pPowerReadyEvent;
} POWER_INIT, *PPOWER_INIT;

#define POWERON_PHASE  -1
#define LOWPOWER_PHASE  1
#define POWEROFF_PHASE  2

NTSTATUS InitializePowerRequestList(HANDLE hPowerRequestEvent);
VOID     CleanupPowerRequestList(VOID);
VOID     DeletePowerRequestList(VOID);
VOID     xxxUserPowerCalloutWorker(VOID);
VOID     VideoPortCalloutThread(PPOWER_INIT pInitData);

/*
 * Fade-in / fade-out globals.
 */

typedef struct tagFADE {
    HANDLE hsprite;
    HDC hdc;
    HBITMAP hbm;
    POINT ptDst;
    SIZE size;
    DWORD dwTime;
    DWORD dwStart;
    DWORD dwFlags;
#ifdef MOUSE_IP
    COLORREF crColorKey;
#endif
} FADE, *PFADE;

/*
 * Globals are included last because they may require some of the types
 * being defined above.
 */
#include "globals.h"
#include "ddemlsvr.h"
/*
 * If you make a change that requires including strid.h when building
 *  ntuser\rtl, then you need to change the sources/makefil* files so this
 *  file will be built in ntuser\inc; make sure that the output of
 *  mc.exe still goes to the kernel directory; this is because there are
 *  other places (like ntuser\server) where we use the same file name.
 */
#ifndef _USERRTL_
#include "strid.h"
#endif

#include "ntuser.h"

#define TestALPHA(uSetting) (!gbDisableAlpha && TestEffectUP(uSetting))

/*
 * tooltips/tracking prototypes from tooltips.c
 */

typedef struct tagTOOLTIP {
    DWORD dwFlags;
    UINT uTID;
    DWORD dwAnimStart;
    int iyAnim;
    LPWSTR pstr;
} TOOLTIP;

typedef struct tagTOOLTIPWND {
    WND;

    DWORD dwShowDelay;
    DWORD dwHideDelay;
    HDC hdcMem;
    HBITMAP hbmMem;

    TOOLTIP;  // this field must be last!
} TOOLTIPWND, *PTOOLTIPWND;

#define HTEXSCROLLFIRST     60
#define HTSCROLLUP          60
#define HTSCROLLDOWN        61
#define HTSCROLLUPPAGE      62
#define HTSCROLLDOWNPAGE    63
#define HTSCROLLTHUMB       64
#define HTEXSCROLLLAST      64
#define HTEXMENUFIRST       65
#define HTMDISYSMENU        65
#define HTMDIMAXBUTTON      66
#define HTMDIMINBUTTON      67
#define HTMDICLOSE          68
#define HTMENUITEM          69
#define HTEXMENULAST        69

int FindNCHitEx(PWND pwnd, int ht, POINT pt);
void xxxTrackMouseMove(PWND pwnd, int htEx, UINT message);
BOOL xxxHotTrack(PWND pwnd, int htEx, BOOL fDraw);
void xxxResetTooltip(PTOOLTIPWND pttwnd);
void xxxCancelMouseMoveTracking (DWORD dwDTFlags, PWND pwndTrack, int htEx, DWORD dwDTCancel);

/*
 * String range IDs.
 *
 * These are defined here to avoid duplicate entries in strid.mc
 */
#define STR_COLORSTART                   STR_SCROLLBAR
#define STR_COLOREND                     STR_MENUBAR

/*
 * Sprite and Fade related functions and defines.
 */
#define FADE_SHOW           0x00000001
#define FADE_COMPLETED      0x00000002
#define FADE_SHOWN          0x00000004
#define FADE_WINDOW         0x00000008
#define FADE_MENU           0x00000010
#define FADE_TOOLTIP        0x00000020
#ifdef MOUSE_IP
#define FADE_COLORKEY       0x00000040
#define FADE_SONAR          0x00000080
#endif

HDC CreateFade(PWND pwnd, RECT *prc, DWORD dwTime, DWORD dwFlags);
VOID StartFade(void);
VOID StopFade(void);
VOID ShowFade(void);
VOID AnimateFade(void);
__inline DWORD TestFadeFlags(
    DWORD dwFlags)
{
    return (gfade.dwFlags & dwFlags);
}

#ifdef MOUSE_IP

#define IS_SONAR_ACTIVE()       (TestUP(MOUSESONAR) && TestFadeFlags(FADE_SONAR))
#define CLEAR_SONAR_LASTVK()        (void)((TestUP(MOUSESONAR) && gbLastVkForSonar) ? (gbLastVkForSonar = 0) : 0)

BOOL StartSonar();
void StopSonar();

#endif

HANDLE xxxSetLayeredWindow(PWND pwnd, BOOL fRepaintBehind);
VOID UnsetLayeredWindow(PWND pwnd);
void TrackLayeredZorder(PWND pwnd);
VOID UpdateRedirectedDC(PDCE pdce);
BOOL _UpdateLayeredWindow(PWND pwnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc,
        POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags);
BOOL _GetLayeredWindowAttributes(PWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags);
BOOL _SetLayeredWindowAttributes(PWND pwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
BOOL RecreateRedirectionBitmap(PWND pwnd);
VOID ResetRedirectedWindows(VOID);

PWND GetStyleWindow(PWND pwnd, DWORD dwStyle);
PWND GetLastChild(PWND pwnd);

BOOL SetRedirectedWindow(PWND pwnd, UINT uFlags);
VOID UnsetRedirectedWindow(PWND pwnd, UINT uFlags);
VOID ConvertRedirectionDCs(PWND pwnd, HBITMAP hbm);
VOID xxxCompositedPaint(PWND pwnd);

#define REDIRECT_LAYER                     0x0001
#define REDIRECT_COMPOSITED                0x0002
#define REDIRECT_EXTREDIRECTED             0x0004
#define REDIRECT_PRINT                     0x0008

typedef struct tagREDIRECT {
    HBITMAP hbm;
    RECT rcUpdate;
    UINT uFlags;
    HRGN hrgnComp;

#if DBG
    PWND pwnd;
#endif // DBG

} REDIRECT, *PREDIRECT;

HBITMAP GetRedirectionBitmap(PWND pwnd);
BOOL SetRedirectionBitmap(PWND pwnd, HBITMAP hbm);
UINT GetRedirectionFlags(PWND pwnd);
BOOL xxxPrintWindow(PWND pwnd, HDC hdcBlt, UINT nFlags);
void xxxTurnOffCompositing(PWND pwndStart, BOOL fChild);


#ifdef REDIRECTION
BOOL xxxSetProcessRedirectionMode(BOOL fEnable, PPROCESSINFO ppi);
BOOL xxxSetDesktopRedirectionMode(BOOL fEnable, PDESKTOP pDesk, PPROCESSINFO ppi);
#endif // REDIRECTION

void InternalInvalidate3(
    PWND pwnd,
    HRGN hrgn,
    DWORD flags);

BOOL UserSetFont(PUNICODE_STRING pProfileUserName,
    LPLOGFONTW   lplf,
    UINT         idFont,
    HFONT*       phfont
    );

HICON DWP_GetIcon(
    PWND pwnd,
    UINT uType);

BOOL xxxRedrawTitle(
    PWND pwnd, UINT wFlags);

DWORD GetContextHelpId(
    PWND pwnd);


HANDLE xxxClientCopyImage(
    HANDLE hImage,
    UINT type,
    int cxNew,
    int cyNew,
    UINT flags);

VOID _WOWCleanup(
    HANDLE hInstance,
    DWORD hTaskWow);

VOID _WOWModuleUnload(HANDLE hModule);

/*
 * FastProfile APIs
 */
typedef struct tagPROFINTINFO {
    UINT idSection;
    LPWSTR lpKeyName;
    DWORD  nDefault;
    PUINT puResult;
} PROFINTINFO, *PPROFINTINFO;

typedef struct {
    UINT idSection;
    UINT id;
    UINT idRes;
    UINT def;
} SPINFO, *PSPINFO;


#define DEFAULT_USER_HANDLE_QUOTA  10000
#define DEFAULT_POSTMESSAGE_LIMIT  10000

/*
 * See aFastRegMap[] in ntuser\kernel\profile.c
 */
#define PMAP_COLORS                      0
#define PMAP_CURSORS                     1
#define PMAP_WINDOWSM                    2
#define PMAP_WINDOWSU                    3
#define PMAP_DESKTOP                     4
#define PMAP_ICONS                       5
#define PMAP_FONTS                       6
#define PMAP_TRUETYPE                    7
#define PMAP_KBDLAYOUT                   8
#define PMAP_INPUT                       9
#define PMAP_COMPAT                     10
#define PMAP_SUBSYSTEMS                 11
#define PMAP_BEEP                       12
#define PMAP_MOUSE                      13
#define PMAP_KEYBOARD                   14
#define PMAP_STICKYKEYS                 15
#define PMAP_KEYBOARDRESPONSE           16
#define PMAP_MOUSEKEYS                  17
#define PMAP_TOGGLEKEYS                 18
#define PMAP_TIMEOUT                    19
#define PMAP_SOUNDSENTRY                20
#define PMAP_SHOWSOUNDS                 21
#define PMAP_AEDEBUG                    22
#define PMAP_NETWORK                    23
#define PMAP_METRICS                    24
#define PMAP_UKBDLAYOUT                 25
#define PMAP_UKBDLAYOUTTOGGLE           26
#define PMAP_WINLOGON                   27
#define PMAP_KEYBOARDPREF               28
#define PMAP_SCREENREADER               29
#define PMAP_HIGHCONTRAST               30
#define PMAP_IMECOMPAT                  31
#define PMAP_IMM                        32
#define PMAP_POOLLIMITS                 33
#define PMAP_COMPAT32                   34
#define PMAP_SETUPPROGRAMNAMES          35
#define PMAP_INPUTMETHOD                36
#define PMAP_COMPAT2                    37
#define PMAP_MOUCLASS_PARAMS            38
#define PMAP_KBDCLASS_PARAMS            39
#define PMAP_COMPUTERNAME               40
#define PMAP_TS                         41
#define PMAP_TABLETPC                   42
#define PMAP_MEDIACENTER                43
#define PMAP_TS_EXCLUDE_DESKTOP_VERSION 44
#define PMAP_LAST                       44

#define MAXPROFILEBUF 256

#define POLICY_NONE     0x0001
#define POLICY_USER     0x0002
#define POLICY_MACHINE  0x0004
#define POLICY_REMOTE   0x0008
#define POLICY_ONLY     0x0010
/*
 * POLICY_REMOTE is not included in POLICY_ALL intentionally.
 * Else, we will try to read the remote policy always.
 */
#define POLICY_ALL      (POLICY_NONE | POLICY_USER | POLICY_MACHINE)
#define POLICY_VALID    (POLICY_ALL | POLICY_ONLY | POLICY_REMOTE)

PUNICODE_STRING CreateProfileUserName(TL *ptl);
void FreeProfileUserName(PUNICODE_STRING pProfileUserName,TL *ptl);
HANDLE  OpenCacheKeyEx(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, ACCESS_MASK amRequest, PDWORD pdwPolicyFlags);
BOOL    CheckDesktopPolicy(PUNICODE_STRING pProfileUserName OPTIONAL, PCWSTR lpKeyName);
BOOL    CheckDesktopPolicyChange(PUNICODE_STRING pProfileUserName OPTIONAL);
DWORD   FastGetProfileKeysW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR pszDefault, LPWSTR *ppszKeys);
BOOL    FastGetProfileDwordW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName, DWORD dwDefault, PDWORD pdwReturn, DWORD dwPolicyOnly);
DWORD   FastGetProfileStringW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, DWORD dwPolicyOnly);
BOOL    FastGetProfileIntW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName, UINT nDefault, PUINT puiReturn, DWORD dwPolicyOnly);
BOOL    FastWriteProfileStringW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName, LPCWSTR lpString);
BOOL    FastGetProfileIntFromID(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, UINT idKey, int def, PINT pResult, DWORD dwPolicyOnly);
DWORD   FastGetProfileStringFromIDW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, UINT idKey, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD cch, DWORD dwPolicyOnly);
BOOL    FastWriteProfileValue(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName, UINT uType, LPBYTE lpStruct, UINT cbSizeStruct);
DWORD   FastGetProfileValue(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName,LPBYTE lpDefault, LPBYTE lpReturn, UINT cbSizeReturn, DWORD dwPolicyOnly);
BOOL    FastGetProfileIntsW(PUNICODE_STRING pProfileUserName OPTIONAL, PPROFINTINFO ppii, DWORD dwPolicyOnly);
BOOL    FastUpdateWinIni(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, UINT wKeyNameId, LPWSTR lpszValue);

/*
 * # of pels added to border width. When a user requests a border width of 1
 * that user actualy gets a border width of BORDER_EXTRA + 1 if the window
 * has a sizing border.
 */
#define BORDER_EXTRA    3

/*
 * tmswitch.c stuff
 */

__inline int GetCaptionHeight(
    PWND pwnd)
{
    if (!TestWF(pwnd, WFCPRESENT)) {
        return 0;
    } else {
        return TestWF(pwnd, WEFTOOLWINDOW) ?
                   SYSMET(CYSMCAPTION) : SYSMET(CYCAPTION);
    }
}

__inline VOID InitTooltipDelay(
    PTOOLTIPWND pttwnd)
{
    if (pttwnd != NULL) {
        pttwnd->dwShowDelay = gdtDblClk * 3;
        pttwnd->dwHideDelay = gdtDblClk * 8;
    }
}

__inline PPROFILEVALUEINFO UPDWORDPointer(
    UINT uSetting)
{
    UserAssert(UPIsDWORDRange(uSetting));
    return gpviCPUserPreferences + UPDWORDIndex(uSetting);
}


/*
 * ComputeTickDelta
 *
 * ComputeTickDelta computes a time delta between two times. The
 * delta is defined as a 31-bit, signed value. It is best to think of time as
 * a clock that wraps around. The delta is the minimum distance on this circle
 * between two different places on the circle. If the delta goes
 * counter-clockwise, it is looking at a time in the PAST and is POSITIVE. If
 * the delta goes clockwise, it is looking at a time in the FUTURE and is
 * negative.
 *
 * It is IMPORTANT to realize that the (dwCurTime >= dwLastTime) comparison does
 * not determine the delta's sign, but only determines the operation to compute
 * the delta without an overflow occuring.
 */
__inline
int ComputeTickDelta(
        IN DWORD dwCurTick,
        IN DWORD dwLastTick)
{
    return (int) dwCurTick - dwLastTick;
}


__inline
DWORD ComputePastTickDelta(
        IN DWORD dwCurTick,
        IN DWORD dwLastTick)
{
    /*
     * This handles a wrap-around.
     */
    return dwCurTick - dwLastTick;
}

__inline BOOL IsTimeFromLastInput(
    DWORD dwTimeout)
{
    return ((NtGetTickCount() - glinp.timeLastInputMessage) > dwTimeout);
}

__inline BOOL IsTimeFromLastRITEvent(
    DWORD dwTimeout)
{
    return ((NtGetTickCount() - gpsi->dwLastRITEventTickCount) > dwTimeout);
}

#if DBG
__inline void DBGIncModalMenuCount(
    VOID)
{
    guModalMenuStateCount++;
}

__inline VOID DBGDecModalMenuCount(
    VOID)
{
    UserAssert(guModalMenuStateCount != 0);
    guModalMenuStateCount--;
}
#else
#define DBGIncModalMenuCount()
#define DBGDecModalMenuCount()
#endif

__inline BOOL IsForegroundLocked(
    VOID)
{
    return (guSFWLockCount != 0 || gppiLockSFW != NULL);
}


/*
 * Compatibility hack for foreground activation problems.
 */
__inline
BOOL GiveUpForeground(
    VOID)
{
    if (gptiForeground == NULL) {
        return FALSE;
    }

    if (GetAppCompatFlags2ForPti(gptiForeground, VER40) & GACF2_GIVEUPFOREGROUND) {
        TAGMSG0(DBGTAG_FOREGROUND, "GiveUpForeground Hack Succeeded!");
        return TRUE;
    }

    return FALSE;
}

__inline VOID IncSFWLockCount(
    VOID)
{
    guSFWLockCount++;
}

__inline VOID DecSFWLockCount(
    VOID)
{
    UserAssert(guSFWLockCount != 0);
    guSFWLockCount--;
}

__inline DWORD UPDWORDValue(
    UINT uSetting)
{
    return UPDWORDPointer(uSetting)->dwValue;
}
/*
 * Use this macro ONLY if UPIsDWORDRange(SPI_GET ## uSetting) is TRUE.
 */
#define UP(uSetting) UPDWORDValue(SPI_GET ## uSetting)

/*
 * NTIMM.C
 */

#define IMESHOWSTATUS_NOTINITIALIZED    ((BOOL)0xffff)

PIMC CreateInputContext(
    IN ULONG_PTR dwClientImcData);

BOOL DestroyInputContext(
    IN PIMC pImc);

VOID FreeInputContext(
    IN PIMC pImc);

HIMC AssociateInputContext(
    IN PWND pWnd,
    IN PIMC pImc);

AIC_STATUS AssociateInputContextEx(
    IN PWND  pWnd,
    IN PIMC  pImc,
    IN DWORD dwFlag);

BOOL UpdateInputContext(
    IN PIMC pImc,
    IN UPDATEINPUTCONTEXTCLASS UpdateType,
    IN ULONG_PTR UpdateValue);

VOID xxxFocusSetInputContext(
    IN PWND pwnd,
    IN BOOL fActivate,
    IN BOOL fQueueMsg);

UINT BuildHimcList(
    PTHREADINFO pti,
    UINT cHimcMax,
    HIMC *phimcFirst);

PWND xxxCreateDefaultImeWindow(
    IN PWND pwnd,
    IN ATOM atomT,
    IN HANDLE hInst);

BOOL xxxImmActivateThreadsLayout(
    PTHREADINFO pti,
    PTLBLOCK    ptlBlockPrev,
    PKL         pkl);

VOID xxxImmActivateAndUnloadThreadsLayout(
    IN PTHREADINFO *ptiList,
    IN UINT         nEntries,
    IN PTLBLOCK     ptlBlockPrev,
    PKL             pklCurrent,
    DWORD           dwHklReplace);

VOID xxxImmActivateLayout(
    IN PTHREADINFO pti,
    IN PKL pkl);

VOID xxxImmUnloadThreadsLayout(
    IN PTHREADINFO *ptiList,
    IN UINT         nEntry,
    IN PTLBLOCK     ptlBlockPrev,
    IN DWORD        dwFlag);

VOID xxxImmUnloadLayout(
    IN PTHREADINFO pti,
    IN DWORD       dwFlag);

PIMEINFOEX xxxImmLoadLayout(
    IN HKL hKL);

VOID xxxImmActivateLayout(
    IN PTHREADINFO pti,
    IN PKL pkl);

BOOL GetImeInfoEx(
    IN PWINDOWSTATION pwinsta,
    IN PIMEINFOEX piiex,
    IN IMEINFOEXCLASS SearchType);

BOOL SetImeInfoEx(
    IN PWINDOWSTATION pwinsta,
    IN PIMEINFOEX piiex);

DWORD xxxImmProcessKey(
    IN PQ   pq,
    IN PWND pwnd,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam);

BOOL GetImeHotKey(
    DWORD dwHotKeyID,
    PUINT puModifiers,
    PUINT puVKey,
    HKL   *phKL );

BOOL  SetImeHotKey(
    DWORD  dwHotKeyID,
    UINT   uModifiers,
    UINT   uVKey,
    HKL    hKL,
    DWORD  dwAction );

PIMEHOTKEYOBJ CheckImeHotKey(
    PQ   pq,
    UINT uVKey,
    LPARAM lParam);

BOOL ImeCanDestroyDefIME(
    IN PWND pwndDefaultIme,
    IN PWND pwndDestroy);

BOOL IsChildSameThread(
    IN PWND pwndParent,
    IN PWND pwndChild);

BOOL ImeCanDestroyDefIMEforChild(
    IN PWND pwndDefaultIme,
    IN PWND pwndDestroy);

VOID ImeCheckTopmost(
    IN PWND pwnd);

VOID ImeSetOwnerWindow(
    IN PWND pwndIme,
    IN PWND pwndNewOwner);

VOID ImeSetFutureOwner(
    IN PWND pwndDefaultIme,
    IN PWND pwndOrgOwner);

VOID ImeSetTopmostChild(
    IN PWND pwndRoot,
    IN BOOL fFlag);

VOID ImeSetTopmost(
    IN PWND pwndRoot,
    IN BOOL fFlag,
    IN PWND pwndInsertBefore);

PSOFTKBDDATA ProbeAndCaptureSoftKbdData(
    PSOFTKBDDATA Source);

VOID xxxNotifyIMEStatus(
    IN PWND pwnd,
    IN DWORD dwOpen,
    IN DWORD dwConversion );

BOOL xxxSetIMEShowStatus(
    IN BOOL fShow);

VOID xxxBroadcastImeShowStatusChange(
    IN PWND pwndDefIme,
    IN BOOL fShow);

VOID xxxCheckImeShowStatusInThread(
    IN PWND pwndDefIme);


#define IsWndImeRelated(pwnd)   \
    (pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME] || \
     TestCF(pwnd, CFIME))

/*
 * Critical section routines for processing mouse input
 */
__inline VOID EnterMouseCrit(
    VOID)
{

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(gpresMouseEventQueue, TRUE);
}

__inline VOID LeaveMouseCrit(
    VOID)
{

    ExReleaseResourceLite(gpresMouseEventQueue);
    KeLeaveCriticalRegion();
}

#if DBG
#define EnterDeviceInfoListCrit _EnterDeviceInfoListCrit
#define LeaveDeviceInfoListCrit _LeaveDeviceInfoListCrit
VOID _EnterDeviceInfoListCrit();
VOID _LeaveDeviceInfoListCrit();
#else
/*
 * Critical section routines for accessing the Device List (gpDeviceInfoList)
 */
__inline VOID EnterDeviceInfoListCrit(
    VOID)
{
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(gpresDeviceInfoList, TRUE);
}
__inline VOID LeaveDeviceInfoListCrit(
    VOID)
{
    ExReleaseResourceLite(gpresDeviceInfoList);
    KeLeaveCriticalRegion();
}
#endif // DBG

#define BEGIN_REENTER_DEVICEINFOLISTCRIT()                              \
{                                                                       \
    BOOL fAlreadyHadDeviceInfoCrit;                                     \
                                                                        \
    /*                                                                  \
     * If we're not in the user crit then acquire it.                   \
     */                                                                 \
    fAlreadyHadDeviceInfoCrit = ExIsResourceAcquiredExclusiveLite(gpresDeviceInfoList); \
    if (fAlreadyHadDeviceInfoCrit == FALSE) {                           \
        EnterDeviceInfoListCrit();                                      \
    }

#define END_REENTER_DEVICEINFOLISTCRIT()                                \
    if (fAlreadyHadDeviceInfoCrit == FALSE) {                           \
       LeaveDeviceInfoListCrit();                                       \
    }                                                                   \
}


/*
 * Request RIT to update the keyboard h/w settings
 */
__inline VOID RequestKeyboardRateUpdate(
    VOID)
{
    gdwUpdateKeyboard |= UPDATE_KBD_TYPEMATIC;
}



/*
 * Keep some capture state visible from user-mode for performance.
 */
__inline VOID LockCaptureWindow(
    PQ pq,
    PWND pwnd)
{
    if (pq->spwndCapture) {
        UserAssert(gpsi->cCaptures > 0);
        gpsi->cCaptures--;
    }

    if (pwnd) {
        gpsi->cCaptures++;
    }

    Lock(&pq->spwndCapture, pwnd);
}

__inline VOID UnlockCaptureWindow(
    PQ pq)
{
    if (pq->spwndCapture) {
        UserAssert(gpsi->cCaptures > 0);
        gpsi->cCaptures--;
        Unlock(&pq->spwndCapture);
    }
}

/*
 * Some routines for manipulating desktop and windowstation handles.
 */
#define HF_DESKTOPHOOK  0       // offset to desktop hook flag
#define HF_PROTECTED    1       // offset to protected flag
#define HF_LIMIT        2       // number of flags per handle

BOOL SetHandleFlag(HANDLE hObject, DWORD dwFlag, BOOL fSet);
BOOL CheckHandleFlag(PEPROCESS Process, DWORD dwSessionId, HANDLE hObject, DWORD dwFlag);
VOID SetHandleInUse(HANDLE hObject);
BOOL CheckHandleInUse(HANDLE hObject);

__inline NTSTATUS CloseProtectedHandle(
    HANDLE handle)
{
    if (handle != NULL) {
        SetHandleFlag(handle, HF_PROTECTED, FALSE);
        return ZwClose(handle);
    }

    return STATUS_SUCCESS;
}

__inline VOID EnterHandleFlagsCrit(
    VOID)
{
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpHandleFlagsMutex);
}

__inline VOID LeaveHandleFlagsCrit(
    VOID)
{
    ExReleaseFastMutexUnsafe(gpHandleFlagsMutex);
    KeLeaveCriticalRegion();
}

// multimon apis

BOOL    xxxEnumDisplayMonitors(
                HDC             hdc,
                LPRECT          lprcClip,
                MONITORENUMPROC lpfnEnum,
                LPARAM          dwData,
                BOOL            fInternal);

BOOL    xxxClientMonitorEnumProc(
                HMONITOR        hMonitor,
                HDC             hdcMonitor,
                LPRECT          lprc,
                LPARAM          dwData,
                MONITORENUMPROC xpfnProc);

VOID    ClipPointToDesktop(LPPOINT lppt);
VOID    DestroyMonitor(PMONITOR pMonitor);
BOOL    GetHDevName(HMONITOR hMon, PWCHAR pName);
ULONG   HdevFromMonitor(PMONITOR pMonitor);

/*
 * The global to assure the atomicness of
 * the monitor update.
 */
extern DWORD gdwMonitorBusy;

/*
 * Rebasing functions for shared memory.
 */
#define REBASESHAREDPTR(p)       (p)
#define REBASESHAREDPTRALWAYS(p) (p)

#define PDEV_ENABLED() \
    InterlockedExchange((LPLONG)&gbMDEVDisabled, FALSE);

#define PDEV_DISABLED() \
    InterlockedExchange((LPLONG)&gbMDEVDisabled, TRUE);

__inline BOOL SafeEnableMDEV(
    VOID)
{
    if (gbMDEVDisabled) {
        if (DrvEnableMDEV(gpDispInfo->pmdev, TRUE)) {
            PDEV_ENABLED();
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        RIPMSGF0(RIP_WARNING, "Trying to enable an enabled MDEV");
        return TRUE;
    }
}

__inline BOOL SafeDisableMDEV(
    VOID)
{
    if (!gbMDEVDisabled) {
        if (DrvDisableMDEV(gpDispInfo->pmdev, TRUE)) {
            PDEV_DISABLED();
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        RIPMSGF0(RIP_WARNING, "Trying to disable a disabled MDEV");
        return TRUE;
    }
}

/*
 * Multimonitor macros used in RTL. There are similar definitions
 * in client\usercli.h
 */
__inline PDISPLAYINFO
GetDispInfo(
    VOID)
{
    return gpDispInfo;
}

__inline PMONITOR
GetPrimaryMonitor(
    VOID)
{
    return REBASESHAREDPTRALWAYS(GetDispInfo()->pMonitorPrimary);
}

VOID _QueryUserHandles(
        IN  LPDWORD     lpIn,
        IN  DWORD       dwInLength,
        OUT DWORD       pdwResult[][TYPE_CTYPES]);



#define REMOVE_FROM_LIST(type, pstart, pitem, next) \
    {                                                           \
        type** pp;                                              \
                                                                \
        for (pp = &pstart; *pp != NULL; pp = &(*pp)->next) {    \
            if (*pp == pitem) {                                 \
                *pp = pitem->next;                              \
                break;                                          \
            }                                                   \
        }                                                       \
    }                                                           \


#define HH_DRIVERENTRY              0x00000001
#define HH_USERINITIALIZE           0x00000002
#define HH_INITVIDEO                0x00000004
#define HH_REMOTECONNECT            0x00000008
#define HH_REMOTEDISCONNECT         0x00000010
#define HH_REMOTERECONNECT          0x00000020
#define HH_REMOTELOGOFF             0x00000040
#define HH_DRIVERUNLOAD             0x00000080
#define HH_GRECLEANUP               0x00000100
#define HH_USERKCLEANUP             0x00000200
#define HH_INITIATEWIN32KCLEANUP    0x00000400
#define HH_ALLDTGONE                0x00000800
#define HH_RITGONE                  0x00001000
#define HH_RITCREATED               0x00002000
#define HH_LOADCURSORS              0x00004000
#define HH_KBDLYOUTGLOBALCLEANUP    0x00008000
#define HH_KBDLYOUTFREEWINSTA       0x00010000
#define HH_CLEANUPRESOURCES         0x00020000
#define HH_DISCONNECTDESKTOP        0x00040000
#define HH_DTQUITPOSTED             0x00080000
#define HH_DTQUITRECEIVED           0x00100000
#define HH_DTWAITONHANDLES          0x00400000

#define HYDRA_HINT(ev)  (gdwHydraHint |= ev)

#if DBG
    VOID TrackAddDesktop(PVOID pDesktop);
    VOID TrackRemoveDesktop(PVOID pDesktop);
    VOID DumpTrackedDesktops(BOOL bBreak);

    #define DbgTrackAddDesktop(pdesk) TrackAddDesktop(pdesk)
    #define DbgTrackRemoveDesktop(pdesk) TrackRemoveDesktop(pdesk)
    #define DbgDumpTrackedDesktops(b) DumpTrackedDesktops(b)
#else
    #define DbgTrackAddDesktop(pdesk)
    #define DbgTrackRemoveDesktop(pdesk)
    #define DbgDumpTrackedDesktops(b)
#endif

#if DBG
    #define TRACE_HYDAPI(m)                                     \
        if (gbTraceHydraApi) {                                  \
            KdPrint(("HYD-%d API: ", gSessionId));              \
            KdPrint(m);                                         \
        }
#else
    #define TRACE_HYDAPI(m)
#endif

#if DBG
    #define TRACE_DESKTOP(m)                                    \
        if (gbTraceDesktop) {                                   \
            KdPrint(("HYD-%d DT ", gSessionId));                \
            KdPrint(m);                                         \
        }
#else
    #define TRACE_DESKTOP(m)
#endif

NTSTATUS
RemoteConnect(
    IN PDOCONNECTDATA pDoConnectData,
    IN ULONG DisplayDriverNameLength,
    IN PWCHAR DisplayDriverName);

NTSTATUS
xxxRemoteDisconnect(
    VOID);

NTSTATUS
xxxRemoteConsoleShadowStop(
    VOID);


NTSTATUS
xxxRemoteReconnect(
    IN PDORECONNECTDATA pDoReconnectData);


NTSTATUS
xxxRemoteNotify(
    IN PDONOTIFYDATA pDoNotifyData);

NTSTATUS
RemoteLogoff(
    VOID);

BOOL
PrepareForLogoff(
    UINT uFlags);

NTSTATUS
xxxRemoteStopScreenUpdates(
    VOID);

VOID xxxPushKeyEvent(
    BYTE  bVk,
    BYTE  bScan,
    DWORD dwFlags,
    DWORD dwExtraInfo);

NTSTATUS
RemoteThinwireStats(
    OUT PVOID Stats);

NTSTATUS
RemoteNtSecurity(
    VOID);

NTSTATUS
xxxRemoteShadowSetup(
    VOID);

NTSTATUS
RemoteShadowStart(
    IN PVOID pThinwireData,
    ULONG ThinwireDataLength);

NTSTATUS
xxxRemoteShadowStop(
    VOID);

NTSTATUS
RemoteShadowCleanup(
    IN PVOID pThinwireData,
    ULONG ThinwireDataLength);

NTSTATUS
xxxRemotePassthruEnable(
    VOID);

NTSTATUS
RemotePassthruDisable(
    VOID);

NTSTATUS
CtxDisplayIOCtl(
    ULONG  DisplayIOCtlFlags,
    PUCHAR pDisplayIOCtlData,
    ULONG  cbDisplayIOCtlData);

DWORD
RemoteConnectState(
    VOID);

BOOL
_GetWinStationInfo(
    WSINFO* pWsInfo);

// from fullscr.c

NTSTATUS
RemoteRedrawRectangle(
    WORD Left,
    WORD Top,
    WORD Right,
    WORD Bottom);

NTSTATUS
RemoteRedrawScreen(
    VOID);

NTSTATUS
RemoteDisableScreen(
    VOID);

// from fekbd.c
VOID
NlsKbdSendIMEProc(
    DWORD dwImeOpen,
    DWORD dwImeConversion);


/*
 * Additional menu functions (dependant on previous inline functions)
 */
__inline BOOL MNIsFlatMenu(
    VOID)
{
    return TestEffectUP(FLATMENU);
}

VOID SetMouseTrails(UINT n);
VOID HideMouseTrails(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam);


#if DBG
#define CheckPublicDC(lpszStr, hdc)                                         \
{                                                                           \
    if (GreGetObjectOwner((HOBJ)hdc, DC_TYPE) == OBJECT_OWNER_PUBLIC) {     \
        RIPMSG1(RIP_ERROR, lpszStr, hdc);                                   \
    }                                                                       \
}
#else
#define CheckPublicDC(lpszStr, hdc)
#endif
#define szMESSAGE   L"Message"

#ifdef LAME_BUTTON

/*
 * Lame button constants -- HKCU\Control Panel\Desktop\LameButtonEnabled.
 */
#define LBUTTON_DIALOG      0x4
#define LBUTTON_TOPLEVEL    0x8

__inline BOOL NeedsLameButton(
    PWND pwnd,
    PWND pwndParent)
{
    /*
     * Windows with the WS_EX_TOOLWINDOW style can't have a lame button (see
     * Windows Bug #237648), nor can consoles.
     */
    if (TestWF(pwnd, WEFTOOLWINDOW) || PsGetCurrentProcess() == gpepCSRSS) {
        return FALSE;
    } else if (pwndParent != NULL && GETFNID(pwndParent) == FNID_DESKTOP) {
        return (gdwLameFlags & LBUTTON_TOPLEVEL) != 0;
    } else if (GETFNID(pwnd) == FNID_DIALOG) {
        return (gdwLameFlags & LBUTTON_DIALOG) != 0;
    } else {
        return FALSE;
    }
}
#endif // LAME_BUTTON

#ifdef TRACK_PNP_NOTIFICATION

typedef enum tagPNP_NOTIFICATION_TYPE {
    PNP_NTF_CLASSNOTIFY,
    PNP_NTF_CREATEDEVICEINFO,
    PNP_NTF_FREEDEVICEINFO,
    PNP_NTF_PROCESSDEVICECHANGES,
    PNP_NTF_REQUESTDEVICECHANGE,
    PNP_NTF_DEVICENOTIFY,
    PNP_NTF_FREEDEVICEINFO_DEFERRED,
    PNP_NTF_CLOSEDEVICE,
    PNP_NTF_DEVICENOTIFY_UNLISTED,
    PNP_NTF_UNREGISTER_NOTIFICATION,
    PNP_NTF_UNREGISTER_REMOTE_CANCELLED,
} PNP_NOTIFICATION_TYPE;

typedef struct tagPNP_NOTIFICATION_RECORD {
    UINT iSeq;
    PNP_NOTIFICATION_TYPE type;
    PVOID pKThread;
    PDEVICEINFO pDeviceInfo;
    HANDLE hDeviceInfo;
    UCHAR szPathName[80];
    ULONG_PTR NotificationCode;
    PVOID trace[LOCKRECORD_STACK];
} PNP_NOTIFICATION_RECORD, *PPNP_NOTIFICATION_RECORD;

VOID CleanupPnpNotificationRecord(
    VOID);

VOID RecordPnpNotification(
    PNP_NOTIFICATION_TYPE type,
    PDEVICEINFO pDeviceInfo,
    ULONG_PTR NotificationCode);

extern BOOL gfRecordPnpNotification;

#endif // TRACK_PNP_NOTIFICATION

#ifdef SUBPIXEL_MOUSE
VOID BuildMouseAccelerationCurve(
    PMONITOR pMonitor);

VOID DoNewMouseAccel(
    INT *dx,
    INT *dw);

VOID ReadDefaultAccelerationCurves(
    PUNICODE_STRING pProfileUserName);

VOID ResetMouseAccelerationCurves(
    VOID);
#endif // SUBPIXEL_MOUSE

#ifdef AUTORUN_CURSOR
VOID ShowAutorunCursor(
    ULONG ulTimeout);

VOID HideAutorunCursor(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam);
#endif // AUTORUN_CURSOR

/*
 * These must go after globals.h is #include'd, as they're inline functions and
 * they use gptiCurrent (indirectly, by way of ThreadLock()).
 */
__inline VOID ThreadLockMenuNoModify(
    PMENU pMenu,
    PTL ptl)
{
    UserAssert(!TestMF(pMenu, MFREADONLY));
    SetMF(pMenu, MFREADONLY);
    ThreadLock(pMenu, ptl);
}

__inline VOID ThreadLockMenuAlwaysNoModify(
    PMENU pMenu,
    PTL ptl)
{
    UserAssert(!TestMF(pMenu, MFREADONLY));
    SetMF(pMenu, MFREADONLY);
    ThreadLockAlways(pMenu, ptl);
}

__inline VOID ThreadUnlockMenuNoModify(
    PTL ptl)
{
    UserAssert(TestMF((PMENU)ptl->pobj, MFREADONLY));
    ClearMF((PMENU)ptl->pobj, MFREADONLY);
    ThreadUnlock(ptl);
}

__inline int
SetBestStretchMode(
    HDC hdc,
    UINT bpp,
    BOOL fHT)
{
    return GreSetStretchBltMode(
                   hdc,
                   ((fHT) ?
                       HALFTONE : ((bpp == 1) ? BLACKONWHITE : COLORONCOLOR)));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\winable.c ===
/**************************** Module Header ********************************\
* Module Name: winable.c
*
* This has the stuff for WinEvents:
*     NotifyWinEvent
*     _SetWinEventHook
*     UnhookWinEventHook
*
* All other additions to USER for Active Accessibility are in winable2.c.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* Based on snapshot taken from:
*  \\trango\slmro\proj\win\src\CORE\access\user_40\user32 on 8/29/96
* 08-30-96 IanJa  Ported from Windows '95
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#if DBG
int gnNotifies;

__inline VOID DBGVERIFYEVENTHOOK(
    PEVENTHOOK peh)
{
    HMValidateCatHandleNoSecure(PtoH(peh), TYPE_WINEVENTHOOK);
    UserAssert(peh->eventMin <= peh->eventMax);
}

__inline VOID DBGVERIFYNOTIFY(
    PNOTIFY pNotify)
{
    UserAssert(pNotify->spEventHook != NULL);
    UserAssert(pNotify->spEventHook->fSync || (pNotify->dwWEFlags & WEF_ASYNC));
}

#else
#define DBGVERIFYEVENTHOOK(peh)
#define DBGVERIFYNOTIFY(pNotify)
#endif

/*
 * Pending Event Notifications (sync and async).
 */
static NOTIFY notifyCache;
static BOOL fNotifyCacheInUse;


/*
 * Local to this module.
 */
WINEVENTPROC xxxGetEventProc(
    PEVENTHOOK pEventOrg);

PNOTIFY CreateNotify(
    PEVENTHOOK peh,
    DWORD event,
    PWND pwnd,
    LONG idObject,
    LONG idChild,
    PTHREADINFO ptiEvent,
    DWORD dwTime);


/*****************************************************************************\
* xxxProcessNotifyWinEvent
*
* Posts or Sends a WinEvent notification.
*
* Post: uses PostEventMesage - does not leave the critical section.
* Send: makes a callback to user-mode - does leave the critical section.
*
* If this is a system thread (RIT, Desktop or Console) then synchronously
* hooked (WINEVENT_INCONTEXT) events are forced to be asynchronous.
*
* We return the next win event hook in the list.
\*****************************************************************************/
PEVENTHOOK xxxProcessNotifyWinEvent(
    PNOTIFY pNotify)
{
    WINEVENTPROC   pfn;
    PEVENTHOOK     pEventHook;
    TL             tlpEventHook;
    PTHREADINFO    ptiCurrent = PtiCurrent();

    pEventHook = pNotify->spEventHook;
    DBGVERIFYEVENTHOOK(pEventHook);
    UserAssert(pEventHook->head.cLockObj);

    if (((pNotify->dwWEFlags & (WEF_ASYNC | WEF_POSTED)) == WEF_ASYNC)
        ||
        (ptiCurrent->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD | TIF_INCLEANUP))

        ||
        (!RtlEqualLuid(&GETPTI(pEventHook)->ppi->luidSession, &ptiCurrent->ppi->luidSession) &&
         !(ptiCurrent->TIF_flags & TIF_ALLOWOTHERACCOUNTHOOK))

        ||
        (GETPTI(pEventHook)->ppi != ptiCurrent->ppi &&
         IsRestricted(GETPTI(pEventHook)->pEThread))

#if defined(_WIN64)
        ||
        ((GETPTI(pEventHook)->TIF_flags & TIF_WOW64) != (ptiCurrent->TIF_flags & TIF_WOW64))
#endif
        ) {
        /*
         * POST
         *
         * WinEvent Hook set without WINEVENT_INCONTEXT flag are posted;
         * Events from system threads are posted because there is no user-mode
         *    part to callback to;
         * Console is not permitted to load DLLs, so we must post back to the
         *    hooking application;
         * DLLs can not be loaded cross bit type(32bit to 64bit) on 64bit NT
         *    so we must post(It may be usefull to let the app be aware and
         *    even supply both a 32bit and a 64bit DLL that are aware of each other);
         * Threads in cleanup can't get called back, so turn their
         *    notifications into async ones. (Better late than never).
         *
         * If forcing these events ASYNC is unacceptable, we might consider
         * doing system/console SYNC events like low-level hooks (sync with
         * timeout: but may have to post it if the timeout expires) - IanJa
         */
        PQ pqReceiver = GETPTI(pEventHook)->pq;
        PEVENTHOOK pEventHookNext = pEventHook->pehNext;

        BEGINATOMICCHECK();

        DBGVERIFYNOTIFY(pNotify);
        pNotify->dwWEFlags |= WEF_POSTED | WEF_ASYNC;
        if (!pqReceiver || (GETPTI(pEventHook) == gptiRit) ||
                pEventHook->fDestroyed ||
                !PostEventMessage(GETPTI(pEventHook), pqReceiver,
                                  QEVENT_NOTIFYWINEVENT,
                                  NULL, 0, 0, (LPARAM)pNotify)) {
            /*
             * If the receiver doesn't have a queue or the
             * post failed (low memory), cleanup what we just
             * created.
             * Note: destroying the notification may destroy pEventHook too.
             */
            RIPMSG2(RIP_WARNING,
                    "Failed to post NOTIFY at 0x%p, time %lx",
                    pNotify,
                    pNotify->dwEventTime);
            DestroyNotify(pNotify);
        }

        ENDATOMICCHECK();

        if (pEventHookNext) {
            DBGVERIFYEVENTHOOK(pEventHookNext);
        }
        return pEventHookNext;
    }

    /*
     * Don't call back if the hook has been destroyed (unhooked).
     */
    if (pEventHook->fDestroyed) {
        /*
         * Save the next hook since DestroyNotify may cause pEventHook to
         * be freed by unlocking it.
         */
        pEventHook = pEventHook->pehNext;
        DestroyNotify(pNotify);
        return pEventHook;
    }

    /*
     * CALLBACK
     *
     * This leaves the critical section.
     * We return the next Event Hook in the list so that the caller doesn't
     * have to lock pEventHook.
     */
    UserAssert((pNotify->dwWEFlags & WEF_DEFERNOTIFY) == 0);

    ThreadLockAlways(pEventHook, &tlpEventHook);

    UserAssertMsg1(pNotify->ptiReceiver == NULL,
         "pNotify %#p is already in callback!  Reentrant?", pNotify);
    pNotify->ptiReceiver = ptiCurrent;

    if (!pEventHook->fSync) {
        UserAssert(pEventHook->ihmod == -1);
        pfn = (WINEVENTPROC)pEventHook->offPfn;
    } else {
        pfn = xxxGetEventProc(pEventHook);
    }
    if (pfn) {
        xxxClientCallWinEventProc(pfn, pEventHook, pNotify);
        DBGVERIFYNOTIFY(pNotify);
        DBGVERIFYEVENTHOOK(pEventHook);
        UserAssert(pEventHook->head.cLockObj);
    }

    pNotify->ptiReceiver = NULL;

    /*
     * Save the next item in the list, ThreadUnlock() may destroy pEventHook.
     * DestroyNotify() may also kill the event if it is a zombie (destroyed
     * but being used, waiting for use count to go to 0 before being freed).
     */
    pEventHook = pEventHook->pehNext;
    ThreadUnlock(&tlpEventHook);

    /*
     * We are done with the notification.  Kill it.
     *
     * NOTE that DestroyNotify does not yield, which is why we can hang on
     * to the pehNext field above around this call.
     *
     * NOTE ALSO that DestroyNotify will kill the event it references if the
     * ref count goes down to zero and it was zombied earlier.
     */
    DestroyNotify(pNotify);

    return pEventHook;
}


/****************************************************************************\
* xxxFlushDeferredWindowEvents
*
* Process notifications that were queued up during DeferWinEventNotify.
\****************************************************************************/
VOID xxxFlushDeferredWindowEvents(
    VOID)
{
    PNOTIFY pNotify;
    DWORD idCurrentThread = W32GetCurrentTID();

    /*
     * If idCurrentThread is 0 we're not in danger of faulting, but we'll
     * needlessly walk the list of pending notifications (since all will be
     * ignored).
     */
    UserAssert(idCurrentThread != 0);

    UserAssert(IsWinEventNotifyDeferredOK());

    pNotify = gpPendingNotifies;
    while (pNotify) {
        if (((pNotify->dwWEFlags & WEF_DEFERNOTIFY) == 0) ||
                (pNotify->idSenderThread != idCurrentThread)) {
            pNotify = pNotify->pNotifyNext;
        } else {
            /*
             * Clear WEF_DEFERNOTIFY so that if we recurse in the callback
             * we won't try to send this notification again.
             */
            pNotify->dwWEFlags &= ~WEF_DEFERNOTIFY;
#if DBG
            gnDeferredWinEvents--;
#endif
            /*
             * We shouldn't have deferred ASYNC notifications: we should have
             * posted them immediately.
             */
            UserAssert((pNotify->dwWEFlags & WEF_ASYNC) == 0);
            xxxProcessNotifyWinEvent(pNotify);
            /*
             * Start again at the head of the list, in case it munged during
             * the callback.
             */
            pNotify = gpPendingNotifies;
        }
    }
}


/*****************************************************************************\
*
* xxxWindowEvent
*
* Send, Post or Defer a Win Event notification, depending on what Win Event
* hooks are installed and what the context of the caller is.
*
* The caller should test FWINABLE() and only call xxxWindowEvent if it is TRUE,
* that way only costs a few clocks if no Win Event hooks are set.
*
* Caller shouldn't lock pwnd, because xxxWindowEvent() will do it.
*
\*****************************************************************************/
VOID
xxxWindowEvent(
    DWORD   event,
    PWND    pwnd,
    LONG    idObject,
    LONG    idChild,
    DWORD   dwFlags)
{
    PEVENTHOOK peh;
    PEVENTHOOK pehNext;
    PTHREADINFO ptiCurrent, ptiEvent;
    DWORD   dwTime;
    PPROCESSINFO ppiEvent;
    DWORD idEventThread;
    HANDLE hEventProcess;
    PNOTIFY pNotify;
    TL tlpwnd;
    TL tlpti;

    /*
     * Do not bother with CheckLock(pwnd) - we ThreadLock it below.
     */
    if (!FEVENTHOOKED(event)) {
        return;
    }

    /*
     * This thread is in startup, and has not yet had it's pti set up
     * This is pretty rare, but sometimes encountered in stress.
     * Test gptiCurrent to avoid the UserAssert(gptiCurrent) in PtiCurrent()
     */
    if (gptiCurrent == NULL) {
        RIPMSG3(RIP_WARNING, "Ignore WinEvent %lx %#p %lx... no PtiCurrent yet",
                event, pwnd, idObject);
        return;
    }
    ptiCurrent = PtiCurrent();

    /*
     * Don't bother with destroyed windows
     */
    if (pwnd && TestWF(pwnd, WFDESTROYED)) {
        RIPMSG3(RIP_WARNING,
                "Ignore WinEvent %lx %#p %lx... pwnd already destroyed",
                event, pwnd, idObject);
        return;
    }

    /*
     * Under some special circumstances we have to defer
     */
    if (ptiCurrent->TIF_flags & (TIF_DISABLEHOOKS | TIF_INCLEANUP)) {
        dwFlags |= WEF_DEFERNOTIFY;
    }

    /*
     * Determine process and thread issuing the event notification
     */
    if ((dwFlags & WEF_USEPWNDTHREAD) && pwnd) {
        ptiEvent = GETPTI(pwnd);
    } else {
        ptiEvent = ptiCurrent;
    }
    idEventThread = TIDq(ptiEvent);
    ppiEvent = ptiEvent->ppi;
    hEventProcess = PsGetThreadProcessId(ptiEvent->pEThread);

    dwTime = NtGetTickCount();

    ThreadLockWithPti(ptiCurrent, pwnd, &tlpwnd);
    ThreadLockPti(ptiCurrent, ptiEvent, &tlpti);

    /*
     * If we're not deferring the current notification process any pending
     * deferred notifications before proceeding with the current notification
     */
    if (!(dwFlags & WEF_DEFERNOTIFY)) {
        xxxFlushDeferredWindowEvents();
    }

    for (peh = gpWinEventHooks; peh; peh = pehNext) {
        DBGVERIFYEVENTHOOK(peh);
        pehNext = peh->pehNext;

        //
        // Is event in the right range?  And is it for this process/thread?
        // Note that we skip destroyed events.  They will be freed any
        // second now, it's just that yielding may have caused reentrancy.
        //
        // If the caller said to ignore events on his own thread, make sure
        // we skip them.
        //
        if (!peh->fDestroyed                &&
            (peh->eventMin <= event)        &&
            (event <= peh->eventMax)        &&
            (!peh->hEventProcess || (peh->hEventProcess == hEventProcess)) &&
            (!peh->fIgnoreOwnProcess || (ppiEvent != GETPTI(peh)->ppi)) &&
            (!peh->idEventThread || (peh->idEventThread == idEventThread))  &&
            (!peh->fIgnoreOwnThread || (ptiEvent != GETPTI(peh))) &&
            // temp fix from SP3 - best to architect events on a per-desktop
            // basis, with a separate pWinEventHook list per desktop. (IanJa)
            (peh->head.pti->rpdesk == ptiCurrent->rpdesk))
        {
            /*
             * Don't create new notifications for zombie event hooks.
             * When an event is destroyed, it stays as a zombie until the in-use
             * count goes to zero (all it's async and deferred notifies gone)
             */
            if (HMIsMarkDestroy(peh)) {
                break;
            }

            UserAssert(peh->fDestroyed == 0);

            if ((pNotify = CreateNotify(peh, event, pwnd, idObject,
                    idChild, ptiEvent, dwTime)) == NULL) {
                break;
            }
            pNotify->dwWEFlags |= dwFlags;

            /*
             * If it's async, don't defer it: post it straight away.
             */
            if (pNotify->dwWEFlags & WEF_ASYNC) {
                pNotify->dwWEFlags &= ~WEF_DEFERNOTIFY;
            }

            if (pNotify->dwWEFlags & WEF_DEFERNOTIFY) {
#if DBG
                gnDeferredWinEvents++;
#endif
                DBGVERIFYNOTIFY(pNotify);
            } else {
                pehNext = xxxProcessNotifyWinEvent(pNotify);
            }
        }
    }

    ThreadUnlockPti(ptiCurrent, &tlpti);
    ThreadUnlock(&tlpwnd);
}

/****************************************************************************\
*
* CreateNotify()
*
* Gets a pointer to a NOTIFY struct that we can then propagate to our
* event window via Send/PostMessage.  We have to do this since we want to
* (pass on a lot more data then can be packed in the parameters.
*
*  We have one cached struct so we avoid lots of allocs and frees in the
*  most common case of just one outstanding notification.
\****************************************************************************/
PNOTIFY
CreateNotify(PEVENTHOOK pEvent, DWORD event, PWND pwnd, LONG idObject,
    LONG idChild, PTHREADINFO ptiSender, DWORD dwTime)
{
    PNOTIFY pNotify;
    UserAssert(pEvent != NULL);

    //
    // Get a pointer.  From cache if available.
    // IanJa - change this to allocate from zone a la AllocQEntry??
    //
    if (!fNotifyCacheInUse) {
        fNotifyCacheInUse = TRUE;
        pNotify = &notifyCache;
#if DBG
        //
        // Make sure we aren't forgetting to set any fields.
        //
        // DebugFillBuffer(pNotify, sizeof(NOTIFY));
#endif
    } else {
        pNotify = (PNOTIFY)UserAllocPool(sizeof(NOTIFY), TAG_NOTIFY);
        if (!pNotify)
            return NULL;
    }


    /*
     * Fill in the notify block.
     */
    pNotify->spEventHook = NULL;
    Lock(&pNotify->spEventHook, pEvent);
    pNotify->hwnd = HW(pwnd);
    pNotify->event = event;
    pNotify->idObject = idObject;
    pNotify->idChild = idChild;
    pNotify->idSenderThread = TIDq(ptiSender);
    UserAssert(pNotify->idSenderThread != 0);
    pNotify->dwEventTime = dwTime;
    pNotify->dwWEFlags = pEvent->fSync ? 0 : WEF_ASYNC;
    pNotify->pNotifyNext = NULL;
    pNotify->ptiReceiver = NULL;
#if DBG
    gnNotifies++;
#endif

    /*
     * The order of non-deferred notifications doesn't matter; they are here
     * simply for cleanup/in-use tracking. However, deferred notifications must
     * be ordered with most recent at the end, so just order them all that way.
     */
    if (gpPendingNotifies) {
        UserAssert(gpLastPendingNotify);
        UserAssert(gpLastPendingNotify->pNotifyNext == NULL);
        gpLastPendingNotify->pNotifyNext = pNotify;
    } else {
        gpPendingNotifies = pNotify;
    }
    gpLastPendingNotify = pNotify;

    return pNotify;
}


/****************************************************************************\
* RemoveNotify
\****************************************************************************/
VOID RemoveNotify(
    PNOTIFY *ppNotify)
{
    PNOTIFY pNotifyRemove;

    pNotifyRemove = *ppNotify;

    /*
     * First, get it out of the pending list.
     */
    *ppNotify = pNotifyRemove->pNotifyNext;

#if DBG
    if (pNotifyRemove->dwWEFlags & WEF_DEFERNOTIFY) {
        UserAssert(gnDeferredWinEvents > 0);
        gnDeferredWinEvents--;
    }
#endif

    if (*ppNotify == NULL) {
        /*
         * Removing last notify, so fix up gpLastPendingNotify:
         * If list now empty, there is no last item.
         */
        if (gpPendingNotifies == NULL) {
            gpLastPendingNotify = NULL;
        } else {
            gpLastPendingNotify = CONTAINING_RECORD(ppNotify, NOTIFY, pNotifyNext);
        }
    }
    UserAssert(gpPendingNotifies == 0 || gpPendingNotifies > (PNOTIFY)100);

    DBGVERIFYEVENTHOOK(pNotifyRemove->spEventHook);

    /*
     * This may cause the win event hook to be freed.
     */
    Unlock(&pNotifyRemove->spEventHook);

    /*
     * Now free it. Either put it back in the cache (if it is the cache)
     * or really free it.
     */
    if (pNotifyRemove == &notifyCache) {
        UserAssert(fNotifyCacheInUse);
        fNotifyCacheInUse = FALSE;
    } else {
        UserFreePool(pNotifyRemove);
    }

#if DBG
    UserAssert(gnNotifies > 0);
    gnNotifies--;
#endif
}


/*****************************************************************************\
* DestroyNotify
*
* This gets the notification out of our pending list and frees the local
* memory it uses.
*
* This function is called
* (1) NORMALLY:   After returning from calling the notify proc
* (2) CLEANUP:    When a thread goes away, we cleanup async notifies it
*     hasn't received, and sync notifies it was in the middle of trying
*     to call (i.e. the event proc faulted).
\*****************************************************************************/
VOID DestroyNotify(
    PNOTIFY pNotifyDestroy)
{
    PNOTIFY  *ppNotify;
    PNOTIFY  pNotifyT;

    DBGVERIFYNOTIFY(pNotifyDestroy);

    /*
     * Either this notify isn't currently in the process of calling back
     * (which means ptiReceiver is NULL) or the thread destroying it
     * must be the one that was calling back (which means this thread
     * was destroyed during the callback and is cleaning up).
     */
    UserAssert(pNotifyDestroy->ptiReceiver == NULL ||
               pNotifyDestroy->ptiReceiver == PtiCurrent());

    ppNotify = &gpPendingNotifies;
    while (pNotifyT = *ppNotify) {
        if (pNotifyT == pNotifyDestroy) {
            RemoveNotify(ppNotify);
            return;
        } else {
            ppNotify = &pNotifyT->pNotifyNext;
        }
    }

    RIPMSG1(RIP_ERROR, "DestroyNotify 0x%p - not found", pNotifyDestroy);
}



/***************************************************************************\
* FreeThreadsWinEvents
*
* During 'exit-list' processing this function is called to free any WinEvent
* notifications and WinEvent hooks created by the current thread.
*
* Notifications that remain may be:
*  o  Posted notifications (async)
*  o  Notifications in xxxClientCallWinEventProc (sync)
*  o  Deferred notifications (should be sync only)
* Destroy the sync notifications, because we cannot do callbacks
* while in thread cleanup.
* Leave the posted (async) notifications alone: they're on their way already.
*
* History:
* 11-11-96 IanJa         Created.
\***************************************************************************/
VOID FreeThreadsWinEvents(
    PTHREADINFO pti)
{
    PEVENTHOOK peh, pehNext;
    PNOTIFY pn, pnNext;
    DWORD idCurrentThread = W32GetCurrentTID();

    /*
     * Loop through all the notifications.
     */
    for (pn = gpPendingNotifies; pn; pn = pnNext) {
        pnNext = pn->pNotifyNext;

        /*
         * Only destroy sync notifications that belong to this thread
         * and are not currently calling back i.e. ptiReceiver must be NULL.
         * Otherwise, when we come back from the callback in
         * xxxProcessNotifyWinEvent we will operate on a freed notify.
         * Also destroy the notification if the receiver is going away
         * or else it gets leaked as long as the sender is alive.
         */
        if ((pn->idSenderThread == idCurrentThread &&
                pn->ptiReceiver == NULL) ||
            pn->ptiReceiver == pti) {
            if ((pn->dwWEFlags & WEF_ASYNC) == 0) {
                UserAssert((pn->dwWEFlags & WEF_POSTED) == 0);
                DestroyNotify(pn);
            }
        }
    }

    peh = gpWinEventHooks;
    while (peh) {
        pehNext = peh->pehNext;
        if (GETPTI(peh) == pti) {
            DestroyEventHook(peh);
        }
        peh = pehNext;
    }
}


/***************************************************************************\
* _SetWinEventHook()
*
* This installs a win event hook.
*
* If hEventProcess set but idEventThread = 0, hook all threads in process.
* If idEventThread set but hEventProcess = NULL, hook single thread only.
* If neither are set, hook everything.
* If both are set ??
*
\***************************************************************************/
PEVENTHOOK _SetWinEventHook(
    DWORD eventMin,
    DWORD eventMax,
    HMODULE hmodWinEventProc,
    PUNICODE_STRING pstrLib,
    WINEVENTPROC pfnWinEventProc,
    HANDLE hEventProcess,
    DWORD idEventThread,
    DWORD dwFlags)
{
    PEVENTHOOK pEventNew;
    PTHREADINFO ptiCurrent;

    int ihmod;

    ptiCurrent = PtiCurrent();

    //
    // If exiting, fail the call.
    //
    if (ptiCurrent->TIF_flags & TIF_INCLEANUP) {
        RIPMSG1(RIP_ERROR,
                "SetWinEventHook: Fail call - thread 0x%p in cleanup",
                ptiCurrent);
        return NULL;
    }

    /*
     * Check to see if filter proc is valid.
     */
    if (pfnWinEventProc == NULL) {
        RIPERR0(ERROR_INVALID_FILTER_PROC,
                RIP_WARNING,
                "pfnWinEventProc == NULL");
        return NULL;
    }

    if (eventMin > eventMax) {
        RIPERR0(ERROR_INVALID_HOOK_FILTER,
                RIP_WARNING,
                "eventMin > eventMax");
        return NULL;
    }

    if (dwFlags & WINEVENT_INCONTEXT) {
        /*
         * WinEventProc to be called in context of hooked thread, so needs a DLL.
         */
        if (hmodWinEventProc == NULL) {
            RIPERR0(ERROR_HOOK_NEEDS_HMOD,
                    RIP_WARNING,
                    "In context hook w/o DLL!");
            return NULL;
        } else if (pstrLib == NULL) {
            /*
             * If we got an hmod, we should get a DLL name too!
             */
            RIPERR1(ERROR_DLL_NOT_FOUND,
                    RIP_WARNING,
                    "hmod 0x%p, but no lib name",
                    hmodWinEventProc);
            return NULL;
        }
        ihmod = GetHmodTableIndex(pstrLib);
        if (ihmod == -1) {
            RIPERR0(ERROR_MOD_NOT_FOUND,
                    RIP_WARNING,
                    "");
            return NULL;
        }
    } else {
        ihmod = -1;            // means no DLL is required
        hmodWinEventProc = 0;
    }

    /*
     * Check the thread id, check it is a GUI thread.
     */
    if (idEventThread != 0) {
        PTHREADINFO ptiT;

        ptiT = PtiFromThreadId(idEventThread);
        if (ptiT == NULL || !(ptiT->TIF_flags & TIF_GUITHREADINITIALIZED)) {
            RIPERR1(ERROR_INVALID_THREAD_ID, RIP_VERBOSE, "pti %#p", ptiT);
            return NULL;
        }
    }

    /*
     * Create the window for async events first.
     *
     * NOTE that USER itself will not pass on window creation/destruction
     * notifications for
     *      * IME windows
     *      * OLE windows
     *      * RPC windows
     *      * Event windows
     */

    /*
     * Get a new event.
     */
    pEventNew = (PEVENTHOOK)HMAllocObject(ptiCurrent,
                                          NULL,
                                          TYPE_WINEVENTHOOK,
                                          sizeof(EVENTHOOK));
    if (!pEventNew) {
        return NULL;
    }

    /*
     * Fill in the new event.
     */
    pEventNew->eventMin = (UINT)eventMin;
    pEventNew->eventMax = (UINT)eventMax;

    pEventNew->fIgnoreOwnThread = ((dwFlags & WINEVENT_SKIPOWNTHREAD) != 0);
    pEventNew->fIgnoreOwnProcess = ((dwFlags & WINEVENT_SKIPOWNPROCESS) != 0);
    pEventNew->fDestroyed = FALSE;
    pEventNew->fSync = ((dwFlags & WINEVENT_INCONTEXT) != 0);

    pEventNew->hEventProcess = hEventProcess;
    pEventNew->idEventThread = idEventThread;

    pEventNew->ihmod = ihmod;

    /*
     * Add a dependency on this module - meaning, increment a count
     * that simply counts the number of hooks set into this module.
     */
    if (pEventNew->ihmod >= 0) {
        AddHmodDependency(pEventNew->ihmod);
    }

    /*
     * If pfnWinEventProc is in caller's process and no DLL is involved,
     * then pEventNew->offPfn is the actual address.
     */
    pEventNew->offPfn = ((ULONG_PTR)pfnWinEventProc) - ((ULONG_PTR)hmodWinEventProc);

    /*
     * Link our event into the master list.
     *
     * Note that we count on USER to not generate any events when installing
     * our hook. The caller can't handle it yet since he hasn't got back
     * his event handle from this call.
     */
    pEventNew->pehNext = gpWinEventHooks;
    gpWinEventHooks = pEventNew;

    /*
     * Update the flags that indicate what event hooks are installed. These
     * flags are accessable from user mode without a kernel transition since
     * they are in shared memory.
     */
    SET_FLAG(gpsi->dwInstalledEventHooks, CategoryMaskFromEventRange(eventMin, eventMax));

    return pEventNew;
}

/****************************************************************************\
* UnhookWinEvent
*
* Unhooks a win event hook. We of course sanity check that this thread is
* the one which installed the hook. We have to: We are going to destroy
* the IPC window and that must be in context.
\****************************************************************************/
BOOL _UnhookWinEvent(
    PEVENTHOOK pEventUnhook)
{
    DBGVERIFYEVENTHOOK(pEventUnhook);

    if (HMIsMarkDestroy(pEventUnhook) || (GETPTI(pEventUnhook) != PtiCurrent())) {
        /*
         * We do this to avoid someone calling UnhookWinEvent() the first
         * time, then somehow getting control again and calling it a second
         * time before we've managed to free up the event since someone was
         * in the middle of using it at the first UWE call.
         */
        RIPERR1(ERROR_INVALID_HANDLE,
                RIP_WARNING,
                "_UnhookWinEvent: Invalid event hook 0x%p",
                PtoHq(pEventUnhook));
        return FALSE;
    }

    /*
     * Purge this baby if all notifications are done.
     *
     * If there are SYNC ones pending, the caller will clean this up upon
     * the return from calling the event.
     *
     * If there are ASYNC ones pending, the receiver will not call the event
     * and clean it up when he gets it.
     */
    DestroyEventHook(pEventUnhook);

    return TRUE;
}


/*****************************************************************************\
* DestroyEventHook
*
* Destroys an event when the ref count has gone down to zero. It may
* happen:
*     * In the event generator's context, after returning from a callback
*       and the ref count dropped to zero, if sync.
*     * In the event installer's context, after returning from a callback
*       and the ref count dropped to zero if async.
*     * In the event installer's context, if on _UnhookWinEvent() the event
*       was not in use at all.
\*****************************************************************************/
VOID DestroyEventHook(
    PEVENTHOOK pEventDestroy)
{
    PEVENTHOOK *ppEvent;
    PEVENTHOOK pEventT;
    DWORD dwCategoryMask = 0;

    DBGVERIFYEVENTHOOK(pEventDestroy);
    UserAssert(gpWinEventHooks);

    /*
     * Mark this event as destroyed, but don't remove it from the event list
     * until its lock count goes to 0 - we may be traversing the list within
     * xxxWindowEvent, so we mustn't break the link to the next hook.
     */
    pEventDestroy->fDestroyed = TRUE;

    /*
     * If the object is locked, mark it for destroy but don't free it yet.
     */
    if (!HMMarkObjectDestroy(pEventDestroy)) {
        return;
    }

    /*
     * Remove this from our event list.
     */
    for (ppEvent = &gpWinEventHooks; pEventT = *ppEvent; ppEvent = &pEventT->pehNext) {
        if (pEventT == pEventDestroy) {
            *ppEvent = pEventDestroy->pehNext;
            break;
        }
    }
    UserAssert(pEventT);

    /*
     * Update the flags that indicate what event hooks are installed. These
     * flags are accessable from user mode without a kernel transition since
     * they are in shared memory. Note that a user could check the shared
     * memory at any time, so they may get a false-positive during this
     * processing. A false-positive would mean that we claim there is a
     * listener, when there really isn't. We never want the user to get
     * a false negative - meaning that we claim there aren't any listeners
     * but there really is. That could mean bad things for accessability.
     */
    for (pEventT = gpWinEventHooks; pEventT != NULL; pEventT = pEventT->pehNext) {
        SET_FLAG(dwCategoryMask, CategoryMaskFromEventRange(pEventT->eventMin, pEventT->eventMax));
    }
    gpsi->dwInstalledEventHooks = dwCategoryMask;

    /*
     * Make sure each hooked thread will unload the hook proc DLL.
     */
    if (pEventDestroy->ihmod >= 0) {
        RemoveHmodDependency(pEventDestroy->ihmod);
    }

    /*
     * Free this pointer.
     */
    HMFreeObject(pEventDestroy);
}

/***************************************************************************\
* xxxGetEventProc
*
* For sync events, this gets the address to call. If 16-bits, then just
* return the installed address. If 32-bits, we need to load the library
* if not in the same process as the installer.
\***************************************************************************/
WINEVENTPROC xxxGetEventProc(
    PEVENTHOOK pEventOrg)
{
    PTHREADINFO ptiCurrent;

    UserAssert(pEventOrg);
    UserAssert(pEventOrg->fSync);
    UserAssert(pEventOrg->ihmod >= 0);
    UserAssert(pEventOrg->offPfn != 0);

    CheckLock(pEventOrg);

    /*
     * Make sure the hook is still around before we try and call it.
     */
    if (HMIsMarkDestroy(pEventOrg)) {
        return NULL;
    }

    ptiCurrent = PtiCurrent();

    /*
     * Make sure the DLL for this hook, if any, has been loaded for the
     * current process.
     */
    if (pEventOrg->ihmod != -1 &&
        TESTHMODLOADED(ptiCurrent, pEventOrg->ihmod) == 0) {
        /*
         * Try loading the library, since it isn't loaded in this processes
         * context. The hook is alrerady locked, so it won't go away while
         * we're loading this library.
         */
        if (xxxLoadHmodIndex(pEventOrg->ihmod) == NULL) {
            return NULL;
        }
    }

    /*
     * While we're still inside the critical section make sure the hook
     * hasn't been 'freed'. If so just return NULL. Since WinEvent has
     * already been called, you might think that we should pass the event
     * on, but the hooker may not be expecting this after having
     * cancelled the hook! In any case, we have two ways of detecting that
     * this hook has been removed (see the following code).
     */

    /*
     * Make sure the hook is still around before we try and call it.
     */
    if (HMIsMarkDestroy(pEventOrg)) {
        return NULL;
    }

    return (WINEVENTPROC)PFNHOOK(pEventOrg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\winable2.c ===
/**************************** Module Header ********************************\
* Module Name: winable2.c
*
* This has the following Active Accesibility API
*     GetGUIThreadInfo
*     GetTitleBarInfo
*     GetScrollBarInfo
*     GetMenuBarInfo
*     GetComboxBoxInfo
*     GetListBoxInfo
*
* The Winevent hooks are handled in winable.c.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 08-30-96 IanJa  Ported from Windows '95
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*****************************************************************************\
* _GetGUIThreadInfo
*
* This gets GUI information out of context. If you pass in a NULL thread ID,
* we will get the 'global' information, using the foreground thread. This
* is guaranteed to be the real active window, focus window, etc. Yes, you
* could do it yourself by calling GetForegroundWindow, getting the thread ID
* of that window via GetWindowThreadProcessId, then passing the ID into
* GetGUIThreadInfo(). However, that takes three calls and aside from being
* a pain, anything could happen in the middle. So passing in NULL gets
* you stuff in one call and hence also works right.
*
* This function returns FALSE if the thread doesn't have a queue or the
* thread ID is bogus.
\*****************************************************************************/
BOOL _GetGUIThreadInfo(
    PTHREADINFO pti,
    PGUITHREADINFO pgui)
{
    PQ pq;

    /*
     * Validate threadinfo structure
     */
    if (pgui->cbSize != sizeof(GUITHREADINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "GUITHREADINFO.cbSize %d is wrong", pgui->cbSize);
        return FALSE;
    }

    /*
     * Is this a valid initialized GUI thread?
     */
    if (pti != NULL) {
        pq = pti->pq;
    } else {
        /*
         * Use the foreground queue. To get menu state information we must also
         * figure out the right pti. This matches _GetForegroundWindow() logic.
         */
        if ((pq = gpqForeground) == NULL) {
            return FALSE;
        }

        if (pq->spwndActive && (GETPTI(pq->spwndActive)->pq == pq)) {
            pti = GETPTI(pq->spwndActive);
            if (PtiCurrentShared()->rpdesk != pti->rpdesk) {
                RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "Foreground window on different desktop");
                return FALSE;
            }
        }
    }

    UserAssert(pq != NULL);

    /*
     * For C2 security, verify that pq and pti are on the current thread's desktop.
     * We can't directly determine which desktop pq belongs to, but we can at
     * least ensure that any caret info we return is not from another desktop
     */
    if (pq->caret.spwnd &&
            (GETPTI(pq->caret.spwnd)->rpdesk != PtiCurrentShared()->rpdesk)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "Foreground caret on different desktop");
        return FALSE;
    }
    if (pti && (pti->rpdesk != PtiCurrentShared()->rpdesk)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "Foreground thread on different desktop");
        return FALSE;
    }

    pgui->flags        = 0;
    pgui->hwndMoveSize = NULL;
    pgui->hwndMenuOwner = NULL;

    /*
     * Get menu information from the THREADINFO.
     */
    if (pti != NULL) {
        if (pti->pmsd && !pti->pmsd->fTrackCancelled && pti->pmsd->spwnd) {
            pgui->flags |= GUI_INMOVESIZE;
            pgui->hwndMoveSize = HWq(pti->pmsd->spwnd);
        }

        if (pti->pMenuState && pti->pMenuState->pGlobalPopupMenu) {
            pgui->flags |= GUI_INMENUMODE;

            if (pti->pMenuState->pGlobalPopupMenu->fHasMenuBar) {
                if (pti->pMenuState->pGlobalPopupMenu->fIsSysMenu) {
                    pgui->flags |= GUI_SYSTEMMENUMODE;
                }
            } else {
                pgui->flags |= GUI_POPUPMENUMODE;
            }

            if (pti->pMenuState->pGlobalPopupMenu->spwndNotify) {
                pgui->hwndMenuOwner = HWq(pti->pMenuState->pGlobalPopupMenu->spwndNotify);
            }
        }

        if (pti->TIF_flags & TIF_16BIT) {
            pgui->flags |= GUI_16BITTASK;
        }
    }

    /*
     * Get the rest of the information from the queue.
     */
    pgui->hwndActive   = HW(pq->spwndActive);
    pgui->hwndFocus    = HW(pq->spwndFocus);
    pgui->hwndCapture  = HW(pq->spwndCapture);
    pgui->hwndCaret    = NULL;

    if (pq->caret.spwnd) {
        pgui->hwndCaret = HWq(pq->caret.spwnd);

        if ((GETPTI(pq->caret.spwnd) != PtiCurrentShared()) &&
            (pq->caret.spwnd->pcls->style & CS_OWNDC)) {
            /*
             * This is the case where we are being called by a different
             * thread than created the window, and the window has a
             * private DC. We have to do extra work to be able to
             * return the desired information.
             * These coords are always relative to the client of hwndCaret.
             */
            pgui->rcCaret.left   = pq->caret.xOwnDc;
            pgui->rcCaret.right  = pgui->rcCaret.left + pq->caret.cxOwnDc;
            pgui->rcCaret.top    = pq->caret.yOwnDc;
            pgui->rcCaret.bottom = pgui->rcCaret.top + pq->caret.cyOwnDc;
        } else {
            /*
             * These coords are still in logical coordinates. Ie, these
             * are the coordinates we draw at in UT_InvertCaret.
             */
            pgui->rcCaret.left   = pq->caret.x;
            pgui->rcCaret.right  = pgui->rcCaret.left + pq->caret.cx;
            pgui->rcCaret.top    = pq->caret.y;
            pgui->rcCaret.bottom = pgui->rcCaret.top + pq->caret.cy;
        }

        if (pq->caret.iHideLevel == 0) {
            pgui->flags |= GUI_CARETBLINKING;
        }
    } else if (pti && (pti->ppi->W32PF_Flags & W32PF_CONSOLEHASFOCUS)) {
        /*
         * The thread is running in the console window with focus. Pull
         * out the info from the console pseudo caret.
         */
        pgui->hwndCaret = pti->rpdesk->cciConsole.hwnd;
        pgui->rcCaret = pti->rpdesk->cciConsole.rc;
    } else {
        SetRectEmpty(&pgui->rcCaret);
    }

    return TRUE;
}


/****************************************************************************\
* xxxGetTitleBarInfo
*
* Gets info about a window's title bar. If the window is bogus or
* doesn't have a titlebar, this will fail.
\****************************************************************************/
BOOL xxxGetTitleBarInfo(
    PWND pwnd,
    PTITLEBARINFO ptbi)
{
    int cxB;

    CheckLock(pwnd);

    /*
     * Validate TITLEBARINFO structure.
     */
    if (ptbi->cbSize != sizeof(TITLEBARINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "TITLEBARINFO.cbSize %d is wrong", ptbi->cbSize);
        return FALSE;
    }

    RtlZeroMemory(&ptbi->rgstate, sizeof(ptbi->rgstate));

    ptbi->rgstate[INDEX_TITLEBAR_SELF] |= STATE_SYSTEM_FOCUSABLE;
    if (TestWF(pwnd, WFBORDERMASK) != LOBYTE(WFCAPTION)) {
        // No titlebar.
        ptbi->rgstate[INDEX_TITLEBAR_SELF] |= STATE_SYSTEM_INVISIBLE;
        return TRUE;
    }

    if (!TestWF(pwnd, WFMINIMIZED) && !TestWF(pwnd, WFCPRESENT)) {
        // Off screen (didn't fit)
        ptbi->rgstate[INDEX_TITLEBAR_SELF] |= STATE_SYSTEM_OFFSCREEN;
        SetRectEmpty(&ptbi->rcTitleBar);
        return TRUE;
    }

    /*
     * Get titlebar rect.
     */
    ptbi->rcTitleBar = pwnd->rcWindow;
    cxB = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
    InflateRect(&ptbi->rcTitleBar, -cxB * SYSMET(CXBORDER), -cxB * SYSMET(CYBORDER));
    if (TestWF(pwnd, WEFTOOLWINDOW)) {
        ptbi->rcTitleBar.bottom = ptbi->rcTitleBar.top + SYSMET(CYSMCAPTION);
    } else {
        ptbi->rcTitleBar.bottom = ptbi->rcTitleBar.top + SYSMET(CYCAPTION);
    }

    /*
     * Don't include the system menu area!
     */
    if (TestWF(pwnd, WFSYSMENU) && _HasCaptionIcon(pwnd)) {
        ptbi->rcTitleBar.left += (ptbi->rcTitleBar.bottom - ptbi->rcTitleBar.top - SYSMET(CYBORDER));
    }

    /*
     * Close button.
     */
    if (!TestWF(pwnd, WFSYSMENU) && TestWF(pwnd, WFWIN40COMPAT)) {
        ptbi->rgstate[INDEX_TITLEBAR_CLOSEBUTTON] |= STATE_SYSTEM_INVISIBLE;
    } else {
        if (!xxxMNCanClose(pwnd)) {
            ptbi->rgstate[INDEX_TITLEBAR_CLOSEBUTTON] |= STATE_SYSTEM_UNAVAILABLE;
        }

        if (TestWF(pwnd, WFCLOSEBUTTONDOWN)) {
            ptbi->rgstate[INDEX_TITLEBAR_CLOSEBUTTON] |= STATE_SYSTEM_PRESSED;
        }
    }


    /*
     * Max button.
     */
    if (!TestWF(pwnd, WFSYSMENU) && TestWF(pwnd, WFWIN40COMPAT)) {
        ptbi->rgstate[INDEX_TITLEBAR_MAXBUTTON] |= STATE_SYSTEM_INVISIBLE;
    } else {
        if (!TestWF(pwnd, WFMAXBOX)) {
            if (!TestWF(pwnd, WFMINBOX)) {
                ptbi->rgstate[INDEX_TITLEBAR_MAXBUTTON] |= STATE_SYSTEM_INVISIBLE;
            } else {
                ptbi->rgstate[INDEX_TITLEBAR_MAXBUTTON] |= STATE_SYSTEM_UNAVAILABLE;
            }
        }

        if (TestWF(pwnd, WFZOOMBUTTONDOWN)) {
            ptbi->rgstate[INDEX_TITLEBAR_MAXBUTTON] |= STATE_SYSTEM_PRESSED;
        }
    }


    /*
     * Min button.
     */
    if (!TestWF(pwnd, WFSYSMENU) && TestWF(pwnd, WFWIN40COMPAT)) {
        ptbi->rgstate[INDEX_TITLEBAR_MINBUTTON] |= STATE_SYSTEM_INVISIBLE;
    } else {
        if (!TestWF(pwnd, WFMINBOX)) {
            if (!TestWF(pwnd, WFMAXBOX)) {
                ptbi->rgstate[INDEX_TITLEBAR_MINBUTTON] |= STATE_SYSTEM_INVISIBLE;
            } else {
                ptbi->rgstate[INDEX_TITLEBAR_MINBUTTON] |= STATE_SYSTEM_UNAVAILABLE;
            }
        }

        if (TestWF(pwnd, WFREDUCEBUTTONDOWN)) {
            ptbi->rgstate[INDEX_TITLEBAR_MINBUTTON] |= STATE_SYSTEM_PRESSED;
        }
    }


    /*
     * Help button.
     */
    if (!TestWF(pwnd, WEFCONTEXTHELP) || TestWF(pwnd, WFMINBOX) ||
            TestWF(pwnd, WFMAXBOX)) {
        ptbi->rgstate[INDEX_TITLEBAR_HELPBUTTON] |= STATE_SYSTEM_INVISIBLE;
    } else {
        if (TestWF(pwnd, WFHELPBUTTONDOWN)) {
            ptbi->rgstate[INDEX_TITLEBAR_HELPBUTTON] |= STATE_SYSTEM_PRESSED;
        }
    }

    // IME button BOGUS!
    ptbi->rgstate[INDEX_TITLEBAR_IMEBUTTON] = STATE_SYSTEM_INVISIBLE;

    return TRUE;
}

/*****************************************************************************\
* xxxGetScrollBarInfo
*
* Gets state & location information about a scrollbar.
*
* Note we fill in the minimal amount of useful info. OLEACC is responsible
* for extrapolation. I.E., if both the line up and line down buttons are
* disabled, the whole scrollbar is, and the thumb is invisible.
\*****************************************************************************/
BOOL xxxGetScrollBarInfo(
    PWND pwnd,
    LONG idObject,
    PSCROLLBARINFO psbi)
{
    UINT   wDisable;
    BOOL   fVertical;
    SBCALC SBCalc;
    PCLS    pcls;

    CheckLock(pwnd);

    /*
     * Validate SCROLLBARINFO structure.
     */
    if (psbi->cbSize != sizeof(SCROLLBARINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING,
                "SCROLLBARINFO.cbSize 0x%x is wrong", psbi->cbSize);
        return FALSE;
    }

    pcls = pwnd->pcls;

    if ((idObject == OBJID_CLIENT) &&
        (GETFNID(pwnd) != FNID_SCROLLBAR) &&
        (pcls->atomClassName != gpsi->atomSysClass[ICLS_SCROLLBAR])) {

        return (BOOL)xxxSendMessage(pwnd, SBM_GETSCROLLBARINFO, 0, (LPARAM)psbi);
    }

    RtlZeroMemory(&psbi->rgstate, sizeof(psbi->rgstate));

    /*
     * Calculate where everything is.
     */
    if (idObject == OBJID_CLIENT) {
        RECT rc;
        wDisable = ((PSBWND)pwnd)->wDisableFlags;
        fVertical = ((PSBWND)pwnd)->fVert;
        GetRect(pwnd, &rc, GRECT_CLIENT | GRECT_CLIENTCOORDS);
        CalcSBStuff2(&SBCalc, &rc, (PSBDATA)&((PSBWND)pwnd)->SBCalc, ((PSBWND)pwnd)->fVert);
    } else {
        /*
         * Is this window scrollbar here?
         */
        if (idObject == OBJID_VSCROLL) {
            fVertical = TRUE;
            if (!TestWF(pwnd, WFVSCROLL)) {
                // No scrollbar.
                psbi->rgstate[INDEX_SCROLLBAR_SELF] |= STATE_SYSTEM_INVISIBLE;
            } else if (!TestWF(pwnd, WFVPRESENT)) {
                // Window too short to display it.
                psbi->rgstate[INDEX_SCROLLBAR_SELF] |= STATE_SYSTEM_OFFSCREEN;
            }
        } else if (idObject == OBJID_HSCROLL) {
            fVertical = FALSE;
            if (! TestWF(pwnd, WFHSCROLL)) {
                // No scrollbar.
                psbi->rgstate[INDEX_SCROLLBAR_SELF] |= STATE_SYSTEM_INVISIBLE;
            } else if (! TestWF(pwnd, WFHPRESENT)) {
                psbi->rgstate[INDEX_SCROLLBAR_SELF] |= STATE_SYSTEM_OFFSCREEN;
            }
        } else {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid idObject %d", idObject);
            return FALSE;
        }

        if (psbi->rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_INVISIBLE) {
            return TRUE;
        }

        wDisable = GetWndSBDisableFlags(pwnd, fVertical);

        if (!(psbi->rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_OFFSCREEN)) {
            CalcSBStuff(pwnd, &SBCalc, fVertical);
        }
    }

    /*
     * Setup button states.
     */
    if (wDisable & LTUPFLAG) {
        psbi->rgstate[INDEX_SCROLLBAR_UP] |= STATE_SYSTEM_UNAVAILABLE;
        psbi->rgstate[INDEX_SCROLLBAR_UPPAGE] |= STATE_SYSTEM_UNAVAILABLE;
    }

    if (wDisable & RTDNFLAG) {
        psbi->rgstate[INDEX_SCROLLBAR_DOWN] |= STATE_SYSTEM_UNAVAILABLE;
        psbi->rgstate[INDEX_SCROLLBAR_DOWNPAGE] |= STATE_SYSTEM_UNAVAILABLE;
    }

    if ((wDisable & (LTUPFLAG | RTDNFLAG)) == (LTUPFLAG | RTDNFLAG)) {
        psbi->rgstate[INDEX_SCROLLBAR_SELF] |= STATE_SYSTEM_UNAVAILABLE;
    }

    /*
     * Button pressed?
     */
    if (TestWF(pwnd, WFSCROLLBUTTONDOWN) &&
            ((idObject != OBJID_VSCROLL) || TestWF(pwnd, WFVERTSCROLLTRACK))) {
        if (TestWF(pwnd, WFLINEUPBUTTONDOWN)) {
            psbi->rgstate[INDEX_SCROLLBAR_UP] |= STATE_SYSTEM_PRESSED;
        }

        if (TestWF(pwnd, WFPAGEUPBUTTONDOWN)) {
            psbi->rgstate[INDEX_SCROLLBAR_UPPAGE] |= STATE_SYSTEM_PRESSED;
        }

        if (TestWF(pwnd, WFPAGEDNBUTTONDOWN)) {
            psbi->rgstate[INDEX_SCROLLBAR_DOWNPAGE] |= STATE_SYSTEM_PRESSED;
        }

        if (TestWF(pwnd, WFLINEDNBUTTONDOWN)) {
            psbi->rgstate[INDEX_SCROLLBAR_DOWN] |= STATE_SYSTEM_PRESSED;
        }
    }

    /*
     * Fill in area locations.
     */
    if (!(psbi->rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_OFFSCREEN)) {
        if (fVertical) {
            psbi->rcScrollBar.left = SBCalc.pxLeft;
            psbi->rcScrollBar.top = SBCalc.pxTop;
            psbi->rcScrollBar.right = SBCalc.pxRight;
            psbi->rcScrollBar.bottom = SBCalc.pxBottom;
        } else {
            psbi->rcScrollBar.left = SBCalc.pxTop;
            psbi->rcScrollBar.top = SBCalc.pxLeft;
            psbi->rcScrollBar.right = SBCalc.pxBottom;
            psbi->rcScrollBar.bottom = SBCalc.pxRight;
        }

        if (idObject == OBJID_CLIENT) {
            OffsetRect(&psbi->rcScrollBar, pwnd->rcClient.left, pwnd->rcClient.top);
        } else {
            OffsetRect(&psbi->rcScrollBar, pwnd->rcWindow.left, pwnd->rcWindow.top);
        }

        psbi->dxyLineButton = (SBCalc.pxUpArrow - SBCalc.pxTop);
        psbi->xyThumbTop = (SBCalc.pxThumbTop - SBCalc.pxTop);
        psbi->xyThumbBottom = (SBCalc.pxThumbBottom - SBCalc.pxTop);

        /*
         * Is the thumb all the way to the left/top? If so, page up is
         * not visible.
         */
        if (SBCalc.pxThumbTop == SBCalc.pxUpArrow) {
            psbi->rgstate[INDEX_SCROLLBAR_UPPAGE] |= STATE_SYSTEM_INVISIBLE;
        }

        /*
         * Is the thumb all the way to the right/down? If so, page down
         * is not visible.
         */
        if (SBCalc.pxThumbBottom == SBCalc.pxDownArrow) {
            psbi->rgstate[INDEX_SCROLLBAR_DOWNPAGE] |= STATE_SYSTEM_INVISIBLE;
        }
    }

    return TRUE;
}


/*****************************************************************************\
* _GetAncestor
*
* This gets one of:
*     * The _real_ parent. This does NOT include the owner, unlike GetParent().
*       Stops at a top level window unless we start with the desktop. In which
*       case, we return the desktop.
*     * The _real_ root, caused by walking up the chain getting the ancestor.
*     * The _real_ owned root, caused by GetParent()ing up.
\*****************************************************************************/
PWND _GetAncestor(
    PWND pwnd,
    UINT gaFlags)
{
    PWND pwndParent;

    /*
     * If we start with the desktop, the message window or the mother window,
     * return NULL.
     */
    if (pwnd == PWNDDESKTOP(pwnd) ||
        pwnd == PWNDMESSAGE(pwnd) ||
        pwnd->spwndParent == NULL) {
        return NULL;
    }

    switch (gaFlags) {
    case GA_PARENT:
        pwnd = pwnd->spwndParent;
        break;

    case GA_ROOT:
        while ((pwnd->spwndParent != PWNDDESKTOP(pwnd)) &&
               (pwnd->spwndParent != PWNDMESSAGE(pwnd))) {
            pwnd = pwnd->spwndParent;
        }
        break;

    case GA_ROOTOWNER:
        while (pwndParent = _GetParent(pwnd)) {
            pwnd = pwndParent;
        }
        break;
    }

    return pwnd;
}


/*****************************************************************************\
* _RealChildWindowFromPoint
*
* This returns the REAL child window at a point. The problem is that
* ChildWindowFromPoint() doesn't deal with HTTRANSPARENT areas of
* standard controls. We want to return a child behind a groupbox if it
* is in the "clear" area. But we want to return a static field always
* even though it too returns HTTRANSPARENT.
\*****************************************************************************/
PWND _RealChildWindowFromPoint(
    PWND pwndParent,
    POINT pt)
{
    PWND pwndChild;
    PWND pwndSave;

    if (pwndParent != PWNDDESKTOP(pwndParent)) {
        pt.x += pwndParent->rcClient.left;
        pt.y += pwndParent->rcClient.top;
    }

    /*
     * Is this point even in the parent?
     */
    if (!PtInRect(&pwndParent->rcClient, pt)  ||
        (pwndParent->hrgnClip && !GrePtInRegion(pwndParent->hrgnClip, pt.x, pt.y))) {
        // Nope
        return NULL;
    }

    pwndSave = NULL;

    /*
     * Loop through the children.
     */
    for (pwndChild = pwndParent->spwndChild; pwndChild; pwndChild = pwndChild->spwndNext) {
        if (!TestWF(pwndChild, WFVISIBLE))
            continue;

        /*
         * Is this point in the child's window?
         */
        if (!PtInRect(&pwndChild->rcWindow, pt) ||
                (pwndChild->hrgnClip && !GrePtInRegion(pwndChild->hrgnClip, pt.x, pt.y)))
            continue;

        /*
         * OK, we are in somebody's window. Is this by chance a group box?
         */
        if (IS_BUTTON(pwndChild)) {
            if (TestWF(pwndChild, BFTYPEMASK) == LOBYTE(BS_GROUPBOX)) {
               pwndSave = pwndChild;
               continue;
            }
        }

        return pwndChild;
    }

    /*
     * Did we save a groupbox which turned out to have nothing behind it
     * at that point?
     */
    if (pwndSave) {
        return pwndSave;
    } else {
        return pwndParent;
    }
}


/*****************************************************************************\
* xxxGetMenuBarInfo
*
* This succeeds if the menu/menu item exists.
*
* Parameters:
*     pwnd        window
*     idObject    this can be OBJID_MENU, OBJID_SYSMENU, or OBJID_CLIENT
*     idItem      which thing do we need info on? 0..cItems. 0 indicates
*                 the menu itself, 1 is the first item on the menu...
*     pmbi        Pointer to a MENUBARINFO structure that gets filled in
*
\*****************************************************************************/
BOOL xxxGetMenuBarInfo(
    PWND pwnd,
    long idObject,
    long idItem,
    PMENUBARINFO pmbi)
{
    PMENU       pMenu;
    int         cBorders;
    PITEM       pItem;
    PPOPUPMENU  ppopup;

    CheckLock(pwnd);

    /*
     * Validate MENUBARINFO structure.
     */
    if (pmbi->cbSize != sizeof(MENUBARINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "MENUBARINFO.cbSize 0x%x is wrong",
                pmbi->cbSize);
        return FALSE;
    }

    /*
     * Initialize the fields.
     */
    SetRectEmpty(&pmbi->rcBar);
    pmbi->hMenu = NULL;
    pmbi->hwndMenu = NULL;
    pmbi->fBarFocused = FALSE;
    pmbi->fFocused = FALSE;

    /*
     * Get the menu handle we will deal with.
     */
    if (idObject == OBJID_MENU) {
        int cBorders;

        if (TestWF(pwnd, WFCHILD) || !pwnd->spmenu) {
            return FALSE;
        }

        pMenu = pwnd->spmenu;
        if (!pMenu) {
            return FALSE;
        }

        /*
         * If we have an item, is it in the valid range?
         */
        if ((idItem < 0) || ((DWORD)idItem > pMenu->cItems)) {
            return FALSE;
        }

        /*
         * Menu handle.
         */
        pmbi->hMenu = PtoHq(pMenu);

        /*
         * Menu rect.
         */
        if (pMenu->cxMenu && pMenu->cyMenu) {
            if (!idItem) {
                cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
                pmbi->rcBar.left = pwnd->rcWindow.left + cBorders * SYSMET(CXBORDER);
                pmbi->rcBar.top = pwnd->rcWindow.top + cBorders * SYSMET(CYBORDER);

                if (TestWF(pwnd, WFCPRESENT)) {
                    pmbi->rcBar.top += (TestWF(pwnd, WEFTOOLWINDOW) ? SYSMET(CYSMCAPTION) : SYSMET(CYCAPTION));
                }

                pmbi->rcBar.right = pmbi->rcBar.left + pMenu->cxMenu;
                pmbi->rcBar.bottom = pmbi->rcBar.top + pMenu->cyMenu;
            } else {
                pItem = pMenu->rgItems + idItem - 1;

                pmbi->rcBar.left = pwnd->rcWindow.left + pItem->xItem;
                pmbi->rcBar.top = pwnd->rcWindow.top + pItem->yItem;
                pmbi->rcBar.right = pmbi->rcBar.left + pItem->cxItem;
                pmbi->rcBar.bottom = pmbi->rcBar.top + pItem->cyItem;
            }
        }

        /*
         * Are we currently in app menu bar mode?
         */
        ppopup = GetpGlobalPopupMenu(pwnd);
        if (ppopup && ppopup->fHasMenuBar && !ppopup->fIsSysMenu &&
            (ppopup->spwndNotify == pwnd)) {
            pmbi->fBarFocused = TRUE;

            if (!idItem) {
                pmbi->fFocused = TRUE;
            } else if (ppopup->ppopupmenuRoot->posSelectedItem == (UINT)idItem-1) {
                pmbi->fFocused = TRUE;
                UserAssert(ppopup->ppopupmenuRoot);
                pmbi->hwndMenu = HW(ppopup->ppopupmenuRoot->spwndNextPopup);
            }
        }
    } else if (idObject == OBJID_SYSMENU) {
        if (!TestWF(pwnd, WFSYSMENU)) {
            return FALSE;
        }

        pMenu = xxxGetSysMenu(pwnd, FALSE);
        if (!pMenu) {
            return FALSE;
        }

        // If we have an item, is it in the valid range?
        if ((idItem < 0) || ((DWORD)idItem > pMenu->cItems))
            return FALSE;

        pmbi->hMenu = PtoHq(pMenu);

        /*
         * Menu rect
         */
        if (_HasCaptionIcon(pwnd)) {
            // The menu and single item take up the same space
            cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
            pmbi->rcBar.left = pwnd->rcWindow.left + cBorders * SYSMET(CXBORDER);
            pmbi->rcBar.top = pwnd->rcWindow.top + cBorders * SYSMET(CYBORDER);

            pmbi->rcBar.right = pmbi->rcBar.left +
                (TestWF(pwnd, WEFTOOLWINDOW) ? SYSMET(CXSMSIZE) : SYSMET(CXSIZE));

            pmbi->rcBar.bottom = pmbi->rcBar.top +
                (TestWF(pwnd, WEFTOOLWINDOW) ? SYSMET(CYSMSIZE) : SYSMET(CYSIZE));
        }

        /*
         * Are we currently in system menu bar mode?
         */
        ppopup = GetpGlobalPopupMenu(pwnd);
        if (ppopup && ppopup->fHasMenuBar && ppopup->fIsSysMenu &&
            (ppopup->spwndNotify == pwnd))
        {
            pmbi->fBarFocused = TRUE;

            if (!idItem) {
                pmbi->fFocused = TRUE;
            } else if (ppopup->ppopupmenuRoot->posSelectedItem == (UINT)idItem - 1) {
                pmbi->fFocused = TRUE;
                UserAssert(ppopup->ppopupmenuRoot);
                pmbi->hwndMenu = HW(ppopup->ppopupmenuRoot->spwndNextPopup);
            }
        }
    } else if (idObject == OBJID_CLIENT) {
        HMENU hMenu = (HMENU)xxxSendMessage(pwnd, MN_GETHMENU, 0, 0);
        pMenu = ValidateHmenu(hMenu);
        if (!pMenu) {
            return FALSE;
        }

        // If we have an item, is it in the valid range?
        if ((idItem < 0) || ((DWORD)idItem > pMenu->cItems)) {
            return FALSE;
        }

        pmbi->hMenu = hMenu;

        if (!idItem) {
            pmbi->rcBar = pwnd->rcClient;
        } else {
            pItem = pMenu->rgItems + idItem - 1;

            pmbi->rcBar.left = pwnd->rcClient.left + pItem->xItem;
            pmbi->rcBar.top = pwnd->rcClient.top + pItem->yItem;
            pmbi->rcBar.right = pmbi->rcBar.left + pItem->cxItem;
            pmbi->rcBar.bottom = pmbi->rcBar.top + pItem->cyItem;
        }

        /*
         * Are we currently in popup mode with us as one of the popups
         * showing?
         *
         * Since malicious code could handle MN_GETHMENU and return a valid
         * HMENU *w/o* pwnd being a real MENUWND, we need to explicitly
         * check the fnid.
         */
        if (GETFNID(pwnd) == FNID_MENU &&
            (ppopup = ((PMENUWND)pwnd)->ppopupmenu) &&
            (ppopup->ppopupmenuRoot == GetpGlobalPopupMenu(pwnd))) {
            pmbi->fBarFocused = TRUE;

            if (!idItem) {
                pmbi->fFocused = TRUE;
            } else if ((UINT)idItem == ppopup->posSelectedItem + 1) {
                pmbi->fFocused = TRUE;
                pmbi->hwndMenu = HW(ppopup->spwndNextPopup);
            }
        }
    } else {
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
* xxxGetComboBoxInfo
*
* This returns combobox information for either a combo or its dropdown
* list.
\***************************************************************************/
BOOL xxxGetComboBoxInfo(
    PWND pwnd,
    PCOMBOBOXINFO pcbi)
{
    PCLS    pcls;
    COMBOBOXINFO cbi = {
        sizeof cbi,
    };
    BOOL fOtherProcess;
    BOOL bRetval = FALSE;
    WORD wWindowType = 0;

    CheckLock(pwnd);

    /*
     * Make sure it is a combobox or a dropdown.
     */
    pcls = pwnd->pcls;
    if ((GETFNID(pwnd) == FNID_COMBOBOX) ||
            (pcls->atomClassName == gpsi->atomSysClass[ICLS_COMBOBOX])) {
        wWindowType = FNID_COMBOBOX;
    } else if ((GETFNID(pwnd) == FNID_COMBOLISTBOX) ||
            (pcls->atomClassName == gpsi->atomSysClass[ICLS_COMBOLISTBOX])) {
        wWindowType = FNID_COMBOLISTBOX;
    } else {
        return (BOOL)xxxSendMessage(pwnd, CB_GETCOMBOBOXINFO, 0, (LPARAM)pcbi);
    }

    /*
     * Validate combo structure
     */
    if (pcbi->cbSize != sizeof(COMBOBOXINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "COMBOBOXINFO.cbSize %d is wrong", pcbi->cbSize);
        return FALSE;
    }

    if (fOtherProcess = (GETPTI(pwnd)->ppi != PpiCurrent())) {
        KeAttachProcess(PsGetProcessPcb(GETPTI(pwnd)->ppi->Process));
    }

    try {
        PCBOX ccxPcboxSnap;
        PWND ccxPwndSnap;
        HWND ccxHwndSnap;

        /*
         * Snap and probe the CBOX structure, since it is client side.
         */
        if (wWindowType == FNID_COMBOBOX) {
            ccxPcboxSnap = ((PCOMBOWND)pwnd)->pcbox;
        } else {
            PLBIV ccxPlbSnap;
            /*
             * If this is a listbox, we must snap and probe the LBIV structure
             * in order to get to the CBOX structure.
             */
            ccxPlbSnap = ((PLBWND)pwnd)->pLBIV;
            if (!ccxPlbSnap) {
                goto errorexit;
            }
            ProbeForRead(ccxPlbSnap, sizeof(LBIV), DATAALIGN);
            ccxPcboxSnap = ccxPlbSnap->pcbox;
        }
        if (!ccxPcboxSnap) {
            goto errorexit;
        }
        ProbeForRead(ccxPcboxSnap, sizeof(CBOX), DATAALIGN);

        /*
         * Get the combo information now.
         */

        /*
         * Snap and probe the client side pointer to the Combo window.
         */
        ccxPwndSnap = ccxPcboxSnap->spwnd;
        ProbeForRead(ccxPwndSnap, sizeof(HEAD), DATAALIGN);
        cbi.hwndCombo = HWCCX(ccxPwndSnap);

        /*
         * Snap & probe the client side pointer to the Edit window.
         * To compare spwndEdit and pwnd, we should compare handles
         * since spwndEdit is a client-side address and pwnd is a
         * kernel-mode address,
         */

        ccxPwndSnap = ccxPcboxSnap->spwndEdit;
        /*
         * If combobox is not fully initialized and spwndEdit is NULL,
         * we should fail.
         */
        ProbeForRead(ccxPwndSnap, sizeof(HEAD), DATAALIGN);
        ccxHwndSnap = HWCCX(ccxPwndSnap);
        if (ccxHwndSnap == HW(pwnd)) {
            /*
             * ComboBox doesn't have Edit control.
             */
            cbi.hwndItem = NULL;
        } else {
            cbi.hwndItem = HWCCX(ccxPwndSnap);
        }

        /*
         * Snap and probe the client side pointer to the List window
         */
        ccxPwndSnap = ccxPcboxSnap->spwndList;
        /*
         * If combobox is not fully initialized and spwndList is NULL,
         * we should fail.
         */
        ProbeForRead(ccxPwndSnap, sizeof(HEAD), DATAALIGN);
        cbi.hwndList = HWCCX(ccxPwndSnap);

        /*
         * Snap the rest of the combo information. We don't need to probe
         * any of these, since there are no more indirections.
         */
        cbi.rcItem = ccxPcboxSnap->editrc;
        cbi.rcButton = ccxPcboxSnap->buttonrc;

        /*
         * Button state.
         */
        cbi.stateButton = 0;
        if (ccxPcboxSnap->CBoxStyle == CBS_SIMPLE) {
            cbi.stateButton |= STATE_SYSTEM_INVISIBLE;
        }
        if (ccxPcboxSnap->fButtonPressed) {
            cbi.stateButton |= STATE_SYSTEM_PRESSED;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        goto errorexit;
    }

    *pcbi = cbi;
    bRetval = TRUE;

errorexit:
    if (fOtherProcess) {
        KeDetachProcess();
    }

    return bRetval;
}


/***************************************************************************\
* xxxGetListBoxInfo
*
* Currently returns back the # of items per column. There is no way to get
* or calculate this info any other way in a multicolumn list.
*
* For now, no structure is returned. If we ever need one more thing, make one.
\***************************************************************************/
DWORD xxxGetListBoxInfo(
    PWND pwnd)
{
    PCLS    pcls;
    DWORD   dwRet = 0;
    BOOL    fOtherProcess;

    CheckLock(pwnd);

    /*
     * Make sure it is a combobox or a dropdown.
     */
    pcls = pwnd->pcls;
    if ((pcls->atomClassName != gpsi->atomSysClass[ICLS_LISTBOX]) &&
            (GETFNID(pwnd) != FNID_LISTBOX)) {
        return (DWORD)xxxSendMessage(pwnd, LB_GETLISTBOXINFO, 0, 0);
    }

    if (fOtherProcess = (GETPTI(pwnd)->ppi != PpiCurrent())) {
        KeAttachProcess(PsGetProcessPcb(GETPTI(pwnd)->ppi->Process));
    }

    try {
        PLBIV ccxPlbSnap;

        /*
         * Snap and probe the pointer to the LBIV, since it is client-side.
         */
        ccxPlbSnap = ((PLBWND)pwnd)->pLBIV;
        if (!ccxPlbSnap) {
            goto errorexit;
        }
        ProbeForRead(ccxPlbSnap, sizeof(LBIV), DATAALIGN);

        if (ccxPlbSnap->fMultiColumn) {
            dwRet = ccxPlbSnap->itemsPerColumn;
        } else {
            dwRet = ccxPlbSnap->cMac;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        dwRet = 0;
    }

errorexit:
    if (fOtherProcess) {
        KeDetachProcess();
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\winloop2.c ===
/*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*/

#include "precomp.h"
#pragma hdrstop

// ----------------------------------------------------------------------------
//
//  IsVSlick() -
//
//  TRUE if window is positioned at +100,+100 from bottom right of screen --
//  probably VSlick -- which has two Tray Windows, one is unowned but off the
//  screen....we want the owned one since its on the screen
//
// ----------------------------------------------------------------------------
BOOL IsVSlick(PWND pwnd)
{
    if (gpDispInfo->cMonitors == 1 &&
        ((unsigned) pwnd->rcWindow.left > (unsigned) gpDispInfo->rcScreen.right ) &&
        ((unsigned) pwnd->rcWindow.top  > (unsigned) gpDispInfo->rcScreen.bottom) &&
        (pwnd->rcWindow.top == (gpDispInfo->rcScreen.bottom+100)) &&
        (pwnd->rcWindow.left == (gpDispInfo->rcScreen.right+100)))
    {
        // MUST BE THE ONE AND ONLY V-SLICK
        return(TRUE);
    }

    return(FALSE);
}

// ----------------------------------------------------------------------------
//
//  Is31TrayWindow() -
//
//  extra grilling required for 3.1 and earlier apps before letting 'em in the
//  tray -- trust me, you DON'T want to change this code. -- JEFFBOG 11/10/94
//
// ----------------------------------------------------------------------------
BOOL Is31TrayWindow(PWND pwnd)
{
    PWND pwnd2;

    if (!(pwnd2 = pwnd->spwndOwner))
        return (!IsVSlick(pwnd)); // unowned -- do we want you?

    if (TestWF(pwnd2, WEFTOOLWINDOW))
        return(FALSE); // owned by a tool window -- we don't want

    return((FHas31TrayStyles(pwnd2) ? (IsVSlick(pwnd2)) : TRUE));
}


// ----------------------------------------------------------------------------
//
//  IsTrayWindow() -
//
//  TRUE if the window passes all the necessary checks -- making it a window
//  that should appear in the tray.
//
// ----------------------------------------------------------------------------
BOOL IsTrayWindow(PWND pwnd)
{
    if ((pwnd==NULL) || !(FDoTray() && (FCallHookTray() || FPostTray(pwnd->head.rpdesk))) ||
            !FTopLevel(pwnd))
        return(FALSE);

    // Check for WS_EX_APPWINDOW or WS_EX_TOOLWINDOW "overriding" bits
    if (TestWF(pwnd, WEFAPPWINDOW))
        return(TRUE);

    if (TestWF(pwnd, WEFTOOLWINDOW))
        return(FALSE);

    if (TestWF(pwnd, WEFNOACTIVATE)) {
        return FALSE;
    }

    if (TestWF(pwnd, WFWIN40COMPAT)) {
        if (pwnd->spwndOwner == NULL)
            return(TRUE);
        if (TestWF(pwnd->spwndOwner, WFWIN40COMPAT))
            return(FALSE);
        // if this window is owned by a 3.1 window, check it like a 3.1 window
    }

    if (!FHas31TrayStyles(pwnd))
        return(FALSE);

    return(Is31TrayWindow(pwnd));
}

/***************************************************************************\
* xxxSetTrayWindow
*
* History:
* 11-Dec-1996 adams     Created.
\***************************************************************************/

void xxxSetTrayWindow(PDESKTOP pdesk, PWND pwnd, PMONITOR pMonitor)
{
    HWND hwnd;

    CheckLock(pMonitor);

    if (pwnd == STW_SAME) {
        pwnd = pdesk->spwndTray;
        hwnd = PtoH(pwnd);
    } else {
        CheckLock(pwnd);
        hwnd = PtoH(pwnd);
        Lock(&(pdesk->spwndTray), pwnd);
    }

    if (!pMonitor) {
        if (pwnd) {
            pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
        } else {
            pMonitor = GetPrimaryMonitor();
        }
    }

    if ( FPostTray(pdesk)) {
        PostShellHookMessages(
                pMonitor->cFullScreen ?
                        HSHELL_RUDEAPPACTIVATED : HSHELL_WINDOWACTIVATED,
                (LPARAM) hwnd);
    }

    if ( FCallHookTray() ) {
        xxxCallHook(
                HSHELL_WINDOWACTIVATED,
                (WPARAM) hwnd,
                (pMonitor->cFullScreen ? 1 : 0),
                WH_SHELL);
    }
}



/***************************************************************************\
* xxxAddFullScreen
*
* Adds an app to the fullscreen list and moves the tray if it is
* the first fullscreen app.
*
* History:
* 27-Feb-1997 adams     Commented.
\***************************************************************************/

BOOL xxxAddFullScreen(PWND pwnd, PMONITOR pMonitor)
{
    BOOL    fYielded;

    PDESKTOP pdesk = pwnd->head.rpdesk;

    CheckLock(pwnd);
    CheckLock(pMonitor);

    if (pdesk == NULL)
        return FALSE;

    fYielded = FALSE;
    if (!TestWF(pwnd, WFFULLSCREEN) && FCallTray(pdesk))
    {
        SetWF(pwnd, WFFULLSCREEN);

        if (pMonitor->cFullScreen++ == 0) {
            xxxSetTrayWindow(pdesk, STW_SAME, pMonitor);
            fYielded = TRUE;
        }

        pwnd = pwnd->spwndOwner;
        if (    pwnd &&
                !TestWF(pwnd, WFCHILD) &&
                pwnd->rcWindow.right == 0 &&
                pwnd->rcWindow.left == 0 &&
                !TestWF(pwnd, WFVISIBLE)) {

            TL tlpwnd;
            ThreadLock(pwnd, &tlpwnd);
            if (xxxAddFullScreen(pwnd, pMonitor)) {
                fYielded = TRUE;
            }

            ThreadUnlock(&tlpwnd);
        }
    }

    return fYielded;
}



/***************************************************************************\
* xxxRemoveFullScreen
*
* Adds an app to the fullscreen list and moves the tray if there
* are no more fullscreen apps.
*
* History:
* 27-Feb-1997 adams     Commented.
\***************************************************************************/

BOOL xxxRemoveFullScreen(PWND pwnd, PMONITOR pMonitor)
{
    PDESKTOP pdesk = pwnd->head.rpdesk;
    BOOL    fYielded;

    CheckLock(pwnd);
    CheckLock(pMonitor);

    if (pdesk == NULL)
        return FALSE;

    fYielded = FALSE;
    if (TestWF(pwnd, WFFULLSCREEN) && FCallTray(pdesk)) {
        ClrWF(pwnd, WFFULLSCREEN);

        if (--pMonitor->cFullScreen == 0) {
            xxxSetTrayWindow(pdesk, STW_SAME, pMonitor);
            fYielded = TRUE;
        }

        /*
         * (adams): Remove this assertion temporarily while I work on
         * a fix for the problem.
         *
         * UserAssert(pMonitor->cFullScreen >= 0);
         */
    }

    return fYielded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\winhtky.c ===
/****************************** Module Header ******************************\
* Module Name: whotkeys.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the core functions of 3.1 window hotkey processing.
*
* History:
* 16-Apr-1992 JimA      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* HotKeyToWindow
*
* Scans the hotkey table and returns the pwnd corresponding to the
* given hot key.  Returns NULL if no such hot key in the list.  Looks at the
* current key state array.
*
* History:
* 04-15-92 JimA         Ported from Win3.1 sources.
\***************************************************************************/

PWND HotKeyToWindow(
    DWORD key)
{
    PHOTKEYSTRUCT phk;
    int ckeys;

    ckeys = gcHotKey;

    if (ckeys == 0)
        return 0;

    phk = gpHotKeyList;

    while (ckeys) {
        if (phk->key == key)
            return TestWF(phk->spwnd, WFVISIBLE) ? phk->spwnd : NULL;
        phk++;
        ckeys--;
    }

    return 0;
}


/***************************************************************************\
* HotKeyHelper
*
* Scans the hot key list and returns a pointer to the entry for the
* window.
*
* History:
* 04-15-92 JimA         Ported from Win3.1 sources.
\***************************************************************************/

PHOTKEYSTRUCT HotKeyHelper(
    PWND pwnd)
{
    PHOTKEYSTRUCT phk;
    int count;

    count = gcHotKey;

    if (gpHotKeyList == NULL)
        return 0;

    phk = gpHotKeyList;

    while (count) {
        if (phk->spwnd == pwnd)
            return phk;
        phk++;
        count--;
    }

    return 0;
}


/***************************************************************************\
* DWP_SetHotKey
*
* Set the hot key for this window.  Replace existing hot key, or if new
* key is NULL, delete the entry.  Return 2 if key already existed and
* was replaced, 1 if key did not exist and was set, 0 for
* failure, and -1 for invalid hot key.
*
* History:
* 15-Apr-1992 JimA      Ported from Win3.1 sources.
\***************************************************************************/

UINT DWP_SetHotKey(
    PWND  pwnd,
    DWORD dwKey)
{
    PHOTKEYSTRUCT phk;
    BOOL          fKeyExists = FALSE;
    PWND          pwndTemp;

    /*
     * Filter out invalid hotkeys
     */
    if (LOBYTE(dwKey) == VK_ESCAPE ||
        LOBYTE(dwKey) == VK_SPACE ||
        LOBYTE(dwKey) == VK_TAB ||
        LOBYTE(dwKey) == VK_PACKET) {

        return (UINT)-1;
    }

    /*
     * Don't allow hotkeys for children
     */
    if (TestWF(pwnd, WFCHILD))
        return 0;

    /*
     * Check if the hot key exists and is assigned to a different pwnd
     */
    if (dwKey != 0) {

        pwndTemp = HotKeyToWindow(dwKey);

        if ((pwndTemp != NULL) && (pwndTemp != pwnd))
            fKeyExists = TRUE;
    }

    /*
     * Get the hotkey assigned to the window, if any
     */
    if ((phk = HotKeyHelper(pwnd)) == NULL) {

        /*
         * Window doesn't exist in the hotkey list and key is being set
         * to zero, so just return.
         */
        if (dwKey == 0)
            return 1;

        /*
         * Allocate and point to a spot for the new hotkey
         */
        if (gcHotKey >= gcHotKeyAlloc) {

            if (gcHotKeyAlloc) {

                phk = (PHOTKEYSTRUCT)UserReAllocPool(
                        (HANDLE)gpHotKeyList,
                        gcHotKeyAlloc * sizeof(HOTKEYSTRUCT),
                        (gcHotKey + 1) * sizeof(HOTKEYSTRUCT), TAG_HOTKEY);

                if (phk != NULL) {

                    gpHotKeyList = phk;
                    phk = &gpHotKeyList[gcHotKey++];
                    gcHotKeyAlloc = gcHotKey;

                } else {

                    return 0;
                }

            } else {

                UserAssert(gpHotKeyList == NULL);
                UserAssert(gcHotKey == 0);

                phk = (PHOTKEYSTRUCT)UserAllocPool(sizeof(HOTKEYSTRUCT),
                                                   TAG_HOTKEY);

                if (phk != NULL) {

                    gpHotKeyList = phk;
                    gcHotKey = 1;
                    gcHotKeyAlloc = 1;

                } else {

                    return 0;
                }
            }

        } else {
            phk = &gpHotKeyList[gcHotKey++];
        }
    }

    if (dwKey == 0) {

        /*
         * The hotkey for this window is being deleted. Copy the last item
         * on the list on top of the one being deleted.
         */
        if (--gcHotKey) {

            Lock(&phk->spwnd, gpHotKeyList[gcHotKey].spwnd);
            Unlock(&gpHotKeyList[gcHotKey].spwnd);

            phk->key = gpHotKeyList[gcHotKey].key;
            phk = (PHOTKEYSTRUCT)UserReAllocPool((HANDLE)gpHotKeyList,
                gcHotKeyAlloc * sizeof(HOTKEYSTRUCT),
                gcHotKey * sizeof(HOTKEYSTRUCT), TAG_HOTKEY);

            if (phk != NULL) {
                gpHotKeyList = phk;
                gcHotKeyAlloc = gcHotKey;
            }

        } else {

            Unlock(&gpHotKeyList[gcHotKey].spwnd);
            UserFreePool((HANDLE)gpHotKeyList);
            gpHotKeyList = NULL;
            gcHotKeyAlloc = 0;
        }

    } else {

        /*
         * Add the window and key to the list
         */
        phk->spwnd = NULL;
        Lock(&phk->spwnd, pwnd);
        phk->key = dwKey;
    }

    return fKeyExists ? 2 : 1;
}

/***************************************************************************\
* DWP_GetHotKey
*
*
* History:
* 15-Apr-1992 JimA      Created.
\***************************************************************************/

UINT DWP_GetHotKey(
    PWND pwnd)
{
    PHOTKEYSTRUCT phk;

    if ((phk = HotKeyHelper(pwnd)) == NULL)
        return 0;

    return phk->key;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\winmgr.c ===
/****************************** Module Header ******************************\
* Module Name: winmgr.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Core Window Manager APIs and support routines.
*
* History:
* 24-Sep-1990 darrinm   Generated stubs.
* 22-Jan-1991 IanJa     Handle revalidation added
* 19-Feb-1991 JimA      Added enum access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxFlashWindow (API)
*
* New for 5.0: HIWORD(dwFlags) contains the number of times the window should be
*              flashed. LOWORD(dwFlags) contains the FLASHW_ bits.
*
* History:
* 27-Nov-1990 DarrinM   Ported.
* 15-Nov-1997 MCostea   Added dwTimeout and windowing the maximised cmd
\***************************************************************************/
BOOL xxxFlashWindow(
    PWND pwnd,
    DWORD dwFlags,
    DWORD dwTimeout)
{

    BOOL fStatePrev = FALSE;
    BOOL fFlashOn;
    DWORD dwState;

    CheckLock(pwnd);
    /*
     * Get the previous state. If not available (FLASHW_STOP) then
     *  initialize on/off based on frame
     */
    dwState = GetFlashWindowState(pwnd);
    if (dwState == FLASHW_DONE) {
        /*
         * We just need to clean up and to set the activation correctly
         */
        dwState |= FLASHW_KILLTIMER;
        dwFlags = FLASHW_STOP;
        goto flash;
    }
    if (dwState == FLASHW_STOP) {
#if defined(_X86_)
        /*
         * If there is a fullscreen cmd window, switch it to window mode
         * so that the user gets a chance to see the flashing one
         */
        if (gbFullScreen == FULLSCREEN) {
            _PostMessage(gspwndFullScreen, CM_MODE_TRANSITION, (WPARAM)WINDOWED, (LPARAM)0);
        }
#endif // _X86_
        if (TestWF(pwnd, WFFRAMEON)) {
            dwState = FLASHW_ON | FLASHW_STARTON;
        }
    } else if (dwFlags == FLASHW_TIMERCALL) {
        dwFlags = dwState;
    }
    dwFlags &= FLASHW_CALLERBITS;
    fStatePrev = (dwState & FLASHW_ON);
    /*
     * Later5.0 Gerardob
     * Not sure why we do this check but it used to be here.
     */
    if (pwnd == gspwndAltTab) {
        return fStatePrev;
    }
    /*
     * Check if we're waiting to come to the foreground to stop.
     */
    if (dwState & FLASHW_FLASHNOFG) {
        if (gpqForeground == GETPTI(pwnd)->pq)
            dwFlags = FLASHW_STOP;
    }

flash:
    /*
     * Figure out new state
     */
    if (dwFlags != FLASHW_STOP) {
        fFlashOn =  !fStatePrev;
    } else {
        fFlashOn = (gpqForeground != NULL) && (gpqForeground->spwndActive == pwnd);
    }
    /*
     * Flash'em
     */
    if ((dwFlags == FLASHW_STOP) || (dwFlags & FLASHW_CAPTION)) {
        xxxSendMessage(pwnd, WM_NCACTIVATE, fFlashOn, 0L);
    }
    if ((dwFlags == FLASHW_STOP) || (dwFlags & FLASHW_TRAY)) {
        if (IsTrayWindow(pwnd)) {
            HWND hw = HWq(pwnd);
            BOOL fShellFlash;
            if (dwState & FLASHW_DONE) {
                /*
                 * If the window is not the active one when we're done flashing,
                 * let the tray icon remain activated.  The Shell  is going to
                 * take care to restore it at the when the window gets activated
                 */
                fShellFlash = !fFlashOn;
            } else {
                fShellFlash = (dwFlags == FLASHW_STOP ? FALSE : fFlashOn);
            }
            xxxCallHook(HSHELL_REDRAW, (WPARAM) hw, (LPARAM) fShellFlash, WH_SHELL);
            PostShellHookMessages(fShellFlash? HSHELL_FLASH:HSHELL_REDRAW, (LPARAM)hw);
        }
    }
    /*
     *  If we're to continue, check count, set timer and store
     *   state as appropriate. Otherwise, kill timer and remove
     *   state
     */
    if (dwFlags != FLASHW_STOP) {
        /*
         * If counting, decrement count when we complete a cycle
         */
        if (HIWORD(dwFlags) != 0) {
            dwState |= FLASHW_COUNTING;
            if (!(fFlashOn ^ !!(dwState & FLASHW_STARTON))) {
                dwFlags -= MAKELONG(0,1);
            }
            /*
             * Make sure we have a timer going.
             */
            if (!(dwState & FLASHW_KILLTIMER)) {
                dwFlags |= FLASHW_TIMER;
            }
        }
        /*
         * Set a timer if needed.
         */
        if (dwFlags & FLASHW_TIMER) {
            dwState |= FLASHW_KILLTIMER;
            InternalSetTimer(pwnd,
                             IDSYS_FLASHWND,
                             dwTimeout ? dwTimeout : gpsi->dtCaretBlink,
                             xxxSystemTimerProc,
                             TMRF_SYSTEM);
        }
        /*
         * Remember on/off state, propagate public flags
         *  and count then save the state
         */
        if (dwState & FLASHW_COUNTING &&
            HIWORD(dwFlags) == 0) {
            dwState = FLASHW_DONE;
        }
        else {
            SET_OR_CLEAR_FLAG(dwState, FLASHW_ON, fFlashOn);
            COPY_FLAG(dwState, dwFlags, FLASHW_CALLERBITS & ~FLASHW_TIMER);
        }
        SetFlashWindowState(pwnd, dwState);

    } else {
        /*
         * We're done.
         */
        if (dwState & FLASHW_KILLTIMER) {
            _KillSystemTimer(pwnd, IDSYS_FLASHWND);
        }
        RemoveFlashWindowState(pwnd);
    }

    return fStatePrev;
}

/***************************************************************************\
* xxxEnableWindow (API)
*
*
* History:
* 12-Nov-1990 DarrinM   Ported.
\***************************************************************************/

BOOL xxxEnableWindow(
    PWND pwnd,
    BOOL fEnable)
{
    BOOL fOldState, fChange;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    fOldState = TestWF(pwnd, WFDISABLED);

    if (!fEnable) {
        fChange = !TestWF(pwnd, WFDISABLED);

        xxxSendMessage(pwnd, WM_CANCELMODE, 0, 0);

        if (pwnd == PtiCurrent()->pq->spwndFocus) {
                xxxSetFocus(NULL);
        }
        SetWF(pwnd, WFDISABLED);

    } else {
        fChange = TestWF(pwnd, WFDISABLED);
        ClrWF(pwnd, WFDISABLED);
    }

    if (fChange) {
        xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_WINDOW,
                INDEXID_CONTAINER, 0);

        xxxSendMessage(pwnd, WM_ENABLE, fEnable, 0L);
    }

    return fOldState;
}

/***************************************************************************\
* xxxDoSend
*
* The following code is REALLY BOGUS!!!! Basically it prevents an
* app from hooking the WM_GET/SETTEXT messages if they're going to
* be called from another app.
*
* History:
* 04-Mar-1992 JimA  Ported from Win 3.1 sources.
\***************************************************************************/

LRESULT xxxDoSend(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam)
{
    /*
     * We compare PROCESSINFO sturctures here so multi-threaded
     * app can do what the want.
     */
    if (GETPTI(pwnd)->ppi == PtiCurrent()->ppi) {
        return xxxSendMessage(pwnd, message, wParam, lParam);
    } else {
        return xxxDefWindowProc(pwnd, message, wParam, lParam);
    }
}

/***************************************************************************\
* xxxGetWindowText (API)
*
*
* History:
* 09-Nov-1990 DarrinM   Wrote.
\***************************************************************************/

int xxxGetWindowText(
    PWND   pwnd,
    LPTSTR psz,
    int    cchMax)
{
    LARGE_UNICODE_STRING str;
    UINT nRet, nLen;

    CheckLock(pwnd);

    if (cchMax) {
        /*
         * Initialize string empty, in case xxxSendMessage aborts validation
         * If a bogus value was returned, rely on str.Length
         */
        str.bAnsi         = FALSE;
        str.MaximumLength = cchMax * sizeof(WCHAR);
        str.Buffer        = psz;
        str.Length        = 0;

        *psz = TEXT('\0');

        nRet = (UINT)xxxDoSend(pwnd, WM_GETTEXT, cchMax, (LPARAM)&str);
        nLen = str.Length / sizeof(WCHAR);
        return (nRet > nLen) ? nLen : nRet;
    }

    return 0;
}

/***************************************************************************\
* xxxSetParent (API)
*
* Change a windows parent to a new window.  These steps are taken:
*
* 1. The window is hidden (if visible),
* 2. Its coordinates are mapped into the new parent's space such that the
*    window's screen-relative position is unchanged.
* 3. The window is unlinked from its old parent and relinked to the new.
* 4. xxxSetWindowPos is used to move the window to its new position.
* 5. The window is shown again (if originally visible)
*
* NOTE: If you have a child window and set its parent to be NULL (the
* desktop), the WS_CHILD style isn't removed from the window. This bug has
* been in windows since 2.x. It turns out the apps group depends on this for
* their combo boxes to work.  Basically, you end up with a top level window
* that never gets activated (our activation code blows it off due to the
* WS_CHILD bit).
*
* History:
* 12-Nov-1990 DarrinM   Ported.
* 19-Feb-1991 JimA      Added enum access check
* 12-Apr-2001 Mohamed   Added the check of parenting your owner.
\***************************************************************************/

PWND xxxSetParent(
    PWND pwnd,
    PWND pwndNewParent)
{
    POINT pt;
    BOOL  fVisible;
    PWND  pwndOldParent, pwndOldRedirectedParent, pwndNewRedirectedParent;
    TL    tlpwndOldParent;
    TL    tlpwndNewParent;
    PVOID pvRet;
    PWND  pwndDesktop;
    PWND  pwndT;
    int flags = SWP_NOZORDER | SWP_NOSIZE;

    CheckLock(pwnd);
    CheckLock(pwndNewParent);

    if (!ValidateParentDepth(pwnd, pwndNewParent)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Exceeded nested children limit");
        return NULL;
    }

    pwndDesktop = PWNDDESKTOP(pwnd);

    /*
     * In 1.0x, an app's parent was null, but now it is pwndDesktop.
     * Need to remember to lock pwndNewParent because we're reassigning
     * it here.
     */
    if (pwndNewParent == NULL)
        pwndNewParent = pwndDesktop;

    /*
     * Don't ever change the parent of the desktop.
     */
    if ((pwnd == pwndDesktop) || (pwnd == PWNDMESSAGE(pwnd))) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied: can't change parent of the desktop");

        return NULL;
    }

    /*
     * Don't let the window become its own parent, grandparent, etc.
     */
    for (pwndT = pwndNewParent; pwndT != NULL; pwndT = pwndT->spwndParent) {

        if (pwnd == pwndT) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING,
                  "Attempting to create a parent-child relationship loop.");
            return NULL;
        }
    }

    /*
     * Don't let the window become the parent of its owner, or of its owner's
     * owner, etc.  This throws ZOrderByOwner2 into an infinite loop.
     */
    for (pwndT = pwndNewParent->spwndOwner; pwndT != NULL; pwndT = pwndT->spwndOwner) {
        if (pwnd == pwndT) {
            RIPERR0(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "Attempting to create a parent-owner relationship loop.");
            return NULL;
        }
    }

    /*
     * We still need pwndNewParent across callbacks...  and even though
     * it was passed in, it may have been reassigned above.
     */
    ThreadLock(pwndNewParent, &tlpwndNewParent);

    /*
     * Make the thing disappear from original parent.
     */
    fVisible = xxxShowWindow(pwnd, MAKELONG(SW_HIDE, TEST_PUDF(PUDF_ANIMATE)));

    /*
     * Ensure that the window being changed and the new parent
     * are not in a destroyed state.
     *
     * IMPORTANT: After this check, do not leave the critical section
     * until the window links have been rearranged.
     */
    if (TestWF(pwnd, WFDESTROYED) || TestWF(pwndNewParent, WFDESTROYED)) {
        ThreadUnlock(&tlpwndNewParent);
        return NULL;
    }

    pwndOldRedirectedParent = GetStyleWindow(pwnd, WEFPREDIRECTED);
    pwndNewRedirectedParent = GetStyleWindow(pwndNewParent, WEFPREDIRECTED);

    if ((pwndOldRedirectedParent != NULL) && (pwndOldRedirectedParent != pwnd)
        && (pwndNewRedirectedParent == NULL)) {
        ConvertRedirectionDCs(pwnd, NULL);
    }

    pwndOldParent = pwnd->spwndParent;
    ThreadLock(pwndOldParent, &tlpwndOldParent);

    if (TestWF(pwndOldParent, WEFLAYOUTRTL)) {
        pt.x = pwnd->rcWindow.right;
    } else {
        pt.x = pwnd->rcWindow.left;
    }
    pt.y = pwnd->rcWindow.top;
    _ScreenToClient(pwndOldParent, &pt);

    UnlinkWindow(pwnd, pwndOldParent);
    Lock(&pwnd->spwndParent, pwndNewParent);

    if (pwndNewParent == PWNDDESKTOP(pwnd) && !TestWF(pwnd, WEFTOPMOST)) {

        /*
         * Make sure a child who's owner is topmost inherits the topmost
         * bit. - win31 bug 7568
         */
        if (TestWF(pwnd, WFCHILD) &&
            (pwnd->spwndOwner) &&
            TestWF(pwnd->spwndOwner, WEFTOPMOST)) {

            SetWF(pwnd, WEFTOPMOST);
        }

        /*
         * BACKWARD COMPATIBILITY HACK ALERT
         *
         * All top level windows must be WS_CLIPSIBLINGs bit set.
         * The SDM ComboBox() code calls SetParent() with a listbox
         * window that does not have this set.  This causes problems
         * with InternalInvalidate2() because it does not subtract off
         * the window from the desktop's update region.
         *
         * We must invalidate the DC cache here, too, because if there is
         * a cache entry lying around, its clipping region will be incorrect.
         */
        if ((pwndNewParent == _GetDesktopWindow()) &&
            !TestWF(pwnd, WFCLIPSIBLINGS)) {

            SetWF(pwnd, WFCLIPSIBLINGS);
            zzzInvalidateDCCache(pwnd, IDC_DEFAULT);
        }

        /*
         * This is a top level window but it isn't a topmost window so we
         * have to link it below all topmost windows.
         */
        LinkWindow(pwnd,
                   CalcForegroundInsertAfter(pwnd),
                   pwndNewParent);
    } else {

        /*
         * If this is a child window or if this is a TOPMOST window, we can
         * link at the head of the parent chain.
         */
        LinkWindow(pwnd, NULL, pwndNewParent);
    }

    /*
     * If we're a child window, do any necessary attaching and
     * detaching.
     */
    if (TestwndChild(pwnd)) {

        /*
         * Make sure we're not a WFCHILD window that got SetParent()'ed
         * to the desktop.
         */
        if ((pwnd->spwndParent != PWNDDESKTOP(pwnd)) &&
            GETPTI(pwnd) != GETPTI(pwndOldParent)) {

            zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwndOldParent), FALSE);
        }

        /*
         * If the new parent window is on a different thread, and also
         * isn't the desktop window, attach ourselves appropriately.
         */
        if (pwndNewParent != PWNDDESKTOP(pwnd) &&
            GETPTI(pwnd) != GETPTI(pwndNewParent)) {

            zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwndNewParent), TRUE);
        }
    }


    /*
     * If we are moving under a WS_EX_COMPOSITED parent-chain, we need to turn
     * off any child windows in the subtree that are WS_EX_COMPOSITED.
     */

    if (GetStyleWindow(pwnd->spwndParent, WEFCOMPOSITED) != NULL) {
        xxxTurnOffCompositing(pwnd, FALSE);
    }


    if (pwndNewParent == PWNDMESSAGE(pwnd) || pwndOldParent == PWNDMESSAGE(pwnd))
        flags |= SWP_NOACTIVATE;

    xxxWindowEvent(EVENT_OBJECT_PARENTCHANGE, pwnd, OBJID_WINDOW,
            INDEXID_CONTAINER, WEF_USEPWNDTHREAD);

    /*
     * We mustn't return an invalid pwndOldParent
     */
    xxxSetWindowPos(pwnd, NULL, pt.x, pt.y, 0, 0, flags);

    if (fVisible) {
        xxxShowWindow(pwnd, MAKELONG(SW_SHOWNORMAL, TEST_PUDF(PUDF_ANIMATE)));
    }

    /*
     * returns pwndOldParent if still valid, else NULL.
     */
    pvRet = ThreadUnlock(&tlpwndOldParent);
    ThreadUnlock(&tlpwndNewParent);

    return pvRet;
}

/***************************************************************************\
* xxxFindWindowEx (API)
*
* Searches for a window among top level windows. The keys used are pszClass,
* (the class name) and/or pszName, (the window title name). Either can be
* NULL.
*
* History:
* 06-Jun-1994 JohnL     Converted xxxFindWindow to xxxFindWindowEx
* 10-Nov-1992 mikeke    Added 16bit and 32bit only flag
* 24-Sep-1990 DarrinM   Generated stubs.
* 02-Jun-1991 ScottLu   Ported from Win3.
* 19-Feb-1991 JimA      Added enum access check
\***************************************************************************/

#define CCHMAXNAME 80

PWND _FindWindowEx(
    PWND   pwndParent,
    PWND   pwndChild,
    LPCWSTR ccxlpszClass,
    LPCWSTR ccxlpszName,
    DWORD  dwType)
{
    /*
     * Note that the Class and Name pointers are client-side addresses.
     */

    PBWL    pbwl;
    HWND    *phwnd;
    PWND    pwnd;
    WORD    atomClass = 0;
    LPCWSTR lpName;
    BOOL    fTryMessage = FALSE;

    if (ccxlpszClass != NULL) {
        /*
         * note that we do a version-less check here, then call FindClassAtom right away.
         */
        atomClass = FindClassAtom(ccxlpszClass);
        if (atomClass == 0) {
            return NULL;
        }
    }

    /*
     * Setup parent window
     */
    if (!pwndParent) {
        pwndParent = _GetDesktopWindow();
        /*
         * If we are starting from the root and no child window
         * was specified, then check the message window tree too
         * in case we don't find it on the desktop tree.
         */

        if (!pwndChild)
            fTryMessage = TRUE;
    }

TryAgain:
    /*
     * Setup first child
     */
    if (!pwndChild) {
        pwndChild = pwndParent->spwndChild;
    } else {
        if (pwndChild->spwndParent != pwndParent) {
            RIPMSG0(RIP_WARNING,
                 "FindWindowEx: Child window doesn't have proper parent");
            return NULL;
        }

        pwndChild = pwndChild->spwndNext;
    }

    /*
     * Generate a list of top level windows.
     */
    if ((pbwl = BuildHwndList(pwndChild, BWL_ENUMLIST, NULL)) == NULL) {
        return NULL;
    }

    /*
     * Set pwnd to NULL in case the window list is empty.
     */
    pwnd = NULL;

    try {
        for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

            /*
             * Validate this hwnd since we left the critsec earlier (below
             * in the loop we send a message!
             */
            if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                continue;

            /*
             * make sure this window is of the right type
             */
            if (dwType != FW_BOTH) {
                if (((dwType == FW_16BIT) && !(GETPTI(pwnd)->TIF_flags & TIF_16BIT)) ||
                    ((dwType == FW_32BIT) && (GETPTI(pwnd)->TIF_flags & TIF_16BIT)))
                    continue;
            }

            /*
             * If the class is specified and doesn't match, skip this window
             * note that we do a version-less check here, use pcls->atomNVClassName
             */
            if (!atomClass || (atomClass == pwnd->pcls->atomNVClassName)) {
                if (!ccxlpszName)
                    break;

                if (pwnd->strName.Length) {
                    lpName = pwnd->strName.Buffer;
                } else {
                    lpName = szNull;
                }

                /*
                 * Is the text the same? If so, return with this window!
                 */
                if (_wcsicmp(ccxlpszName, lpName) == 0)
                    break;
            }

            /*
             * The window did not match.
             */
            pwnd = NULL;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        pwnd = NULL;
    }

    FreeHwndList(pbwl);

    if (!pwnd && fTryMessage) {
        fTryMessage = FALSE;
        pwndParent = _GetMessageWindow();
        pwndChild = NULL;
        goto TryAgain;
    }

    return ((*phwnd == (HWND)1) ? NULL : pwnd);
}

/***************************************************************************\
* UpdateCheckpoint
*
* Checkpoints the current window size/position/state and returns a pointer
* to the structure.
*
* History:
\***************************************************************************/

PCHECKPOINT UpdateCheckpoint(
    PWND pwnd)
{
    RECT rc;

    GetRect(pwnd, &rc, GRECT_WINDOW | GRECT_PARENTCOORDS);
    return CkptRestore(pwnd, &rc);
}

/***************************************************************************\
* GetWindowPlacement
*
* History:
* 02-Mar-1992 MikeKe    From Win 3.1
\***************************************************************************/

BOOL _GetWindowPlacement(
    PWND             pwnd,
    PWINDOWPLACEMENT pwp)
{
    CHECKPOINT * pcp;

    /*
     * this will set the normal or the minimize point in the checkpoint,
     * so that all elements will be up to date.
     */
    pcp = UpdateCheckpoint(pwnd);

    if (!pcp)
        return FALSE;

    if (TestWF(pwnd, WFMINIMIZED)) {
        pwp->showCmd = SW_SHOWMINIMIZED;
    } else if (TestWF(pwnd, WFMAXIMIZED)) {
        pwp->showCmd = SW_SHOWMAXIMIZED;
    } else {
        pwp->showCmd = SW_SHOWNORMAL;
    }

    CopyRect(&pwp->rcNormalPosition, &pcp->rcNormal);

    if (pcp->fMinInitialized) {
        pwp->ptMinPosition = pcp->ptMin;
    } else {
        pwp->ptMinPosition.x = pwp->ptMinPosition.y = -1;
    }

    /*
     * We never ever save the position of "normal" maximized windows.  Other
     * wise, when the size border changes dimensions, the max pos would be
     * invalid, and you would never be able to reset it.
     */
    if (pcp->fMaxInitialized && !TestWF(pwnd, WFREALLYMAXIMIZABLE)) {
        pwp->ptMaxPosition = pcp->ptMax;
    } else {
        pwp->ptMaxPosition.x = pwp->ptMaxPosition.y = -1;
    }

    if ((pwnd->spwndParent == PWNDDESKTOP(pwnd)) &&
            !TestWF(pwnd, WEFTOOLWINDOW)) {

        PMONITOR    pMonitor;

        pMonitor = _MonitorFromRect(&pwp->rcNormalPosition, MONITOR_DEFAULTTOPRIMARY);

        /*
         * Convert min, normal positions to be relative to the working area.
         * The max pos already is (always is saved that way).
         *
         * working area, except for maximized position, which is always
         * working area relative.
         */
        if (pcp->fMinInitialized) {
            pwp->ptMinPosition.x -= (pMonitor->rcWork.left - pMonitor->rcMonitor.left);
            pwp->ptMinPosition.y -= (pMonitor->rcWork.top - pMonitor->rcMonitor.top);
        }

        OffsetRect(&pwp->rcNormalPosition,
            pMonitor->rcMonitor.left - pMonitor->rcWork.left,
            pMonitor->rcMonitor.top - pMonitor->rcWork.top);
    }

    pwp->flags = 0;

    /*
     * B#3276
     * Don't allow WPF_SETMINPOSITION on top-level windows.
     */
    if (TestwndChild(pwnd) && pcp->fDragged)
        pwp->flags |= WPF_SETMINPOSITION;

    if (pcp->fWasMaximizedBeforeMinimized || TestWF(pwnd, WFMAXIMIZED))
        pwp->flags |= WPF_RESTORETOMAXIMIZED;

    pwp->length = sizeof(WINDOWPLACEMENT);

    return TRUE;
}

/***************************************************************************\
* CheckPlacementBounds
*
* History:
* 02-Mar-1992 MikeKe    From Win 3.1
\***************************************************************************/

VOID CheckPlacementBounds(
    LPRECT      lprc,
    LPPOINT     ptMin,
    LPPOINT     ptMax,
    PMONITOR    pMonitor)
{
    int xIcon;
    int yIcon;
    int sTop;
    int sBottom;
    int sLeft;
    int sRight;

    /*
     * Check Normal Window Placement
     */

    /*
     * Possible values for these sign variables are :
     * -1 : less than the minimum for that dimension
     *  0 : within the range for that dimension
     *  1 : more than the maximum for that dimension
     */
    sTop = (lprc->top < pMonitor->rcWork.top) ? -1 :
        ((lprc->top > pMonitor->rcWork.bottom) ? 1 : 0);

    sBottom = (lprc->bottom < pMonitor->rcWork.top) ? -1 :
        ((lprc->bottom > pMonitor->rcWork.bottom) ? 1 : 0);

    sLeft = (lprc->left < pMonitor->rcWork.left) ? -1 :
        ((lprc->left > pMonitor->rcWork.right) ? 1 : 0);

    sRight = (lprc->right < pMonitor->rcWork.left) ? -1 :
        ((lprc->right > pMonitor->rcWork.right) ? 1 : 0);

    if ((sTop * sBottom > 0) || (sLeft * sRight > 0)) {

        /*
         * Window is TOTALLY outside monitor bounds.  The resolution and/or
         * configuration of monitors probably changed since the last time
         * we ran this app.
         *
         * Slide it FULLY onto the monitor at the nearest position.
         */
        int size;

        if (sTop < 0) {
            lprc->bottom -= lprc->top;
            lprc->top     = pMonitor->rcWork.top;
        } else if (sBottom > 0) {
            size = lprc->bottom - lprc->top;
            lprc->top    = max(pMonitor->rcWork.bottom - size, pMonitor->rcWork.top);
            lprc->bottom = lprc->top + size;
        }

        if (sLeft < 0) {
            lprc->right -= lprc->left;
            lprc->left   = pMonitor->rcWork.left;
        } else if (sRight > 0) {
            size = lprc->right - lprc->left;
            lprc->left  = max(pMonitor->rcWork.right - size, pMonitor->rcWork.left);
            lprc->right = lprc->left + size;
        }
    }

    /*
     * Check Iconic Window Placement
     */
    if (ptMin->x != -1) {

        xIcon = SYSMET(CXMINSPACING);
        yIcon = SYSMET(CYMINSPACING);

        sTop = (ptMin->y < pMonitor->rcWork.top) ? -1 :
            ((ptMin->y > pMonitor->rcWork.bottom) ? 1 : 0);

        sBottom = (ptMin->y + yIcon < pMonitor->rcWork.top) ? -1 :
            ((ptMin->y + yIcon > pMonitor->rcWork.bottom) ? 1 : 0);

        sLeft = (ptMin->x < pMonitor->rcWork.left) ? -1 :
            ((ptMin->x > pMonitor->rcWork.right) ? 1 : 0);

        sRight = (ptMin->x + xIcon < pMonitor->rcWork.left) ? -1 :
            ((ptMin->x + xIcon > pMonitor->rcWork.right) ? 1 : 0);

        /*
         * Icon is TOTALLY outside monitor bounds; repark it.
         */
        if ((sTop * sBottom > 0) || (sLeft * sRight > 0))
            ptMin->x = ptMin->y = -1;
    }

    /*
     * Check Maximized Window Placement
     */
    if (ptMax->x != -1 &&
        (ptMax->x + pMonitor->rcWork.left >= pMonitor->rcWork.right ||
         ptMax->y + pMonitor->rcWork.top >= pMonitor->rcWork.bottom)) {

        /*
         * window is TOTALLY below beyond maximum dimensions; zero the
         * position so that the window will at least be clipped to the
         * monitor.
         */
        ptMax->x = 0;
        ptMax->y = 0;
    }
}

/***************************************************************************\
* WPUpdateCheckPointSettings
*
* History:
* 02/23/98  GerardoB    Extracted from xxxSetWindowPlacement
\***************************************************************************/
void WPUpdateCheckPointSettings (PWND pwnd, UINT uWPFlags)
{
    CHECKPOINT *    pcp;

    UserAssert(TestWF(pwnd, WFMINIMIZED));
    if (pcp = UpdateCheckpoint(pwnd)) {

        /*
         * Save settings in the checkpoint struct
         */
        if (uWPFlags & WPF_SETMINPOSITION)
            pcp->fDragged = TRUE;

        if (uWPFlags & WPF_RESTORETOMAXIMIZED) {
            pcp->fWasMaximizedBeforeMinimized = TRUE;
        } else {
            pcp->fWasMaximizedBeforeMinimized = FALSE;
        }
    }
}
/***************************************************************************\
* xxxSetWindowPlacement
*
* History:
* 02-Mar-1992 MikeKe    From Win 3.1
\***************************************************************************/

BOOL xxxSetWindowPlacement(
    PWND             pwnd,
    PWINDOWPLACEMENT pwp)
{
    CHECKPOINT *    pcp;
    PMONITOR        pMonitor;
    RECT            rc;
    POINT           ptMin;
    POINT           ptMax;
    BOOL            fMin;
    BOOL            fMax;
    UINT            uSWPFlags;
    BOOL            fRealAsync;

    CheckLock(pwnd);

    CopyRect(&rc, &pwp->rcNormalPosition);
    if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
        pMonitor = _MonitorFromRect(&rc, MONITOR_DEFAULTTOPRIMARY);
    }

    ptMin = pwp->ptMinPosition;
    fMin  = ((ptMin.x != -1) && (ptMin.y != -1));

    ptMax = pwp->ptMaxPosition;
    fMax  = ((ptMax.x != -1) && (ptMax.y != -1));

    /*
     * Convert back to working rectangle coordinates
     */
    if (    pwnd->spwndParent == PWNDDESKTOP(pwnd) &&
            !TestWF(pwnd, WEFTOOLWINDOW)) {

        OffsetRect(
                &rc,
                pMonitor->rcWork.left - pMonitor->rcMonitor.left,
                pMonitor->rcWork.top - pMonitor->rcMonitor.top);

        if (fMin) {
            ptMin.x += pMonitor->rcWork.left - pMonitor->rcMonitor.left;
            ptMin.y += pMonitor->rcWork.top - pMonitor->rcMonitor.top;
        }

        CheckPlacementBounds(&rc, &ptMin, &ptMax, pMonitor);
    }

    if (pcp = UpdateCheckpoint(pwnd)) {

        /*
         * Save settings in the checkpoint struct
         */
        CopyRect(&pcp->rcNormal, &rc);

        pcp->ptMin                        = ptMin;
        pcp->fMinInitialized              = fMin;
        pcp->fDragged                     = (pwp->flags & WPF_SETMINPOSITION) ?
                                                TRUE : FALSE;
        pcp->ptMax                        = ptMax;
        pcp->fMaxInitialized              = fMax;
        pcp->fWasMaximizedBeforeMinimized = FALSE;
    }

    /*
     * WPF_ASYNCWINDOWPLACEMENT new for NT5.
     */
    uSWPFlags = SWP_NOZORDER | SWP_NOACTIVATE
                | ((pwp->flags & WPF_ASYNCWINDOWPLACEMENT) ? SWP_ASYNCWINDOWPOS : 0);

    if (TestWF(pwnd, WFMINIMIZED)) {

        if ((!pcp || pcp->fDragged) && fMin) {
            xxxSetWindowPos(pwnd,
                            PWND_TOP,
                            ptMin.x,
                            ptMin.y,
                            0,
                            0,
                            SWP_NOSIZE | uSWPFlags);
        }

    } else if (TestWF(pwnd, WFMAXIMIZED)) {

        if (pcp != NULL) {
            if (TestWF(pwnd, WFREALLYMAXIMIZABLE))
                pcp->fMaxInitialized = FALSE;

            if (pcp->fMaxInitialized) {
                if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
                    ptMax.x += pMonitor->rcWork.left;
                    ptMax.y += pMonitor->rcWork.top;
                }

                xxxSetWindowPos(pwnd,
                                PWND_TOP,
                                ptMax.x,
                                ptMax.y,
                                0,
                                0,
                                SWP_NOSIZE | uSWPFlags);
            }
        }


    } else {

        xxxSetWindowPos(pwnd,
                        PWND_TOP,
                        rc.left,
                        rc.top,
                        rc.right - rc.left,
                        rc.bottom - rc.top,
                        uSWPFlags);
    }
    /*
     * xxxSetWindowPos is only assync when the window's thread is on a
     *  different queue than the current thread's. See AsyncWindowPos.
     */
    fRealAsync = (pwp->flags & WPF_ASYNCWINDOWPLACEMENT)
                    && (GETPTI(pwnd)->pq != PtiCurrent()->pq);

    if (fRealAsync) {
        _ShowWindowAsync(pwnd, pwp->showCmd, pwp->flags);
    } else {
        xxxShowWindow(pwnd, MAKELONG(pwp->showCmd, TEST_PUDF(PUDF_ANIMATE)));
    }

    if (TestWF(pwnd, WFMINIMIZED) && !fRealAsync) {
        WPUpdateCheckPointSettings(pwnd, pwp->flags);
    }

    return TRUE;
}

/***************************************************************************\
* xxxSetInternalWindowPos
*
* Sets a window to the size, position and state it was most recently
* in.  Side effect (possibly bug): shows and activates the window as well.
*
* History:
* 28-Mar-1991 DavidPe   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxSetInternalWindowPos(
    PWND    pwnd,
    UINT    cmdShow,
    LPRECT  lprcWin,
    LPPOINT lpptMin)
{
    CHECKPOINT *    pcp;
    PMONITOR        pMonitor;

    CheckLock(pwnd);

    if ((pcp = UpdateCheckpoint(pwnd)) == NULL) {
        return FALSE;
    }

    if (lprcWin) {

        pcp->rcNormal = *lprcWin;
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            pMonitor = _MonitorFromRect(lprcWin, MONITOR_DEFAULTTOPRIMARY);
            OffsetRect(
                    &pcp->rcNormal,
                    pMonitor->rcWork.left - pMonitor->rcMonitor.left,
                    pMonitor->rcWork.top - pMonitor->rcMonitor.top);
        }
    }

    if (lpptMin && (lpptMin->x != -1)) {

        pcp->ptMin = *lpptMin;
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            pMonitor = _MonitorFromRect(&pcp->rcNormal, MONITOR_DEFAULTTOPRIMARY);
            pcp->ptMin.x += pMonitor->rcWork.left - pMonitor->rcMonitor.left;
            pcp->ptMin.y += pMonitor->rcWork.top - pMonitor->rcMonitor.top;
        }

        pcp->fDragged = TRUE;
        pcp->fMinInitialized = TRUE;

    } else {
        pcp->fMinInitialized = FALSE;
        pcp->fDragged = FALSE;
    }

    if (TestWF(pwnd, WFMINIMIZED)) {

        /*
         * need to move the icon
         */
        if (pcp->fMinInitialized) {
            xxxSetWindowPos(pwnd,
                            PWND_TOP,
                            pcp->ptMin.x,
                            pcp->ptMin.y,
                            0,
                            0,
                            SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
        }

    } else if (!TestWF(pwnd, WFMAXIMIZED) && lprcWin) {
        /*
         * need to set the size and the position
         */
        xxxSetWindowPos(pwnd,
                        NULL,
                        lprcWin->left,
                        lprcWin->top,
                        lprcWin->right - lprcWin->left,
                        lprcWin->bottom - lprcWin->top,
                        SWP_NOZORDER);
    }

    xxxShowWindow(pwnd, MAKELONG(cmdShow, TEST_PUDF(PUDF_ANIMATE)));

    return TRUE;
}

/***************************************************************************\
* _GetDesktopWindow (API)
*
* History:
* 07-Nov-1990 DarrinM   Implemented.
\***************************************************************************/

PWND _GetDesktopWindow(VOID)
{
    PTHREADINFO  pti = PtiCurrent();
    PDESKTOPINFO pdi;

    if (pti == NULL)
        return NULL;

    pdi = pti->pDeskInfo;

    return pdi == NULL ? NULL : pdi->spwnd;
}

/***************************************************************************\
* _GetDesktopWindow (API)
*
* History:
* 07-Nov-1990 DarrinM   Implemented.
\***************************************************************************/

PWND _GetMessageWindow(VOID)
{
    PTHREADINFO  pti = PtiCurrent();
    PDESKTOP pdi;

    if (pti == NULL)
        return NULL;

    pdi = pti->rpdesk;

    return pdi == NULL ? NULL : pdi->spwndMessage;
}

/**************************************************************************\
* TestWindowProcess
*
* History:
* 14-Nov-1994 JimA      Created.
\**************************************************************************/

BOOL TestWindowProcess(
    PWND pwnd)
{
    return (PpiCurrent() == GETPTI(pwnd)->ppi);
}

/***************************************************************************\
* ValidateDepth
*
* The function conveniently simulates recursion by utilizing the fact
* that from any sibling in the Next chain we can correctly get to the
* parent window and that two siblings in the Next chain cannot have
* different parents.
*
* 12-Mar-1997   vadimg      created
\***************************************************************************/

#define NESTED_WINDOW_LIMIT 100

BOOL ValidateParentDepth(PWND pwnd, PWND pwndParent)
{
    UINT cDepth = 1, cDepthMax;
    PWND pwndStop;

    /*
     * Calculate the depth of the parent chain.
     */
    while (pwndParent != NULL) {
        pwndParent = pwndParent->spwndParent;
        cDepth++;
    }

    cDepthMax = cDepth;

    /*
     * When pwnd is NULL, it means that we want to add one more
     * level to the existing depth of pwndParent.
     */
    if (pwnd == NULL || pwnd->spwndChild == NULL) {
        goto Exit;
    } else {
        pwndStop = pwnd->spwndParent;
    }

Restart:
    if (pwnd->spwndChild != NULL) {
        pwnd = pwnd->spwndChild;
        cDepth++;
    } else if (pwnd->spwndNext != NULL) {
        pwnd = pwnd->spwndNext;
    } else {
        if (cDepth > cDepthMax) {
            cDepthMax = cDepth;
        }

        /*
         * Find a parent with siblings and recurse on them. Terminate
         * when we reach the parent of the original pwnd.
         */
        do {
            pwnd = pwnd->spwndParent;
            cDepth--;

            if (pwnd == pwndStop)
                goto Exit;

        } while (pwnd->spwndNext == NULL);

        pwnd = pwnd->spwndNext;
    }
    goto Restart;

Exit:
    return (cDepthMax <= NESTED_WINDOW_LIMIT);
}

/***************************************************************************\
* ValidateOwnerDepth
*
* pwndOwner is the new intended owner, we basically add 1 to the current
* nested owner chain depth. We assume that the actual window does not have
* any ownees. In reality, it can through SetWindowLong, but finding the
* maximum depth of the ownee chain is really tricky - just look in swp.c.
*
* 12-Mar-1997   vadimg      created
\***************************************************************************/

BOOL ValidateOwnerDepth(PWND pwnd, PWND pwndOwner)
{
    UINT cDepth = 1;

    while (pwndOwner != NULL) {

        /*
         * Do not allow loops in the owner chain.
         */
        if (pwndOwner == pwnd) {
            return FALSE;
        }

        pwndOwner = pwndOwner->spwndOwner;
        cDepth++;
    }

    return (cDepth <= NESTED_WINDOW_LIMIT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\winprop.c ===
/****************************** Module Header ******************************\
* Module Name: winprop.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains routines having to do with window properties.
*
* History:
* 11-13-90 DarrinM      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* InternalSetProp
*
* SetProp searches the linked-list of window property structures for the
* specified key.  If found, the existing property structure is changed to
* hold the new hData handle.  If no property is found with the specified key
* a new property structure is created and initialized.
*
* Since property keys are retained as atoms, we convert the incoming pszKey
* to an atom before lookup or storage.  pszKey might actually be an atom
* already, so we keep a flag, PROPF_STRING, so we know whether the atom was
* created by the system or whether it was passed in.  This way we know
* whether we should destroy it when the property is destroyed.
*
* Several property values are for User's private use.  These properties are
* denoted with the flag PROPF_INTERNAL.  Depending on the fInternal flag,
* either internal (User) or external (application) properties are set/get/
* removed/enumerated, etc.
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

BOOL InternalSetProp(
    PWND pwnd,
    LPWSTR pszKey,
    HANDLE hData,
    DWORD dwFlags)
{
    PPROP pprop;

    if (pszKey == NULL) {
        RIPERR0(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"pszKey\" (NULL) to InternalSetProp");

        return FALSE;
    }

    /*
     * If no property list exists for this window, create one.
     */
    pprop = _FindProp(pwnd, pszKey, dwFlags & PROPF_INTERNAL);
    if (pprop == NULL) {

        /*
         * pszKey must be an atom within the server.
         */
        UserAssert(!IS_PTR(pszKey));

        /*
         * CreateProp allocates the property and links it into the window's
         * property list.
         */
        pprop = CreateProp(pwnd);
        if (pprop == NULL)
            return FALSE;

        pprop->atomKey = PTR_TO_ID(pszKey);
        pprop->fs = (WORD)dwFlags;
    }

    pprop->hData = hData;

    return TRUE;
}


/***************************************************************************\
* InternalRemoveProp
*
* Remove the specified property from the specified window's property list.
* The property's hData handle is returned to the caller who can then free
* it or whatever.  NOTE: This also applies to internal properties as well --
* InternalRemoveProp will free the property structure and atom (if created
* by User) but will not free the hData itself.
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

HANDLE InternalRemoveProp(
    PWND pwnd,
    LPWSTR pszKey,
    BOOL fInternal)
{
    PPROP pprop;
    PPROP ppropLast;
    HANDLE hT;

    /*
     * Find the property to be removed.
     */
    pprop = _FindProp(pwnd, pszKey, fInternal);
    if (pprop == NULL)
        return NULL;

    /*
     * Remember what it was pointing at.
     */
    hT = pprop->hData;

    /*
     * Move the property at the end of the list into this slot.
     */
    pwnd->ppropList->iFirstFree--;
    ppropLast = &pwnd->ppropList->aprop[pwnd->ppropList->iFirstFree];
    *pprop = *ppropLast;
    RtlZeroMemory(ppropLast, sizeof(*ppropLast));

    return hT;
}


/***************************************************************************\
* _BuildPropList
*
* This is a unique client/server routine - it builds a list of Props and
* returns it to the client.  Unique since the client doesn't know how
* big the list is ahead of time.
*
* 29-Jan-1992 JohnC    Created.
\***************************************************************************/

NTSTATUS _BuildPropList(
    PWND pwnd,
    PROPSET aPropSet[],
    UINT cPropMax,
    PUINT pcPropNeeded)
{
    UINT i;
    PPROPLIST ppropList;
    PPROP pProp;
    DWORD iRetCnt = 0;            // The number of Props returned
    DWORD iProp = 0;
    PPROPSET pPropSetLast = (aPropSet + cPropMax - 1);
    NTSTATUS Status;

    /*
     * If the Window does not have a property list then we're done
     */
    ppropList = pwnd->ppropList;
    if (ppropList == NULL) {
        *pcPropNeeded = 0;
        return STATUS_SUCCESS;
    }

    /*
     * For each element in the property list enumerate it.
     * (only if it is not internal!)
     */
    Status = STATUS_SUCCESS;
    pProp = ppropList->aprop;
    for (i = ppropList->iFirstFree; i > 0; i--) {

        /*
         * if we run out of space in shared memory return
         * STATUS_BUFFER_TOO_SMALL
         */
        if (&aPropSet[iProp] > pPropSetLast) {

            /*
             * Reset to the beginning of the output
             * buffer so we can continue and compute
             * the needed space.
             */
            iProp = 0;
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        if (!(pProp->fs & PROPF_INTERNAL)) {
            aPropSet[iProp].hData = pProp->hData;
            aPropSet[iProp].atom = pProp->atomKey;
            iProp++;
            iRetCnt++;
        }
        pProp++;
    }

    /*
     * Return the number of PROPLISTs given back to the client
     */

    *pcPropNeeded = iRetCnt;

    return Status;
}


/***************************************************************************\
* CreateProp
*
* Create a property structure and link it at the head of the specified
* window's property list.
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

PPROP CreateProp(
    PWND pwnd)
{
    PPROPLIST ppropList;
    PPROP pprop;

    if (pwnd->ppropList == NULL) {
        pwnd->ppropList = (PPROPLIST)DesktopAlloc(pwnd->head.rpdesk,
                                                  sizeof(PROPLIST),
                                                  DTAG_PROPLIST);
        if (pwnd->ppropList == NULL) {
            return NULL;
        }
        pwnd->ppropList->cEntries = 1;
    } else if (pwnd->ppropList->iFirstFree == pwnd->ppropList->cEntries) {
        ppropList = (PPROPLIST)DesktopAlloc(pwnd->head.rpdesk,
                                            sizeof(PROPLIST) + pwnd->ppropList->cEntries * sizeof(PROP),
                                            DTAG_PROPLIST);
        if (ppropList == NULL) {
            return NULL;
        }
        RtlCopyMemory(ppropList, pwnd->ppropList, sizeof(PROPLIST) + (pwnd->ppropList->cEntries - 1) * sizeof(PROP));
        DesktopFree(pwnd->head.rpdesk, pwnd->ppropList);
        pwnd->ppropList = ppropList;
        pwnd->ppropList->cEntries++;
    }
    pprop = &pwnd->ppropList->aprop[pwnd->ppropList->iFirstFree];
    pwnd->ppropList->iFirstFree++;

    return pprop;
}


/***************************************************************************\
* DeleteProperties
*
* When a window is destroyed we want to destroy all its accompanying
* properties.  DestroyProperties does this, including destroying any hData
* that was allocated by User for internal properties.  Any atoms created
* along with the properties are destroyed as well.  hData in application
* properties are not destroyed automatically; we assume the application
* is taking care of that itself (in its WM_DESTROY handler or similar).
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

void DeleteProperties(
    PWND pwnd)
{
    PPROP pprop;
    UINT i;

    UserAssert(pwnd->ppropList);

    /*
     * Loop through the whole list of properties on this window.
     */
    pprop = pwnd->ppropList->aprop;
    for (i = pwnd->ppropList->iFirstFree; i > 0; i--) {

        /*
         * Is this an internal property?  If so, free any data we allocated
         * for it.
         */
        if ((pprop->fs & PROPF_INTERNAL) && !(pprop->fs & PROPF_NOPOOL)) {
                UserFreePool(pprop->hData);
        }

        /*
         * Advance to the next property in the list.
         */
        pprop++;
    }

    /*
     * All properties gone, free the property list and clear out the
     * window's property list pointer.
     */
    DesktopFree(pwnd->head.rpdesk, pwnd->ppropList);
    pwnd->ppropList = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\winsta.c ===
/**************************** Module Header ********************************\
* Module Name: winsta.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Windowstation Routines
*
* History:
* 01-14-91 JimA         Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* InitTerminal
*
* Creates the desktop thread for a terminal and also the RIT for the
* IO terminal
*
* History:
* 27-10-97 CLupu        Created.
\***************************************************************************/
NTSTATUS xxxInitTerminal(
    PTERMINAL pTerm)
{
    NTSTATUS Status;
    PKEVENT pEventTermInit;
    HANDLE hEventInputReady, hEventTermInit;
    USER_API_MSG m;

    CheckCritIn();

    UserAssert(!(pTerm->dwTERMF_Flags & TERMF_INITIALIZED));

    if (pTerm->pEventInputReady != NULL) {

        /*
         * if we make it here it means that another thread is
         * executing xxxInitTerminal for the same terminal and it
         * left the critical section.
         */
        UserAssert(pTerm->pEventTermInit != NULL);

        /*
         * use a local variable so we can safely reset
         * pTerm->pEventTermInit when we're done with it
         */
        pEventTermInit = pTerm->pEventTermInit;

        ObReferenceObject(pEventTermInit);

        LeaveCrit();

        goto Wait;
    }

    /*
     * Create the input ready event. RIT and desktop thread will wait for it.
     * It will be set when the first desktop in this terminal will be created.
     */
    Status = ZwCreateEvent(
                     &hEventInputReady,
                     EVENT_ALL_ACCESS,
                     NULL,
                     NotificationEvent,
                     FALSE);

    if (!NT_SUCCESS(Status))
        return Status;

    Status = ObReferenceObjectByHandle(
                     hEventInputReady,
                     EVENT_ALL_ACCESS,
                     *ExEventObjectType,
                     KernelMode,
                     &pTerm->pEventInputReady, NULL);

    ZwClose(hEventInputReady);

    if (!NT_SUCCESS(Status))
        return Status;

    /*
     * Device and RIT initialization. Don't do it for
     * the system terminal.
     */
    if (!(pTerm->dwTERMF_Flags & TERMF_NOIO)) {
        if (!CreateTerminalInput(pTerm)) {
            ObDereferenceObject(pTerm->pEventInputReady);
            return STATUS_NO_MEMORY;
        }
    }

    /*
     * create an event to syncronize the terminal initialization
     */
    Status = ZwCreateEvent(
                     &hEventTermInit,
                     EVENT_ALL_ACCESS,
                     NULL,
                     NotificationEvent,
                     FALSE);

    if (!NT_SUCCESS(Status)) {
        ObDereferenceObject(pTerm->pEventInputReady);
        return Status;
    }

    Status = ObReferenceObjectByHandle(
                     hEventTermInit,
                     EVENT_ALL_ACCESS,
                     *ExEventObjectType,
                     KernelMode,
                     &pTerm->pEventTermInit, NULL);

    ZwClose(hEventTermInit);

    if (!NT_SUCCESS(Status)) {
        ObDereferenceObject(pTerm->pEventInputReady);
        return Status;
    }

    /*
     * use a local variable so we can safely reset
     * pTerm->pEventTermInit when we're done with it
     */
    pEventTermInit = pTerm->pEventTermInit;

    if (!InitCreateSystemThreadsMsg(&m, CST_DESKTOP, pTerm, 0, FALSE)) {
        ObDereferenceObject(pTerm->pEventInputReady);
        ObDereferenceObject(pEventTermInit);
        return STATUS_NO_MEMORY;
    }

    LeaveCrit();

    /*
     * Create the desktop thread.
     */
    if (ISCSRSS()) {
        /*
         * Windows bug: 452899
         * Since we are in CSRSS context use LpcRequestPort to send LPC_DATAGRAM message type,
         * Do not use LpcRequestWaitReplyPort because it will send LPC_REQUEST which will
         * fail (in server side).
         */
        RIPMSGF1(RIP_WARNING, "Desktop Thread for term=%p is being created within CSRSS context.", pTerm);
        Status = LpcRequestPort(CsrApiPort, (PPORT_MESSAGE)&m);
    } else {
        Status = LpcRequestWaitReplyPort(CsrApiPort, (PPORT_MESSAGE)&m, (PPORT_MESSAGE)&m);
    }

    if (!NT_SUCCESS(Status) || (!ISCSRSS() && !NT_SUCCESS(m.ReturnValue))) {
        EnterCrit();
        RIPMSGF1(RIP_WARNING, "Failed to create a desktop thread with 0x%x ... bailing out.", m.ReturnValue);
        ObDereferenceObject(pTerm->pEventInputReady);
        ObDereferenceObject(pEventTermInit);
        return STATUS_NO_MEMORY;
    }

Wait:
    KeWaitForSingleObject(pEventTermInit,
                          WrUserRequest,
                          KernelMode,
                          FALSE,
                          NULL);

    EnterCrit();

    /*
     * dereference the terminal init event. It will eventually
     * go away.
     */
    ObDereferenceObject(pEventTermInit);

    pTerm->pEventTermInit = NULL;

    if (pTerm->dwTERMF_Flags & TERMF_DTINITFAILED) {
        return STATUS_NO_MEMORY;
    }

    pTerm->dwTERMF_Flags |= TERMF_INITIALIZED;
    return STATUS_SUCCESS;
}

static CONST LPCWSTR lpszStdFormats[] = {
    L"StdExit",
    L"StdNewDocument",
    L"StdOpenDocument",
    L"StdEditDocument",
    L"StdNewfromTemplate",
    L"StdCloseDocument",
    L"StdShowItem",
    L"StdDoVerbItem",
    L"System",
    L"OLEsystem",
    L"StdDocumentName",
    L"Protocols",
    L"Topics",
    L"Formats",
    L"Status",
    L"EditEnvItems",
    L"True",
    L"False",
    L"Change",
    L"Save",
    L"Close",
    L"MSDraw"
};

NTSTATUS CreateGlobalAtomTable(
    PVOID* ppAtomTable)
{
    NTSTATUS Status;
    RTL_ATOM Atom;
    ULONG i;

    Status = RtlCreateAtomTable(0, ppAtomTable);
    if (!NT_SUCCESS(Status)) {
        RIPMSG0(RIP_WARNING, "Global atom table not created");
        return Status;
    }

    for (i = 0; i < ARRAY_SIZE(lpszStdFormats); i++) {
        Status = RtlAddAtomToAtomTable(*ppAtomTable,
                                       (PWSTR)lpszStdFormats[i],
                                       &Atom);
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING,
                    "RtlAddAtomToAtomTable failed to add atom %ws",
                    lpszStdFormats[i]);

            RtlDestroyAtomTable(*ppAtomTable);
            return Status;
        }

        RtlPinAtomInAtomTable(*ppAtomTable, Atom);
    }

    return Status;
}


/***************************************************************************\
* xxxCreateWindowStation
*
* Creates the specified windowstation and starts a logon thread for the
* station.
*
* History:
* 01-15-91 JimA         Created.
\***************************************************************************/
HWINSTA xxxCreateWindowStation(
    POBJECT_ATTRIBUTES  ObjectAttributes,
    KPROCESSOR_MODE     OwnershipMode,
    DWORD               dwDesiredAccess,
    HANDLE              hKbdLayoutFile,
    DWORD               offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    PCWSTR              pwszKLID,
    UINT                uKbdInputLocale)
{
    PWINDOWSTATION          pwinsta;
    PTHREADINFO             ptiCurrent;
    PDESKTOP                pdeskTemp;
    HDESK                   hdeskTemp;
    PSECURITY_DESCRIPTOR    psd;
    PSECURITY_DESCRIPTOR    psdCapture;
    PPROCESSINFO            ppiSave;
    NTSTATUS                Status;
    PACCESS_ALLOWED_ACE     paceList = NULL, pace;
    ULONG                   ulLength, ulLengthSid;
    HANDLE                  hEvent;
    HWINSTA                 hwinsta;
    DWORD                   dwDisableHooks;
    PTERMINAL               pTerm = NULL;
    PWND                    pwnd;
    WCHAR                   szBaseNamedObjectDirectory[MAX_SESSION_PATH];
    BOOL                    bMDWCreated = FALSE;

    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * Get the pointer to the security descriptor so we can
     * assign it to the new object later.
     */
    psdCapture = ObjectAttributes->SecurityDescriptor;

    /*
     * The first windowstation that gets created is Winsta0 and
     * it's the only interactive one.
     */
    if (grpWinStaList == NULL) {

        /*
         * Assert that winlogon is the first to call CreateWindowStation
         */
        UserAssert(PsGetCurrentProcessId() == gpidLogon);

        pTerm = &gTermIO;
    } else {
        pTerm = &gTermNOIO;

        UserAssert(grpWinStaList->rpwinstaNext == NULL ||
                   pTerm->dwTERMF_Flags & TERMF_NOIO);

        pTerm->dwTERMF_Flags |= TERMF_NOIO;
    }

    /*
     * Create the WindowStation object
     */
    Status = ObCreateObject(KernelMode, *ExWindowStationObjectType,
            ObjectAttributes, OwnershipMode, NULL, sizeof(WINDOWSTATION),
            0, 0, &pwinsta);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_WARNING, "Failed to create windowstation");
        return NULL;
    }

    /*
     * WindowStation object was created then reference gWinstaRunRef.
     * We have to dereference it at FreeWindowStation().
     * And wait for any live objects to get freed in Win32KDriverUnload().
     */
    if (!ExAcquireRundownProtection(&gWinstaRunRef)) {
        goto create_error;
    }

    /*
     * Initialize everything.
     */
    RtlZeroMemory(pwinsta, sizeof(WINDOWSTATION));

    /*
     * Store the session id of the session who created the windowstation
     */
    pwinsta->dwSessionId = gSessionId;

    pwinsta->pTerm = pTerm;

    /*
     * All the windowstations in the system terminal are non-interactive.
     */
    if (pTerm->dwTERMF_Flags & TERMF_NOIO) {
        pwinsta->dwWSF_Flags = WSF_NOIO;
    }

    /*
     * Create the global atom table and populate it with the default OLE atoms
     * Pin each atom so they can't be deleted by bogus applications like Winword
     */
    Status = CreateGlobalAtomTable(&pwinsta->pGlobalAtomTable);
    if (!NT_SUCCESS(Status)) {
        UserAssert(pwinsta->pGlobalAtomTable == NULL);
        RIPNTERR0(Status, RIP_WARNING, "CreateGlobalAtomTable failed");
        goto create_error;
    }

    /*
     * create the desktop thread
     * and the RIT (only for the IO terminal)
     */
    if (!(pTerm->dwTERMF_Flags & TERMF_INITIALIZED)) {

        Status = xxxInitTerminal(pTerm);

        if (!NT_SUCCESS(Status)) {
            RIPNTERR0(Status, RIP_WARNING, "xxxInitTerminal failed");
            goto create_error;
        }
    }

    if (!(pwinsta->dwWSF_Flags & WSF_NOIO)) {
        if (!xxxInitWindowStation()) {
            RIPNTERR0(STATUS_NO_MEMORY, RIP_WARNING, "xxxInitWindowStation failed");
            goto create_error;
        }
    }

    /*
     * Create only one desktop owner window per terminal.
     */
    if (pTerm->spwndDesktopOwner == NULL) {

        /*
         * Switch ppi values so window will be created using the
         * system's desktop window class.
         */
        ptiCurrent = PtiCurrent();
        ppiSave = ptiCurrent->ppi;
        ptiCurrent->ppi = pTerm->ptiDesktop->ppi;

#ifndef LAZY_CLASS_INIT
        UserAssert(pTerm->ptiDesktop->ppi->W32PF_Flags & W32PF_CLASSESREGISTERED);
#endif

        pdeskTemp = ptiCurrent->rpdesk;            /* save current desktop */
        hdeskTemp = ptiCurrent->hdesk;
        if (pdeskTemp) {
            ObReferenceObject(pdeskTemp);
            LogDesktop(pdeskTemp, LD_REF_FN_CREATEWINDOWSTATION, TRUE, (ULONG_PTR)PtiCurrent());
        }

        /*
         * The following code is not supposed to leave the critical section because
         * CreateWindowStation is an API so the current thread can be on any state
         *  setting its pdesk to NULL it's kind of bogus
         */
        DeferWinEventNotify();
        BEGINATOMICCHECK();
        if (zzzSetDesktop(ptiCurrent, NULL, NULL) == FALSE) {
            Status = STATUS_NO_MEMORY;
            EXITATOMICCHECK();
            zzzEndDeferWinEventNotify();
            /*
             * Restore caller's ppi
             */
            ptiCurrent->ppi = ppiSave;

            goto create_error;
        }


        /*
         * HACK HACK HACK!!! (adams) In order to create the desktop window
         * with the correct desktop, we set the desktop of the current thread
         * to the new desktop. But in so doing we allow hooks on the current
         * thread to also hook this new desktop. This is bad, because we don't
         * want the desktop window to be hooked while it is created. So we
         * temporarily disable hooks of the current thread and desktop, and
         * reenable them after switching back to the original desktop.
         */

        dwDisableHooks = ptiCurrent->TIF_flags & TIF_DISABLEHOOKS;
        ptiCurrent->TIF_flags |= TIF_DISABLEHOOKS;

        /*
         * Create the desktop owner window
         *
         * CONSIDER (adams): Do we want to limit the desktop size so that the
         * width and height of a rect will fit in 16bit coordinates?
         *
         *         SHRT_MIN / 2, SHRT_MIN / 2, SHRT_MAX, SHRT_MAX,
         *
         * Or do we want to limit it so just any point has 16bit coordinates?
         *
         *         -SHRT_MIN, -SHRT_MIN, SHRT_MAX * 2, SHRT_MAX * 2
         */
        pwnd =  xxxNVCreateWindowEx(0,
                                    (PLARGE_STRING)DESKTOPCLASS,
                                    NULL,
                                    WS_POPUP | WS_CLIPCHILDREN,
                                    SHRT_MIN / 2,
                                    SHRT_MIN / 2,
                                    SHRT_MAX,
                                    SHRT_MAX,
                                    NULL,
                                    NULL,
                                    hModuleWin,
                                    NULL,
                                    VER31);
        if (pwnd == NULL) {
            RIPMSGF0(RIP_WARNING, "Failed to create mother desktop window");
            Status = STATUS_NO_MEMORY;
            EXITATOMICCHECK();
            zzzEndDeferWinEventNotify();
            /*
             * Restore caller's ppi
             */
            ptiCurrent->ppi = ppiSave;

            /*
             * Restore the previous desktop
             */
            zzzSetDesktop(ptiCurrent, pdeskTemp, hdeskTemp);

            goto create_error;
        }

        /*
         * Mark this handle entry that is allocated out of pool
         */
        {
            PHE phe;

            UserAssert(ptiCurrent->rpdesk == NULL);

            phe = HMPheFromObject(pwnd);
            phe->bFlags |= HANDLEF_POOL;
        }

        Lock(&(pTerm->spwndDesktopOwner), pwnd);
        pTerm->dwTERMF_Flags |= TERMF_MOTHERWND_CREATED;

        UserAssert(ptiCurrent->TIF_flags & TIF_DISABLEHOOKS);
        ptiCurrent->TIF_flags = (ptiCurrent->TIF_flags & ~TIF_DISABLEHOOKS) | dwDisableHooks;

        SetVisible(pTerm->spwndDesktopOwner, SV_SET);
        HMChangeOwnerThread(pTerm->spwndDesktopOwner, pTerm->ptiDesktop);
        bMDWCreated = TRUE;

        /*
         * Restore caller's ppi
         */
        ptiCurrent->ppi = ppiSave;

        /*
         * Restore the previous desktop
         */
        if (zzzSetDesktop(ptiCurrent, pdeskTemp, hdeskTemp) == FALSE) {
            Status = STATUS_NO_MEMORY;
            EXITATOMICCHECK();
            zzzEndDeferWinEventNotify();

            goto create_error;
        }

        ENDATOMICCHECK();
        zzzEndDeferWinEventNotify();

        if (pdeskTemp) {
            LogDesktop(pdeskTemp, LD_DEREF_FN_CREATEWINDOWSTATION, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdeskTemp);
        }
    }

    /*
     * If this is the visible windowstation, assign it to
     * the server and create the desktop switch notification
     * event.
     */
    if (!(pwinsta->dwWSF_Flags & WSF_NOIO)) {
        UNICODE_STRING strName;
        HANDLE hRootDir;
        OBJECT_ATTRIBUTES obja;

        /*
         * Create desktop switch notification event.
         */
        ulLengthSid = RtlLengthSid(SeExports->SeWorldSid);
        ulLength = ulLengthSid + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);

        /*
         * Allocate the ACE list
         */
        paceList = (PACCESS_ALLOWED_ACE)UserAllocPoolWithQuota(ulLength, TAG_SECURITY);

        if (paceList == NULL) {
            Status = STATUS_NO_MEMORY;
            goto create_error;
        }

        /*
         * Initialize ACE 0
         */
        pace = paceList;
        pace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
        pace->Header.AceSize = (USHORT)ulLength;
        pace->Header.AceFlags = 0;
        pace->Mask = SYNCHRONIZE;
        RtlCopySid(ulLengthSid, &pace->SidStart, SeExports->SeWorldSid);

        /*
         * Create the SD
         */
        psd = CreateSecurityDescriptor(paceList, ulLength, FALSE);

        UserFreePool(paceList);

        if (psd == NULL) {
            Status = STATUS_NO_MEMORY;
            goto create_error;
        }

        /*
         * Create the named event.
         */
        UserAssert(ghEventSwitchDesktop == NULL);

        if (gbRemoteSession) {
            swprintf(szBaseNamedObjectDirectory, L"\\Sessions\\%ld\\BaseNamedObjects",
                     gSessionId);
            RtlInitUnicodeString(&strName, szBaseNamedObjectDirectory);
        } else {
            RtlInitUnicodeString(&strName, L"\\BaseNamedObjects");
        }

        InitializeObjectAttributes(&obja,
                                   &strName,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL);
        Status = ZwOpenDirectoryObject(&hRootDir,
                                       DIRECTORY_ALL_ACCESS &
                                           ~(DELETE | WRITE_DAC | WRITE_OWNER),
                                       &obja);
        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&strName, L"WinSta0_DesktopSwitch");
            InitializeObjectAttributes(&obja,
                                       &strName,
                                       OBJ_OPENIF | OBJ_KERNEL_HANDLE,
                                       hRootDir,
                                       psd);
            Status = ZwCreateEvent(&hEvent, EVENT_ALL_ACCESS, &obja,
                    NotificationEvent, FALSE);
            ZwClose(hRootDir);

            if (NT_SUCCESS(Status)) {
                Status = ObReferenceObjectByHandle(hEvent, EVENT_ALL_ACCESS, *ExEventObjectType,
                        KernelMode, &gpEventSwitchDesktop, NULL);
                if (NT_SUCCESS(Status)) {

                    /*
                     * Attach to the system process and create a handle to the
                     * object.  This will ensure that the object name is retained
                     * when hEvent is closed.  This is simpler than creating a
                     * permanent object, which takes the
                     * SeCreatePermanentPrivilege.
                     */
                    KeAttachProcess(PsGetProcessPcb(gpepCSRSS));

                    Status = ObOpenObjectByPointer(
                            gpEventSwitchDesktop,
                            0,
                            NULL,
                            EVENT_ALL_ACCESS,
                            NULL,
                            KernelMode,
                            &ghEventSwitchDesktop);
                    KeDetachProcess();
                }
                ZwClose(hEvent);
            }
        }

        if (!NT_SUCCESS(Status)) {
            goto create_error;
        }

        UserFreePool(psd);
    }

    /*
     * Create a handle to the windowstation.
     */
    Status = ObInsertObject(pwinsta, NULL, dwDesiredAccess, 1,
            &pwinsta, &hwinsta);

    if (Status == STATUS_OBJECT_NAME_EXISTS) {

        /*
         * The windowstation already exists, so deref and leave.
         */
        ObDereferenceObject(pwinsta);
    } else if (NT_SUCCESS(Status)) {
        PSECURITY_DESCRIPTOR psdParent = NULL, psdNew;
        SECURITY_SUBJECT_CONTEXT Context;
        POBJECT_DIRECTORY pParentDirectory;
        SECURITY_INFORMATION siNew;
        BOOLEAN MemoryAllocated = FALSE;

        /*
         * Create security descriptor for the windowstation.
         * ObInsertObject only supports non-container
         * objects, so we must assign our own security descriptor.
         */
        SeCaptureSubjectContext(&Context);
        SeLockSubjectContext(&Context);

        pParentDirectory = OBJECT_HEADER_TO_NAME_INFO(
                OBJECT_TO_OBJECT_HEADER(pwinsta))->Directory;

        if (pParentDirectory != NULL) {
            Status = ObGetObjectSecurity(
                    pParentDirectory,
                    &psdParent,
                    &MemoryAllocated);
            if ( !NT_SUCCESS(Status) ) {
                goto create_error;
            }
        }

        Status = SeAssignSecurity(
                psdParent,
                psdCapture,
                &psdNew,
                TRUE,
                &Context,
                (PGENERIC_MAPPING)&WinStaMapping,
                PagedPool);

        ObReleaseObjectSecurity(psdParent, MemoryAllocated);

        SeUnlockSubjectContext(&Context);
        SeReleaseSubjectContext(&Context);

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_ACCESS_DENIED) {
                RIPNTERR0(Status,
                          RIP_WARNING,
                          "Access denied during object creation");
            } else {
                RIPNTERR1(Status,
                          RIP_ERROR,
                          "Can't create security descriptor! Status = 0x%x",
                          Status);
            }
        } else {

            /*
             * Call the security method to copy the security descriptor
             */
            siNew = (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                    DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION);
            Status = ObSetSecurityDescriptorInfo(
                    pwinsta,
                    &siNew,
                    psdNew,
                    &OBJECT_TO_OBJECT_HEADER(pwinsta)->SecurityDescriptor,
                    PagedPool,
                    (PGENERIC_MAPPING)&WinStaMapping);
            SeDeassignSecurity(&psdNew);

            if (NT_SUCCESS(Status)) {
                PWINDOWSTATION *ppwinsta;

                /*
                 * Put it on the tail of the global windowstation list
                 */
                ppwinsta = &grpWinStaList;
                while (*ppwinsta != NULL)
                    ppwinsta = &(*ppwinsta)->rpwinstaNext;
                LockWinSta(ppwinsta, pwinsta);

                /*
                 * For interactive window stations load the keyboard
                 * layout.
                 */
                if ((pwinsta->dwWSF_Flags & WSF_NOIO) == 0 && pwszKLID != NULL) {
                    TL tlpwinsta;

                    PushW32ThreadLock(pwinsta, &tlpwinsta, UserDereferenceObject);
                    if (xxxLoadKeyboardLayoutEx(
                                pwinsta,
                                hKbdLayoutFile,
                                (HKL)NULL,
                                offTable,
                                pKbdTableMulti,
                                pwszKLID,
                                uKbdInputLocale,
                                KLF_ACTIVATE | KLF_INITTIME) == NULL) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                    PopW32ThreadLock(&tlpwinsta);
                }
            }
        }

        ObDereferenceObject(pwinsta);
    }

    if (!NT_SUCCESS(Status)) {
        RIPNTERR1(Status,
                  RIP_WARNING,
                  "CreateWindowStation: Failed with Status 0x%x",
                  Status);
        return NULL;
    }

    return hwinsta;

    /*
     * Goto here if an error occurs so things can be cleaned up.
     */
create_error:

    RIPNTERR1(Status,
              RIP_WARNING,
              "CreateWindowStation: Failed with Status 0x%x",
              Status);

    ObDereferenceObject(pwinsta);

    if (bMDWCreated) {
        /*
         * Switch ppi values so that HMChangeOwnerThread() can find system's
         * desktop window class.
         */
        ppiSave = ptiCurrent->ppi;
        ptiCurrent->ppi = pTerm->ptiDesktop->ppi;
        HMChangeOwnerThread(pTerm->spwndDesktopOwner, ptiCurrent);

        xxxCleanupMotherDesktopWindow(pTerm);

        /*
         * Restore caller's ppi
         */
        ptiCurrent->ppi = ppiSave;

    }

    return NULL;
}

__inline VOID MarkKLUnloaded(
    PKL pkl)
{
    HMMarkObjectDestroy(pkl);
    pkl->dwKL_Flags |= KL_UNLOADED;
}

/***************************************************************************\
* FreeWindowStation
*
* Called when last lock to the windowstation is removed. Frees all resources
* owned by the windowstation.
*
* History:
* 12-22-93 JimA         Created.
\***************************************************************************/
NTSTATUS FreeWindowStation(
    PKWIN32_DELETEMETHOD_PARAMETERS pDeleteParams)
{
    PWINDOWSTATION pwinsta = pDeleteParams->Object;

    UserAssert(OBJECT_TO_OBJECT_HEADER(pwinsta)->Type == *ExWindowStationObjectType);

    /*
     * Mark the windowstation as dying. Make sure we're not recursing.
     */
    UserAssert(!(pwinsta->dwWSF_Flags & WSF_DYING));
    pwinsta->dwWSF_Flags |= WSF_DYING;

    UserAssert(pwinsta->rpdeskList == NULL);

    /*
     * Free up the other resources.
     */
    if (!(pwinsta->dwWSF_Flags & WSF_NOIO) && gpEventSwitchDesktop != NULL) {
        KeSetEvent(gpEventSwitchDesktop, EVENT_INCREMENT, FALSE);
        ObDereferenceObject(gpEventSwitchDesktop);
        gpEventSwitchDesktop = NULL;
    }

    BEGIN_REENTERCRIT();

    RtlDestroyAtomTable(pwinsta->pGlobalAtomTable);

    ForceEmptyClipboard(pwinsta);

    /*
     * Free up keyboard layouts.
     */
    if (!(pwinsta->dwWSF_Flags & WSF_NOIO) && pwinsta->spklList != NULL) {
#if DBG
        int iter = 0;
#endif
        PKL pklLast = pwinsta->spklList->pklPrev;

        RIPMSG2(RIP_WARNING, "FreeWindowStation: pwinsta(%p)->spklList is not NULL, %p", pwinsta, pwinsta->spklList);

        while (pwinsta->spklList != pklLast) {
            PKL pklNext = pwinsta->spklList->pklNext;
#if DBG
            ++iter;
            UserAssert(iter < 1000);
#endif

            MarkKLUnloaded(pwinsta->spklList);
            Lock(&pwinsta->spklList, pklNext);
        }

        MarkKLUnloaded(pwinsta->spklList);
        Unlock(&pwinsta->spklList);

        HYDRA_HINT(HH_KBDLYOUTFREEWINSTA);

        /*
         * make sure the logon notify window went away
         */
        UserAssert(gspwndLogonNotify == NULL);
    } else {
        UserAssert(pwinsta->spklList == NULL);
    }

    /*
     * Free the USER sid.
     */
    if (pwinsta->psidUser != NULL) {
        UserFreePool(pwinsta->psidUser);
        pwinsta->psidUser = NULL;
    }

    /*
     * Dereference gWinstaRunRef, because it was referenced at WindowStation
     * creation time in xxxCreateWindowStation().
     */
    ExReleaseRundownProtection(&gWinstaRunRef);

    END_REENTERCRIT();

    return STATUS_SUCCESS;
}

/***************************************************************************\
* DestroyWindowStation
*
* Removes the windowstation from the global list. We can't release any
* resources until all locks have been removed.
*
* History:
* 01-17-91 JimA         Created.
\***************************************************************************/
NTSTATUS DestroyWindowStation(
    PKWIN32_CLOSEMETHOD_PARAMETERS pCloseParams)
{
    PWINDOWSTATION pwinsta = pCloseParams->Object;
    PWINDOWSTATION *ppwinsta;
    PDESKTOP pdesk;
    PDESKTOP pdeskLock = NULL;

    UserAssert(OBJECT_TO_OBJECT_HEADER(pCloseParams->Object)->Type == *ExWindowStationObjectType);

    /*
     * If this is not the last handle, leave.
     */
    if (pCloseParams->SystemHandleCount != 1) {
        return STATUS_SUCCESS;
    }

    BEGIN_REENTERCRIT();

    /*
     * If the window station was linked into the terminal's list, go ahead
     * and unlink it.
     */
    for (ppwinsta = &grpWinStaList;
            *ppwinsta != NULL && pwinsta != *ppwinsta;
            ppwinsta = &(*ppwinsta)->rpwinstaNext) {
        /* do nothing */;
    }

    if (*ppwinsta != NULL) {
        UnlockWinSta(ppwinsta);
        /*
         * Assert that unlocking it didn't destroy it.
         */
        UserAssert(OBJECT_TO_OBJECT_HEADER(pCloseParams->Object)->Type == *ExWindowStationObjectType);

        *ppwinsta = pwinsta->rpwinstaNext;
        /*
         * The instruction above transfered rpwinstaNext lock ownership to
         * the previous element in the list. Hence the value in pwinsta can
         * no longer be considered valid.
         */
        pwinsta->rpwinstaNext = NULL;
    }

    /*
     * Notify all console threads and wait for them to terminate.
     */
    pdesk = pwinsta->rpdeskList;
    while (pdesk != NULL) {
        if (pdesk != grpdeskLogon && pdesk->dwConsoleThreadId) {
            LockDesktop(&pdeskLock, pdesk, LDL_FN_DESTROYWINDOWSTATION, 0);
            TerminateConsole(pdesk);

            /*
             * Restart scan in case desktop list has changed.
             */
            pdesk = pwinsta->rpdeskList;
            UnlockDesktop(&pdeskLock, LDU_FN_DESTROYWINDOWSTATION, 0);
        } else {
            pdesk = pdesk->rpdeskNext;
        }
    }

    END_REENTERCRIT();

    return STATUS_SUCCESS;
}


/***************************************************************************\
* WindowStationOpenProcedure
*
* History:
* 06-11-01 GerardoB         Created for instrumentation/debugging purposes.
* 02-26-02 Msadek           Change it to deny any open with granted special
*                           rights cross session.
\***************************************************************************/
NTSTATUS WindowStationOpenProcedure(
    PKWIN32_OPENMETHOD_PARAMETERS pOpenParams)
{
    /*
     * Allow windowstation open cross session only if no special rights
     * granted.
     */
    if (pOpenParams->GrantedAccess & SPECIFIC_RIGHTS_ALL) {
        if (PsGetProcessSessionId(pOpenParams->Process) !=
            ((PWINDOWSTATION)pOpenParams->Object)->dwSessionId) {
            return STATUS_ACCESS_DENIED;
        }
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* ParseWindowStation
*
* Parse a windowstation path.
*
* History:
* 06-14-95 JimA         Created.
\***************************************************************************/
NTSTATUS ParseWindowStation(
    PKWIN32_PARSEMETHOD_PARAMETERS pParseParams)
{
    PWINDOWSTATION pwinsta = pParseParams->ParseObject;

    UserAssert(OBJECT_TO_OBJECT_HEADER(pParseParams->ParseObject)->Type == *ExWindowStationObjectType);

    /*
     * If nothing remains to be parsed, return the windowstation.
     */
    *(pParseParams->Object) = NULL;
    if (pParseParams->RemainingName->Length == 0) {
        if (pParseParams->ObjectType != *ExWindowStationObjectType) {
            return STATUS_OBJECT_TYPE_MISMATCH;
        }

        ObReferenceObject(pwinsta);
        *(pParseParams->Object) = pwinsta;
        return STATUS_SUCCESS;
    }

    /*
     * Skip leading path separator, if present.
     */
    if (*(pParseParams->RemainingName->Buffer) == OBJ_NAME_PATH_SEPARATOR) {
        pParseParams->RemainingName->Buffer++;
        pParseParams->RemainingName->Length -= sizeof(WCHAR);
        pParseParams->RemainingName->MaximumLength -= sizeof(WCHAR);
    }

    /*
     * Validate the desktop name.
     */
    if (wcschr(pParseParams->RemainingName->Buffer, L'\\')) {
        return STATUS_OBJECT_PATH_INVALID;
    }

    if (pParseParams->ObjectType == *ExDesktopObjectType) {
        return ParseDesktop(pParseParams->ParseObject,
                            pParseParams->ObjectType,
                            pParseParams->AccessState,
                            pParseParams->AccessMode,
                            pParseParams->Attributes,
                            pParseParams->CompleteName,
                            pParseParams->RemainingName,
                            pParseParams->Context,
                            pParseParams->SecurityQos,
                            pParseParams->Object);
    }

    return STATUS_OBJECT_TYPE_MISMATCH;
}


/***************************************************************************\
* OkayToCloseWindowStation
*
* We can only close windowstation handles if they're not in use.
*
* History:
* 08-Feb-1999 JerrySh   Created.
\***************************************************************************/
NTSTATUS OkayToCloseWindowStation(
    PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS pOkCloseParams)
{
    PWINDOWSTATION pwinsta = (PWINDOWSTATION)pOkCloseParams->Object;

    UserAssert(OBJECT_TO_OBJECT_HEADER(pOkCloseParams->Object)->Type == *ExWindowStationObjectType);

    /*
     * Kernel mode code can close anything.
     */
    if (pOkCloseParams->PreviousMode == KernelMode) {
        return STATUS_SUCCESS;
    /*
     * Do not allow a user mode process to close a kernel handle of ours.
     * It shouldn't. In addition, if this happens cross-session, we will try to
     * attach to the system processes and will bugcheck since the seesion
     * address space is not mapped into it. Same for the session manager 
     * process. See bug# 759533.
     */
    } else if (PsGetProcessSessionIdEx(pOkCloseParams->Process) == -1) {
        return STATUS_ACCESS_DENIED;
    }

    /*
     * We can't close a windowstation that's being used.
     */
    if (CheckHandleInUse(pOkCloseParams->Handle) ||
        CheckHandleFlag(pOkCloseParams->Process, pwinsta->dwSessionId, pOkCloseParams->Handle, HF_PROTECTED)) {
        RIPMSG1(RIP_WARNING,
                "Trying to close windowstation 0x%p while still in use",
                pwinsta);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* _OpenWindowStation
*
* Opens the specified windowstation.
*
* History:
* 03-19-1991 JimA         Created.
\***************************************************************************/
HWINSTA _OpenWindowStation(
    POBJECT_ATTRIBUTES pObjA,
    DWORD dwDesiredAccess,
    KPROCESSOR_MODE AccessMode)
{
    HWINSTA hwinsta;
    NTSTATUS Status;

    /*
     * Obja is client-side. Ob interfaces protect and capture as
     * appropriate.
     */
    Status = ObOpenObjectByName(pObjA,
                                *ExWindowStationObjectType,
                                AccessMode,
                                NULL,
                                dwDesiredAccess,
                                NULL,
                                &hwinsta);
    if (!NT_SUCCESS(Status)) {
        try {
            RIPNTERR3(Status,
                      RIP_VERBOSE,
                      "Opening of winsta %.*ws failed with Status 0x%x",
                      pObjA->ObjectName->Length,
                      pObjA->ObjectName->Buffer,
                      Status);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        }

        hwinsta = NULL;
    }

    return hwinsta;
}

/***************************************************************************\
* _CloseWindowStation (API)
*
* Closes a windowstation for the calling process
*
* History:
* 15-Jun-1999 JerrySh   Created.
\***************************************************************************/
BOOL _CloseWindowStation(
    HWINSTA hwinsta)
{
    HWINSTA hwinstaCurrent;

    _GetProcessWindowStation(&hwinstaCurrent);
    if (hwinsta != hwinstaCurrent) {
        return NT_SUCCESS(ZwClose(hwinsta));
    }

    return FALSE;
}

/***************************************************************************\
* _SetProcessWindowStation (API)
*
* Sets the windowstation of the calling process to the windowstation
* specified by pwinsta.
*
* History:
* 01-14-91 JimA         Created.
\***************************************************************************/
NTSTATUS _SetProcessWindowStation(
    HWINSTA hwinsta,
    KPROCESSOR_MODE AccessMode)
{
    PETHREAD Thread = PsGetCurrentThread();
    PEPROCESS Process = PsGetCurrentProcess();
    HWINSTA hwinstaDup, hwinstaProcess;
    NTSTATUS Status;
    PPROCESSINFO ppi;
    PWINDOWSTATION pwinsta, pwinstaOld;
    OBJECT_HANDLE_INFORMATION ohi;

    Status = ObReferenceObjectByHandle(hwinsta,
                                       0,
                                       *ExWindowStationObjectType,
                                       AccessMode,
                                       &pwinsta,
                                       &ohi);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR1(Status,
                  RIP_WARNING,
                  "Failed to reference windowstation with Status = 0x%x",
                  Status);
        return Status;
    }

    if (pwinsta->dwSessionId != gSessionId) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Cannot assign a window station of a different session");
        ObDereferenceObject(pwinsta);
        return STATUS_INVALID_PARAMETER;
    }

   /*
    * We need to lock the winsta handle so that an app cannot free it by
    * calling GetProcessWindowStation() & CloseHandle().
    */

    /*
     * Unprotect the old hwinsta.
     */
    ppi = PpiFromProcess(PsGetThreadProcess(Thread));
    if (ppi->hwinsta) {
        SetHandleFlag(ppi->hwinsta, HF_PROTECTED, FALSE);
    }

    /*
     * Save the WindowStation information.
     */
    LockWinSta(&ppi->rpwinsta, pwinsta);
    ObDereferenceObject(pwinsta);
    ppi->hwinsta = hwinsta;

    /*
     * Protect the new Window Station Handle
     */
    SetHandleFlag(ppi->hwinsta, HF_PROTECTED, TRUE);

    /*
     * Check the old Atom Manager WindowStation to see if we are
     * changing this process' WindowStation.
     */
    hwinstaProcess = PsGetProcessWin32WindowStation(Process);
    if (hwinstaProcess != NULL) {
        /*
         * Get a pointer to the old WindowStation object to see if it's
         * the same WindowStation that we are setting.
         */
        Status = ObReferenceObjectByHandle(hwinstaProcess,
                                           0,
                                           *ExWindowStationObjectType,
                                           AccessMode,
                                           &pwinstaOld,
                                           NULL);
        if (NT_SUCCESS(Status)) {
            /*
             * Are they different WindowStations?  If so, NULL out the
             * atom manager cache so we will reset it below.
             */
            if (pwinsta != pwinstaOld) {
                ZwClose(hwinstaProcess);
                PsSetProcessWindowStation(Process, NULL);
            }
            ObDereferenceObject(pwinstaOld);

        } else {
            /*
             * Their Atom Manager handle is bad?  Give them a new one.
             */
            PsSetProcessWindowStation(Process, NULL);
            RIPMSGF2(RIP_WARNING,
                     "Couldn't reference old WindowStation (0x%x) Status=0x%x",
                     hwinstaProcess,
                     Status);
        }
    }

    /*
     * Duplicate the WindowStation handle and stash it in the atom manager's
     * cache (Process->Win32WindowStation).
     */
    hwinstaProcess = PsGetProcessWin32WindowStation(Process);
    if (hwinstaProcess == NULL) {
        Status = ZwDuplicateObject(NtCurrentProcess(),
                                   hwinsta,
                                   NtCurrentProcess(),
                                   &hwinstaDup,
                                   0,
                                   0,
                                   DUPLICATE_SAME_ACCESS);
        if (NT_SUCCESS(Status)) {
            PsSetProcessWindowStation(Process, hwinstaDup);
        } else {
            RIPMSGF2(RIP_WARNING,
                     "Couldn't dup WindowStation handle (0x%x) Status 0x%x",
                     hwinsta,
                     Status);
        }
    }

    ppi->amwinsta = ohi.GrantedAccess;

    if (pwinsta->dwWSF_Flags & WSF_NOIO) {
        ppi->W32PF_Flags &= ~W32PF_IOWINSTA;
    } else {
        ppi->W32PF_Flags |= W32PF_IOWINSTA;
    }

    /*
     * Do the access check now for readscreen so that blts off of the
     * display will be as fast as possible.
     */
    if (RtlAreAllAccessesGranted(ohi.GrantedAccess, WINSTA_READSCREEN)) {
        ppi->W32PF_Flags |= W32PF_READSCREENACCESSGRANTED;
    } else {
        ppi->W32PF_Flags &= ~W32PF_READSCREENACCESSGRANTED;
    }

    return STATUS_SUCCESS;
}


/***************************************************************************\
* _GetProcessWindowStation (API)
*
* Returns a pointer to the windowstation of the calling process.
*
* History:
* 01-14-91 JimA         Created.
\***************************************************************************/
PWINDOWSTATION _GetProcessWindowStation(
    HWINSTA *phwinsta)
{
    PPROCESSINFO ppi = PpiCurrent();

    if (phwinsta) {
        *phwinsta = ppi->hwinsta;
    }

    return ppi->rpwinsta;
}


/***************************************************************************\
* _BuildNameList
*
* Builds a list of windowstation or desktop names.
*
* History:
* 05-17-94 JimA         Created.
* 10-21-96 CLupu        Added TERMINAL enumeration
\***************************************************************************/
NTSTATUS _BuildNameList(
    PWINDOWSTATION pwinsta,
    PNAMELIST      ccxpNameList,
    UINT           cbNameList,
    PUINT          pcbNeeded)
{
    PBYTE                    pobj;
    PWCHAR                   ccxpwchDest, ccxpwchMax;
    ACCESS_MASK              amDesired;
    POBJECT_HEADER           pHead;
    POBJECT_HEADER_NAME_INFO pNameInfo;
    DWORD                    iNext;
    NTSTATUS                 Status;
    CONST GENERIC_MAPPING *pGenericMapping;

    try {
        ccxpNameList->cNames = 0;
        ccxpwchDest = ccxpNameList->awchNames;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_ACCESS_VIOLATION;
    }

    ccxpwchMax = (PWCHAR)((PBYTE)ccxpNameList + cbNameList - sizeof(WCHAR));

    /*
     * If we're enumerating windowstations, pwinsta is NULL. Otherwise,
     * we're enumerating desktops.
     */
    if (pwinsta == NULL) {
        pobj  = (PBYTE)grpWinStaList;
        amDesired = WINSTA_ENUMERATE;
        pGenericMapping = &WinStaMapping;
        iNext = FIELD_OFFSET(WINDOWSTATION, rpwinstaNext);
    } else {
        pobj = (PBYTE)pwinsta->rpdeskList;
        amDesired = DESKTOP_ENUMERATE;
        pGenericMapping = &DesktopMapping;
        iNext = FIELD_OFFSET(DESKTOP, rpdeskNext);
    }

    Status = STATUS_SUCCESS;
    *pcbNeeded = 0;
    while (pobj != NULL) {
        if (AccessCheckObject(pobj, amDesired, UserMode, pGenericMapping)) {
            /*
             * Find object name.
             */
            pHead = OBJECT_TO_OBJECT_HEADER(pobj);
            pNameInfo = OBJECT_HEADER_TO_NAME_INFO(pHead);
            if (pNameInfo == NULL) {
                goto NEXT_ITERATION;
            }

            /*
             * If we run out of space, reset the buffer and continue so we
             * can compute the needed space.
             */
            if ((PWCHAR)((PBYTE)ccxpwchDest + pNameInfo->Name.Length +
                    sizeof(WCHAR)) >= ccxpwchMax) {
                *pcbNeeded += (UINT)((PBYTE)ccxpwchDest - (PBYTE)ccxpNameList);
                try {
                    ccxpwchDest = ccxpNameList->awchNames;
                } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                      return STATUS_ACCESS_VIOLATION;
                }
                Status = STATUS_BUFFER_TOO_SMALL;
            }

            try {
                /*
                 * If the entire buffer is sufficient for the new string,
                 * the copy operation is performed, otherwise the size of
                 * this new string is noted and the copy is skipped.
                 */
                ccxpNameList->cNames++;
                if ((PWCHAR)((PBYTE)ccxpwchDest + pNameInfo->Name.Length +
                    sizeof(WCHAR)) <= ccxpwchMax) {
                    /*
                     * Copy and terminate the string
                     */
                    RtlCopyMemory(ccxpwchDest, pNameInfo->Name.Buffer, pNameInfo->Name.Length);
                    (PBYTE)ccxpwchDest += pNameInfo->Name.Length;
                    UserAssert(ccxpwchDest <= (ccxpwchMax - sizeof(WCHAR)));
                    *ccxpwchDest++ = 0;
                }
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                return STATUS_ACCESS_VIOLATION;
            }
        }

        NEXT_ITERATION:
        pobj = *(PBYTE*)(pobj + iNext);
    }

    /*
     * Put an empty string on the end.
     */
    try {
        UserAssert(ccxpwchDest <= (PWCHAR)((PBYTE)ccxpNameList + cbNameList - sizeof(WCHAR)));
        *ccxpwchDest++ = 0;

        ccxpNameList->cb = (UINT)((PBYTE)ccxpwchDest - (PBYTE)ccxpNameList);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_ACCESS_VIOLATION;
    }

    *pcbNeeded += (UINT)((PBYTE)ccxpwchDest - (PBYTE)ccxpNameList);

    return Status;
}

NTSTATUS ReferenceWindowStation(
    PETHREAD Thread,
    HWINSTA hwinsta,
    ACCESS_MASK amDesiredAccess,
    PWINDOWSTATION *ppwinsta,
    BOOL fUseDesktop)
{
    PPROCESSINFO ppi;
    PTHREADINFO pti;
    PWINDOWSTATION pwinsta = NULL;
    NTSTATUS Status;

    /*
     * We prefer to use the thread's desktop to dictate which windowstation to
     * use rather than the process. This allows NetDDE, which has threads
     * running under different desktops on different windowstations but whose
     * process is set to only one of these windowstations, to get global atoms
     * properly without having to change its process windowstation a billion
     * times and synchronize.
     */
    ppi = PpiFromProcess(PsGetThreadProcess(Thread));
    pti = PtiFromThread(Thread);

    /*
     * First, try to get the windowstation from the pti, and then from the
     * ppi.
     */
    if (ppi != NULL) {
        if (!fUseDesktop || pti == NULL || pti->rpdesk == NULL ||
                ppi->rpwinsta == pti->rpdesk->rpwinstaParent) {

            /*
             * Use the windowstation assigned to the process.
             */
            pwinsta = ppi->rpwinsta;
            if (pwinsta != NULL) {
                RETURN_IF_ACCESS_DENIED(ppi->amwinsta, amDesiredAccess,
                        STATUS_ACCESS_DENIED);
            }
        }

        /*
         * If we aren't using the process' windowstation, try to go through
         * the thread's desktop.
         */
        if (pwinsta == NULL && pti != NULL && pti->rpdesk != NULL) {

            /*
             * Perform access check the parent windowstation.  This
             * is an expensive operation.
             */
            pwinsta = pti->rpdesk->rpwinstaParent;
            if (!AccessCheckObject(pwinsta, amDesiredAccess, KernelMode, &WinStaMapping))
                return STATUS_ACCESS_DENIED;
        }
    }

    /*
     * If we still don't have a windowstation and a handle was passed in, use
     * it.
     */
    if (pwinsta == NULL) {
        if (hwinsta != NULL) {
            Status = ObReferenceObjectByHandle(hwinsta,
                                               amDesiredAccess,
                                               *ExWindowStationObjectType,
                                               KernelMode,
                                               &pwinsta,
                                               NULL);
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
            ObDereferenceObject(pwinsta);
        } else {
            return STATUS_NOT_FOUND;
        }
    }

    *ppwinsta = pwinsta;

    return STATUS_SUCCESS;
}

/***************************************************************************\
* _SetWindowStationUser
*
* Private API for winlogon to associate a windowstation with a user.
*
* History:
* 06-27-94 JimA         Created.
\***************************************************************************/
BOOL _SetWindowStationUser(
    PWINDOWSTATION pwinsta,
    PLUID pluidUser,
    PSID ccxpsidUser,
    DWORD cbsidUser)
{
    /*
     * Make sure the caller is the logon process.
     */
    if (PsGetCurrentProcessId() != gpidLogon) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "_SetWindowStationUser: Caller must be in the logon process");

        return FALSE;
    }

    if (pwinsta->psidUser != NULL) {
        UserFreePool(pwinsta->psidUser);
    }

    if (ccxpsidUser != NULL) {
        pwinsta->psidUser = UserAllocPoolWithQuota(cbsidUser, TAG_SECURITY);
        if (pwinsta->psidUser == NULL) {
            RIPERR0(ERROR_OUTOFMEMORY,
                    RIP_WARNING,
                    "Memory allocation failed in _SetWindowStationUser");

            return FALSE;
        }
        try {
            RtlCopyMemory(pwinsta->psidUser, ccxpsidUser, cbsidUser);
        } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
            UserFreePool(pwinsta->psidUser);
            pwinsta->psidUser = NULL;
            return FALSE;
        }
    } else {
        pwinsta->psidUser = NULL;
    }

    pwinsta->luidUser = *pluidUser;

    return TRUE;
}


/***************************************************************************\
* _LockWorkStation (API)
*
* locks the workstation. This API just posts a message to winlogon
* and winlogon does all the work
*
* History:
* 06-11-97 CLupu        Created.
\***************************************************************************/
BOOL _LockWorkStation(
    VOID)
{
    UserAssert(gspwndLogonNotify != NULL);

    _PostMessage(gspwndLogonNotify,
                 WM_LOGONNOTIFY, LOGON_LOCKWORKSTATION, LOCK_NORMAL);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\xlate.c ===
/****************************** Module Header ******************************\
* Module Name: xlate.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 12-07-90 GregoryW      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*
 * "The great artist is the simplifier."
 * - Henri Frederic Amiel (1821-1881)
 * Ibid., November 25, 1861
 */

/*
 * Determine the state of all the Modifier Keys (a Modifier Key
 * is any key that may modify values produced by other keys: these are
 * commonly SHIFT, CTRL and/or ALT)
 * Build a bit-mask (wModBits) to encode which modifier keys are depressed.
 */
WORD GetModifierBits(
    PMODIFIERS pModifiers,
    LPBYTE afKeyState)
{
    PVK_TO_BIT pVkToBit = pModifiers->pVkToBit;
    WORD wModBits = 0;

    CheckCritIn();

    while (pVkToBit->Vk) {
        if (TestKeyDownBit(afKeyState, pVkToBit->Vk)) {
            wModBits |= pVkToBit->ModBits;
        }
        pVkToBit++;
    }
    return wModBits;
}

/*
 * Given modifier bits, return the modification number.
 */
WORD GetModificationNumber(
    PMODIFIERS pModifiers,
    WORD wModBits)
{
    CheckCritInShared();
    if (wModBits > pModifiers->wMaxModBits) {
         return SHFT_INVALID;
    }

    return pModifiers->ModNumber[wModBits];
}

/*****************************************************************************\
* VKFromVSC
*
* This function is called from KeyEvent() after each call to VSCFromSC.  The
* keyboard input data passed in is translated to a virtual key code.
* This translation is dependent upon the currently depressed modifier keys.
*
* For instance, scan codes representing the number pad keys may be
* translated into VK_NUMPAD codes or cursor movement codes depending
* upon the state of NumLock and the modifier keys.
*
* History:
*
\*****************************************************************************/
BYTE VKFromVSC(
    PKE pke,
    BYTE bPrefix,
    LPBYTE afKeyState
    )
{
    USHORT usVKey;
    PVSC_VK pVscVk;
    PKBDTABLES pKbdTbl;
    static BOOL fVkPause;

    CheckCritIn();
    DBG_UNREFERENCED_PARAMETER(afKeyState);

    /*
     * Initialize as an unknown VK (unrecognised scancode)
     */
    pke->usFlaggedVk = usVKey = VK_UNKNOWN;

    /* HACK ALERT
     * For Korean 103 keyboard:
     * Check this is Korean keyboard layout or not.
     */
    if (IS_IME_ENABLED() &&
            KOREAN_KBD_LAYOUT(GetActiveHKL())) {
        if ((pke->bScanCode == 0x71) || (pke->bScanCode == 0x72)) {
            pke->bScanCode |= 0x80;
            bPrefix = 0xE0;
        } else {
            pke->bScanCode &= 0x7F;
        }
    } else {
        pke->bScanCode &= 0x7F;
    }

    if (gptiForeground == NULL) {
        RIPMSG0(RIP_VERBOSE, "VKFromVSC: NULL gptiForeground\n");
        pKbdTbl = gpKbdTbl;
    } else {
        if (gptiForeground->spklActive) {
            pKbdTbl = gptiForeground->spklActive->spkf->pKbdTbl;
        } else {
            RIPMSG0(RIP_VERBOSE, "VKFromVSC: NULL spklActive\n");
            pKbdTbl = gpKbdTbl;
        }
    }
    if (bPrefix == 0) {
        if (pke->bScanCode < pKbdTbl->bMaxVSCtoVK) {
            /*
             * direct index into non-prefix table
             */
            usVKey = pKbdTbl->pusVSCtoVK[pke->bScanCode];
            if (usVKey == 0) {
                return 0xFF;
            }
        } else {
            /*
             * unexpected scancode
             */
            RIPMSG2(RIP_VERBOSE, "unrecognized scancode 0x%x, prefix %x",
                    pke->bScanCode, bPrefix);
            return 0xFF;
        }
    } else {
        /*
         * Scan the E0 or E1 prefix table for a match
         */
        if (bPrefix == 0xE0) {
            /*
             * Set the KBDEXT (extended key) bit in case the scancode is not
             * found in the table (eg: FUJITSU POS keyboard #65436)
             */
            usVKey |= KBDEXT;
            /*
             * Ignore the SHIFT keystrokes generated by the hardware
             */
            if ((pke->bScanCode == SCANCODE_LSHIFT) ||
                    (pke->bScanCode == SCANCODE_RSHIFT)) {
                TAGMSG1(DBGTAG_KBD, "VKFromVSC: E0, %02x ignored", pke->bScanCode);
                return 0;
            }
            pVscVk = pKbdTbl->pVSCtoVK_E0;
        } else if (bPrefix == 0xE1) {
            pVscVk = pKbdTbl->pVSCtoVK_E1;
        } else {
            /*
             * Unrecognized prefix (from ScancodeMap?) produces an
             * unextended and unrecognized VK.
             */
            return 0xFF;
        }
        while (pVscVk->Vk) {
            if (pVscVk->Vsc == pke->bScanCode) {
                usVKey = pVscVk->Vk;
                break;
            }
            pVscVk++;
        }
    }

    /*
     * Scancode set 1 returns PAUSE button as E1 1D 45 (E1 Ctrl NumLock)
     * so convert E1 Ctrl to VK_PAUSE, and remember to discard the NumLock
     */
    if (fVkPause) {
        /*
         * This is the "45" part of the Pause scancode sequence.
         * Discard this key event: it is a false NumLock
         */
        fVkPause = FALSE;
        return 0;
    }
    if (usVKey == VK_PAUSE) {
        /*
         * This is the "E1 1D" part of the Pause scancode sequence.
         * Alter the scancode to the value Windows expects for Pause,
         * and remember to discard the "45" scancode that will follow
         */
        pke->bScanCode = 0x45;
        fVkPause = TRUE;
    }

    /*
     * Convert to a different VK if some modifier keys are depressed.
     */
    if (usVKey & KBDMULTIVK) {
        WORD nMod;
        PULONG pul;

        nMod = GetModificationNumber(
                   gpModifiers_VK,
                   GetModifierBits(gpModifiers_VK, gafRawKeyState));

        /*
         * Scan gapulCvt_VK[nMod] for matching VK.
         */
        if ((nMod != SHFT_INVALID) && ((pul = gapulCvt_VK[nMod]) != NULL)) {
            while (*pul != 0) {
                if (LOBYTE(*pul) == LOBYTE(usVKey)) {
                    pke->usFlaggedVk = (USHORT)HIWORD(*pul);
                    return (BYTE)pke->usFlaggedVk;
                }
                pul++;
            }
        }
    }

    pke->usFlaggedVk = usVKey;
    return (BYTE)usVKey;
}

/***************************************************************************\
* UINT InternalMapVirtualKeyEx(UINT wCode, UINT wType, PKBDTABLES pKbdTbl);
*
* History:
* IanJa 5/13/91  from Win3.1 \\pucus\win31ro!drivers\keyboard\getname.asm
* GregoryW 2/21/95  renamed from _MapVirtualKey and added third parameter.
\***************************************************************************/

UINT InternalMapVirtualKeyEx(
    UINT wCode,
    UINT wType,
    PKBDTABLES pKbdTbl)
{
    PVK_TO_WCHARS1 pVK;
    PVK_TO_WCHAR_TABLE pVKT;
    UINT VkRet = 0;
    USHORT usScanCode;
    PVSC_VK pVscVk;
    PBYTE pVkNumpad;

    switch (wType) {
    case 0:

        /*
         * Convert Virtual Key (wCode) to Scan Code
         */
        if ((wCode >= VK_SHIFT) && (wCode <= VK_MENU)) {

            /*
             * Convert ambiguous Shift/Control/Alt keys to left-hand keys
             */
            wCode = (UINT)((wCode - VK_SHIFT) * 2 + VK_LSHIFT);
        }

        /*
         * Scan through the table that maps Virtual Scancodes to Virtual Keys
         * for non-extended keys.
         */
        for (usScanCode = 0; usScanCode < pKbdTbl->bMaxVSCtoVK; usScanCode++) {
            if ((UINT)LOBYTE(pKbdTbl->pusVSCtoVK[usScanCode]) == wCode) {
                return usScanCode & 0xFF;
            }
        }

        /*
         * Scan through the table that maps Virtual Scancodes to Virtual Keys
         * for extended keys.
         */
        for (pVscVk = pKbdTbl->pVSCtoVK_E0; pVscVk->Vk; pVscVk++) {
            if ((UINT)LOBYTE(pVscVk->Vk) == wCode) {
                return (UINT)pVscVk->Vsc;
            }
        }

        /*
         * There was no match: maybe the Virtual Key can only be generated
         * with Numlock on. Scan through aVkNumpad[] to determine scancode.
         */
        for (pVkNumpad = aVkNumpad; *pVkNumpad != 0; pVkNumpad++) {
            if ((UINT)(*pVkNumpad) == wCode) {
                return (UINT)(pVkNumpad - aVkNumpad) + SCANCODE_NUMPAD_FIRST;
            }
        }

        return 0;   // No match found!

    case 1:
    case 3:

        /*
         * Convert Scan Code (wCode) to Virtual Key, disregarding modifier keys
         * and NumLock key etc.  Returns 0 for no corresponding Virtual Key
         */
        if (wCode < (UINT)(pKbdTbl->bMaxVSCtoVK)) {
            VkRet = (UINT)LOBYTE(pKbdTbl->pusVSCtoVK[wCode]);
        } else {
            /*
             * Scan the E0 prefix table for a match
             */
            for (pVscVk = pKbdTbl->pVSCtoVK_E0; pVscVk->Vk; pVscVk++) {
                if ((UINT)pVscVk->Vsc == wCode) {
                    VkRet = (UINT)LOBYTE(pVscVk->Vk);
                    break;
                }
            }
        }

        if ((wType == 1) && (VkRet >= VK_LSHIFT) && (VkRet <= VK_RMENU)) {

            /*
             * Convert left/right Shift/Control/Alt keys to ambiguous keys
             * (neither left nor right)
             */
            VkRet = (UINT)((VkRet - VK_LSHIFT) / 2 + VK_SHIFT);
        }

        if (VkRet == 0xFF) {
            VkRet = 0;
        }
        return VkRet;

    case 2:

        /*
         * Bogus Win3.1 functionality: despite SDK documenation, return uppercase for
         * VK_A through VK_Z
         */
        if ((wCode >= (WORD)'A') && (wCode <= (WORD)'Z')) {
            return wCode;
        }

        // HIWORD is no loner the wchar, due to app compat problems #287134
        // We should not return the wchar from pti->wchInjected that cached
        // at GetMessage time.
        // (delete this commented-out section by end of March 1999 - IanJa)
        //
        // if (LOWORD(wCode) == VK_PACKET) {
        //    return HIWORD(wCode);
        // }

        /*
         * Convert Virtual Key (wCode) to ANSI.
         * Search each Shift-state table in turn, looking for the Virtual Key.
         */
        for (pVKT = pKbdTbl->pVkToWcharTable; pVKT->pVkToWchars != NULL; pVKT++) {
            pVK = pVKT->pVkToWchars;
            while (pVK->VirtualKey != 0) {
                if ((UINT)pVK->VirtualKey == wCode) {

                    /*
                     * Match found: return the unshifted character
                     */
                    if (pVK->wch[0] == WCH_DEAD) {

                        /*
                         * It is a dead character: the next entry contains its
                         * value.  Set the high bit to indicate dead key
                         * (undocumented behaviour)
                         */
                        pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);
                        return pVK->wch[0] | (UINT)0x80000000;
                    } else if (pVK->wch[0] == WCH_NONE) {
                        return 0; // 9013
                    }
                    if (pVK->wch[0] == WCH_NONE) {
                        return 0;
                    }
                    return pVK->wch[0];
                }
                pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);
            }
        }
    }

    /*
     * Can't find translation, or wType was invalid
     */
    return 0;
}

/***************************************************************************\
* _GetKeyNameText (API)
*
* int _GetKeyNameText(DWORD lParam, LPSTR lpStr, UINT size);
*
*   lParam: value from WM_KEYDOWN message, etc.
*
*       Byte 3 (bits 16..23) of lParam contains a scan code.
*
*       Bit 20 of lParam is the Extended bit (distingushes some keys on
*       Enhanced keyboard).
*
*       Bit 21 of lParam is a don't care bit (don't distingush between
*       left and right control, shift, Enter keys, between edit keys
*       in edit area and on numeric pad, etc).  The app calling this
*       function sets this bit in lParam, if it so desires.
*
*   lpStr:      Pointer to output string.
*
*   iSize:      Maximum length of output string, not including null byte.
*
* History:
* IanJa 4/11/91  from Win3.1 \\pucus\win31ro!drivers\keyboard\getname.asm
\***************************************************************************/

int APIENTRY _GetKeyNameText(
    LONG lParam,
    LPWSTR ccxlpStr,
    int cchSize)
{
    BYTE Vsc = LOBYTE(HIWORD(lParam));
    PVSC_LPWSTR pKN;
    PTHREADINFO ptiT = PtiCurrentShared();
    PKBDTABLES pKbdTbl;
    UINT Vk;
    UINT Char;

    /*
     * NOTE -- lpStr can be a client-side address, so access through it
     *    must be guarded with try blocks.
     */

    if (cchSize < 1)
        return 0;

    /*
     * If bit 25 set (don't care about left vs. right) then:
     * 1) convert right-Shift into left-Shift
     * 2) clear the extended bit for Ctrl and Alt only (effectively converting
     *    right-Ctrl & right-Alt into left-Ctrl & right-Alt)
     * For Windows '95 compatibility, the DONTCARE_BIT doesn't apply to other
     * extended keys (eg: NumPad cursor movement keys, NumPad Enter). Some
     * applications (Word '95) depend on this.  #37796
     */
    if (lParam & DONTCARE_BIT) {
        if (Vsc == SCANCODE_RSHIFT) {
           Vsc = SCANCODE_LSHIFT;
        }
        if (lParam & EXTENDED_BIT) {
            if ((Vsc == SCANCODE_CTRL) || (Vsc == SCANCODE_ALT)) {
                lParam &= ~EXTENDED_BIT;
            }
        }
        lParam &= ~DONTCARE_BIT;
    }

    if (ptiT->spklActive == (PKL)NULL) {
        return 0;
    }
    pKbdTbl = ptiT->spklActive->spkf->pKbdTbl;

    /*
     * Scan pKbdTbl->pKeyNames[] or pKeyNamesExt[] for matching Virtual Scan Code
     */
    if (lParam & EXTENDED_BIT) {
        pKN = pKbdTbl->pKeyNamesExt;
    } else {
        pKN = pKbdTbl->pKeyNames;
    }

    if (pKN) {
        while (pKN->vsc != 0) {
            if (Vsc == pKN->vsc) {

                try {
                    cchSize = wcsncpycch(ccxlpStr, pKN->pwsz, cchSize);
                    cchSize--;
                    ccxlpStr[cchSize] = L'\0';
                } except(W32ExceptionHandler(TRUE, RIP_ERROR)) {
                    return 0;
                }
                return cchSize;
            }
            pKN++;
        }
    }

    /*
     * The name of the key was not found in the table, so we
     * now attempt to construct the key name from the character produced by
     * the key.  Translate Scancode -> Virtual Key -> character.
     */

    /*
     * Translate Scancode to Virtual Key (ignoring modifier keys etc.)
     */
    Vk = InternalMapVirtualKeyEx((UINT)Vsc, 1, pKbdTbl);
    if (Vk == 0) {
        return 0;
    }

    /*
     * Now translate Virtual Key to character (ignoring modifier keys etc.)
     */
    Char = InternalMapVirtualKeyEx((UINT)Vk, 2, pKbdTbl);
    if (Char == 0) {
        return 0;
    }

    if (Char & 0x80000000) {
        LPWSTR *ppwsz;

        ppwsz = pKbdTbl->pKeyNamesDead;
        if (ppwsz) {
            while (*ppwsz != NULL) {
                if (*ppwsz[0] == (WCHAR)Char) {
                    try {
                        cchSize = wcsncpycch(ccxlpStr, (*ppwsz)+1, cchSize);
                        cchSize--;
                        ccxlpStr[cchSize] = L'\0';
                    } except(W32ExceptionHandler(TRUE, RIP_ERROR)) {
                        return 0;
                    }
                    return cchSize;
                }
                ppwsz++;
            }
        }
    }

    /*
     * Construct a single character name (adding null-terminator if possible)
     */
    try {
        ccxlpStr[0] = (WCHAR)Char;
        if (cchSize >= 2) {
            ccxlpStr[1] = L'\0';
        }
    } except(W32ExceptionHandler(TRUE, RIP_ERROR)) {
        return 0;
    }
    return 1;
}

/***************************************************************************\
* xxxAltGr() - handle special case Right-hand ALT key (Locale dependent)
*
* Note:  gbAltGrDown reminds us to send the fake Ctrl key back up if we
* switched to a non-AltGr layout while ALtGr was down: otherwise the Ctrl key
* gets stuck down.  (For example: using AltGr with KBDSEL to switch from
* German to US layout).
\***************************************************************************/
BOOL gbAltGrDown = FALSE;

VOID xxxAltGr(
    PKE pKe)
{
    if ((pKe->usFlaggedVk & 0xFF) != VK_RMENU) {
        return;
    }

    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * If neither CTRL key is down, then fake one going down so that
         * the right hand ALT key is converted to CTRL + ALT.
         */
        if (!TestRawKeyDown(VK_CONTROL)) {
            gbAltGrDown = TRUE;
            xxxKeyEvent(VK_LCONTROL, 0x1D | SCANCODE_SIMULATED,
                        pKe->dwTime, 0,
#ifdef GENERIC_INPUT    // LATER: NULL, or pKe->hDevice?
                        NULL,
                        NULL,
#endif
                        FALSE);
        }
    } else {
        /*
         * If the physical Left Ctrl key is not really down, fake the
         * Left Ctrl key coming back up (undo earlier faked Left Ctrl down)
         */
        gbAltGrDown = FALSE;
        if (!TestRawKeyDown(VK_LCONTROL)) {
            xxxKeyEvent(VK_LCONTROL | KBDBREAK, 0x1D | SCANCODE_SIMULATED,
                        pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                        NULL,
                        NULL,
#endif
                        FALSE);
        }
    }
}

/*****************************************************************************\
* xxxShiftLock()
*     handle ShiftLock feature, where only hitting Shift turns CapsLock off
*
\*****************************************************************************/
BOOL xxxShiftLock(
    PKE pKe)
{
    USHORT Vk;

    /*
     * We only mess with downstrokes: return TRUE to let it pass unmolested.
     */
    if (pKe->usFlaggedVk & KBDBREAK) {
        return TRUE;
    }

    Vk = pKe->usFlaggedVk & 0xFF;

    /*
     * If CapsLock is pressed when CapsLock is already on, lose the keystroke.
     */
    if ((Vk == VK_CAPITAL) && TestAsyncKeyStateToggle(VK_CAPITAL)) {
        return FALSE;
    }

    /*
     * If a Shift key goes down when CapsLock is on, turn CapsLock off
     * by simulating a click on the CapsLock key.
     * Let the Shift down through FIRST, since it might be part of an
     * input lang toggle (tough luck that this toggle turns off CapsLock!)
     */
    if (((Vk == VK_LSHIFT) || (Vk == VK_RSHIFT) || (Vk == VK_SHIFT)) &&
            TestAsyncKeyStateToggle(VK_CAPITAL)) {
        xxxKeyEvent(pKe->usFlaggedVk, pKe->bScanCode,
                    pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    FALSE);
        xxxKeyEvent(VK_CAPITAL, 0x3A | SCANCODE_SIMULATED,
                    pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    FALSE);
        xxxKeyEvent(VK_CAPITAL | KBDBREAK, 0x3A | SCANCODE_SIMULATED,
                    pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    FALSE);
        return FALSE;
    }

    return TRUE;
}

/*
 * Returning FALSE means the Key Event has been deleted by a special-case
 * KeyEvent processor.
 * Returning TRUE means the Key Event should be passed on (although it may
 * have been altered.
 */
BOOL KEOEMProcs(PKE pKe)
{
    int i;

    CheckCritIn();

    for (i = 0; aKEProcOEM[i] != NULL; i++) {
        if (!aKEProcOEM[i](pKe)) {
            /*
             * Eat the key event
             */
            return FALSE;
        }
    }

    /*
     * Pass the (possibly altered) key event on.
     */
    return TRUE;
}

/*
 * Returning FALSE means the Key Event has been deleted by a special-case
 * KeyEvent processor.
 * Returning TRUE means the Key Event should be passed on (although it may
 * have been altered.
 */
BOOL xxxKELocaleProcs(PKE pKe)
{
    CheckCritIn();

    /*
     * AltGr is a layout-specific behavior
     * Modifier keys are sent up as necessary in xxxInternalActivateKeyboardLayout
     * (#139178), so left-Ctrl won't be left stuck down if we switch from an
     * AltGr keyboard to a non-AltGr keybord while the AltGr is held down.
     */
    if ((gpKbdTbl->fLocaleFlags & KLLF_ALTGR) || gbAltGrDown) {
        xxxAltGr(pKe);
    }

    /*
     * ShiftLock/CapsLock is per-user (global) behavior as well as (for
     * backward compatibility) per-layout behavior.
     */
    if ((gdwKeyboardAttributes & KLLF_SHIFTLOCK) ||
            (gpKbdTbl->fLocaleFlags & KLLF_SHIFTLOCK)) {
        if (!xxxShiftLock(pKe)) {
            return FALSE;
        }
    }

    /*
     * Other special Key Event processors
     */

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\alignrec.c ===
/**************************************************************************\
* Module Name: mergerec.c
*
* Contains all the code to reposition rectangles
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* NOTES:
*
* History:
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define MONITORS_MAX 10

#define RectCenterX(prc)    ((prc)->left+((prc)->right-(prc)->left)/2)
#define RectCenterY(prc)    ((prc)->top+((prc)->bottom-(prc)->top)/2)

// ----------------------------------------------------------------------------
//
//  INTERSECTION_AXIS()
//      This macro tells us how a particular set of overlapping rectangles
//  should be adjusted to remove the overlap.  It is basically a condensed
//  version of a lookup table that does the same job.  The parameters for the
//  macro are two rectangles, where one is the intersection of the other with
//  a third (unspecified) rectangle.  The macro compares the edges of the
//  rectangles to determine which sides of the intersection were "caused" by
//  the source rectangle.  In the pre-condensed version of this macro, the
//  results of these comparisons (4 bits) would be used to index into a 16
//  entry table which specifies the way to resolve the overlap.  However, this
//  is highly redundant, as the table would actually represents several rotated
//  and/or inverted instances of a few basic relationships:
//
//  Horizontal Vertical  Diagonal  Contained       Crossing
//      *--*    *-----*   *---*     *-----*         *----*
//   *--+* |    | *-* |   | *-+-*   | *-* |       *-+----+-*
//   |  || |    *-+-+-*   | | | |   | | | |  and  | |    | |
//   *--+* |      | |     *-+-* |   | *-* |       *-+----+-*
//      *--*      *-*       *---*   *-----*         *----*
//
//  What we are really interested in determining is whether we "should" move
//  the rectangles horizontally or vertically to resolve the overlap, hence we
//  are testing for three states: Horizontal, Vertical and Don't Know.
//
//  The macro gives us these three states by XORing the high and low bits of
//  of the comparison to reduce the table to 4 cases where 1 and 2 are
//  vertical and horizontal respectively, and then subtracting 1 so that the
//  2 bit signifies "unknown-ness."
//
//  Note that there are some one-off cases in the comparisons because we are
//  not actually looking at the third rectangle.  However this greatly reduces
//  the complexity so these small errors are acceptible given the scale of the
//  rectangles we are comparing.
//
// ----------------------------------------------------------------------------
#define INTERSECTION_AXIS(a, b) \
    (((((a->left == b->left) << 1) | (a->top == b->top)) ^ \
    (((a->right == b->right) << 1) | (a->bottom == b->bottom))) - 1)

#define INTERSECTION_AXIS_VERTICAL      (0)
#define INTERSECTION_AXIS_HORIZONTAL    (1)
#define INTERSECTION_AXIS_UNKNOWN(code) (code & 2)

// ----------------------------------------------------------------------------
//
//  CenterRectangles()
//      Move all the rectangles so their origin is the center of their union.
//
// ----------------------------------------------------------------------------
void NEAR PASCAL CenterRectangles(LPRECT arc, UINT count)
{
    LPRECT lprc, lprcL;
    RECT rcUnion;

    CopyRect(&rcUnion, arc);

    lprcL = arc + count;
    for (lprc = arc + 1; lprc < lprcL; lprc++)
    {
        UnionRect(&rcUnion, &rcUnion, lprc);
    }

    for (lprc = arc; count; count--)
    {
        OffsetRect(lprc, -RectCenterX(&rcUnion), -RectCenterY(&rcUnion));
        lprc++;
    }
}

// ----------------------------------------------------------------------------
//
//  RemoveOverlap()
//    This is called from RemoveOverlaps to resolve conflicts when two
//  rectangles overlap.  It returns the PMONITOR for the monitor it decided to
//  move.  This routine always moves rectangles away from the origin so it can
//  be used to converge on a zero-overlap configuration.
//
//  This function will bias slightly toward moving lprc2 (all other things
//  being equal).
//
// ----------------------------------------------------------------------------
LPRECT NEAR PASCAL RemoveOverlap(LPRECT lprc1, LPRECT lprc2, LPRECT lprcI)
{
    LPRECT lprcMove, lprcStay;
    POINT ptC1, ptC2;
    BOOL fNegative;
    BOOL fC1Neg;
    BOOL fC2Neg;
    int dC1, dC2;
    int xOffset;
    int yOffset;
    int nAxis;

    //
    // Compute the centers of both rectangles.  We will need them later.
    //
    ptC1.x = RectCenterX(lprc1);
    ptC1.y = RectCenterY(lprc1);
    ptC2.x = RectCenterX(lprc2);
    ptC2.y = RectCenterY(lprc2);

    //
    // Decide whether we should move things horizontally or vertically.  All
    // this goop is here so it will "feel" right when the system needs to
    // move a monitor on you.
    //
    nAxis = INTERSECTION_AXIS(lprcI, lprc1);

    if (INTERSECTION_AXIS_UNKNOWN(nAxis))
    {
        //
        // Is this a "big" intersection between the two rectangles?
        //
        if (PtInRect(lprcI, ptC1) || PtInRect(lprcI, ptC2))
        {
            //
            // This is a "big" overlap.  Decide if the rectangles
            // are aligned more "horizontal-ish" or "vertical-ish."
            //
            xOffset = ptC1.x - ptC2.x;
            if (xOffset < 0)
                xOffset *= -1;
            yOffset = ptC1.y - ptC2.y;
            if (yOffset < 0)
                yOffset *= -1;

            if (xOffset >= yOffset)
                nAxis = INTERSECTION_AXIS_HORIZONTAL;
            else
                nAxis = INTERSECTION_AXIS_VERTICAL;
        }
        else
        {
            //
            // This is a "small" overlap.  Move the rectangles the
            // smallest distance that will fix the overlap.
            //
            if ((lprcI->right - lprcI->left) <= (lprcI->bottom - lprcI->top))
                nAxis = INTERSECTION_AXIS_HORIZONTAL;
            else
                nAxis = INTERSECTION_AXIS_VERTICAL;
        }
    }

    //
    // We now need to pick the rectangle to move.  Move the one
    // that is further from the origin along the axis of motion.
    //
    if (nAxis == INTERSECTION_AXIS_HORIZONTAL)
    {
        dC1 = ptC1.x;
        dC2 = ptC2.x;
    }
    else
    {
        dC1 = ptC1.y;
        dC2 = ptC2.y;
    }

    if ((fC1Neg = (dC1 < 0)) != 0)
        dC1 *= -1;

    if ((fC2Neg = (dC2 < 0)) != 0)
        dC2 *= -1;

    if (dC2 < dC1)
    {
        lprcMove     = lprc1;
        lprcStay     = lprc2;
        fNegative    = fC1Neg;
    }
    else
    {
        lprcMove     = lprc2;
        lprcStay     = lprc1;
        fNegative    = fC2Neg;
    }

    //
    // Compute a new home for the rectangle and put it there.
    //
    if (nAxis == INTERSECTION_AXIS_HORIZONTAL)
    {
        int xPos;

        if (fNegative)
            xPos = lprcStay->left - (lprcMove->right - lprcMove->left);
        else
            xPos = lprcStay->right;

        xOffset = xPos - lprcMove->left;
        yOffset = 0;
    }
    else
    {
        int yPos;

        if (fNegative)
            yPos = lprcStay->top - (lprcMove->bottom - lprcMove->top);
        else
            yPos = lprcStay->bottom;

        yOffset = yPos - lprcMove->top;
        xOffset = 0;
    }

    OffsetRect(lprcMove, xOffset, yOffset);
    return lprcMove;
}

// ----------------------------------------------------------------------------
//
//  RemoveOverlaps()
//    This is called from CleanupDesktopRectangles make sure the monitor array
//  is non-overlapping.
//
// ----------------------------------------------------------------------------
void NEAR PASCAL RemoveOverlaps(LPRECT arc, UINT count)
{
    LPRECT lprc1, lprc2, lprcL;

    //
    // Center the rectangles around a common origin.  We will move them outward
    // when there are conflicts so centering (a) reduces running time and
    // hence (b) reduces the chances of totally mangling the positions.
    //
    CenterRectangles(arc, count);

    //
    // Now loop through the array fixing any overlaps.
    //
    lprcL = arc + count;
    lprc2 = arc + 1;

ReScan:
    while (lprc2 < lprcL)
    {
        //
        // Scan all rectangles before this one looking for intersections.
        //
        for (lprc1 = arc; lprc1 < lprc2; lprc1++)
        {
            RECT rcI;

            //
            // Move one of the rectanges if there is an intersection.
            //
            if (IntersectRect(&rcI, lprc1, lprc2))
            {
                //
                // Move one of the rectangles out of the way and then restart
                // the scan for overlaps with that rectangle (since moving it
                // may have created new overlaps).
                //
                lprc2 = RemoveOverlap(lprc1, lprc2, &rcI);
                goto ReScan;
            }
        }

        lprc2++;
    }
}

// ----------------------------------------------------------------------------
//
//  AddNextContiguousRectangle()
//    This is called from RemoveGaps to find the next contiguous rectangle
//  in the array.  If there are no more contiguous rectangles it picks the
//  closest rectangle and moves it so it is contiguous.
//
// ----------------------------------------------------------------------------
LPRECT FAR * NEAR PASCAL AddNextContiguousRectangle(LPRECT FAR *aprc,
    LPRECT FAR *pprcSplit, UINT count)
{
    LPRECT FAR *pprcL;
    LPRECT FAR *pprcTest;
    LPRECT FAR *pprcAxis;
    LPRECT FAR *pprcDiag;
    UINT dAxis = (UINT)-1;
    UINT dDiag = (UINT)-1;
    POINT dpAxis;
    POINT dpDiag;
    POINT dpMove;

    pprcL = aprc + count;

    for (pprcTest = aprc; pprcTest < pprcSplit; pprcTest++)
    {
        LPRECT lprcTest = *pprcTest;
        LPRECT FAR *pprcScan;

        for (pprcScan = pprcSplit; pprcScan < pprcL; pprcScan++)
        {
            RECT rcCheckOverlap;
            LPRECT lprcScan = *pprcScan;
            LPRECT FAR *pprcCheckOverlap;
            LPRECT FAR *FAR *pppBest;
            LPPOINT pdpBest;
            UINT FAR *pdBest;
            UINT dX, dY;
            UINT dTotal;

            //
            // Figure out how far the rectangle may be along both axes.
            // Note some of these numbers could be garbage at this point but
            // the code below will take care of it.
            //
            if (lprcScan->right <= lprcTest->left)
                dpMove.x = dX = lprcTest->left - lprcScan->right;
            else
                dpMove.x = -(int)(dX = (lprcScan->left - lprcTest->right));

            if (lprcScan->bottom <= lprcTest->top)
                dpMove.y = dY = lprcTest->top - lprcScan->bottom;
            else
                dpMove.y = -(int)(dY = (lprcScan->top - lprcTest->bottom));

            //
            // Figure out whether the rectangles are vertical, horizontal or
            // diagonal to each other and pick the measurements we will test.
            //
            if ((lprcScan->top < lprcTest->bottom) &&
                (lprcScan->bottom > lprcTest->top))
            {
                // The rectangles are somewhat horizontally aligned.
                dpMove.y = dY = 0;
                pppBest = &pprcAxis;
                pdpBest = &dpAxis;
                pdBest = &dAxis;
            }
            else if ((lprcScan->left < lprcTest->right) &&
                (lprcScan->right > lprcTest->left))
            {
                // The rectangles are somewhat vertically aligned.
                dpMove.x = dX = 0;
                pppBest = &pprcAxis;
                pdpBest = &dpAxis;
                pdBest = &dAxis;
            }
            else
            {
                // The rectangles are somewhat diagonally aligned.
                pppBest = &pprcDiag;
                pdpBest = &dpDiag;
                pdBest = &dDiag;
            }

            //
            // Make sure there aren't other rectangles in the way.  We only
            // need to check the upper array since that is the pool of
            // semi-placed rectangles.  Any rectangles in the lower array that
            // are "in the way" will be found in a different iteration of the
            // enclosing loop.
            //

            CopyRect(&rcCheckOverlap, lprcScan);
            OffsetRect(&rcCheckOverlap, dpMove.x, dpMove.y);

            for (pprcCheckOverlap = pprcScan + 1; pprcCheckOverlap < pprcL;
                pprcCheckOverlap++)
            {
                RECT rc;
                if (IntersectRect(&rc, *pprcCheckOverlap, &rcCheckOverlap))
                    break;
            }
            if (pprcCheckOverlap < pprcL)
            {
                // There was another rectangle in the way; don't use this one.
                continue;
            }

            //
            // If it is closer than the one we already had, use it instead.
            //
            dTotal = dX + dY;
            if (dTotal < *pdBest)
            {
                *pdBest = dTotal;
                *pdpBest = dpMove;
                *pppBest = pprcScan;
            }
        }
    }

    //
    // If we found anything along an axis use that otherwise use a diagonal.
    //
    if (dAxis != (UINT)-1)
    {
        pprcSplit = pprcAxis;
        dpMove = dpAxis;
    }
    else if (dDiag != (UINT)-1)
    {
        // NOTE (AndreVa): consider moving the rectangle to a side in this case.
        // (that, of course would add a lot of code to avoid collisions)
        pprcSplit = pprcDiag;
        dpMove = dpDiag;
    }
    else
        dpMove.x = dpMove.y = 0;

    //
    // Move the monitor into place and return it as the one we chose.
    //
    if (dpMove.x || dpMove.y)
        OffsetRect(*pprcSplit, dpMove.x, dpMove.y);

    return pprcSplit;
}

// ----------------------------------------------------------------------------
//
//  RemoveGaps()
//    This is called from CleanupDesktopRectangles to make sure the monitor
//  array is contiguous.  It assumes that the array is already non-overlapping.
//
// ----------------------------------------------------------------------------
void NEAR PASCAL RemoveGaps(LPRECT arc, UINT count)
{
    LPRECT aprc[MONITORS_MAX];
    LPRECT lprc, lprcL, lprcSwap, FAR *pprc, FAR *pprcNearest;
    UINT uNearest;

    //
    // We will need to find the rectangle closest to the center of the group.
    // We don't really need to center the array here but it doesn't hurt and
    // saves us some code below.
    //
    CenterRectangles(arc, count);

    //
    // Build an array of LPRECTs we can shuffle around with relative ease while
    // not disturbing the order of the passed array.  Also take note of which
    // one is closest to the center so we start with it and pull the rest of
    // the rectangles inward.  This can make a big difference in placement when
    // there are more than 2 rectangles.
    //
    uNearest = (UINT)-1;
    pprcNearest = pprc = aprc;
    lprcL = (lprc = arc) + count;

    while (lprc < lprcL)
    {
        int x, y;
        UINT u;

        //
        // Fill in the array.
        //
        *pprc = lprc;

        //
        // Check if this one is closer to the center of the group.
        //
        x = RectCenterX(lprc);
        y = RectCenterY(lprc);
        if (x < 0) x *= -1;
        if (y < 0) y *= -1;

        u = (UINT)x + (UINT)y;
        if (u < uNearest)
        {
            uNearest    = u;
            pprcNearest = pprc;
        }

        pprc++;
        lprc++;
    }

    //
    // Now make sure we move everything toward the centermost rectangle.
    //
    if (pprcNearest != aprc)
    {
        lprcSwap     = *pprcNearest;
        *pprcNearest = *aprc;
        *aprc        = lprcSwap;
    }

    //
    // Finally, loop through the array closing any gaps.
    //
    pprc = aprc + 1;
    for (lprc = arc + 1; lprc < lprcL; pprc++, lprc++)
    {
        //
        // Find the next suitable rectangle to combine into the group and move
        // it into position.
        //
        pprcNearest = AddNextContiguousRectangle(aprc, pprc, count);

        //
        // If the rectangle that was added is not the next in our array, swap.
        //
        if (pprcNearest != pprc)
        {
            lprcSwap     = *pprcNearest;
            *pprcNearest = *pprc;
            *pprc        = lprcSwap;
        }
    }
}

// ----------------------------------------------------------------------------
//
//  CleanUpDesktopRectangles()
//    This is called by CleanUpMonitorRectangles (etc) to force a set of
//  rectangles into a contiguous, non-overlapping arrangement.
//
// ----------------------------------------------------------------------------

BOOL
AlignRects(LPRECT arc, DWORD cCount, DWORD iPrimary, DWORD dwFlags)
{
    LPRECT lprc, lprcL;

    //
    // Limit for loops.
    //

    lprcL = arc + cCount;

    //
    // We don't need to get all worked up if there is only one rectangle.
    //

    if (cCount > MONITORS_MAX)
    {
        return FALSE;
    }


    if (cCount > 1)
    {
        if (!(dwFlags & CUDR_NOSNAPTOGRID))
        {
            //
            // Align monitors on 8 pixel boundaries so GDI can use the same
            // brush realization on compatible devices (BIG performance win).
            // Note that we assume the size of a monitor will be in multiples
            // of 8 pixels on X and Y.  We cannot do this for the work areas so
            // we convert them to be relative to the origins of their monitors
            // for the time being.
            //
            // The way we do this alignment is to just do the overlap/gap
            // resoluton in 8 pixel space (ie divide everything by 8 beforehand
            // and multiply it by 8 afterward).
            //
            // Note: WE CAN'T USE MULTDIV HERE because it introduces one-off
            // errors when monitors span the origin.  These become eight-off
            // errors when we scale things back up and we end up trying to
            // create DCs with sizes like 632x472 etc (not too good).  It also
            // handles rounding the wierdly in both positive and negative space
            // and we just want to snap things to a grid so we compensate for
            // truncation differently here.
            //
            for (lprc = arc; lprc < lprcL; lprc++)
            {
                RECT rc;
                int d;


                CopyRect(&rc, lprc);

                d = rc.right - rc.left;

                if (rc.left < 0)
                    rc.left -= 4;
                else
                    rc.left += 3;

                rc.left /= 8;
                rc.right = rc.left + (d / 8);

                d = rc.bottom - rc.top;

                if (rc.top < 0)
                    rc.top -= 4;
                else
                    rc.top += 3;

                rc.top /= 8;
                rc.bottom = rc.top + (d / 8);

                CopyRect(lprc, &rc);
            }
        }

        //
        // RemoveGaps is designed assuming that none of the rectangles that it
        // is passed will overlap.  Thus we cannot safely call it if we have
        // skipped the call to RemoveOverlaps or it might loop forever.
        //
        if (!(dwFlags & CUDR_NORESOLVEPOSITIONS))
        {
            RemoveOverlaps(arc, cCount);

            if (!(dwFlags & CUDR_NOCLOSEGAPS))
            {
                RemoveGaps(arc, cCount);
            }
        }

        if (!(dwFlags & CUDR_NOSNAPTOGRID))
        {
            //
            // Now return the monitor rectangles to pixel units this is a
            // simple multiply and MultDiv doesn't offer us any code size
            // advantage so (I guess that assumes a bit about the compiler,
            // but...) just do it right here.
            //
            for (lprc = arc; lprc < lprcL; lprc++)
            {
                lprc->left   *= 8;
                lprc->top    *= 8;
                lprc->right  *= 8;
                lprc->bottom *= 8;
            }
        }
    }

    if (!(dwFlags & CUDR_NOPRIMARY))
    {
        //
        // Reset all the coordinates based on the primaries position,
        // so that it is always located at 0,0
        //

        LONG dx = -((arc + iPrimary)->left);
        LONG dy = -((arc + iPrimary)->top);

        for (lprc = arc; lprc < lprcL; lprc++)
        {
            OffsetRect(lprc, dx, dy);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\chartran.c ===
/****************************** Module Header ******************************\
* Module Name: chartran.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the routines for translating ACP characters
* to Unicode and translating Unicode characters to ACP characters.
* NOTE: The ACP is the currently installed 8-bit code page.
*
*
* History:
* 08-01-91 GregoryW      Created.
* 05-14-92 GregoryW      Modified to use the Rtl translation routines.
\***************************************************************************/

extern __declspec(dllimport) USHORT NlsAnsiCodePage;

#define IS_ACP(cp) (((cp) == NlsAnsiCodePage) || ((cp) == CP_ACP))

/***************************************************************************\
* WCSToMBEx (API)
*
* Convert a wide-character (Unicode) string to MBCS (ANSI) string.
*
* nAnsiChar > 0 indicates the number of bytes to allocate to store the
*    ANSI string (if bAllocateMem == TRUE) or the size of the buffer
*    pointed to by *pAnsiString (bAllocateMem == FALSE).
*
* nAnsiChar == -1 indicates that the necessary number of bytes be allocated
*    to hold the translated string.  bAllocateMem must be set to TRUE in
*    this case.
*
* Return value
*   Success: number of characters in the output string
*        If bAllocateMem was TRUE, then FreeAnsiString() may be
*        used to free the allocated memory at *ppAnsiString.
*   Failure: 0 means failure
*        (Any buffers allocated by this routine are freed)
*
* History:
*  1992-??-?? GregoryW   Created
*  1993-01-07 IanJa      fix memory leak on error case.
\***************************************************************************/

int
WCSToMBEx(
    WORD wCodePage,
    LPCWSTR pUnicodeString,
    int cchUnicodeString,
    LPSTR *ppAnsiString,
    int nAnsiChar,
    BOOL bAllocateMem)
{
    ULONG nCharsInAnsiString;
#ifdef _USERK_
    INT iCharsInAnsiString;
#endif // _USERK_

    if (nAnsiChar == 0 || cchUnicodeString == 0 || pUnicodeString == NULL) {
        return 0;      // nothing to translate or nowhere to put it
    }

    /*
     * Adjust the cchUnicodeString value.  If cchUnicodeString == -1 then the
     * string pointed to by pUnicodeString is NUL terminated so we
     * count the number of bytes.  If cchUnicodeString < -1 this is an
     * illegal value so we return FALSE.  Otherwise, cchUnicodeString is
     * set and requires no adjustment.
     */
    if (cchUnicodeString == -1) {
        cchUnicodeString = (wcslen(pUnicodeString) + 1);
    } else if (cchUnicodeString < -1) {
        return 0;     // illegal value
    }

    /*
     * Adjust the nAnsiChar value.  If nAnsiChar == -1 then we pick a
     * value based on cchUnicodeString to hold the converted string.  If
     * nAnsiChar < -1 this is an illegal value so we return FALSE.
     * Otherwise, nAnsiChar is set and requires no adjustment.
     */
    if (nAnsiChar == -1) {
        if (bAllocateMem == FALSE) {
            return 0;  // no destination
        }
        nAnsiChar = cchUnicodeString * DBCS_CHARSIZE;
    } else if (nAnsiChar < -1) {
        return 0;     // illegal value
    }

    if (bAllocateMem) {
        /*
         * We need to allocate memory to hold the translated string.
         */
        *ppAnsiString = (LPSTR)UserRtlAllocMem(nAnsiChar);
        if (*ppAnsiString == NULL) {
            return 0;
        }
    }

    /*
     * translate Unicode string pointed to by pUnicodeString into
     * ANSI and store in location pointed to by pAnsiString.  We
     * stop translating when we fill up the ANSI buffer or reach
     * the end of the Unicode string.
     */

    /*
     * if the target multibyte codepage is eqaul to ACP, Call faster Rtl function.
     */
    if (IS_ACP(wCodePage)) {

        NTSTATUS Status;

        Status = RtlUnicodeToMultiByteN(
                        (PCH)*ppAnsiString,
                        nAnsiChar,
                        &nCharsInAnsiString,
                        (PWCH)pUnicodeString,
                        cchUnicodeString * sizeof(WCHAR));
        /*
         * If the ansi buffer is too small, RtlUnicodeToMultiByteN()
         * returns STATUS_BUFFER_OVERFLOW. In this case, the function
         * put as many ansi characters as specified in the buffer and
         *  returns the number by chacacters(in bytes) written. We would
         * like to return the actual byte  count written in the ansi
         * buffer rather than returnning 0 since callers of this function
         * don't expect to be returned 0 in most case.
         */

        if (!NT_SUCCESS(Status) && Status != STATUS_BUFFER_OVERFLOW) {
            if (bAllocateMem) {
                UserRtlFreeMem(*ppAnsiString);
            }
            return 0;   // translation failed
        }

        return (int)nCharsInAnsiString;

    } else {

#ifdef _USERK_
        /*
         * Call GRE to convert string to Unicode. (Kernel mode)
         */

        iCharsInAnsiString = EngWideCharToMultiByte(
                                 (UINT)wCodePage,
                                 (LPWSTR)pUnicodeString,
                                 cchUnicodeString * sizeof(WCHAR),
                                 (LPSTR)*ppAnsiString,
                                 nAnsiChar);

        nCharsInAnsiString = (iCharsInAnsiString == -1) ? 0 :
                                                          (ULONG) iCharsInAnsiString;

#else
        /*
         * Call NLS API (Kernel32) to convert string to Unicode. (User mode)
         */
        nCharsInAnsiString = WideCharToMultiByte(
                                 (UINT)wCodePage, 0,
                                 (LPCWSTR)pUnicodeString,
                                 cchUnicodeString,
                                 (LPSTR)*ppAnsiString,
                                 nAnsiChar,
                                 NULL, NULL);
#endif // _USERK_

        if (nCharsInAnsiString == 0) {
            if (bAllocateMem) {
                UserRtlFreeMem(*ppAnsiString);
            }
        }

        return (int)nCharsInAnsiString;
    }
}

// Returns number of character converted

int MBToWCSEx(
    WORD wCodePage,
    LPCSTR pAnsiString,
    int nAnsiChar,
    LPWSTR *ppUnicodeString,
    int cchUnicodeString,
    BOOL bAllocateMem)
{
    ULONG nBytesInUnicodeString;

    if (nAnsiChar == 0 || cchUnicodeString == 0 || pAnsiString == NULL) {
        return 0;      // nothing to translate or nowhere to put it
    }

    /*
     * Adjust the nAnsiChar value.  If nAnsiChar == -1 then the
     * string pointed to by pAnsiString is NUL terminated so we
     * count the number of bytes.  If nAnsiChar < -1 this is an
     * illegal value so we return FALSE.  Otherwise, nAnsiChar is
     * set and requires no adjustment.
     */

#ifdef _USERK_
    UserAssert(nAnsiChar >= USER_AWCONV_COUNTSTRINGSZ);
#endif
    if (nAnsiChar < 0) {

        /*
         *  Bug 268035 - joejo
         *  Need to fail if the count is a negative number less than -2!
         */
        if (nAnsiChar < USER_AWCONV_COUNTSTRINGSZ) {
            return 0;
        }

#if (USER_AWCONV_COUNTSTRING != -1 || USER_AWCONV_COUNTSTRINGSZ != -2)
#error USER_AWCONV_COUNTSTRING or USER_AWCONV_COUNTSTRINGSZ has unexpected value.
#endif
        /* HACK HACK HACK
         * If nAnsiChar is -1 (USER_AWCONV_COUNTSTRING), nAnsiChar length will be strlen() + 1,
         * to allocate the memory including trailing \0: this is compatible to the original code.
         * If nAnsiCahr is -2 (USER_AWCONV_COUNTSTRINGSZ), memory for trailing \0 will not be needed,
         * so memory allocation is optimized and the return value would be same as strlen().
         */
        nAnsiChar = strlen(pAnsiString) + 2 + nAnsiChar;   // don't forget the NUL if nAnsiChar == -1

        if (nAnsiChar == 0) {
            return 0;
        }
    }

    /*
     * Adjust the cchUnicodeString value.  If cchUnicodeString == -1 then we
     * pick a value based on nAnsiChar to hold the converted string.  If
     * cchUnicodeString < -1 this is an illegal value so we return FALSE.
     * Otherwise, cchUnicodeString is set and requires no adjustment.
     */
    if (cchUnicodeString == -1) {
        if (bAllocateMem == FALSE) {
            return 0;    // no destination
        }
        cchUnicodeString = nAnsiChar;
    } else if (cchUnicodeString < -1) {
        return 0;     // illegal value
    }

    if (bAllocateMem) {
        *ppUnicodeString = (LPWSTR)UserRtlAllocMem(cchUnicodeString*sizeof(WCHAR));
        if (*ppUnicodeString == NULL) {
            return 0;    // allocation failed
        }
    }

    /*
     * if codepage is CP_ACP, We will call faster RtlXXX function.
     */
    if (IS_ACP(wCodePage)) {
        /*
         * translate ANSI string pointed to by pAnsiString into Unicode
         * and store in location pointed to by pUnicodeString.  We
         * stop translating when we fill up the Unicode buffer or reach
         * the end of the ANSI string.
         */
        if (!NT_SUCCESS(RtlMultiByteToUnicodeN(
                            (PWCH)*ppUnicodeString,
                            cchUnicodeString * sizeof(WCHAR),
                            &nBytesInUnicodeString,
                            (PCH)pAnsiString,
                            nAnsiChar
                            ))) {
            if (bAllocateMem) {
                UserRtlFreeMem(*ppUnicodeString);
            }
            return 0;   // translation failed
        }

        return (int)(nBytesInUnicodeString / sizeof(WCHAR));

    } else {
        /*
         * if wCodePage is not ACP, Call NLS API.
         */
        ULONG nCharsInUnicodeString;

#ifdef _USERK_

        /*
         * I believe we will never hit this code which is why I am
         * adding this assert.  [gerritv] 5-21-96
         */
#define SHOULD_NOT_REACH_HERE   0
        UserAssert(SHOULD_NOT_REACH_HERE);
#undef  SHOULD_NOT_REACH_HERE
        return 0;

#if 0   // FYI: old code
        INT   iCharsInUnicodeString;

        /*
         * Call GRE to convert string to Unicode. (Kernel mode)
         * I believe we will never hit this code which is why I am
         * adding this assert.  [gerritv] 5-21-96
         */

        UserAssert(0);

        iCharsInUnicodeString = EngMultiByteToWideChar(
                                    (UINT)wCodePage,
                                    (LPWSTR)*ppUnicodeString,
                                    (int)cchUnicodeString * sizeof(WCHAR),
                                    (LPSTR)pAnsiString,
                                    (int)nAnsiChar);

        nCharsInUnicodeString = (iCharsInUnicodeString == -1) ? 0 :
                                                          (ULONG) iCharsInUnicodeString;
#endif

#else
        /*
         * Call NLS API (Kernel32) to convert string to Unicode. (User mode)
         */
        nCharsInUnicodeString = MultiByteToWideChar(
                                    (UINT)wCodePage, 0,
                                    (LPCSTR)pAnsiString,
                                    (int)nAnsiChar,
                                    (LPWSTR)*ppUnicodeString,
                                    (int)cchUnicodeString);
#endif // _USERK_

        if (nCharsInUnicodeString == 0) {
            if (bAllocateMem) {
                UserRtlFreeMem(*ppUnicodeString);
            }
        }

        return (int)nCharsInUnicodeString;
    }

}


/**************************************************************************\
* RtlWCSMessageWParmCharToMB
*
* Converts a Wide Character to a Multibyte character; in place
* Returns the number of characters converted or zero if failure
*
* 11-Feb-1992  JohnC    Created
\**************************************************************************/

BOOL RtlWCSMessageWParamCharToMB(DWORD msg, WPARAM *pWParam)
{
    DWORD dwAnsi;
    NTSTATUS Status;
    WORD CodePage;
    int nbWch;

#ifdef FE_SB // RtlWCSMessageWParamCharToMB()
    //
    // Format of *pWParam here...
    //
    // LOWORD(*pWParam) = Unicode CodePoint...
    // HIWORD(*pWParam) = Has some information for DBCS messaging
    //                    (ex. WPARAM_IR_DBCSCHAR)
    //
    // Then we need to convert ONLY loword of wParam to Unicode...
    //
#endif // FE_SB
#ifndef FE_SB
    // NtBug #3135 (Closed 02/04/93)
    // Publisher Posts WM_CHAR messages with wParam > 0xFF (not a valid ANSI char)!
    //
    // It does this to disable TranslateAccelerator for that char.
    // MSPub's winproc must get the non-ANSI 'character' value, so PostMessage must
    // translate *two* characters of wParam for character messages, and PeekMessage
    // must translate *two* Unicode chars of wParam for ANSI app.
#endif

    /*
     * Only these messages have CHARs: others are passed through
     */

    switch(msg) {
#ifdef FE_IME // RtlWCSMessageWParamCharToMB()
    case WM_IME_CHAR:
    case WM_IME_COMPOSITION:
#endif // FE_IME
    case WM_CHAR:
    case WM_CHARTOITEM:
    case EM_SETPASSWORDCHAR:
    case WM_DEADCHAR:
    case WM_SYSCHAR:
    case WM_SYSDEADCHAR:
    case WM_MENUCHAR:

        CodePage = THREAD_CODEPAGE();
        dwAnsi = 0;

        nbWch = IS_DBCS_ENABLED() ? 1 * sizeof(WCHAR) : 2 * sizeof(WCHAR);

        if (IS_ACP(CodePage)) {
            // HACK HACK HACK HACK (for NtBug #3135)
            // to allow applications that store data in high word of wParam
            // Jan/06/96 hiroyama
            Status = RtlUnicodeToMultiByteN((LPSTR)&dwAnsi, sizeof(dwAnsi),
                    NULL, (LPWSTR)pWParam, nbWch);
            if (!NT_SUCCESS(Status)) {
                // LATER IanJa: returning FALSE makes GetMessage fail, which
                // terminates the app.  We should use some default 'bad character'
                // I use 0x00 for now.
                *pWParam = 0x00;
                return TRUE;
            }
        } else {
            int cwch;
            // assuming little endian
#ifdef _USERK_
            cwch = EngWideCharToMultiByte(CodePage,
                    (LPWSTR)pWParam, nbWch,
                    (LPSTR)&dwAnsi, sizeof(dwAnsi));
#else
            cwch = WideCharToMultiByte(CodePage, 0,
                    (LPCWSTR)pWParam, nbWch / sizeof(WCHAR),
                    (LPSTR)&dwAnsi, sizeof(dwAnsi), NULL, NULL);
#endif // _USERK_
            // KdPrint(("0x%04x -> 0x%02x (%d)\n", *pWParam, dwAnsi, CodePage));
            if (cwch == 0) {
                *pWParam = 0x00;
                return TRUE;
            }
        }
        if (IS_DBCS_ENABLED()) {
            WORD wAnsi = LOWORD(dwAnsi);
            //
            // From:
            //   HIBYTE(wAnsi)            = Dbcs TrailingByte.
            //   LOBYTE(wAnsi)            = Dbcs LeadingByte or Sbcs character.
            //
            // To:
            //   HIWORD(*pWParam)         = Original Data (information for DBCS messgaing).
            //   HIBYTE(LOWORD(*pWParam)) = Dbcs LeadingByte Byte.
            //   LOBYTE(LOWORD(*pWParam)) = Dbcs TrailingByte or Sbcs character.
            //
            if (IS_DBCS_MESSAGE(wAnsi)) {
                //
                // It's a DBCS character.
                //
                *pWParam = MAKEWPARAM(MAKEWORD(HIBYTE(wAnsi),LOBYTE(wAnsi)),HIWORD(*pWParam));
            } else {
                //
                // It's a SBCS character.
                //
                *pWParam = MAKEWPARAM(MAKEWORD(LOBYTE(wAnsi),0),0);
            }
        } else {
#if DBG
            if ((dwAnsi == 0) || (dwAnsi > 0xFF)) {
                RIPMSG1(RIP_VERBOSE, "msgW -> msgA: char = 0x%.4lX\n", dwAnsi);
            }
#endif
            *pWParam = dwAnsi;
        }
        break;
    }

    return TRUE;
}


/**************************************************************************\
* RtlMBMessageCharToWCS
*
* Converts a Multibyte character to a Wide character; in place
* Returns the number of characters converted or zero if failure
*
* 11-Feb-1992  JohnC    Created
* 13-Jan-1993  IanJa    Translate 2 characters (Publisher posts these!)
\**************************************************************************/

BOOL RtlMBMessageWParamCharToWCS(DWORD msg, WPARAM *pWParam)
{
    DWORD dwUni;
    NTSTATUS Status;
    // FE_SB    (RtlMBMessageWParamCharToWCS)
    BOOL  bWmCrIrDbcsChar = FALSE;
    WORD  wAnsi = LOWORD(*pWParam);
    // end FE_SB    (RtlMBMessageWParamCharToWCS)
    WORD CodePage = THREAD_CODEPAGE();

    /*
     * Only these messages have CHARs: others are passed through
     */

    switch(msg) {
    // FE_SB    (RtlMBMessageWParamCharToWCS)
    case WM_CHAR:
        //
        // WM_CHAR's wParam format for WM_IME_REPORT:IR_DBCSCHAR
        //
        if (IS_DBCS_ENABLED() && (*pWParam & WMCR_IR_DBCSCHAR)) {
            //
            // Mark this message is sent as IR_DBCSCHAR format.
            //
            bWmCrIrDbcsChar = TRUE;
        }

        //
        // Fall through....
        //
#ifdef FE_IME
    case WM_IME_CHAR:
    case WM_IME_COMPOSITION:
        //
        // We need to re-align for Unicode convertsion..
        // WM_CHAR/WM_IME_CHAR/WM_IME_COMPOSITION's wParam format :
        //
        // ReAlign IR_DBCS char format to regular sequence.
        //
        // From:
        //
        //  HIWORD(wParam)         = 0;
        //  HIBYTE(LOWORD(wParam)) = DBCS LeadingByte.
        //  LOBYTE(LOWORD(wParan)) = DBCS TrailingByte or SBCS character.
        //
        // To:
        //  HIWORD(wParam)         = 0;
        //  HIBYTE(LOWORD(wParam)) = DBCS TrailingByte.
        //  LOBYTE(LOWORD(wParam)) = DBCS LeadingByte or SBCS character.
        //
        if (IS_DBCS_ENABLED()) {
            *pWParam = MAKE_WPARAM_DBCSCHAR(wAnsi);
        }
#endif
        //
        // Fall through...
        //
        // end FE_SB    (RtlMBMessageWParamCharToWCS)
    case WM_CHARTOITEM:
    case EM_SETPASSWORDCHAR:
    case WM_DEADCHAR:
    case WM_SYSCHAR:
    case WM_SYSDEADCHAR:
    case WM_MENUCHAR:

        dwUni = 0;

        if (IS_ACP(CodePage)) {
            Status = RtlMultiByteToUnicodeN((LPWSTR)&dwUni, sizeof(dwUni),
                    NULL, (LPSTR)pWParam, 2 * sizeof(CHAR));
            if (!NT_SUCCESS(Status))
                return FALSE;
        } else {
            int cwch;
#ifdef _USERK_
            cwch = EngMultiByteToWideChar(CodePage,
                    (LPWSTR)&dwUni, sizeof(dwUni),
                    (LPSTR)pWParam, 2);
#else
            cwch = MultiByteToWideChar(CodePage, 0,
                    (LPSTR)pWParam, 2,
                    (LPWSTR)&dwUni, sizeof(dwUni) / sizeof(WCHAR));
#endif // _USERK_
            // KdPrint(("0x%02x -> 0x%04x (%d)\n", *pWParam, dwUni, CodePage));
            if (cwch == 0) {
                return FALSE;
            }
        }

        // FE_SB    (RtlMBMessageWParamCharToWCS)
        //
        // if this character is sent for WM_IME_REPORT:IR_DBCSCHAR, we mark it.
        //
        if (bWmCrIrDbcsChar)
            dwUni |= WMCR_IR_DBCSCHAR;
        // else FE_SB (RtlMBMessageWParamCharToWCS)
#if DBG
        if ((dwUni == 0) || (dwUni > 0xFF)) {
            RIPMSG1(RIP_VERBOSE, "msgA -> msgW: wchar = 0x%lX\n", dwUni);
        }
#endif
        // end FE_SB
        *pWParam = dwUni;
        break;
    }

    return TRUE;
}

/**************************************************************************\
* RtlInitLargeAnsiString
*
* Captures a large ANSI string in the same manner as
* RtlInitAnsiString.
*
* 03-22-95 JimA         Created.
\**************************************************************************/

VOID RtlInitLargeAnsiString(
    PLARGE_ANSI_STRING plstr,
    LPCSTR psz,
    UINT cchLimit)
{
    ULONG Length;

    plstr->Buffer = (PSTR)psz;
    plstr->bAnsi = TRUE;
    if (ARGUMENT_PRESENT( psz )) {
        Length = strlen( psz );
        plstr->Length = min(Length, cchLimit);
        plstr->MaximumLength = min((Length + 1), cchLimit);
    } else {
        plstr->MaximumLength = 0;
        plstr->Length = 0;
    }
}

/**************************************************************************\
* RtlInitLargeUnicodeString
*
* Captures a large unicode string in the same manner as
* RtlInitUnicodeString.
*
* 03-22-95 JimA         Created.
\**************************************************************************/

VOID RtlInitLargeUnicodeString(
    PLARGE_UNICODE_STRING plstr,
    LPCWSTR psz,
    UINT cchLimit)
{
    ULONG Length;

    plstr->Buffer = (PWSTR)psz;
    plstr->bAnsi = FALSE;
    if (ARGUMENT_PRESENT( psz )) {
        Length = wcslen( psz ) * sizeof( WCHAR );
        plstr->Length = min(Length, cchLimit);
        plstr->MaximumLength = min((Length + sizeof(UNICODE_NULL)), cchLimit);
    } else {
        plstr->MaximumLength = 0;
        plstr->Length = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\wmicon.c ===
/***************************************************************************\
* Module Name: wmicon.c
*
* Icon Drawing Routines
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* 22-Jan-1991 MikeKe  from win30
* 13-Jan-1994 JohnL   rewrote from Chicago (m5)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define GetCWidth(cxOrg, lrF, cxDes) \
    (cxOrg ? cxOrg : ((lrF & DI_DEFAULTSIZE) ? SYSMET(CXICON) : cxDes))

#define GetCHeight(cyOrg, lrF, cyDes) \
    (cyOrg ? cyOrg : ((lrF & DI_DEFAULTSIZE) ? SYSMET(CYICON) : cyDes))

/***************************************************************************\
* BltIcon
*
* Note: We use the following DI flags to indicate what bitmap to draw:
* DI_IMAGE - render the color image bits (also known as XOR image)
* DI_MASK - render the mask bits (also known and AND image)
* DI_NORMAL - even though this is normally used to indicate that both the
*             mask and the image pieces of the icon should be rendered, it
*             is used here to indicate that the alpha channel should be
*             rendered.  See _DrawIconEx.
\***************************************************************************/
BOOL BltIcon(
    HDC     hdc,
    int     x,
    int     y,
    int     cx,
    int     cy,
    HDC     hdcSrc,
    PCURSOR pcur,
    UINT    diFlag,
    LONG    rop)
{
    HBITMAP hbmpSave;
    HBITMAP hbmpUse;
    LONG    rgbText;
    LONG    rgbBk;
    int     nMode;
    int     yBlt = 0;

    /*
     * Setup the DC for drawing
     */
    switch (diFlag) {
    default:
    case DI_IMAGE:
        hbmpUse = pcur->hbmColor;

        /*
         * If there isn't an explicit color bitmap, it is encoded
         * along with the mask, but in the second half.
         */
        if (NULL == hbmpUse) {
            hbmpUse = pcur->hbmMask;
            yBlt = pcur->cy / 2;
        }
        break;

    case DI_MASK:
        hbmpUse = pcur->hbmMask;
        break;

    case DI_NORMAL:
        UserAssert(pcur->hbmUserAlpha != NULL);
        hbmpUse = pcur->hbmUserAlpha;
        break;
    }

    rgbBk   = GreSetBkColor(hdc, 0x00FFFFFFL);
    rgbText = GreSetTextColor(hdc, 0x00000000L);
    nMode   = SetBestStretchMode(hdc, pcur->bpp, FALSE);

    hbmpSave = GreSelectBitmap(hdcSrc, hbmpUse);

    if (diFlag == DI_NORMAL) {
        BLENDFUNCTION bf;
        bf.BlendOp = AC_SRC_OVER;
        bf.BlendFlags = AC_MIRRORBITMAP;
        bf.SourceConstantAlpha = 0xFF;
        bf.AlphaFormat = AC_SRC_ALPHA;

        GreAlphaBlend(hdc,
                      x,
                      y,
                      cx,
                      cy,
                      hdcSrc,
                      0,
                      yBlt,
                      pcur->cx,
                      pcur->cy / 2,
                      bf,
                      NULL);
    }
    else {
        /*
         * Do the output to the surface.  By passing in (-1) as the background
         * color, we are telling GDI to use the background-color already set
         * in the DC.
         */
        GreStretchBlt(hdc,
                      x,
                      y,
                      cx,
                      cy,
                      hdcSrc,
                      0,
                      yBlt,
                      pcur->cx,
                      pcur->cy / 2,
                      rop,
                      (COLORREF)-1);
    }

    GreSetStretchBltMode(hdc, nMode);
    GreSetTextColor(hdc, rgbText);
    GreSetBkColor(hdc, rgbBk);

    GreSelectBitmap(hdcSrc, hbmpSave);

    return TRUE;
}

/***************************************************************************\
* DrawIconEx
*
* Draws icon in desired size.
*
\***************************************************************************/
BOOL _DrawIconEx(
    HDC     hdc,
    int     x,
    int     y,
    PCURSOR pcur,
    int     cx,
    int     cy,
    UINT    istepIfAniCur,
    HBRUSH  hbr,
    UINT    diFlags)
{
    BOOL fSuccess = FALSE;
    BOOL fAlpha = FALSE;
    LONG rop = (diFlags & DI_NOMIRROR) ? NOMIRRORBITMAP : 0;

    /*
     * If this is an animated cursor, just grab the ith frame and use it
     * for drawing.
     */
    if (pcur->CURSORF_flags & CURSORF_ACON) {

        if ((int)istepIfAniCur >= ((PACON)pcur)->cicur) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "DrawIconEx, icon step out of range.");
            goto Done;
        }

        pcur = ((PACON)pcur)->aspcur[((PACON)pcur)->aicur[istepIfAniCur]];
    }

    /*
     * We really want to draw an alpha icon if we can.  But we need to
     * respect the user's request to draw only the image or only the
     * mask.  We decide if we are, or are not, going to draw the icon
     * with alpha information here.
     */
    if (pcur->hbmUserAlpha != NULL && ((diFlags & DI_NORMAL) == DI_NORMAL)) {
        fAlpha = TRUE;
    }

    /*
     * Setup defaults.
     */
    cx = GetCWidth(cx, diFlags, pcur->cx);
    cy = GetCHeight(cy, diFlags, (pcur->cy / 2));

    if (hbr) {

        HBITMAP    hbmpT = NULL;
        HDC        hdcT;
        HBITMAP    hbmpOld;
        POLYPATBLT PolyData;

        if (hdcT = GreCreateCompatibleDC(hdc)) {

            if (hbmpT = GreCreateCompatibleBitmap(hdc, cx, cy)) {
                POINT pt;
                BOOL bRet;

                hbmpOld = GreSelectBitmap(hdcT, hbmpT);

                /*
                 * Set new dc's brush origin in same relative
                 * location as passed-in dc's.
                 */
                bRet = GreGetBrushOrg(hdc, &pt);
                /*
                 * Bug 292396 - joejo
                 * Stop overactive asserts by replacing with RIPMSG.
                 */
                if (bRet != TRUE) {
                    RIPMSG0(RIP_WARNING, "DrawIconEx, GreGetBrushOrg failed.");
                }

                bRet = GreSetBrushOrg(hdcT, pt.x, pt.y, NULL);
                if (bRet != TRUE) {
                    RIPMSG0(RIP_WARNING, "DrawIconEx, GreSetBrushOrg failed.");
                }

                PolyData.x         = 0;
                PolyData.y         = 0;
                PolyData.cx        = cx;
                PolyData.cy        = cy;
                PolyData.BrClr.hbr = hbr;

                bRet = GrePolyPatBlt(hdcT, PATCOPY, &PolyData, 1, PPB_BRUSH);
                if (bRet != TRUE) {
                    RIPMSG0(RIP_WARNING, "DrawIconEx, GrePolyPatBlt failed.");
                }
                
                /*
                 * Output the image to the temporary memoryDC.
                 */
                if (fAlpha) {
                    BltIcon(hdcT, 0, 0, cx, cy, ghdcMem, pcur, DI_NORMAL, rop | SRCCOPY);
                }
                else {
                    BltIcon(hdcT, 0, 0, cx, cy, ghdcMem, pcur, DI_MASK, rop | SRCAND);
                    BltIcon(hdcT, 0, 0, cx, cy, ghdcMem, pcur, DI_IMAGE, rop | SRCINVERT);
                }


                /*
                 * Blt the bitmap to the original DC.
                 */
                GreBitBlt(hdc, x, y, cx, cy, hdcT, 0, 0, SRCCOPY, (COLORREF)-1);

                GreSelectBitmap(hdcT, hbmpOld);

                bRet = GreDeleteObject(hbmpT);
                if (bRet != TRUE) {
                    RIPMSG0(RIP_WARNING, "DrawIconEx, GreDeleteObject failed. Possible Leak");
                }
                
                fSuccess = TRUE;
            }

            GreDeleteDC(hdcT);
        }

    } else {
        if (fAlpha) {
            BltIcon(hdc, x, y, cx, cy, ghdcMem, pcur, DI_NORMAL, rop | SRCCOPY);
        } else {
            if (diFlags & DI_MASK) {

                BltIcon(hdc,
                        x,
                        y,
                        cx,
                        cy,
                        ghdcMem,
                        pcur,
                        DI_MASK,
                        ((diFlags & DI_IMAGE) ? rop | SRCAND : rop | SRCCOPY));
            }

            if (diFlags & DI_IMAGE) {

                BltIcon(hdc,
                        x,
                        y,
                        cx,
                        cy,
                        ghdcMem,
                        pcur,
                        DI_IMAGE,
                        ((diFlags & DI_MASK) ? rop | SRCINVERT : rop | SRCCOPY));
            }
        }

        fSuccess = TRUE;
    }

Done:

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\draw.c ===
/****************************** Module Header ******************************\
* Module Name: draw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains common drawing functions.
*
* History:
* 12-Feb-1992 MikeKe    Moved Drawtext to the client side
\***************************************************************************/


CONST WCHAR szRadio[] = L"nmlkji";
CONST WCHAR szCheck[] = L"gfedcb";

/***************************************************************************\
* FlipUserTextOutW
*
* Flip the check mark if the hdc is mirrored otherwise it just calls UserTextOutW
*
\***************************************************************************/
BOOL FlipUserTextOutW(HDC hdc, int x, int y, LPCWSTR ch, int nCount)
{
    BOOL bRet;
    int iOldTextAlign, iGraphicsModeOld;

    if ((UserGetLayout(hdc) & LAYOUT_RTL) &&
        (nCount == 1) &&
        ((ch[0] == TEXT('a')) ||(ch[0] == TEXT('b')))
       )
    {
        bRet = FALSE;

        //Check mark then set the hdc in GM_COMPATIBLE to unmirror it.
        if (iGraphicsModeOld = UserSetGraphicsMode(hdc, GM_COMPATIBLE))
        {
            iOldTextAlign = UserGetTextAlign(hdc);
            if ((iOldTextAlign & TA_CENTER) != TA_CENTER)
            {
                UserSetTextAlign(hdc, iOldTextAlign^TA_RIGHT);
            }
            bRet = UserTextOutW(hdc, x, y, ch, nCount);
            UserSetGraphicsMode(hdc, iGraphicsModeOld);
            UserSetTextAlign(hdc, iOldTextAlign);
        }
    } else {
        bRet = UserTextOutW(hdc, x, y, ch, nCount);
    }

    return bRet;
}
/***************************************************************************\
* FillRect
*
* Callable from either client or server contexts
*
* History:
* 29-Oct-1990 MikeHar   Ported from Windows.
\***************************************************************************/

int APIENTRY FillRect(
    HDC     hdc,
    LPCRECT prc,
    HBRUSH  hBrush)
{
    ULONG_PTR   iBrush;
    POLYPATBLT PolyData;

    iBrush = (ULONG_PTR)hBrush - 1;
    if (iBrush <= COLOR_ENDCOLORS) {
        hBrush = SYSHBRUSH(iBrush);
    }

    PolyData.x         = prc->left;
    PolyData.y         = prc->top;
    PolyData.cx        = prc->right - prc->left;
    PolyData.cy        = prc->bottom - prc->top;
    PolyData.BrClr.hbr = hBrush;

    /*
     * Win95 incompatibility: they return either hBrush or the brush that
     * was previosuly selected in hdc. Not documented this way though.
     */
    return UserPolyPatBlt(hdc, PATCOPY, &PolyData, 1, PPB_BRUSH);
}

/***************************************************************************\
* InvertRect
*
* Can be called from either the client or server contexts.
*
* History:
* 29-Oct-1990 MikeHar   Ported from Windows.
\***************************************************************************/

BOOL APIENTRY InvertRect(
    HDC     hdc,
    LPCRECT prc)
{
    return UserPatBlt(hdc,
                      prc->left,
                      prc->top,
                      prc->right - prc->left,
                      prc->bottom - prc->top,
                      DSTINVERT);
}

/***************************************************************************\
* DrawDiagonalLine
*
* History:
\***************************************************************************/

DWORD DrawDiagonalLine(
    HDC    hdc,
    LPRECT lprc,
    int    iDirection,
    int    iThickness,
    UINT   flags)
{
    RECT    rc;
    LPINT   py;
    int     cx;
    int     cy;
    int     dx;
    int     dy;
    LPINT   pc;

    POLYPATBLT ppbData[8];
    int        ppbCount = 0;

    if (IsRectEmpty(lprc))
        return 0L;

    rc = *lprc;

    /*
     * We draw slopes < 1 by varying y instead of x.
     */
    --iThickness;

    /*
     * See WinBug #139374
     */
    cy = rc.bottom - rc.top;
    cx = rc.right - rc.left;

    if (!flags && (cy != cx))
        cy -= iThickness * SYSMETRTL(CYBORDER);

    if (cy >= cx) {

        /*
         * "slope" is >= 1, so vary x by 1
         */
        cy /= cx;
        pc = &cy;

        cx = SYSMETRTL(CXBORDER);

    } else {

        /*
         * "slope" is < 1, so vary y by 1
         */
        cx /= cy;
        pc = &cx;

        cy = SYSMETRTL(CYBORDER);
    }

    dx = cx;
    dy = iDirection * cy;

    *pc = (*pc + iThickness) * SYSMETRTL(CYBORDER);

    rc.right  -= cx;
    rc.bottom -= cy;

    /*
     * For negative slopes, start from opposite side.
     */
    py = ((iDirection < 0) ? &rc.top : &rc.bottom);

    while ((rc.left <= rc.right) && (rc.top <= rc.bottom)) {

        if (!(flags & BF_MIDDLE)) {

            /*
             * UserPatBlt(hdc, rc.left, *py, cx, cy, PATCOPY);
             */

            ppbData[ppbCount].x         = rc.left;
            ppbData[ppbCount].y         = *py;
            ppbData[ppbCount].cx        = cx;
            ppbData[ppbCount].cy        = cy;
            ppbData[ppbCount].BrClr.hbr = NULL;

            ppbCount++;

        } else {

            /*
             * Fill interior.  We can determine vertex in interior
             * by vector define.
             */
            if (cy > SYSMETRTL(CYBORDER)) {

                if (flags & BF_LEFT) {

                    /*
                     * UserPatBlt(hdc, rc.left, lprc->top, cx, *py - lprc->top + cy, PATCOPY);
                     */

                    ppbData[ppbCount].x         = rc.left;
                    ppbData[ppbCount].y         = lprc->top;
                    ppbData[ppbCount].cx        = cx;
                    ppbData[ppbCount].cy        = *py - lprc->top + cy;
                    ppbData[ppbCount].BrClr.hbr = NULL;

                    ppbCount++;

                } else {
                    /*
                     * UserPatBlt(hdc, rc.left, *py, cx, lprc->bottom - *py, PATCOPY);
                     */

                    ppbData[ppbCount].x          = rc.left;
                    ppbData[ppbCount].y          = *py;
                    ppbData[ppbCount].cx         = cx;
                    ppbData[ppbCount].cy         = lprc->bottom - *py;
                    ppbData[ppbCount].BrClr.hbr  = NULL;

                    ppbCount++;
                }

            } else {

                if (flags & BF_TOP) {

                    /*
                     * UserPatBlt(hdc, rc.left, *py, lprc->right - rc.left, cy, PATCOPY);
                     */

                    ppbData[ppbCount].x          = rc.left;
                    ppbData[ppbCount].y          = *py;
                    ppbData[ppbCount].cx         = lprc->right - rc.left;
                    ppbData[ppbCount].cy         = cy;
                    ppbData[ppbCount].BrClr.hbr  = NULL;

                    ppbCount++;

                } else {
                    /*
                     * UserPatBlt(hdc, lprc->left, *py, rc.left - lprc->left + cx, cy, PATCOPY);
                     */

                    ppbData[ppbCount].x          = lprc->left;
                    ppbData[ppbCount].y          = *py;
                    ppbData[ppbCount].cx         = rc.left - lprc->left + cx;
                    ppbData[ppbCount].cy         = cy;
                    ppbData[ppbCount].BrClr.hbr  = NULL;

                    ppbCount++;

                }
            }
        }

        rc.left += dx;
        *py     -= dy;

        /*
         * do we need to flush PolyPatBlt ?
         */
        if (ppbCount == 8) {
            UserPolyPatBlt(hdc, PATCOPY, &ppbData[0], 8, PPB_BRUSH);
            ppbCount = 0;
        }
    }

    /*
     * any left-over PolyPatblt buffered operations?
     */
    if (ppbCount != 0) {
        UserPolyPatBlt(hdc, PATCOPY, &ppbData[0], ppbCount, PPB_BRUSH);
    }

    return MAKELONG(cx, cy);
}

/***************************************************************************\
* FillTriangle
*
* Fills in the triangle whose sides are two rectangle edges and a
* diagonal.  The vertex in the interior can be determined from the
* vector type.
*
* History:
\***************************************************************************/

BOOL FillTriangle(
    HDC    hdc,
    LPRECT lprc,
    HBRUSH hbr,
    UINT   flags)
{
    HBRUSH hbrT;
    int    nDirection;

    switch (flags & (BF_RECT | BF_DIAGONAL)) {

    case BF_DIAGONAL_ENDTOPLEFT:
    case BF_DIAGONAL_ENDBOTTOMRIGHT:
        nDirection = -1;
        break;

    default:
        nDirection = 1;
        break;
    }
    hbrT = UserSelectBrush(hdc, hbr);
    DrawDiagonalLine(hdc, lprc, nDirection, 1, flags);
    /*
     * Don't care if the above functions failed for a bad hdc
     */
    return (UserSelectBrush(hdc, hbrT) != NULL);
}

/***************************************************************************\
* DrawDiagonal
*
* Called by DrawEdge() for BF_DIAGONAL edges.
*
* Draws line of slope 1, one of 4 different ones.  The difference is
* where the line starts and where the end point is.  The BF_ flags for
* BF_DIAGONAL specify where the end point is.  For example, BF_DIAGONAL |
* BF_TOP | BF_LEFT means to draw a line ending up at the top left corner.
* So the origin must be bottom right, and the angle must be 3pi/4, or
* 135 degrees.
*
* History:
\***************************************************************************/

BOOL DrawDiagonal(
    HDC    hdc,
    LPRECT lprc,
    HBRUSH hbrTL,
    HBRUSH hbrBR,
    UINT   flags)
{
    HBRUSH  hbrT;
    int     nDirection;
    DWORD   dAdjust;

    /*
     * Away from light source
     */
    hbrT = ((flags & BF_BOTTOM) ? hbrBR : hbrTL);

    switch (flags & (BF_RECT | BF_DIAGONAL)){

    case BF_DIAGONAL_ENDTOPLEFT:
    case BF_DIAGONAL_ENDBOTTOMRIGHT:
        nDirection = -1;
        break;

    default:
        nDirection = 1;
        break;
    }

    hbrT = UserSelectBrush(hdc, hbrT);
    dAdjust = DrawDiagonalLine(hdc, lprc, nDirection, 1, (flags & ~BF_MIDDLE));
    /*
     * Adjust rectangle for next border
     */
    if (flags & BF_TOP)
        lprc->left += LOWORD(dAdjust);
    else
        lprc->right -= LOWORD(dAdjust);

    if (flags & BF_RIGHT)
        lprc->top += HIWORD(dAdjust);
    else
        lprc->bottom -= HIWORD(dAdjust);

    /*
     * Moved this to the end to save a check for return value
     */
    return (UserSelectBrush(hdc, hbrT) != NULL);
}

/***************************************************************************\
* DrawGrip
*
* History:
\***************************************************************************/

BOOL DrawGrip(
    HDC    hdc,
    LPRECT lprc,
    UINT   wState)
{
    int        x;
    int        y;
    int        c;
    HBRUSH     hbrOld;
    DWORD      rgbHilight;
    DWORD      rgbShadow;
    DWORD      rgbOld;
    POLYPATBLT PolyData;

    c = min((lprc->right - lprc->left), (lprc->bottom - lprc->top));
    x = lprc->right  - c;    // right justify
    y = lprc->bottom - c;    // bottom justify

    /*
     * Setup colors
     */
    if (wState & (DFCS_FLAT | DFCS_MONO)) {
        hbrOld = SYSHBR(WINDOW);
        rgbHilight = SYSRGBRTL(WINDOWFRAME);
        rgbShadow = SYSRGBRTL(WINDOWFRAME);
    } else {
        hbrOld = SYSHBR(3DFACE);
        rgbHilight = SYSRGBRTL(3DHILIGHT);
        rgbShadow = SYSRGBRTL(3DSHADOW);
    }

    PolyData.x         = lprc->left;
    PolyData.y         = lprc->top;
    PolyData.cx        = lprc->right-lprc->left;
    PolyData.cy        = lprc->bottom-lprc->top;
    PolyData.BrClr.hbr = hbrOld;
    UserPolyPatBlt(hdc, PATCOPY, &PolyData, 1, PPB_BRUSH);

    rgbOld = UserSetTextColor(hdc, rgbHilight);

    if (wState & DFCS_SCROLLSIZEGRIPRIGHT) {
        UserTextOutW(hdc, x, y, L"x", 1);
        UserSetTextColor(hdc, rgbShadow);
        UserTextOutW(hdc, x, y, L"y", 1);
    } else {
        UserTextOutW(hdc, x, y, L"o", 1);
        UserSetTextColor(hdc, rgbShadow);
        UserTextOutW(hdc, x, y, L"p", 1);
    }

    UserSetTextColor(hdc, rgbOld);
    return TRUE;
}

/***************************************************************************\
* DrawBox
*
* History:
\***************************************************************************/

BOOL DrawBox(
    HDC    hdc,
    LPRECT lprc,
    UINT   wControlState)
{
    int      cx;
    int      cy;
    int      c;
    int      x;
    int      y;
    LPCWSTR  lp = szRadio;
    int      i;
    BOOL     fSkip0thItem;
    COLORREF clr[6];
    COLORREF clrOld;

    fSkip0thItem = ((wControlState & (DFCS_BUTTON3STATE | DFCS_PUSHED |
        DFCS_INACTIVE | DFCS_CHECKED)) == (DFCS_BUTTON3STATE | DFCS_CHECKED));

    /*
     * Don't need radio mask with marlett font!
     */
    if (wControlState & DFCS_BUTTONRADIOMASK) {

        clr[0] = clr[1] = clr[2] = clr[3] = clr[4] = 0L;
        FillRect(hdc, lprc, ghbrWhite);

    } else {

        /*
         * DFCS_BUTTONRADIOIMAGE
         */
        if (wControlState & (DFCS_MONO | DFCS_FLAT)) {
            clr[1] = clr[2] = clr[3] = clr[4] = SYSRGBRTL(WINDOWFRAME);
        } else {
            clr[1] = SYSRGBRTL(3DLIGHT);
            clr[2] = SYSRGBRTL(3DDKSHADOW);
            clr[3] = SYSRGBRTL(3DHILIGHT);
            clr[4] = SYSRGBRTL(3DSHADOW);
        }


        if (wControlState & (DFCS_PUSHED | DFCS_INACTIVE))
            clr[0] = SYSRGBRTL(3DFACE);
        else if (fSkip0thItem)
            clr[0] = SYSRGBRTL(3DHILIGHT);
        else
            clr[0] = SYSRGBRTL(WINDOW);

        if (wControlState & DFCS_BUTTONRADIOIMAGE)
            FillRect(hdc, lprc, ghbrBlack);
        else if (!(wControlState & DFCS_BUTTONRADIO))
            lp = szCheck;
    }

    cx = lprc->right - lprc->left;
    cy = lprc->bottom - lprc->top;

    c = min(cx,cy);
    x = lprc->left + ((cx - c) / 2); // - 1;
    y = lprc->top  + ((cy - c) / 2);

    if (fSkip0thItem &&
        ((gpsi->BitCount < 8) || (SYSRGB(3DHILIGHT) == RGB(255,255,255)))) {

        COLORREF   clrBk;
        POLYPATBLT PolyData;

         /*
          * Make the interior of a 3State checkbox which is just checked a
          * dither, just like an indeterminate push button which is pressed.
          */
         clrBk  = UserSetBkColor(hdc, SYSRGB(3DHILIGHT));
         clrOld = UserSetTextColor(hdc, SYSRGB(3DFACE));

         PolyData.x         = x;
         PolyData.y         = y;
         PolyData.cx        = cx;
         PolyData.cy        = cy;
         PolyData.BrClr.hbr = gpsi->hbrGray;
         UserPolyPatBlt(hdc, PATCOPY, &PolyData, 1, PPB_BRUSH);

         UserSetBkColor(hdc, clrBk);

    } else {
        clrOld = UserSetTextColor(hdc, clr[0]);
        UserTextOutW(hdc, x, y, lp, 1);
    }

    lp++;

    for (i = 1; i < 5; i++) {
        UserSetTextColor(hdc, clr[i]);
        UserTextOutW(hdc, x, y, lp++, 1);
    }

    if (wControlState & DFCS_CHECKED) {
        COLORREF clrCheck;

        if (wControlState & (DFCS_BUTTON3STATE | DFCS_INACTIVE)) {
            clrCheck = SYSRGBRTL(3DSHADOW);
        } else if (wControlState & DFCS_HOT) {
            clrCheck = SYSRGBRTL(HOTLIGHT);
        } else {
            clrCheck = SYSRGBRTL(WINDOWTEXT);
        }

        UserSetTextColor(hdc, clrCheck);
        FlipUserTextOutW(hdc, x, y, lp, 1);
    }

    UserSetTextColor(hdc, clrOld);

    return TRUE;
}
/***************************************************************************\
* GetCaptionChar
*
* History:
* 04/02/97 GerardoB Created
\***************************************************************************/
WCHAR GetCaptionChar (UINT wState)
{
    wState &= DFCS_CAPTIONALL;
    switch (wState) {
    case DFCS_CAPTIONCLOSE:
        return TEXT('r');
    case DFCS_CAPTIONMIN:
        return TEXT('0');
    case DFCS_CAPTIONMAX:
        return TEXT('1');
    case DFCS_CAPTIONRESTORE:
        return TEXT('2');
    /* case DFCS_CAPTIONHELP: */
    default:
        return TEXT('s');
    }
}
/***************************************************************************\
* DrawMenuMark
*
* History:
\***************************************************************************/

BOOL DrawMenuMark(
    HDC    hdc,
    LPRECT lprc,
    UINT   wType,
    UINT   wState)
{
    COLORREF rgbOld;
    int      x;
    int      y;
    int      c;
    int      cx;
    int      cy;
    WCHAR    ch;

    cx = lprc->right - lprc->left;
    cy = lprc->bottom - lprc->top;

    c = min(cx,cy);
    x = lprc->left + ((cx - c) / 2) - ((cx > 0xb) ? 1 : 0);
    y = lprc->top  + ((cy - c) / 2);

    FillRect(hdc, lprc, ghbrWhite);

    rgbOld = UserSetTextColor(hdc, 0L);

    if (wType == DFC_MENU) {
        if (wState & DFCS_MENUCHECK) {
            ch = TEXT('a');
        } else if (wState & DFCS_MENUBULLET) {
            ch = TEXT('h');
        } else if (wState & DFCS_MENUARROWRIGHT) {
            ch = TEXT('w');
        } else {
            ch = TEXT('8');
        }
    } else {
        UserAssert(wType == DFC_POPUPMENU);
        ch = GetCaptionChar(wState);
    }

    FlipUserTextOutW(hdc, x, y, &ch, 1);
    UserSetTextColor(hdc, rgbOld);

    return TRUE;
}

/***************************************************************************\
* DrawIt
*
* History:
\***************************************************************************/

BOOL DrawIt(
    HDC    hdc,
    LPRECT lprc,
    UINT   wState,
    WCHAR  ch)
{
    COLORREF rgb;
    int      x;
    int      y;
    int      c;
    int      cx;
    int      cy;
    BOOL     fDrawDisabled = wState & DFCS_INACTIVE;

    cx = lprc->right - lprc->left;
    cy = lprc->bottom - lprc->top;

    c = min(cx,cy);
    x = lprc->left + ((cx - c) / 2);
    y = lprc->top  + ((cy - c) / 2);

    if (fDrawDisabled) {
        rgb = SYSRGBRTL(3DHILIGHT);
    } else if (wState & DFCS_HOT) {
        rgb = SYSRGBRTL(HOTLIGHT);
    } else {
        rgb = SYSRGBRTL(BTNTEXT);
    }

    rgb = UserSetTextColor(hdc, rgb);

    if (wState & (DFCS_INACTIVE | DFCS_PUSHED)) {
        x++;
        y++;
    }

    UserTextOutW(hdc, x, y, &ch, 1);

    if (fDrawDisabled) {
        UserSetTextColor(hdc, SYSRGBRTL(3DSHADOW));
        UserTextOutW(hdc, x - 1, y - 1, &ch, 1);
    }

    UserSetTextColor(hdc, rgb);

    return TRUE;
}

/***************************************************************************\
* DrawScrollArrow
*
* History:
\***************************************************************************/

BOOL DrawScrollArrow(
    HDC    hdc,
    LPRECT lprc,
    UINT   wControlState)
{
    WCHAR ch = (wControlState & DFCS_SCROLLHORZ) ? TEXT('3') : TEXT('5');

    if (wControlState & DFCS_SCROLLMAX)
        ch++;

    return DrawIt(hdc, lprc, wControlState, ch);
}


/***************************************************************************\
* DrawFrameControl
*
* History:
*   03-March-2001  Mohamed  Hooked API and created this wrapper.
\***************************************************************************/
FUNCLOG4(
    LOG_GENERAL,
    BOOL,
    DUMMYCALLINGTYPE,
    DrawFrameControl,
    HDC,
    hdc,
    LPRECT,
    lprc,
    UINT,
    wType,
    UINT,
    wState)
BOOL DrawFrameControl(
    HDC    hdc,
    LPRECT lprc,
    UINT   wType,
    UINT   wState)
{

/*
 * There is a note here about the use of _USERK_.  DrawFrameControl is present
 * both in kernel and user mode.  Kernel side is not aware of UAH and therefore
 * this directive protects the kernel side by eliminating all wrappers 
 * and UAH-related code from the kernel version and only exposing it during 
 * the build for user mode.
 */

#ifndef _USERK_     // Eliminate UAH code in kernel build.

    BOOL bRet;

    BEGIN_USERAPIHOOK()
        bRet = guah.pfnDrawFrameControl(hdc, lprc, wType, wState);
    END_USERAPIHOOK()

    return bRet;
}


/***************************************************************************\
* RealDrawFrameControl
*
* History:
*   03-March-2001  Mohamed  Hooked this API and changed to Real*
\***************************************************************************/

BOOL RealDrawFrameControl(
    HDC    hdc,
    LPRECT lprc,
    UINT   wType,
    UINT   wState)
{

#endif              // _USERK_

    RECT     rc;
    HFONT    hFont;
    HFONT    hOldFont;
    BOOL     fRet = TRUE;
    int      iOldBk;
    int      c;
    BOOL     fButton = FALSE;
    LOGFONTW lfw;
    int      iGraphicsModeOld = 0;
    int      iOldTextAlign;

    rc = *lprc;

    /*
     * If the hdc is mirrored then set it in GM_ADVANCED mode
     * to enforce the text to be mirrored.
     */
    if (UserGetLayout(hdc) & LAYOUT_RTL) {
        if (iGraphicsModeOld = UserSetGraphicsMode(hdc, GM_ADVANCED))
        {
            iOldTextAlign = UserGetTextAlign(hdc);
            if ((iOldTextAlign & TA_CENTER) != TA_CENTER)
            {
                UserSetTextAlign(hdc, iOldTextAlign^TA_RIGHT);
            }
        }
    }

    /*
     * Enforce monochrome/flat
     */
    if (gpsi->BitCount == 1)
        wState |= DFCS_MONO;

    if (wState & DFCS_MONO)
        wState |= DFCS_FLAT;

    if ((wType != DFC_MENU)
            && (wType != DFC_POPUPMENU)
            && ((wType != DFC_BUTTON) || (wState & DFCS_BUTTONPUSH))
            && ((wType != DFC_SCROLL)
                || !(wState & (DFCS_SCROLLSIZEGRIP | DFCS_SCROLLSIZEGRIPRIGHT))))
    {
        UINT wBorder = BF_ADJUST;

        if (wType != DFC_SCROLL)
            wBorder |= BF_SOFT;

        UserAssert(DFCS_FLAT == BF_FLAT);
        UserAssert(DFCS_MONO == BF_MONO);

        wBorder |= (wState & (DFCS_FLAT | DFCS_MONO));

        DrawPushButton(hdc, &rc, wState, wBorder);

        if (wState & DFCS_ADJUSTRECT)
            *lprc = rc;

        fButton = TRUE;
    }

    iOldBk = UserSetBkMode(hdc, TRANSPARENT);
    if (!iOldBk) {
        /*
         * return FALSE if the hdc is bogus
         */
        if (iGraphicsModeOld) {
            UserSetGraphicsMode(hdc, iGraphicsModeOld);
            UserSetTextAlign(hdc, iOldTextAlign);
        }
        return FALSE;
    }

    c = min(rc.right - rc.left, rc.bottom - rc.top);

    if (c <= 0) {
        if (iGraphicsModeOld){
            UserSetGraphicsMode(hdc, iGraphicsModeOld);
            UserSetTextAlign(hdc, iOldTextAlign);
        }
        return FALSE;
    }

    RtlZeroMemory(&lfw, sizeof(lfw));
    lfw.lfHeight         = c;
    lfw.lfWeight         = FW_NORMAL;
    lfw.lfCharSet        = SYMBOL_CHARSET;
    RtlCopyMemory(lfw.lfFaceName, L"Marlett", sizeof(L"Marlett"));
    hFont = UserCreateFontIndirectW(&lfw);

    hOldFont = UserSelectFont(hdc, hFont);

    if (!fButton) {

        if ((wType == DFC_MENU) || (wType == DFC_POPUPMENU)) {
            if (wState & (DFCS_MENUARROWUP | DFCS_MENUARROWDOWN)) {
                if (!(wState & DFCS_TRANSPARENT))  {
                    POLYPATBLT ppbData;

                    ppbData.x  = lprc->left;
                    ppbData.y  = lprc->top;
                    ppbData.cx = lprc->right - lprc->left;
                    ppbData.cy = lprc->bottom - lprc->top;
                    ppbData.BrClr.hbr = SYSHBR(MENU);
                    UserPolyPatBlt(hdc, PATCOPY, &ppbData, 1, PPB_BRUSH);
                }
                DrawScrollArrow(hdc, &rc,
                        (wState & (DFCS_HOT | DFCS_INACTIVE)) | ((wState & DFCS_MENUARROWUP) ? DFCS_SCROLLUP : DFCS_SCROLLDOWN));
            } else {
                DrawMenuMark(hdc, &rc, wType, wState);
            }
        } else if (wType == DFC_BUTTON) {
            DrawBox(hdc, &rc, wState);
        } else {  // wType == DFC_SCROLL
            DrawGrip(hdc, lprc, wState);
        }

    } else if (wType == DFC_CAPTION) {
        DrawIt(hdc, &rc, wState, GetCaptionChar(wState));
    } else if (wType == DFC_SCROLL) {

        DrawScrollArrow(hdc, &rc, wState);

    } else if (wType != DFC_BUTTON) {

        fRet = FALSE;
    }

    if (iGraphicsModeOld){
        UserSetGraphicsMode(hdc, iGraphicsModeOld);
        UserSetTextAlign(hdc, iOldTextAlign);
    }

    UserSetBkMode(hdc, iOldBk);
    UserSelectFont(hdc, hOldFont);
    UserDeleteObject(hFont);

    return fRet;
}

/***************************************************************************\
* DrawEdge
*
* Draws a 3D edge using 2 3D borders.  Adjusts interior rectangle if desired
* And fills it if requested.
*
* Returns:
*     FALSE if error
*
* History:
* 30-Jan-1991 Laurabu   Created.
\***************************************************************************/

BOOL DrawEdge(
    HDC    hdc,
    LPRECT lprc,
    UINT   edge,
    UINT   flags)
{
    HBRUSH     hbrTL;
    HBRUSH     hbrBR;
    RECT       rc;
    UINT       bdrType;
    POLYPATBLT ppbData[4];
    UINT       ppbCount;
    BOOL       fResult = TRUE;

    /*
     * Enforce monochromicity and flatness
     */
    if (gpsi->BitCount == 1)
        flags |= BF_MONO;

    if (flags & BF_MONO)
        flags |= BF_FLAT;

    rc = *lprc;

    /*
     * Draw the border segment(s), and calculate the remaining space as we
     * go.
     */
    if (bdrType = (edge & BDR_OUTER)) {

DrawBorder:

        /*
         * Get brushes.  Note the symmetry between raised outer,
         * sunken inner and sunken outer, raised inner.
         */
        if (flags & BF_FLAT) {

            if (flags & BF_MONO)
                hbrBR = (bdrType & BDR_OUTER) ? SYSHBR(WINDOWFRAME) : SYSHBR(WINDOW);
            else
                hbrBR = (bdrType & BDR_OUTER) ? SYSHBR(3DSHADOW) : SYSHBR(3DFACE);

            hbrTL = hbrBR;

        } else {

            /*
             * 5 == HILIGHT
             * 4 == LIGHT
             * 3 == FACE
             * 2 == SHADOW
             * 1 == DKSHADOW
             */

            switch (bdrType) {
            /*
             * +2 above surface
             */
            case BDR_RAISEDOUTER:
                hbrTL = ((flags & BF_SOFT) ? SYSHBR(3DHILIGHT) : SYSHBR(3DLIGHT));
                hbrBR = SYSHBR(3DDKSHADOW);     // 1
                break;

            /*
             * +1 above surface
             */
            case BDR_RAISEDINNER:
                hbrTL = ((flags & BF_SOFT) ? SYSHBR(3DLIGHT) : SYSHBR(3DHILIGHT));
                hbrBR = SYSHBR(3DSHADOW);       // 2
                break;

            /*
             * -1 below surface
             */
            case BDR_SUNKENOUTER:
                hbrTL = ((flags & BF_SOFT) ? SYSHBR(3DDKSHADOW) : SYSHBR(3DSHADOW));
                hbrBR = SYSHBR(3DHILIGHT);      // 5
                break;

            /*
             * -2 below surface
             */
            case BDR_SUNKENINNER:
                hbrTL = ((flags & BF_SOFT) ? SYSHBR(3DSHADOW) : SYSHBR(3DDKSHADOW));
                hbrBR = SYSHBR(3DLIGHT);        // 4
                break;

            default:
                return FALSE;
            }
        }

        /*
         * Draw the sides of the border.  NOTE THAT THE ALGORITHM FAVORS THE
         * BOTTOM AND RIGHT SIDES, since the light source is assumed to be top
         * left.  If we ever decide to let the user set the light source to a
         * particular corner, then change this algorithm.
         */
        if (flags & BF_DIAGONAL) {

            fResult = DrawDiagonal(hdc, &rc, hbrTL, hbrBR, flags);

        } else {

            /*
             * reset ppbData index
             */
            ppbCount = 0;

            /*
             * Bottom Right edges
             */
                /*
                 * Right
                 */
            if (flags & BF_RIGHT) {

                rc.right -= SYSMETRTL(CXBORDER);

                ppbData[ppbCount].x         = rc.right;
                ppbData[ppbCount].y         = rc.top;
                ppbData[ppbCount].cx        = SYSMETRTL(CXBORDER);
                ppbData[ppbCount].cy        = rc.bottom - rc.top;
                ppbData[ppbCount].BrClr.hbr = hbrBR;
                ppbCount++;
            }

            /*
             * Bottom
             */
            if (flags & BF_BOTTOM) {
                rc.bottom -= SYSMETRTL(CYBORDER);

                ppbData[ppbCount].x         = rc.left;
                ppbData[ppbCount].y         = rc.bottom;
                ppbData[ppbCount].cx        = rc.right - rc.left;
                ppbData[ppbCount].cy        = SYSMETRTL(CYBORDER);
                ppbData[ppbCount].BrClr.hbr = hbrBR;
                ppbCount++;
            }

            /*
             * Top Left edges
             */
            /*
             * Left
             */
            if (flags & BF_LEFT) {
                ppbData[ppbCount].x         = rc.left;
                ppbData[ppbCount].y         = rc.top;
                ppbData[ppbCount].cx        = SYSMETRTL(CXBORDER);
                ppbData[ppbCount].cy        = rc.bottom - rc.top;
                ppbData[ppbCount].BrClr.hbr = hbrTL;
                ppbCount++;

                rc.left += SYSMETRTL(CXBORDER);
            }

            /*
             * Top
             */
            if (flags & BF_TOP) {
                ppbData[ppbCount].x         = rc.left;
                ppbData[ppbCount].y         = rc.top;
                ppbData[ppbCount].cx        = rc.right - rc.left;
                ppbData[ppbCount].cy        = SYSMETRTL(CYBORDER);
                ppbData[ppbCount].BrClr.hbr = hbrTL;
                ppbCount++;

                rc.top += SYSMETRTL(CYBORDER);
            }
            /*
             * Send all queued PatBlts to GDI in one go
             */
            fResult = UserPolyPatBlt(hdc,PATCOPY,&ppbData[0],ppbCount,PPB_BRUSH);
        }
    }

    if (bdrType = (edge & BDR_INNER)) {
        /*
         * Strip this so the next time through, bdrType will be 0.
         * Otherwise, we'll loop forever.
         */
        edge &= ~BDR_INNER;
        goto DrawBorder;
    }


    /*
     * Select old brush back in, if we changed it.
     */

    /*
     * Fill the middle & clean up if asked
     */
    if (flags & BF_MIDDLE) {
        if (flags & BF_DIAGONAL)
            fResult = FillTriangle(hdc, &rc, ((flags & BF_MONO) ? (HBRUSH)SYSHBR(WINDOW) : (HBRUSH)SYSHBR(3DFACE)), flags);
        else
            fResult = FillRect(hdc, &rc, ((flags & BF_MONO) ? (HBRUSH)SYSHBR(WINDOW) : (HBRUSH)SYSHBR(3DFACE)));
    }

    if (flags & BF_ADJUST)
        *lprc = rc;

    return fResult;
}

/***************************************************************************\
* DrawPushButton
*
* Draws a push style button in the given state.  Adjusts passed in rectangle
* if desired.
*
* Algorithm:
*    Depending on the state we either draw
*             * raised edge   (undepressed)
*             * sunken edge with extra shadow (depressed)
*     If it is an option push button (a push button that is
*             really a check button or a radio button like buttons
*             in tool bars), and it is checked, then we draw it
*             depressed with a different fill in the middle.
*
* History:
* 05-Feb-19 Laurabu     Created.
\***************************************************************************/

VOID DrawPushButton(
    HDC    hdc,
    LPRECT lprc,
    UINT   state,
    UINT   flags)
{
    RECT   rc;
    HBRUSH hbrMiddle;
    DWORD  rgbBack;
    DWORD  rgbFore;
    BOOL   fDither;

    rc = *lprc;

    DrawEdge(hdc,
             &rc,
             (state & (DFCS_PUSHED | DFCS_CHECKED)) ? EDGE_SUNKEN : EDGE_RAISED,
             (UINT)(BF_ADJUST | BF_RECT | (flags & (BF_SOFT | BF_FLAT | BF_MONO))));

    /*
     * BOGUS
     * On monochrome, need to do something to make pushed buttons look
     * better.
     */

    /*
     * Fill in middle.  If checked, use dither brush (gray brush) with
     * black becoming normal color.
     */
    fDither = FALSE;

    if (state & DFCS_CHECKED) {

        if ((gpsi->BitCount < 8) || (SYSRGBRTL(3DHILIGHT) == RGB(255,255,255))) {
            hbrMiddle = KHBRUSH_TO_HBRUSH(gpsi->hbrGray);
            rgbBack = UserSetBkColor(hdc, SYSRGBRTL(3DHILIGHT));
            rgbFore = UserSetTextColor(hdc, SYSRGBRTL(3DFACE));
            fDither = TRUE;
        } else {
            hbrMiddle = SYSHBR(3DHILIGHT);
        }

    } else {
        hbrMiddle = SYSHBR(3DFACE);
    }

    FillRect(hdc, &rc, hbrMiddle);

    if (fDither) {
        UserSetBkColor(hdc, rgbBack);
        UserSetTextColor(hdc, rgbFore);
    }

    if (flags & BF_ADJUST)
        *lprc = rc;
}

/***************************************************************************\
* DrawFrame
*
* History:
\***************************************************************************/

BOOL DrawFrame(
    HDC   hdc,
    PRECT prc,
    int   clFrame,
    int   cmd)
{
    int        x;
    int        y;
    int        cx;
    int        cy;
    int        cxWidth;
    int        cyWidth;
    HANDLE     hbrSave;
    LONG       rop;
    POLYPATBLT PolyData[4];

    x = prc->left;
    y = prc->top;

    cxWidth = SYSMETRTL(CXBORDER) * clFrame;
    cyWidth = SYSMETRTL(CYBORDER) * clFrame;

    cx = prc->right - x - cxWidth;
    cy = prc->bottom - y - cyWidth;

    rop = ((cmd & DF_ROPMASK) ? PATINVERT : PATCOPY);

    if ((cmd & DF_HBRMASK) == DF_GRAY) {
        hbrSave = KHBRUSH_TO_HBRUSH(gpsi->hbrGray);
    } else {
        UserAssert(((cmd & DF_HBRMASK) >> 3) < COLOR_MAX);
        hbrSave = SYSHBRUSH((cmd & DF_HBRMASK) >> 3);
    }

    PolyData[0].x         = x;
    PolyData[0].y         = y;
    PolyData[0].cx        = cxWidth;
    PolyData[0].cy        = cy;
    PolyData[0].BrClr.hbr = hbrSave;

    PolyData[1].x         = x + cxWidth;
    PolyData[1].y         = y;
    PolyData[1].cx        = cx;
    PolyData[1].cy        = cyWidth;
    PolyData[1].BrClr.hbr = hbrSave;

    PolyData[2].x         = x;
    PolyData[2].y         = y + cy;
    PolyData[2].cx        = cx;
    PolyData[2].cy        = cyWidth;
    PolyData[2].BrClr.hbr = hbrSave;

    PolyData[3].x         = x + cx;
    PolyData[3].y         = y + cyWidth;
    PolyData[3].cx        = cxWidth;
    PolyData[3].cy        = cy;
    PolyData[3].BrClr.hbr = hbrSave;

    UserPolyPatBlt(hdc, rop, &PolyData[0], 4, PPB_BRUSH);

    return TRUE;
}

/***************************************************************************\
* GetSignFromMappingMode
*
* For the current mapping mode,  find out the sign of x from left to right,
* and the sign of y from top to bottom.
*
* History:
\***************************************************************************/

BOOL GetSignFromMappingMode (
    HDC    hdc,
    PPOINT pptSign)
{
    SIZE sizeViewPortExt;
    SIZE sizeWindowExt;

    if (!UserGetViewportExtEx(hdc, &sizeViewPortExt)
            || !UserGetWindowExtEx(hdc, &sizeWindowExt)) {

        return FALSE;
    }

    pptSign->x = ((sizeViewPortExt.cx ^ sizeWindowExt.cx) < 0) ? -1 : 1;

    pptSign->y = ((sizeViewPortExt.cy ^ sizeWindowExt.cy) < 0) ? -1 : 1;

    return TRUE;
}

/***************************************************************************\
* ClientFrame
*
* Draw a rectangle
*
* History:
* 19-Jan-1993 MikeKe    Created
\***************************************************************************/

BOOL ClientFrame(
    HDC     hDC,
    LPCRECT pRect,
    HBRUSH  hBrush,
    DWORD   patOp,
    int     cxBorder,
    int     cyBorder)
{
    int        x;
    int        y;
    POINT      point;
    POINT      ptSign;
    POLYPATBLT PolyData[4];

    if (!GetSignFromMappingMode (hDC, &ptSign))
        return FALSE;

    y = pRect->bottom - (point.y = pRect->top);
    if (y < 0) {
        return FALSE;
    }

    x = pRect->right -  (point.x = pRect->left);

    /*
     * Check width and height signs
     */
    if (((x ^ ptSign.x) < 0) || ((y ^ ptSign.y) < 0))
        return FALSE;

    /*
     * Factor in the thickness of the rectangle to be drawn.  This will
     * automatically offset the edges so that the actual rectangle gets filled
     * "in" as it becomes thicker.
     */
    ptSign.x *= cxBorder;
    ptSign.y *= cyBorder;

    // Top border
    PolyData[0].x         = point.x;
    PolyData[0].y         = point.y;
    PolyData[0].cx        = x;
    PolyData[0].cy        = ptSign.y;
    PolyData[0].BrClr.hbr = hBrush;

    // Bottom border
    point.y = pRect->bottom - ptSign.y;
    PolyData[1].x         = point.x;
    PolyData[1].y         = point.y;
    PolyData[1].cx        = x;
    PolyData[1].cy        = ptSign.y;
    PolyData[1].BrClr.hbr = hBrush;

    /*
     * Left Border
     * Don't xor the corners twice
     */
    point.y = pRect->top + ptSign.y;
    y -= 2 * ptSign.y;
    PolyData[2].x         = point.x;
    PolyData[2].y         = point.y;
    PolyData[2].cx        = ptSign.x;
    PolyData[2].cy        = y;
    PolyData[2].BrClr.hbr = hBrush;

    // Right Border
    point.x = pRect->right - ptSign.x;
    PolyData[3].x         = point.x;
    PolyData[3].y         = point.y;
    PolyData[3].cx        = ptSign.x;
    PolyData[3].cy        = y;
    PolyData[3].BrClr.hbr = hBrush;

    return UserPolyPatBlt(hDC, patOp, PolyData, sizeof (PolyData) / sizeof (*PolyData), PPB_BRUSH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\winwhere.c ===
/****************************** Module Header ******************************\
* Module Name: winwhere.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 08-Nov-1990 DavidPe   Created.
* 23-Jan-1991 IanJa     Serialization: Handle revalidation added
* 19-Feb-1991 JimA      Added enum access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* LayerHitTest
*
* 9/21/1998        vadimg      created
\***************************************************************************/

__inline BOOL LayerHitTest(PWND pwnd, POINT pt)
{
    ASSERT(TestWF(pwnd, WEFLAYERED));

    if (TestWF(pwnd, WEFTRANSPARENT))
        return FALSE;

    if (!GrePtInSprite(gpDispInfo->hDev, PtoHq(pwnd), pt.x, pt.y))
        return FALSE;

    return TRUE;
}

/***************************************************************************\
* ChildWindowFromPoint (API)
*
* Returns NULL if pt is not in parent's client area at all,
* hwndParent if point is not over any children, and a child window if it is
* over a child.  Will return hidden and disabled windows if they are at the
* given point.
*
* History:
* 19-Nov-1990 DavidPe   Created.
* 19-Feb-1991 JimA      Added enum access check
\***************************************************************************/

PWND _ChildWindowFromPointEx(
    PWND  pwnd,
    POINT pt,
    UINT  uFlags)
{
    if (pwnd != PWNDDESKTOP(pwnd)) {
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            pt.x = pwnd->rcClient.right - pt.x;
        } else {
            pt.x += pwnd->rcClient.left;
        }
        pt.y += pwnd->rcClient.top;
    }

    // _ClientToScreen(pwndParent, (LPPOINT)&pt);

    if (PtInRect(&pwnd->rcClient, pt)) {

        PWND pwndChild;

        if (pwnd->hrgnClip != NULL) {
            if (!GrePtInRegion(pwnd->hrgnClip, pt.x, pt.y))
                return NULL;
        }

        if (TestWF(pwnd, WEFLAYERED)) {
            if (!LayerHitTest(pwnd, pt))
                return NULL;
        }
        
        /*
         * Enumerate the children, skipping disabled and invisible ones
         * if so desired.  Still doesn't work for WS_EX_TRANSPARENT windows.
         */
        for (pwndChild = pwnd->spwndChild;
                 pwndChild;
                 pwndChild = pwndChild->spwndNext) {

            /*
             * Skip windows as desired.
             */
            if ((uFlags & CWP_SKIPINVISIBLE) && !TestWF(pwndChild, WFVISIBLE))
                continue;

            if ((uFlags & CWP_SKIPDISABLED) && TestWF(pwndChild, WFDISABLED))
                continue;

            if ((uFlags & CWP_SKIPTRANSPARENT) && TestWF(pwndChild, WEFTRANSPARENT))
                continue;

            if (PtInRect(&pwndChild->rcWindow, pt)) {

                if (pwndChild->hrgnClip != NULL) {
                    if (!GrePtInRegion(pwndChild->hrgnClip, pt.x, pt.y))
                        continue;
                }
                if (TestWF(pwndChild, WEFLAYERED)) {
                    if (!LayerHitTest(pwndChild, pt))
                        continue;
                }
                return(pwndChild);
            }
        }

        return pwnd;
    }

    return NULL;
}

/***************************************************************************\
* xxxWindowFromPoint (API)
*
* History:
* 19-Nov-1990 DavidPe   Created.
* 19-Feb-1991 JimA      Added enum access check
\***************************************************************************/

PWND xxxWindowFromPoint(
    POINT pt)
{
    HWND hwnd;
    PWND pwndT;
    TL   tlpwndT;

    pwndT = _GetDesktopWindow();
    ThreadLock(pwndT, &tlpwndT);
    
    hwnd = xxxWindowHitTest2(pwndT, pt, NULL, WHT_IGNOREDISABLED);

    ThreadUnlock(&tlpwndT);

    return RevalidateHwnd(hwnd);
}

#ifdef REDIRECTION

/***************************************************************************\
* xxxCallSpeedHitTestHook
*
* Call the speed hit test hook to give the opportunity to the hook to fake
* where the mouse pointer is.
*
* 25-Jan-1999 CLupu   Created.
\***************************************************************************/

PWND xxxCallSpeedHitTestHook(POINT* ppt)
{
    PHOOK pHook;
    PWND  pwnd = NULL;

    /*
     * Call the hit test hooks to give them the opportunity to change
     * the coordinates and the hwnd
     */
    if ((pHook = PhkFirstValid(PtiCurrent(), WH_HITTEST)) != NULL) {
        HTHOOKSTRUCT ht;
        BOOL         bAnsiHook;

        ht.pt      = *ppt;
        ht.hwndHit = NULL;

        xxxCallHook2(pHook, HC_ACTION, 0, (LPARAM)&ht, &bAnsiHook);

        if (ht.hwndHit != NULL) {
            
            pwnd = HMValidateHandle(ht.hwndHit, TYPE_WINDOW);

            if (pwnd != NULL) {
                ppt->x = ht.pt.x;
                ppt->y = ht.pt.y;
            }
        }
    }
    return pwnd;
}

#endif // REDIRECTION

/***************************************************************************\
* SpeedHitTest
*
* This routine quickly finds out what top level window this mouse point
* belongs to. Used purely for ownership purposes.
*
* 12-Nov-1992 ScottLu   Created.
\***************************************************************************/

PWND SpeedHitTest(
    PWND   pwndParent,
    POINT  pt)
{
    PWND pwndT;
    PWND pwnd;

    if (pwndParent == NULL)
        return NULL;

    for (pwnd = pwndParent->spwndChild; pwnd != NULL; pwnd = pwnd->spwndNext) {

        /*
         * Are we looking at an hidden window?
         */
        if (!TestWF(pwnd, WFVISIBLE))
            continue;

        /*
         * Are we barking up the wrong tree?
         */
        if (!PtInRect((LPRECT)&pwnd->rcWindow, pt)) {
            continue;
        }

        /*
         * Check to see if in window region (if it has one)
         */
        if (pwnd->hrgnClip != NULL) {
            if (!GrePtInRegion(pwnd->hrgnClip, pt.x, pt.y))
                continue;
        }

        /*
         * Is this a sprite?
         */
        if (TestWF(pwnd, WEFLAYERED)) {
            if (!LayerHitTest(pwnd, pt))
                continue;
        }

#ifdef REDIRECTION
        if (TestWF(pwnd, WEFEXTREDIRECTED)) {
            continue;
        }
#endif // REDIRECTION

        /*
         * Children?
         */
        if ((pwnd->spwndChild != NULL) &&
                PtInRect((LPRECT)&pwnd->rcClient, pt)) {

            pwndT = SpeedHitTest(pwnd, pt);
            if (pwndT != NULL)
                return pwndT;
        }

        return pwnd;
    }

    return pwndParent;
}

/***************************************************************************\
* xxxWindowHitTest
*
* History:
* 08-Nov-1990 DavidPe   Ported.
* 28-Nov-1990 DavidPe   Add pwndTransparent support for HTTRANSPARENT.
* 25-Jan-1991 IanJa     change PWNDPOS parameter to int *
* 19-Feb-1991 JimA      Added enum access check
* 02-Nov-1992 ScottLu   Removed pwndTransparent.
* 12-Nov-1992 ScottLu   Took out fSendHitTest, fixed locking bug
\***************************************************************************/

HWND xxxWindowHitTest(
    PWND  pwnd,
    POINT pt,
    int   *piPos,
    DWORD dwHitTestFlags)
{
    HWND hwndT;
    TL   tlpwnd;

    CheckLock(pwnd);

    hwndT = NULL;
    ThreadLockNever(&tlpwnd);
    while (pwnd != NULL) {
        ThreadLockExchangeAlways(pwnd, &tlpwnd);
        hwndT = xxxWindowHitTest2(pwnd, pt, piPos, dwHitTestFlags);
        if (hwndT != NULL)
            break;

        pwnd = pwnd->spwndNext;
    }

    ThreadUnlock(&tlpwnd);
    return hwndT;
}

/***************************************************************************\
* xxxWindowHitTest2
*
* When this routine is entered, all windows must be locked.  When this
* routine returns a window handle, it locks that window handle and unlocks
* all windows.  If this routine returns NULL, all windows are still locked.
* Ignores disabled and hidden windows.
*
* History:
* 08-Nov-1990 DavidPe   Ported.
* 25-Jan-1991 IanJa     change PWNDPOS parameter to int *
* 19-Feb-1991 JimA      Added enum access check
* 12-Nov-1992 ScottLu   Took out fSendHitTest
\***************************************************************************/

HWND xxxWindowHitTest2(
    PWND  pwnd,
    POINT pt,
    int   *piPos,
    DWORD dwHitTestFlags)
{
    int  ht = HTERROR, htGrip=HTBOTTOMRIGHT;
    HWND hwndT;
    TL   tlpwndChild;

    CheckLock(pwnd);

    /*
     * Are we at the bottom of the window chain?
     */
    if (pwnd == NULL)
        return NULL;

    /*
     * Are we looking at an hidden window?
     */
    if (!TestWF(pwnd, WFVISIBLE))
        return NULL;

    /*
     * Are we barking up the wrong tree?
     */
    if (!PtInRect((LPRECT)&pwnd->rcWindow, pt)) {
        return NULL;
    }

    if (pwnd->hrgnClip != NULL) {
        if (!GrePtInRegion(pwnd->hrgnClip, pt.x, pt.y))
            return(NULL);
    }
    
    if (TestWF(pwnd, WEFLAYERED)) {
        if (!LayerHitTest(pwnd, pt))
            return NULL;
    }
    
#ifdef REDIRECTION
    /*
     * If this is called when the layered window is actually trying
     * to process the message then let it see the hit test
     */
    if (TestWF(pwnd, WEFEXTREDIRECTED) && PpiCurrent() != GETPTI(pwnd)->ppi) {
        return NULL;
    }
#endif // REDIRECTION

    /*
     * Are we looking at an disabled window?
     */
    if (TestWF(pwnd, WFDISABLED) && (dwHitTestFlags & WHT_IGNOREDISABLED)) {
        if (TestwndChild(pwnd)) {
            return NULL;
        } else {
            ht = HTERROR;
            goto Exit;
        }
    }

#ifdef SYSMODALWINDOWS
    /*
     * If SysModal window present and we're not in it, return an error.
     * Be sure to assign the point to the SysModal window, so the message
     * will be sure to be removed from the queue.
     */
    if (!CheckPwndFilter(pwnd, gspwndSysModal)) {
        pwnd = gspwndSysModal;

        /*
         * Fix notorious stack overflow bug (some WINABLE fix from Memphis)
         */
        ht = HTCLIENT;
        goto Exit;
    }
#endif

    /*
     * Are we on a minimized window?
     */
    if (!TestWF(pwnd, WFMINIMIZED)) {
        /*
         * Are we in the window's client area?
         */
        if (PtInRect((LPRECT)&pwnd->rcClient, pt)) {
            /*
             * Recurse through the children.
             */
            ThreadLock(pwnd->spwndChild, &tlpwndChild);
            hwndT = xxxWindowHitTest(pwnd->spwndChild,
                                     pt,
                                     piPos,
                                     dwHitTestFlags);
            
            ThreadUnlock(&tlpwndChild);
            if (hwndT != NULL)
                return hwndT;
        }

    }

    /*
     * If window not in same task, don't send WM_NCHITTEST.
     */
    if (GETPTI(pwnd) != PtiCurrent()) {
        ht = HTCLIENT;
        goto Exit;
    }

    /*
     * Send the message.
     */
    ht = (int)xxxSendMessage(pwnd, WM_NCHITTEST, 0, MAKELONG(pt.x, pt.y));

    /*
     * If window is transparent keep enumerating.
     */
    if (ht == HTTRANSPARENT) {
        return NULL;
    }

Exit:

    /*
     * Set wndpos accordingly.
     */
    if (piPos) {
        *piPos = ht;
    }

    /*
     * If this is a RTL mirrored window, then the grip is at
     * HTBOTTOMLEFT (in terms of screen coordinates since they are
     * not RTL mirrored).
     */
    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        htGrip = HTBOTTOMLEFT;
    }

    /*
     * if the click is in the sizebox of the window and this window itself is
     * not sizable, return the window that will be sized by this sizebox
     */
    if ((ht == htGrip) && !TestWF(pwnd, WFSIZEBOX)) {

        PWND  pwndT;
         /*
          * SizeBoxHwnd() can return NULL!  We don't want to act like this
          * is transparent if the sizebox isn't a grip
          */
         pwnd = (pwndT = SizeBoxHwnd(pwnd)) ? pwndT : pwnd;
    }

    return HWq(pwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\getset.c ===
/****************************** Module Header ******************************\
* Module Name: getset.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains window manager information routines
*
* History:
* 10-22-90 MikeHar      Ported functions from Win 3.0 sources.
* 13-Feb-1991 mikeke    Added Revalidation code (None)
* 08-Feb-1991 IanJa     Unicode/ANSI aware and neutral
\***************************************************************************/

/***************************************************************************\
* MapServerToClientPfn
*
* Returns the client wndproc representing the server wndproc passed in
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/

ULONG_PTR MapServerToClientPfn(
    KERNEL_ULONG_PTR dw,
    BOOL bAnsi)
{
    int i;

    for (i = FNID_WNDPROCSTART; i <= FNID_WNDPROCEND; i++) {
        if ((WNDPROC_PWND)dw == STOCID(i)) {
            if (bAnsi) {
                return FNID_TO_CLIENT_PFNA_CLIENT(i);
            } else {
                return FNID_TO_CLIENT_PFNW_CLIENT(i);
            }
        }
    }
    return 0;
}

/***************************************************************************\
* MapClientNeuterToClientPfn
*
* Maps client Neuter routines like editwndproc to Ansi or Unicode versions
* and back again.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/

ULONG_PTR MapClientNeuterToClientPfn(
    PCLS pcls,
    KERNEL_ULONG_PTR dw,
    BOOL bAnsi)
{
    /*
     * Default to the class window proc.
     */
    if (dw == 0) {
        dw = (KERNEL_ULONG_PTR)pcls->lpfnWndProc;
    }

    /*
     * If this is one of our controls and it hasn't been subclassed, try
     * to return the correct ANSI/Unicode function.
     */
    if (pcls->fnid >= FNID_CONTROLSTART && pcls->fnid <= FNID_CONTROLEND) {
        if (!bAnsi) {
            if (FNID_TO_CLIENT_PFNA_KERNEL(pcls->fnid) == dw)
                return FNID_TO_CLIENT_PFNW_CLIENT(pcls->fnid);
        } else {
            if (FNID_TO_CLIENT_PFNW_KERNEL(pcls->fnid) == dw)
                return FNID_TO_CLIENT_PFNA_CLIENT(pcls->fnid);
        }
#ifdef BUILD_WOW6432
        if (!bAnsi) {
            if (FNID_TO_CLIENT_PFNW_KERNEL(pcls->fnid) == dw)
                return FNID_TO_CLIENT_PFNW_CLIENT(pcls->fnid);
        } else {
            if (FNID_TO_CLIENT_PFNA_KERNEL(pcls->fnid) == dw)
                return FNID_TO_CLIENT_PFNA_CLIENT(pcls->fnid);
        }
        dw = (KERNEL_ULONG_PTR)MapKernelClientFnToClientFn((WNDPROC_PWND)dw);
#endif
    }

    return (ULONG_PTR)dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\drawtext.c ===
/****************************** Module Header ******************************\
* Module Name: drawtext.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains common text drawing functions.
*
* History:
* 02-12-92 mikeke   Moved Drawtext to the client side
\***************************************************************************/


/***************************************************************************\
* Define some macros to test the format flags. We won't support them all
* on the kernel-mode side, since they're not all needed there.
\***************************************************************************/
#ifdef _USERK_
    #define CALCRECT(wFormat)               FALSE
    #define EDITCONTROL(wFormat)            FALSE
    #define EXPANDTABS(wFormat)             FALSE
    #define EXTERNALLEADING(wFormat)        FALSE
    #define MODIFYSTRING(wFormat)           FALSE
    #define NOPREFIX(wFormat)               TRUE
    #define PATHELLIPSIS(wFormat)           FALSE
    #define SINGLELINE(wFormat)             TRUE
    #define TABSTOP(wFormat)                FALSE
    #define WORDBREAK(wFormat)              FALSE
    #define WORDELLIPSIS(wFormat)           FALSE
    #define NOFULLWIDTHCHARBREAK(dwFormat)  FALSE
#else
    #define CALCRECT(wFormat)               (wFormat & DT_CALCRECT)
    #define EDITCONTROL(wFormat)            (wFormat & DT_EDITCONTROL)
    #define EXPANDTABS(wFormat)             (wFormat & DT_EXPANDTABS)
    #define EXTERNALLEADING(wFormat)        (wFormat & DT_EXTERNALLEADING)
    #define MODIFYSTRING(wFormat)           (wFormat & DT_MODIFYSTRING)
    #define NOPREFIX(wFormat)               (wFormat & DT_NOPREFIX)
    #define PATHELLIPSIS(wFormat)           (wFormat & DT_PATH_ELLIPSIS)
    #define SINGLELINE(wFormat)             (wFormat & DT_SINGLELINE)
    #define TABSTOP(wFormat)                (wFormat & DT_TABSTOP)
    #define WORDBREAK(wFormat)              (wFormat & DT_WORDBREAK)
    #define WORDELLIPSIS(wFormat)           (wFormat & DT_WORD_ELLIPSIS)
    // Note: DT_NOFULLWIDTHCHARBREAK exceeds WORD limit. Use dwFormat
    //  rather than wFormat.
    #define NOFULLWIDTHCHARBREAK(dwFormat)  (dwFormat & DT_NOFULLWIDTHCHARBREAK)
#endif
#define ENDELLIPSIS(wFormat)        (wFormat & DT_END_ELLIPSIS)
#define NOCLIP(wFormat)             (wFormat & DT_NOCLIP)
#define RTLREADING(wFormat)         (wFormat & DT_RTLREADING)
#define HIDEPREFIX(wFormat)         (wFormat & DT_HIDEPREFIX)

/***************************************************************************\
* Stuff used in DrawText code
\***************************************************************************/

#define CR 13
#define LF 10
#define SYM_SP 0xf020
#define DT_HFMTMASK 0x03
#define DT_VFMTMASK 0x0C
#define ETO_OPAQUEFGND 0x0A

static CONST WCHAR szEllipsis[CCHELLIPSIS+1] = TEXT("...");

extern HDC    ghdcBits2;

/* Max length of a full path is around 260. But, most of the time, it will
 * be less than 128. So, we alloc only this much on stack. If the string is
 * longer, we alloc from local heap (which is slower).
 *
 * BOGUS: For international versions, we need to give some more margin here.
 */
#define MAXBUFFSIZE     128

/***************************************************************************\
*  There are word breaking characters which are compatible with
* Japanese Windows 3.1 and FarEast Windows 95.
*
*  SJ - Country Japan , Charset SHIFTJIS, Codepage  932.
*  GB - Country PRC   , Charset GB2312  , Codepage  936.
*  B5 - Country Taiwan, Charset BIG5    , Codepage  950.
*  WS - Country Korea , Charset WANGSUNG, Codepage  949.
*  JB - Country Korea , Charset JOHAB   , Codepage 1361. *** LATER ***
*
* [START BREAK CHARACTERS]
*
*   These character should not be the last charatcer of the line.
*
*  Unicode   Japan      PRC     Taiwan     Korea
*  -------+---------+---------+---------+---------+
*
* + ASCII
*
*   U+0024 (SJ+0024)                     (WS+0024) Dollar sign
*   U+0028 (SJ+0028)                     (WS+0028) Opening parenthesis
*   U+003C (SJ+003C)                               Less-than sign
*   U+005C (SJ+005C)                               Backslash
*   U+005B (SJ+005B) (GB+005B)           (WS+005B) Opening square bracket
*   U+007B (SJ+007B) (GB+007B)           (WS+007B) Opening curly bracket
*
* + General punctuation
*
*   U+2018                               (WS+A1AE) Single Turned Comma Quotation Mark
*   U+201C                               (WS+A1B0) Double Comma Quotation Mark
*
* + CJK symbols and punctuation
*
*   U+3008                               (WS+A1B4) Opening Angle Bracket
*   U+300A (SJ+8173)                     (WS+A1B6) Opening Double Angle Bracket
*   U+300C (SJ+8175)                     (WS+A1B8) Opening Corner Bracket
*   U+300E (SJ+8177)                     (WS+A1BA) Opening White Corner Bracket
*   U+3010 (SJ+9179)                     (WS+A1BC) Opening Black Lenticular Bracket
*   U+3014 (SJ+816B)                     (WS+A1B2) Opening Tortoise Shell Bracket
*
* + Fullwidth ASCII variants
*
*   U+FF04                               (WS+A3A4) Fullwidth Dollar Sign
*   U+FF08 (SJ+8169)                     (WS+A3A8) Fullwidth opening parenthesis
*   U+FF1C (SJ+8183)                               Fullwidth less-than sign
*   U+FF3B (SJ+816D)                     (WS+A3DB) Fullwidth opening square bracket
*   U+FF5B (SJ+816F)                     (WS+A3FB) Fullwidth opening curly bracket
*
* + Halfwidth Katakana variants
*
*   U+FF62 (SJ+00A2)                               Halfwidth Opening Corner Bracket
*
* + Fullwidth symbol variants
*
*   U+FFE1                               (WS+A1CC) Fullwidth Pound Sign
*   U+FFE6                               (WS+A3DC) Fullwidth Won Sign
*
* [END BREAK CHARACTERS]
*
*   These character should not be the top charatcer of the line.
*
*  Unicode   Japan      PRC     Taiwan     Korea
*  -------+---------+---------+---------+---------+
*
* + ASCII
*
*   U+0021 (SJ+0021) (GB+0021) (B5+0021) (WS+0021) Exclamation mark
*   U+0025                               (WS+0025) Percent Sign
*   U+0029 (SJ+0029)                     (WS+0029) Closing parenthesis
*   U+002C (SJ+002C) (GB+002C) (B5+002C) (WS+002C) Comma
*   U+002E (SJ+002E) (GB+002E) (B5+002E) (WS+002E) Priod
*   U+003A                               (WS+003A) Colon
*   U+003B                               (WS+003B) Semicolon
*   U+003E (SJ+003E)                               Greater-than sign
*   U+003F (SJ+003F) (GB+003F) (B5+003F) (WS+003F) Question mark
*   U+005D (SJ+005D) (GB+005D) (B5+005D) (WS+005D) Closing square bracket
*   U+007D (SJ+007D) (GB+007D) (B5+007D) (WS+007D) Closing curly bracket
*
* + Latin1
*
*   U+00A8           (GB+A1A7)                     Spacing diaeresis
*   U+00B0                               (WS+A1C6) Degree Sign
*   U+00B7                     (B5+A150)           Middle Dot
*
* + Modifier letters
*
*   U+02C7           (GB+A1A6)                     Modifier latter hacek
*   U+02C9           (GB+A1A5)                     Modifier letter macron
*
* + General punctuation
*
*   U+2013                     (B5+A156)           En Dash
*   U+2014                     (b5+A158)           Em Dash
*   U+2015           (GB+A1AA)                     Quotation dash
*   U+2016           (GB+A1AC)                     Double vertical bar
*   U+2018           (GB+A1AE)                     Single turned comma quotation mark
*   U+2019           (GB+A1AF) (B5+A1A6) (WS+A1AF) Single comma quotation mark
*   U+201D           (GB+A1B1) (B5+A1A8) (WS+A1B1) Double comma quotation mark
*   U+2022           (GB+A1A4)                     Bullet
*   U+2025                     (B5+A14C)           Two Dot Leader
*   U+2026           (GB+A1AD) (B5+A14B)           Horizontal ellipsis
*   U+2027                     (B5+A145)           Hyphenation Point
*   U+2032                     (B5+A1AC) (WS+A1C7) Prime
*   U+2033                               (WS+A1C8) Double Prime
*
* + Letterlike symbols
*
*   U+2103                               (WS+A1C9) Degrees Centigrade
*
* + Mathemetical opetartors
*
*   U+2236           (GB+A1C3)                     Ratio
*
* + Form and Chart components
*
*   U+2574                     (B5+A15A)           Forms Light Left
*
* + CJK symbols and punctuation
*
*   U+3001 (SJ+8141) (GB+A1A2) (B5+A142)           Ideographic comma
*   U+3002 (SJ+8142) (GB+A1A3) (B5+A143)           Ideographic period
*   U+3003           (GB+A1A8)                     Ditto mark
*   U+3005           (GB+A1A9)                     Ideographic iteration
*   U+3009           (GB+A1B5) (B5+A172) (WS+A1B5) Closing angle bracket
*   U+300B (SJ+8174) (GB+A1B7) (B5+A16E) (WS+A1B7) Closing double angle bracket
*   U+300D (SJ+8176) (GB+A1B9) (B5+A176) (WS+A1B9) Closing corner bracket
*   U+300F (SJ+8178) (GB+A1BB) (B5+A17A) (WS+A1BB) Closing white corner bracket
*   U+3011 (SJ+817A) (GB+A1BF) (B5+A16A) (WS+A1BD) Closing black lenticular bracket
*   U+3015 (SJ+816C) (GB+A1B3) (B5+A166) (WS+A1B3) Closing tortoise shell bracket
*   U+3017           (GB+A1BD)                     Closing white lenticular bracket
*   U+301E                     (B5+A1AA)           Double Prime Quotation Mark
*
* + Hiragana
*
*   U+309B (SJ+814A)                               Katakana-Hiragana voiced sound mark
*   U+309C (SJ+814B)                               Katakana-Hiragana semi-voiced sound mark
*
* + CNS 11643 compatibility
*
*   U+FE30                     (B5+A14A)           Glyph for Vertical 2 Dot Leader
*   U+FE31                     (B5+A157)           Glyph For Vertical Em Dash
*   U+FE33                     (B5+A159)           Glyph for Vertical Spacing Underscore
*   U+FE34                     (B5+A15B)           Glyph for Vertical Spacing Wavy Underscore
*   U+FE36                     (B5+A160)           Glyph For Vertical Closing Parenthesis
*   U+FE38                     (B5+A164)           Glyph For Vertical Closing Curly Bracket
*   U+FE3A                     (B5+A168)           Glyph For Vertical Closing Tortoise Shell Bracket
*   U+FE3C                     (B5+A16C)           Glyph For Vertical Closing Black Lenticular Bracket
*   U+FE3E                     (B5+A16E)           Closing Double Angle Bracket
*   U+FE40                     (B5+A174)           Glyph For Vertical Closing Angle Bracket
*   U+FE42                     (B5+A178)           Glyph For Vertical Closing Corner Bracket
*   U+FE44                     (B5+A17C)           Glyph For Vertical Closing White Corner Bracket
*   U+FE4F                     (B5+A15C)           Spacing Wavy Underscore
*
* + Small variants
*
*   U+FE50                     (B5+A14D)           Small Comma
*   U+FE51                     (B5+A14E)           Small Ideographic Comma
*   U+FE52                     (B5+A14F)           Small Period
*   U+FE54                     (B5+A151)           Small Semicolon
*   U+FE55                     (B5+A152)           Small Colon
*   U+FE56                     (B5+A153)           Small Question Mark
*   U+FE57                     (B5+A154)           Small Exclamation Mark
*   U+FE5A                     (B5+A17E)           Small Closing Parenthesis
*   U+FE5C                     (B5+A1A2)           Small Closing Curly Bracket
*   U+FE5E                     (B5+A1A4)           Small Closing Tortoise Shell Bracket
*
* + Fullwidth ASCII variants
*
*   U+FF01 (SJ+8149) (GB+A3A1) (B5+A149) (WS+A3A1) Fullwidth exclamation mark
*   U+FF02           (GB+A3A2)                     Fullwidth Quotation mark
*   U+FF05                               (WS+A3A5) Fullwidth Percent Sign
*   U+FF07           (GB+A3A7)                     Fullwidth Apostrophe
*   U+FF09 (SJ+816A) (GB+A3A9) (B5+A15E) (WS+A3A9) Fullwidth Closing parenthesis
*   U+FF0C (SJ+8143) (GB+A3AC) (B5+A141) (WS+A3AC) Fullwidth comma
*   U+FF0D           (GB+A3AD)                     Fullwidth Hyphen-minus
*   U+FF0E (SJ+8144)           (B5+A144) (WS+A3AE) Fullwidth period
*   U+FF1A           (GB+A3BA) (B4+A147) (WS+A3BA) Fullwidth colon
*   U+FF1B           (GB+A3BB) (B5+A146) (WS+A3BB) Fullwidth semicolon
*   U+FF1E (SJ+8184)                               Fullwidth Greater-than sign
*   U+FF1F (SJ+8148) (GB+A3BF) (B5+A148) (WS+A3BF) Fullwidth question mark
*   U+FF3D (SJ+816E) (GB+A3DD)           (WS+A3DD) Fullwidth Closing square bracket
*   U+FF5C                     (B5+A155)           Fullwidth Vertical Bar
*   U+FF5D (SJ+8170)           (B5+A162) (WS+A3FD) Fullwidth Closing curly bracket
*   U+FF5E           (GB+A1AB)                     Fullwidth Spacing tilde
*
* + Halfwidth Katakana variants
*
*   U+FF61 (SJ+00A1)                               Halfwidth Ideographic period
*   U+FF63 (SJ+00A3)                               Halfwidth Closing corner bracket
*   U+FF64 (SJ+00A4)                               Halfwidth Ideographic comma
*   U+FF9E (SJ+00DE)                               Halfwidth Katakana voiced sound mark
*   U+FF9F (SJ+00DF)                               Halfwidth Katakana semi-voiced sound mark
*
* + Fullwidth symbol variants
*
*   U+FFE0                               (WS+A1CB) Fullwidth Cent Sign
*
\***************************************************************************/

#if 0   // not currently used --- FYI only
/***************************************************************************\
* Start Break table
*  These character should not be the last charatcer of the line.
\***************************************************************************/

CONST BYTE aASCII_StartBreak[] = {
/* 00       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 2X */                1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
/* 6X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aCJKSymbol_StartBreak[] = {
/* 30       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */                            1, 0, 1, 0, 1, 0, 1, 0,
/* 1X */    1, 0, 0, 0, 1
};

CONST BYTE aFullWidthHalfWidthVariants_StartBreak[] = {
/* FF       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */                1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* 1X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
/* 2X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
/* 6X */    0, 0, 1
};
#endif

/***************************************************************************\
* End Break table.
*  These character should not be the top charatcer of the line.
\***************************************************************************/

CONST BYTE aASCII_Latin1_EndBreak[] = {
/* 00       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 2X */       1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 6X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 8X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 9X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* AX */    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* BX */    1, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aGeneralPunctuation_EndBreak[] = {
/* 20       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 1X */             1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0,
/* 2X */    0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 1, 1
};

CONST BYTE aCJKSymbol_EndBreak[] = {
/* 30       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */       1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1,
/* 1X */    0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aCNS11643_SmallVariants_EndBreak[] = {
/* FE       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 3X */    1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
/* 4X */    1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
/* 5X */    1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1
};

CONST BYTE aFullWidthHalfWidthVariants_EndBreak[] = {
/* FF       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */       1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0,
/* 1X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1,
/* 2X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
/* 6X */    0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 8X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 9X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
};

/***************************************************************************\
*  UserIsFELineBreak() - Detects East Asia word breaking characters.        *
*                                                                           *
* History:                                                                  *
* 10-Mar-1996 HideyukN  Created.                                            *
\***************************************************************************/

#if 0   // not currently used --- FYI only
BOOL UserIsFELineBreakStart(WCHAR wch)
{
    switch (wch>>8) {
        case 0x00:
            //
            // Check if word breaking chars in ASCII.
            //
            if ((wch >= 0x0024) && (wch <= 0x007B))
                return((BOOL)(aASCII_StartBreak[wch - 0x0024]));
            else
                return(FALSE);

        case 0x20:
            //
            // Check if work breaking chars in "General punctuation"
            //
            if ((wch == 0x2018) || (wch == 0x201C))
                return(TRUE);
            else
                return(FALSE);

        case 0x30:
            //
            // Check if word breaking chars in "CJK symbols and punctuation"
            // and Hiragana.
            //
            if ((wch >= 0x3008) && (wch <= 0x3014))
                return((BOOL)(aCJKSymbol_StartBreak[wch - 0x3008]));
            else
                return(FALSE);

        case 0xFF:
            //
            // Check if word breaking chars in "Fullwidth ASCII variants",
            // "Halfwidth Katakana variants" or "Fullwidth Symbol variants".
            //
            if ((wch >= 0xFF04) && (wch <= 0xFF62))
                return((BOOL)(aFullWidthHalfWidthVariants_StartBreak[wch - 0xFF04]));
            else if ((wch == 0xFFE1) || (wch == 0xFFE6))
                return(TRUE);
            else
                return(FALSE);

        default:
            return(FALSE);
    }
}
#endif

BOOL UserIsFELineBreakEnd(WCHAR wch)
{
    switch (wch>>8) {
        case 0x00:
            //
            // Check if word breaking chars in ASCII or Latin1.
            //
            if ((wch >= 0x0021) && (wch <= 0x00B7))
                return((BOOL)(aASCII_Latin1_EndBreak[wch - 0x0021]));
            else
                return(FALSE);

        case 0x02:
            //
            // Check if work breaking chars in "Modifier letters"
            //
            if ((wch == 0x02C7) || (wch == 0x02C9))
                return(TRUE);
            else
                return(FALSE);

        case 0x20:
            //
            // Check if work breaking chars in "General punctuation"
            //
            if ((wch >= 0x2013) && (wch <= 0x2033))
                return((BOOL)(aGeneralPunctuation_EndBreak[wch - 0x2013]));
            else
                return(FALSE);

        case 0x21:
            //
            // Check if work breaking chars in "Letterlike symbols"
            //
            if (wch == 0x2103)
                return(TRUE);
            else
                return(FALSE);

        case 0x22:
            //
            // Check if work breaking chars in "Mathemetical opetartors"
            //
            if (wch == 0x2236)
                return(TRUE);
            else
                return(FALSE);

        case 0x25:
            //
            // Check if work breaking chars in "Form and Chart components"
            //
            if (wch == 0x2574)
                return(TRUE);
            else
                return(FALSE);

        case 0x30:
            //
            // Check if word breaking chars in "CJK symbols and punctuation"
            // and Hiragana.
            //
            if ((wch >= 0x3001) && (wch <= 0x301E))
                return((BOOL)(aCJKSymbol_EndBreak[wch - 0x3001]));
            else if ((wch == 0x309B) || (wch == 0x309C))
                return(TRUE);
            else
                return(FALSE);

        case 0xFE:
            //
            // Check if word breaking chars in "CNS 11643 compatibility"
            // or "Small variants".
            //
            if ((wch >= 0xFE30) && (wch <= 0xFE5E))
                return((BOOL)(aCNS11643_SmallVariants_EndBreak[wch - 0xFE30]));
            else
                return(FALSE);

        case 0xFF:
            //
            // Check if word breaking chars in "Fullwidth ASCII variants",
            // "Halfwidth Katakana variants" or "Fullwidth symbol variants".
            //
            if ((wch >= 0xFF01) && (wch <= 0xFF9F))
                return((BOOL)(aFullWidthHalfWidthVariants_EndBreak[wch - 0xFF01]));
            else if (wch >= 0xFFE0)
                return(TRUE);
            else
                return(FALSE);

        default:
            return(FALSE);
    }
}

#define UserIsFELineBreak(wChar)    UserIsFELineBreakEnd(wChar)

/***************************************************************************\
*  UserIsFullWidth() - Detects East Asia FullWidth character.               *
*                                                                           *
* History:                                                                  *
* 10-Mar-1996 HideyukN  Created                                             *
\***************************************************************************/

typedef struct _FULLWIDTH_UNICODE {
    WCHAR Start;
    WCHAR End;
} FULLWIDTH_UNICODE, *PFULLWIDTH_UNICODE;

#define NUM_FULLWIDTH_UNICODES    4

CONST FULLWIDTH_UNICODE FullWidthUnicodes[] = {
   { 0x4E00, 0x9FFF }, // CJK_UNIFIED_IDOGRAPHS
   { 0x3040, 0x309F }, // HIRAGANA
   { 0x30A0, 0x30FF }, // KATAKANA
   { 0xAC00, 0xD7A3 }  // HANGUL
};

BOOL UserIsFullWidth(DWORD dwCodePage,WCHAR wChar)
{
    INT  index;
    INT  cChars;
#ifdef _USERK_
    CHAR aChars[2];
#endif // _USERK_

    //
    // Early out for ASCII.
    //
    if (wChar < 0x0080) {
        //
        // if the character < 0x0080, it should be a halfwidth character.
        //
        return (FALSE);
    }
    //
    // Scan FullWdith definition table... most of FullWidth character is
    // defined here... this is more faster than call NLS API.
    //
    for (index = 0; index < NUM_FULLWIDTH_UNICODES; index++) {
        if ((wChar >= FullWidthUnicodes[index].Start) &&
            (wChar <= FullWidthUnicodes[index].End)      ) {
            return (TRUE);
        }
    }
    //
    // if this Unicode character is mapped to Double-Byte character,
    // this is also FullWidth character..
    //
#ifdef _USERK_
    cChars = EngWideCharToMultiByte((UINT)dwCodePage,&wChar,sizeof(WCHAR),aChars,sizeof(aChars));
#else
    cChars = WideCharToMultiByte((UINT)dwCodePage,0,&wChar,1,NULL,0,NULL,NULL);
#endif // _USERK_

    return(cChars > 1 ? TRUE : FALSE);
}
/***************************************************************************\
*  UserTextOutWInternal
*  Wrapper for UserTextOutW, used to adjust the parameter passed to
*  PSMTextOut
*
\***************************************************************************/
BOOL UserTextOutWInternal(
    HDC     hdc,
    int     x,
    int     y,
    LPCWSTR lp,
    UINT    cc,
    DWORD   dwFlags)
{
    UNREFERENCED_PARAMETER(dwFlags);
    return UserTextOutW(hdc, x, y, lp, cc);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  KKGetPrefixWidth() -                                                    */
/*                                                                          */
/*  Returns total width of prefix character. Japanese Windows has           */
/*  three shortcut prefixes, '&',\036 and \037.  They may have              */
/*  different width.                                                        */
/*                                                                          */
/*    From Chicago ctlmgr.c HideyukN                                        */
/*--------------------------------------------------------------------------*/

int KKGetPrefixWidth(HDC hdc, LPCWSTR lpStr, int cch)
{
    SIZE size;
    SIZE iPrefix1 = {-1L,-1L};
    SIZE iPrefix2 = {-1L,-1L};
    SIZE iPrefix3 = {-1L,-1L};
    int  iTotal   = 0;

    while (cch-- > 0 && *lpStr) {
        switch(*lpStr) {
        case CH_PREFIX:
            if (lpStr[1] != CH_PREFIX) {
                if (iPrefix1.cx == -1) {
                    UserGetTextExtentPointW(hdc, lpStr, 1, &iPrefix1);
                }
                iTotal += iPrefix1.cx;
            } else {
                lpStr++;
                cch--;
            }
            break;
        case CH_ENGLISHPREFIX:
            if (iPrefix2.cx == -1) {
                 UserGetTextExtentPointW(hdc, lpStr, 1, &iPrefix2);
            }
            iTotal += iPrefix2.cx;
            break;
        case CH_KANJIPREFIX:
            if (iPrefix3.cx == -1) {
                 UserGetTextExtentPointW(hdc, lpStr, 1, &iPrefix3);
            }
            iTotal += iPrefix3.cx;
            //
            // In NT, always alpha numeric mode, Then we have to sum
            // KANA accel key prefix non visible char width.
            // so always add the extent for next char.
            //
            UserGetTextExtentPointW(hdc, lpStr, 1, &size);
            iTotal += size.cx;
            break;
        default:
            // No need to taking care of Double byte since 2nd byte of
            // DBC is grater than 0x2f but all shortcut keys are less
            // than 0x30.
            break;
        }
        lpStr++;
    }
    return iTotal;
}

#if ((DT_WORDBREAK & ~0xff) != 0)
#error cannot use BOOLEAN for DT_WORDBREAK, or you should use "!!" before assigning it
#endif

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetNextWordbreak() -                                                    */
/*    From Chicago ctlmgr.c  FritzS                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LPCWSTR GetNextWordbreak(DWORD dwCodePage,
                         LPCWSTR lpch,
                         LPCWSTR lpchEnd,
                         DWORD  dwFormat,
                         LPDRAWTEXTDATA lpDrawInfo)

{
    /* ichNonWhite is used to make sure we always make progress. */
    int ichNonWhite = 1;
    int ichComplexBreak = 0;        // Breaking opportunity for complex scripts
    BOOLEAN fBreakSpace = (BOOLEAN)WORDBREAK(dwFormat);
    /*
     * If DT_WORDBREAK and DT_NOFULLWIDTHCHARBREAK are both set, we must
     * stop assuming FullWidth characters as word as we're doing in
     * NT4 and Win95. Instead, CR/LF and/or white space will only be
     * a line-break characters.
     */
    BOOLEAN fDbcsCharBreak = (fBreakSpace && !NOFULLWIDTHCHARBREAK(dwFormat));

#ifdef _USERK_
    /*
     * Well, we actually should not and do not call GetNextWordBreak() in
     * kernel, since only Menu stuff (no word break!) calls DrawText from kernel.
     * In reality, thanks to a smart linker, word-break helper
     * functions even does not exist in win32k.sys.
     * Later, we should explicitly omit to compile those routines when we
     * build kernel.
     */
    UNREFERENCED_PARAMETER(dwFormat);
#endif

    // We must terminate this loop before lpch == lpchEnd, otherwise, we
    // may gp fault during *lpch.
    while (lpch < lpchEnd) {
        switch (*lpch) {
        case CR:
        case LF:
            return lpch;

        case '\t':
        case ' ':
        case SYM_SP:
            if (fBreakSpace)
                return (lpch + ichNonWhite);

            /*** FALL THRU ***/

        default:
            /*
             * Since most Japanese writing don't use space character
             * to separate each word, we define each Kanji character
             * as a word.
             */
            if (fDbcsCharBreak && UserIsFullWidth(dwCodePage, *lpch)) {
                if (!ichNonWhite)
                    return lpch;
                /*
                 * if the next character is the last character of this string,
                 * We return the character, even this is a "KINSOKU" charcter...
                 */
                if ((lpch+1) != lpchEnd) {
                    /*
                     * Check next character of FullWidth character.
                     * if the next character is "KINSOKU" character, the character
                     * should be handled as a part of previous FullWidth character.
                     * Never handle is as A character, and should not be a Word also.
                     */
                    if (UserIsFELineBreak(*(lpch+1))) {
                        /*
                         * Then if the character is "KINSOKU" character, we return
                         * the next of this character,...
                         */
                        return (lpch + 1 + 1);
                    }
                }
                /*
                 * Otherwise, we just return the chracter that is next of FullWidth
                 * Character. Because we treat A FullWidth chacter as A Word.
                 */
                return (lpch + 1);
            }
            /*
             * If the character is not a FullWidth character and the complex script
             * LPK is present. Call it to determine the breaking opportunity for
             * script that requires word break such as Thai. Note that if *lpch is
             * NOT a complex script character. The LPK will fail the call and return 0
             * since currently Uniscribe does not know how to handle FE break.
             */
            else if(fBreakSpace && lpDrawInfo->bCharsetDll) {
#ifdef _USERK_
                PTHREADINFO ptiCurrent = PtiCurrentShared();
                if(CALL_LPK(ptiCurrent))
#endif
                    ichComplexBreak = (*UserLpkDrawTextEx)(0, 0, 0, lpch, (int)(lpchEnd - lpch), 0,
                                        0, NULL, DT_GETNEXTWORD, -1);
                if (ichComplexBreak > 0)
                    return (lpch + ichComplexBreak);
            }
            lpch++;
            ichNonWhite = 0;
        }
    }

    return lpch;
}

/***************************************************************************\
* GetPrefixCount
*
* This routine returns the count of accelerator mnemonics and the
* character location (starting at 0) of the character to underline.
* A single CH_PREFIX character will be striped and the following character
* underlined, all double CH_PREFIX character sequences will be replaced by
* a single CH_PREFIX (this is done by PSMTextOut). This routine is used
* to determine the actual character length of the string that will be
* printed, and the location the underline should be placed. Only
* cch characters from the input string will be processed. If the lpstrCopy
* parameter is non-NULL, this routine will make a printable copy of the
* string with all single prefix characters removed and all double prefix
* characters collapsed to a single character. If copying, a maximum
* character count must be specified which will limit the number of
* characters copied.
*
* The location of the single CH_PREFIX is returned in the low order
* word, and the count of CH_PREFIX characters that will be striped
* from the string during printing is in the hi order word. If the
* high order word is 0, the low order word is meaningless. If there
* were no single prefix characters (i.e. nothing to underline), the
* low order word will be -1 (to distinguish from location 0).
*
* These routines assume that there is only one single CH_PREFIX character
* in the string.
*
* WARNING! this rountine returns information in BYTE count not CHAR count
* (so it can easily be passed onto GreExtTextOutW which takes byte
* counts as well)
*
* History:
* 11-13-90 JimA         Ported to NT
* 30-Nov-1992 mikeke    Client side version
\***************************************************************************/

LONG GetPrefixCount(
    LPCWSTR lpstr,
    int cch,
    LPWSTR lpstrCopy,
    int charcopycount)
{
    int chprintpos = 0;         /* Num of chars that will be printed */
    int chcount = 0;            /* Num of prefix chars that will be removed */
    int chprefixloc = -1;       /* Pos (in printed chars) of the prefix */
    WCHAR ch;

    /*
     * If not copying, use a large bogus count...
     */
    if (lpstrCopy == NULL)
        charcopycount = 32767;

    while ((cch-- > 0) && *lpstr && charcopycount-- != 0) {

        /*
         * Is this guy a prefix character ?
         */
        if ((ch = *lpstr++) == CH_PREFIX) {

            /*
             * Yup - increment the count of characters removed during print.
             */
            chcount++;

            /*
             * Is the next also a prefix char?
             */
            if (*lpstr != CH_PREFIX) {

                /*
                 * Nope - this is a real one, mark its location.
                 */
                chprefixloc = chprintpos;

            } else {

                /*
                 * yup - simply copy it if copying.
                 */
                if (lpstrCopy != NULL)
                    *(lpstrCopy++) = CH_PREFIX;
                cch--;
                lpstr++;
                chprintpos++;
            }
        } else if (ch == CH_ENGLISHPREFIX) {    // Still needs to be parsed
            /*
             * Yup - increment the count of characters removed during print.
             */
            chcount++;

            /*
             * Next character is a real one, mark its location.
             */
            chprefixloc = chprintpos;

        } else if (ch == CH_KANJIPREFIX) {      // Still needs to be parsed
            /*
             * We only support Alpha Numeric(CH_ENGLISHPREFIX).
             * no support for Kana(CH_KANJIPREFIX).
             */
            /*
             * Yup - increment the count of characters removed during print.
             */
            chcount++;

            if(cch) {
                /* don't copy the character */
                chcount++;
                lpstr++;
                cch--;
            }
        } else {

            /*
             * Nope - just inc count of char.  that will be printed
             */
            chprintpos++;
            if (lpstrCopy != NULL)
                *(lpstrCopy++) = ch;
        }
    }

    if (lpstrCopy != NULL)
        *lpstrCopy = 0;

    /*
     * Return the character counts
     */
    return MAKELONG(chprefixloc, chcount);
}

/***************************************************************************\
*  DT_GetExtentMinusPrefixes
\***************************************************************************/

int DT_GetExtentMinusPrefixes(HDC hdc, LPCWSTR lpchStr, int cchCount, UINT wFormat,
                        int iOverhang, LPDRAWTEXTDATA  lpDrawInfo, int iCharSet)
{
  int  iPrefixCount;
  int  cxPrefixes = 0;
  WCHAR PrefixChar = CH_PREFIX;
  SIZE size;
  PCLIENTINFO pci = GetClientInfo();
#ifdef _USERK_
  PTHREADINFO ptiCurrent = PtiCurrentShared();
#endif
  UNREFERENCED_PARAMETER(wFormat);

  if(!NOPREFIX(wFormat) &&
      (iPrefixCount = HIWORD(GetPrefixCount(lpchStr, cchCount, NULL, 0)))) {
      //
      // Kanji Windows has three shortcut prefixes...
      //  (ported from Win95 ctlmgr.c)
      //
      BOOL b16Bit;

#ifdef _USERK_
      try {
          b16Bit = pci->dwTIFlags & TIF_16BIT;
      } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
          b16Bit = FALSE;
      }
#else
      b16Bit = pci->dwTIFlags & TIF_16BIT;
#endif
      if (IS_DBCS_ENABLED() && b16Bit) {
          // 16bit apps compatibility
          cxPrefixes = KKGetPrefixWidth(hdc, lpchStr, cchCount) - (iPrefixCount * iOverhang);
      }
      else {
          if(lpDrawInfo->bCharsetDll) {
#ifdef _USERK_
              if(CALL_LPK(ptiCurrent))
#endif // _USERK_
              {
                  // Call LPKDrawTextEx with fDraw = FALSE just to get the text extent.
                  return (*UserLpkDrawTextEx)(hdc, 0, 0, lpchStr, cchCount, FALSE,
                         wFormat, lpDrawInfo, DT_CHARSETDRAW, iCharSet);
              }
          } else {
              cxPrefixes = UserGetTextExtentPointW(hdc, &PrefixChar, 1, &size);
              cxPrefixes = size.cx - iOverhang;
              cxPrefixes *=  iPrefixCount;
          }
      }
  }
#ifdef _USERK_
  if(CALL_LPK(ptiCurrent))
    xxxClientGetTextExtentPointW(hdc, lpchStr, cchCount, &size);
  else
#endif // _USERK_
    UserGetTextExtentPointW(hdc, lpchStr, cchCount, &size);
  return (size.cx - cxPrefixes);
}

/***************************************************************************\
*   DT_DrawStr
*      This will draw the given string in the given location without worrying
*  about the left/right justification. Gets the extent and returns it.
*  If fDraw is TRUE and if NOT DT_CALCRECT, this draws the text.
*        NOTE: This returns the extent minus Overhang.
*
*   From Chicago ctlmgr.c  FritzS
\***************************************************************************/
int DT_DrawStr(HDC hdc, int  xLeft, int yTop, LPCWSTR lpchStr,
               int cchCount, BOOL fDraw, UINT wFormat,
               LPDRAWTEXTDATA  lpDrawInfo, int iCharSet)
{
    LPCWSTR        lpch;
    int   iLen;
    int   cxExtent;
    int   xOldLeft = xLeft;  // Save the xLeft given to compute the extent later
    int   xTabLength = lpDrawInfo->cxTabLength;
    int   iTabOrigin = lpDrawInfo->rcFormat.left;

    //
    // Because xLeft and yTop is a point in a rect, and we shift the rect in a mirrored hdc to include
    // its most right pixel, then shift this point as well.
    //
    if (UserGetLayout(hdc) & LAYOUT_RTL) {
        --xOldLeft;
        --xLeft;
    }

    //
    // if there is a charset dll, let it draw the text.
    //
    if(lpDrawInfo->bCharsetDll) {
#ifdef _USERK_
        PTHREADINFO ptiCurrent = PtiCurrentShared();

        //
        // Don't perform a callback if in thread cleanup mode.
        //
        if(!CALL_LPK(ptiCurrent))
            return 0 ;
#endif // _USERK_
        return (*UserLpkDrawTextEx)(hdc, xLeft, yTop, lpchStr, cchCount, fDraw,
                   wFormat, lpDrawInfo, DT_CHARSETDRAW, iCharSet);
    }

    // Check if the tabs need to be expanded
    if(EXPANDTABS(wFormat)) {
        while(cchCount) {
            // Look for a tab
            for(iLen = 0, lpch = lpchStr; iLen < cchCount; iLen++)
                  if(*lpch++ == TEXT('\t'))
                    break;

                // Draw text, if any, upto the tab
            if (iLen) {
                // Draw the substring taking care of the prefixes.
                if (fDraw && !CALCRECT(wFormat)) { // Only if we need to draw text
                    (*(lpDrawInfo->lpfnTextDraw))(hdc, xLeft, yTop, (LPWSTR)lpchStr, iLen, wFormat);
                }
                // Get the extent of this sub string and add it to xLeft.
                xLeft += DT_GetExtentMinusPrefixes(hdc, lpchStr, iLen, wFormat, lpDrawInfo->cxOverhang, lpDrawInfo, iCharSet) - lpDrawInfo->cxOverhang;
            }

            //if a TAB was found earlier, calculate the start of next sub-string.
            if (iLen < cchCount) {
                iLen++;  // Skip the tab
                if (xTabLength) // Tab length could be zero
                    xLeft = (((xLeft - iTabOrigin)/xTabLength) + 1)*xTabLength + iTabOrigin;
            }

            // Calculate the details of the string that remains to be drawn.
            cchCount -= iLen;
            lpchStr = lpch;
        }
        cxExtent = xLeft - xOldLeft;
    } else {
        // If required, draw the text (with either PSMTextOut or PSTextOut)
        if (fDraw && !CALCRECT(wFormat)) {
            (*(lpDrawInfo->lpfnTextDraw))(hdc, xLeft, yTop, (LPWSTR)lpchStr, cchCount, wFormat);
        }
        // Compute the extent of the text.
        cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchStr, cchCount, wFormat,
                                             lpDrawInfo->cxOverhang, lpDrawInfo, iCharSet) - lpDrawInfo->cxOverhang;
    }
    return cxExtent;
}

/***************************************************************************\
*  DT_DrawJustifiedLine
*      This function draws one complete line with proper justification
*
*   from Chicago ctlmgr.c  FritzS
\***************************************************************************/

void DT_DrawJustifiedLine(HDC  hdc, int yTop, LPCWSTR lpchLineSt,
                                 int cchCount, UINT wFormat,
                                 LPDRAWTEXTDATA lpDrawInfo, int iCharSet)
{
  LPRECT lprc;
  int   cxExtent;
  int   xLeft;

  lprc = &(lpDrawInfo->rcFormat);
  xLeft = lprc->left;

  // Handle the special justifications (right or centered) properly.
  if(wFormat & (DT_CENTER | DT_RIGHT)) {
      cxExtent = DT_DrawStr(hdc, xLeft, yTop, lpchLineSt, cchCount, FALSE,
                     wFormat, lpDrawInfo, iCharSet) + lpDrawInfo->cxOverhang;
      if(wFormat & DT_CENTER)
          xLeft = lprc->left + (((lprc->right - lprc->left) - cxExtent) >> 1);
      else
          xLeft = lprc->right - cxExtent;
    } else
      xLeft = lprc->left;

  // Draw the whole line.
  cxExtent = DT_DrawStr(hdc, xLeft, yTop, lpchLineSt, cchCount, TRUE, wFormat,
                        lpDrawInfo, iCharSet) +lpDrawInfo->cxOverhang;
  if(cxExtent > lpDrawInfo->cxMaxExtent)
      lpDrawInfo->cxMaxExtent = cxExtent;
}

/***************************************************************************\
* DT_InitDrawTextInfo
*      This is called at the begining of DrawText(); This initializes the
* DRAWTEXTDATA structure passed to this function with all the required info.
*
*  from Chicago ctlmgr.c  FritzS
\***************************************************************************/

BOOL DT_InitDrawTextInfo(
    HDC hdc,
    LPRECT lprc,
    UINT wFormat,
    LPDRAWTEXTDATA lpDrawInfo,
    LPDRAWTEXTPARAMS lpDTparams)
{
  SIZE   sizeViewPortExt = {0, 0},sizeWindowExt = {0, 0};
  TEXTMETRICW tm;
  LPRECT      lprcDest;
  int         iTabLength = 8;   // Default Tab length is 8 characters.
  int         iLeftMargin;
  int         iRightMargin;
  BOOL        fUseSystemFont;

  if (lpDTparams) {
      /*
       *  Only if DT_TABSTOP flag is mentioned, we must use the iTabLength field.
       */
      if (TABSTOP(wFormat))
          iTabLength = lpDTparams->iTabLength;
      iLeftMargin = lpDTparams->iLeftMargin;
      iRightMargin = lpDTparams->iRightMargin;
  } else {
      iLeftMargin = iRightMargin = 0;
  }

  /*
   *  Get the View port and Window extents for the given DC
   *  If this call fails, hdc must be invalid
   */
  if (!UserGetViewportExtEx(hdc,&sizeViewPortExt)) {
#ifndef _USERK_
      /*
       * This call fails on  standard Metafiles. So check
       * if the DC is really invalid to be compatible with
       * Win9x
       */
      if ((hdc == NULL) || !GdiValidateHandle(hdc))
#endif
          return FALSE;
  }
  UserGetWindowExtEx(hdc, &sizeWindowExt);

  /*
   *  For the current mapping mode,  find out the sign of x from left to right.
   */
  lpDrawInfo->iXSign =
      (((sizeViewPortExt.cx ^ sizeWindowExt.cx) & 0x80000000) ? -1 : 1);

  /*
   *  For the current mapping mode,  find out the sign of y from top to bottom.
   */
  lpDrawInfo->iYSign =
      (((sizeViewPortExt.cy ^ sizeWindowExt.cy) & 0x80000000) ? -1 : 1);

  /*
   *  Calculate the dimensions of the current font in this DC.
   * (If it is SysFont AND the mapping mode is MM_TEXT, use system font's data)
   */
  fUseSystemFont = ((wFormat & DT_INTERNAL) || IsSysFontAndDefaultMode(hdc));
  if (!fUseSystemFont) {
      /*
       *  Edit controls have their own way of calculating the aveCharWidth.
       */
      if (EDITCONTROL(wFormat)) {
          tm.tmAveCharWidth = UserGetCharDimensionsW(hdc, &tm, NULL);
          tm.tmCharSet = (BYTE)UserGetTextCharsetInfo(hdc, NULL, 0);
          if (tm.tmAveCharWidth == 0) {
              fUseSystemFont = TRUE;
          }
      } else if (!UserGetTextMetricsW(hdc, &tm)) {
          /*
           * This can fail in a hard error popup during logon or logoff
           * because UpdatePerUserSystemParameters destroys the server-side
           * font handle for the DC, and a repaint occurs before we switch
           * desktops (the switch recreates the popup from scratch with the
           * new font OK). ChrisWil's changes to move system-wide attributes
           * into desktops should take care of this in Kernel-mode.  This is
           * just a horrible, horrible hack for now.
           */
          RIPMSG0(RIP_WARNING, "UserGetTextMetricsW failed: only in logon/off?\n");
          tm.tmOverhang = 0;

          /*
           * We should probably set fUseSystemFont to TRUE here. But I
           *  assume that this "horrible hack" works fine plus it has been
           *  here for good. So I'll leave it alone. 6/3/96
           */
      }
  }

  if (fUseSystemFont) {
      /*
       *  Avoid GetTextMetrics for internal calls since they use sys font.
       */
      tm.tmHeight = gpsi->cySysFontChar;
      tm.tmExternalLeading = gpsi->tmSysFont.tmExternalLeading;
      tm.tmAveCharWidth = gpsi->tmSysFont.tmAveCharWidth;
      tm.tmOverhang = gpsi->tmSysFont.tmOverhang;
#ifdef _USERK_
      tm.tmCharSet = (BYTE)UserGetTextCharsetInfo(gpDispInfo->hdcScreen, NULL, 0);
#else
      tm.tmCharSet = (BYTE)UserGetTextCharsetInfo(ghdcBits2, NULL, 0);
#endif // _USERK_
  }


  // cyLineHeight is in pixels (This will be signed).
  lpDrawInfo->cyLineHeight = (tm.tmHeight +
            (EXTERNALLEADING(wFormat) ? tm.tmExternalLeading : 0)) *
            lpDrawInfo->iYSign;

  // cxTabLength is the tab length in pixels (This will not be signed)
  lpDrawInfo->cxTabLength = tm.tmAveCharWidth * iTabLength;

  // Set the cxOverhang
  lpDrawInfo->cxOverhang = tm.tmOverhang;

  // Pick up the proper TextOut function based on the prefix processing reqd.
#ifdef _USERK_
  lpDrawInfo->bCharsetDll = PpiCurrent()->dwLpkEntryPoints & LPK_DRAWTEXTEX;
  if (lpDrawInfo->bCharsetDll == FALSE) {
      lpDrawInfo->lpfnTextDraw = (NOPREFIX(wFormat) ? (LPFNTEXTDRAW)UserTextOutWInternal : xxxPSMTextOut);
  }
#else
  lpDrawInfo->bCharsetDll = (BOOL)(fpLpkDrawTextEx != (FPLPKDRAWTEXTEX)NULL);
  if (lpDrawInfo->bCharsetDll == FALSE) {
      lpDrawInfo->lpfnTextDraw = (NOPREFIX(wFormat) ? (LPFNTEXTDRAW)UserTextOutWInternal : PSMTextOut);
  }
#endif // _USERK_

  // Set up the format rectangle based on the margins.
//  LCopyStruct(lprc, lprcDest = (LPRECT)&(lpDrawInfo->rcFormat), sizeof(RECT));
  lprcDest = &(lpDrawInfo->rcFormat);
  *lprcDest = *lprc;

  // We need to do the following only if the margins are given
  if(iLeftMargin | iRightMargin) {
      lprcDest->left += iLeftMargin * lpDrawInfo->iXSign;
      lprcDest->right -= (lpDrawInfo->cxRightMargin = iRightMargin * lpDrawInfo->iXSign);
    } else
      lpDrawInfo->cxRightMargin = 0;  // Initialize to zero.

  // cxMaxWidth is unsigned.
  lpDrawInfo->cxMaxWidth = (lprcDest->right - lprcDest->left) * lpDrawInfo->iXSign;
  lpDrawInfo->cxMaxExtent = 0;  // Initialize this to zero.

  return TRUE;
}

/***************************************************************************\
* DT_AdjustWhiteSpaces
*      In the case of WORDWRAP, we need to treat the white spaces at the
* begining/end of each line specially. This function does that.
*  lpStNext = points to the begining of next line.
*  lpiCount = points to the count of characters in the current line.
\***************************************************************************/

LPCWSTR  DT_AdjustWhiteSpaces(LPCWSTR  lpStNext, LPINT lpiCount, UINT wFormat)
{
  switch(wFormat & DT_HFMTMASK) {
      case DT_LEFT:
        // Prevent a white space at the begining of a left justfied text.
        // Is there a white space at the begining of next line......
        if((*lpStNext == TEXT(' ')) || (*lpStNext == TEXT('\t'))) {
            // ...then, exclude it from next line.
            lpStNext++;
          }
        break;

      case DT_RIGHT:
        // Prevent a white space at the end of a RIGHT justified text.
        // Is there a white space at the end of current line,.......
        if((*(lpStNext-1) == TEXT(' ')) || (*(lpStNext - 1) == TEXT('\t'))) {
            // .....then, Skip the white space from the current line.
            (*lpiCount)--;
          }
        break;

      case DT_CENTER:
        // Exclude white spaces from the begining and end of CENTERed lines.
        // If there is a white space at the end of current line.......
        if((*(lpStNext-1) == TEXT(' ')) || (*(lpStNext - 1) == TEXT('\t')))
            (*lpiCount)--;    //...., don't count it for justification.
        // If there is a white space at the begining of next line.......
        if((*lpStNext == TEXT(' ')) || (*lpStNext == TEXT('\t')))
            lpStNext++;       //...., exclude it from next line.
        break;
    }
  return lpStNext;
}

/***************************************************************************\
*  DT_BreakAWord
*      A word needs to be broken across lines and this finds out where to
*  break it.
\***************************************************************************/
LPCWSTR  DT_BreakAWord(HDC  hdc, LPCWSTR lpchText,
              int iLength, int iWidth, UINT wFormat, int iOverhang, LPDRAWTEXTDATA  lpDrawInfo, int iCharSet)
{
  int  iLow = 0, iHigh = iLength;
  int  iNew;


  while((iHigh - iLow) > 1) {
      iNew = iLow + (iHigh - iLow)/2;
      if(DT_GetExtentMinusPrefixes(hdc, lpchText, iNew, wFormat, iOverhang, lpDrawInfo, iCharSet) > iWidth)
          iHigh = iNew;
      else
          iLow = iNew;
    }
  // If the width is too low, we must print atleast one char per line.
  // Else, we will be in an infinite loop.
  if(!iLow && iLength)
      iLow = 1;
  return (lpchText+iLow);
}

/***************************************************************************\
* DT_GetLineBreak
*      This finds out the location where we can break a line.
* Returns LPCSTR to the begining of next line.
* Also returns via lpiLineLength, the length of the current line.
* NOTE: (lpstNextLineStart - lpstCurrentLineStart) is not equal to the
* line length; This is because, we exclude some white spaces at the begining
* and/or end of lines; Also, CR/LF is excluded from the line length.
\***************************************************************************/

LPWSTR DT_GetLineBreak(
    HDC  hdc,
    LPCWSTR lpchLineStart,
    int   cchCount,
    DWORD dwFormat,
    LPINT lpiLineLength,
    LPDRAWTEXTDATA  lpDrawInfo,
    int iCharSet)
{
  LPCWSTR lpchText, lpchEnd, lpch, lpchLineEnd;
  int   cxStart, cxExtent, cxNewExtent;
  BOOL  fAdjustWhiteSpaces = FALSE;
  WCHAR  ch;
  DWORD dwCodePage = USERGETCODEPAGE(hdc);

  cxStart = lpDrawInfo->rcFormat.left;
  cxExtent = cxNewExtent = 0;
  lpchText = lpchLineStart;
  lpchEnd = lpchLineStart + cchCount;


  while(lpchText < lpchEnd) {
      lpchLineEnd = lpch = GetNextWordbreak(dwCodePage,lpchText, lpchEnd, dwFormat, lpDrawInfo);
      // DT_DrawStr does not return the overhang; Otherwise we will end up
      // adding one overhang for every word in the string.

      // For simulated Bold fonts, the summation of extents of individual
      // words in a line is greater than the extent of the whole line. So,
      // always calculate extent from the LineStart.
      // BUGTAG: #6054 -- Win95B -- SANKAR -- 3/9/95 --
      cxNewExtent = DT_DrawStr(hdc, cxStart, 0, lpchLineStart, (int)(((PBYTE)lpch - (PBYTE)lpchLineStart)/sizeof(WCHAR)), FALSE,
                 dwFormat, lpDrawInfo, iCharSet);

      if (WORDBREAK(dwFormat) && ((cxNewExtent + lpDrawInfo->cxOverhang) > lpDrawInfo->cxMaxWidth)) {
          // Are there more than one word in this line?
          if (lpchText != lpchLineStart)  {
              lpchLineEnd = lpch = lpchText;
              fAdjustWhiteSpaces = TRUE;
          } else {
              //One word is longer than the maximum width permissible.
              //See if we are allowed to break that single word.
              if(EDITCONTROL(dwFormat) && !WORDELLIPSIS(dwFormat)) {
                  lpchLineEnd = lpch = DT_BreakAWord(hdc, lpchText, (int)(((PBYTE)lpch - (PBYTE)lpchText)/sizeof(WCHAR)),
                        lpDrawInfo->cxMaxWidth - cxExtent,
                        dwFormat,
                        lpDrawInfo->cxOverhang, lpDrawInfo, iCharSet); //Break that word
                  //Note: Since we broke in the middle of a word, no need to
                  // adjust for white spaces.
              } else {
                  fAdjustWhiteSpaces = TRUE;
                  // Check if we need to end this line with ellipsis
                  if(WORDELLIPSIS(dwFormat))
                    {
                      // Don't do this if already at the end of the string.
                      if (lpch < lpchEnd)
                        {
                          // If there are CR/LF at the end, skip them.
                          if ((ch = *lpch) == CR || ch == LF)
                            {
                              if ((++lpch < lpchEnd) && (*lpch == (WCHAR)(ch ^ (LF ^ CR))))
                                  lpch++;
                              fAdjustWhiteSpaces = FALSE;
                            }
                        }
                    }
              }
          }
          // Well! We found a place to break the line. Let us break from this
          // loop;
          break;
      } else {
          // Don't do this if already at the end of the string.
          if (lpch < lpchEnd) {
              if ((ch = *lpch) == CR || ch == LF) {
                  if ((++lpch < lpchEnd) && (*lpch == (WCHAR)(ch ^ (LF ^ CR))))
                      lpch++;
                  fAdjustWhiteSpaces = FALSE;
                  break;
              }
          }
      }

      // Point at the beginning of the next word.
      lpchText = lpch;
      cxExtent = cxNewExtent;
  }

  // Calculate the length of current line.
  *lpiLineLength = (INT)((PBYTE)lpchLineEnd - (PBYTE)lpchLineStart)/sizeof(WCHAR);

  // Adjust the line length and lpch to take care of spaces.
  if(fAdjustWhiteSpaces && (lpch < lpchEnd))
      lpch = DT_AdjustWhiteSpaces(lpch, lpiLineLength, dwFormat);

  // return the begining of next line;
  return (LPWSTR)lpch;
}

/***************************************************************************\
*  NeedsEndEllipsis()
*      This function checks whether the given string fits within the given
*      width or we need to add end-ellipse. If it required end-ellipses, it
*      returns TRUE and it returns the number of characters that are saved
*      in the given string via lpCount.
\***************************************************************************/
BOOL  NeedsEndEllipsis(HDC        hdc,
                                     LPCWSTR     lpchText,
                                     LPINT      lpCount,
                                     LPDRAWTEXTDATA  lpDTdata,
                                     UINT       wFormat, LPDRAWTEXTDATA  lpDrawInfo, int iCharSet)
{
    int   cchText;
    int   ichMin, ichMax, ichMid;
    int   cxMaxWidth;
    int   iOverhang;
    int   cxExtent;
    SIZE size;
    cchText = *lpCount;  // Get the current count.

    if (cchText == 0)
        return FALSE;

    cxMaxWidth  = lpDTdata->cxMaxWidth;
    iOverhang   = lpDTdata->cxOverhang;

    cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchText, cchText, wFormat, iOverhang, lpDrawInfo, iCharSet);

    if (cxExtent <= cxMaxWidth)
        return FALSE;
    // Reserve room for the "..." ellipses;
    // (Assumption: The ellipses don't have any prefixes!)
    UserGetTextExtentPointW(hdc, szEllipsis, CCHELLIPSIS, &size);
    cxMaxWidth -= size.cx - iOverhang;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxMaxWidth > 0) {
        // Binary search to find characters that will fit.
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax) {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchText, ichMid, wFormat, iOverhang, lpDrawInfo, iCharSet);

            if (cxExtent < cxMaxWidth)
                ichMin = ichMid;
            else {
                if (cxExtent > cxMaxWidth)
                    ichMax = ichMid - 1;
                else {
                    // Exact match up up to ichMid: just exit.
                    //
                    ichMax = ichMid;
                    break;
                  }
              }
          }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
      }

    *lpCount = ichMax;
    return TRUE;
}

/***************************************************************************\
* BOGUS: The same function is available in SHELL2.DLL also.
* We need to remove from one of the places.
\***************************************************************************/
// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo
/***************************************************************************\
\***************************************************************************/


LPWSTR PathFindFileName(LPCWSTR pPath, int cchText)
{
    LPCWSTR pT;

    for (pT = pPath; cchText > 0 && *pPath; pPath++, cchText--) {
        if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':')) && pPath[1])
            pT = pPath + 1;
    }

    return (LPWSTR)pT;   // REVIEW, should this be const?
}

/***************************************************************************\
* AddPathEllipse():
*      This adds a path ellipse to the given path name.
*      Returns TRUE if the resultant string's extent is less the the
* cxMaxWidth. FALSE, if otherwise.
\***************************************************************************/
int AddPathEllipsis(
    HDC    hDC,
    LPWSTR lpszPath,
    int    cchText,
    UINT   wFormat,
    int    cxMaxWidth,
    int    iOverhang, LPDRAWTEXTDATA  lpDrawInfo, int iCharSet)
{
  int    iLen;
  UINT   dxFixed, dxEllipsis;
  LPWSTR lpEnd;          /* end of the unfixed string */
  LPWSTR lpFixed;        /* start of text that we always display */
  BOOL   bEllipsisIn;
  int    iLenFixed;
  SIZE   size;

  lpFixed = PathFindFileName(lpszPath, cchText);
  if (lpFixed != lpszPath)
      lpFixed--;  // point at the slash
  else
      return cchText;

  lpEnd = lpFixed;
  bEllipsisIn = FALSE;
  iLenFixed = cchText - (int)(lpFixed - lpszPath);
  dxFixed = DT_GetExtentMinusPrefixes(hDC, lpFixed, iLenFixed, wFormat, iOverhang, lpDrawInfo, iCharSet);

  // It is assumed that the "..." string does not have any prefixes ('&').
  UserGetTextExtentPointW(hDC, szEllipsis, CCHELLIPSIS, &size);
  dxEllipsis = size.cx - iOverhang;

  while (TRUE) {
      iLen = dxFixed + DT_GetExtentMinusPrefixes(hDC, lpszPath, (int)((PBYTE)lpEnd - (PBYTE)lpszPath)/sizeof(WCHAR),
                                       wFormat, iOverhang, lpDrawInfo, iCharSet) - iOverhang;

      if (bEllipsisIn)
          iLen += dxEllipsis;

      if (iLen <= cxMaxWidth)
          break;

      bEllipsisIn = TRUE;

      if (lpEnd <= lpszPath) {
          /* Things didn't fit. */
          lpEnd = lpszPath;
          break;
      }

      /* Step back a character. */
      lpEnd--;
  }

  if (bEllipsisIn && (lpEnd + CCHELLIPSIS < lpFixed)) {
      // NOTE: the strings could over lap here. So, we use LCopyStruct.

      RtlMoveMemory((lpEnd + CCHELLIPSIS), lpFixed, iLenFixed * sizeof(WCHAR));
      RtlCopyMemory(lpEnd, szEllipsis, CCHELLIPSIS * sizeof(WCHAR));

      cchText = (int)(lpEnd - lpszPath) + CCHELLIPSIS + iLenFixed;

      // now we can NULL terminate the string
      *(lpszPath + cchText) = TEXT('\0');
  }

  return cchText;
}

//-----------------------------------------------------------------------
// This function returns the number of characters actually drawn.
//-----------------------------------------------------------------------
int AddEllipsisAndDrawLine(
    HDC            hdc,
    int            yLine,
    LPCWSTR        lpchText,
    int            cchText,
    DWORD          dwDTformat,
    LPDRAWTEXTDATA lpDrawInfo,
    int iCharSet)
{
    LPWSTR pEllipsis = NULL;
    WCHAR  szTempBuff[MAXBUFFSIZE];
    LPWSTR lpDest;
    BOOL   fAlreadyCopied = FALSE;

    // Check if this is a filename with a path AND
    // Check if the width is too narrow to hold all the text.
    if(PATHELLIPSIS(dwDTformat) &&
        ((DT_GetExtentMinusPrefixes(hdc, lpchText, cchText,
                   dwDTformat, lpDrawInfo->cxOverhang, lpDrawInfo, iCharSet)) > lpDrawInfo->cxMaxWidth)) {
        // We need to add Path-Ellipsis. See if we can do it in-place.
        if(!MODIFYSTRING(dwDTformat)) {
            // NOTE: When you add Path-Ellipsis, the string could grow by
            // CCHELLIPSIS bytes.
            if((cchText + CCHELLIPSIS + 1) <= MAXBUFFSIZE)
                lpDest = szTempBuff;
            else {   // Alloc from local heap.
                // Alloc the buffer from local heap.
                if(!(pEllipsis = (LPWSTR)UserRtlAllocMem(
                        (cchText+CCHELLIPSIS+1)*sizeof(WCHAR))))
                    return 0;
                lpDest = (LPWSTR)pEllipsis;
            }
            // Source String may not be NULL terminated. So, copy just
            // the given number of characters.
            RtlCopyMemory(lpDest, lpchText, cchText*sizeof(WCHAR));
            lpchText = lpDest;        // lpchText points to the copied buff.
            fAlreadyCopied = TRUE;    // Local copy has been made.
        }
        // Add the path ellipsis now!
        cchText = AddPathEllipsis(hdc, (LPWSTR)lpchText, cchText, dwDTformat,
            lpDrawInfo->cxMaxWidth, lpDrawInfo->cxOverhang, lpDrawInfo, iCharSet);
    }

    // Check if end-ellipsis are to be added.
    if((ENDELLIPSIS(dwDTformat) || WORDELLIPSIS(dwDTformat)) &&
        NeedsEndEllipsis(hdc, lpchText, &cchText, lpDrawInfo, dwDTformat, lpDrawInfo, iCharSet)) {
        // We need to add end-ellipsis; See if we can do it in-place.
        if(!MODIFYSTRING(dwDTformat) && !fAlreadyCopied) {
            // See if the string is small enough for the buff on stack.
            if((cchText+CCHELLIPSIS+1) <= MAXBUFFSIZE)
                lpDest = szTempBuff;  // If so, use it.
            else {
                // Alloc the buffer from local heap.
                if(!(pEllipsis = (LPWSTR)UserRtlAllocMem(
                        (cchText+CCHELLIPSIS+1)*sizeof(WCHAR))))
                    return 0;
                lpDest = pEllipsis;
            }
            // Make a copy of the string in the local buff.
            RtlCopyMemory(lpDest, lpchText, cchText*sizeof(WCHAR));
            lpchText = lpDest;
        }
        // Add an end-ellipsis at the proper place.
        RtlCopyMemory((LPWSTR)(lpchText+cchText), szEllipsis, (CCHELLIPSIS+1)*sizeof(WCHAR));
        cchText += CCHELLIPSIS;
    }

    // Draw the line that we just formed.
    DT_DrawJustifiedLine(hdc, yLine, lpchText, cchText, dwDTformat, lpDrawInfo, iCharSet);

    // Free the block allocated for End-Ellipsis.
    if(pEllipsis)
        UserRtlFreeMem(pEllipsis);

    return cchText;
}


/***************************************************************************\
* IDrawTextEx
*      This is the new DrawText API
\***************************************************************************/

/***************************************************************************\
* IDrawTextEx
*      This is the new DrawText API
\***************************************************************************/

int  DrawTextExW(
   HDC               hdc,
   LPWSTR            lpchText,
   int               cchText,
   LPRECT            lprc,
   UINT              dwDTformat,
   LPDRAWTEXTPARAMS  lpDTparams)
{
   /*
    * The LPK requires a charset.  The Unicode entry point always passes a -1,
    * but the ANSI entry point passes a more interesting value.  Both the
    * 'W' version and 'A' version of DrawTextEx call this common worker routine.
    */
   return DrawTextExWorker(hdc, lpchText, cchText, lprc, dwDTformat, lpDTparams, -1);
}

int  DrawTextExWorker(
   HDC               hdc,
   LPWSTR            lpchText,
   int               cchText,
   LPRECT            lprc,
   UINT              dwDTformat,
   LPDRAWTEXTPARAMS  lpDTparams,
   int               iCharset)
{
    DRAWTEXTDATA DrawInfo;
    WORD         wFormat = LOWORD(dwDTformat);
    LPWSTR       lpchTextBegin;
    LPWSTR       lpchEnd;
    LPWSTR       lpchNextLineSt;
    int          iLineLength;
    int          iySign;
    int          yLine;
    int          yLastLineHeight;
    HRGN         hrgnClip;
    int          iLineCount;
    RECT         rc;
    BOOL         fLastLine;
    WCHAR        ch;
    UINT         oldAlign;

#if DBG
    if (dwDTformat & ~DT_VALID)
        RIPMSG0 (RIP_WARNING, "DrawTextExW: Invalid dwDTformat flags");
#endif

    if (lpchText == NULL) {
        return 0;
    }

    if (cchText == 0 && *lpchText) {
        /*
         * infoview.exe passes lpchText that points to '\0'
         *
         * "Microsoft Expedia Streets and Trips 2000" and "MS MapPoint 2000"
         * tries cchText == 0 to detect if DrawTextW is supported.
         */

        /* Added by Chicago:
         * Lotus Notes doesn't like getting a zero return here
         */
        return 1;
    }

    if (cchText == -1)
        cchText = wcslen(lpchText);



    if ((lpDTparams) && (lpDTparams->cbSize != sizeof(DRAWTEXTPARAMS))) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "DrawTextEx: cbSize %ld is invalid",
                lpDTparams->cbSize);
        return 0;
    }

#ifdef LATER
    /*
     * If DT_MODIFYSTRING is specified, then check for read-write pointer.
     */
    if (MODIFYSTRING(dwDTformat) &&
            (ENDELLIPSIS(dwDTformat) || PATHELLIPSIS(dwDTformat))) {
        if(IsBadWritePtr(lpchText, cchText)) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "DrawTextEx: For DT_MODIFYSTRING, lpchText must be read-write");
            return(0);
        }
    }
#endif

    /*
     * Initialize the DrawInfo structure.
     */
    if (!DT_InitDrawTextInfo(hdc, lprc, dwDTformat, (LPDRAWTEXTDATA)&DrawInfo, lpDTparams))
        return 0;

    DrawInfo.iCharset = iCharset;
    /*
     * If the rect is too narrow or the margins are too wide.....Just forget it!
     *
     * If wordbreak is specified, the MaxWidth must be a reasonable value.
     * This check is sufficient because this will allow CALCRECT and NOCLIP
     * cases.  --SANKAR.
     *
     * This also fixed all of our known problems with AppStudio.
     */
    if (DrawInfo.cxMaxWidth <= 0) {

        /*
         * We used to return a non-zero value in win31.
         * If the kernel calls this we are always Ver 4.0 or above
         */
#ifdef _USERK_
        if (0) {
#else
        if (GETAPPVER() < VER40) {
#endif
            if((DrawInfo.cxMaxWidth == 0) && !CALCRECT(wFormat)) {
                return(1);
            }
        } else {
            if (WORDBREAK(wFormat)) {
                RIPMSG0 (RIP_WARNING, "DrawTextExW: FAILURE DrawInfo.cxMaxWidth <=0");
                return (1);
            }
        }
    }

    /*
     * if we're not doing the drawing, initialise the lpk-dll
     */
    if (RTLREADING(dwDTformat)) {
        oldAlign = UserSetTextAlign(hdc, TA_RTLREADING | UserGetTextAlign(hdc));
    }

    /*
     * If we need to clip, let us do that.
     */
    if (!NOCLIP(wFormat)) {
        //
        // Save clipping region so we can restore it later.
        //
        // hrgnSave = SaveClipRgn(hdc);
        // IntersectClipRect(hdc, lprc->left, lprc->top, lprc->right, lprc->bottom);

        hrgnClip = UserCreateRectRgn(0,0,0,0);
        if (hrgnClip != NULL) {
            if (UserGetClipRgn(hdc, hrgnClip) != 1) {
                UserDeleteObject(hrgnClip);
                hrgnClip = (HRGN)-1;
            }
            rc = *lprc;
            UserIntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
        }
    } else {
        hrgnClip = NULL;
    }

    lpchTextBegin = lpchText;
    lpchEnd = lpchText + cchText;

ProcessDrawText:

    iLineCount = 0;  // Reset number of lines to 1.
    yLine = lprc->top;

    if (SINGLELINE(wFormat)) {
        iLineCount = 1;  // It is a single line.


        /*
         * Process single line DrawText.
         */
        switch (wFormat & DT_VFMTMASK) {
            case DT_BOTTOM:
                yLine = lprc->bottom - DrawInfo.cyLineHeight;
                break;

            case DT_VCENTER:
                yLine = lprc->top + ((lprc->bottom - lprc->top - DrawInfo.cyLineHeight) / 2);
                break;
        }

        cchText = AddEllipsisAndDrawLine(hdc, yLine, lpchText, cchText, dwDTformat, &DrawInfo, iCharset);
        yLine += DrawInfo.cyLineHeight;
        lpchText += cchText;
    } else  {

        /*
         * Multiline
         * If the height of the rectangle is not an integral multiple of the
         * average char height, then it is possible that the last line drawn
         * is only partially visible. However, if DT_EDITCONTROL style is
         * specified, then we must make sure that the last line is not drawn if
         * it is going to be partially visible. This will help imitate the
         * appearance of an edit control.
         */
        if (EDITCONTROL(wFormat))
            yLastLineHeight = DrawInfo.cyLineHeight;
        else
            yLastLineHeight = 0;

        iySign = DrawInfo.iYSign;
        fLastLine = FALSE;
        // Process multiline DrawText.
        while ((lpchText < lpchEnd) && (!fLastLine)) {
          // Check if the line we are about to draw is the last line that needs
          // to be drawn.
          // Let us check if the display goes out of the clip rect and if so
          // let us stop here, as an optimisation;
          if (!CALCRECT(wFormat) &&         // We don't need to calc rect?
                  (!NOCLIP(wFormat)) &&     // Must we clip the display ?
                                            // Are we outside the rect?
                  ((yLine + DrawInfo.cyLineHeight + yLastLineHeight)*iySign > (lprc->bottom*iySign))) {
              fLastLine = TRUE;    // Let us quit this loop
          }


          /*
           * We do the Ellipsis processing only for the last line.
           */
          if (fLastLine && (ENDELLIPSIS(dwDTformat) || PATHELLIPSIS(dwDTformat))) {
              lpchText += AddEllipsisAndDrawLine(hdc, yLine, lpchText, cchText, dwDTformat, &DrawInfo, iCharset);
          } else {
              lpchNextLineSt = (LPWSTR)DT_GetLineBreak(hdc, lpchText, cchText, dwDTformat, &iLineLength, &DrawInfo, iCharset);

              /*
               * Check if we need to put ellipsis at the end of this line.
               * Also check if this is the last line.
               */
              if (WORDELLIPSIS(dwDTformat) ||
                       ((lpchNextLineSt >= lpchEnd) && (ENDELLIPSIS(dwDTformat) || PATHELLIPSIS(dwDTformat))))
                  AddEllipsisAndDrawLine(hdc, yLine, lpchText, iLineLength, dwDTformat, &DrawInfo, iCharset);
              else
                  DT_DrawJustifiedLine(hdc, yLine, lpchText, iLineLength, dwDTformat, &DrawInfo, iCharset);
              cchText -= (int)((PBYTE)lpchNextLineSt - (PBYTE)lpchText) / sizeof(WCHAR);
              lpchText = lpchNextLineSt;
          }
            iLineCount++; // We draw one more line.
            yLine += DrawInfo.cyLineHeight;
        }


        /*
         * For Win3.1 and NT compatibility, if the last char is a CR or a LF
         * then the height returned includes one more line.
         */
        if (!EDITCONTROL(dwDTformat) &&
                (lpchEnd > lpchTextBegin)    &&   // If zero length it will fault.
                (((ch = (*(lpchEnd-1))) == CR) || (ch == LF)))
            yLine += DrawInfo.cyLineHeight;
    }


    /*
     * If DT_CALCRECT, modify width and height of rectangle to include
     * all of the text drawn.
     */
    if (CALCRECT(wFormat)) {
        DrawInfo.rcFormat.right = DrawInfo.rcFormat.left + DrawInfo.cxMaxExtent * DrawInfo.iXSign;
        lprc->right = DrawInfo.rcFormat.right + DrawInfo.cxRightMargin;

        // If the Width is more than what was provided, we have to redo all
        // the calculations, because, the number of lines can be less now.
        // (We need to do this only if we have more than one line).
        if((iLineCount > 1) && (DrawInfo.cxMaxExtent > DrawInfo.cxMaxWidth)) {
            DrawInfo.cxMaxWidth = DrawInfo.cxMaxExtent;
            lpchText = lpchTextBegin;
            cchText = (int)((PBYTE)lpchEnd - (PBYTE)lpchTextBegin)/sizeof(WCHAR);
            goto  ProcessDrawText;  // Start all over again!
        }
        lprc->bottom = yLine;
    }

// if (!NOCLIP(wFormat))
// {
//     RestoreClipRgn(hdc, hrgnClip);
// }

    if (hrgnClip != NULL) {
        if (hrgnClip == (HRGN)-1) {
            UserExtSelectClipRgn(hdc, NULL, RGN_COPY);
        } else {
            UserExtSelectClipRgn(hdc, hrgnClip, RGN_COPY);
            UserDeleteObject(hrgnClip);
        }
    }

    if (RTLREADING(dwDTformat))
        UserSetTextAlign(hdc, oldAlign);

    /*
     * Copy the number of characters actually drawn
     */
    if(lpDTparams != NULL)
        lpDTparams->uiLengthDrawn = (UINT)((PBYTE)lpchText - (PBYTE)lpchTextBegin)/sizeof(WCHAR);

    if (yLine == lprc->top)
        return 1;

    return (yLine - lprc->top);
}

/***************************************************************************\
*
* IsSysFontAndDefaultMode()
*
* Returns TRUE if font selected into DC is the system font AND the current
* mapping mode of the DC is MM_TEXT (Default mode); else returns FALSE. This
* is called by interrupt time code so it needs to be in the fixed code
* segment.
*
* History:
* 07-Jul-95 BradG   Ported from Win95
\***************************************************************************/

BOOL IsSysFontAndDefaultMode(HDC hdc)
{
    return((UserGetHFONT(hdc) == ghFontSys) && (UserGetMapMode(hdc) == MM_TEXT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\precomp.h ===
#ifdef _USERK_
#define NOWINBASEINTERLOCK
#else
#define NONTOSPINTERLOCK
#endif
#include <ntosp.h>

#include <ntrtl.h>

#include <stdio.h>

#include "userrtl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\input.c ===
/****************************** Module Header ******************************\
* Module Name: input.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains common input functions.
*
* History:
* 09-12-95 JerrySh      Created.
\***************************************************************************/


/***************************************************************************\
* CheckMsgRange
*
* Checks to see if a message range is within a message filter
*
* History:
* 11-13-90 DavidPe      Created.
* 11-Oct-1993 mikeke    Macroized
\***************************************************************************/

#define CheckMsgRange(wMsgRangeMin, wMsgRangeMax, wMsgFilterMin, wMsgFilterMax) \
    (  ((wMsgFilterMin) > (wMsgFilterMax))      \
     ? (  ((wMsgRangeMax) >  (wMsgFilterMax))   \
        &&((wMsgRangeMin) <  (wMsgFilterMin)))  \
     : (  ((wMsgRangeMax) >= (wMsgFilterMin))   \
        &&((wMsgRangeMin) <= (wMsgFilterMax)))  \
    )

/***************************************************************************\
* CalcWakeMask
*
* Calculates which wakebits to check for based on the message
* range specified by wMsgFilterMin/Max.  This basically means
* if the filter range didn't input WM_KEYUP and WM_KEYDOWN,
* QS_KEY wouldn't be included.
*
* History:
* 10-28-90 DavidPe      Created.
\***************************************************************************/

UINT CalcWakeMask(
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT fsWakeMaskFilter)
{
    UINT fsWakeMask;

    /*
     * New for NT5: wake mask filter.
     * In addition to the message filter, the application can also provide
     *      a wake mask directly.
     * If none is provided, default to NT4 mask (plus QS_SENDMESSAGE).
     */
    if (fsWakeMaskFilter == 0) {
        fsWakeMask = (QS_ALLINPUT | QS_EVENT | QS_ALLPOSTMESSAGE);
    } else {
        /*
         * If the caller wants input, we force all input events. The
         *  same goes for posted messages. We do this to keep NT4
         *  compatibility as much as possible.
         */
        if (fsWakeMaskFilter & QS_INPUT) {
            fsWakeMaskFilter |= (QS_INPUT | QS_EVENT);
        }
        if (fsWakeMaskFilter & (QS_POSTMESSAGE | QS_TIMER | QS_HOTKEY)) {
            fsWakeMaskFilter |= (QS_POSTMESSAGE | QS_TIMER | QS_HOTKEY);
        }
        fsWakeMask = fsWakeMaskFilter;
    }

#ifndef _USERK_
    /*
     * The client PeekMessage in client\cltxt.h didn't used to
     *  call CalcWakeMask if wMsgFilterMax was 0. We call it now
     *  to take care of fsWakeMaskFilter but still bail before
     *  messing with the message filter.
     */
    if (wMsgFilterMax == 0) {
        return fsWakeMask;
    }
#endif

    /*
     * Message filter.
     * If the filter doesn't match certain ranges, we take out bits one by one.
     * First check for a 0, 0 filter which means we want all input.
     */
    if (wMsgFilterMin == 0 && wMsgFilterMax == ((UINT)-1)) {
        return fsWakeMask;
    }

    /*
     * We're not looking at all posted messages.
     */
    fsWakeMask &= ~QS_ALLPOSTMESSAGE;

    /*
     * Check for mouse move messages.
     */
    if ((CheckMsgFilter(WM_NCMOUSEMOVE, wMsgFilterMin, wMsgFilterMax) == FALSE) &&
            (CheckMsgFilter(WM_MOUSEMOVE, wMsgFilterMin, wMsgFilterMax) == FALSE)) {
        fsWakeMask &= ~QS_MOUSEMOVE;
    }

    /*
     * First check to see if mouse buttons messages are in the filter range.
     */
    if ((CheckMsgRange(WM_NCLBUTTONDOWN, WM_NCMBUTTONDBLCLK, wMsgFilterMin,
            wMsgFilterMax) == FALSE) && (CheckMsgRange(WM_MOUSEFIRST + 1,
            WM_MOUSELAST, wMsgFilterMin, wMsgFilterMax) == FALSE)) {
        fsWakeMask &= ~QS_MOUSEBUTTON;
    }

    /*
     * Check for key messages.
     */
    if (CheckMsgRange(WM_KEYFIRST, WM_KEYLAST, wMsgFilterMin, wMsgFilterMax) == FALSE) {
        fsWakeMask &= ~QS_KEY;
    }

#ifdef GENERIC_INPUT
    /*
     * Check for raw input messages
     */
    if (CheckMsgRange(WM_INPUT, WM_INPUT, wMsgFilterMin, wMsgFilterMax) == FALSE) {
        fsWakeMask &= ~QS_RAWINPUT;
    }
#endif

    /*
     * Check for paint messages.
     */
    if (CheckMsgFilter(WM_PAINT, wMsgFilterMin, wMsgFilterMax) == FALSE) {
        fsWakeMask &= ~QS_PAINT;
    }

    /*
     * Check for timer messages.
     */
    if ((CheckMsgFilter(WM_TIMER, wMsgFilterMin, wMsgFilterMax) == FALSE) &&
            (CheckMsgFilter(WM_SYSTIMER,
            wMsgFilterMin, wMsgFilterMax) == FALSE)) {
        fsWakeMask &= ~QS_TIMER;
    }

    /*
     * Check also for WM_QUEUESYNC which maps to all input bits.
     * This was added for CBT/EXCEL processing.  Without it, a
     * xxxPeekMessage(....  WM_QUEUESYNC, WM_QUEUESYNC, FALSE) would
     * not see the message. (bobgu 4/7/87)
     * Since the user can provide a wake mask now (fsWakeMaskFilter),
     *  we also add QS_EVENT in this case (it was always set on NT4).
     */
    if (wMsgFilterMin == WM_QUEUESYNC) {
        fsWakeMask |= (QS_INPUT | QS_EVENT);
    }

    return fsWakeMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\menu.c ===
/****************************** Module Header ******************************\
* Module Name: menu.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains common menu functions.
*
* History:
* 11-15-94 JimA         Created.
\***************************************************************************/


/***************************************************************************\
* GetMenuDefaultItem
*
* Searches through a menu for the default item. A menu can have at most
* one default. We will return either the ID or the position, as requested.
*
* We try to return back the first non-disabled default item. However, if
* all of the defaults we encountered were disabled, we'll return back the
* the first default if we found it.
*
\***************************************************************************/
DWORD _GetMenuDefaultItem(
    PMENU pMenu,
    BOOL fByPosition,
    UINT uFlags)
{
    int iItem, cItems;
    PITEM pItem;
    PMENU pSubMenu;

    pItem = REBASEALWAYS(pMenu, rgItems);
    cItems = pMenu->cItems;

    /*
     * Walk the list of items sequentially until we find one that has
     * MFS_DEFAULT set.
     */
    for (iItem = 0; iItem < cItems; iItem++, pItem++) {
        if (TestMFS(pItem, MFS_DEFAULT)) {
            if ((uFlags & GMDI_USEDISABLED) || !TestMFS(pItem, MFS_GRAYED)) {
                if ((uFlags & GMDI_GOINTOPOPUPS) && (pItem->spSubMenu != NULL)) {
                    DWORD id;

                    /*
                     * Is there a valid submenu default?  If not, we'll use
                     * this one.
                     */
                    pSubMenu = REBASEPTR(pMenu, pItem->spSubMenu);
                    id = _GetMenuDefaultItem(pSubMenu, fByPosition, uFlags);
                    if (id != MFMWFP_NOITEM)
                        return id;
                }

                break;
            }
        }
    }

    if (iItem < cItems) {
        return (fByPosition ? iItem : pItem->wID);
    } else {
        return MFMWFP_NOITEM;
    }
}

/***************************************************************************\
* xxxMNCanClose
*
* Returns TRUE if the given window either doesn't have a system menu or has
* a system menu which has an enabled menu item with the SC_CLOSE syscommand
* id.
*
\***************************************************************************/
BOOL xxxMNCanClose(
    PWND pwnd)
{
    PMENU   pMenu;
    PITEM   pItem;
    PCLS    pcls;

    CheckLock(pwnd);

    pcls = (PCLS)REBASEALWAYS(pwnd, pcls);
    if (TestCF2(pcls, CFNOCLOSE)) {
        return FALSE;
    }

    pMenu = xxxGetSysMenuHandle(pwnd);
    if (!pMenu || !(pMenu = REBASEPTR(pwnd, pMenu))) {
        return FALSE;
    }

    /*
     * Note how this parallels the code in SetCloseDefault -- we check for
     * 3 different IDs.
     */
    pItem = MNLookUpItem(pMenu, SC_CLOSE, FALSE, NULL);

    if (!pItem) {
        pItem = MNLookUpItem(pMenu, SC_CLOSE-0x7000, FALSE, NULL);
        if (!pItem) {
            pItem = MNLookUpItem(pMenu, 0xC070, FALSE, NULL);
        }
    }

    return (pItem && !TestMFS(pItem, MFS_GRAYED));
}

/***************************************************************************\
* xxxLoadSysMenu
*
* Loads a menu from USER32.DLL and then gives it the "NT5 look".
*
* History
*  04/02/97 GerardoB    Created.
*  06/28/00 JasonSch    Added code to add menu item for the lame button.
\***************************************************************************/
RTLMENU xxxLoadSysMenu(
#ifdef LAME_BUTTON
    UINT uMenuId,
    PWND pwnd)
#else
    UINT uMenuId)
#endif // LAME_BUTTON
{
    RTLMENU rtlMenu;
    MENUINFO mi;
    MENUITEMINFO mii;
    TL tlMenu;

#ifdef _USERK_
    UNICODE_STRING strMenuName;
    RtlInitUnicodeStringOrId(&strMenuName, MAKEINTRESOURCE(uMenuId));
    rtlMenu = xxxClientLoadMenu(NULL, &strMenuName);
#else
    rtlMenu = LoadMenu(hmodUser, MAKEINTRESOURCE(uMenuId));
#endif // _USERK_

    if (rtlMenu == NULL) {
        RIPMSG1(RIP_WARNING, "xxxLoadSysMenu failed to load: %#lx", uMenuId);
        return NULL;
    }

    ThreadLockAlways(rtlMenu, &tlMenu);

    /*
     * Add the checkorbmp style (draw bitmaps and checkmarks on the
     * same column).
     */
    mi.cbSize = sizeof(mi);
    mi.fMask = MIM_STYLE | MIM_APPLYTOSUBMENUS;
    mi.dwStyle = MNS_CHECKORBMP;
    xxxRtlSetMenuInfo(rtlMenu, &mi);

    /*
     * Add the bitmaps for close, minimize, maximize and restore items.
     */
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_BITMAP;
    mii.hbmpItem = HBMMENU_POPUP_CLOSE;
    xxxRtlSetMenuItemInfo(rtlMenu, SC_CLOSE, &mii);
    if (uMenuId != ID_DIALOGSYSMENU) {
        mii.hbmpItem = HBMMENU_POPUP_MINIMIZE;
        xxxRtlSetMenuItemInfo (rtlMenu, SC_MINIMIZE, &mii);
        mii.hbmpItem = HBMMENU_POPUP_MAXIMIZE;
        xxxRtlSetMenuItemInfo (rtlMenu, SC_MAXIMIZE, &mii);
        mii.hbmpItem = HBMMENU_POPUP_RESTORE;
        xxxRtlSetMenuItemInfo (rtlMenu, SC_RESTORE, &mii);
    }

#ifdef LAME_BUTTON
    if (pwnd && TestWF(pwnd, WEFLAMEBUTTON)) {
        /*
         * We want to add a lame button item to the this window's system menu.
         *
         * The menuitem is added to the beginning of the menu, and then a
         * separator is added after it.
         */
        RTLMENU rtlSubMenu = RtlGetSubMenu(rtlMenu, 0);
        PMENU pSubMenu;
#ifdef _USERK_
        pSubMenu = rtlSubMenu;
#else
        pSubMenu = VALIDATEHMENU(rtlSubMenu);
#endif // _USERK_

        if (pSubMenu != NULL) {
            UNICODE_STRING strItem;
            TL tlmenu;

            RtlInitUnicodeString(&strItem, gpsi->gwszLame);
            RtlZeroMemory(&mii, sizeof(mii));
            mii.cbSize = sizeof(mi);
            mii.fMask = MIIM_TYPE;
            mii.fType = MFT_SEPARATOR;

            ThreadLockAlways(rtlSubMenu, &tlmenu);
            xxxRtlInsertMenuItem(rtlSubMenu, 0, TRUE, &mii, &strItem);
            mii.fType = 0;
            mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STRING;
            mii.dwTypeData = strItem.Buffer;
            mii.wID = SC_LAMEBUTTON;
            xxxRtlInsertMenuItem(rtlSubMenu, 0, TRUE, &mii, &strItem);
            ThreadUnlock(&tlmenu);
        }
    }
#endif // LAME_BUTTON

    ThreadUnlock(&tlMenu);
    return rtlMenu;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\help.c ===
/****************************** Module Header ******************************\
* Module Name: help.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the various rectangle manipulation APIs.
*
* History:
* 23-May-95 BradG   Created for Kernel mode
\***************************************************************************/

BOOL FIsParentDude(PWND pwnd)
{
    return(TestWF(pwnd, WEFCONTROLPARENT) || TestWF(pwnd, WFDIALOGWINDOW) ||
        ((TestWF(pwnd, BFTYPEMASK) == BS_GROUPBOX) &&
         IS_BUTTON(pwnd)));
}


/***************************************************************************\
* GetContextHelpId()
*   Given a pwnd, this returns the Help Context Id for that window;
* Note: If a window does not have a Context Id of its own, then it inherits
* the ContextId of it's parent, if it is a child window; else, from its owner,
* it is a owned popup.
\***************************************************************************/

DWORD GetContextHelpId(
    PWND pwnd)
{
    DWORD  dwContextId;

    while (!(dwContextId = (DWORD)(ULONG_PTR)_GetProp(pwnd,
            MAKEINTATOM(gpsi->atomContextHelpIdProp), PROPF_INTERNAL))) {
        pwnd = (TestwndChild(pwnd) ?
                REBASEPWND(pwnd, spwndParent) :
                REBASEPWND(pwnd, spwndOwner));
        if (!pwnd || (GETFNID(pwnd) == FNID_DESKTOP))
            break;
    }

    return dwContextId;
}




/*
 * Dialog Child enumeration proc
 *
 * Enumerates children of a dialog looking for the child under the mouse.
 *
 */
BOOL CALLBACK EnumPwndDlgChildProc(PWND pwnd, LPARAM lParam)
{
    PDLGENUMDATA pDlgEnumData = (PDLGENUMDATA)lParam;

    if (pwnd != pDlgEnumData->pwndDialog && IsVisible(pwnd) &&
            PtInRect(KPRECT_TO_PRECT(&pwnd->rcWindow), pDlgEnumData->ptCurHelp)) {
        /*
         * If it's a group box, keep enumerating. This takes care of
         * the case where we have a disabled control in a group box.
         * We'll find the group box first, and keep enumerating until we
         * hit the disabled control.
         */
        pDlgEnumData->pwndControl = pwnd;
        return (FIsParentDude(pwnd));
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\mmrtl.c ===
/****************************** Module Header ******************************\
* Module Name: mmrtl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Multimonitor APIs.
*
* History:
* 29-Mar-1997 adams     Created.
\***************************************************************************/

#define Int32x32To32(x, y) ((x) * (y))

/*
 * There is no object locking in the client, so the monitor object can
 * go away at any time. Therefore to be safe, we need an exception handler.
 */
#ifdef _USERK_
#define BEGIN_EXCEPTION_HANDLER
#define END_EXCEPTION_HANDLER
#define END_EXCEPTION_HANDLER_EMPTY
#else // _USERK_
#define BEGIN_EXCEPTION_HANDLER try {
#define END_EXCEPTION_HANDLER \
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) { \
        pMonitorResult = NULL; \
    }
#define END_EXCEPTION_HANDLER_EMPTY \
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) { \
    }
#endif // _USERK_


/***************************************************************************\
* _MonitorFromPoint
*
* Calculate the monitor that a point is in or is nearest to.
*
* Arguments:
*     pt      - The point.
*     dwFlags - One of:
*         MONITOR_DEFAULTTONULL - If the point isn't in a monitor,
*             return NULL.
*
*         MONITOR_DEFAULTTOPRIMARY - If the point isn't in a monitor,
*             return the primary monitor.
*
*         MONITOR_DEFAULTTONEAREST - Return the monitor nearest the point.
*
* History:
* 22-Sep-1996 adams     Created.
* 29-Mar-1997 adams     Moved to rtl.
\***************************************************************************/

PMONITOR
_MonitorFromPoint(POINT pt, DWORD dwFlags)
{
    PMONITOR        pMonitor, pMonitorResult;
    int             dx;
    int             dy;

    UserAssert(dwFlags == MONITOR_DEFAULTTONULL ||
               dwFlags == MONITOR_DEFAULTTOPRIMARY ||
               dwFlags == MONITOR_DEFAULTTONEAREST);

    if (GetDispInfo()->cMonitors == 1 && dwFlags != MONITOR_DEFAULTTONULL)
        return GetPrimaryMonitor();

    switch (dwFlags) {
    case MONITOR_DEFAULTTONULL:
    case MONITOR_DEFAULTTOPRIMARY:
        /*
         * Return the monitor the point is in.
         */

        BEGIN_EXCEPTION_HANDLER

        for (   pMonitor = REBASESHAREDPTRALWAYS(GetDispInfo()->pMonitorFirst);
                pMonitor;
                pMonitor = REBASESHAREDPTR(pMonitor->pMonitorNext)) {

            if (!(pMonitor->dwMONFlags & MONF_VISIBLE))
                continue;

            if (PtInRect(KPRECT_TO_PRECT(&pMonitor->rcMonitor), pt)) {
                return pMonitor;
            }
        }

        END_EXCEPTION_HANDLER_EMPTY

        /*
         * Return what the user wants if it's not found.
         */
        switch (dwFlags) {
        case MONITOR_DEFAULTTONULL:
            return NULL;

        case MONITOR_DEFAULTTOPRIMARY:
            return GetPrimaryMonitor();

        default:
            UserAssertMsg0(FALSE, "Logic error in _MonitorFromPoint");
            break;
        }

    case MONITOR_DEFAULTTONEAREST:

#define MONITORFROMPOINTALGORITHM(SUMSQUARESMAX, SUMSQUARESTYPE, POINTMULTIPLY)     \
        SUMSQUARESTYPE  sumsquare;                                                  \
        SUMSQUARESTYPE  leastsumsquare;                                             \
        leastsumsquare = SUMSQUARESMAX;                                             \
        for (   pMonitor = REBASESHAREDPTRALWAYS(GetDispInfo()->pMonitorFirst);     \
                pMonitor;                                                           \
                pMonitor = REBASESHAREDPTR(pMonitor->pMonitorNext)) {               \
                                                                                    \
            if (!(pMonitor->dwMONFlags & MONF_VISIBLE))                             \
                continue;                                                           \
                                                                                    \
            /*                                                                      \
             * Determine distance from monitor along x axis.                        \
             */                                                                     \
            if (pt.x < pMonitor->rcMonitor.left) {                                  \
                dx = pMonitor->rcMonitor.left - pt.x;                               \
            } else if (pt.x < pMonitor->rcMonitor.right) {                          \
                dx = 0;                                                             \
            } else {                                                                \
                /*                                                                  \
                 * Monitor rectangles do not include the rightmost edge.            \
                 */                                                                 \
                dx = pt.x - (pMonitor->rcMonitor.right - 1);                        \
            }                                                                       \
                                                                                    \
            /*                                                                      \
             * Skip this monitor if dx is greater than dx^2 + dy^2.                 \
             * We do this check to avoid multiplication operations.                 \
             */                                                                     \
            if ((SUMSQUARESTYPE) dx >= leastsumsquare)                              \
                continue;                                                           \
                                                                                    \
            /*                                                                      \
             * Determine distance from monitor along y axis.                        \
             */                                                                     \
            if (pt.y < pMonitor->rcMonitor.top) {                                   \
                dy = pMonitor->rcMonitor.top - pt.y;                                \
            } else if (pt.y < pMonitor->rcMonitor.bottom) {                         \
                /*                                                                  \
                 * The point is in the monitor and we're done                       \
                 * if both dx and dy are zero.                                      \
                 */                                                                 \
                if (dx == 0)                                                        \
                    return pMonitor;                                                \
                                                                                    \
                dy = 0;                                                             \
            } else {                                                                \
                dy = pt.y - (pMonitor->rcMonitor.bottom - 1);                       \
            }                                                                       \
                                                                                    \
            /*                                                                      \
             * Calculate dx^2. Skip this monitor if dx is greater                   \
             * than dx^2 + dy^2. We do this check to avoid                          \
             * multiplication operations.                                           \
             */                                                                     \
            sumsquare = POINTMULTIPLY(dx, dx);                                      \
            if (sumsquare >= leastsumsquare)                                        \
                continue;                                                           \
                                                                                    \
            /*                                                                      \
             * Skip this monitor if dx^2 + y is greater than dx^2 + dy^2.           \
             * We do this check to avoid multiplication operations.                 \
             */                                                                     \
            if (sumsquare + (SUMSQUARESTYPE) dy >= leastsumsquare)                  \
                continue;                                                           \
                                                                                    \
            /*                                                                      \
             * Compute dx^2 + dy^2. Skip this monitor if it's not the least.        \
             */                                                                     \
            sumsquare += (SUMSQUARESTYPE) POINTMULTIPLY(dy, dy);                    \
            if (sumsquare >= leastsumsquare)                                        \
                continue;                                                           \
                                                                                    \
            /*                                                                      \
             * This is the closest monitor so far.                                  \
             */                                                                     \
            leastsumsquare = sumsquare;                                             \
            pMonitorResult = pMonitor;                                              \
        }

#if DBG
        pMonitorResult = (PMONITOR) -1;
#endif

        if (    pt.x < SHRT_MIN || SHRT_MAX < pt.x ||
                pt.y < SHRT_MIN || SHRT_MAX < pt.y) {

            BEGIN_EXCEPTION_HANDLER
            MONITORFROMPOINTALGORITHM(_UI64_MAX, ULONGLONG, Int32x32To64)
            END_EXCEPTION_HANDLER

        } else {

            BEGIN_EXCEPTION_HANDLER
            MONITORFROMPOINTALGORITHM(UINT_MAX, UINT, Int32x32To32)
            END_EXCEPTION_HANDLER

        }

        UserAssert(pMonitorResult != (PMONITOR) -1);
        return pMonitorResult;

    default:
        UserAssert(0 && "Logic error in _MonitorFromPoint, shouldn't have gotten here.");
        break;
    }

    UserAssert(0 && "Logic error in _MonitorFromPoint, shouldn't have gotten here.");
    return NULL;
}



/***************************************************************************\
* _MonitorFromRect
*
* Calculate the monitor that a rect is in or is nearest to.
*
* Arguments:
*     lprc    - The rect.
*     dwFlags - One of:
*         MONITOR_DEFAULTTONULL - If the rect doesn't intersect a monitor,
*             return NULL.
*
*         MONITOR_DEFAULTTOPRIMARY - If the rect doesn't intersect a monitor,
*             return the primary monitor.
*
*         MONITOR_DEFAULTTONEAREST - Return the monitor nearest the rect.
*
* History:
* 22-Sep-1996 adams     Created.
* 29-Mar-1997 adams     Moved to rtl.
\***************************************************************************/

PMONITOR
_MonitorFromRect(LPCRECT lprc, DWORD dwFlags)
{
    PDISPLAYINFO    pDispInfo;
    PMONITOR        pMonitor, pMonitorResult;
    RECT            rc;
    int             area, areaMost;

    UserAssert(dwFlags == MONITOR_DEFAULTTONULL ||
               dwFlags == MONITOR_DEFAULTTOPRIMARY ||
               dwFlags == MONITOR_DEFAULTTONEAREST);

    /*
     * Special case the most common case - 1 monitor.
     */
    pDispInfo = GetDispInfo();
    if (pDispInfo->cMonitors == 1 && dwFlags != MONITOR_DEFAULTTONULL)
        return GetPrimaryMonitor();

    /*
     * If rect is empty, use topleft point.
     */
    if (IsRectEmpty(lprc)) {
        return _MonitorFromPoint(*(LPPOINT)lprc, dwFlags);
    }

    /*
     * Return the primary monitor if the rectangle covers the desktop.
     */
    if (    lprc->left   <= pDispInfo->rcScreen.left &&
            lprc->top    <= pDispInfo->rcScreen.top &&
            lprc->right  >= pDispInfo->rcScreen.right &&
            lprc->bottom >= pDispInfo->rcScreen.bottom) {

        return GetPrimaryMonitor();
    }

    /*
     * Calculate the nearest rectangle by determining which
     * monitor has the greatest intersection with the rectangle.
     */

    BEGIN_EXCEPTION_HANDLER

    areaMost = 0;
    for (   pMonitor = REBASESHAREDPTRALWAYS(GetDispInfo()->pMonitorFirst);
            pMonitor;
            pMonitor = REBASESHAREDPTR(pMonitor->pMonitorNext)) {

        if (!(pMonitor->dwMONFlags & MONF_VISIBLE))
            continue;

        if (IntersectRect(&rc, lprc, KPRECT_TO_PRECT(&pMonitor->rcMonitor))) {
            if (EqualRect(&rc, lprc))
                return pMonitor;

            /*
             * Calculate the area of the intersection. Note that
             * the intersection must be in 16bit coordinats, since
             * we limit monitor rects to 16bit coordinate space.
             * So the result of any area calculation will fit in
             * in an int.
             */
            area = (rc.right - rc.left) * (rc.bottom - rc.top);
            if (area > areaMost) {
                areaMost = area;
                pMonitorResult = pMonitor;
            }
        }
    }

    END_EXCEPTION_HANDLER

    UserAssert(areaMost >= 0);
    if (areaMost > 0)
        return pMonitorResult;


    switch (dwFlags) {
    case MONITOR_DEFAULTTONULL:
        return NULL;

    case MONITOR_DEFAULTTOPRIMARY:
        return GetPrimaryMonitor();

    case MONITOR_DEFAULTTONEAREST:
        {
            int dx, dy;

#define MONITORFROMRECTALGORITHM(SUMSQUARESMAX, SUMSQUARESTYPE, POINTMULTIPLY)      \
            SUMSQUARESTYPE  sumsquare;                                              \
            SUMSQUARESTYPE  leastsumsquare;                                         \
            leastsumsquare = SUMSQUARESMAX;                                         \
            for (   pMonitor = REBASESHAREDPTRALWAYS(GetDispInfo()->pMonitorFirst); \
                    pMonitor;                                                       \
                    pMonitor = REBASESHAREDPTR(pMonitor->pMonitorNext)) {           \
                                                                                    \
                if (!(pMonitor->dwMONFlags & MONF_VISIBLE))                         \
                    continue;                                                       \
                                                                                    \
                /*                                                                  \
                 * Determine distance from monitor along x axis.                    \
                 */                                                                 \
                if (lprc->right <= pMonitor->rcMonitor.left) {                      \
                    /*                                                              \
                     * Add 1 because rectangles do not include the rightmost edge.  \
                     */                                                             \
                    dx = pMonitor->rcMonitor.left - lprc->right + 1;                \
                } else if (lprc->left < pMonitor->rcMonitor.right) {                \
                    dx = 0;                                                         \
                } else {                                                            \
                    /*                                                              \
                     * Add 1 because rectangles do not include the rightmost edge.  \
                     */                                                             \
                    dx = lprc->left - (pMonitor->rcMonitor.right - 1);              \
                }                                                                   \
                                                                                    \
                /*                                                                  \
                 * Skip this monitor if dx is greater than dx^2 + dy^2.             \
                 * We do this check to avoid multiplication operations.             \
                 */                                                                 \
                if ((SUMSQUARESTYPE) dx >= leastsumsquare)                          \
                    continue;                                                       \
                                                                                    \
                /*                                                                  \
                 * Determine distance from monitor along y axis.                    \
                 */                                                                 \
                if (lprc->bottom <= pMonitor->rcMonitor.top) {                      \
                    /*                                                              \
                     * Add 1 because rectangles do not include the bottommost edge. \
                     */                                                             \
                    dy = pMonitor->rcMonitor.top - lprc->bottom + 1;                \
                } else if (lprc->top < pMonitor->rcMonitor.bottom) {                \
                    UserAssert(dx != 0 && "This rectangle intersects a monitor, so we shouldn't be here."); \
                    dy = 0;                                                         \
                } else {                                                            \
                    /*                                                              \
                     * Add 1 because rectangles do not include the bottommost edge. \
                     */                                                             \
                    dy = lprc->top - pMonitor->rcMonitor.bottom + 1;                \
                }                                                                   \
                                                                                    \
                /*                                                                  \
                 * Calculate dx^2. Skip this monitor if dx is greater               \
                 * than dx^2 + dy^2. We do this check to avoid                      \
                 * multiplication operations.                                       \
                 */                                                                 \
                sumsquare = POINTMULTIPLY(dx, dx);                                  \
                if (sumsquare >= leastsumsquare)                                    \
                    continue;                                                       \
                                                                                    \
                /*                                                                  \
                 * Skip this monitor if dx^2 + y is greater than dx^2 + dy^2.       \
                 * We do this check to avoid multiplication operations.             \
                 */                                                                 \
                if (sumsquare + (SUMSQUARESTYPE) dy >= leastsumsquare)              \
                    continue;                                                       \
                                                                                    \
                /*                                                                  \
                 * Compute dx^2 + dy^2. Skip this monitor if it's not the least.    \
                 */                                                                 \
                sumsquare += (SUMSQUARESTYPE) POINTMULTIPLY(dy, dy);                \
                if (sumsquare >= leastsumsquare)                                    \
                    continue;                                                       \
                                                                                    \
                /*                                                                  \
                 * This is the closest monitor so far.                              \
                 */                                                                 \
                leastsumsquare = sumsquare;                                         \
                pMonitorResult = pMonitor;                                          \
            }

#if DBG
            pMonitorResult = (PMONITOR) -1;
#endif

            if (    lprc->left < SHRT_MIN || SHRT_MAX < lprc->left ||
                    lprc->top < SHRT_MIN || SHRT_MAX < lprc->top ||
                    lprc->right < SHRT_MIN || SHRT_MAX < lprc->right ||
                    lprc->bottom < SHRT_MIN || SHRT_MAX < lprc->bottom) {

                BEGIN_EXCEPTION_HANDLER
                MONITORFROMRECTALGORITHM(_UI64_MAX, ULONGLONG, Int32x32To64)
                END_EXCEPTION_HANDLER

            } else {

                BEGIN_EXCEPTION_HANDLER
                MONITORFROMRECTALGORITHM(UINT_MAX, UINT, Int32x32To32)
                END_EXCEPTION_HANDLER

            }

            UserAssert(pMonitorResult != (PMONITOR) -1);
            return pMonitorResult;
        }

    default:
        UserAssertMsg0(0, "Logic error in _MonitorFromWindow, shouldn't have gotten here.");
        break;
    }

    UserAssertMsg0(0, "Logic error in _MonitorFromWindow, shouldn't have gotten here.");
    return NULL;
}



/***************************************************************************\
* _MonitorFromWindow
*
* Calculate the monitor that a window is in or is nearest to. We use
* the center of the window to determine its location. If the window
* is minimized, use its normal position.
*
* Arguments:
*     pwnd    - The window.
*     dwFlags - One of:
*         MONITOR_DEFAULTTONULL - If the window doesn't intersect a monitor,
*             return NULL.
*
*         MONITOR_DEFAULTTOPRIMARY - If the window doesn't intersect a monitor,
*             return the primary monitor.
*
*         MONITOR_DEFAULTTONEAREST - Return the monitor nearest the window.
*
* History:
* 22-Sep-1996 adams     Created.
* 29-Mar-1997 adams     Moved to rtl.
\***************************************************************************/

PMONITOR
_MonitorFromWindow(PWND pwnd, DWORD dwFlags)
{
    PWND            pwndParent;

    UserAssert(dwFlags == MONITOR_DEFAULTTONULL ||
               dwFlags == MONITOR_DEFAULTTOPRIMARY ||
               dwFlags == MONITOR_DEFAULTTONEAREST);

    if (GetDispInfo()->cMonitors == 1 && dwFlags != MONITOR_DEFAULTTONULL) {
        return GetPrimaryMonitor();
    }

    if (!pwnd)
        goto NoWindow;

    /*
     * Handle minimized windows.
     */
    if (TestWF(pwnd, WFMINIMIZED))
    {
#ifdef _USERK_
        CHECKPOINT *    pcp;

        pcp = (CHECKPOINT *)_GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL);
        if (pcp) {
            return _MonitorFromRect(&pcp->rcNormal, dwFlags);
        }
#else
        WINDOWPLACEMENT wp;
        HWND            hwnd;

        wp.length = sizeof(wp);
        hwnd = (HWND)PtoH(pwnd);
        if (GetWindowPlacement(hwnd, &wp)) {
            return _MonitorFromRect(&wp.rcNormalPosition, dwFlags);
        }

        /*
         * (adams) If GetWindowPlacement fails, then either there was not enough
         * memory to allocate a CHECKPOINT, or the window was destroyed
         * and the API failed. If the later, the following code my be
         * playing with invalid memory. Although on the client side we
         * can never guarantee that a window is valid, it seems especially
         * likely that it is invalid here. So do another revalidation
         * by calling IsWindow.
         */
        if (!IsWindow(hwnd))
            goto NoWindow;
#endif

        UserAssert(GETFNID(pwnd) != FNID_DESKTOP);
        pwndParent = REBASEPWND(pwnd, spwndParent);
        if (GETFNID(pwndParent) == FNID_DESKTOP) {
            return GetPrimaryMonitor();
        }

        /*
         * Otherwise, if we are a child window, fall thru below to use the
         * window rect, which actually means something for non-toplevel dudes.
         */
    }

    return _MonitorFromRect(KPRECT_TO_PRECT(&pwnd->rcWindow), dwFlags);

NoWindow:
    if (dwFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) {
        return GetPrimaryMonitor();
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\rect.c ===
/****************************** Module Header ******************************\
* Module Name: rect.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the various rectangle manipulation APIs.
*
* History:
* 10-20-90 DarrinM      Grabbed 'C' rect routines from Portable PM.
\***************************************************************************/

#ifdef _USERK_
    #define VALIDATERECT(prc, retval)   UserAssert(prc)
#else
    #define VALIDATERECT(prc, retval)   if (prc == NULL) return retval
#endif

/***********************************************************************\
* SetRect (API)
*
* This function fills a rectangle structure with the passed in coordinates.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\***********************************************************************/

BOOL APIENTRY SetRect(
    LPRECT prc,
    int left,
    int top,
    int right,
    int bottom)
{
    VALIDATERECT(prc, FALSE);

    prc->left = left;
    prc->top = top;
    prc->right = right;
    prc->bottom = bottom;
    return TRUE;
}

/************************************************************************\
* CopyInflateRect (API)
*
* This function copies the rect from prcSrc to prcDst, and inflates it.
*
* History:
* 12-16-93  FritzS
\************************************************************************/

BOOL APIENTRY CopyInflateRect(
    LPRECT prcDst,
    CONST RECT *prcSrc,
    int cx, int cy)
{
    prcDst->left   = prcSrc->left   - cx;
    prcDst->right  = prcSrc->right  + cx;
    prcDst->top    = prcSrc->top    - cy;
    prcDst->bottom = prcSrc->bottom + cy;
    return TRUE;
}

/************************************************************************\
* CopyOffsetRect (API)
*
* This function copies the rect from prcSrc to prcDst, and offsets it.
*
* History:
* 01-03-94  FritzS
\************************************************************************/

BOOL APIENTRY CopyOffsetRect(
    LPRECT prcDst,
    CONST RECT *prcSrc,
    int cx, int cy)
{
    prcDst->left   = prcSrc->left   + cx;
    prcDst->right  = prcSrc->right  + cx;
    prcDst->top    = prcSrc->top    + cy;
    prcDst->bottom = prcSrc->bottom + cy;
    return TRUE;
}

/************************************************************************\
* IsRectEmpty (API)
*
* This function returns TRUE if *prc is an empty rect, FALSE
* otherwise.  An empty rect is one that has no area: right is
* less than or equal to left, bottom is less than or equal to top.
*
* Warning:
*   This function assumes that the rect is in device coordinates
*   mode where left and top coordinate are smaller than right and
*   bottom.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY IsRectEmpty(
    CONST RECT *prc)
{
    VALIDATERECT(prc, TRUE);

    return ((prc->left >= prc->right) || (prc->top >= prc->bottom));
}

/***********************************************************************\
* PtInRect (API)
*
* This function returns TRUE if *ppt falls inside of *prc.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY PtInRect(
    CONST RECT *prc,
    POINT  pt)
{
    VALIDATERECT(prc, FALSE);

    return ((pt.x >= prc->left) && (pt.x < prc->right) &&
            (pt.y >= prc->top)  && (pt.y < prc->bottom));
}

/************************************************************************\
* OffsetRect (API)
*
* This function offsets the coordinates of *prc by adding cx to
* both the left and right coordinates, and cy to both the top and
* bottom coordinates.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY OffsetRect(
    LPRECT prc,
    int cx,
    int cy)
{
    VALIDATERECT(prc, FALSE);

    prc->left   += cx;
    prc->right  += cx;
    prc->bottom += cy;
    prc->top    += cy;
    return TRUE;
}

/************************************************************************\
* InflateRect (API)
*
* This function expands the given rect by cx horizantally and cy
* vertically on all sides.  If cx or cy are negative, the rect
* is inset.  cx is subtracted from the left and added to the right,
* and cy is subtracted from the top and added to the bottom.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY InflateRect(
    LPRECT prc,
    int cx,
    int cy)
{
    VALIDATERECT(prc, FALSE);

    prc->left   -= cx;
    prc->right  += cx;
    prc->top    -= cy;
    prc->bottom += cy;
    return TRUE;
}

/************************************************************************\
* IntersectRect (API)
*
* Calculates the intersection between *prcSrc1 and *prcSrc2,
* returning the resulting rect in *prcDst.  Returns TRUE if
* *prcSrc1 intersects *prcSrc2, FALSE otherwise.  If there is no
* intersection, an empty rect is returned in *prcDst
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY IntersectRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)

{
    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    prcDst->left  = max(prcSrc1->left, prcSrc2->left);
    prcDst->right = min(prcSrc1->right, prcSrc2->right);

    /*
     * check for empty rect
     */
    if (prcDst->left < prcDst->right) {

        prcDst->top = max(prcSrc1->top, prcSrc2->top);
        prcDst->bottom = min(prcSrc1->bottom, prcSrc2->bottom);

        /*
         * check for empty rect
         */
        if (prcDst->top < prcDst->bottom) {
            return TRUE;        // not empty
        }
    }

    /*
     * empty rect
     */
    SetRectEmpty(prcDst);

    return FALSE;
}

/********************************************************************\
* UnionRect (API)
*
* This function calculates a rect that bounds *prcSrc1 and
* *prcSrc2, returning the result in *prcDst.  If either
* *prcSrc1 or *prcSrc2 are empty, then the other rect is
* returned.  Returns TRUE if *prcDst is a non-empty rect,
* FALSE otherwise.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\*******************************************************************/

BOOL APIENTRY UnionRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)
{
    BOOL frc1Empty, frc2Empty;

    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    frc1Empty = ((prcSrc1->left >= prcSrc1->right) ||
            (prcSrc1->top >= prcSrc1->bottom));

    frc2Empty = ((prcSrc2->left >= prcSrc2->right) ||
            (prcSrc2->top >= prcSrc2->bottom));

    if (frc1Empty && frc2Empty) {
        SetRectEmpty(prcDst);
        return FALSE;
    }

    if (frc1Empty) {
        *prcDst = *prcSrc2;
        return TRUE;
    }

    if (frc2Empty) {
        *prcDst = *prcSrc1;
        return TRUE;
    }

    /*
     * form the union of the two non-empty rects
     */
    prcDst->left   = min(prcSrc1->left,   prcSrc2->left);
    prcDst->top    = min(prcSrc1->top,    prcSrc2->top);
    prcDst->right  = max(prcSrc1->right,  prcSrc2->right);
    prcDst->bottom = max(prcSrc1->bottom, prcSrc2->bottom);

    return TRUE;
}

/********************************************************************\
* EqualRect (API)
*
* This function returns TRUE if *prc1 and *prc2 are identical,
* FALSE otherwise.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\*****************************************************************/

#undef EqualRect     // don't let macro interfere with API
BOOL APIENTRY EqualRect(
    CONST RECT *prc1,
    CONST RECT *prc2)
{
    VALIDATERECT(prc1, FALSE);
    VALIDATERECT(prc2, FALSE);

    /*
     * Test equality only. This is what win31 does. win31 does not check to
     * see if the rectangles are "empty" first.
     */
    return RtlEqualMemory(prc1, prc2, sizeof(RECT));
}

/**********************************************************************\
* SubtractRect (API)
*
* This function subtracts *prc2 from *prc1, returning the result in *prcDst
* Returns FALSE if *lprDst is empty, TRUE otherwise.
*
* Warning:
*   Subtracting one rect from another may not always result in a
*   rectangular area; in this case SubtractRect will return *prc1 in
*   *prcDst.  For this reason, SubractRect provides only an
*   approximation of subtraction.  However, the area described by
*   *prcDst will always be greater than or equal to the "true" result
*   of the subtraction.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowsese.
\**********************************************************************/

BOOL APIENTRY SubtractRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)
{
    int cSidesOut;
    BOOL fIntersect;
    RECT rcInt;

    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    fIntersect = IntersectRect(&rcInt, prcSrc1, prcSrc2);

    /*
     * this is done after the intersection in case prcDst is the same
     * pointer as prcSrc2
     */
    *prcDst = *prcSrc1;

    if (fIntersect) {
        /*
         * exactly any 3 sides of prc2 must be outside prc1 to subtract
         */
        cSidesOut = 0;
        if (rcInt.left   <= prcSrc1->left)
            cSidesOut++;
        if (rcInt.top    <= prcSrc1->top)
            cSidesOut++;
        if (rcInt.right  >= prcSrc1->right)
            cSidesOut++;
        if (rcInt.bottom >= prcSrc1->bottom)
            cSidesOut++;

        if (cSidesOut == 4) {
            /*
             * result is the empty rect
             */
             SetRectEmpty(prcDst);
             return FALSE;
        }

        if (cSidesOut == 3) {
            /*
             * subtract the intersecting rect
             */
            if (rcInt.left > prcSrc1->left)
                prcDst->right = rcInt.left;

            else if (rcInt.right < prcSrc1->right)
                prcDst->left = rcInt.right;

            else if (rcInt.top > prcSrc1->top)
                prcDst->bottom = rcInt.top;

            else if (rcInt.bottom < prcSrc1->bottom)
                prcDst->top = rcInt.bottom;
        }
    }

    if ((prcDst->left >= prcDst->right) || (prcDst->top >= prcDst->bottom))
        return FALSE;

    return TRUE;
}

/************************************************************************\
* CopyRect (API)
*
* This function copies the rect from prcSrc to prcDst.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

#undef CopyRect     // don't let macro interfere with API
BOOL APIENTRY CopyRect(
    LPRECT prcDst,
    CONST RECT *prcSrc)
{
    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc, FALSE);

    *prcDst = *prcSrc;
    return TRUE;
}


/************************************************************************\
* SetRectEmpty (API)
*
* This fuction sets *prc to an empty rect by setting each field to 0.
* Equivalent to SetRect(prc, 0, 0, 0, 0).
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

#undef SetRectEmpty     // don't let macro interfere with API
BOOL APIENTRY SetRectEmpty(
    LPRECT prc)
{
    VALIDATERECT(prc, FALSE);

    RtlZeroMemory(prc, sizeof(RECT));
    return TRUE;
}



/***************************************************************************\
* RECTFromSIZERECT
*
* This function converts a SIZERECT to a RECT.
*
* History:
* 24-Sep-1996 adams     Created.
\***************************************************************************/

void
RECTFromSIZERECT(PRECT prc, PCSIZERECT psrc)
{
    prc->left = psrc->x;
    prc->top = psrc->y;
    prc->right = psrc->x + psrc->cx;
    if (!(((prc->right < 0) == (psrc->x < 0))
        || ((prc->right < 0) == (psrc->cx < 0)))) {
        prc->right = prc->right < 0 ? INT_MAX : INT_MIN;
    }

    prc->bottom = psrc->y + psrc->cy;
    if (!(((prc->bottom < 0) == (psrc->y < 0))
        || ((prc->bottom < 0) == (psrc->cy < 0)))) {
        prc->bottom = prc->bottom < 0 ? INT_MAX : INT_MIN;
    }
}


/***************************************************************************\
* SIZERECTFromRECT
*
* Converts a RECT to a SIZERECT.
*
* History:
* 09-May-1997 adams     Created.
\***************************************************************************/

void
SIZERECTFromRECT(PSIZERECT psrc, LPCRECT prc)
{
    psrc->x = prc->left;
    psrc->y = prc->top;
    psrc->cx = prc->right - prc->left;
    psrc->cy = prc->bottom - prc->top;
}


/***************************************************************************\
* MirrorClientRect
*
* Mirror a rectangle using the client coordinates.
*
*
* History:
\***************************************************************************/
void MirrorClientRect(PWND pwnd, LPRECT lprc)
{
    int left, cx;

    cx          = pwnd->rcClient.right - pwnd->rcClient.left;
    left        = lprc->left;
    lprc->left  = cx - lprc->right;
    lprc->right = cx - left;
}


/***************************************************************************\
* MirrorWindowRect
*
* Mirror a rectangle using the window coordinates.
*
*
* History:
* 06-Jun-2000   JStall      Created
\***************************************************************************/
void MirrorWindowRect(PWND pwnd, LPRECT lprc)
{
    int left, cx;

    cx          = pwnd->rcWindow.right - pwnd->rcWindow.left;
    left        = lprc->left;
    lprc->left  = cx - lprc->right;
    lprc->right = cx - left;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\text.c ===
/****************************** Module Header ******************************\
* Module Name: text.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the MessageBox API and related functions.
*
* History:
* 10-01-90 EricK        Created.
* 11-20-90 DarrinM      Merged in User text APIs.
* 02-07-91 DarrinM      Removed TextOut, ExtTextOut, and GetTextExtentPoint stubs.
\***************************************************************************/


/***************************************************************************\
* PSMGetTextExtent
*
* NOTE: This routine should only be called with the system font since having
* to realize a new font would cause memory to move...
*
* LATER: Can't this be eliminated altogether?  Nothing should be moving
*        anymore.
*
* History:
* 11-13-90  JimA        Ported.
\***************************************************************************/

#ifdef _USERK_

BOOL xxxPSMGetTextExtent(
    HDC hdc,
    LPWSTR lpstr,
    int cch,
    PSIZE psize)
{
    int result;
    WCHAR szTemp[255], *pchOut;
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    TL tl;

    if (cch > sizeof(szTemp)/sizeof(WCHAR)) {
        pchOut = (WCHAR*)UserAllocPool((cch+1) * sizeof(WCHAR), TAG_RTL);
        if (pchOut == NULL) {
            psize->cx = psize->cy = 0;
            return FALSE;
        }
        ThreadLockPool(ptiCurrent, pchOut, &tl);
    } else {
        pchOut = szTemp;
    }

    result = HIWORD(GetPrefixCount(lpstr, cch, pchOut, cch));

    if (result) {
        lpstr = pchOut;
        cch -= result;
    }
    if (CALL_LPK(ptiCurrent)) {
        xxxClientGetTextExtentPointW(hdc, lpstr, cch, psize);
    } else {
        UserGetTextExtentPointW(hdc, lpstr, cch, psize);
    }
    if (pchOut != szTemp)
        ThreadUnlockAndFreePool(ptiCurrent, &tl);

    /*
     * IanJa everyone seems to ignore the ret val
     */
    return TRUE;
}

#else

BOOL PSMGetTextExtent(
    HDC hdc,
    LPCWSTR lpstr,
    int cch,
    PSIZE psize)
{
    int result;
    WCHAR szTemp[255], *pchOut;

    if (cch > sizeof(szTemp)/sizeof(WCHAR)) {
        pchOut = (WCHAR*)UserLocalAlloc(0, (cch+1) * sizeof(WCHAR));
        if (pchOut == NULL) {
            psize->cx = psize->cy = 0;
            return FALSE;
        }
    } else {
        pchOut = szTemp;
    }

    result = HIWORD(GetPrefixCount(lpstr, cch, pchOut, cch));

    if (result) {
        lpstr = pchOut;
        cch -= result;
    }

    UserGetTextExtentPointW(hdc, lpstr, cch, psize);

    if (pchOut != szTemp)
        UserLocalFree(pchOut);

    /*
     * IanJa everyone seems to ignore the ret val
     */
    return TRUE;
}

#endif // _USERK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(WINCORE_PATH)\core.inc

MAJORCOMP=user
MINORCOMP=rtl

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..\..;                                  \
        $(NTUSER_PATH)\inc;                      \
        $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O);  \
        $(NTUSER_PATH)\kernel\$(ALT_PROJECT);    \
        $(WINCORE_PATH)\w32inc;                  \
        $(WINCORE_PATH)\w32inc\$(O);             \
        $(BASE_INC_PATH);                        \
        $(TERMSRV_INC_PATH);                     \
        $(WINCORE_PATH)\ntgdi\inc


C_DEFINES=$(C_DEFINES) /DUNICODE /D_UNICODE

SOURCES=..\alignrec.c \
        ..\chartran.c \
        ..\draw.c     \
        ..\drawtext.c \
        ..\getset.c   \
        ..\help.c     \
        ..\input.c    \
        ..\menu.c     \
        ..\mmrtl.c    \
        ..\random.c   \
        ..\rect.c     \
        ..\text.c     \
        ..\winevent.c \
        ..\winmgr.c   \
        ..\winprop.c  \
        ..\wow.c

PRECOMPILED_INCLUDE=..\..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\..\sources.inc ..\sources.inc $(WINCORE_PATH)\core.inc

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\winmgr.c ===
/****************************** Module Header ******************************\
* Module Name: winmgr.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains routines common to client and kernel.
*
* History:
* 02-20-92 DarrinM      Pulled functions from user\server.
* 11-11-94 JimA         Separated from client.
\***************************************************************************/

/***************************************************************************\
* FindNCHit
*
* History:
* 11-09-90 DavidPe      Ported.
\***************************************************************************/
int FindNCHit(
    PWND pwnd,
    LONG lPt)
{
    POINT pt;
    RECT rcWindow;
    RECT rcClient;
    RECT rcClientAdj;
    int cBorders;
    int dxButton;

    pt.x = GET_X_LPARAM(lPt);
    pt.y = GET_Y_LPARAM(lPt);

    if (!PtInRect(KPRECT_TO_PRECT(&pwnd->rcWindow), pt))
        return HTNOWHERE;

    if (TestWF(pwnd, WFMINIMIZED)) {
        CopyInflateRect(&rcWindow, KPRECT_TO_PRECT(&pwnd->rcWindow),
            -(SYSMETRTL(CXFIXEDFRAME) + SYSMETRTL(CXBORDER)), -(SYSMETRTL(CYFIXEDFRAME) + SYSMETRTL(CYBORDER)));

        if (!PtInRect(&rcWindow, pt))
            return HTCAPTION;

        goto CaptionHit;
    }

    // Get client rectangle
    rcClient = pwnd->rcClient;
    if (PtInRect(&rcClient, pt))
        return HTCLIENT;

    // Are we in "pseudo" client, i.e. the client & scrollbars & border
    if (TestWF(pwnd, WEFCLIENTEDGE))
        CopyInflateRect(&rcClientAdj, &rcClient, SYSMETRTL(CXEDGE), SYSMETRTL(CYEDGE));
    else
        rcClientAdj = rcClient;

    if (TestWF(pwnd, WFVPRESENT)) {
       if ((!!TestWF(pwnd, WEFLEFTSCROLL)) ^ (!!TestWF(pwnd, WEFLAYOUTRTL)))
           rcClientAdj.left -= SYSMETRTL(CXVSCROLL);
       else
           rcClientAdj.right += SYSMETRTL(CXVSCROLL);
    }
    if (TestWF(pwnd, WFHPRESENT))
        rcClientAdj.bottom += SYSMETRTL(CYHSCROLL);

    if (!PtInRect(&rcClientAdj, pt))
    {
        // Subtract out window borders
        cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
        CopyInflateRect(&rcWindow, KPRECT_TO_PRECT(&pwnd->rcWindow),
            -cBorders*SYSMETRTL(CXBORDER), -cBorders*SYSMETRTL(CYBORDER));

        // Are we on the border?
        if (!PtInRect(&rcWindow, pt))
        {
            // On a sizing border?
            if (!TestWF(pwnd, WFSIZEBOX)) {
                //
                // Old compatibility thing:  For 3.x windows that just had
                // a border, we returned HTNOWHERE, believe it or not,
                // because our hit-testing code wasn't very good.
                //
                if (!TestWF(pwnd, WFWIN40COMPAT) &&
                        !TestWF(pwnd, WFDLGFRAME)    &&
                        !TestWF(pwnd, WEFDLGMODALFRAME)) {
                    return HTNOWHERE;

                } else {
                    return HTBORDER;  // We are on a dlg frame.
                }
            } else {

                int ht;

                //
                // Note this improvement.  The HT codes are numbered so that
                // if you subtract HTSIZEFIRST-1 from them all, they sum up.  I.E.,
                // (HTLEFT - HTSIZEFIRST + 1) + (HTTOP - HTSIZEFIRST + 1) ==
                // (HTTOPLEFT - HTSIZEFIRST + 1).
                //

                if (TestWF(pwnd, WEFTOOLWINDOW))
                    InflateRect(&rcWindow, -SYSMETRTL(CXSMSIZE), -SYSMETRTL(CYSMSIZE));
                else
                    InflateRect(&rcWindow, -SYSMETRTL(CXSIZE), -SYSMETRTL(CYSIZE));

                if (pt.y < rcWindow.top)
                    ht = (HTTOP - HTSIZEFIRST + 1);
                else if (pt.y >= rcWindow.bottom)
                    ht = (HTBOTTOM - HTSIZEFIRST + 1);
                else
                    ht = 0;

                if (pt.x < rcWindow.left)
                    ht += (HTLEFT - HTSIZEFIRST + 1);
                else if (pt.x >= rcWindow.right)
                    ht += (HTRIGHT - HTSIZEFIRST + 1);

                return (ht + HTSIZEFIRST - 1);
            }
        }

        // Are we above the client area?
        if (pt.y < rcClientAdj.top)
        {
            // Are we in the caption?
            if (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION))
            {
CaptionHit:

                if (TestWF(pwnd, WEFLAYOUTRTL)) {
                    pt.x = pwnd->rcWindow.right - (pt.x - pwnd->rcWindow.left);
                }

                if (pt.y >= rcWindow.top)
                {
                    if (TestWF(pwnd, WEFTOOLWINDOW))
                    {
                        rcWindow.top += SYSMETRTL(CYSMCAPTION);
                        dxButton = SYSMETRTL(CXSMSIZE);
                    }
                    else
                    {
                        rcWindow.top += SYSMETRTL(CYCAPTION);
                        dxButton = SYSMETRTL(CXSIZE);
                    }

                    if ((pt.y >= rcWindow.top) && TestWF(pwnd, WFMPRESENT))
                        return HTMENU;

                    if ((pt.x >= rcWindow.left)  &&
                        (pt.x <  rcWindow.right) &&
                        (pt.y <  rcWindow.top))
                    {
                        // Are we in the window menu?
                        if (TestWF(pwnd, WFSYSMENU))
                        {
                            rcWindow.left += dxButton;
                            if (pt.x < rcWindow.left)
                            {
                                if (!_HasCaptionIcon(pwnd))
                                // iconless windows have no sysmenu hit rect
                                    return HTCAPTION;

                                return HTSYSMENU;
                            }
                        } else if (TestWF(pwnd, WFWIN40COMPAT)) {
#ifdef LAME_BUTTON
                            /*
                             * The old code assumed that a 4.0 compatible app
                             * would not have "anything" else in the caption if
                             * it doesn't have a system menu. With the lame
                             * button, this is no longer true. The code will
                             * work fine if the else-if block below is removed.
                             * However, if we do that then we do a whole bunch
                             * of unnecessary checks below (looking for the
                             * minimize button, which we know isn't there, for
                             * example). Hence, this quick-and-dirty goto. This
                             * allows lame button hit tracking to work on
                             * windows with no system menu, as well as not
                             * change hit test behavior in the shipped bits
                             * (which we most definitely do NOT want to break!)
                             */
                            goto LameButtonHitTest;
#else
                            return HTCAPTION;
#endif // LAME_BUTTON
                        }

                        // Are we in the close button?
                        rcWindow.right -= dxButton;
                        if (pt.x >= rcWindow.right)
                            return HTCLOSE;

                        if ((pt.x < rcWindow.right) && !TestWF(pwnd, WEFTOOLWINDOW))
                        {
                            // Are we in the maximize/restore button?
                            if (TestWF(pwnd, (WFMAXBOX | WFMINBOX)))
                            {
                                // Note that sizing buttons are same width for both
                                // big captions and small captions.
                                rcWindow.right -= dxButton;
                                if (pt.x >= rcWindow.right)
                                    return HTZOOM;

                                // Are we in the minimize button?
                                rcWindow.right -= dxButton;
                                if (pt.x >= rcWindow.right)
                                    return HTREDUCE;
                            }
                            else if (TestWF(pwnd, WEFCONTEXTHELP))
                            {
                                rcWindow.right -= dxButton;
                                if (pt.x >= rcWindow.right)
                                    return HTHELP;
                            }
#ifdef LAME_BUTTON
                            LameButtonHitTest:
                            if (TestWF(pwnd, WEFLAMEBUTTON)) {
                                rcWindow.right -= (gpsi->ncxLame + 2 * SYSMET(CXEDGE));

                                if (TestWF(pwnd, WEFRIGHT)) {
                                    if (pt.x >= rcWindow.left &&
                                        pt.x < rcWindow.left + gpsi->ncxLame) {
                                        return HTLAMEBUTTON;
                                    }
                                } else {
                                    if (pt.x >= rcWindow.right &&
                                        pt.x < rcWindow.right + gpsi->ncxLame) {
                                        return HTLAMEBUTTON;
                                    }
                                }
                            }
#endif // LAME_BUTTON
                        }
                    }
                }

                // We're in the caption proper
                return HTCAPTION;
            }

            //
            // Are we in the menu?
            //
            if (TestWF(pwnd, WFMPRESENT)) {
                return HTMENU;
            }
        }
    } else {
        //
        // NOTE:
        // We can only be here if we are on the client edge, horz scroll,
        // sizebox, or vert scroll.  Hence, if we are not on the first 3,
        // we must be on the last one.
        //

        //
        // Are we on the client edge?
        //
        if (TestWF(pwnd, WEFCLIENTEDGE)) {
            InflateRect(&rcClientAdj, -SYSMETRTL(CXEDGE), -SYSMETRTL(CYEDGE));
            if (!PtInRect(&rcClientAdj, pt)) {
                return HTBORDER;
            }
        }

        //
        // Are we on the scrollbars?
        //
        if (TestWF(pwnd, WFHPRESENT) && (pt.y >= rcClient.bottom)) {
            int iHitTest = HTHSCROLL;
            UserAssert(pt.y < rcClientAdj.bottom);

            if (TestWF(pwnd, WFVPRESENT)) {
                PWND pwndSizeBox = SizeBoxHwnd(pwnd);

                if (pt.x >= rcClient.right) {
                    return pwndSizeBox ? HTBOTTOMRIGHT : HTGROWBOX;
                } else if (TestWF(pwnd, WEFLAYOUTRTL) && (pt.x < rcClient.left)) {
                    //
                    // Mirror the grip box location so that it becomes
                    // on the bottom-left side if this is a RTL mirrrored
                    // windows.
                    //
                    return pwndSizeBox ? HTBOTTOMLEFT : HTGROWBOX;
                }
            }

            return iHitTest;
        } else {
            UserAssert(TestWF(pwnd, WFVPRESENT));
            if ((!!TestWF(pwnd, WEFLEFTSCROLL)) ^ (!!TestWF(pwnd, WEFLAYOUTRTL))) {
                UserAssert(pt.x < rcClient.left);
                UserAssert(pt.x >= rcClientAdj.left);
            } else {
                UserAssert(pt.x >= rcClient.right);
                UserAssert(pt.x < rcClientAdj.right);
            }

            return HTVSCROLL;
        }
    }

    //
    // We give up.
    //
    // Win31 returned HTNOWHERE in this case; For compatibility, we will
    // keep it that way.
    //
    return HTNOWHERE;

}

BOOL _FChildVisible(
    PWND pwnd)
{
    while (TestwndChild(pwnd)) {
        pwnd = REBASEPWND(pwnd, spwndParent);
        if (pwnd == NULL) {
            break;
        } else if (!TestWF(pwnd, WFVISIBLE)) {
            return FALSE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* _MapWindowPoints
*
*
* History:
* 03-03-92 JimA             Ported from Win 3.1 sources.
\***************************************************************************/
int _MapWindowPoints(
    PWND pwndFrom,
    PWND pwndTo,
    LPPOINT lppt,
    DWORD cpt)
{
    int     dx = 0, dy = 0;
    int     SaveLeft, Sign = 1;
    RECT    *pR      = (RECT *)lppt;
    BOOL    bMirrored = FALSE;

    /*
     * If a window is NULL, use the desktop window.
     * If the window is the desktop, don't offset by
     * the client rect, since it won't work if the screen
     * origin is not (0,0) - use zero instead.
     */

    /*
     * Compute deltas
     */
    if (pwndFrom && GETFNID(pwndFrom) != FNID_DESKTOP) {
        if (TestWF(pwndFrom, WEFLAYOUTRTL)) {
            Sign      = -Sign;
            dx        = -pwndFrom->rcClient.right;
            bMirrored = (cpt == 2);
        } else {
            dx = pwndFrom->rcClient.left;
        }
        dy = pwndFrom->rcClient.top;
    }

    if (pwndTo && GETFNID(pwndTo) != FNID_DESKTOP) {
        if (TestWF(pwndTo, WEFLAYOUTRTL)) {
            Sign      = -Sign;
            dx        = dx + Sign * pwndTo->rcClient.right;
            bMirrored = (cpt == 2);
        } else {
            dx = dx - Sign * pwndTo->rcClient.left;
        }
        dy = dy - pwndTo->rcClient.top;
    }

    /*
     * Map the points
     */
    while (cpt--) {
        lppt->x += dx;
        lppt->x *= Sign;
        lppt->y += dy;
        ++lppt;
    }

    if (bMirrored) {     //Special case for Rect
        SaveLeft  = min (pR->left, pR->right);
        pR->right = max (pR->left, pR->right);
        pR->left  = SaveLeft;
    }

    return MAKELONG(dx, dy);
}


/***************************************************************************\
*
* GetRealClientRect()
*
* Gets real client rectangle, inc. scrolls and excl. one row or column
* of minimized windows.
*
* If hwndParent is the desktop, then
*     * If pMonitor is NULL, use the primary monitor
*     * Otherwise use the appropriate monitor's rectangles
*
\***************************************************************************/
VOID GetRealClientRect(
    PWND        pwnd,
    LPRECT      prc,
    UINT        uFlags,
    PMONITOR    pMonitor)
{
    if (GETFNID(pwnd) == FNID_DESKTOP) {
        if (!pMonitor) {
            pMonitor = GetPrimaryMonitor();
        }
        *prc = (uFlags & GRC_FULLSCREEN) ? pMonitor->rcMonitor : pMonitor->rcWork;
    } else {
        GetRect(pwnd, prc, GRECT_CLIENT | GRECT_CLIENTCOORDS);
        if (uFlags & GRC_SCROLLS) {
            if (TestWF(pwnd, WFHPRESENT)) {
                prc->bottom += SYSMETRTL(CYHSCROLL);
            }

            if (TestWF(pwnd, WFVPRESENT)) {
                prc->right += SYSMETRTL(CXVSCROLL);
            }
        }
    }

    if (uFlags & GRC_MINWNDS) {
        switch (SYSMETRTL(ARRANGE) & ~ARW_HIDE) {
            case ARW_TOPLEFT | ARW_RIGHT:
            case ARW_TOPRIGHT | ARW_LEFT:
                //
                // Leave space on top for one row of min windows
                //
                prc->top += SYSMETRTL(CYMINSPACING);
                break;

            case ARW_TOPLEFT | ARW_DOWN:
            case ARW_BOTTOMLEFT | ARW_UP:
                //
                // Leave space on left for one column of min windows
                //
                prc->left += SYSMETRTL(CXMINSPACING);
                break;

            case ARW_TOPRIGHT | ARW_DOWN:
            case ARW_BOTTOMRIGHT | ARW_UP:
                //
                // Leave space on right for one column of min windows
                //
                prc->right -= SYSMETRTL(CXMINSPACING);
                break;

            case ARW_BOTTOMLEFT | ARW_RIGHT:
            case ARW_BOTTOMRIGHT | ARW_LEFT:
                //
                // Leave space on bottom for one row of min windows
                //
                prc->bottom -= SYSMETRTL(CYMINSPACING);
                break;
        }
    }
}


/***************************************************************************\
* _GetLastActivePopup (API)
*
*
*
* History:
* 11-27-90 darrinm      Ported from Win 3.0 sources.
* 02-19-91 JimA         Added enum access check
\***************************************************************************/
PWND _GetLastActivePopup(
    PWND pwnd)
{
    if (pwnd->spwndLastActive == NULL)
        return pwnd;

    return REBASEPWND(pwnd, spwndLastActive);
}


/***************************************************************************\
* IsDescendant
*
* Internal version if IsChild that is a bit faster and ignores the WFCHILD
* business.
*
* Returns TRUE if pwndChild == pwndParent (IsChild doesn't).
*
* History:
* 07-22-91 darrinm      Translated from Win 3.1 ASM code.
* 03-03-94 Johnl        Moved from server
\***************************************************************************/

BOOL _IsDescendant(
    PWND pwndParent,
    PWND pwndChild)
{
    while (1) {
        if (pwndParent == pwndChild)
            return TRUE;
        if (GETFNID(pwndChild) == FNID_DESKTOP)
            break;
        pwndChild = REBASEPWND(pwndChild, spwndParent);
    }

    return FALSE;
}

/***************************************************************************\
* IsVisible
*
* Return whether or not a given window can be drawn in or not.
*
* History:
* 07-22-91 darrinm      Translated from Win 3.1 ASM code.
\***************************************************************************/

BOOL IsVisible(
    PWND pwnd)
{
    PWND pwndT;

    for (pwndT = pwnd; pwndT; pwndT = REBASEPWND(pwndT, spwndParent)) {

        /*
         * Invisible windows are always invisible
         */
        if (!TestWF(pwndT, WFVISIBLE))
            return FALSE;

        if (TestWF(pwndT, WFMINIMIZED)) {

            /*
             * Children of minimized windows are always invisible.
             */
            if (pwndT != pwnd)
                return FALSE;
        }

        /*
         * If we're at the desktop, then we don't want to go any further.
         */
        if (GETFNID(pwndT) == FNID_DESKTOP)
            break;
    }

    return TRUE;
}


/***************************************************************************\
*
*  Function:       GetWindowBorders
*
*  Synopsis:       Calculates # of borders around window
*
*  Algorithm:      Calculate # of window borders and # of client borders
*
*   This routine is ported from Chicago wmclient.c -- FritzS
*
\***************************************************************************/

int GetWindowBorders(LONG lStyle, DWORD dwExStyle, BOOL fWindow, BOOL fClient)
{
    int cBorders = 0;

    if (fWindow) {
        //
        // Is there a 3D border around the window?
        //
        if (dwExStyle & WS_EX_WINDOWEDGE)
            cBorders += 2;
        else if (dwExStyle & WS_EX_STATICEDGE)
            ++cBorders;

        //
        // Is there a single flat border around the window?  This is true for
        // WS_BORDER, WS_DLGFRAME, and WS_EX_DLGMODALFRAME windows.
        //
        if ( (lStyle & WS_CAPTION) || (dwExStyle & WS_EX_DLGMODALFRAME) )
                ++cBorders;

        //
        // Is there a sizing flat border around the window?
        //
        if (lStyle & WS_SIZEBOX)
                cBorders += gpsi->gclBorder;
    }

    if (fClient) {
            //
            // Is there a 3D border around the client?
            //
            if (dwExStyle & WS_EX_CLIENTEDGE)
            cBorders += 2;
    }

    return cBorders;
}



/***************************************************************************\
*  SizeBoxHwnd()
*
*  Returns the HWND that will be sized if the user drags in the given window's
*  sizebox -- If NULL, then the sizebox is not needed
*
*  Criteria for choosing what window will be sized:
*  find first sizeable parent; if that parent is not maximized and the child's
*  bottom, right corner is within a scroll bar height and width of the parent's
*  bottom, right corner, that parent will be sized.
*
*   From Chicago
\***************************************************************************/

PWND SizeBoxHwnd(
    PWND pwnd)
{
    BOOL bMirroredSizeBox = (BOOL) TestWF(pwnd, WEFLAYOUTRTL);

    int xbrChild;
    int ybrChild = pwnd->rcWindow.bottom;

    if (bMirroredSizeBox) {
        xbrChild = pwnd->rcWindow.left;
    } else {
        xbrChild = pwnd->rcWindow.right;
    }

    while (GETFNID(pwnd) != FNID_DESKTOP) {
        if (TestWF(pwnd, WFSIZEBOX)) {
            // First sizeable parent found
            int xbrParent;
            int ybrParent;

            if (TestWF(pwnd, WFMAXIMIZED))
                return NULL;

            if (bMirroredSizeBox) {
                xbrParent = pwnd->rcClient.left;
            } else {
                xbrParent = pwnd->rcClient.right;
            }
            ybrParent = pwnd->rcClient.bottom;

            /*  If the sizebox dude is within an EDGE of the client's bottom
             *  right corner (left corner for mirrored windows), let this succeed.
             *  That way people who draw their own sunken clients will be happy.
             */
            if (bMirroredSizeBox) {
                if ((xbrChild - SYSMETRTL(CXEDGE) > xbrParent) || (ybrChild + SYSMETRTL(CYEDGE) < ybrParent)) {
                    //
                    // Child's bottom, left corner of SIZEBOX isn't close enough
                    // to bottom left of parent's client.
                    //
                    return NULL;
                }
            } else {
                if ((xbrChild + SYSMETRTL(CXEDGE) < xbrParent) || (ybrChild + SYSMETRTL(CYEDGE) < ybrParent)) {
                    //
                    // Child's bottom, right corner of SIZEBOX isn't close enough
                    // to bottom right of parent's client.
                    //
                    return NULL;
                }
            }

            return pwnd;
        }

        if (!TestWF(pwnd, WFCHILD) || TestWF(pwnd, WFCPRESENT))
            break;

        pwnd = REBASEPWND(pwnd, spwndParent);
    }
    return NULL;
}



// --------------------------------------------------------------------------
//
//  NeedsWindowEdge()
//
//  Modifies style/extended style to enforce WS_EX_WINDOWEDGE when we want
//  it.
//
//
// When do we want WS_EX_WINDOWEDGE on a window?
//      (1) If the window has a caption
//      (2) If the window has the WS_DLGFRAME or WS_EX_DLGFRAME style (note
//          that this takes care of (1))
//      (3) If the window has WS_THICKFRAME
//
// --------------------------------------------------------------------------
BOOL NeedsWindowEdge(
    DWORD dwStyle,
    DWORD dwExStyle,
    BOOL fNewApp)
{
    BOOL fGetsWindowEdge = FALSE;

    if (dwExStyle & WS_EX_DLGMODALFRAME) {
        fGetsWindowEdge = TRUE;
    } else if (dwExStyle & WS_EX_STATICEDGE) {
        fGetsWindowEdge = FALSE;
    } else if (dwStyle & WS_THICKFRAME) {
        fGetsWindowEdge = TRUE;
    } else {
        switch (dwStyle & WS_CAPTION) {
        case WS_DLGFRAME:
            fGetsWindowEdge = TRUE;
            break;

        case WS_CAPTION:
            fGetsWindowEdge = fNewApp;
            break;
        }
    }

    return fGetsWindowEdge;
}


// --------------------------------------------------------------------------
//
//  HasCaptionIcon()
//
//  TRUE if this is a window that should have an icon drawn in its caption
//  FALSE otherwise
//
// --------------------------------------------------------------------------
BOOL _HasCaptionIcon(
    PWND pwnd)
{
    HICON hIcon;
    PCLS pcls;

    if (TestWF(pwnd, WEFTOOLWINDOW)) {
        // it's a tool window -- it doesn't get an icon
        return FALSE;
    }

    if ((TestWF(pwnd, WFBORDERMASK) != (BYTE)LOBYTE(WFDLGFRAME)) &&
            !TestWF(pwnd, WEFDLGMODALFRAME)) {
        // they are not trying to look like a dialog, they get an icon
        return TRUE;
    }

    if (!TestWF(pwnd, WFWIN40COMPAT) &&
        (((PCLS)REBASEALWAYS(pwnd, pcls))->atomClassName == (ATOM)(ULONG_PTR)DIALOGCLASS)) {
        /*
         * It's an older REAL dialog -- it doesn't get an icon.
         */
        return FALSE;
    }

    hIcon = (HICON) _GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), TRUE);

    if (hIcon) {
        // It's a 4.0 dialog with a small icon -- if that small icon is
        // something other than the generic small windows icon, it gets an icon.
        return hIcon != gpsi->hIconSmWindows;
    }
    hIcon = (HICON) _GetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), TRUE);

    if (hIcon && (hIcon != gpsi->hIcoWindows)) {
        // It's a 4.0 dialog with no small icon, but instead a large icon
        // that's not the generic windows icon -- it gets an icon.
        return TRUE;
    }

    pcls = REBASEALWAYS(pwnd, pcls);
    if (pcls->spicnSm) {
        if (pcls->spicnSm != HMObjectFromHandle(gpsi->hIconSmWindows)) {
            // It's a 4.0 dialog with a class icon that's not the generic
            // windows icon -- it gets an icon.
            return TRUE;
        }
    }

    // It's a 4.0 dialog with no small or large icon -- it doesn't get an icon.
    return FALSE;
}


/***************************************************************************\
* GetTopLevelWindow
*
* History:
* 10-19-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/
PWND GetTopLevelWindow(
    PWND pwnd)
{
    if (pwnd != NULL) {
        while (TestwndChild(pwnd)) {
            pwnd = REBASEPWND(pwnd, spwndParent);
        }
    }

    return pwnd;
}



/***************************************************************************\
* GetRect
*
* Returns a rect from pwnd (client or window) and returns it in
* one of these coordinate schemes:
*
*      (a) Own Client
*      (b) Own Window
*      (c) Parent Client
*
* Moreover, it does the right thing for case (d) when pwnd is top level.
* In that case, we never want to offset by origin of the parent, which is the
* desktop, since that will not work when the virtual screen has a
* negative origin.  And it does the right thing for cases (b) and (c)
* if pwnd is the desktop.
*
* NOTE: The Win95 version of this function had a flag GRECT_SCREENCOORDS,
* which would return the rectangle in screen coords. There's no reason to
* call a function to do this, since the smallest and fastest to copy a
* rectangle is simple assignment. Therefore, I removed GRECT_SCREENCOORDS.
*
* History:
* 19-Sep-1996 adams     Created.
\***************************************************************************/
VOID GetRect(
    PWND pwnd,
    LPRECT lprc,
    UINT uCoords)
{
    PWND    pwndParent;
    LPRECT  lprcOffset;

    UserAssert(lprc);
    UserAssert((uCoords & ~(GRECT_COORDMASK | GRECT_RECTMASK)) == 0);
    UserAssert(uCoords & GRECT_COORDMASK);
    UserAssert(uCoords & GRECT_RECTMASK);

    *lprc = (uCoords & GRECT_WINDOW) ? pwnd->rcWindow : pwnd->rcClient;

    /*
     * If this is the desktop window, we have what we want, whether we
     * are asking for GRECT_PARENTCOORDS, WINDOWCOORD or CLIENTCOORDS
     */
    if (GETFNID(pwnd) == FNID_DESKTOP) {
        return;
    }

    switch (uCoords & GRECT_COORDMASK) {
    case GRECT_PARENTCOORDS:
        pwndParent = REBASEPWND(pwnd, spwndParent);
        if (GETFNID(pwndParent) == FNID_DESKTOP) {
            return;
        }

        lprcOffset = KPRECT_TO_PRECT(&pwndParent->rcClient);

        //
        // Let's mirror the edges of the child's window since the parent
        // is mirrored, so should the child window be. [samera]
        //
        if (TestWF(pwndParent,WEFLAYOUTRTL) &&
                (uCoords & GRECT_WINDOW) &&
                (TestWF(pwnd,WFCHILD))) {
            int iLeft;

            //
            // I am using OffsetRect instead of implementing a new
            // OffsetMirrorRect API since this is the only place I am
            // doing it in.
            //
            // Since screen coordinates are not mirrored, the rect offsetting
            // should be done relative to prcOffset->right since it is the
            // leading edge for mirrored windows. [samera]
            //

            UserVerify(OffsetRect(lprc, -lprcOffset->right, -lprcOffset->top));

            iLeft = lprc->left;
            lprc->left  = (lprc->right * -1);
            lprc->right = (iLeft * -1);

            return;
        }
        break;

    case GRECT_WINDOWCOORDS:
        lprcOffset = KPRECT_TO_PRECT(&pwnd->rcWindow);
        break;

    case GRECT_CLIENTCOORDS:
        lprcOffset = KPRECT_TO_PRECT(&pwnd->rcClient);
        break;

    default:
        RIPMSG1(RIP_ERROR,
                "Logic error in GetRect - invalid uCoords 0x%x",
                uCoords);
        return;
    }

    UserVerify(OffsetRect(lprc, -lprcOffset->left, -lprcOffset->top));
}

#ifdef _USERK_
#if DBG
DWORD GetDbgTagFlags(
    int tag)
{
    return (gpsi != NULL ? gpsi->adwDBGTAGFlags[tag] : 0);
}

DWORD GetRipFlags(
    VOID)
{
    return (gpsi != NULL ? gpsi->dwRIPFlags : RIPF_DEFAULT);
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\winevent.c ===
/****************************** Module Header ******************************\
* Module Name: winevent.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains routines common to client and kernel.
*
* History:
* 07-18-2000 DwayneN    Created
\***************************************************************************/

/*
 * Event Space Partitioning
 * This map describes how the event space is partioned up into separate
 * categories.  Each entry describes where a range of events begins, and
 * what category that range belongs to.  The range implicitly extends up
 * to, but not including the beginning of the next range.  The first range
 * must begin with EVENT_MIN.  The last range must begin with EVENT_MAX.
 * This last range is ignored except that it defines where the 
 * next-to-last range ends.
 *
 * Be sure to keep this in sync with the category definitions!
 */
typedef struct _EVCATINFO
{
    DWORD dwBeginRange;
    DWORD dwCategory;
} EVCATINFO, *PEVCATINFO;

static EVCATINFO geci[] = {
    {EVENT_MIN,                                 EVENTCATEGORY_OTHER},
    {EVENT_SYSTEM_MENUSTART,                    EVENTCATEGORY_SYSTEM_MENU},
    {EVENT_SYSTEM_CAPTURESTART,                 EVENTCATEGORY_OTHER},
    {EVENT_CONSOLE_CARET,                       EVENTCATEGORY_CONSOLE},
    {EVENT_CONSOLE_END_APPLICATION + 1,         EVENTCATEGORY_OTHER},
    {EVENT_OBJECT_FOCUS,                        EVENTCATEGORY_FOCUS},
    {EVENT_OBJECT_SELECTION,                    EVENTCATEGORY_OTHER},
    {EVENT_OBJECT_STATECHANGE,                  EVENTCATEGORY_STATECHANGE},
    {EVENT_OBJECT_LOCATIONCHANGE,               EVENTCATEGORY_LOCATIONCHANGE},
    {EVENT_OBJECT_NAMECHANGE,                   EVENTCATEGORY_NAMECHANGE},
    {EVENT_OBJECT_DESCRIPTIONCHANGE,            EVENTCATEGORY_OTHER},
    {EVENT_OBJECT_VALUECHANGE,                  EVENTCATEGORY_VALUECHANGE},
    {EVENT_OBJECT_PARENTCHANGE,                 EVENTCATEGORY_OTHER},
    {EVENT_MAX,                                 EVENTCATEGORY_OTHER}};

/***************************************************************************\
* IsEventInRange
*
* Returns TRUE if the specified event falls within the specified range,
* and FALSE if not.
*
\***************************************************************************/
__inline BOOL IsEventInRange(
    DWORD event,
    DWORD eventMin,
    DWORD eventMax)
{
    return ((event >= eventMin) && (event <= eventMax));
}

/***************************************************************************\
* RangesOverlap
*
* Returns TRUE if the two ranges overlap at all, FALSE if not.
*
* Note that the ranges are both assumed to be inclusinve on both ends.
*
\***************************************************************************/
__inline BOOL RangesOverlap(
    DWORD r1Min,
    DWORD r1Max,
    DWORD r2Min,
    DWORD r2Max)
{
    UserAssert(r1Min <= r1Max);
    UserAssert(r2Min <= r2Max);
    return (r1Min <= r2Max) && (r1Max >= r2Min);
}

/***************************************************************************\
* CategoryMaskFromEvent
*
* Returns the bit-mask for the category that the specified event belongs to.
*
\***************************************************************************/
DWORD CategoryMaskFromEvent(
    DWORD event)
{
    UserAssert(IsEventInRange(event, EVENT_MIN, EVENT_MAX));

    switch (event) {
    case EVENT_SYSTEM_MENUSTART:
    case EVENT_SYSTEM_MENUEND:
    case EVENT_SYSTEM_MENUPOPUPSTART:
    case EVENT_SYSTEM_MENUPOPUPEND:
        return EVENTCATEGORY_SYSTEM_MENU;

    case EVENT_CONSOLE_CARET:
    case EVENT_CONSOLE_UPDATE_REGION:
    case EVENT_CONSOLE_UPDATE_SIMPLE:
    case EVENT_CONSOLE_UPDATE_SCROLL:
    case EVENT_CONSOLE_LAYOUT:
    case EVENT_CONSOLE_START_APPLICATION:
    case EVENT_CONSOLE_END_APPLICATION:
        return EVENTCATEGORY_CONSOLE;

    case EVENT_OBJECT_FOCUS:
        return EVENTCATEGORY_FOCUS;
        
    case EVENT_OBJECT_NAMECHANGE:
        return EVENTCATEGORY_NAMECHANGE;
    
    case EVENT_OBJECT_VALUECHANGE:
        return EVENTCATEGORY_VALUECHANGE;
    
    case EVENT_OBJECT_STATECHANGE:
        return EVENTCATEGORY_STATECHANGE;
    
    case EVENT_OBJECT_LOCATIONCHANGE:
        return EVENTCATEGORY_LOCATIONCHANGE;

    default:
        return EVENTCATEGORY_OTHER;
    }
}

/***************************************************************************\
* CategoryMaskFromEventRange
*
* Returns a bit-mask for the categories that the events in the specified
* event range belong to.
*
\***************************************************************************/
DWORD CategoryMaskFromEventRange(
    DWORD eventMin,
    DWORD eventMax)
{
    DWORD dwCategoryMask = 0;
    DWORD i;
    DWORD iMax = ARRAY_SIZE(geci) - 1;

    /*
     * This is a DEBUG section that tries to verify some aspects of the
     * geci array.
     */
#if DBG
    UserAssert(iMax >= 1);
    UserAssert(geci[0].dwBeginRange == EVENT_MIN);
    UserAssert(geci[iMax].dwBeginRange == EVENT_MAX);
    for (i = 0; i < iMax; i++) {
        UserAssert(geci[i].dwBeginRange >= EVENT_MIN);
        UserAssert(geci[i].dwBeginRange <= EVENT_MAX);
        UserAssert(geci[i].dwBeginRange < geci[i+1].dwBeginRange);
        dwCategoryMask |= geci[i].dwCategory;
    }
    UserAssert(dwCategoryMask == EVENTCATEGORY_ALL);
    dwCategoryMask = 0;
#endif // DBG
    
    /*
     * Spin through the geci array and check to see which ranges overlap
     * the range passed to this function.
     */
    for (i = 0; i < iMax; i++) {
        /*
         * Bail out early once we pass the range we are checking.
         */
        if (geci[i].dwBeginRange > eventMax) {
            break;
        }
        
        /*
         * Check to see if the ith range in the table overlaps the range
         * passed to this function.
         */
        if (RangesOverlap(geci[i].dwBeginRange, geci[i+1].dwBeginRange-1, eventMin, eventMax)) {
            dwCategoryMask |= geci[ i ].dwCategory;
        }
    }

    return dwCategoryMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\winprop.c ===
/***************************************************************************\
* MapPropertyKey
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Maps a property key string into an atom.
*
* History:
* 21-Dec-1994   JimA    Created.
\***************************************************************************/

__inline ATOM MapPropertyKey(
    PCWSTR pszKey)
{
#ifdef _USERK_
    /*
     * Internal properties must use atoms, not strings.
     */
    UserAssert(!IS_PTR(pszKey));
#else
    /*
     * Is pszKey an atom?  If not, find the atom that matches the string.
     * If one doesn't exist, bail out.
     */
    if (IS_PTR(pszKey))
        return GlobalFindAtomW(pszKey);
#endif

    return PTR_TO_ID(pszKey);
}

/***************************************************************************\
* FindProp
*
* Search the window's property list for the specified property.  pszKey
* could be a string or an atom.  If it is a string, convert it to an atom
* before lookup.  FindProp will only find internal or external properties
* depending on the fInternal flag.
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

PPROP _FindProp(
    PWND pwnd,
    PCWSTR pszKey,
    BOOL fInternal)
{
    UINT i;
    PPROPLIST ppropList;
    PPROP pprop;
    ATOM atomKey;

    /*
     * Make sure we have a property list.
     */
    ppropList = REBASE(pwnd, ppropList);
    if (ppropList == NULL)
        return NULL;

    /*
     * Call to the appropriate routine to verify the key name.
     */
    atomKey = MapPropertyKey(pszKey);
    if (atomKey == 0)
        return NULL;

    /*
     * Now we've got the atom, search the list for a property with the
     * same atom/name.  Make sure to only return internal properties if
     * the fInternal flag is set.  Do the same for external properties.
     */
    pprop = ppropList->aprop;
    for (i = ppropList->iFirstFree; i > 0; i--) {
        if (pprop->atomKey == atomKey) {
            if (fInternal) {
                if (pprop->fs & PROPF_INTERNAL)
                    return pprop;
            } else {
                if (!(pprop->fs & PROPF_INTERNAL))
                    return pprop;
            }
        }
        pprop++;
    }

    /*
     * Property not found, too bad.
     */
    return NULL;
}

/***************************************************************************\
* InternalGetProp
*
* Search the window's property list for the specified property and return
* the hData handle from it.  If the property is not found, NULL is returned.
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

HANDLE _GetProp(
    PWND pwnd,
    PCWSTR pszKey,
    BOOL fInternal)
{
    PPROP pprop;

    /*
     * A quick little optimization for that case where the window has no
     * properties at all.
     */
    if (pwnd->ppropList == NULL)
        return NULL;

    /*
     * FindProp does all the work, including converting pszKey to an atom
     * (if necessary) for property lookup.
     */
    pprop = _FindProp(pwnd, pszKey, fInternal);
    if (pprop == NULL)
        return NULL;

    return KHANDLE_TO_HANDLE(pprop->hData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\random.c ===
/****************************** Module Header ******************************\
* Module Name: random.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains a random collection of support routines for the User
* API functions.  Many of these functions will be moved to more appropriate
* files once we get our act together.
*
* History:
* 10-17-90 DarrinM      Created.
* 02-06-91 IanJa        HWND revalidation added (none required)
\***************************************************************************/


/***************************************************************************\
* RtlGetExpWinVer
*
* Returns the expected windows version, in the same format as Win3.1's
* GetExpWinVer(). This takes it out of the module header. As such, this
* api cannot be called from the server context to get version info for
* a client process - instead that information needs to be queried ahead
* of time and passed with any client/server call.
*
* 03-14-92 ScottLu      Created.
\***************************************************************************/

DWORD RtlGetExpWinVer(
    HANDLE hmod)
{
    PIMAGE_NT_HEADERS pnthdr;
    DWORD dwMajor = 3;
    DWORD dwMinor = 0xA;

    /*
     * If it doesn't look like a valid 32bit hmod, use the default
     *  (i.e., assuming all 16bit hmods are 0x30a)
     */
    if ((hmod != NULL) && (LOWORD(HandleToUlong(hmod)) == 0)) {
        try {
            pnthdr = RtlImageNtHeader((PVOID)hmod);
            // If for some reason we can't get the header information,
            // just return the default
            if(pnthdr == NULL) {
                goto NO_HEADER;
            }
            dwMajor = pnthdr->OptionalHeader.MajorSubsystemVersion;
            /*
             * Still need this hack 'cuz the linker still puts
             * version 1.00 in the header of some things.
             */
            if (dwMajor == 1) {
                dwMajor = 0x3;
            } else {
                dwMinor = pnthdr->OptionalHeader.MinorSubsystemVersion;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            dwMajor = 3;        // just to be safe
            dwMinor = 0xA;
        }
    }


    /*
     * Return this is a win3.1 compatible format:
     *
     * 0x030A == win3.1
     * 0x0300 == win3.0
     * 0x0200 == win2.0, etc.
     */

    // dwMajor and dwMinor are initialized where they're declared
    NO_HEADER:
    return (DWORD)MAKELONG(MAKEWORD((BYTE)dwMinor, (BYTE)dwMajor), 0);
}

/***************************************************************************\
* FindCharPosition
*
* Finds position of character ch in lpString.  If not found, the length
* of the string is returned.
*
* History:
*   11-13-90 JimA                Created.
\***************************************************************************/

DWORD FindCharPosition(
    LPWSTR lpString,
    WCHAR ch)
{
    DWORD dwPos = 0L;

    while (*lpString && *lpString != ch) {
        ++lpString;
        ++dwPos;
    }
    return dwPos;
}


/***************************************************************************\
* TextCopy
*
* Returns: number of characters copied not including the NULL
*
* History:
* 10-25-90 MikeHar      Wrote.
* 11-09-90 DarrinM      Rewrote with a radically new algorithm.
* 01-25-91 MikeHar      Fixed the radically new algorithm.
* 02-01-91 DarrinM      Bite me.
* 11-26-91 DarrinM      Ok, this time it's perfect (except NLS, probably).
* 01-13-92 GregoryW     Now it's okay for Unicode.
\***************************************************************************/

UINT TextCopy(
    PLARGE_UNICODE_STRING pstr,
    LPWSTR pszDst,
    UINT cchMax)
{
    if (cchMax != 0) {
        cchMax = min(pstr->Length / sizeof(WCHAR), cchMax - 1);
        RtlCopyMemory(pszDst, KPVOID_TO_PVOID(pstr->Buffer), cchMax * sizeof(WCHAR));
        pszDst[cchMax] = 0;
    }

    return cchMax;
}

/***************************************************************************\
* DWORD wcsncpycch(dest, source, count) - copy no more than n wide chars
*
* Purpose:
*       Copies no more than count characters from the source string to the
*       destination.  If count is less than the length of source,
*       NO NULL CHARACTER is put onto the end of the copied string.
*       If count is greater than the length of sources, dest is NOT padded
*       with more than 1 null character.
*
*
* Entry:
*       LPWSTR dest - pointer to destination
*       LPWSTR source - source string for copy
*       DWORD count - max number of characters to copy
*
* Exit:
*       returns number of characters copied into dest, including the null
*   terminator, if any.
*
* Exceptions:
*
****************************************************************************/

DWORD wcsncpycch (
        LPWSTR dest,
        LPCWSTR source,
        DWORD count
        )
{
        LPWSTR start = dest;

        while (count && (*dest++ = *source++))    /* copy string */
                count--;

        return (DWORD)(dest - start);
}

/***************************************************************************\
* DWORD strncpycch(dest, source, count) - copy no more than n characters
*
* Purpose:
*       Copies no more than count characters from the source string to the
*       destination.  If count is less than the length of source,
*       NO NULL CHARACTER is put onto the end of the copied string.
*       If count is greater than the length of sources, dest is NOT padded
*       with more than 1 null character.
*
*
* Entry:
*       LPSTR dest - pointer to destination
*       LPSTR source - source string for copy
*       DWORD count - max number of characters to copy
*
* Exit:
*       returns number of characters copied into dest, including the null
*   terminator, if any.
*
* Exceptions:
*
*******************************************************************************/

DWORD strncpycch (
        LPSTR dest,
        LPCSTR source,
        DWORD count
        )
{
        LPSTR start = dest;

        while (count && (*dest++ = *source++))    /* copy string */
                count--;

        return (DWORD)(dest - start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\userrtl.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

/****************************** Module Header ******************************\
* Module Name: userrtl.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used by the User
* RTL library.
*
* History:
* 04-27-91 DarrinM      Created from PROTO.H, MACRO.H and STRTABLE.H
\***************************************************************************/

#ifndef _USERRTL_
#define _USERRTL_

/*
 * Typedefs copied from winbase.h to avoid using nturtl.h
 */
typedef struct _SECURITY_ATTRIBUTES *LPSECURITY_ATTRIBUTES;
#define MAKEINTATOM(i)  (LPTSTR)((ULONG_PTR)((WORD)(i)))

#ifdef _USERK_
    #undef _USERK_
    #include "..\kernel\precomp.h"
    #define _USERK_
#else
    #include "..\client\precomp.h"
#endif

#include <w32p.h>

#include "ntuser.h"

/*
 * REBASE macros take kernel desktop addresses and convert them into
 * user addresses.
 *
 * REBASEALWAYS converts a kernel address contained in an object
 * REBASEPWND casts REBASEALWAYS to a PWND
 * REBASE only converts if the address is in kernel space.  Also works for NULL
 * REBASEPTR converts a random kernel address
 */

#ifdef _USERK_

#define REBASEALWAYS(p, elem) ((p)->elem)
#define REBASEPTR(obj, p) (p)
#define REBASE(p, elem) ((p)->elem)
#define REBASEPWND(p, elem) ((p)->elem)
#endif  // _USERK_


// jcjc extern SHAREDINFO gSharedInfo;
// jcjc extern HFONT ghFontSys;

PVOID UserRtlAllocMem(
    ULONG uBytes);
VOID UserRtlFreeMem(
    PVOID pMem);


#ifdef FE_SB // Prototype for FarEast Line break & NLS conversion.

    #ifdef _USERK_
        #define USERGETCODEPAGE(hdc) (GreGetCharSet(hdc) & 0x0000FFFF)
    #else
        #define USERGETCODEPAGE(hdc) (GdiGetCodePage(hdc))
    #endif // _USERK_


    BOOL UserIsFullWidth(
        DWORD dwCodePage,
        WCHAR wChar);
    BOOL UserIsFELineBreak(
        DWORD dwCodePage,
        WCHAR wChar);

#endif // FE_SB


/***************************************************************************\
*
* Function prototypes for client/server-specific routines
* called from rtl routines.
*
\***************************************************************************/

#ifdef _USERK_

BOOL _TextOutW(
    HDC     hdc,
    int     x,
    int     y,
    LPCWSTR lp,
    UINT    cc);

UINT APIENTRY GreSetTextAlign(HDC, UINT);
UINT APIENTRY GreGetTextAlign(HDC);

#define UserCreateFontIndirectW   GreCreateFontIndirectW
#define UserCreateRectRgn         GreCreateRectRgn
#define UserDeleteObject          GreDeleteObject
#define UserExtSelectClipRgn      GreExtSelectClipRgn
#define UserExtTextOutW           GreExtTextOutW
#define UserGetCharDimensionsW    GetCharDimensions
#define UserGetClipRgn(hdc, hrgnClip) \
        GreGetRandomRgn(hdc, hrgnClip, 1)
#define UserGetHFONT              GreGetHFONT
#define UserGetMapMode            GreGetMapMode
#define UserGetTextColor          GreGetTextColor
#define UserGetTextExtentPointW(hdc, pstr, i, psize) \
        GreGetTextExtentW(hdc, (LPWSTR)pstr, i, psize, GGTE_WIN3_EXTENT)
#define UserGetTextMetricsW       _GetTextMetricsW
#define UserGetViewportExtEx      GreGetViewportExt
#define UserGetWindowExtEx        GreGetWindowExt
#define UserIntersectClipRect     GreIntersectClipRect
#define UserPatBlt                GrePatBlt
#define UserPolyPatBlt            GrePolyPatBlt
#define UserSelectBrush           GreSelectBrush
#define UserSelectFont            GreSelectFont
#define UserSetBkColor            GreSetBkColor
#define UserSetBkMode             GreSetBkMode
#define UserSetTextColor          GreSetTextColor
#define UserTextOutW              _TextOutW
#define UserGetTextCharsetInfo    GreGetTextCharsetInfo
#define UserGetTextAlign          GreGetTextAlign
#define UserSetTextAlign          GreSetTextAlign
#define UserLpkDrawTextEx         xxxClientLpkDrawTextEx
#define UserGetLayout             GreGetLayout
#define UserSetGraphicsMode       GreSetGraphicsMode

#else

#define UserCreateFontIndirectW   CreateFontIndirectW
#define UserCreateRectRgn         CreateRectRgn
#define UserDeleteObject          DeleteObject
#define UserExtSelectClipRgn      ExtSelectClipRgn
#define UserExtTextOutW           ExtTextOutW
#define UserGetCharDimensionsW    GdiGetCharDimensions
#define UserGetClipRgn            GetClipRgn
#define UserGetHFONT              GetHFONT
#define UserGetMapMode            GetMapMode
#define UserGetTextColor          GetTextColor
#define UserGetTextExtentPointW   GetTextExtentPointW
#define UserGetTextMetricsW       GetTextMetricsW
#define UserGetViewportExtEx      GetViewportExtEx
#define UserGetWindowExtEx        GetWindowExtEx
#define UserIntersectClipRect     IntersectClipRect
#define UserPatBlt                PatBlt
#define UserPolyPatBlt            PolyPatBlt
#define UserSelectBrush           SelectObject
#define UserSelectFont            SelectObject
#define UserSetBkColor            SetBkColor
#define UserSetBkMode             SetBkMode
#define UserSetTextColor          SetTextColor
#define UserTextOutW              TextOutW
#define UserGetTextCharsetInfo    GetTextCharsetInfo
#define UserGetTextAlign          GetTextAlign
#define UserSetTextAlign          SetTextAlign
#define UserLpkDrawTextEx         fpLpkDrawTextEx
#define UserGetLayout             GetLayout
#define UserSetGraphicsMode       SetGraphicsMode

#endif // _USERK_

#endif  // !_USERRTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\chartran.c ===
/****************************** Module Header ******************************\
* Module Name: chartran.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#define MOVE_TO_RTL
#include "precomp.h"
#pragma hdrstop
#include "..\chartran.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\alignrec.c ===
/****************************** Module Header ******************************\
* Module Name: chartran.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#define MOVE_TO_RTL
#include "precomp.h"
#pragma hdrstop
#include "..\alignrec.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\getset.c ===
/****************************** Module Header ******************************\
* Module Name: getset.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\getset.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\input.c ===
/****************************** Module Header ******************************\
* Module Name: input.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\input.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\wow.c ===
/****************************** Module Header ******************************\
* Module Name: wow.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains shared code between USER32 and USER16
* No New CODE should be added to this file, unless its shared
* with USER16.
*
* History:
* 29-DEC-93 NanduriR      shared user32/user16 code.
\***************************************************************************/

#include "wow.h"


#ifdef _USERK_
    #define CHECK_RESTRICTED()                                                      \
        if (((PTHREADINFO)W32GetCurrentThread())->TIF_flags & TIF_RESTRICTED) {     \
            if (!ValidateHandleSecure(h))                                           \
                pobj = NULL;                                                        \
        }                                                                           \

#else
    #define CHECK_RESTRICTED()                                              \
        if (pci && (pci->dwTIFlags & TIF_RESTRICTED) && pobj) {             \
            if (!NtUserValidateHandleSecure(h))                             \
                pobj = NULL;                                                \
        }                                                                   \

#endif



#ifdef _USERK_
    #define GET_CURRENT_CLIENTINFO()                            \
        {                                                       \
            PW32THREAD pW32Thread;                              \
                                                                \
            pW32Thread = W32GetCurrentThread();                 \
                                                                \
            if (pW32Thread) {                                   \
                pci = ((PTHREADINFO)pW32Thread)->pClientInfo;   \
            } else {                                            \
                pci = NULL;                                     \
            }                                                   \
        }

#else
    #define GET_CURRENT_CLIENTINFO()                            \
        pci = GetClientInfo();

#endif // _USERK_


/*
 * We have two types of desktop validation:
 *
 */

#ifdef _USERK_

#define DESKTOPVALIDATE(pci, pobj) \
            UNREFERENCED_PARAMETER(pci);

#define DESKTOPVALIDATECCX(pti, pobj)                                           \
        try {                                                                   \
            if (((PVOID)pobj >= pti->pClientInfo->pDeskInfo->pvDesktopBase) &&  \
               ((PVOID)pobj < pti->pClientInfo->pDeskInfo->pvDesktopLimit)) {   \
                pobj = (PBYTE)pobj - pti->ulClientDelta;                        \
            }                                                                   \
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {                    \
                pobj = NULL;                                                    \
        }                                                                       \

#define SHAREDVALIDATE(pobj)

#else

#define DESKTOPVALIDATE(pci, pobj)                              \
        if (pci->pDeskInfo &&                                   \
            pobj >= pci->pDeskInfo->pvDesktopBase &&            \
            pobj < pci->pDeskInfo->pvDesktopLimit) {            \
            pobj = (KERNEL_PVOID)((KERNEL_ULONG_PTR)pobj - pci->ulClientDelta);         \
        } else {                                                \
            pobj = (KERNEL_PVOID)NtUserCallOneParam((ULONG_PTR)h,                       \
                    SFI__MAPDESKTOPOBJECT);                     \
        }                                                       \

#define SHAREDVALIDATE(pobj)                                    \
        pobj = REBASESHAREDPTRALWAYS(pobj);

#endif // _USERK_


/*
 * Keep the general path through validation straight without jumps - that
 * means tunneling if()'s for this routine - this'll make validation fastest
 * because of instruction caching.
 *
 * In order to have the validation code in one place only, we define
 *  the *ValidateHandleMacro macros which are to be included by the
 *  HMValidateHanlde* routines. We don't make these into functions
 *  because we're optimizing on time, not size.
 */
#define ValidateHandleMacro(pci, pobj, h, bType) \
    StartValidateHandleMacro(h) \
    BeginAliveValidateHandleMacro()  \
    BeginTypeValidateHandleMacro(pobj, bType) \
    DESKTOPVALIDATE(pci, pobj) \
    EndTypeValidateHandleMacro \
    EndAliveValidateHandleMacro()  \
    EndValidateHandleMacro

#ifdef _USERK_
#define ValidateCatHandleMacro(pci, pobj, h, bType) \
    StartValidateHandleMacro(h) \
    BeginTypeValidateHandleMacro(pobj, bType) \
    DESKTOPVALIDATE(pci, pobj) \
    EndTypeValidateHandleMacro \
    EndValidateHandleMacro
#define ValidateCatHandleMacroCcx(pti, pobj, h, bType) \
    StartValidateHandleMacro(h) \
    BeginTypeValidateHandleMacro(pobj, bType) \
    DESKTOPVALIDATECCX(pti, pobj) \
    EndTypeValidateHandleMacro \
    EndValidateHandleMacro
#endif

#define ValidateSharedHandleMacro(pobj, h, bType) \
    StartValidateHandleMacro(h)  \
    BeginAliveValidateHandleMacro()  \
    BeginTypeValidateHandleMacro(pobj, bType) \
    SHAREDVALIDATE(pobj)        \
    EndTypeValidateHandleMacro \
    EndAliveValidateHandleMacro()  \
    EndValidateHandleMacro


/*
 * The handle validation routines should be optimized for time, not size,
 * since they get called so often.
 */
#pragma optimize("t", on)

/***************************************************************************\
* HMValidateHandle
*
* This routine validates a handle manager handle.
*
* 01-22-92 ScottLu      Created.
\***************************************************************************/

PVOID FASTCALL HMValidateHandle(
    HANDLE h,
    BYTE bType)
{
    DWORD       dwError;
    KERNEL_PVOID pobj = NULL;
    PCLIENTINFO pci;

    GET_CURRENT_CLIENTINFO();

#if DBG && !defined(_USERK_)
    /*
     * We don't want 32 bit apps passing 16 bit handles
     *  we should consider failing this before we get
     *  stuck supporting it (Some VB apps do this).
     */
    if (pci && (h != NULL)
           && (HMUniqFromHandle(h) == 0)
           && !(pci->dwTIFlags & TIF_16BIT)) {
        RIPMSG3(RIP_WARNING, "HMValidateHandle: 32bit process [%d] using 16 bit handle [%#p] bType:%#lx",
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), h, (DWORD)bType);
    }
#endif

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    /*
     * Validation macro. Falls through if the handle is invalid.
     */
    ValidateHandleMacro(pci, pobj, h, bType);

    /*
     * check for secure process
     */
    CHECK_RESTRICTED();

    if (pobj != NULL) {
        return KPVOID_TO_PVOID(pobj);
    }

    switch (bType) {

    case TYPE_WINDOW:
        dwError = ERROR_INVALID_WINDOW_HANDLE;
        break;

    case TYPE_MENU:
        dwError = ERROR_INVALID_MENU_HANDLE;
        break;

    case TYPE_CURSOR:
        dwError = ERROR_INVALID_CURSOR_HANDLE;
        break;

    case TYPE_ACCELTABLE:
        dwError = ERROR_INVALID_ACCEL_HANDLE;
        break;

    case TYPE_HOOK:
        dwError = ERROR_INVALID_HOOK_HANDLE;
        break;

    case TYPE_SETWINDOWPOS:
        dwError = ERROR_INVALID_DWP_HANDLE;
        break;

    default:
        dwError = ERROR_INVALID_HANDLE;
        break;
    }

    RIPERR2(dwError,
            RIP_WARNING,
            "HMValidateHandle: Invalid:%#p Type:%#lx",
            h, (DWORD)bType);

    /*
     * If we get here, it's an error.
     */
    return NULL;
}

/***************************************************************************\
* HMValidateHandleNoSecure
*
* This routine validates a handle manager handle.
*
* 01-22-92 ScottLu      Created.
\***************************************************************************/
PVOID FASTCALL HMValidateHandleNoSecure(
    HANDLE h,
    BYTE bType)
{
    KERNEL_PVOID pobj = NULL;
    PCLIENTINFO pci;

    GET_CURRENT_CLIENTINFO();

#if !defined(_USERK_)
    /*
     * We don't want 32 bit apps passing 16 bit handles
     *  we should consider failing this before we get
     *  stuck supporting it (Some VB apps do this).
     */
    if (pci && (h != NULL)
           && (HMUniqFromHandle(h) == 0)
           && !(pci->dwTIFlags & TIF_16BIT)) {
        RIPMSG3(RIP_WARNING, "HMValidateHandle: 32bit process [%d] using 16 bit handle [%#p] bType:%#lx",
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), h, (DWORD)bType);
    }
#endif

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    /*
     * Validation macro.
     */
    ValidateHandleMacro(pci, pobj, h, bType);

    return KPVOID_TO_PVOID(pobj);
}

#if defined(_USERK_)
PVOID FASTCALL HMValidateCatHandleNoSecure(
    HANDLE h,
    BYTE bType)
{
    PVOID       pobj = NULL;
    PCLIENTINFO pci;

    GET_CURRENT_CLIENTINFO();

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    /*
     * Validation macro.
     */
    ValidateCatHandleMacro(pci, pobj, h, bType);

    return pobj;
}
PVOID FASTCALL HMValidateCatHandleNoSecureCCX(
    HANDLE h,
    BYTE bType,
    PTHREADINFO pti)
{
    PVOID       pobj = NULL;

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    /*
     * Validation macro.
     */
    ValidateCatHandleMacroCcx(pti, pobj, h, bType);

    return pobj;
}

PVOID FASTCALL HMValidateCatHandleNoRip(
    HANDLE h,
    BYTE bType)
{
    PVOID       pobj = NULL;
    PCLIENTINFO pci;

    /*
     * This is the fastest way way to do validation, because
     *  unlike HMValidateHandle, this function doesn't set the
     *  last error.
     *
     * Validation macro. Falls through if the handle is invalid.
     */

    GET_CURRENT_CLIENTINFO();

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    ValidateCatHandleMacro(pci, pobj, h, bType);

    /*
     * check for secure process
     */
    CHECK_RESTRICTED();

    return pobj;
}
#endif

PVOID FASTCALL HMValidateHandleNoRip(
    HANDLE h,
    BYTE bType)
{
    KERNEL_PVOID pobj = NULL;
    PCLIENTINFO pci;

    /*
     * This is the fastest way way to do validation, because
     *  unlike HMValidateHandle, this function doesn't set the
     *  last error.
     *
     * Validation macro. Falls through if the handle is invalid.
     */

    GET_CURRENT_CLIENTINFO();

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    ValidateHandleMacro(pci, pobj, h, bType);

    /*
     * check for secure process
     */
    CHECK_RESTRICTED();

    return KPVOID_TO_PVOID(pobj);
}

#if DBG && !defined(_USERK_)
/*
 * HMValidateHandleNoDesktop is a debug-client-side only function
 *  used to verify a given handle without calling DESKTOPVALIDATE.
 * If the handle is valid, it returns the object's kernel pointer
 *  which can be used as a BOOL value only.
 * Use this function to verify handles for which corresponding phe->phead
 *  is a pool allocation (as opposed to desktop-heap allocations).
 */
KERNEL_PVOID FASTCALL HMValidateHandleNoDesktop(
    HANDLE h,
    BYTE bType)
{
    KERNEL_PVOID pobj = NULL;

    StartValidateHandleMacro(h)
    BeginTypeValidateHandleMacro(pobj, bType)
    EndTypeValidateHandleMacro
    EndValidateHandleMacro
    return pobj;
}
#endif


/***************************************************************************\
* HMValidateSharedHandle
*
* This routine validates a handle manager handle allocated in
* shared memory.
*
* History:
* 02-Apr-1997 adams     Created.
\***************************************************************************/

PVOID FASTCALL HMValidateSharedHandle(
    HANDLE h,
    BYTE bType)
{
    DWORD dwError;
    KERNEL_PVOID pobj = NULL;

#if DBG && !defined(_USERK_)

    /*
     * We don't want 32 bit apps passing 16 bit handles
     *  we should consider failing this before we get
     *  stuck supporting it (Some VB apps do this).
     */
    if ((h != NULL)
           && (HMUniqFromHandle(h) == 0)
           && !(GetClientInfo()->dwTIFlags & TIF_16BIT)) {
        RIPMSG3(RIP_WARNING, "HMValidateHandle: 32bit process [%d] using 16 bit handle [%#p] bType:%#lx",
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), h, (DWORD)bType);
    }
#endif

    /*
     * Validation macro. Falls through if the handle is invalid.
     */
    ValidateSharedHandleMacro(pobj, h, bType);

    if (pobj != NULL)
        return KPVOID_TO_PVOID(pobj);

    switch (bType) {
        case TYPE_MONITOR:
            dwError = ERROR_INVALID_MONITOR_HANDLE;
            break;

        default:
            dwError = ERROR_INVALID_HANDLE;
            break;
    }

    RIPERR2(dwError,
            RIP_WARNING,
            "HMValidateSharedHandle: Invalid:%#p Type:%#lx",
            h, (DWORD)bType);

    /*
     * If we get here, it's an error.
     */
    return NULL;
}


/*
 * Switch back to default optimization.
 */
#pragma optimize("", on)

/***************************************************************************\
* MNLookUpItem
*
* Return a pointer to the menu item specified by wCmd and wFlags
*
* History:
*   10-11-90 JimA       Translated from ASM
*   01-07-93 FritzS     Ported from Chicago
\***************************************************************************/

PITEM MNLookUpItem(
    PMENU pMenu,
    UINT wCmd,
    BOOL fByPosition,
    PMENU *ppMenuItemIsOn)
{
    PITEM pItem;
    PITEM pItemRet = NULL;
    PITEM  pItemMaybe;
    PMENU   pMenuMaybe = NULL;
    int i;

    if (ppMenuItemIsOn != NULL)
        *ppMenuItemIsOn = NULL;

    if (pMenu == NULL || !pMenu->cItems || wCmd == MFMWFP_NOITEM) {
//      RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "MNLookUpItem: invalid item");
        return NULL;
    }

    /*
     * dwFlags determines how we do the search
     */
    if (fByPosition) {
        if (wCmd < (UINT)pMenu->cItems) {
            pItemRet = &((PITEM)REBASEALWAYS(pMenu, rgItems))[wCmd];
            if (ppMenuItemIsOn != NULL)
                *ppMenuItemIsOn = pMenu;
            return (pItemRet);
        } else
            return NULL;
    }
    /*
     * Walk down the menu and try to find an item with an ID of wCmd.
     * The search procedes from the end of the menu (as was done in
     * assembler).
     */

/* this is the Chicago code, which walks from the front of the menu -- Fritz */


//        for (pItem = &pMenu->rgItems[i - 1]; pItemRet == NULL && i--; --pItem) {
    for (i = 0, pItem = REBASEALWAYS(pMenu, rgItems); i < (int)pMenu->cItems;
            i++, pItem++) {

        /*
         * If the item is a popup, recurse down the tree
         */
        if (pItem->spSubMenu != NULL) {
        //
        // COMPAT:
        // Allow apps to pass in menu handle as ID in menu APIs.  We
        // remember that this popup had a menu handle with the same ID
        // value.  This is a 2nd choice though.  We still want to see
        // if there's some actual command that has this ID value first.
        //
            if (pItem->wID == wCmd) {
                pMenuMaybe = pMenu;
                pItemMaybe = pItem;
            }

            pItemRet = MNLookUpItem((PMENU)REBASEPTR(pMenu, pItem->spSubMenu),
                    wCmd, FALSE, ppMenuItemIsOn);
            if (pItemRet != NULL)
                return pItemRet;
        } else if (pItem->wID == wCmd) {

                /*
                 * Found the item, now save things for later
                 */
                if (ppMenuItemIsOn != NULL)
                    *ppMenuItemIsOn = pMenu;
                return pItem;
        }
    }

    if (pMenuMaybe) {
        // no non popup menu match found -- use the 2nd choice popup menu
        // match
        if (ppMenuItemIsOn != NULL)
            *ppMenuItemIsOn = pMenuMaybe;
        return(pItemMaybe);
    }

    return(NULL);
}

/***************************************************************************\
* GetMenuState
*
* Either returns the state of a menu item or the state and item count
* of a popup.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

UINT _GetMenuState(
    PMENU pMenu,
    UINT wId,
    UINT dwFlags)
{
    PITEM pItem;
    DWORD fFlags;

    /*
     * If the item does not exist, leave
     */
    if ((pItem = MNLookUpItem(pMenu, wId, (BOOL) (dwFlags & MF_BYPOSITION), NULL)) == NULL)
        return (UINT)-1;

    fFlags = pItem->fState | pItem->fType;

#ifndef _USERK_
    /*
     * Add old MFT_BITMAP flag to keep old apps happy
     */
    if ((pItem->hbmp != NULL) && (pItem->lpstr == NULL)) {
        fFlags |= MFT_BITMAP;
    }
#endif

    if (pItem->spSubMenu != NULL) {
        /*
         * If the item is a popup, return item count in high byte and
         * popup flags in low byte
         */

        fFlags = ((fFlags | MF_POPUP) & 0x00FF) +
            (((PMENU)REBASEPTR(pMenu, pItem->spSubMenu))->cItems << 8);
    }

    return fFlags;
}


/***************************************************************************\
* GetPrevPwnd
*
*
*
* History:
* 11-05-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

PWND GetPrevPwnd(
    PWND pwndList,
    PWND pwndFind)
{
    PWND pwndFound, pwndNext;

    if (pwndList == NULL)
        return NULL;

    if (pwndList->spwndParent == NULL)
        return NULL;

    pwndNext = REBASEPWND(pwndList, spwndParent);
    pwndNext = REBASEPWND(pwndNext, spwndChild);
    pwndFound = NULL;

    while (pwndNext != NULL) {
        if (pwndNext == pwndFind)
            break;
        pwndFound = pwndNext;
        pwndNext = REBASEPWND(pwndNext, spwndNext);
    }

    return (pwndNext == pwndFind) ? pwndFound : NULL;
}


/***************************************************************************\
* _GetWindow (API)
*
*
* History:
* 11-05-90 darrinm      Ported from Win 3.0 sources.
* 02-19-91 JimA         Added enum access check
* 05-04-02 DarrinM      Removed enum access check and moved to USERRTL.DLL
\***************************************************************************/

PWND _GetWindow(
    PWND pwnd,
    UINT cmd)
{
    PWND pwndT;
    BOOL fRebase = FALSE;

    /*
     * If this is a desktop window, return NULL for sibling or
     * parent information.
     */
    if (GETFNID(pwnd) == FNID_DESKTOP) {
        switch (cmd) {
        case GW_CHILD:
            break;

        default:
            return NULL;
            break;
        }
    }

    /*
     * Rebase the returned window at the end of the routine
     * to avoid multiple test for pwndT == NULL.
     */
    pwndT = NULL;
    switch (cmd) {
    case GW_HWNDNEXT:
        pwndT = pwnd->spwndNext;
        fRebase = TRUE;
        break;

    case GW_HWNDFIRST:
        if (pwnd->spwndParent) {
            pwndT = REBASEPWND(pwnd, spwndParent);
            pwndT = REBASEPWND(pwndT, spwndChild);
            if (GetAppCompatFlags(NULL) & GACF_IGNORETOPMOST) {
                while (pwndT != NULL) {
                    if (!TestWF(pwndT, WEFTOPMOST))
                        break;
                    pwndT = REBASEPWND(pwndT, spwndNext);
                }
            }
        }
        break;

    case GW_HWNDLAST:
        pwndT = GetPrevPwnd(pwnd, NULL);
        break;

    case GW_HWNDPREV:
        pwndT = GetPrevPwnd(pwnd, pwnd);
        break;

    case GW_OWNER:
        pwndT = pwnd->spwndOwner;
        fRebase = TRUE;
        break;

    case GW_CHILD:
        pwndT = pwnd->spwndChild;
        fRebase = TRUE;
        break;

#if !defined(_USERK_)
    case GW_ENABLEDPOPUP:
       pwndT = (PWND)NtUserCallHwnd(PtoHq(pwnd), SFI_DWP_GETENABLEDPOPUP);
       fRebase = TRUE;
       break;
#endif

    default:
        RIPERR0(ERROR_INVALID_GW_COMMAND, RIP_VERBOSE, "");
        return NULL;
    }

    if (pwndT != NULL && fRebase)
        pwndT = REBASEPTR(pwnd, pwndT);

    return pwndT;
}

/***************************************************************************\
* _GetParent (API)
*
*
*
* History:
* 11-12-90 darrinm      Ported.
* 02-19-91 JimA         Added enum access check
* 05-04-92 DarrinM      Removed enum access check and moved to USERRTL.DLL
\***************************************************************************/

PWND _GetParent(
    PWND pwnd)
{
    /*
     * For 1.03 compatibility reasons, we should return NULL
     * for top level "tiled" windows and owner for other popups.
     * pwndOwner is set to NULL in xxxCreateWindow for top level
     * "tiled" windows.
     */
    if (!(TestwndTiled(pwnd))) {
        if (TestwndChild(pwnd))
            pwnd = REBASEPWND(pwnd, spwndParent);
        else
            pwnd = REBASEPWND(pwnd, spwndOwner);
        return pwnd;
    }

    /*
     * The window was not a child window; they may have been just testing
     * if it was
     */
    return NULL;
}


/***************************************************************************\
* GetSubMenu
*
* Return the handle of a popup menu.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

PMENU _GetSubMenu(
    PMENU pMenu,
    int nPos)
{
    PITEM pItem;
    PMENU pPopup = NULL;

    /*
     * Make sure nPos refers to a valid popup
     */
    if ((UINT)nPos < (UINT)((PMENU)pMenu)->cItems) {
        pItem = &((PITEM)REBASEALWAYS(pMenu, rgItems))[nPos];
        if (pItem->spSubMenu != NULL)
            pPopup = (PMENU)REBASEPTR(pMenu, pItem->spSubMenu);

    }

    return pPopup;
}


/***************************************************************************\
* _IsChild (API)
*
*
*
* History:
* 11-07-90 darrinm      Translated from Win 3.0 ASM code.
\***************************************************************************/

BOOL _IsChild(
    PWND pwndParent,
    PWND pwnd)
{
    /*
     * Don't need a test to get out of the loop because the
     * desktop is not a child.
     */
    while (pwnd != NULL) {
        if (!TestwndChild(pwnd))
            return FALSE;

        pwnd = REBASEPWND(pwnd, spwndParent);
        if (pwndParent == pwnd)
            return TRUE;
    }
    return FALSE;
}



/***************************************************************************\
* _IsWindowVisible (API)
*
* IsWindowVisible returns the TRUEVIS state of a window, rather than just
* the state of its WFVISIBLE flag.  According to this routine, a window is
* considered visible when it and all the windows on its parent chain are
* visible (WFVISIBLE flag set).  A special case hack was put in that causes
* any icon window being dragged to be considered as visible.
*
* History:
* 11-12-90 darrinm      Ported.
\***************************************************************************/

BOOL _IsWindowVisible(
    PWND pwnd)
{
    /*
     * Check if this is the iconic window being moved around with a mouse
     * If so, return a TRUE, though, strictly speaking, it is hidden.
     * This helps the Tracer guys from going crazy!
     * Fix for Bug #57 -- SANKAR -- 08-08-89 --
     */
    if (pwnd == NULL)
        return TRUE;

    for (;;) {
        if (!TestWF(pwnd, WFVISIBLE))
            return FALSE;
        if (GETFNID(pwnd) == FNID_DESKTOP)
            break;
        pwnd = REBASEPWND(pwnd, spwndParent);
    }

    return TRUE;
}


/***************************************************************************\
* _ClientToScreen (API)
*
* Map a point from client to screen-relative coordinates.
*
* History:
* 11-12-90 darrinm      Translated from Win 3.0 ASM code.
\***************************************************************************/

VOID _ClientToScreen(
    PWND pwnd,
    PPOINT ppt)
{
    /*
     * Client and screen coordinates are the same for the
     * desktop window.
     */
    if (GETFNID(pwnd) != FNID_DESKTOP) {
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            ppt->x  = pwnd->rcClient.right - ppt->x;
        } else {
            ppt->x += pwnd->rcClient.left;
        }
        ppt->y += pwnd->rcClient.top;
    }
}


/***************************************************************************\
* _GetClientRect (API)
*
*
*
* History:
* 26-Oct-1990 DarrinM   Implemented.
\***************************************************************************/

VOID _GetClientRect(
    PWND   pwnd,
    LPRECT prc)
{
    /*
     * If this is a 3.1 app, and it's minimized, then we need to return
     * a rectangle other than the real-client-rect.  This is necessary since
     * there is no client-rect-size in Win4.0.  Apps such as PackRat 1.0
     * will GPF if returned a empty-rect.
     */
    if (TestWF(pwnd, WFMINIMIZED) && !TestWF(pwnd, WFWIN40COMPAT)) {
        prc->left   = 0;
        prc->top    = 0;
        prc->right  = SYSMETRTL(CXMINIMIZED);
        prc->bottom = SYSMETRTL(CYMINIMIZED);

    } else {

        if (GETFNID(pwnd) != FNID_DESKTOP) {
            *prc = pwnd->rcClient;
            OffsetRect(prc, -pwnd->rcClient.left, -pwnd->rcClient.top);
        } else {
            /*
             * For compatibility, return the rect of the primary
             * monitor for the desktop window.
             */
            prc->left = prc->top = 0;
            prc->right = SYSMETRTL(CXSCREEN);
            prc->bottom = SYSMETRTL(CYSCREEN);
        }
    }
}


/***************************************************************************\
* _GetWindowRect (API)
*
*
*
* History:
* 26-Oct-1990 DarrinM   Implemented.
\***************************************************************************/

VOID _GetWindowRect(
    PWND   pwnd,
    LPRECT prc)
{

    if (GETFNID(pwnd) != FNID_DESKTOP) {
        *prc = pwnd->rcWindow;
    } else {
        /*
         * For compatibility, return the rect of the primary
         * monitor for the desktop window.
         */
        prc->left   = 0;
        prc->top    = 0;
        prc->right  = SYSMETRTL(CXSCREEN);
        prc->bottom = SYSMETRTL(CYSCREEN);
    }
}

/***************************************************************************\
* _ScreenToClient (API)
*
* Map a point from screen to client-relative coordinates.
*
* History:
* 11-12-90 darrinm      Translated from Win 3.0 ASM code.
\***************************************************************************/

VOID _ScreenToClient(
    PWND pwnd,
    PPOINT ppt)
{
    /*
     * Client and screen coordinates are the same for the
     * desktop window.
     */
    if (GETFNID(pwnd) != FNID_DESKTOP) {
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            ppt->x  = pwnd->rcClient.right - ppt->x;
        } else {
            ppt->x -= pwnd->rcClient.left;
        }
        ppt->y -= pwnd->rcClient.top;
    }
}
/***************************************************************************\
* PhkNextValid
*
* This helper routine walk the phkNext chain looking for the next valid
*  hook (i.e., not marked as destroyed). If the end of the local (or
*  thread specific) hook chain is reached, then it jumps to the global
*  (or desktop) chain.
*
* Once a hook is destroyed, we don't want anymore activity on it; however,
*  if the hook is locked at destroy time (= someone is calling it), then
*  we keep it in the list so CallNextHook will work properly
*
* History:
* 03/24/96  GerardoB        Moved to rtl and added *Valid stuff.
* 01-30-91  DavidPe         Created.
\***************************************************************************/
PHOOK PhkNextValid(PHOOK phk)
{

#if DBG
    int iHook = phk->iHook;
#ifdef _USERK_
    CheckCritInShared();
#endif
#endif

    do {
        /*
         * If this hook is marked as destroyed, it must be either
         *  locked or we should be in the process of destroying it
         */
        UserAssert(!(phk->flags & HF_DESTROYED)
                    || (((PHEAD)phk)->cLockObj != 0)
                    || (phk->flags & HF_INCHECKWHF));
        /*
         * Get the next hook
         */
        if (phk->phkNext != NULL) {
            phk = REBASEALWAYS(phk, phkNext);
        } else if (!(phk->flags & HF_GLOBAL)) {
#ifdef _USERK_
            phk = PtiCurrent()->pDeskInfo->aphkStart[phk->iHook + 1];
#else
            PCLIENTINFO pci = GetClientInfo();
            phk = pci->pDeskInfo->aphkStart[phk->iHook + 1];
            /*
             * If it found a pointer, rebase it.
             */
            if (phk != NULL) {
                (KPBYTE)phk -= pci->ulClientDelta;
            }
#endif
            UserAssert((phk == NULL) || (phk->flags & HF_GLOBAL));
        } else {
            return NULL;
        }
        /*
         * If destroyed, keep looking.
         */
    } while ((phk != NULL) && (phk->flags & HF_DESTROYED));

#ifdef _USERK_
    DbgValidateHooks(phk, iHook);
#endif

    return phk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\drawtext.c ===
/****************************** Module Header ******************************\
* Module Name: drawtext.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\drawtext.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\draw.c ===
/****************************** Module Header ******************************\
* Module Name: draw.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\draw.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\help.c ===
/****************************** Module Header ******************************\
* Module Name: help.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\help.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\menu.c ===
/****************************** Module Header ******************************\
* Module Name: menu.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\menu.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\mmrtl.c ===
/****************************** Module Header ******************************\
* Module Name: mmrtl.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* 31-Mar-1997 adams Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\mmrtl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\random.c ===
/****************************** Module Header ******************************\
* Module Name: random.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\random.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\rect.c ===
/****************************** Module Header ******************************\
* Module Name: rect.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\rect.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=userrtl
TARGETTYPE=LIBRARY

TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_

!include ..\..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\makefile.inc ===
..\..\precomp.h: $(NTUSER_PATH)\inc\user.h         \
                 $(WINDOWS_INC_PATH)\winuserp.h    \
                 ..\..\userrtl.h

#
# Dependencies for dummy targets
#
..\alignrec.c:  ..\..\alignrec.c
..\chartran.c:  ..\..\chartran.c
..\draw.c:      ..\..\draw.c
..\drawtext.c:  ..\..\drawtext.c
..\getset.c:    ..\..\getset.c
..\help.c:      ..\..\help.c
..\input.c:     ..\..\input.c
..\menu.c:      ..\..\menu.c
..\mmrtl.c:     ..\..\mmrtl.c
..\random.c:    ..\..\random.c
..\rect.c:      ..\..\rect.c
..\text.c:      ..\..\text.c
..\winevent.c:  ..\..\winevent.c
..\winmgr.c:    ..\..\winmgr.c
..\winprop.c:   ..\..\winprop.c
..\wow.c:       ..\..\wow.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\text.c ===
/****************************** Module Header ******************************\
* Module Name: text.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\text.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\alignrec.c ===
/****************************** Module Header ******************************\
* Module Name: chartran.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#define MOVE_TO_RTL
#include "precomp.h"
#pragma hdrstop
#include "..\alignrec.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\chartran.c ===
/****************************** Module Header ******************************\
* Module Name: chartran.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#define MOVE_TO_RTL
#include "precomp.h"
#pragma hdrstop
#include "..\chartran.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\draw.c ===
/****************************** Module Header ******************************\
* Module Name: draw.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\draw.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\getset.c ===
/****************************** Module Header ******************************\
* Module Name: getset.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\getset.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\drawtext.c ===
/****************************** Module Header ******************************\
* Module Name: drawtext.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\drawtext.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\help.c ===
/****************************** Module Header ******************************\
* Module Name: help.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\help.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\input.c ===
/****************************** Module Header ******************************\
* Module Name: input.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\input.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\winevent.c ===
/****************************** Module Header ******************************\
* Module Name: winevent.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
* It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
* files that are not stored in the current directory or the current
* directory's parent.
* Note also that a specific dependency line is included in makefile.inc
* so the corresponding object is properly rebuilt when the source file
* included below changes.
*
* History:
* Jul-18-2000 DwayneN Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winevent.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\menu.c ===
/****************************** Module Header ******************************\
* Module Name: menu.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\menu.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\mmrtl.c ===
/****************************** Module Header ******************************\
* Module Name: mmrtl.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* 31-Mar-1997 adams Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\mmrtl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\winmgr.c ===
/****************************** Module Header ******************************\
* Module Name: winmgr.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winmgr.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\winprop.c ===
/****************************** Module Header ******************************\
* Module Name: winprop.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winprop.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\random.c ===
/****************************** Module Header ******************************\
* Module Name: random.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\random.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\rect.c ===
/****************************** Module Header ******************************\
* Module Name: rect.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\rect.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\text.c ===
/****************************** Module Header ******************************\
* Module Name: text.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\text.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\winevent.c ===
/****************************** Module Header ******************************\
* Module Name: winevent.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
* It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
* files that are not stored in the current directory or the current
* directory's parent.
* Note also that a specific dependency line is included in makefile.inc
* so the corresponding object is properly rebuilt when the source file
* included below changes.
*
* History:
* Jul-18-2000 DwayneN Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winevent.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\winmgr.c ===
/****************************** Module Header ******************************\
* Module Name: winmgr.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winmgr.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\winprop.c ===
/****************************** Module Header ******************************\
* Module Name: winprop.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winprop.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\client\wow.c ===
/****************************** Module Header ******************************\
* Module Name: wow.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#ifndef WOW
#pragma hdrstop
#endif
#include "..\wow.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=userkrtl
TARGETTYPE=LIBRARY

TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_ -D_USERK_ -DNTOS_KERNEL_RUNTIME=1

NTTARGETFILES=

!include ..\..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\makefile.inc ===
..\..\precomp.h: $(NTUSER_PATH)\inc\user.h    \
    $(PROJECT_INC_PATH)\winuserp.h            \
    ..\..\userrtl.h

#
# Dependencies for dummy targets
#
..\alignrec.c:  ..\..\alignrec.c
..\chartran.c:  ..\..\chartran.c
..\draw.c:      ..\..\draw.c
..\drawtext.c:  ..\..\drawtext.c
..\getset.c:    ..\..\getset.c
..\help.c:      ..\..\help.c
..\input.c:     ..\..\input.c
..\menu.c:      ..\..\menu.c
..\mmrtl.c:     ..\..\mmrtl.c
..\random.c:    ..\..\random.c
..\rect.c:      ..\..\rect.c
..\text.c:      ..\..\text.c
..\winevent.c:  ..\..\winevent.c
..\winmgr.c:    ..\..\winmgr.c
..\winprop.c:   ..\..\winprop.c
..\wow.c:       ..\..\wow.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\rtl\kernel\wow.c ===
/****************************** Module Header ******************************\
* Module Name: wow.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#ifndef WOW
#pragma hdrstop
#endif
#include "..\wow.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\api.c ===
/*************************************************************************
*
* api.c
*
* WinStation Control API's for WIN32 subsystem.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*************************************************************************/

/*
 * Includes.
 */
#include "precomp.h"
#pragma hdrstop

#include "ntuser.h"

#include <winsta.h>
#include <wstmsg.h>
#include <icadd.h>
#include <winbasep.h>

#define SESSION_ROOT L"\\Sessions"
#define MAX_SESSION_PATH 256

NTSTATUS CsrPopulateDosDevices(VOID);
NTSTATUS CleanupSessionObjectDirectories(VOID);

BOOL CtxInitUser32(VOID);

USHORT gHRes = 0;
USHORT gVRes = 0;
USHORT gColorDepth = 0;

#if DBG
ULONG  gulConnectCount = 0;
#endif // DBG

DWORD  gLUIDDeviceMapsEnabled = 0;

/*
 * The following are gotten from ICASRV.
 */
HANDLE G_IcaVideoChannel = NULL;
HANDLE G_IcaMouseChannel = NULL;
HANDLE G_IcaKeyboardChannel = NULL;
HANDLE G_IcaBeepChannel = NULL;
HANDLE G_IcaCommandChannel = NULL;
HANDLE G_IcaThinwireChannel = NULL;
WCHAR  G_WinStationName[WINSTATIONNAME_LENGTH];
HANDLE G_DupIcaVideoChannel = NULL;
HANDLE G_DupIcaCommandChannel = NULL;


HANDLE G_ConsoleShadowVideoChannel;
HANDLE G_ConsoleShadowMouseChannel;
HANDLE G_ConsoleShadowKeyboardChannel;
HANDLE G_ConsoleShadowBeepChannel;
HANDLE G_ConsoleShadowCommandChannel;
HANDLE G_ConsoleShadowThinwireChannel;
BOOL   G_fCursorShadow;
HANDLE G_DupConsoleShadowVideoChannel = NULL;
HANDLE G_DupConsoleShadowCommandChannel = NULL;

/*
 * Definition for the WinStation control API's dispatch table
 */
typedef NTSTATUS (*PWIN32WINSTATION_API)(IN OUT PWINSTATION_APIMSG ApiMsg);

typedef struct _WIN32WINSTATION_DISPATCH {
    PWIN32WINSTATION_API pWin32ApiProc;
} WIN32WINSTATION_DISPATCH, *PWIN32WINSTATION_DISPATCH;

NTSTATUS W32WinStationDoConnect(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationDoDisconnect(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationDoReconnect(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationExitWindows(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationTerminate(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationNtSecurity(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationDoMessage(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationThinwireStats(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationShadowSetup(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationShadowStart(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationShadowStop(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationShadowCleanup(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationPassthruEnable(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationPassthruDisable(IN OUT PWINSTATION_APIMSG);

// This is the counter part to SMWinStationBroadcastSystemMessage
NTSTATUS W32WinStationBroadcastSystemMessage(IN OUT PWINSTATION_APIMSG);
// This is the counter part to SMWinStationSendWindowMessage
NTSTATUS W32WinStationSendWindowMessage(IN OUT PWINSTATION_APIMSG);

NTSTATUS W32WinStationSetTimezone(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationDoNotify(IN OUT PWINSTATION_APIMSG);
NTSTATUS W32WinStationDoLoadStringNMessage(IN OUT PWINSTATION_APIMSG);
HANDLE CreateTermSrvReadyEvent();

/*
 * WinStation API Dispatch Table
 *
 * Only the API's that WIN32 implements as opposed to ICASRV
 * are entered here. The rest are NULL so that the same WinStation API
 * numbers may be used by ICASRV and WIN32.  If this table is
 * changed, the table below must be modified too, as well as the API
 * dispatch table in the ICASRV.
 */


WIN32WINSTATION_DISPATCH Win32WinStationDispatch[SMWinStationMaxApiNumber] = {
    NULL, // create
    NULL, // reset
    NULL, // disconnect
    NULL, // WCharLog
    NULL, // ApiWinStationGetSMCommand,
    NULL, // ApiWinStationBrokenConnection,
    NULL, // ApiWinStationIcaReplyMessage,
    NULL, // ApiWinStationIcaShadowHotkey,
    W32WinStationDoConnect,
    W32WinStationDoDisconnect,
    W32WinStationDoReconnect,
    W32WinStationExitWindows,
    W32WinStationTerminate,
    W32WinStationNtSecurity,
    W32WinStationDoMessage,
    NULL,
    W32WinStationThinwireStats,
    W32WinStationShadowSetup,
    W32WinStationShadowStart,
    W32WinStationShadowStop,
    W32WinStationShadowCleanup,
    W32WinStationPassthruEnable,
    W32WinStationPassthruDisable,
    W32WinStationSetTimezone,
    NULL, // [AraBern] this was missing: SMWinStationInitialProgram
    NULL, // [AraBern] this was missing: SMWinStationNtsdDebug
    W32WinStationBroadcastSystemMessage,
    W32WinStationSendWindowMessage,
    W32WinStationDoNotify,
    W32WinStationDoLoadStringNMessage,
    NULL, // SMWinStationWindowInvalid
};

#if DBG
PSZ Win32WinStationAPIName[SMWinStationMaxApiNumber] = {
    "SmWinStationCreate",
    "SmWinStationReset",
    "SmWinStationDisconnect",
    "SmWinStationWCharLog",
    "SmWinStationGetSMCommand",
    "SmWinStationBrokenConnection",
    "SmWinStationIcaReplyMessage",
    "SmWinStationIcaShadowHotkey",
    "SmWinStationDoConnect",
    "SmWinStationDoDisconnect",
    "SmWinStationDoReconnect",
    "SmWinStationExitWindows",
    "SmWinStationTerminate",
    "SmWinStationNtSecurity",
    "SmWinStationDoMessage",
    "SmWinstationDoBreakPoint",
    "SmWinStationThinwireStats",
    "SmWinStationShadowSetup",
    "SmWinStationShadowStart",
    "SmWinStationShadowStop",
    "SmWinStationShadowCleanup",
    "SmWinStationPassthruEnable",
    "SmWinStationPassthruDisable",
    "SMWinStationSetTimeZone",
    "SMWinStationInitialProgram",
    "SMWinStationNtsdDebug",
    "W32WinStationBroadcastSystemMessage",
    "W32WinStationSendWindowMessage",
    "W32WinStationDoNotify",
    "W32WinStationDoLoadStringNMessage",
    "SMWinStationWindowInvalid",
};
#endif

NTSTATUS TerminalServerRequestThread(PVOID);
NTSTATUS Win32CommandChannelThread(PVOID);
NTSTATUS Win32ConsoleShadowChannelThread(PVOID);
NTSTATUS RemoteDoMessage(PWINSTATION_APIMSG pMsg);
NTSTATUS RemoteDoLoadStringNMessage(PWINSTATION_APIMSG pMsg);
NTSTATUS MultiUserSpoolerInit();

extern HANDLE g_hDoMessageEvent;

NTSTATUS RemoteDoBroadcastSystemMessage(PWINSTATION_APIMSG pMsg);
NTSTATUS RemoteDoSendWindowMessage(PWINSTATION_APIMSG pMsg);
BOOL CancelExitWindows(VOID);



/*****************************************************************************
 *
 *  WinStationAPIInit
 *
 *   Creates and initializes the WinStation API port and thread.
 *
 * ENTRY:
 *    No Parameters
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationAPIInit(
    VOID)
{
    NTSTATUS  Status;
    CLIENT_ID ClientId;
    HANDLE    ThreadHandle;
    KPRIORITY Priority;
    ULONG LUIDDeviceMapsEnabled;
#if DBG
    static BOOL Inited = FALSE;
#endif

#if DBG
    UserAssert(Inited == FALSE);
    Inited = TRUE;
#endif

    gSessionId = NtCurrentPeb()->SessionId;

    //
    // Check if LUID DosDevices are enabled.
    //
    Status = NtQueryInformationProcess(NtCurrentProcess(),
                                       ProcessLUIDDeviceMapsEnabled,
                                       &LUIDDeviceMapsEnabled,
                                       sizeof(LUIDDeviceMapsEnabled),
                                       NULL);
    if (NT_SUCCESS(Status)) {
        gLUIDDeviceMapsEnabled = LUIDDeviceMapsEnabled;
    }

    Status = RtlCreateUserThread(NtCurrentProcess(),
                                 NULL,
                                 TRUE,
                                 0,
                                 0,
                                 0,
                                 TerminalServerRequestThread,
                                 NULL,
                                 &ThreadHandle,
                                 &ClientId);
    if (!NT_SUCCESS(Status)) {
        RIPMSGF1(RIP_WARNING,
                 "Failed to create TerminalServerRequestThread, Status = 0x%x",
                 Status);
        goto Exit;
    }

    /*
     * Add thread to server thread pool.
     */
    CsrAddStaticServerThread(ThreadHandle, &ClientId, 0);

    /*
     * Boost priority of ICA SRV Request thread
     */
    Priority = THREAD_BASE_PRIORITY_MAX;

    Status = NtSetInformationThread(ThreadHandle, ThreadBasePriority,
                                 &Priority, sizeof(Priority));

    if (!NT_SUCCESS(Status)) {
        RIPMSGF1(RIP_WARNING,
                 "Failed to set thread priority, Status = 0x%x",
                 Status);
        goto Exit;
    }

    /*
     * Resume the thread now that we've initialized things.
     */
    NtResumeThread(ThreadHandle, NULL);

Exit:
    return Status;
}

NTSTATUS
TerminalServerRequestThread(
    PVOID ThreadParameter)
{
    UNICODE_STRING              PortName;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    WINSTATIONAPI_CONNECT_INFO  info;
    ULONG                       ConnectInfoLength;
    WINSTATION_APIMSG           ApiMsg;
    PWIN32WINSTATION_DISPATCH   pDispatch;
    NTSTATUS                    Status;
    REMOTE_PORT_VIEW            ServerView;
    HANDLE                      CsrStartHandle, hevtTermSrvInit;
    HANDLE                      hLPCPort = NULL;

    UNREFERENCED_PARAMETER(ThreadParameter);

    if (NtCurrentPeb()->SessionId == 0) {
        hevtTermSrvInit = CreateTermSrvReadyEvent();
    } else {
        hevtTermSrvInit = OpenEvent(SYNCHRONIZE, FALSE, L"Global\\TermSrvReadyEvent");
    }

    if (hevtTermSrvInit == NULL) {
        RIPMSG1(RIP_WARNING,
                "Couldn't create TermSrvReadyEvent. Error = 0x%x",
                GetLastError());
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    NtWaitForSingleObject(hevtTermSrvInit, FALSE, NULL);
    NtClose(hevtTermSrvInit);

    /*
     * Connect to terminal server API port.
     */
    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    RtlInitUnicodeString(&PortName, L"\\SmSsWinStationApiPort");

    /*
     * Init the REMOTE_VIEW structure.
     */
    ServerView.Length = sizeof(ServerView);
    ServerView.ViewSize = 0;
    ServerView.ViewBase = 0;

    /*
     * Fill in the ConnectInfo structure with our access request mask.
     */
    info.Version = CITRIX_WINSTATIONAPI_VERSION;
    info.RequestedAccess = 0;
    ConnectInfoLength = sizeof(WINSTATIONAPI_CONNECT_INFO);

    Status = NtConnectPort(&hLPCPort,
                           &PortName,
                           &DynamicQos,
                           NULL, // ClientView
                           &ServerView,
                           NULL, // Max message length [select default]
                           (PVOID)&info,
                           &ConnectInfoLength);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "TerminalServerRequestThread: Failed to connect to LPC port: Status = 0x%x", Status);
        UserExitWorkerThread(Status);
        return Status;
    }

    //
    // Terminal Server calls into Session Manager to create a new Hydra session.
    // The session manager creates and resume a new session and returns to Terminal
    // server the session id of the new session. There is a race condition where
    // CSR can resume and call into terminal server before terminal server can
    // store the session id in its internal structure. To prevent this CSR will
    // wait here on a named event which will be set by Terminal server once it
    // gets the sessionid for the newly created session
    //

    if (NtCurrentPeb()->SessionId != 0) {
        CsrStartHandle = CreateEvent(NULL, TRUE, FALSE, L"CsrStartEvent");

        if (!CsrStartHandle) {
            RIPMSG1(RIP_WARNING,
                    "Failed to create CsrStartEvent. Error = 0x%x",
                    GetLastError());
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        } else {
            Status = NtWaitForSingleObject(CsrStartHandle, FALSE, NULL);

            NtClose(CsrStartHandle);
            if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING,
                        "Wait for CsrStartEvent failed: Status = 0x%x", Status);
            }
        }
    }

    RtlZeroMemory(&ApiMsg, sizeof(ApiMsg));
    for (;;) {

        /*
         * Initialize LPC message fields.
         */
        ApiMsg.h.u1.s1.DataLength     = sizeof(ApiMsg) - sizeof(PORT_MESSAGE);
        ApiMsg.h.u1.s1.TotalLength    = sizeof(ApiMsg);
        ApiMsg.h.u2.s2.Type           = 0; // Kernel will fill in message type
        ApiMsg.h.u2.s2.DataInfoOffset = 0;
        ApiMsg.ApiNumber              = SMWinStationGetSMCommand;

        Status = NtRequestWaitReplyPort(hLPCPort,
                                        (PPORT_MESSAGE)&ApiMsg,
                                        (PPORT_MESSAGE)&ApiMsg);

        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING,
                    "TerminalServerRequestThread wait failed: Status 0x%x", Status);
            break;
        }

        if (ApiMsg.ApiNumber >= SMWinStationMaxApiNumber) {
            RIPMSG1(RIP_WARNING,
                    "TerminalServerRequestThread: Bad API number %d", ApiMsg.ApiNumber);

            ApiMsg.ReturnedStatus = STATUS_NOT_IMPLEMENTED;
        } else {
            /*
             * We must VALIDATE which ones are implemented here.
             */
            pDispatch = &Win32WinStationDispatch[ApiMsg.ApiNumber];

            if (pDispatch->pWin32ApiProc) {
                BOOL bRestoreDesktop = FALSE;
                USERTHREAD_USEDESKTOPINFO utudi;

                Status = STATUS_SUCCESS;

                /*
                 * For all the win32k callouts - with the exception of
                 * terminate and timezone setting - set this thread to the
                 * current desktop.
                 */
                if (ApiMsg.ApiNumber != SMWinStationTerminate && ApiMsg.ApiNumber != SMWinStationSetTimeZone) {
                    BOOL bAttachDesktop = TRUE;
                    if (ApiMsg.ApiNumber == SMWinStationDoConnect) {
                        WINSTATIONDOCONNECTMSG* m = &ApiMsg.u.DoConnect;
                        if (!m->ConsoleShadowFlag) {
                            bAttachDesktop = FALSE;
                        }
                    }
                    if (bAttachDesktop) {
                        utudi.hThread = NULL;
                        utudi.drdRestore.pdeskRestore = NULL;
                        Status = NtUserSetInformationThread(NtCurrentThread(),
                                                            UserThreadUseActiveDesktop,
                                                            &utudi, sizeof(utudi));

                        if (NT_SUCCESS(Status)) {
                            bRestoreDesktop = TRUE;
                        }
                    }
                }


                /*
                 * Call the API
                 */
                if (Status == STATUS_SUCCESS) {
                    ApiMsg.ReturnedStatus = (pDispatch->pWin32ApiProc)(&ApiMsg);
                } else {
                    ApiMsg.ReturnedStatus = Status;
                }

                if (bRestoreDesktop) {
                    NtUserSetInformationThread(NtCurrentThread(),
                                               UserThreadUseDesktop,
                                               &utudi,
                                               sizeof(utudi));
                }

                /*
                 * Let's bail ...
                 */
                if (ApiMsg.ApiNumber == SMWinStationTerminate) {
                    break;
                }
            } else {
                // This control API is not implemented in WIN32
                ApiMsg.ReturnedStatus = STATUS_NOT_IMPLEMENTED;
            }
        }
    }

Exit:
    if (hLPCPort) {
        NtClose(hLPCPort);
    }

    UserExitWorkerThread(Status);
    return Status;
}

#if DBG
VOID
W32WinStationDumpReconnectInfo(
    WINSTATIONDORECONNECTMSG *pDoReconnect,
    BOOLEAN bReconnect)
{
    PSTR pCallerName;

    if (bReconnect) {
        pCallerName = "W32WinStationDoReconnect";
    } else {
        pCallerName = "W32WinStationDoConnect";
    }

    DbgPrint(pCallerName);
    DbgPrint(" - Display resolution information for session %d :\n", gSessionId);

    DbgPrint("\tProtocolType : %04d\n", pDoReconnect->ProtocolType);
    DbgPrint("\tHRes : %04d\n", pDoReconnect->HRes);
    DbgPrint("\tVRes : %04d\n", pDoReconnect->VRes);
    DbgPrint("\tColorDepth : %04d\n", pDoReconnect->ColorDepth);

    DbgPrint("\tKeyboardType : %d\n", pDoReconnect->KeyboardType);
    DbgPrint("\tKeyboardSubType : %d\n", pDoReconnect->KeyboardSubType);
    DbgPrint("\tKeyboardFunctionKey : %d\n", pDoReconnect->KeyboardFunctionKey);
}
#else
    #define W32WinStationDumpReconnectInfo(p, b)
#endif // DBG

NTSTATUS
W32WinStationDoConnect(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    WINSTATIONDOCONNECTMSG* m = &pMsg->u.DoConnect;
    WCHAR                   DisplayDriverName[10];
    CLIENT_ID               ClientId;
    HANDLE                  ThreadHandle = NULL;
    KPRIORITY               Priority;
    DOCONNECTDATA           DoConnectData;
    WINSTATIONDORECONNECTMSG mDoReconnect;
    HANDLE hDisplayChangeEvent = NULL;


    if (!m->ConsoleShadowFlag) {
        UserAssert(gulConnectCount == 0);

        if ((gLUIDDeviceMapsEnabled == 0) && (gSessionId != 0)) {
            /*
             * Populate the sessions \DosDevices from
             * the current consoles settings
             */
            Status = CsrPopulateDosDevices();
            if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING, "CsrPopulateDosDevices failed with Status %lx", Status);
                goto Exit;
            }
        }

        G_IcaVideoChannel    = m->hIcaVideoChannel;
        G_IcaMouseChannel    = m->hIcaMouseChannel;
        G_IcaKeyboardChannel = m->hIcaKeyboardChannel;
        G_IcaBeepChannel     = m->hIcaBeepChannel;
        G_IcaCommandChannel  = m->hIcaCommandChannel;
        G_IcaThinwireChannel = m->hIcaThinwireChannel;

        RtlZeroMemory(G_WinStationName, sizeof(G_WinStationName));
        memcpy(G_WinStationName, m->WinStationName,
                min(sizeof(G_WinStationName), sizeof(m->WinStationName)));

        Status = NtDuplicateObject( NtCurrentProcess(),
                                    G_IcaVideoChannel,
                                    NtCurrentProcess(),
                                    &G_DupIcaVideoChannel,
                                    0,
                                    0,
                                    DUPLICATE_SAME_ACCESS );
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "NtDuplicateObject failed with Status %lx", Status);
            goto Exit;
        }

        Status = NtDuplicateObject( NtCurrentProcess(),
                                    G_IcaCommandChannel,
                                    NtCurrentProcess(),
                                    &G_DupIcaCommandChannel,
                                    0,
                                    0,
                                    DUPLICATE_SAME_ACCESS );
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "NtDuplicateObject failed with Status %lx", Status);
            NtClose(G_DupIcaVideoChannel);
            G_DupIcaVideoChannel = NULL;
            goto Exit;
        }
    }  else {
        G_ConsoleShadowVideoChannel    = m->hIcaVideoChannel;
        G_ConsoleShadowMouseChannel    = m->hIcaMouseChannel;
        G_ConsoleShadowKeyboardChannel = m->hIcaKeyboardChannel;
        G_ConsoleShadowBeepChannel     = m->hIcaBeepChannel;
        G_ConsoleShadowCommandChannel  = m->hIcaCommandChannel;
        G_ConsoleShadowThinwireChannel = m->hIcaThinwireChannel;

        G_fCursorShadow = FALSE;
        SystemParametersInfo(SPI_GETCURSORSHADOW, 0, &G_fCursorShadow, 0);
        if (G_fCursorShadow) {
            SystemParametersInfo(SPI_SETCURSORSHADOW, 0, FALSE, 0);
        }

        hDisplayChangeEvent = m->hDisplayChangeEvent;

        Status = NtDuplicateObject( NtCurrentProcess(),
                                    G_ConsoleShadowVideoChannel,
                                    NtCurrentProcess(),
                                    &G_DupConsoleShadowVideoChannel,
                                    0,
                                    0,
                                    DUPLICATE_SAME_ACCESS );
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "NtDuplicateObject failed with Status %lx", Status);
            goto Exit;
        }

        Status = NtDuplicateObject( NtCurrentProcess(),
                                    G_ConsoleShadowCommandChannel,
                                    NtCurrentProcess(),
                                    &G_DupConsoleShadowCommandChannel,
                                    0,
                                    0,
                                    DUPLICATE_SAME_ACCESS );
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "NtDuplicateObject failed with Status %lx", Status);
            NtClose(G_DupConsoleShadowVideoChannel);
            G_DupConsoleShadowVideoChannel = NULL;
            goto Exit;
        }
    }


    /*
     * This must be 8 unicode characters (file name) plus two zero wide characters.
     */
    RtlZeroMemory(DisplayDriverName, sizeof(DisplayDriverName));
    memcpy(DisplayDriverName, m->DisplayDriverName, sizeof(DisplayDriverName) - 2);

    /*
     * Give the information to the WIN32 driver.
     */
    RtlZeroMemory(&DoConnectData, sizeof(DoConnectData));

    DoConnectData.fMouse          = m->fMouse;
    DoConnectData.IcaBeepChannel  = m->hIcaBeepChannel;
    DoConnectData.IcaVideoChannel = m->hIcaVideoChannel;
    DoConnectData.IcaMouseChannel = m->hIcaMouseChannel;
    DoConnectData.fEnableWindowsKey = m->fEnableWindowsKey;

    DoConnectData.IcaKeyboardChannel        = m->hIcaKeyboardChannel;
    DoConnectData.IcaThinwireChannel        = m->hIcaThinwireChannel;
    DoConnectData.fClientDoubleClickSupport = m->fClientDoubleClickSupport;

    DoConnectData.DisplayChangeEvent = hDisplayChangeEvent;

    /*
     * Give the information to the keyboard type/subtype/number of functions.
     */
    DoConnectData.ClientKeyboardType.Type        = m->KeyboardType;
    DoConnectData.ClientKeyboardType.SubType     = m->KeyboardSubType;
    DoConnectData.ClientKeyboardType.FunctionKey = m->KeyboardFunctionKey;

    memcpy(DoConnectData.WinStationName, G_WinStationName,
            min(sizeof(G_WinStationName), sizeof(DoConnectData.WinStationName)));

    DoConnectData.drProtocolType = m->ProtocolType;
    DoConnectData.drPelsHeight = m->VRes;
    DoConnectData.drPelsWidth = m->HRes;
    DoConnectData.drBitsPerPel = m->ColorDepth;

    mDoReconnect.ProtocolType = m->ProtocolType;
    mDoReconnect.HRes = m->HRes;
    mDoReconnect.VRes = m->VRes;
    mDoReconnect.ColorDepth = m->ColorDepth;

    W32WinStationDumpReconnectInfo(&mDoReconnect, FALSE);

    /* Give winstation protocol name */
    RtlZeroMemory(DoConnectData.ProtocolName, sizeof(DoConnectData.ProtocolName));
    memcpy(DoConnectData.ProtocolName, m->ProtocolName, sizeof(DoConnectData.ProtocolName) - 2);

    /* Give winstation audio drver name */
    RtlZeroMemory(DoConnectData.AudioDriverName, sizeof(DoConnectData.AudioDriverName));
    memcpy(DoConnectData.AudioDriverName, m->AudioDriverName, sizeof(DoConnectData.AudioDriverName) - 2);


    DoConnectData.fConsoleShadowFlag = (BOOL) m->ConsoleShadowFlag;

    Status = NtUserRemoteConnect(&DoConnectData,
                                 ARRAY_SIZE(DisplayDriverName),
                                 DisplayDriverName);

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "NtUserRemoteConnect failed with Status %lx", Status);
        goto Exit;
    }


    Status = RtlCreateUserThread(NtCurrentProcess(),
                                 NULL,
                                 TRUE,
                                 0L,
                                 0L,
                                 0L,
                                 Win32CommandChannelThread,
                                 (PVOID)m->ConsoleShadowFlag,
                                 &ThreadHandle,
                                 &ClientId);


    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "RtlCreateUserThread failed with Status %lx", Status);
        if (G_DupIcaVideoChannel) {
            NtClose(G_DupIcaVideoChannel);
            G_DupIcaVideoChannel = NULL;
        }

        if (G_DupIcaCommandChannel) {
            NtClose(G_DupIcaCommandChannel);
            G_DupIcaCommandChannel = NULL;
        }

        if (G_DupConsoleShadowVideoChannel) {
            NtClose(G_DupConsoleShadowVideoChannel);
            G_DupConsoleShadowVideoChannel = NULL;
        }

        if (G_DupConsoleShadowCommandChannel) {
            NtClose(G_DupConsoleShadowCommandChannel);
            G_DupConsoleShadowCommandChannel = NULL;
        }

        goto Exit;
    }

    /*
     * Add thread to server thread pool only if we are in regular sessions.
     * In console shadow, we don't do this as it will leak the handle --
     * CSRSS doesn't close these handles.
     */
    if (!m->ConsoleShadowFlag && CsrAddStaticServerThread(ThreadHandle, &ClientId, 0) == NULL) {
        RIPMSG0(RIP_WARNING, "CsrAddStaticServerThread failed");

        /*
         * Close the handle as the above function does not have a reference
         * to us in its list.
         */
        CloseHandle(ThreadHandle);
        goto Exit;
    }

    /*
     * Boost priority of thread
     */
    Priority = THREAD_BASE_PRIORITY_MAX;

    Status = NtSetInformationThread(ThreadHandle, ThreadBasePriority,
                                    &Priority, sizeof(Priority));

    UserAssert(NT_SUCCESS(Status));

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "NtSetInformationThread failed with Status %lx", Status);
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * Resume the thread now that we've initialized things.
     */
    NtResumeThread(ThreadHandle, NULL);

    if (!m->ConsoleShadowFlag) {
        if (CsrConnectToUser() == NULL) {
            RIPMSG0(RIP_WARNING, "CsrConnectToUser failed");
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        if (!CtxInitUser32()) {
            RIPMSG0(RIP_WARNING, "CtxInitUser32 failed");
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        /*
         * Create the Spooler service thread
         */
        if (gSessionId != 0) {
            Status = MultiUserSpoolerInit();
        }

        /*
         * Save the resolution
         */
        gHRes       = mDoReconnect.HRes;
        gVRes       = mDoReconnect.VRes;
        gColorDepth = mDoReconnect.ColorDepth;
    } else {
        /*
         * By now, the object has been referenced in kernel mode.
         */
        CloseHandle(hDisplayChangeEvent);
    }

Exit:

#if DBG
    if (!m->ConsoleShadowFlag) {
        if (Status == STATUS_SUCCESS) {
            gulConnectCount++;
        }
    }
#endif // DBG

    /*
     *  Close the thread handle now if we are in console shadow
     */
    if (m->ConsoleShadowFlag && NULL != ThreadHandle) {
        CloseHandle(ThreadHandle);
    }
    return Status;
}


NTSTATUS
W32WinStationDoDisconnect(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WINSTATIONDODISCONNECTMSG *m = &pMsg->u.DoDisconnect;
    IO_STATUS_BLOCK IoStatus;

    if (!m->ConsoleShadowFlag) {
        RtlZeroMemory(G_WinStationName, sizeof(G_WinStationName));
        Status = (NTSTATUS)NtUserCallNoParam(SFI_XXXREMOTEDISCONNECT);
    } else {
        Status = (NTSTATUS)NtUserCallNoParam(SFI_XXXREMOTECONSOLESHADOWSTOP);

        if (G_ConsoleShadowMouseChannel) {
            CloseHandle(G_ConsoleShadowMouseChannel);
            G_ConsoleShadowMouseChannel = NULL;
        }
        if (G_ConsoleShadowKeyboardChannel) {
            CloseHandle(G_ConsoleShadowKeyboardChannel);
            G_ConsoleShadowKeyboardChannel = NULL;
        }

        // Instead send a IOCTL to termdd
        if (G_ConsoleShadowCommandChannel) {
            Status = NtDeviceIoControlFile(
                        G_ConsoleShadowCommandChannel,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL,
                        NULL,
                        0,
                        NULL,
                        0);
            CloseHandle(G_ConsoleShadowCommandChannel);
            G_ConsoleShadowCommandChannel = NULL;
        }

        if (G_ConsoleShadowVideoChannel) {
            Status = NtDeviceIoControlFile(
                        G_ConsoleShadowVideoChannel,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL,
                        NULL,
                        0,
                        NULL,
                        0);
            CloseHandle(G_ConsoleShadowVideoChannel);
            G_ConsoleShadowVideoChannel = NULL;
        }

        if (G_ConsoleShadowBeepChannel) {
            CloseHandle(G_ConsoleShadowBeepChannel);
            G_ConsoleShadowBeepChannel = NULL;
        }

        if (G_ConsoleShadowThinwireChannel) {
            CloseHandle(G_ConsoleShadowThinwireChannel);
            G_ConsoleShadowThinwireChannel = NULL;
        }

        if (G_fCursorShadow) {
            SystemParametersInfo(SPI_SETCURSORSHADOW, 0, (LPVOID)TRUE, 0);
        }
    }

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "xxxRemoteDisconnect failed with Status %lx", Status);
    }

#if DBG
    if (!m->ConsoleShadowFlag && Status == STATUS_SUCCESS) {
        gulConnectCount--;
    }

#endif // DBG

    return Status;
}


NTSTATUS
W32WinStationDoReconnect(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    DORECONNECTDATA             DoReconnectData;
    WINSTATIONDORECONNECTMSG*   m = &pMsg->u.DoReconnect;

    UserAssert(gulConnectCount == 0);

    RtlZeroMemory(&DoReconnectData, sizeof(DoReconnectData));

    DoReconnectData.fMouse = m->fMouse;
    DoReconnectData.fEnableWindowsKey = m->fEnableWindowsKey;
    DoReconnectData.fClientDoubleClickSupport = m->fClientDoubleClickSupport;

    memcpy(G_WinStationName, m->WinStationName,
           min(sizeof(G_WinStationName), sizeof(m->WinStationName)));

    memcpy(DoReconnectData.WinStationName, G_WinStationName,
           min(sizeof(G_WinStationName), sizeof(DoReconnectData.WinStationName)));

    DoReconnectData.drProtocolType = m->ProtocolType;
    DoReconnectData.drPelsHeight = m->VRes;
    DoReconnectData.drPelsWidth = m->HRes;
    DoReconnectData.drBitsPerPel = m->ColorDepth;
    if (m->fDynamicReconnect) {
       DoReconnectData.fChangeDisplaySettings = TRUE;
    } else {
       DoReconnectData.fChangeDisplaySettings = FALSE;
    }
    // DoReconnectData.drDisplayFrequency is no yet setup
    DoReconnectData.drDisplayFrequency = 0;

    /*
     * Give the information to the keyboard type/subtype/number of functions.
     */
    DoReconnectData.ClientKeyboardType.Type        = m->KeyboardType;
    DoReconnectData.ClientKeyboardType.SubType     = m->KeyboardSubType;
    DoReconnectData.ClientKeyboardType.FunctionKey = m->KeyboardFunctionKey;


    RtlZeroMemory(DoReconnectData.DisplayDriverName, sizeof(DoReconnectData.DisplayDriverName));

    UserAssert(sizeof(m->DisplayDriverName) <= sizeof(WCHAR) * DR_DISPLAY_DRIVER_NAME_LENGTH);
    memcpy(DoReconnectData.DisplayDriverName, m->DisplayDriverName, sizeof(m->DisplayDriverName) - 2);

    RtlZeroMemory(DoReconnectData.ProtocolName, sizeof(DoReconnectData.ProtocolName));

    UserAssert(sizeof(m->DisplayDriverName) <= sizeof(WCHAR) * WPROTOCOLNAME_LENGTH);
    memcpy(DoReconnectData.ProtocolName, m->ProtocolName, sizeof(m->ProtocolName) - 2);

    RtlZeroMemory(DoReconnectData.AudioDriverName, sizeof(DoReconnectData.AudioDriverName));
    memcpy(DoReconnectData.AudioDriverName, m->AudioDriverName, sizeof(m->AudioDriverName) - 2);

    W32WinStationDumpReconnectInfo(m, TRUE);

    /*
     * Give the information to the WIN32 driver.
     */

    Status = (NTSTATUS)NtUserCallOneParam((ULONG_PTR)&DoReconnectData,
                                          SFI_XXXREMOTERECONNECT);

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "xxxRemoteReconnect failed with Status %lx", Status);
    } else {

        /*
         * Save the resolution
         */
        gHRes       = m->HRes;
        gVRes       = m->VRes;
        gColorDepth = m->ColorDepth;

#if DBG
        gulConnectCount++;
#endif // DBG
    }

    return Status;
}



NTSTATUS
W32WinStationDoNotify(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    DONOTIFYDATA                DoNotifyData;
    WINSTATIONDONOTIFYMSG*   m = &pMsg->u.DoNotify;

    switch (m->NotifyEvent) {
    case WinStation_Notify_DisableScrnSaver:
        DoNotifyData.NotifyEvent = Notify_DisableScrnSaver;
        break;

    case WinStation_Notify_EnableScrnSaver:
        DoNotifyData.NotifyEvent = Notify_EnableScrnSaver;
        break;

    case WinStation_Notify_Disconnect:

        DoNotifyData.NotifyEvent = Notify_Disconnect;
        break;

    case WinStation_Notify_SyncDisconnect:

        DoNotifyData.NotifyEvent = Notify_SyncDisconnect;
        break;

    case WinStation_Notify_Reconnect:

        DoNotifyData.NotifyEvent = Notify_Reconnect;
        break;

    case WinStation_Notify_PreReconnect:

       DoNotifyData.NotifyEvent = Notify_PreReconnect;
       break;

    case WinStation_Notify_PreReconnectDesktopSwitch:

       DoNotifyData.NotifyEvent = Notify_PreReconnectDesktopSwitch;
       break;

    case WinStation_Notify_HelpAssistantShadowStart:

       DoNotifyData.NotifyEvent = Notify_HelpAssistantShadowStart;
       break;

    case WinStation_Notify_HelpAssistantShadowFinish:

       DoNotifyData.NotifyEvent = Notify_HelpAssistantShadowFinish;
       break;

    case WinStation_Notify_DisconnectPipe:
        DoNotifyData.NotifyEvent = Notify_DisconnectPipe;
        break;

    default:
        RIPMSGF1(RIP_ERROR, "Unknown NotifyEvent 0x%x", m->NotifyEvent);
        return STATUS_INVALID_PARAMETER;
    }

    /*
     * Give the information to the WIN32 driver.
     */

    Status = (NTSTATUS)NtUserCallOneParam((ULONG_PTR)&DoNotifyData,
                                          SFI_XXXREMOTENOTIFY);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxRemoteNotify failed with Status %lx", Status);
    }

    return Status;
}



NTSTATUS
W32WinStationExitWindows(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    WINSTATIONEXITWINDOWSMSG*   m = &pMsg->u.ExitWindows;


    UserAssert(gulConnectCount <= 1);


    /*
     *  Cancel any existing ExitWindows call so that we can force logoff the user
     */
    CancelExitWindows();

    /*
     *  Tell winlogon to logoff
     */
    Status = (NTSTATUS)NtUserCallNoParam(SFI_REMOTELOGOFF);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteLogoff failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationTerminate(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE   hevtRitExited, hevtRitStuck, hevtShutDown;
    DONOTIFYDATA DoNotifyData;
    IO_STATUS_BLOCK IoStatus;

    UNREFERENCED_PARAMETER(pMsg);

    gbExitInProgress = TRUE;

    /*
     * Get rid of hard error thread.
     */
    if (gdwHardErrorThreadId != 0) {

        BoostHardError(-1, BHE_FORCE);

        /*
         * Poll (!!?) for hard error thread completion. The thread does
         * not exit.
         */
        while (gdwHardErrorThreadId != 0) {
            RIPMSG0(RIP_WARNING, "Waiting for hard error thread to stop...");

            Sleep(3 * 1000);
        }

        RIPMSG0(RIP_WARNING, "Stopped hard error thread");
    }

    if (g_hDoMessageEvent) {
        NtSetEvent(g_hDoMessageEvent, NULL);
    }

    /*
     * Give the information that we want to stop reading to the WIN32 driver.
     */

    DoNotifyData.NotifyEvent = Notify_StopReadInput;

    Status = (NTSTATUS)NtUserCallOneParam((ULONG_PTR)&DoNotifyData,
                                          SFI_XXXREMOTENOTIFY);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "W32WinStationTerminate : xxxRemoteNotify failed with Status %lx", Status);
    }


    if (G_IcaMouseChannel) {
        CloseHandle(G_IcaMouseChannel);
        G_IcaMouseChannel = NULL;
    }

    if (G_IcaKeyboardChannel) {
        CloseHandle(G_IcaKeyboardChannel);
        G_IcaKeyboardChannel = NULL;
    }

    // Instead send a IOCTL to termdd
    if (G_IcaCommandChannel) {

        Status = NtDeviceIoControlFile(
                    G_IcaCommandChannel,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL,
                    NULL,
                    0,
                    NULL,
                    0);
        CloseHandle(G_IcaCommandChannel);
        G_IcaCommandChannel = NULL;
    }

    if (G_IcaVideoChannel) {

        Status = NtDeviceIoControlFile(
                    G_IcaVideoChannel,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL,
                    NULL,
                    0,
                    NULL,
                    0);
        CloseHandle(G_IcaVideoChannel);
        G_IcaVideoChannel = NULL;
    }

    if (G_IcaBeepChannel) {
        CloseHandle(G_IcaBeepChannel);
        G_IcaBeepChannel = NULL;
    }
    if (G_IcaThinwireChannel) {
        CloseHandle(G_IcaThinwireChannel);
        G_IcaThinwireChannel = NULL;
    }

    hevtShutDown = OpenEvent(EVENT_ALL_ACCESS,
                             FALSE,
                             L"EventShutDownCSRSS");
    if (hevtShutDown == NULL) {
        /*
         * This case is for cached sessions where RIT and Destiop thread have
         * not been created.
         */
        RIPMSG0(RIP_WARNING, "W32WinStationTerminate terminating CSRSS ...");

        if (gLUIDDeviceMapsEnabled == 0) {

            Status = CleanupSessionObjectDirectories();

        }
        return 0;
    }

    hevtRitExited = CreateEvent(NULL,
                                FALSE,
                                FALSE,
                                L"EventRitExited");

    UserAssert(hevtRitExited != NULL);

    hevtRitStuck = CreateEvent(NULL,
                               FALSE,
                               FALSE,
                               L"EventRitStuck");

    UserAssert(hevtRitStuck != NULL);

    /*
     * RIT is created. Signal this event that starts the
     * cleanup in win32k.
     */
    SetEvent(hevtShutDown);

    TAGMSG0(DBGTAG_TermSrv, "EventShutDownCSRSS set in CSRSS ...");

    while (1) {
        HANDLE arHandles[2] = {hevtRitExited, hevtRitStuck};
        DWORD  result;

        result = WaitForMultipleObjects(2, arHandles, FALSE, INFINITE);

        switch (result) {
        case WAIT_OBJECT_0:
            goto RITExited;

        case WAIT_OBJECT_0 + 1:

            /*
             * The RIT is stuck because there are still GUI threads
             * assigned to desktops. One reason for this is that winlogon
             * died w/o calling ExitWindowsEx.
             */
            break;
        default:
            FRE_RIPMSG1(RIP_ERROR,
                    "WFMO returned unexpected value 0x%x",
                    result);
            break;
        }
    }

RITExited:

    TAGMSG0(DBGTAG_TermSrv, "EventRitExited set in CSRSS ...");

    CloseHandle(hevtRitExited);
    CloseHandle(hevtRitStuck);
    CloseHandle(hevtShutDown);

    Status = CleanupSessionObjectDirectories();
    return Status;
}


NTSTATUS
W32WinStationNtSecurity(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(pMsg);

    Status = (NTSTATUS)NtUserCallNoParam(SFI_REMOTENTSECURITY);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteNtSecurity failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationDoMessage(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = RemoteDoMessage(pMsg);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteDoMessage failed with Status %lx", Status);
    }

    return Status;
}

// This is different from W32WinStationDoMessage in that it loads the string and displays the message.
NTSTATUS
W32WinStationDoLoadStringNMessage(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status;

    Status = RemoteDoLoadStringNMessage(pMsg);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteDoLoadStringNMessage failed with Status %lx", Status);
    }

    return Status;
}

 // This is the counter part to SMWinStationBroadcastSystemMessage
NTSTATUS
W32WinStationBroadcastSystemMessage(
    PWINSTATION_APIMSG pMsg )
{
    NTSTATUS Status;

    Status = RemoteDoBroadcastSystemMessage(pMsg);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteDoBroadcastSystemMessage(): failed with status 0x%lx", Status);
    }

    return Status;
}
 // This is the counter part to SMWinStationSendWindowMessage
NTSTATUS
W32WinStationSendWindowMessage(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status;

    Status = RemoteDoSendWindowMessage(pMsg);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteDoSendWindowMessage failed with Status 0x%lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationThinwireStats(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status;
    WINSTATIONTHINWIRESTATSMSG* m = &pMsg->u.ThinwireStats;

    Status = (NTSTATUS)NtUserCallOneParam((ULONG_PTR)&m->Stats,
                                          SFI_REMOTETHINWIRESTATS);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteThinwireStats failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationShadowSetup(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status;
    WINSTATIONSHADOWSETUPMSG* m = &pMsg->u.ShadowSetup;

    Status = (NTSTATUS)NtUserCallNoParam(SFI_XXXREMOTESHADOWSETUP);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxRemoteShadowSetup failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationShadowStart(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status;
    WINSTATIONSHADOWSTARTMSG* m = &pMsg->u.ShadowStart;

    Status = (NTSTATUS)NtUserCallTwoParam((ULONG_PTR)m->pThinwireData,
                                          (ULONG_PTR)m->ThinwireDataLength,
                                          SFI_REMOTESHADOWSTART);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteShadowStart failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationShadowStop(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status;
    WINSTATIONSHADOWSTOPMSG* m = &pMsg->u.ShadowStop;

    Status = (NTSTATUS)NtUserCallNoParam(SFI_XXXREMOTESHADOWSTOP);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxRemoteShadowStop failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationShadowCleanup(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status;
    WINSTATIONSHADOWCLEANUPMSG* m = &pMsg->u.ShadowCleanup;

    Status = (NTSTATUS)NtUserCallTwoParam((ULONG_PTR)m->pThinwireData,
                                          (ULONG_PTR)m->ThinwireDataLength,
                                          SFI_REMOTESHADOWCLEANUP);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteShadowCleanup failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationPassthruEnable(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(pMsg);

    Status = (NTSTATUS)NtUserCallNoParam(SFI_XXXREMOTEPASSTHRUENABLE);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxRemotePassthruEnable failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationPassthruDisable(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(pMsg);

    Status = (NTSTATUS)NtUserCallNoParam(SFI_REMOTEPASSTHRUDISABLE);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemotePassthruDisable failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
CleanupSessionObjectDirectories(
    VOID)
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING    UnicodeString;
    HANDLE            LinkHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    BOOLEAN           RestartScan;
    UCHAR             DirInfoBuffer[ 4096 ];
    WCHAR             szSessionString [ MAX_SESSION_PATH ];
    ULONG             Context = 0;
    ULONG             ReturnedLength;
    HANDLE            DosDevicesDirectory;
    HANDLE            *HandleArray;
    ULONG             Size = 100;
    ULONG             i, Count = 0;

    swprintf(szSessionString,L"%ws\\%ld\\DosDevices",SESSION_ROOT,NtCurrentPeb()->SessionId);

    RtlInitUnicodeString(&UnicodeString, szSessionString);

    InitializeObjectAttributes(&Attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenDirectoryObject(&DosDevicesDirectory,
                                   DIRECTORY_ALL_ACCESS,
                                   &Attributes);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "NtOpenDirectoryObject failed with Status %lx", Status);
        return Status;
    }

Restart:
    HandleArray = (HANDLE *)LocalAlloc(LPTR, Size * sizeof(HANDLE));

    if (HandleArray == NULL) {

        NtClose(DosDevicesDirectory);
        return STATUS_NO_MEMORY;
    }

    RestartScan = TRUE;
    DirInfo = (POBJECT_DIRECTORY_INFORMATION)DirInfoBuffer;

    while (TRUE) {
        Status = NtQueryDirectoryObject(DosDevicesDirectory,
                                        (PVOID)DirInfo,
                                        sizeof(DirInfoBuffer),
                                        TRUE,
                                        RestartScan,
                                        &Context,
                                        &ReturnedLength);
        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }

            break;
        }

        if (!wcscmp(DirInfo->TypeName.Buffer, L"SymbolicLink")) {
            if (Count >= Size) {
                for (i = 0; i < Count; i++) {
                    NtClose(HandleArray[i]);
                }
                Size += 20;
                Count = 0;
                LocalFree(HandleArray);
                goto Restart;

            }

            InitializeObjectAttributes(&Attributes,
                                       &DirInfo->Name,
                                       OBJ_CASE_INSENSITIVE,
                                       DosDevicesDirectory,
                                       NULL);

            Status = NtOpenSymbolicLinkObject(&LinkHandle,
                                              SYMBOLIC_LINK_ALL_ACCESS,
                                              &Attributes);
            if (NT_SUCCESS(Status)) {
                Status = NtMakeTemporaryObject(LinkHandle);
                if (NT_SUCCESS(Status)) {
                    HandleArray[Count] = LinkHandle;
                    Count++;
                }
            }
        }

        RestartScan = FALSE;
    }

    for (i = 0; i < Count; i++) {
        NtClose (HandleArray[i]);
    }

    LocalFree(HandleArray);
    NtClose(DosDevicesDirectory);

    return Status;
}



NTSTATUS
W32WinStationSetTimezone(
    PWINSTATION_APIMSG pMsg)
{
     /*++

Routine Description:

   This function sets Time Zone Information as global shared data

Arguments:

    NONE

Return Value:

    NONE

--*/
    TIME_ZONE_INFORMATION tzi;

    tzi.Bias         = pMsg->u.SetTimeZone.TimeZone.Bias;
    tzi.StandardBias = pMsg->u.SetTimeZone.TimeZone.StandardBias;
    tzi.DaylightBias = pMsg->u.SetTimeZone.TimeZone.DaylightBias;
    memcpy(&tzi.StandardName,&(pMsg->u.SetTimeZone.TimeZone.StandardName),sizeof(tzi.StandardName));
    memcpy(&tzi.DaylightName,&(pMsg->u.SetTimeZone.TimeZone.DaylightName),sizeof(tzi.DaylightName));

    tzi.StandardDate.wYear         = pMsg->u.SetTimeZone.TimeZone.StandardDate.wYear;
    tzi.StandardDate.wMonth        = pMsg->u.SetTimeZone.TimeZone.StandardDate.wMonth;
    tzi.StandardDate.wDayOfWeek    = pMsg->u.SetTimeZone.TimeZone.StandardDate.wDayOfWeek;
    tzi.StandardDate.wDay          = pMsg->u.SetTimeZone.TimeZone.StandardDate.wDay;
    tzi.StandardDate.wHour         = pMsg->u.SetTimeZone.TimeZone.StandardDate.wHour;
    tzi.StandardDate.wMinute       = pMsg->u.SetTimeZone.TimeZone.StandardDate.wMinute;
    tzi.StandardDate.wSecond       = pMsg->u.SetTimeZone.TimeZone.StandardDate.wSecond;
    tzi.StandardDate.wMilliseconds = pMsg->u.SetTimeZone.TimeZone.StandardDate.wMilliseconds;

    tzi.DaylightDate.wYear         = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wYear;
    tzi.DaylightDate.wMonth        = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wMonth;
    tzi.DaylightDate.wDayOfWeek    = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wDayOfWeek;
    tzi.DaylightDate.wDay          = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wDay;
    tzi.DaylightDate.wHour         = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wHour;
    tzi.DaylightDate.wMinute       = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wMinute;
    tzi.DaylightDate.wSecond       = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wSecond;
    tzi.DaylightDate.wMilliseconds = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wMilliseconds;

    //call to kernel32
    SetClientTimeZoneInformation(&tzi);

    return STATUS_SUCCESS;
}


// 
// Create \\Globals\TermSrvReady event with security descriptor, where only system can
// set/reset it's state and others can wait on it. Create this event only in session 0.
//

HANDLE CreateTermSrvReadyEvent()
{
    NTSTATUS    Status;
    SID_IDENTIFIER_AUTHORITY SystemAuth = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    SECURITY_ATTRIBUTES SecurityAttributes;
    PSID pSystemSid = NULL;
    PSID pWorldSid = NULL;
    PSECURITY_DESCRIPTOR pSd = NULL;
    PACL pEventDacl;
    HANDLE hTermSrvReady = NULL;
    ULONG AclLength;

    // Allocate and Initialize the "System" Sid.
    Status = RtlAllocateAndInitializeSid( &SystemAuth,
                                          1,
                                          SECURITY_LOCAL_SYSTEM_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &pSystemSid );
    if (!NT_SUCCESS(Status)) {
        goto TermSrvReadyErr;
    }

    // Allocate and Initialize the "World" Sid.
    Status = RtlAllocateAndInitializeSid( &WorldAuth,
                                          1,
                                          SECURITY_WORLD_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &pWorldSid );
    if (!NT_SUCCESS(Status)) {
        goto TermSrvReadyErr;
    }

    // Allocate space for the security descriptor.
    AclLength = (ULONG)sizeof(ACL) +
                   (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                   RtlLengthSid( pSystemSid ) +
                   RtlLengthSid( pWorldSid ) +
                   8;       

    pSd = (PSECURITY_DESCRIPTOR) LocalAlloc(0, SECURITY_DESCRIPTOR_MIN_LENGTH + AclLength);
    if (pSd == NULL) {
        goto TermSrvReadyErr;
    }

    pEventDacl = (PACL) ((BYTE*)(pSd) + SECURITY_DESCRIPTOR_MIN_LENGTH);

    // Set up a new ACL with no ACE.
    Status = RtlCreateAcl(pEventDacl, AclLength, ACL_REVISION2);
    if (!NT_SUCCESS(Status)) {
        goto TermSrvReadyErr;
    }

    // WORLD access
    Status = RtlAddAccessAllowedAce( pEventDacl,
                                     ACL_REVISION2,
                                     SYNCHRONIZE,
                                     pWorldSid
                                   );
    if (!NT_SUCCESS(Status)) {
        goto TermSrvReadyErr;
    }

    // SYSTEM access
    Status = RtlAddAccessAllowedAce( pEventDacl,
                                     ACL_REVISION2,
                                     EVENT_MODIFY_STATE,
                                     pSystemSid
                                   );
    if (!NT_SUCCESS(Status)) {
        goto TermSrvReadyErr;
    }

    // Now initialize security descriptors that export this protection
    Status = RtlCreateSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION1);
    if (!NT_SUCCESS(Status)) {
        goto TermSrvReadyErr;
    }

    Status = RtlSetDaclSecurityDescriptor(pSd, TRUE, pEventDacl, FALSE);
    if (!NT_SUCCESS(Status)) {
        goto TermSrvReadyErr;
    }

    // Fill the Security Attributes
    ZeroMemory(&SecurityAttributes, sizeof(SecurityAttributes));
    SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttributes.lpSecurityDescriptor = pSd;
    SecurityAttributes.bInheritHandle = FALSE;

    // Now create TermSrvReady event with this security attributes.
    hTermSrvReady = CreateEventW(&SecurityAttributes, TRUE, FALSE, L"Global\\TermSrvReadyEvent");
    if (hTermSrvReady == NULL) {
        goto TermSrvReadyErr;
    }

    // Check if someone bad has already created this event for ill-purpose. 
    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        NtClose(hTermSrvReady);
        hTermSrvReady = NULL;
    }

TermSrvReadyErr:

    if (pSystemSid) {
        RtlFreeSid(pSystemSid);
    }

    if (pWorldSid) {
        RtlFreeSid(pWorldSid);
    }

    if (pSd) {
        LocalFree(pSd);
    }

    return hTermSrvReady;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\debug.c ===
/****************************** Module Header ******************************\
* Module Name: debug.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains random debugging related functions.
*
* History:
* 17-May-1991 DarrinM   Created.
* 22-Jan-1992 IanJa     ANSI/Unicode neutral (all debug output is ANSI)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/**************************************************************************\
* ActivateDebugger
*
* Force an exception on the active application's context so it will break
* into the debugger.
*
* History:
* 05-10-91 DarrinM      Created.
\***************************************************************************/

ULONG SrvActivateDebugger(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PACTIVATEDEBUGGERMSG a = (PACTIVATEDEBUGGERMSG)&m->u.ApiMessageData;
    PCSR_THREAD Thread;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(ReplyStatus);

    /*
     * If the process is CSR, break
     */
    if (a->ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) {
        DbgBreakPoint();
        return STATUS_SUCCESS;
    }

    /*
     * Impersonate the client if this is a user mode request.
     */
    if (m->h.u2.s2.Type == LPC_REQUEST) {
        if (!CsrImpersonateClient(NULL)) {
            return STATUS_UNSUCCESSFUL;
        }
    }

    /*
     * Lock the client thread
     */
    Status = CsrLockThreadByClientId(a->ClientId.UniqueThread, &Thread);
    if (NT_SUCCESS(Status)) {
        ASSERT(a->ClientId.UniqueProcess == Thread->ClientId.UniqueProcess);

        Status = DbgUiIssueRemoteBreakin (Thread->Process->ProcessHandle);

        UserAssert(NT_SUCCESS(Status));
        Status = NtAlertThread(Thread->ThreadHandle);
        UserAssert(NT_SUCCESS(Status));
        CsrUnlockThread(Thread);
    }

    /*
     * Stop impersonating the client.
     */
    if (m->h.u2.s2.Type == LPC_REQUEST) {
        CsrRevertToSelf();
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\exitwin.c ===
/**************************** Module Header ********************************\
* Module Name: exitwin.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 07-23-92 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <wchar.h>
#include <regstr.h>
#include <reason.h>

#define BEGIN_LPC_RECV(API)                                                 \
    P##API##MSG a = (P##API##MSG)&m->u.ApiMessageData;                      \
    PCSR_THREAD pcsrt;                                                      \
    PTEB Teb = NtCurrentTeb();                                              \
    NTSTATUS Status = STATUS_SUCCESS;                                       \
    UNREFERENCED_PARAMETER(ReplyStatus);                                    \
                                                                            \
    Teb->LastErrorValue = 0;                                                \
    pcsrt = CSR_SERVER_QUERYCLIENTTHREAD();

#define END_LPC_RECV()                                                  \
    a->dwLastError = Teb->LastErrorValue;                               \
    return Status;

#define CCHBODYMAX  512

#define CSR_THREAD_SHUTDOWNSKIP 0x00000008
#define CSR_THREAD_HANGREPORTED 0x00000010

/*
 * SrvRecordShutdownReason globals
 */
ULONG   g_ShutdownState;
ULONG   g_DirtyShutdownMax = 1;
HMODULE g_SnapShotDllHandle;
LONG    g_SnapShot = 1;

/*
 * Snapshot dll entry function.
 */
typedef ULONG (*SNAPSHOTFUNC)(DWORD dwStrings, LPCTSTR *lpStrings, PLONG MaxBuffSize, LPTSTR SnapShotBuff);

BOOL WowExitTask(PCSR_THREAD pcsrt);
NTSTATUS UserClientShutdown(PCSR_PROCESS pcsrp, ULONG dwFlags, BOOLEAN fFirstPass);
BOOL CancelExitWindows(VOID);

/***************************************************************************\
* _ExitWindowsEx
*
* Determines whether shutdown is allowed, and if so calls CSR to start
* shutting down processes. If this succeeds all the way through, tell winlogon
* so it'll either logoff or reboot the system. Shuts down the processes in
* the caller's sid.
*
* History
* 07-23-92 ScottLu      Created.
\***************************************************************************/
NTSTATUS _ExitWindowsEx(
    PCSR_THREAD pcsrt,
    UINT dwFlags)
{
    LUID luidCaller;
    NTSTATUS Status;

    if ((dwFlags & EWX_REBOOT) || (dwFlags & EWX_POWEROFF)) {
        dwFlags |= EWX_SHUTDOWN;
    }

    //
    // Only winlogon gets to set the high flags:
    //

    if ((dwFlags & ~EWX_VALID) != 0) {
        if (HandleToUlong(pcsrt->ClientId.UniqueProcess) != gIdLogon) {
            RIPMSG2(RIP_WARNING,
                    "Process 0x%x tried to call ExitWindowsEx with flags 0x%x",
                    pcsrt->ClientId.UniqueProcess,
                    dwFlags);

            return STATUS_ACCESS_DENIED;
        }
    }

    /*
     * Find out the callers sid. Only want to shutdown processes in the
     * callers sid.
     */
    if (!CsrImpersonateClient(NULL)) {
        return STATUS_BAD_IMPERSONATION_LEVEL;
    }

    Status = CsrGetProcessLuid(NULL, &luidCaller);
    if (!NT_SUCCESS(Status)) {
        CsrRevertToSelf();
        return Status;
    }

    /*
     * Loop until we can do the shutdown. If we cannot do it, we'll go to
     * fastexit and bail.
     */
    while (TRUE) {
        Status = NtUserSetInformationThread(pcsrt->ThreadHandle,
                                            UserThreadInitiateShutdown,
                                            &dwFlags, sizeof(dwFlags));

        switch (Status) {
        case STATUS_PENDING:
            /*
             * The logoff/shutdown is in progress and nothing more needs to
             * be done.
             */
            goto fastexit;

        case STATUS_RETRY:


            if (!CancelExitWindows()) {
               Status = STATUS_PENDING;
               goto fastexit;
            } else {
               continue;
            }

        case STATUS_CANT_WAIT:

            /*
             * There is no notify window and the calling thread has
             * windows that prevent this request from succeeding.
             * The client handles this by starting another thread
             * to recall ExitWindowsEx.
             */
            goto fastexit;

        default:
            if (!NT_SUCCESS(Status)) {
                SetLastError(RtlNtStatusToDosError(Status));
                goto fastexit;
            }
        }
        break;
    }

    /*
     * This thread is doing the shutdown
     */
    EnterCrit();
    UserAssert(gdwThreadEndSession == 0);
    gdwThreadEndSession = HandleToUlong(pcsrt->ClientId.UniqueThread);
    LeaveCrit();

    /*
     * Call csr to loop through the processes shutting them down.
     */
    Status = CsrShutdownProcesses(&luidCaller, dwFlags);
    if (Status == STATUS_CANCELLED && IsSETEnabled()) {
        SHUTDOWN_REASON sr;
        sr.cbSize = sizeof(SHUTDOWN_REASON);
        sr.uFlags = dwFlags;
        sr.dwReasonCode = 0;
        sr.fShutdownCancelled = TRUE;
        sr.dwEventType = SR_EVENT_EXITWINDOWS;
        sr.lpszComment = NULL;

        /*
         * Record the fact that the shutdown was cancelled.
         */
        RecordShutdownReason(&sr);
    }

    /*
     * Tell win32k.sys we're done.
     */
    NtUserSetInformationThread(pcsrt->ThreadHandle, UserThreadEndShutdown, &Status, sizeof(Status));

    EnterCrit();
    gdwThreadEndSession = 0;
    NtSetEvent(gheventCancelled, NULL);
    LeaveCrit();

fastexit:
    CsrRevertToSelf();

    return Status;
}

/***************************************************************************\
* UserClientShutdown
*
* This gets called from CSR. If we recognize the application (i.e., it has a
* top level window), then send queryend/end session messages to it. Otherwise
* say we don't recognize it.
*
* 07-23-92 ScottLu      Created.
\***************************************************************************/
NTSTATUS UserClientShutdown(
    PCSR_PROCESS pcsrp,
    ULONG dwFlags,
    BOOLEAN fFirstPass)
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_PROCESS Process;
    PCSR_THREAD Thread;
    USERTHREAD_SHUTDOWN_INFORMATION ShutdownInfo;
    BOOL fNoMsgs;
    BOOL fNoMsgsEver = TRUE;
    BOOL Forced = FALSE;
    BOOL bDoBlock;
    BOOL fNoRetry;
    DWORD cmd = 0, dwClientFlags;
    NTSTATUS Status;
    NTSTATUS TerminateStatus = STATUS_ACCESS_DENIED;
    UINT cThreads;
    BOOL fSendEndSession = FALSE;

#if DBG
    DWORD dwLocalThreadEndSession = gdwThreadEndSession;
#endif

    /*
     * If this is a logoff and the process does not belong to
     * the account doing the logoff and is not LocalSystem,
     * do not send end-session messages. Console will notify
     * the app of the logoff.
     */
    if (!(dwFlags & EWX_SHUTDOWN) && (pcsrp->ShutdownFlags & SHUTDOWN_OTHERCONTEXT)) {
        Status = SHUTDOWN_UNKNOWN_PROCESS;
        goto CleanupAndExit;
    }

    /*
     * Calculate whether to allow exit and force-exit this process before
     * we unlock pcsrp.
     */
    fNoRetry = (pcsrp->ShutdownFlags & SHUTDOWN_NORETRY) || (dwFlags & EWX_FORCE);

    /*
     * Setup flags for WM_CLIENTSHUTDOWN
     * -Assume the process is going to OK the WM_QUERYENDSESSION (WMCS_EXIT)
     * -NT's shutdown always starts with a logoff.
     * -Shutdown or logoff? (WMCS_SHUTDOWN)
     * -Should display dialog for hung apps? (WMCS_NODLGIFHUNG)
     * -is this process in the context being logged off? (WMCS_CONTEXTLOGOFF)
     */
    dwClientFlags = WMCS_EXIT | (fNoRetry ? WMCS_NORETRY : 0);

    /*
     * Check the flags originally passed by the ExitWindows caller to see if we're
     *  really just logging off.
     */
    if (!(dwFlags & (EWX_WINLOGON_OLD_REBOOT | EWX_WINLOGON_OLD_SHUTDOWN))) {
        dwClientFlags |= WMCS_LOGOFF;
    }

    if (dwFlags & EWX_FORCEIFHUNG) {
        dwClientFlags |= WMCS_NODLGIFHUNG;
    }
    if (!(pcsrp->ShutdownFlags & (SHUTDOWN_SYSTEMCONTEXT | SHUTDOWN_OTHERCONTEXT))) {
        dwClientFlags |= WMCS_CONTEXTLOGOFF;
    }


    /*
     * Lock the process while we walk the thread list. We know
     * that the process is valid and therefore do not need to
     * check the return status.
     */
    CsrLockProcessByClientId(pcsrp->ClientId.UniqueProcess, &Process);

    ShutdownInfo.StatusShutdown = SHUTDOWN_UNKNOWN_PROCESS;

    /*
     * Go through the thread list and mark them as not
     * shutdown yet.
     */
    ListHead = &pcsrp->ThreadList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
        Thread->Flags &= ~(CSR_THREAD_SHUTDOWNSKIP | CSR_THREAD_HANGREPORTED);
        ListNext = ListNext->Flink;
    }

    /*
     * Perform the proper shutdown operation on each thread. Keep
     * a count of the number of gui threads found.
     */
    cThreads = 0;
    ShutdownInfo.drdRestore.pdeskRestore = NULL;
    ShutdownInfo.drdRestore.hdeskNew = NULL;
    while (TRUE) {
        ListNext = ListHead->Flink;
        while (ListNext != ListHead) {
            Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
            /*
             * Skip the thread doing the shutdown. Assume that it's
             * ready.
             * gdwThreadEndSession shouldn't change while the shutdown
             *  is in progress; so this should be thread safe.
             */
            UserAssert(gdwThreadEndSession == dwLocalThreadEndSession);
            if (HandleToUlong(Thread->ClientId.UniqueThread) == gdwThreadEndSession) {
                Thread->Flags |= CSR_THREAD_SHUTDOWNSKIP;
            }

            if (!(Thread->Flags &
                    (CSR_THREAD_DESTROYED | CSR_THREAD_SHUTDOWNSKIP))) {
                break;
            }
            ListNext = ListNext->Flink;
        }

        if (ListNext == ListHead) {
            break;
        }

        Thread->Flags |= CSR_THREAD_SHUTDOWNSKIP;
        ShutdownInfo.dwFlags = dwClientFlags;

        CsrReferenceThread(Thread);
        CsrUnlockProcess(Process);

        Status = NtUserQueryInformationThread(Thread->ThreadHandle,
                                              UserThreadShutdownInformation,
                                              &ShutdownInfo,
                                              sizeof(ShutdownInfo),
                                              NULL);

        CsrLockProcessByClientId(pcsrp->ClientId.UniqueProcess, &Process);
        /*
         * When we release the process structure lock, Thread can go away.
         * Since we already ref'ed it, we're safe, but once we deref here
         * its ref count can go to zero and the memory will be freed, in
         * which case we must be careful not to touch it again.
         */
        if (CsrDereferenceThread(Thread) == 0) {
            continue;
        }

        if (!NT_SUCCESS(Status)) {
            continue;
        }

        if (ShutdownInfo.StatusShutdown == SHUTDOWN_UNKNOWN_PROCESS) {
            continue;
        }
        if (ShutdownInfo.StatusShutdown == SHUTDOWN_KNOWN_PROCESS) {
            CsrUnlockProcess(Process);
            Status = SHUTDOWN_KNOWN_PROCESS;
            goto RestoreDesktop;
        }

        /*
         * If this process is not in the account being logged off and it
         * is not on the windowstation being logged off, don't send
         * the end session messages.
         */
        if (!(dwClientFlags & WMCS_CONTEXTLOGOFF) && (ShutdownInfo.hwndDesktop == NULL)) {
            /*
             * This process is not in the context being logged off. Do
             * not terminate it and let console send an event to the process.
             */
            ShutdownInfo.StatusShutdown = SHUTDOWN_UNKNOWN_PROCESS;
            continue;
        }

        /*
         * Shut down this process.
         */
        cThreads++;

        if (ISTS()) {
            Forced = (dwFlags & EWX_FORCE);
            fNoMsgs =  (pcsrp->ShutdownFlags & SHUTDOWN_NORETRY) ||
                       !(ShutdownInfo.dwFlags & USER_THREAD_GUI);
            fNoMsgsEver &= fNoMsgs;
            if (Forced && (!(dwFlags & EWX_NONOTIFY) || (gSessionId != 0)))  {
                dwClientFlags &= ~WMCS_LOGOFF; // WinStation Reset or Shutdown. Don't do this for console session.
            }

            if (fNoMsgs || Forced) {
                BoostHardError((ULONG_PTR)Thread->ClientId.UniqueProcess, BHE_FORCE);
            }
            bDoBlock = (fNoMsgs == FALSE);

        } else {
            if (fNoRetry || !(ShutdownInfo.dwFlags & USER_THREAD_GUI)) {

                /*
                 * Dispose of any hard errors.
                 */
                BoostHardError((ULONG_PTR)Thread->ClientId.UniqueProcess, BHE_FORCE);
                bDoBlock = FALSE;
            } else {
                bDoBlock = TRUE;
            }
        }

        if (bDoBlock) {
            CsrReferenceThread(Thread);
            CsrUnlockProcess(Process);

            /*
             * There are problems in changing shutdown to send all the
             * QUERYENDSESSIONs at once before doing any ENDSESSIONs, like
             * Windows does. The whole machine needs to be modal if you do this.
             * If it isn't modal, then you have this problem. Imagine app 1 and 2.
             * 1 gets the queryendsession, no problem. 2 gets it and brings up a
             * dialog. Now being a simple user, you decide you need to change the
             * document in app 1. Now you switch back to app 2, hit ok, and
             * everything goes away - including app 1 without saving its changes.
             * Also, apps expect that once they've received the QUERYENDSESSION,
             * they are not going to get anything else of any particular interest
             * (unless it is a WM_ENDSESSION with FALSE). We had bugs pre 511 where
             * apps were blowing up because of this.
             * If this change is made, the entire system must be modal
             * while this is going on. - ScottLu 6/30/94
             */
            cmd = ThreadShutdownNotify(dwClientFlags | WMCS_QUERYEND, (ULONG_PTR)Thread, 0);

            CsrLockProcessByClientId(pcsrp->ClientId.UniqueProcess, &Process);
            CsrDereferenceThread(Thread);

            /*
             * If shutdown has been cancelled, let csr know about it.
             */
            switch (cmd) {
            case TSN_USERSAYSCANCEL:
            case TSN_APPSAYSNOTOK:
                if (!Forced) {
                    dwClientFlags &= ~WMCS_EXIT;
                }

                /*
                 * Fall through.
                 */
            case TSN_APPSAYSOK:
                fSendEndSession = TRUE;
                break;

            case TSN_USERSAYSKILL:
                /*
                 * Since we cannot just kill one thread, the whole process
                 *  is going down. Hence, there is no point on continuing
                 *  checking other threads. Also, the user wants it killed
                 *  so we won't waste any time sending more messages
                 */
                dwClientFlags |= WMCS_EXIT;
                goto KillIt;

            case TSN_NOWINDOW:
                /*
                 * Did this process have a window?
                 * If this is the second pass we terminate the process even if it did
                 * not have any windows in case the app was just starting up.
                 * WOW hits this often because it takes so long to start up.
                 * Logon (with WOW auto-starting) then logoff WOW won't die but will
                 * lock some files open so you can't logon next time.
                 */
                if (fFirstPass) {
                    cThreads--;
                }
                break;
            }
        }
    }

    /*
     * If end session message need to be sent, do it now.
     */
    if (fSendEndSession) {

        /*
         * Go through the thread list and mark them as not
         * shutdown yet.
         */
        ListNext = ListHead->Flink;
        while (ListNext != ListHead) {
            Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
            Thread->Flags &= ~(CSR_THREAD_SHUTDOWNSKIP | CSR_THREAD_HANGREPORTED);
            ListNext = ListNext->Flink;
        }

        /*
         * Perform the proper shutdown operation on each thread.
         */
        while (TRUE) {
            ListHead = &pcsrp->ThreadList;
            ListNext = ListHead->Flink;
            while (ListNext != ListHead) {
                Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
                if (!(Thread->Flags &
                        (CSR_THREAD_DESTROYED | CSR_THREAD_SHUTDOWNSKIP))) {
                    break;
                }
                ListNext = ListNext->Flink;
            }
            if (ListNext == ListHead)
                break;

            CsrReferenceThread(Thread);
            CsrUnlockProcess(Process);

            Thread->Flags |= CSR_THREAD_SHUTDOWNSKIP;
            ShutdownInfo.dwFlags = dwClientFlags;

            Status = NtUserQueryInformationThread(Thread->ThreadHandle,
                    UserThreadShutdownInformation, &ShutdownInfo, sizeof(ShutdownInfo), NULL);

            if (!NT_SUCCESS(Status))
                goto SkipThread;

            if (ShutdownInfo.StatusShutdown == SHUTDOWN_UNKNOWN_PROCESS ||
                    !(ShutdownInfo.dwFlags & USER_THREAD_GUI))
                goto SkipThread;

            /*
             * Send the end session messages to the thread.
             */

            /*
             * If the user says kill it, the user wants it to go away now
             * no matter what. If the user didn't say kill, then call again
             * because we need to send WM_ENDSESSION messages.
             */
            ThreadShutdownNotify(dwClientFlags, (ULONG_PTR)Thread, 0);

SkipThread:
            CsrLockProcessByClientId(pcsrp->ClientId.UniqueProcess, &Process);
            CsrDereferenceThread(Thread);
        }
    }

KillIt:
    CsrUnlockProcess(Process);

    if (ISTS()) {
        bDoBlock = (!fNoMsgsEver && !(dwClientFlags & WMCS_EXIT));
    } else {
        bDoBlock = (!fNoRetry && !(dwClientFlags & WMCS_EXIT));
    }

    if (bDoBlock) {
        Status = SHUTDOWN_CANCEL;
        goto RestoreDesktop;
    }

    /*
     * Set the final shutdown status according to the number of gui
     * threads found. If the count is zero, we have an unknown process.
     */
    if (cThreads == 0)
        ShutdownInfo.StatusShutdown = SHUTDOWN_UNKNOWN_PROCESS;
    else
        ShutdownInfo.StatusShutdown = SHUTDOWN_KNOWN_PROCESS;

    if (ShutdownInfo.StatusShutdown == SHUTDOWN_UNKNOWN_PROCESS ||
            !(dwClientFlags & WMCS_CONTEXTLOGOFF)) {

        /*
         * This process is not in the context being logged off. Do
         * not terminate it and let console send an event to the process.
         */
        Status = SHUTDOWN_UNKNOWN_PROCESS;

        if (ShutdownInfo.drdRestore.hdeskNew) {
            goto RestoreDesktop;
        }
        goto CleanupAndExit;
    }

    /*
     * Calling ExitProcess() in the app's context will not always work
     * because the app may have .dll termination deadlocks: so the thread
     * will hang with the rest of the process. To ensure apps go away,
     * we terminate the process with NtTerminateProcess().
     *
     * Pass this special value, DBG_TERMINATE_PROCESS, which tells
     * NtTerminateProcess() to return failure if it can't terminate the
     * process because the app is being debugged.
     */

    if (ISTS()) {
        NTSTATUS ExitStatus;
        HANDLE DebugPort;

        ExitStatus = DBG_TERMINATE_PROCESS;
        if (NT_SUCCESS(NtQueryInformationProcess(NtCurrentProcess(),
                                                 ProcessDebugPort,
                                                 &DebugPort,
                                                 sizeof(HANDLE),
                                                 NULL)) &&
            (DebugPort != NULL)) {
            // Csr is being debugged - go ahead and kill the process
            ExitStatus = 0;
        }
        TerminateStatus = NtTerminateProcess(pcsrp->ProcessHandle, ExitStatus);
    } else {
        TerminateStatus = NtTerminateProcess(pcsrp->ProcessHandle, DBG_TERMINATE_PROCESS);
    }

    pcsrp->Flags |= CSR_PROCESS_TERMINATED;


    /*
     * Let csr know we know about this process - meaning it was our
     * responsibility to shut it down.
     */
    Status = SHUTDOWN_KNOWN_PROCESS;

RestoreDesktop:

    /*
     * Release the desktop that was used.
     */
    {
        USERTHREAD_USEDESKTOPINFO utudi;
        utudi.hThread = NULL;
        RtlCopyMemory(&(utudi.drdRestore), &(ShutdownInfo.drdRestore), sizeof(DESKRESTOREDATA));

        NtUserSetInformationThread(NtCurrentThread(), UserThreadUseDesktop,
                &utudi, sizeof(utudi));
    }

    /*
     * Now that we're done with the process handle, derefence the csr
     * process structure.
     */
    if (Status != SHUTDOWN_UNKNOWN_PROCESS) {

        /*
         * If TerminateProcess returned STATUS_ACCESS_DENIED, then the process
         * is being debugged and it wasn't terminated.Otherwise we need to wait
         * anyway since TerminateProcess might return failure when the process
         * is going away (ie STATUS_PROCESS_IS_TERMINATING).If termination
         * indeed fail, something is wrong anyway so waiting a bit won't
         * hurt much.
         * If we wait give the process whatever exit timeout value configured
         * in the registry, but no less  than the 5 second Hung App timeout.

         */
        if (TerminateStatus != STATUS_ACCESS_DENIED) {
            LARGE_INTEGER li;

            li.QuadPart = (LONGLONG)-10000 * gdwProcessTerminateTimeout;
            TerminateStatus = NtWaitForSingleObject(pcsrp->ProcessHandle,
                                           FALSE,
                                           &li);
            if (TerminateStatus != STATUS_WAIT_0) {
                RIPMSG2(RIP_WARNING,
                        "UserClientShutdown: wait for process %x failed with status %x",
                        pcsrp->ClientId.UniqueProcess, TerminateStatus);
            }
        }

        CsrDereferenceProcess(pcsrp);
    }


CleanupAndExit:

    return Status;
}

/***************************************************************************\
* WMCSCallback
*
* This function is passed to SendMessageCallback when sending the
*  WM_CLIENTSHUTDOWN message. It propagates the return value back
*  if ThreadShutdownNotify is still waiting for it; otherwise,
*  it just frees the memory.
*
* 03-04-97 GerardoB     Created.
\***************************************************************************/
VOID CALLBACK WMCSCallback(
    HWND hwnd,
    UINT uMsg,
    ULONG_PTR dwData,
    LRESULT lResult)
{
    PWMCSDATA pwmcsd = (PWMCSDATA)dwData;

    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(uMsg);

    if (pwmcsd->dwFlags & WMCSD_IGNORE) {
        LocalFree(pwmcsd);
        return;
    }

    pwmcsd->dwFlags |= WMCSD_REPLY;
    pwmcsd->dwRet = (DWORD)lResult;
}

/***************************************************************************\
* GetInputWindow
*
* We assume a thread is waiting for input if it's not hung, the (main)
* window is disabled, and it owns an enabled popup.
*
* 03-06-97 GerardoB     Created.
\***************************************************************************/
HWND GetInputWindow(
    PCSR_THREAD pcsrt,
    HWND hwnd)
{
    DWORD dwTimeout;
    HWND hwndPopup;

    /*
     * Ask the kernel if the thread is hung.
     */
    dwTimeout = gCmsHungAppTimeout;
    NtUserQueryInformationThread(pcsrt->ThreadHandle,
       UserThreadHungStatus, &dwTimeout, sizeof(dwTimeout), NULL);

    /*
     * If not hung and disabled, see if it owns an enabled popup.
     */
    if (!dwTimeout && !IsWindowEnabled(hwnd)) {
        hwndPopup = GetWindow(hwnd, GW_ENABLEDPOPUP);
        if (hwndPopup != NULL && hwndPopup != hwnd) {
            return hwndPopup;
        }
    }

    return NULL;
}

/***************************************************************************\
* GetApplicationText
*
* Gets the text that identifies the given window or thread
*
* 08-01-97 GerardoB     Created.
\***************************************************************************/
VOID GetApplicationText(
    HWND hwnd,
    HANDLE hThread,
    WCHAR *pwcText,
    UINT uLen)
{
    /*
     * GetWindowText doesn't call the hwnd's proc; otherwise, we could
     * get blocked here for good.
     */
    GetWindowText(hwnd, pwcText, uLen);

    if (*pwcText == 0) {
        /*
         * We couldn't get the window's title; let's try the thread's name.
         */
        NtUserQueryInformationThread(hThread, UserThreadTaskName,
                                     pwcText, uLen * sizeof(WCHAR), NULL);
    }
}

/***************************************************************************\
* ReportHang
*
* This function launches an intermediate app (dumprep.exe) which packages up
* the hang information & ships it up to MS. We create an event and wait on
* it so that we know when the minidump information has been grabbed from the
* app.
*
* 08-31-00 DerekM       Created
\***************************************************************************/
VOID ReportHang(
    CLIENT_ID *pcidToKill)
{
    PROCESS_SESSION_INFORMATION psi;
    SECURITY_ATTRIBUTES         sa;
    SECURITY_DESCRIPTOR         sd;
    PCSR_THREAD                 pcsrt = CSR_SERVER_QUERYCLIENTTHREAD();
    NTSTATUS                    Status;
    HANDLE                      rghWait[2] = { NULL, NULL };
    HANDLE                      hProc = NULL;
    WCHAR                       wszEvent[MAX_PATH], *pwszSuffix;
    DWORD                       dw, dwTimeout, dwStartWait;
    BOOL                        fIs64Bit = FALSE;
#ifdef _WIN64
    ULONG_PTR                   Wow64Info = 0;
    HANDLE                      hProcKill = NULL;
#endif

#if defined(_DEBUG) || defined(DEBUG)
    dwTimeout = 600000; // 10 minutes
#else
    dwTimeout = 120000; //  2 minutes
#endif

    // we're going to launch dwwin in the context of the interactive user that
    //  is logged on to the killing process's session. So we need to figure out
    //  what session it's in.
    // If any of these fail, we have to bail cuz otherwise we'd have to create
    // an instance of dwwin.exe in local system context, and since dwwin.exe
    // can launch helpcenter, this is bad.
    hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE,
                        HandleToLong(pcsrt->ClientId.UniqueProcess));
    if (hProc == NULL) {
        RIPMSG2(RIP_WARNING,
                "HangReporting: Couldn't open killing process (pid: %d) (err: %08x)\n",
                HandleToLong(pcsrt->ClientId.UniqueProcess), GetLastError());
        goto done;
    }

    Status = NtQueryInformationProcess(hProc, ProcessSessionInformation, &psi,
                                       sizeof(psi), NULL);
    if (NT_SUCCESS(Status) == FALSE) {
        RIPMSG2(RIP_WARNING,
                "HangReporting: Couldn't get the session ID (pid: %d) (err: %08x)\n",
                HandleToLong(pcsrt->ClientId.UniqueProcess),
                RtlNtStatusToDosError(Status));
        goto done;
    }

#ifdef _WIN64
    // need to determine if we're a Wow64 process so we can build the appropriate
    //  signatures...
    hProcKill = OpenProcess(PROCESS_ALL_ACCESS, FALSE,
                            HandleToLong(pcidToKill->UniqueProcess));
    if (hProcKill == NULL) {
        RIPMSG2(RIP_WARNING,
                "HangReporting: Couldn't open dying process (pid: %d) (err: %08x)\n",
                HandleToLong(pcidToKill->UniqueProcess), GetLastError());
        goto done;
    }

    Status = NtQueryInformationProcess(hProcKill, ProcessWow64Information,
                                       &Wow64Info, sizeof(Wow64Info), NULL);
    if (NT_SUCCESS(Status) == FALSE) {
        RIPMSG2(RIP_WARNING,
                "HangReporting: Couldn't get Wow64 info (pid: %d) (err: %08x)\n",
                HandleToLong(pcidToKill->UniqueProcess),
                RtlNtStatusToDosError(Status));
        goto done;
    }

    fIs64Bit = (Wow64Info == 0);
#endif

    // Because of a bug where CreateProcessAsUser doesn't want to work from
    // the csrss process, we have to have a remote process sitting around
    // waiting on a pipe. It will call CreateProcessAsUser (as well as
    // determine the correct token for the session).
    //
    // Note that it only accepts requests from processes running as local
    // system.

    // Since a remote process does the creation of dumprep.exe, we need to
    // used a named event instead of relying on dumprep to inherit the event
    // handle.
    dw = swprintf(wszEvent, L"Global\\%d%x%x%x%x%x", psi.SessionId,
                  GetTickCount(), HandleToLong(pcsrt->ClientId.UniqueProcess),
                  HandleToLong(pcsrt->ClientId.UniqueThread),
                  HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
                  HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread));
    pwszSuffix = wszEvent + dw;

    // make sure to create this event with a NULL DACL so a generic usermode
    // process has access to it.
    Status = RtlCreateSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    if (NT_SUCCESS(Status) == FALSE) {
        RIPMSG1(RIP_WARNING, "HangReporting: could not create SD (err: %08x)\n",
                RtlNtStatusToDosError(Status));
        goto done;
    }

    // This is implemented in reclient.h & creates a SD with creator &
    // LocalSystem having full rights & world & anonymous having sync
    // rights.
    Status = AllocDefSD(&sd,
                        STANDARD_RIGHTS_ALL | GENERIC_ALL | EVENT_ALL_ACCESS,
                        EVENT_MODIFY_STATE | SYNCHRONIZE | GENERIC_READ);
    if (NT_SUCCESS(Status) == FALSE) {
        RIPMSG1(RIP_WARNING, "HangReporting: could not create SD (err: %08x)\n",
                RtlNtStatusToDosError(Status));
        goto done;
    }

    ZeroMemory(&sa, sizeof(sa));
    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;

    // Need an event so we know when the app we're killing is no longer
    // necessary. If the event already exists, try to create a new one.
    // But only do this a maximum of 7 times.
    for (dw = 0; dw < 7; dw++) {
        rghWait[0] = CreateEventW(&sa, TRUE, FALSE, wszEvent);
        if (rghWait[0] == NULL) {
            RIPMSG1(RIP_WARNING,
                    "HangReporting: Error creating wait event (err: %08x)\n",
                    GetLastError());
            goto done;
        }

        if (GetLastError() != ERROR_ALREADY_EXISTS) {
            break;
        }

        // Sleep for a millisecond to make the result of GetTickCount() even
        // more unpredictable...
        Sleep(1);
        _ltow(GetTickCount(), pwszSuffix, 16);
    }

    if (dw >= 7) {
        RIPMSG0(RIP_WARNING, "HangReporting: Could not find unique wait event name\n");
        goto done;
    }

    FreeDefSD(&sd);

    if (StartHangReport(psi.SessionId, wszEvent,
                        HandleToLong(pcidToKill->UniqueProcess),
                        HandleToLong(pcidToKill->UniqueThread),
                        fIs64Bit, &rghWait[1]) == FALSE)
    {
        RIPMSG1(RIP_WARNING,
                "HangReporting: StartHangReport failed (err: %08x)\n",
                GetLastError());
        goto done;
    }

    // use MsgWaitForMultipleObjects in case this thread is doing UI processing
    //  Not really likely, but you never know.  Anyway, only wait 2 minutes for
    //  dumprep to generate the minidump.  If it still hasn't done it by then,
    //  it isn't likely to ever finish.
    dwStartWait = GetTickCount();
    for (;;)
    {
        dw = MsgWaitForMultipleObjects(2, rghWait, FALSE, dwTimeout, QS_ALLINPUT);
        if (dw == WAIT_OBJECT_0 + 2)
        {
            DWORD   dwNow;
            DWORD   dwSub;
            MSG     msg;

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            dwNow = GetTickCount();
            if (dwNow < dwStartWait)
                dwSub = ((DWORD)-1 - dwStartWait) + dwNow;
            else
                dwSub = dwNow - dwStartWait;

            if (dwSub > dwTimeout)
                dwTimeout = 0;
            else
                dwTimeout -= dwSub;

            continue;
        }

        break;
    }

done:
#ifdef _WIN64
    if (hProcKill != NULL) {
        CloseHandle(hProcKill);
    }
#endif
    if (hProc != NULL) {
        CloseHandle(hProc);
    }
    if (rghWait[0] != NULL) {
        CloseHandle(rghWait[0]);
    }
    if (rghWait[1] != NULL) {
        CloseHandle(rghWait[1]);
    }
}

/***************************************************************************\
* ThreadShutdownNotify
*
* This function notifies a given thread that it's time (or about time)
* to go away. This is called from _EndTask to post the WM_CLOSE message
* or from UserClientShutdown to send the WM_QUERYENDSESSION and
* WM_ENDSESSION messages. If the thread fails to respond, then the
* "End Application" dialog is brought up. This function is also called
* from Console to display that dialog too.
*
* 03-07-97 GerardoB     Created to replace SendShutdownMessages,
*                       MySendEndSessionMessages and DoEndTaskDialog
* 08-15-00 JasonSch     Added code to limit number of CSRSS worker threads
*                       stuck in _EndTask to 8.
\***************************************************************************/
DWORD ThreadShutdownNotify(
    DWORD dwClientFlags,
    ULONG_PTR dwThread,
    LPARAM lParam)
{
    HWND hwnd, hwndOwner, hwndDlg;
    PWMCSDATA pwmcsd = NULL;
    ENDDLGPARAMS edp;
    DWORD dwRet, dwRealTimeout, dwTimeout, dwStartTiming, dwCmd;
    MSG msg;
    PCSR_THREAD pcsrt;
    HANDLE hThread;
    BOOL fEndTaskNow = FALSE;
    static DWORD dwTSNThreads = 0;

#define ESMH_CANCELEVENT     0
#define ESMH_THREAD          1
#define ESMH_HANDLECOUNT     2
    HANDLE ahandles[ESMH_HANDLECOUNT];

    if (dwTSNThreads > TSN_MAX_THREADS) {
        /*
         * If we've already reached our limit in terms of CSRSS threads stuck
         * in this function, "fail" this call.
         */
        return TSN_USERSAYSCANCEL;
    }

    /*
     * If this is console, just set up the wait loop and
     * bring the dialog up right away. Otherwise, find
     * the notification window, notify it, and go wait.
     */
    if (dwClientFlags & WMCS_CONSOLE) {
        hThread = (HANDLE)dwThread;
        dwRealTimeout = 0;
        goto SetupWaitLoop;
    } else {
        pcsrt = (PCSR_THREAD)dwThread;
        hThread = pcsrt->ThreadHandle;
        hwnd = (HWND)lParam;
    }

    /*
     * If no window was provided, find a top-level window owned by the thread.
     */
    if (hwnd == NULL) {
        EnumThreadWindows(HandleToUlong(pcsrt->ClientId.UniqueThread),
                          &FindWindowFromThread,
                          (LPARAM)&hwnd);
        if (hwnd == NULL) {
            return TSN_NOWINDOW;
        }
    }

    /*
     * Find the root owner (we'll guess this is the "main" window).
     */
    while ((hwndOwner = GetWindow(hwnd, GW_OWNER)) != NULL) {
        hwnd = hwndOwner;
    }

#ifdef FE_IME
    /*
     * If this is a console window, then just returns TSN_APPSAYSOK.
     * In this routine:
     * Normally windows NT environment, hwnd never point to console window.
     * However, In ConIme process, its owner window point to console window.
     */
    if (!(dwClientFlags & WMCS_ENDTASK)) {
        if ((HANDLE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE) == ghModuleWin) {
            return TSN_APPSAYSOK;
        }
    }
#endif // FE_IME

    /*
     * If this is an EndTask request but the window is disabled,
     * then we want to bring the dialog up right way (the app
     * is probably waiting for input).
     *
     * Otherwise, we bring the window to the foreground, send/post
     * the request and wait.
     */


    /*
     * Make sure we respond to the user ASAP when they attempt to shutdown
     * an application that we know is hung.
     */
    if ((dwClientFlags & WMCS_ENDTASK)) {
        dwTimeout = gCmsHungAppTimeout;
        NtUserQueryInformationThread(pcsrt->ThreadHandle, UserThreadHungStatus, &dwTimeout, sizeof(dwTimeout), NULL);

        if (!IsWindowEnabled(hwnd) || dwTimeout) {
            dwRealTimeout = 0;
            fEndTaskNow = TRUE;
        }
    }

    if (!fEndTaskNow) {
        SetForegroundWindow(hwnd);
        dwRealTimeout = gCmsHungAppTimeout;
        if (dwClientFlags & WMCS_ENDTASK) {
            PostMessage(hwnd, WM_CLOSE, 0, 0);
        } else {
            /*
             * If the shutdown was canceled, we don't need to wait
             * (we're just sending the WM_ENDSESSION(FALSE)).
             */
            if (!(dwClientFlags & (WMCS_QUERYEND | WMCS_EXIT))) {
                SendNotifyMessage(hwnd, WM_CLIENTSHUTDOWN, dwClientFlags, 0);
                return TSN_APPSAYSOK;
            }

            /*
             * Allocate callback data. If out of memory, kill it.
             */
            pwmcsd = (PWMCSDATA)LocalAlloc(LPTR, sizeof(WMCSDATA));
            if (pwmcsd == NULL) {
                return TSN_USERSAYSKILL;
            }

            SendMessageCallback(hwnd, WM_CLIENTSHUTDOWN, dwClientFlags, 0,
                                WMCSCallback, (ULONG_PTR)pwmcsd);
        }
    }

SetupWaitLoop:
    /*
     * This thread is now officially going to be "stuck" in TSN. Increment our
     * count of threads so disposed.
     */
    ++dwTSNThreads;

    /*
     * This tells us if the hwndDlg is valid. This is set/cleared by EndTaskDlgProc.
     */
    ZeroMemory(&edp, sizeof(edp));
    edp.dwFlags = EDPF_NODLG;

    /*
     * Loop until the hwnd replies, the request is canceled
     * or the thread goes away. If it times out, bring up the
     * dialog and wait until the user tells us what to do.
     */
    *(ahandles + ESMH_CANCELEVENT) = gheventCancel;
    *(ahandles + ESMH_THREAD) = hThread;
    dwStartTiming = GetTickCount();
    dwCmd = 0;
    while (dwCmd == 0) {
        /*
         * Calculate how long we have to wait.
         */
        dwTimeout = dwRealTimeout;
        if ((dwTimeout != 0) && (dwTimeout != INFINITE)) {
            dwTimeout -= (GetTickCount() - dwStartTiming);
            if ((int)dwTimeout < 0) {
                dwTimeout = 0;
            }
        }

        dwRet = MsgWaitForMultipleObjects(ESMH_HANDLECOUNT, ahandles, FALSE, dwTimeout, QS_ALLINPUT);

        switch (dwRet) {
            case WAIT_OBJECT_0 + ESMH_CANCELEVENT:
                /*
                 * The request has been canceled.
                 */
                dwCmd = TSN_USERSAYSCANCEL;
                break;

            case WAIT_OBJECT_0 + ESMH_THREAD:
                /*
                 * The thread is gone.
                 */
                dwCmd = TSN_APPSAYSOK;
                break;

            case WAIT_OBJECT_0 + ESMH_HANDLECOUNT:
                /*
                 * We got some input; process it.
                 */
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    if ((edp.dwFlags & EDPF_NODLG)
                            || !IsDialogMessage(hwndDlg, &msg)) {

                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }

                /*
                 * If we got a reply to the message, act on it
                 */
                if (pwmcsd != NULL && (pwmcsd->dwFlags & WMCSD_REPLY)) {

                    switch (pwmcsd->dwRet) {
                        default:
                            /*
                             * If the message was not processed (the thread
                             * exited) or someone processed it and returned
                             * a bogus value, just shut them down.
                             *
                             * Fall through.
                             */
                        case WMCSR_ALLOWSHUTDOWN:
                            /*
                             * We're going to nuke this app, so get rid of
                             * any pending harderror boxes he might have.
                             */
                            BoostHardError((ULONG_PTR)pcsrt->ClientId.UniqueProcess, BHE_FORCE);
                            /*
                             * Fall through.
                             */
                        case WMCSR_DONE:
                            dwCmd = TSN_APPSAYSOK;
                            break;

                        case WMCSR_CANCEL:
                            dwCmd = TSN_APPSAYSNOTOK;
                            break;
                    }
                }
                /*
                 * Else if the dialog is still up, keep waiting for the user
                 *  to tell us what to do
                 */
                else if (!(edp.dwFlags & EDPF_NODLG)) {
                    break;
                }
                /*
                 * Else if the user dismissed the dialog, act on his response
                 */
                else if (edp.dwFlags & EDPF_RESPONSE) {
                    switch(edp.dwRet) {
                        case IDC_ENDNOW:
                            /*
                             * The user wants us to kill it
                             */
                            dwCmd = TSN_USERSAYSKILL;
                            if ((dwClientFlags & WMCS_ENDTASK) != 0 &&
                                (edp.dwFlags & EDPF_HUNG) != 0) {
                                THREAD_BASIC_INFORMATION tbi;
                                CLIENT_ID *pcidToKill = NULL;

                                if ((dwClientFlags & WMCS_CONSOLE) != 0) {
                                    if (NtQueryInformationThread(hThread,
                                                                 ThreadBasicInformation,
                                                                 &tbi,
                                                                 sizeof(tbi),
                                                                 NULL) == STATUS_SUCCESS) {
                                        pcidToKill = &(tbi.ClientId);
                                    }
                                } else {
                                    pcidToKill = &(pcsrt->ClientId);
                                }

                                if (pcidToKill != NULL) {
                                    if (!(pcsrt->Flags & CSR_THREAD_HANGREPORTED))
                                    {
                                        // insure that we only call this ONCE
                                        pcsrt->Flags |= CSR_THREAD_HANGREPORTED;
                                        ReportHang(pcidToKill);
                                    }
                                }
                            }
                            break;

                        /* case IDCANCEL: */
                        default:
                            dwCmd = TSN_USERSAYSCANCEL;
                            break;
                    }
                }
                break;

            case WAIT_TIMEOUT:
                if (dwClientFlags & WMCS_NORETRY) {

                    /*
                     * We come here only for Terminal Server case. We return
                     * TSN_APPSAYSOK as Terminal Server 4 did in this case.
                     */
                    UserAssert(ISTS());

                    dwCmd = TSN_APPSAYSOK;
                    break;
                }


                /*
                 * Once we time out, we bring up the dialog and let
                 * its timer take over.
                 */
                dwRealTimeout = INFINITE;
                /*
                 * Check if the windows app is waiting for input;
                 * if not, we assume it is hung for EndTask. Otherwise,
                 * we enter a wait mode that brings the dialog up just
                 * to provide some (waiting) feedback. Console just gets
                 * the dialog right away.
                 */
                if (!(dwClientFlags & WMCS_CONSOLE)) {
                    if (BoostHardError((ULONG_PTR)pcsrt->ClientId.UniqueProcess, BHE_TEST)
                           || (GetInputWindow(pcsrt, hwnd) != NULL)) {

                        edp.dwFlags |= EDPF_INPUT;
                    } else {
                        /*
                         * If the window's gone and the thread is still responsive, then
                         * this must be an app that just hides its window on WM_CLOSE
                         * (e.g., MSN Instant Messenger). Let's nuke the app w/o
                         * bringing up the EndTask dialog.
                         */
                        if (!IsWindow(hwnd)) {
                            DWORD dwThreadHung;

                            /*
                             * Ask the kernel if the thread is hung.
                             */
                            dwThreadHung = gCmsHungAppTimeout;
                            NtUserQueryInformationThread(pcsrt->ThreadHandle,
                                                         UserThreadHungStatus,
                                                         &dwThreadHung,
                                                         sizeof(dwThreadHung),
                                                         NULL);
                            if (!dwThreadHung) {
                                dwCmd = TSN_APPSAYSOK;
                                break;
                            }
                        }

                        /*
                         * EWX_FORCEIFHUNG support.
                         * Also, if this is an ExitWindows call and the process is
                         * not in the context being logged off, we won't kill it.
                         * So don't bother asking the user what to do.
                         */
                        if ((dwClientFlags & WMCS_NODLGIFHUNG)
                                || (!(dwClientFlags & WMCS_ENDTASK)
                                        && !(dwClientFlags & WMCS_CONTEXTLOGOFF))) {

                            dwCmd = TSN_USERSAYSKILL;
                            break;
                        }

                        /*
                         * Hung or Wait?
                         */
                        if (dwClientFlags & WMCS_ENDTASK) {
                            edp.dwFlags |= EDPF_HUNG;
                        } else {
                            edp.dwFlags |= EDPF_WAIT;
                        }
                    }
                }

                /*
                 * If the registry says no dialog, then tell the caller
                 * the user wants to kill the app.
                 */
                if (gfAutoEndTask) {
                    dwCmd = TSN_USERSAYSKILL;
                    break;
                }

                /*
                 * Setup the parameters needed by EndTaskDlgProc.
                 */
                edp.dwRet = 0;
                edp.dwClientFlags = dwClientFlags;
                if (dwClientFlags & WMCS_CONSOLE) {
                    edp.pcsrt = NULL;
                    edp.lParam = lParam;
                } else {
                    edp.pcsrt = pcsrt;
                    edp.lParam = (LPARAM)hwnd;
                }

                hwndDlg = CreateDialogParam(ghModuleWin, MAKEINTRESOURCE(IDD_ENDTASK),
                                        NULL, EndTaskDlgProc, (LPARAM)(&edp));
                /*
                 * If we cannot ask the user, then kill the app.
                 */
                if (hwndDlg == NULL) {
                    edp.dwFlags |= EDPF_NODLG;
                    dwCmd = TSN_USERSAYSKILL;
                    break;
                }
                break;

            default:
                /*
                 * Unexpected return; something is wrong. Kill the app.
                 */
                UserAssert(dwRet != dwRet);
                dwCmd = TSN_USERSAYSKILL;
                break;
        }
    }

    /*
     * If the dialog is up, nuke it.
     */
    if (!(edp.dwFlags & EDPF_NODLG)) {
        DestroyWindow(hwndDlg);
    }

    /*
     * Make sure pwmcsd is freed or marked to be freed by WMCSCallback
     * when the reply comes.
     */
    if (pwmcsd != NULL) {
        if (pwmcsd->dwFlags & WMCSD_REPLY) {
            LocalFree(pwmcsd);
        } else {
            pwmcsd->dwFlags |= WMCSD_IGNORE;
        }
    }

#if DBG
    /*
     * If cancelling, let's name the app that didn't let us log off.
     */
    if ((dwClientFlags & WMCS_EXIT) && (dwCmd == TSN_APPSAYSNOTOK)) {
        WCHAR achTitle[CCHBODYMAX];
        WCHAR *pwcText;
        UserAssert(!(dwClientFlags & WMCS_CONSOLE));
        pwcText = achTitle;
        *(achTitle + CCHBODYMAX - 1) = (WCHAR)0;
        GetApplicationText(hwnd, hThread, pwcText, CCHBODYMAX - 1);
        RIPMSG3(RIP_WARNING, "Log off canceled by pid:%#lx tid:%#lx - '%ws'.\n",
                             HandleToUlong(pcsrt->ClientId.UniqueProcess),
                             HandleToUlong(pcsrt->ClientId.UniqueThread),
                             pwcText);
    }
#endif // DBG

    /*
     * If we're killing this dude, clean any hard errors.
     * Also if wow takes care of it, then our caller doesn't need to
     */
    if ((dwCmd == TSN_USERSAYSKILL) && !(dwClientFlags & WMCS_CONSOLE)) {

        BoostHardError((ULONG_PTR)pcsrt->ClientId.UniqueProcess, BHE_FORCE);

        if (!(pcsrt->Flags & CSR_THREAD_DESTROYED) && WowExitTask(pcsrt)) {
            dwCmd = TSN_APPSAYSOK;
        }
    }

    --dwTSNThreads;
    return dwCmd;
}

/***************************************************************************\
* SetEndTaskDlgStatus
*
* Displays the appropiate message and shows the dialog
*
* 03-11-97 GerardoB     Created
\***************************************************************************/
VOID SetEndTaskDlgStatus(
    ENDDLGPARAMS *pedp,
    HWND hwndDlg,
    UINT uStrId,
    BOOL fInit)
{
    BOOL f, fIsWaiting, fWasWaiting;
    WCHAR *pwcText;

    fWasWaiting = (pedp->uStrId == STR_ENDTASK_WAIT);
    fIsWaiting = (pedp->dwFlags & EDPF_WAIT) != 0;

    /*
     * Store the current message id, load it and show it.
     */
    pedp->uStrId = uStrId;
    pwcText = ServerLoadString(ghModuleWin, uStrId, NULL, &f);
    if (pwcText != NULL) {
        SetDlgItemText(hwndDlg, IDC_STATUSMSG, pwcText);
        LocalFree(pwcText);
    }

    /*
     * If we haven't decided that the app is hung, set a
     * timer to keep an eye on it.
     */
    if (!(pedp->dwFlags & EDPF_HUNG) && !(pedp->dwClientFlags & WMCS_CONSOLE)) {
        SetTimer(hwndDlg, IDT_CHECKAPPSTATE, gCmsHungAppTimeout, NULL);
    }

    /*
     * If initializing or switching to/from the wait mode,
     * set the proper status for IDC_STATUSCANCEL, IDCANCEL,
     * IDC_ENDNOW and  the start/stop the progress bar.
     *
     * Invalidate paint if/as needed.
     */
    if (fInit || (fIsWaiting ^ fWasWaiting)) {
        RECT rc;
        HWND hwndStatusCancel = GetDlgItem(hwndDlg, IDC_STATUSCANCEL);
        HWND hwndCancelButton = GetDlgItem(hwndDlg, IDCANCEL);
        HWND hwndEndButton = GetDlgItem(hwndDlg, IDC_ENDNOW);
        DWORD dwSwpFlags;
        /*
         * If on wait mode, we hide the cancel button and its
         *  explanatory text. The End button will be moved to
         *  the cancel button position.
         */
        dwSwpFlags = ((fIsWaiting ? SWP_HIDEWINDOW : SWP_SHOWWINDOW)
                                | SWP_NOREDRAW | SWP_NOSIZE | SWP_NOMOVE
                                | SWP_NOZORDER | SWP_NOSENDCHANGING
                                | SWP_NOACTIVATE);
        /*
         * If we're hiding the cancel button, give focus/def id to
         * the End button.
         *
         * Note that DM_SETDEIF won't do the right thing unless
         * both Cancel/End buttons are visible.
         */
        if (fIsWaiting) {
            SendMessage(hwndDlg, DM_SETDEFID, IDC_ENDNOW, 0);
            SetFocus(hwndEndButton);
        }
        SetWindowPos(hwndStatusCancel, NULL, 0, 0, 0, 0, dwSwpFlags);
        SetWindowPos(hwndCancelButton, NULL, 0, 0, 0, 0, dwSwpFlags);

        /*
         * If the cancel button is visible, give it focus/def id.
         */
        if (!fIsWaiting) {
            SendMessage(hwndDlg, DM_SETDEFID, IDCANCEL, 0);
            SetFocus(hwndCancelButton);
        }

        /*
         * Initialize progress bar (first time around).
         */
        if (fIsWaiting && (pedp->hbrProgress == NULL)) {
            int iMagic;
            /*
             * Initialize progress bar stuff.
             * The size and location calculations below were made up
             *  to make it look good(?).
             * We need that location on dialog coordiantes since the
             *  progress bar is painted on the dialog's WM_PAINT.
             */
            GetClientRect(hwndStatusCancel, &pedp->rcBar);
            iMagic = (pedp->rcBar.bottom - pedp->rcBar.top) / 4;
            InflateRect(&pedp->rcBar, 0, -iMagic + GetSystemMetrics(SM_CYEDGE));
            pedp->rcBar.right -= (5 * iMagic);
            OffsetRect(&pedp->rcBar, 0, -iMagic);
            MapWindowPoints(hwndStatusCancel, hwndDlg, (LPPOINT)&pedp->rcBar, 2);
            /*
             * Calculate drawing rectangle and dimensions. We kind of make it
             * look like comctrl's progress bar.
             */
            pedp->rcProgress = pedp->rcBar;
            InflateRect(&pedp->rcProgress, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYEDGE));
            pedp->iProgressStop = pedp->rcProgress.right;
            pedp->iProgressWidth = ((2 * (pedp->rcProgress.bottom - pedp->rcProgress.top)) / 3);

            pedp->rcProgress.right = pedp->rcProgress.left + pedp->iProgressWidth - 1;

            pedp->hbrProgress = CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION));
            /*
             * Remember the End button position.
             */
            GetWindowRect(hwndEndButton, &pedp->rcEndButton);
            MapWindowPoints(NULL, hwndDlg, (LPPOINT)&pedp->rcEndButton, 2);
        }

        /*
         * Start/Stop progress bar and set End button position
         */
        if (fIsWaiting) {
            RECT rcEndButton;
            UINT uTimeout = (gdwHungToKillCount * gCmsHungAppTimeout)
                            / ((pedp->iProgressStop - pedp->rcProgress.left) / pedp->iProgressWidth);
            SetTimer(hwndDlg, IDT_PROGRESS, uTimeout, NULL);
            /*
             * The Cancel and the End buttons might have different widths when
             *  localized. So make sure we position it inside the dialog and
             *  to the right end of the dialog.
             */
            GetWindowRect(hwndCancelButton, &rc);
            GetWindowRect(hwndEndButton, &rcEndButton);
            rc.left = rc.right - (rcEndButton.right - rcEndButton.left);
            MapWindowPoints(NULL, hwndDlg, (LPPOINT)&rc, 2);
        } else if (fWasWaiting) {
            KillTimer(hwndDlg, IDT_PROGRESS);
            rc = pedp->rcEndButton;
        }

        /*
         * Move the End button if needed
         */
        if (fIsWaiting || fWasWaiting) {
            SetWindowPos(hwndEndButton, NULL, rc.left, rc.top, 0, 0,
                            SWP_NOREDRAW | SWP_NOSIZE | SWP_NOACTIVATE
                            | SWP_NOZORDER | SWP_NOSENDCHANGING);
        }

        /*
         * Make sure we repaint if needed
         */
        if (!fInit) {
            InvalidateRect(hwndDlg, NULL, TRUE);
        }
    }

    /*
     * If initializing or in hung mode, make sure the user can
     * see the dialog; only bring it to the foreground on
     * initialization (no rude focus stealing)
     */
    if (fInit || (pedp->dwFlags & EDPF_HUNG)) {
        SetWindowPos(hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW
                     | SWP_NOACTIVATE | SWP_NOSENDCHANGING);

        if (fInit) {
            SetForegroundWindow(hwndDlg);
        }
    }
}

/***************************************************************************\
* EndTaskDlgProc
*
* This is the dialog procedure for the dialog that comes up when an app is
* not responding.
*
* 03-06-97 GerardoB     Rewrote it once again. New template though.
* 07-23-92 ScottLu      Rewrote it, but used same dialog template.
* 04-28-92 JonPa        Created.
\***************************************************************************/
INT_PTR APIENTRY EndTaskDlgProc(
    HWND hwndDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    ENDDLGPARAMS* pedp;
    WCHAR achTitle[CCHBODYMAX];
    WCHAR *pwcText, *pwcTemp;
    UINT uLen;
    UINT uStrId;
    PAINTSTRUCT ps;
    HDC hdc, hdcMem;
    BOOL fIsInput, fWasInput;
    int iOldLayout;

    switch (msg) {
    case WM_INITDIALOG:
        /*
         * Save parameters
         */
        pedp = (ENDDLGPARAMS*)lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (ULONG_PTR)pedp);
        /*
         * This tells the caller that the dialog is up
         */
        pedp->dwFlags &= ~EDPF_NODLG;
        /*
         * Build the dialog title making sure that
         *  we end up with a NULL terminated string.
         */
        *(achTitle + CCHBODYMAX - 1) = (WCHAR)0;
        uLen = GetWindowText(hwndDlg, achTitle, CCHBODYMAX - 1);
        pwcText = achTitle + uLen;
        uLen = CCHBODYMAX - 1 - uLen;
        /*
         * Console provides the title; we figure it out for windows apps.
         */
        if (pedp->dwClientFlags & WMCS_CONSOLE) {
            pwcTemp = (WCHAR *)pedp->lParam;
            while (uLen-- && (*pwcText++ = *pwcTemp++));
        } else {
            GetApplicationText((HWND)pedp->lParam, pedp->pcsrt->ThreadHandle, pwcText, uLen);
        }

        SetWindowText(hwndDlg, achTitle);
        /*
         * Get the app's icon: first look for atomIconProperty.
         * If not available, try the class icon.
         * Else, use the default icon.
         */
        pedp->hIcon = (HICON)GetProp((HWND)pedp->lParam, ICON_PROP_NAME);

        if (pedp->hIcon == NULL) {

            pedp->hIcon = (HICON)GetClassLongPtr((HWND)pedp->lParam, GCLP_HICON);

            if (pedp->hIcon == NULL) {

                if (pedp->dwClientFlags & WMCS_CONSOLE) {
                    pedp->hIcon = LoadIcon(ghModuleWin, MAKEINTRESOURCE(IDI_CONSOLE));
                }
                else {
                    pedp->hIcon = LoadIcon(NULL, IDI_APPLICATION);
                }
            }
        }

        /*
         * Figure out what message the caller wants initially
         */
        if (pedp->dwClientFlags & WMCS_CONSOLE) {
            uStrId = STR_ENDTASK_CONSOLE;
        } else if (pedp->dwFlags & EDPF_INPUT) {
            uStrId = STR_ENDTASK_INPUT;
        } else if (pedp->dwFlags & EDPF_WAIT) {
            uStrId = STR_ENDTASK_WAIT;
        } else {
            uStrId = STR_ENDTASK_HUNG;
        }

        /*
         * Display the message, set the focus and show the dialog
         */
        SetEndTaskDlgStatus(pedp, hwndDlg, uStrId, TRUE);
        return FALSE;


    case WM_PAINT:
        pedp = (ENDDLGPARAMS*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if ((pedp == NULL) || (pedp->hIcon == NULL)) {
            break;
        }

        /*
         * Draw the icon
         */
        hdc = BeginPaint(hwndDlg, &ps);
        iOldLayout = GetLayout(hdc);

        if (iOldLayout != GDI_ERROR) {
            SetLayout(hdc, iOldLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
        }

        DrawIcon(hdc, ETD_XICON, ETD_YICON, pedp->hIcon);

        if (iOldLayout != GDI_ERROR) {
            SetLayout(hdc, iOldLayout);
        }

        /*
         * If waiting, draw the progress bar;
         * else draw the warning sign.
         */
        if (pedp->dwFlags & EDPF_WAIT) {
            RECT rc;
            /*
             * Draw a client-edge-looking border.
             */
            rc = pedp->rcBar;
            DrawEdge(hdc, &rc, BDR_SUNKENOUTER, BF_RECT | BF_ADJUST);
            InflateRect(&rc, -1, -1);
            /*
             * Draw the blocks up to the current position.
             */
            rc.right = rc.left + pedp->iProgressWidth - 1;
            while (rc.left < pedp->rcProgress.left) {
                if (rc.right > pedp->iProgressStop) {
                    rc.right = pedp->iProgressStop;
                    if (rc.left >= rc.right) {
                        break;
                    }
                }
                FillRect(hdc, &rc, pedp->hbrProgress);
                rc.left += pedp->iProgressWidth;
                rc.right += pedp->iProgressWidth;
            }
        } else {
            /*
             * Load the bitmap the first time around and
             * figure out where it goes.
             */
            if (pedp->hbmpWarning == NULL) {
                BITMAP bmp;
                pedp->hbmpWarning = LoadBitmap(ghModuleWin, MAKEINTRESOURCE(IDB_WARNING));
                if (GetObject(pedp->hbmpWarning, sizeof(bmp), &bmp)) {
                    pedp->rcWarning.left = ETD_XICON;
                    pedp->rcWarning.top = ETD_XICON + 32 - bmp.bmHeight;
                    pedp->rcWarning.right = bmp.bmWidth;
                    pedp->rcWarning.bottom = bmp.bmHeight;
                }
            }
            /*
             * Blit it.
             */
            hdcMem = CreateCompatibleDC(hdc);
            SelectObject(hdcMem, pedp->hbmpWarning);
            GdiTransparentBlt(hdc, pedp->rcWarning.left, pedp->rcWarning.top,
                   pedp->rcWarning.right, pedp->rcWarning.bottom,
                   hdcMem, 0, 0, pedp->rcWarning.right, pedp->rcWarning.bottom, RGB(255, 0, 255));
            DeleteDC(hdcMem);
        }

        EndPaint(hwndDlg, &ps);
        return TRUE;

    case WM_TIMER:
        pedp = (ENDDLGPARAMS*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pedp == NULL) {
            return TRUE;
        }
        switch (wParam) {
        case IDT_CHECKAPPSTATE:
            pedp->dwCheckTimerCount++;
            /*
             * Check if the app has switched from/to a waiting-for-input
             *  mode. If so, update the dialog and wait a little longer
             */
            fIsInput = (BoostHardError((ULONG_PTR)pedp->pcsrt->ClientId.UniqueProcess, BHE_TEST)
                        || (GetInputWindow(pedp->pcsrt, (HWND)pedp->lParam) != NULL));
            fWasInput = (pedp->dwFlags & EDPF_INPUT);
            if (fIsInput ^ fWasInput) {
                UINT uProgress;
                pedp->dwFlags &= ~(EDPF_INPUT | EDPF_WAIT);
                pedp->dwFlags |= (fIsInput ? EDPF_INPUT : EDPF_WAIT);
                SetEndTaskDlgStatus(pedp, hwndDlg,
                                    (fIsInput ? STR_ENDTASK_INPUT : STR_ENDTASK_WAIT),
                                     FALSE);
                pedp->dwCheckTimerCount /= 2;
                uProgress = pedp->rcProgress.left - pedp->rcBar.left - GetSystemMetrics(SM_CXEDGE);
                uProgress /= 2;
                pedp->rcProgress.left -= uProgress;
                pedp->rcProgress.right -= uProgress;
            }
            /*
             * Is it time to declare it hung?
             */
            if (pedp->dwCheckTimerCount >= gdwHungToKillCount) {
                KillTimer(hwndDlg, IDT_CHECKAPPSTATE);
                pedp->dwFlags &= ~(EDPF_INPUT | EDPF_WAIT);
                pedp->dwFlags |= EDPF_HUNG;
                SetEndTaskDlgStatus(pedp, hwndDlg, STR_ENDTASK_HUNG, FALSE);
            }
        break;

        case IDT_PROGRESS:
            /*
             * Draw the next block in the progress bar.
             */
            if (pedp->rcProgress.right >= pedp->iProgressStop) {
                pedp->rcProgress.right = pedp->iProgressStop;
                if (pedp->rcProgress.left >= pedp->rcProgress.right) {
                    break;
                }
            }
            hdc = GetDC(hwndDlg);
            FillRect(hdc, &pedp->rcProgress, pedp->hbrProgress);
            ReleaseDC(hwndDlg, hdc);
            pedp->rcProgress.left += pedp->iProgressWidth;
            pedp->rcProgress.right += pedp->iProgressWidth;
        break;
        }
        return TRUE;


    case WM_NCACTIVATE:
        /*
         * Make sure we're uncovered when active and not covering the app
         *  when inactive
         */
        pedp = (ENDDLGPARAMS*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pedp != NULL) {
            HWND hwnd;
            if (wParam) {
                hwnd = HWND_TOPMOST;
            } else if (pedp->dwClientFlags & WMCS_CONSOLE) {
                hwnd = HWND_TOP;
            } else {
                hwnd = (HWND)pedp->lParam;
            }
            SetWindowPos(hwndDlg, hwnd,
                         0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
        }
        break;


    case WM_COMMAND:
        /*
         * The user has made a choice, we're done.
         */
        pedp = (ENDDLGPARAMS*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pedp != NULL) {
            pedp->dwRet = (DWORD)wParam;
        }
        DestroyWindow(hwndDlg);
        break;


    case WM_DESTROY:
        /*
         * We're dead. Make sure the caller knows we're history
         */
        pedp = (ENDDLGPARAMS*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pedp != NULL) {
            pedp->dwFlags |= (EDPF_NODLG | EDPF_RESPONSE);
            if (pedp->hbmpWarning != NULL) {
                DeleteObject(pedp->hbmpWarning);
            }
            if (pedp->hbrProgress != NULL) {
                DeleteObject(pedp->hbrProgress);
            }
        }
        break;
    }

    return FALSE;
}

/***************************************************************************\
* _EndTask
*
* This routine is called from the task manager to end an application - for
* gui apps, either a win32 app or a win16 app. Note: Multiple console
* processes can live in a single console window. We'll pass these requests
* for destruction to console.
*
* 07-25-92 ScottLu      Created.
\***************************************************************************/
BOOL _EndTask(
    HWND hwnd,
    BOOL fMeanKill)
{
    BOOL fRet = TRUE;
    PCSR_THREAD pcsrt = CSR_SERVER_QUERYCLIENTTHREAD();
    PCSR_THREAD pcsrtKill;
    DWORD dwThreadId;
    DWORD dwProcessId;
    LPWSTR lpszMsg;
    BOOL fAllocated;
    DWORD dwCmd;
    USERTHREAD_USEDESKTOPINFO utudi;
    NTSTATUS Status;

    /*
     * Set the current work thread to a desktop so we can
     * go safely into win32k.sys.
     */
    utudi.hThread = pcsrt->ThreadHandle;
    utudi.drdRestore.pdeskRestore = NULL;

    Status = NtUserSetInformationThread(NtCurrentThread(),
            UserThreadUseDesktop, &utudi, sizeof(utudi));
    if (!NT_SUCCESS(Status)) {
        /*
         * We were unable to get the thread's desktop. Game over.
         */
        return TRUE;
    }


    /*
     * Get the process and thread that owns hwnd.
     */
    dwThreadId = GetWindowThreadProcessId(hwnd, &dwProcessId);
    if (dwThreadId == 0) {
        goto RestoreDesktop;
    }

    /*
     * Don't allow destruction of winlogon.
     */
    if (dwProcessId == gIdLogon) {
        goto RestoreDesktop;
    }

    /*
     * If this is a console window, then just send the close message to
     * it, and let console clean up the processes in it.
     */
    if ((HANDLE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE) == ghModuleWin) {
        PostMessage(hwnd, WM_CLOSE, 0, 0);
        goto RestoreDesktop;
    }

    /*
     * Find the CSR_THREAD for the window.
     */
    Status = CsrLockThreadByClientId(LongToHandle(dwThreadId), &pcsrtKill);
    if (!NT_SUCCESS(Status)) {
        /*
         * This is probably the ghost thread, which CSRSS doesn't know about
         * (as it's created via RtlCreateUserThread, which doesn't LPC into
         * CSRSS like regular CreateThread does). When the ghost window gets
         * the WM_CLOSE it'll handle removing the real window and thread. If
         * this *isn't* a ghost window, then no real harm done, so we post
         * no matter what.
         */
        PostMessage(hwnd, WM_CLOSE, 0, 0);
        goto RestoreDesktop;
    }
    CsrReferenceThread(pcsrtKill);
    CsrUnlockThread(pcsrtKill);

    /*
     * If this is a WOW app, then shutdown just this wow application.
     */
    if (!fMeanKill) {
        /*
         * Find out what to do now - did the user cancel or the app cancel,
         * etc? Only allow cancelling if we are not forcing the app to
         * exit.
         */
        dwCmd = ThreadShutdownNotify(WMCS_ENDTASK, (ULONG_PTR)pcsrtKill, (LPARAM)hwnd);

        switch (dwCmd) {
        case TSN_APPSAYSNOTOK:
            /*
             * App says not ok - this'll let taskman bring up the "are you sure?"
             * dialog to the user.
             */
            CsrDereferenceThread(pcsrtKill);
            fRet = FALSE;
            goto RestoreDesktop;

        case TSN_USERSAYSCANCEL:
            /*
             * User hit cancel on the timeout dialog - so the user really meant
             * it. Let taskman know everything is ok by returning TRUE.
             */
            CsrDereferenceThread(pcsrtKill);
            goto RestoreDesktop;
        }
    }

    /*
     * Kill the application now. If the thread has not been destroyed,
     * nuke the task. If WowExitTask returns that the thread is not
     * a WOW task, terminate the process.
     */
    if (!(pcsrtKill->Flags & CSR_THREAD_DESTROYED) && !WowExitTask(pcsrtKill)) {

        BOOL bDoBlock;

        /*
         * Calling ExitProcess() in the app's context will not always work
         * because the app may have .dll termination deadlocks: so the thread
         * will hang with the rest of the process. To ensure apps go away,
         * we terminate the process with NtTerminateProcess().
         *
         * Pass this special value, DBG_TERMINATE_PROCESS, which tells
         * NtTerminateProcess() to return failure if it can't terminate the
         * process because the app is being debugged.
         */
        if (ISTS()) {
            NTSTATUS ExitStatus;
            HANDLE DebugPort;

            ExitStatus = DBG_TERMINATE_PROCESS;
            if (NT_SUCCESS(NtQueryInformationProcess(NtCurrentProcess(),
                                                     ProcessDebugPort,
                                                     &DebugPort,
                                                     sizeof(HANDLE),
                                                     NULL)) &&
                (DebugPort != NULL)) {
                // Csr is being debugged - go ahead and kill the process
                ExitStatus = 0;
            }
            Status = NtTerminateProcess(pcsrtKill->Process->ProcessHandle, ExitStatus);
            if (!NT_SUCCESS(Status) && Status != STATUS_PROCESS_IS_TERMINATING) {

                bDoBlock = TRUE;
            } else {
                bDoBlock = FALSE;
            }
        } else {
            Status = NtTerminateProcess(pcsrtKill->Process->ProcessHandle, DBG_TERMINATE_PROCESS);
            if (!NT_SUCCESS(Status) && Status != STATUS_PROCESS_IS_TERMINATING) {
                bDoBlock = TRUE;
            } else {
                bDoBlock = FALSE;
            }
        }

        if (bDoBlock) {

            /*
             * If the app is being debugged, don't close it - because that can
             * cause a hang to the NtTerminateProcess() call.
             */
            lpszMsg = ServerLoadString(ghModuleWin, STR_APPDEBUGGED,
                    NULL, &fAllocated);
            if (lpszMsg) {
                MessageBoxEx(NULL, lpszMsg, NULL, MB_OK | MB_SETFOREGROUND, 0);
                LocalFree(lpszMsg);
            }
        } else {
            pcsrtKill->Process->Flags |= CSR_PROCESS_TERMINATED;
        }
    }
    CsrDereferenceThread(pcsrtKill);

RestoreDesktop:
    utudi.hThread = NULL;
    Status = NtUserSetInformationThread(NtCurrentThread(),
            UserThreadUseDesktop, &utudi, sizeof(utudi));
    UserAssert(NT_SUCCESS(Status));

    return fRet;
}

/***************************************************************************\
* WowExitTask
*
* Calls wow back to make sure a specific task has exited. Returns
* TRUE if the thread is a WOW task, FALSE if not.
*
* 08-02-92 ScottLu      Created.
\***************************************************************************/
BOOL WowExitTask(
    PCSR_THREAD pcsrt)
{
    HANDLE ahandle[2];
    USERTHREAD_WOW_INFORMATION WowInfo;
    NTSTATUS Status;

    ahandle[1] = gheventCancel;

    /*
     * Query task id and exit function.
     */
    Status = NtUserQueryInformationThread(pcsrt->ThreadHandle,
            UserThreadWOWInformation, &WowInfo, sizeof(WowInfo), NULL);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    /*
     * If no task id was returned, it is not a WOW task
     */
    if (WowInfo.hTaskWow == 0) {
        return FALSE;
    }

    /*
     * Try to make it exit itself. This will work most of the time.
     * If this doesn't work, terminate this process.
     */
    ahandle[0] = InternalCreateCallbackThread(pcsrt->Process->ProcessHandle,
                                              (ULONG_PTR)WowInfo.lpfnWowExitTask,
                                              (ULONG_PTR)WowInfo.hTaskWow);
    if (ahandle[0] == NULL) {
        NtTerminateProcess(pcsrt->Process->ProcessHandle, 0);
        pcsrt->Process->Flags |= CSR_PROCESS_TERMINATED;
        goto Exit;
    }

    WaitForMultipleObjects(2, ahandle, FALSE, INFINITE);
    NtClose(ahandle[0]);

Exit:
    return TRUE;
}

/***************************************************************************\
* InternalWaitCancel
*
* Console calls this to wait for objects or shutdown to be cancelled
*
* 29-Oct-1992 mikeke    Created
\***************************************************************************/
DWORD InternalWaitCancel(
    HANDLE handle,
    DWORD dwMilliseconds)
{
    HANDLE ahandle[2];

    ahandle[0] = handle;
    ahandle[1] = gheventCancel;

    return WaitForMultipleObjects(2, ahandle, FALSE, dwMilliseconds);
}


/***************************************************************************\
* InternalCreateCallbackThread
*
* This routine creates a remote thread in the context of a given process.
* It is used to call the console control routine, as well as ExitProcess when
* forcing an exit. Returns a thread handle.
*
* 07-28-92 ScottLu      Created.
\***************************************************************************/

HANDLE InternalCreateCallbackThread(
    HANDLE hProcess,
    ULONG_PTR lpfn,
    ULONG_PTR dwData)
{
    LONG BasePriority;
    HANDLE hThread, hToken;
    PTOKEN_DEFAULT_DACL lpDaclDefault;
    TOKEN_DEFAULT_DACL daclDefault;
    ULONG cbDacl;
    SECURITY_ATTRIBUTES attrThread;
    SECURITY_DESCRIPTOR sd;
    DWORD idThread;
    NTSTATUS Status;

    hThread = NULL;

    Status = NtOpenProcessToken(hProcess, TOKEN_QUERY, &hToken);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("NtOpenProcessToken failed, status = %x\n", Status));
        return NULL;
    }

    cbDacl = 0;
    NtQueryInformationToken(hToken,
            TokenDefaultDacl,
            &daclDefault,
            sizeof(daclDefault),
            &cbDacl);

    lpDaclDefault = (PTOKEN_DEFAULT_DACL)LocalAlloc(LMEM_FIXED, cbDacl);
    if (lpDaclDefault == NULL) {
        KdPrint(("LocalAlloc failed for lpDaclDefault"));
        goto closeexit;
    }

    Status = NtQueryInformationToken(hToken,
            TokenDefaultDacl,
            lpDaclDefault,
            cbDacl,
            &cbDacl);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("NtQueryInformationToken failed, status = %x\n", Status));
        goto freeexit;
    }

    if (!NT_SUCCESS(RtlCreateSecurityDescriptor(&sd,
            SECURITY_DESCRIPTOR_REVISION1))) {
        UserAssert(FALSE);
        goto freeexit;
    }

    RtlSetDaclSecurityDescriptor(&sd, TRUE, lpDaclDefault->DefaultDacl, TRUE);

    attrThread.nLength = sizeof(attrThread);
    attrThread.lpSecurityDescriptor = &sd;
    attrThread.bInheritHandle = FALSE;

    GetLastError();
    hThread = CreateRemoteThread(hProcess,
        &attrThread,
        0L,
        (LPTHREAD_START_ROUTINE)lpfn,
        (LPVOID)dwData,
        0,
        &idThread);

    if (hThread != NULL) {
        BasePriority = THREAD_PRIORITY_HIGHEST;
        NtSetInformationThread(hThread,
                               ThreadBasePriority,
                               &BasePriority,
                               sizeof(LONG));
    }

freeexit:
    LocalFree((HANDLE)lpDaclDefault);

closeexit:
    NtClose(hToken);

    return hThread;
}

ULONG
SrvExitWindowsEx(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    BEGIN_LPC_RECV(EXITWINDOWSEX);

    Status = _ExitWindowsEx(pcsrt, a->uFlags);
    a->fSuccess = NT_SUCCESS(Status);

    END_LPC_RECV();
}

ULONG
SrvEndTask(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PENDTASKMSG petm = (PENDTASKMSG)&m->u.ApiMessageData;
    PCSR_THREAD pcsrt;
    PTEB Teb = NtCurrentTeb();

    Teb->LastErrorValue = 0;
    pcsrt = CSR_SERVER_QUERYCLIENTTHREAD();
    /*
     * Don't block the client so it can respond to messages while we
     * process this request -- we might bring up the End Application
     * dialog or the hwnd being shutdown might request some user action.
     */
    if (pcsrt->Process->ClientPort != NULL) {
        m->ReturnValue = STATUS_SUCCESS;
        petm->dwLastError = 0;
        petm->fSuccess = TRUE;
        NtReplyPort(pcsrt->Process->ClientPort, (PPORT_MESSAGE)m);
        *ReplyStatus = CsrServerReplied;
    }

    petm->fSuccess = _EndTask(petm->hwnd, petm->fForce);

    petm->dwLastError = Teb->LastErrorValue;
    return STATUS_SUCCESS;
}

/***************************************************************************\
* IsPrivileged
*
* Check to see if the client has the specified privileges
*
* History:
* 01-02-91 JimA       Created.
\***************************************************************************/
BOOL IsPrivileged(
    PPRIVILEGE_SET ppSet)
{
    HANDLE hToken;
    NTSTATUS Status;
    BOOLEAN bResult = FALSE;

    /*
     * Impersonate the client.
     */
    if (!CsrImpersonateClient(NULL)) {
        return FALSE;
    }

    /*
     * Open the client's token.
     */
    Status = NtOpenThreadToken(NtCurrentThread(),
                               TOKEN_QUERY,
                               TRUE,
                               &hToken);
    if (NT_SUCCESS(Status)) {
        UNICODE_STRING strSubSystem;

        RtlInitUnicodeString(&strSubSystem, L"USER32");

        /*
         * Perform the check.
         */
        Status = NtPrivilegeCheck(hToken, ppSet, &bResult);
        NtPrivilegeObjectAuditAlarm(&strSubSystem, NULL, hToken,
                0, ppSet, bResult);
        NtClose(hToken);
        if (!bResult) {
            SetLastError(ERROR_ACCESS_DENIED);
        }
    }

    CsrRevertToSelf();
    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
    }

    /*
     * Return result of privilege check.
     */
    return (BOOL)(bResult && NT_SUCCESS(Status));
}

/***************************************************************************\
* SrvRegisterServicesProcess
*
* Register the services process.
*
* History:
* 05-05-95 BradG         Created.
\***************************************************************************/
ULONG SrvRegisterServicesProcess(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PRIVILEGE_SET psTcb = { 1, PRIVILEGE_SET_ALL_NECESSARY,
        { SE_TCB_PRIVILEGE, 0 }
    };

    BEGIN_LPC_RECV(REGISTERSERVICESPROCESS);

    /*
     * Allow only one services process and then only if it has TCB
     * privilege.
     */
    EnterCrit();
    if ((gdwServicesProcessId != 0) || !IsPrivileged(&psTcb)) {
        SetLastError(ERROR_ACCESS_DENIED);
        a->fSuccess = FALSE;
    } else {
        gdwServicesProcessId = a->dwProcessId;
        a->fSuccess = TRUE;
    }
    LeaveCrit();

    END_LPC_RECV();
}

#ifdef FE_IME
/***************************************************************************\
* IsImeWindow
*
* Returns TRUE if it's an IME window.
*
* History:
* 06-05-96 KazuM         Created.
\***************************************************************************/
BOOL
IsImeWindow(
    HWND hwnd)
{
    int num;
    WCHAR ClassName[16];

    num = GetClassName(hwnd, ClassName, sizeof(ClassName)/sizeof(WCHAR)-1);
    if (num == 0) {
        return FALSE;
    }

    ClassName[num] = L'\0';
    if (wcsncmp(ClassName, L"IME", 3) == 0) {
        return TRUE;
    }

    return (GetClassLong(hwnd, GCL_STYLE) & CS_IME) != 0;
}
#endif // FE_IME

/***************************************************************************\
* CancelExitWindows
*
* Cancel any logoff/shutdown that is in progress. This is called from _ExitWindowsEx
* to cancel an existing exitwindows call if a new call arrives with a different sid.
* This call is also  used for Personal Terminal Services single session scenatio so
* that a force logoff can be initiated once the existing ExitWindows call is
* cancelled.
*
* History:
\***************************************************************************/
BOOL CancelExitWindows(
   VOID)
{
   LARGE_INTEGER li;

   /*
    * Another logoff/shutdown is in progress and we need
    * to cancel it so we can do an override.
    *
    * If someone else is trying to cancel shutdown, exit.
    */
   EnterCrit();
   li.QuadPart  = 0;
   if (NtWaitForSingleObject(gheventCancel, FALSE, &li) == WAIT_OBJECT_0) {
       LeaveCrit();
       return FALSE;
   }

   /*
    * If no one will set gheventCancelled, don't wait.
    */
   if (gdwThreadEndSession == 0) {
       LeaveCrit();
       return TRUE;
   }

   NtClearEvent(gheventCancelled);
   NtSetEvent(gheventCancel, NULL);
   LeaveCrit();
   /*
    * Wait for the other guy to be cancelled
    */
   NtWaitForSingleObject(gheventCancelled, FALSE, NULL);

   EnterCrit();

   /*
    * This signals that we are no longer trying to cancel a
    * shutdown
    */
   NtClearEvent(gheventCancel);

   /*
    * If someone managed to start a shutdown again, exit.
    * Can this happen? Let's assert to check it out.
    */
   if (gdwThreadEndSession != 0) {
       UserAssert(gdwThreadEndSession == 0);
       LeaveCrit();
       return FALSE;
   }
   LeaveCrit();

   return TRUE;
}

/***************************************************************************\
* TestShutdownPrivilege
*
* Test to see if the clent has shutdown privilege.
*
* History:
* 02-02-20 qingboz         Created.
\***************************************************************************/
BOOL
TestShutdownPrivilege(
    HANDLE UserToken)
{
    NTSTATUS    Status;
    LUID        LuidPrivilege = RtlConvertLongToLuid(SE_SHUTDOWN_PRIVILEGE);
    LUID        TokenPrivilege;
    ULONG       BytesRequired;
    ULONG       i;
    BOOL        bHasPrivilege = FALSE;
    BOOL        bNetWork = FALSE;
    PSID        NetworkSid = NULL;
    PTOKEN_PRIVILEGES Privileges = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    Status = RtlAllocateAndInitializeSid(&NtAuthority,
                                          1, SECURITY_NETWORK_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &NetworkSid );

    if (!NT_SUCCESS(Status)) {
        NetworkSid = NULL;
        goto Cleanup;
    }

    if (CheckTokenMembership(UserToken, NetworkSid, &bNetWork)) {
        if (bNetWork) {
            LuidPrivilege = RtlConvertLongToLuid(SE_REMOTE_SHUTDOWN_PRIVILEGE);
        }
    } else {
        goto Cleanup;
    }

    Status = NtQueryInformationToken(
                 UserToken,
                 TokenPrivileges,
                 NULL,
                 0,
                 &BytesRequired
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        goto Cleanup;
    }

    Privileges = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, BytesRequired);
    if (!Privileges) {
        goto Cleanup;
    }

    Status = NtQueryInformationToken(
                 UserToken,
                 TokenPrivileges,
                 Privileges,
                 BytesRequired,
                 &BytesRequired
                 );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    for (i=0; i<Privileges->PrivilegeCount; i++) {
        TokenPrivilege = *((LUID UNALIGNED *) &Privileges->Privileges[i].Luid);
        if (RtlEqualLuid(&TokenPrivilege, &LuidPrivilege)) {
            bHasPrivilege = TRUE;
            break;
        }
    }

Cleanup:
    if (NetworkSid) {
        RtlFreeSid(NetworkSid);
    }

    if (Privileges) {
        LocalFree(Privileges);
    }

    return bHasPrivilege;
}

/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 02-02-20 qingboz         Created.
\***************************************************************************/
PSID GetUserSid(
    HANDLE UserToken)
{
    PTOKEN_USER pUser;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;

    if (UserToken == NULL) {
        return NULL;
    }

    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);

    if (pUser == NULL) {
        return NULL;
    }

    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,
                 TokenUser,
                 pUser,
                 BytesRequired,
                 &BytesRequired
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //
        PTOKEN_USER pTemp = pUser;
        pUser = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pUser == NULL) {
            LocalFree( pTemp );
            return NULL;
        }

        status = NtQueryInformationToken(
                     UserToken,
                     TokenUser,
                     pUser,
                     BytesRequired,
                     &BytesRequired
                     );

    }

    if (!NT_SUCCESS(status)) {
        LocalFree(pUser);
        return NULL;
    }

    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        LocalFree(pUser);
        return NULL;
    }

    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        LocalFree(pSid);
        pSid = NULL;
    }

    return pSid;
}

/***************************************************************************\
* SrvRecordShutdownReason
*
* Process RecordShutdownReason request from clients. This will log an event
* in the event log, and optionally take a system snapshot.
*
* History:
* 01-12-12 qingboz         Created.
* 02-02-20 qingboz         Added privilege check and moved some stuff from
*                          client to server (such as user name and SID).
\***************************************************************************/
ULONG
SrvRecordShutdownReason(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PRECORDSHUTDOWNREASONMSG prm = (PRECORDSHUTDOWNREASONMSG)&m->u.ApiMessageData;
    LPWSTR  lpStrings[8];
    WORD    wEventType;
    WORD    wStringCnt = 0;
    WCHAR   szReasonCode[32];
    BOOL    bRet = FALSE;
    BOOL    bReportEvent = FALSE;
    BOOL    bIsCrsssOrWinlogon = FALSE;
    BOOL    bIsCancelEvent = FALSE;
    struct {
        DWORD Reason;
        PWCHAR SnapShotBuf;
    } SnapShot;
    UINT    SnapShotSize = 0;
    HANDLE  hEventLog = NULL;

    LPWSTR  lpszUserName = NULL;
    LPWSTR  lpszUserDomain = NULL;
    LPWSTR  lpszComputerName = NULL;
    LPWSTR  lpszReasonTitle = NULL;
    LPWSTR  lpszComment = NULL;
    DWORD   dwComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
    DWORD   dwUserNameLen = MAX_PATH + 1;
    DWORD   dwUserDomainLen = MAX_PATH + 1;
    DWORD   dwReasonTitleLen = MAX_REASON_NAME_LEN;
    PSID psid;
    SID_NAME_USE eUse;
    HANDLE hToken;

    UNREFERENCED_PARAMETER(ReplyStatus);

    /*
     * Need to impersonate in order to check privilege and get user name.
     */
    if (!CsrImpersonateClient(NULL)) {
        return FALSE;
    }

    if (!NT_SUCCESS(NtOpenThreadToken(NtCurrentThread(), TOKEN_QUERY, (BOOLEAN)TRUE, &hToken))) {
        CsrRevertToSelf();
        return FALSE;
    }

    /*
     * Find out whether this is csrss/winlogon calling us.
     */
    if (m->h.ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess
        || HandleToUlong(m->h.ClientId.UniqueProcess) == gIdLogon) {
            bIsCrsssOrWinlogon = TRUE;
    }

    /*
     * We just need the token, so we can revert now.
     */
    CsrRevertToSelf();

    // Check for privilege.
    if (!TestShutdownPrivilege(hToken)) {
        NtClose(hToken);
        return FALSE;
    }

    // Get SID for reporting event.
    psid = GetUserSid(hToken);
    NtClose(hToken); // done with the token.
    if (!psid) {
        return FALSE;
    }

    SnapShot.SnapShotBuf = NULL; // so cleanup won't free an uninitialized buffer when memory alloc fails later.

    /*
     * For cancel event we don't need capature buffer, so we only validate
     * the buffer for non-cancelling events.
     */
    if (prm->dwEventType == SR_EVENT_EXITWINDOWS && prm->fShutdownCancelled
        || prm->dwEventType == SR_EVENT_INITIATE_CLEAN_ABORT) {
        bIsCancelEvent = TRUE;
    } else {
        if (!m->CaptureBuffer) {
            goto Cleanup;
        }
        if (!CsrValidateMessageBuffer(m, &prm->psr, sizeof(SHUTDOWN_REASON), sizeof(BYTE))) {
            goto Cleanup;
        }
        if (prm->dwProcessNameLen == 0 || prm->dwProcessNameLen - 1 > MAX_PATH
            || !CsrValidateMessageBuffer(m, &prm->pwchProcessName, prm->dwProcessNameLen, sizeof(WCHAR))) {
            goto Cleanup;
        }
        if (prm->dwShutdownTypeLen == 0 || prm->dwShutdownTypeLen > SHUTDOWN_TYPE_LEN
            || !CsrValidateMessageBuffer(m, &prm->pwchShutdownType, prm->dwShutdownTypeLen, sizeof(WCHAR))) {
            goto Cleanup;
        }
        if (prm->dwCommentLen
            && (prm->dwCommentLen > MAX_REASON_COMMENT_LEN || !CsrValidateMessageBuffer(m, &prm->pwchComment, prm->dwCommentLen, sizeof(WCHAR)))) {
            goto Cleanup;
        }

        SnapShot.Reason = prm->psr->dwReasonCode;
        prm->pwchProcessName[prm->dwProcessNameLen - 1] = 0;
        prm->pwchShutdownType[prm->dwShutdownTypeLen - 1] = 0;
        if (prm->dwCommentLen) {
            prm->pwchComment[prm->dwCommentLen - 1] = 0;
        }
    }

    /*
     * This function could be called multiple times during a single shutdown,
     * we need to make sure that we don't log two shutdown events. We also
     * need to make sure max one dirty event per reboot.
     */
    if (prm->dwEventType == SR_EVENT_DIRTY) {
        if (InterlockedCompareExchange((volatile LONG*)&g_DirtyShutdownMax, 0L, 1L)) {
            bReportEvent = TRUE;
        }
    } else {
        if (prm->dwEventType == SR_EVENT_EXITWINDOWS && prm->fShutdownCancelled
            || prm->dwEventType == SR_EVENT_INITIATE_CLEAN_ABORT) {
            /*
             * If csrss or winlogon issue the abort we will log the event no matter what.
             */
            if (bIsCrsssOrWinlogon) {
                bReportEvent = TRUE;
                InterlockedCompareExchange((volatile LONG*)&g_ShutdownState, 0L, 1L);
            } else if (InterlockedCompareExchange((volatile LONG*)&g_ShutdownState, 0L, 1L)) {
                bReportEvent = TRUE;
            }
        } else {
            if (!InterlockedCompareExchange((volatile LONG*)&g_ShutdownState, 1L, 0L)) {
                bReportEvent = TRUE;
            }
        }
    }

    if (!bReportEvent) {
        return TRUE;
    }

     // Allocate buffers after validations.
    lpszUserName = (LPWSTR)LocalAlloc(LPTR, dwUserNameLen * sizeof(WCHAR));
    lpszUserDomain = (LPWSTR)LocalAlloc(LPTR, dwUserDomainLen * sizeof(WCHAR));
    lpszComputerName = (LPWSTR)LocalAlloc(LPTR, dwComputerNameLen * sizeof(WCHAR));
    lpszReasonTitle = (LPWSTR)LocalAlloc(LPTR, dwReasonTitleLen * sizeof(WCHAR));
    if (!lpszUserName || !lpszUserDomain || !lpszComputerName || !lpszReasonTitle) {
        goto Cleanup;
    }

    // Get the comment.
    if (!bIsCancelEvent && prm->dwCommentLen > 0) {
        lpszComment = LocalAlloc(LPTR, prm->dwCommentLen * sizeof(WCHAR));
        if (!lpszComment) {
            goto Cleanup;
        }
        wcsncpy(lpszComment, prm->pwchComment, prm->dwCommentLen);
        lpszComment[prm->dwCommentLen-1] = 0;
    }

    // Get User name.
    if (!LookupAccountSidW(NULL, psid, lpszUserName, &dwUserNameLen, lpszUserDomain,
        &dwUserDomainLen, &eUse)) {
        //
        //  log an event w/o user info, because shutdown might be initiated 
        //  when lsass was terminated unexpected.
        //
        lpszUserName[0] = lpszUserDomain[0] = 0;
    } else {

        lpszUserName[MAX_PATH] = 0;
        lpszUserDomain[MAX_PATH] = 0;

        // We need to pack into a buffer of MAX_PATH + 1 in the form L"domain\\username"
        if (wcslen(lpszUserDomain) + wcslen(lpszUserName) > MAX_PATH - 1) {
            goto Cleanup;
        }
        if (wcslen(lpszUserDomain) > 0) {
            wcscat(lpszUserDomain, L"\\");
        }
        wcscat(lpszUserDomain, lpszUserName);
    }

    // Get Computer Name.
    if (!GetComputerNameW(lpszComputerName, &dwComputerNameLen)) {
        //
        //  log an event w/o user info, because shutdown might be initiated 
        //  when some critical process/service got terminated unexpected.
        //
        lpszComputerName[0]=0;
    } else {
        lpszComputerName[MAX_COMPUTERNAME_LENGTH] = 0;
    }

    // Get reason title.
    if (!GetReasonTitleFromReasonCode(prm->psr->dwReasonCode, lpszReasonTitle, dwReasonTitleLen)) {
        goto Cleanup;
    }
    lpszReasonTitle[MAX_REASON_NAME_LEN-1] = 0;

    // Get the reason code string.
    _snwprintf(szReasonCode, ARRAY_SIZE(szReasonCode), L"0x%x", prm->psr->dwReasonCode);
    szReasonCode[ARRAY_SIZE(szReasonCode)-1] = 0;

    switch (prm->dwEventType) {
        LPWSTR  lpCommentStart;
        LPWSTR  lpCommentEnd;
        INT     i;

        case SR_EVENT_EXITWINDOWS:
            if (prm->fShutdownCancelled) {
                wEventType = EVENTLOG_WARNING_TYPE;
                lpStrings[wStringCnt++] = lpszComputerName;
                lpStrings[wStringCnt++] = lpszUserDomain;
            } else {
                wEventType = EVENTLOG_INFORMATION_TYPE;
                lpStrings[wStringCnt++] = prm->pwchProcessName;
                lpStrings[wStringCnt++] = lpszComputerName;
                lpStrings[wStringCnt++] = lpszReasonTitle;
                lpStrings[wStringCnt++] = szReasonCode;
                lpStrings[wStringCnt++] = prm->pwchShutdownType;
                lpStrings[wStringCnt++] = lpszComment;
                lpStrings[wStringCnt++] = lpszUserDomain;
            }
            break;
        case SR_EVENT_INITIATE_CLEAN:
            wEventType = EVENTLOG_INFORMATION_TYPE;
            lpStrings[wStringCnt++] = prm->pwchProcessName;
            lpStrings[wStringCnt++] = lpszComputerName;
            lpStrings[wStringCnt++] = lpszReasonTitle;
            lpStrings[wStringCnt++] = szReasonCode;
            lpStrings[wStringCnt++] = prm->pwchShutdownType;
            lpStrings[wStringCnt++] = lpszComment;
            lpStrings[wStringCnt++] = lpszUserDomain;
            break;
        case SR_EVENT_INITIATE_CLEAN_ABORT:
            wEventType = EVENTLOG_WARNING_TYPE;
            lpStrings[wStringCnt++] = lpszComputerName;
            lpStrings[wStringCnt++] = lpszUserDomain;
            break;
        case SR_EVENT_DIRTY:
            lpCommentStart = lpszComment;
            lpCommentEnd = lpCommentStart + (lpCommentStart ? wcslen(lpCommentStart) : 0);
            wEventType = EVENTLOG_WARNING_TYPE;
            lpStrings[wStringCnt++] = lpszReasonTitle;
            lpStrings[wStringCnt++] = szReasonCode;

            /*
            * In case of dirty event, the comment is in the following format:
            * L"nnn\nccccccccnnn\ncccccccnnn\ncccccc"
            * Basically it is three strings with each one headed by its length
            * and a newline.
            */

            for (i = 0; i < 3; i++) {
                INT cnt;
                if (lpCommentStart >= lpCommentEnd) {
                    break;
                }
                cnt = _wtoi(lpCommentStart);
                *lpCommentStart++ = L'\0';
                while (lpCommentStart < lpCommentEnd && *lpCommentStart != L'\n') {
                    lpCommentStart++;
                }

                if (*lpCommentStart) {
                    lpStrings[wStringCnt++] = ++lpCommentStart;
                } else {
                    lpStrings[wStringCnt++] = NULL;
                }
                lpCommentStart += cnt;
            }

            for (; i < 3; i++) {
                lpStrings[wStringCnt++] = NULL;
            }

            lpStrings[wStringCnt++] = lpszUserDomain;

            break;
        default:
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Unknown prm->dwEventType 0x%x", prm->dwEventType);
            goto Cleanup;
    }

    // First see if we need to take a snapshot.
    if (prm->dwEventType == SR_EVENT_INITIATE_CLEAN) {
        CONST WCHAR szSnapShotVal[] = L"Snapshot";
        CONST ULONG ulMaxSnapShotSize = 2048;
        SNAPSHOTFUNC pSnapShotProc;
        DWORD   DoSnapShotValue = SNAPSHOT_POLICY_UNPLANNED;
        HKEY    hKey = NULL;

        // First try to read the policy.
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RELIABILITY_POLICY, 0, KEY_QUERY_VALUE, &hKey)) {
            DWORD dwSize = sizeof(DWORD);
            DWORD dwType;
            if (ERROR_SUCCESS == RegQueryValueEx(hKey, szSnapShotVal, NULL, &dwType, (UCHAR*)&DoSnapShotValue, &dwSize)) {
                if (dwType != REG_DWORD) {
                    DoSnapShotValue = SNAPSHOT_POLICY_UNPLANNED;
                } else if (DoSnapShotValue == 0) {
                    DoSnapShotValue = SNAPSHOT_POLICY_NEVER;
                } else {
                    DoSnapShotValue = SNAPSHOT_POLICY_UNPLANNED;
                }
            }
            RegCloseKey(hKey);
        } // else SNAPSHOT_POLICY_UNPLANNED will be used.

        /*
        * SNAPSHOT_POLICY_ALWAYS: we will take a snapshot when we get here.
        * SNAPSHOT_POLICY_NEVER: we wont event proceed into the if (no snapshot)
        * SNAPSHOT_POLICY_UNPLANNED: Snapshot only if the reason is unplanned.
        */

        if (DoSnapShotValue == SNAPSHOT_POLICY_ALWAYS
            || (DoSnapShotValue == SNAPSHOT_POLICY_UNPLANNED
                && !(prm->psr->dwReasonCode & SHTDN_REASON_FLAG_PLANNED))) {

            SnapShotSize = ulMaxSnapShotSize/sizeof(WCHAR);
            SnapShot.SnapShotBuf = LocalAlloc(LPTR, ulMaxSnapShotSize);
            if (SnapShot.SnapShotBuf == NULL) {
                goto Cleanup;
            }

            SnapShot.SnapShotBuf[0] = 0;

            /*
            * Snapshot.dll is loaded once and will be unloaded when system
            * shutdowns down. If we fail in any way make sure we can try it
            * again next time this function gets called.
            */
            if (InterlockedCompareExchange(&g_SnapShot, 0L, 1L)) {
                g_SnapShotDllHandle = LoadLibrary(L"snapshot.dll");
                if (!g_SnapShotDllHandle) {
                    InterlockedExchange(&g_SnapShot, 1L);
                }
            }

            if (g_SnapShotDllHandle) {
                pSnapShotProc = (SNAPSHOTFUNC)GetProcAddress(g_SnapShotDllHandle, "LogSystemSnapshot");
                if (pSnapShotProc) {
                        (*pSnapShotProc)(wStringCnt, lpStrings, &SnapShotSize, SnapShot.SnapShotBuf);
                } else {
                    SnapShot.SnapShotBuf[0] = L'\0';
                }
            } else {
                SnapShot.SnapShotBuf[0] = L'\0';
            }

            SnapShot.SnapShotBuf[ulMaxSnapShotSize/sizeof(WCHAR)-1] = L'\0';
            SnapShotSize = wcslen(SnapShot.SnapShotBuf);

            if (SnapShotSize > 0 ) {
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RELIABILITY, 0, KEY_ALL_ACCESS, &hKey)) {
                    RegSetValueEx(hKey,
                        REGSTR_VAL_SHUTDOWN_STATE_SNAPSHOT,
                        0,
                        REG_SZ,
                        (LPBYTE)SnapShot.SnapShotBuf,
                        SnapShotSize * sizeof(WCHAR));
                    RegCloseKey(hKey);
                }
            }
        }
    }


    /*
     * If the client is server, we need to revert so RegisterEventSourceW() can
     * succeed if the user is not in admin group.
     */
    if (m->h.ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) {
        CsrRevertToSelf();
    }
    hEventLog = RegisterEventSourceW(NULL, L"USER32");
    if (m->h.ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) {
        CsrImpersonateClient(NULL);
    }

    if (!hEventLog) {
        goto Cleanup;
    }

    /*
     * We are required to log the snapshot info (if a snopshot is taken)
     * into the data part, so we need to realloc the snapshot buf in order
     * to insert the reason code.
     */
    if (!SnapShot.SnapShotBuf || wcslen(SnapShot.SnapShotBuf) == 0) { // no snapshot, so just report reason.
        bRet = ReportEventW(hEventLog, wEventType, 0, prm->dwEventID, psid,
                    wStringCnt, sizeof(DWORD),
                    lpStrings, &SnapShot);
    } else { /* need to repack */
        DWORD dwNewBuf = (lstrlenW(SnapShot.SnapShotBuf)+1) * sizeof(WCHAR) + sizeof(DWORD);
        PWCHAR pBuf = LocalAlloc(LPTR, dwNewBuf);
        if (pBuf) {
            *((DWORD*)pBuf) = SnapShot.Reason;
            swprintf(&pBuf[2], L"%s", SnapShot.SnapShotBuf);
            LocalFree(SnapShot.SnapShotBuf);
            SnapShot.SnapShotBuf = pBuf;
            bRet = ReportEventW(hEventLog, wEventType, 0, prm->dwEventID, psid,
                        wStringCnt, dwNewBuf,
                        lpStrings, pBuf);
        }
    }
    DeregisterEventSource(hEventLog);

Cleanup:
    LocalFree(SnapShot.SnapShotBuf);
    LocalFree(psid);
    LocalFree(lpszUserDomain);
    LocalFree(lpszUserName);
    LocalFree(lpszComputerName);
    LocalFree(lpszReasonTitle);
    LocalFree(lpszComment);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\command.c ===
/*************************************************************************
*
* command.c
*
* WinStation command channel handler
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* $Author:
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

#include "ntuser.h"

#include <winsta.h>
#include <wstmsg.h>

#include <icadd.h>

extern HANDLE WinStationIcaApiPort;

extern HANDLE G_DupIcaVideoChannel;
extern HANDLE G_DupIcaCommandChannel;
extern HANDLE G_DupConsoleShadowVideoChannel;
extern HANDLE G_DupConsoleShadowCommandChannel;


extern NTSTATUS BrokenConnection(BROKENCLASS, BROKENSOURCECLASS);
extern NTSTATUS ShadowHotkey(VOID);

NTSTATUS
Win32CommandChannelThread(
    PVOID ThreadParameter)
{
    ICA_CHANNEL_COMMAND Command;
    ULONG               ActualLength;
    NTSTATUS            Status;
    ULONG               Error;
    OVERLAPPED          Overlapped;
    USERTHREAD_USEDESKTOPINFO utudi;
    BOOL bRestoreDesktop = FALSE;
    BOOL bShadowCommandChannel = (BOOL)PtrToUlong(ThreadParameter);
    HANDLE hChannel = bShadowCommandChannel ? G_DupConsoleShadowCommandChannel : G_DupIcaCommandChannel;
    HANDLE hChannelToClose = NULL; 

    for ( ; ; ) {
        RtlZeroMemory(&Overlapped, sizeof(Overlapped));

        if (!ReadFile(hChannel,
                      &Command,
                      sizeof(Command),
                      &ActualLength,
                      &Overlapped)) {

            Error = GetLastError();

            if (Error == ERROR_IO_PENDING) {
                
                /*
                 * check on the results of the asynchronous read
                 */
                if (!GetOverlappedResult(hChannel, &Overlapped,
                                         &ActualLength, TRUE)) {
                    // wait for result

                    RIPMSG1(RIP_WARNING, "Command Channel: Error 0x%x from GetOverlappedResult", GetLastError());
                    break;
                }
            } else {
                RIPMSG1(RIP_WARNING, "Command Channel: Error 0x%x from ReadFile", Error);
                break;
            }
        }

        if (ActualLength < sizeof(ICA_COMMAND_HEADER)) {
            
            RIPMSG1(RIP_WARNING, "Command Channel Thread bad length 0x%x",
                   ActualLength);
            continue;
        }

        /*
         * This is a Csrss thread with no desktop. It needs to grab a temporary one
         * before calling into win32k.
         */


        Status = STATUS_SUCCESS;
        bRestoreDesktop = FALSE;
        if (Command.Header.Command != ICA_COMMAND_BROKEN_CONNECTION && Command.Header.Command != ICA_COMMAND_SHADOW_HOTKEY) {
            if (Command.Header.Command != ICA_COMMAND_DISPLAY_IOCTL || Command.DisplayIOCtl.DisplayIOCtlFlags & DISPLAY_IOCTL_FLAG_REDRAW) {
                utudi.hThread = NULL;
                utudi.drdRestore.pdeskRestore = NULL;
                bRestoreDesktop = TRUE;
                Status = NtUserSetInformationThread(NtCurrentThread(),
                                                    UserThreadUseActiveDesktop,
                                                    &utudi, sizeof(utudi));
            }
        }

        if (NT_SUCCESS(Status)) {

            switch (Command.Header.Command) {

            case ICA_COMMAND_BROKEN_CONNECTION:
                /*
                 * broken procedure
                 */
                Status = BrokenConnection(
                            Command.BrokenConnection.Reason,
                            Command.BrokenConnection.Source);

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "BrokenConnection failed with Status 0x%x", Status);
                }
                break;

            case ICA_COMMAND_REDRAW_RECTANGLE:
                /*
                 * setfocus ???
                 */
                if (ActualLength < sizeof(ICA_COMMAND_HEADER) + sizeof(ICA_REDRAW_RECTANGLE)) {

                    RIPMSG1(RIP_WARNING, "Command Channel: redraw rect bad length %d", ActualLength);
                    break;
                }
                Status = NtUserRemoteRedrawRectangle(
                             Command.RedrawRectangle.Rect.Left,
                             Command.RedrawRectangle.Rect.Top,
                             Command.RedrawRectangle.Rect.Right,
                             Command.RedrawRectangle.Rect.Bottom);

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "NtUserRemoteRedrawRectangle failed with Status 0x%x", Status);
                }
                break;

            case ICA_COMMAND_REDRAW_SCREEN: // setfocus

                Status = NtUserRemoteRedrawScreen();

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "NtUserRemoteRedrawScreen failed with Status 0x%x", Status);
                }
                break;

            case ICA_COMMAND_STOP_SCREEN_UPDATES: // killfocus

                Status = NtUserRemoteStopScreenUpdates();

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "NtUserRemoteStopScreenUpdates failed with Status 0x%x", Status);
                } else {
                    IO_STATUS_BLOCK IoStatus;

                    NtDeviceIoControlFile( 
                                    bShadowCommandChannel ? G_DupConsoleShadowVideoChannel 
                                        : G_DupIcaVideoChannel,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &IoStatus,
                                           IOCTL_VIDEO_ICA_STOP_OK,
                                           NULL,
                                           0,
                                           NULL,
                                           0);
                }
                break;

            case ICA_COMMAND_SHADOW_HOTKEY: // shadow hotkey

                Status = ShadowHotkey();

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "ShadowHotkey failed with Status 0x%x", Status);
                }
                break;

            case ICA_COMMAND_DISPLAY_IOCTL:

                Status = NtUserCtxDisplayIOCtl(
                             Command.DisplayIOCtl.DisplayIOCtlFlags,
                             &Command.DisplayIOCtl.DisplayIOCtlData[0],
                             Command.DisplayIOCtl.cbDisplayIOCtlData);

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "NtUserCtxDisplayIOCtl failed with Status 0x%x", Status);
                }
                break;

            default:
                RIPMSG1(RIP_WARNING, "Command Channel: Bad Command 0x%x", Command.Header.Command);
                break;
            }

            /*
             * Release the temporary desktop.
             */
            if (bRestoreDesktop) {
                NTSTATUS retStatus;
                retStatus = NtUserSetInformationThread(NtCurrentThread(),
                                           UserThreadUseDesktop,
                                           &utudi,
                                           sizeof(utudi));
            }
        }
    }

    if (!bShadowCommandChannel) {
        /*
         * Close command channel LPC port if there is one.
         */
        if (WinStationIcaApiPort) {
            NtClose(WinStationIcaApiPort);
            WinStationIcaApiPort = NULL;
        }
    }

    // We have to close the commandchannel handle here
    if (hChannel != NULL) {
        NtClose(hChannel);
    }

    // We have to close the relevant Video Channel here
    hChannelToClose = ( bShadowCommandChannel ? G_DupConsoleShadowVideoChannel : G_DupIcaVideoChannel );
    if (hChannelToClose != NULL) {
        NtClose(hChannelToClose);
    }

    UserExitWorkerThread(STATUS_SUCCESS);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\globals.c ===
/****************************** Module Header ******************************\
* Module Name: globals.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the server's global variables.  One must be
* executing on the server's context to manipulate any of these variables.
* Serializing access to them is also a good idea.
*
* History:
* 10-15-90 DarrinM      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

HANDLE ghModuleWin;
CRITICAL_SECTION gcsUserSrv;

DWORD gCmsHungAppTimeout;
DWORD gCmsWaitToKillTimeout;
DWORD gdwHungToKillCount;
BOOL gfAutoEndTask;
BOOL gbExitInProgress;

/*
 * These globals are used when shutting down the services process.
 */
DWORD gdwServicesProcessId;
DWORD gdwServicesWaitToKillTimeout;
DWORD gdwProcessTerminateTimeout;

/*
 * logon process id
 */
DWORD gIdLogon;

/*
 * Hard error stuff
 */
PHARDERRORINFO gphiList;
DWORD gdwHardErrorThreadId;
HANDLE gNtDllHandle;
HANDLE gEventSource;
PWSTR gpwszaSUCCESS;
PWSTR gpwszaSYSTEM_INFORMATION;
PWSTR gpwszaSYSTEM_WARNING;
PWSTR gpwszaSYSTEM_ERROR;

/*
 * EndTask / Shutdown stuff
 */
DWORD gdwThreadEndSession;
HANDLE gheventCancel;
HANDLE gheventCancelled;

ULONG gSessionId;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\exports.c ===
/**************************** Module Header ********************************\
* Module Name: exports.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Routines exported from winsrv.dll
*
* History:
* 03-04-95 JimA                Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* _UserSoundSentry
*
* Private API for BASE to use for SoundSentry support.
*
* History:
* 08-02-93 GregoryW         Created.
\***************************************************************************/
BOOL
_UserSoundSentry(
    UINT uVideoMode)
{
    UNREFERENCED_PARAMETER(uVideoMode);

    return NT_SUCCESS(NtUserSoundSentry());
}

/***************************************************************************\
* _UserTestTokenForInteractive
*
* Returns TRUE if the token passed represents an interactive user logged
* on by winlogon, otherwise FALSE
*
* The token handle passed must have TOKEN_QUERY access.
*
* History:
* 05-06-92 Davidc       Created
\***************************************************************************/

NTSTATUS
_UserTestTokenForInteractive(
    HANDLE Token,
    PLUID pluidCaller
    )
{
    PTOKEN_STATISTICS pStats;
    ULONG BytesRequired;
    NTSTATUS Status;

    /*
     * Get the session id of the caller.
     */
    Status = NtQueryInformationToken(
                 Token,                     // Handle
                 TokenStatistics,           // TokenInformationClass
                 NULL,                      // TokenInformation
                 0,                         // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        return Status;
        }

    //
    // Allocate space for the user info
    //

    pStats = (PTOKEN_STATISTICS)LocalAlloc(LPTR, BytesRequired);
    if (pStats == NULL) {
        return Status;
        }

    //
    // Read in the user info
    //

    Status = NtQueryInformationToken(
                 Token,             // Handle
                 TokenStatistics,       // TokenInformationClass
                 pStats,                // TokenInformation
                 BytesRequired,         // TokenInformationLength
                 &BytesRequired         // ReturnLength
                 );

    if (NT_SUCCESS(Status)) {
        if (pluidCaller != NULL)
             *pluidCaller = pStats->AuthenticationId;

        /*
         * A valid session id has been returned.  Compare it
         * with the id of the logged on user.
         */
        Status = NtUserTestForInteractiveUser(&pStats->AuthenticationId);
#ifdef LATER
        if (pStats->AuthenticationId.QuadPart == pwinsta->luidUser.QuadPart)
            Status = STATUS_SUCCESS;
        else
            Status = STATUS_ACCESS_DENIED;
#endif
    }

    LocalFree(pStats);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\makefile.inc ===
..\precomp.h: ..\usersrv.h ..\globals.h $(O)\strid.h  ..\..\inc\user.h ..\..\inc\csrmsg.h \
              $(WINDOWS_INC_PATH)\winuserp.h  $(WINCORE_PATH)\w32inc\winuserk.h

$(O)\strid.h $(O)\res.rc $(O)\msg00001.bin: ..\strid.mc
    mc -v -U ..\strid.mc -r $(O) -h $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\globals.h ===
/****************************** Module Header ******************************\
* Module Name: globals.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the server's global variables
* One must be executing on the server's context to manipulate
* any of these variables or call any of these functions.  Serializing access
* to them is also a good idea.
*
* History:
* 10-15-90 DarrinM      Created.
\***************************************************************************/

#ifndef _GLOBALS_
#define _GLOBALS_

extern CRITICAL_SECTION gcsUserSrv;
extern BOOL gfAutoEndTask;
extern BOOL gbExitInProgress;

/*
 * Logon process id.
 */
extern DWORD gIdLogon;

/*
 * Hard error globals.
 */
extern DWORD gdwHardErrorThreadId;
extern HANDLE gNtDllHandle;
extern HANDLE gEventSource;
extern PHARDERRORINFO gphiList;

/*
 * EndTask / Shutdown stuff.
 */
extern DWORD gdwThreadEndSession;
extern HANDLE gheventCancel;
extern HANDLE gheventCancelled;
extern PWSTR gpwszaSUCCESS;
extern PWSTR gpwszaSYSTEM_INFORMATION;
extern PWSTR gpwszaSYSTEM_WARNING;
extern PWSTR gpwszaSYSTEM_ERROR;

extern ULONG gSessionId;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\icamsg.c ===
/*************************************************************************\
*
* icamsg.c
*
* Process ICA send message requests
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* $Author:
*
\*************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <dbt.h>
#include <ntdddisk.h>
#include "ntuser.h"

#include <winsta.h>
#include <wstmsg.h>


#define MAX_STRING_BYTES (512 * sizeof(WCHAR))

/*
 * maximum messages (messagebox) a session can have pending.
 */
#define MAX_MESSAGES_PER_SESSION 25

NTSTATUS RemoteMessageThread(
    PVOID pVoid);

VOID UserHardErrorEx(
    PCSR_THREAD pt,
    PHARDERROR_MSG pmsg,
    PCTXHARDERRORINFO pCtxHEInfo);

NTSTATUS ReplyMessageToTerminalServer(
    NTSTATUS ReplyStatus,
    PNTSTATUS pStatus,
    ULONG Response,
    PULONG pResponse,
    HANDLE hEvent);

PCTXHARDERRORINFO gpchiList;
HANDLE g_hDoMessageEvent;
ULONG PendingMessages;

/******************************************************************************\
* RemoteDoMessage
\******************************************************************************/
NTSTATUS
RemoteDoMessage(
    PWINSTATION_APIMSG pMsg)
{
    WINSTATIONSENDMESSAGEMSG * pSMsg = &pMsg->u.SendMessage;
    PCTXHARDERRORINFO pchi;
    NTSTATUS Status;
    CLIENT_ID ClientId;
    static HANDLE hMessageThread = NULL;

    /*
     * if termsrv rpc is going to wait we must have status and event.
     * also if we are not going to wait, we must not have status and event.
     */
    UserAssert(pSMsg->DoNotWait == (pSMsg->pStatus == 0));
    UserAssert(pSMsg->DoNotWait == (pSMsg->hEvent == 0));
    UserAssert(PendingMessages <= MAX_MESSAGES_PER_SESSION);

    /*
     * are we being flooded with messages?
     */
    if (PendingMessages == MAX_MESSAGES_PER_SESSION) {
        return STATUS_UNSUCCESSFUL;
    }

    /*
     *  Create list entry
     */
    if ((pchi = LocalAlloc(LPTR, sizeof(CTXHARDERRORINFO))) == NULL) {
        goto memError;
    } else if ((pchi->pTitle = LocalAlloc(LPTR, pSMsg->TitleLength + sizeof(WCHAR))) == NULL) {
        goto memError;
    } else if ((pchi->pMessage = LocalAlloc(LPTR, pSMsg->MessageLength + sizeof(WCHAR))) == NULL) {
        goto memError;
    }

    /*
     * Increment our pending message count.
     */
    EnterCrit();
    PendingMessages++;
    pchi->CountPending = TRUE;

    /*
     * Initialize
     */
    pchi->ClientId  = pMsg->h.ClientId;
    pchi->MessageId = pMsg->MessageId;
    pchi->Timeout   = pSMsg->Timeout;
    pchi->pStatus   = pSMsg->pStatus;
    pchi->pResponse = pSMsg->pResponse;
    pchi->hEvent    = pSMsg->hEvent;
    pchi->DoNotWait = pSMsg->DoNotWait;
    pchi->Style     = pSMsg->Style;
    pchi->DoNotWaitForCorrectDesktop = pSMsg->DoNotWaitForCorrectDesktop;

    pchi->pTitle[pSMsg->TitleLength / sizeof(WCHAR)] = L'\0';
    RtlCopyMemory(pchi->pTitle, pSMsg->pTitle, pSMsg->TitleLength);

    pchi->pMessage[pSMsg->MessageLength / sizeof(WCHAR)] = L'\0';
    RtlCopyMemory(pchi->pMessage, pSMsg->pMessage, pSMsg->MessageLength);

    /*
     * Link in at the head.
     */
    pchi->pchiNext = gpchiList;
    gpchiList = pchi;

    LeaveCrit();

    /*
     * Start message thread if not running, otherwise signal thread.
     */
    if (hMessageThread == NULL) {
        Status = RtlCreateUserThread(NtCurrentProcess(),
                                     NULL,
                                     TRUE,
                                     0,
                                     0,
                                     0,
                                     RemoteMessageThread,
                                     NULL,
                                     &hMessageThread,
                                     &ClientId);

        if (NT_SUCCESS(Status)) {
            /*
             *  Add thread to server thread pool.
             */
            CsrAddStaticServerThread(hMessageThread, &ClientId, 0);
            NtResumeThread(hMessageThread, NULL);
        } else {
            RIPMSGF1(RIP_WARNING,
                     "Cannot start RemoteMessageThread, Status 0x%x",
                     Status);
        }
    } else {
        if (g_hDoMessageEvent == NULL) {
            return STATUS_UNSUCCESSFUL;
        }

        Status = NtSetEvent(g_hDoMessageEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            RIPMSGF1(RIP_WARNING,
                     "Error NtSetEvent failed, Status = 0x%x",
                     Status);
            return Status;
        }
    }

    return STATUS_SUCCESS;

memError:

    if (pchi) {
        if (pchi->pMessage) {
            LocalFree(pchi->pMessage);
        }

        if (pchi->pTitle) {
            LocalFree(pchi->pTitle);
        }

        LocalFree(pchi);
    }

    if (!pSMsg->DoNotWait) {
        ReplyMessageToTerminalServer(
                STATUS_NO_MEMORY,
                pSMsg->pStatus,
                0, // response is NA at this case, since we havent gotten one.
                pSMsg->pResponse,
                pSMsg->hEvent);
    }

    return STATUS_NO_MEMORY;
}


/*******************************************************************************
 *
 *  RemoteDoLoadStringNMessage
 *
 * ENTRY:
 *
 * EXIT:
 *    STATUS_SUCCESS - successful
 *
 ******************************************************************************/

NTSTATUS
RemoteDoLoadStringNMessage(
    PWINSTATION_APIMSG pMsg)
{
    WINSTATIONLOADSTRINGMSG * pSMsg = &pMsg->u.LoadStringMessage;
    PCTXHARDERRORINFO pchi = NULL;
    NTSTATUS Status;
    CLIENT_ID ClientId;
    static HANDLE hMessageThread = NULL;
    WCHAR *szText = NULL;
    WCHAR *szTitle = NULL;
    WCHAR *FUSDisconnectMsg = NULL;
    int cchTitle, cchMessage;
    BOOL f;

    /*
     * If termsrv rpc is going to wait we must have status and event. Also
     * if we are not going to wait, we must not have status and event.
     */
    UserAssert(pSMsg->DoNotWait == (pSMsg->pStatus == 0));
    UserAssert(pSMsg->DoNotWait == (pSMsg->hEvent == 0));
    UserAssert(PendingMessages <= MAX_MESSAGES_PER_SESSION);

    //
    // Allocate the strings needed to display the Popup MessageBox.
    //
    if ((szTitle = LocalAlloc(LMEM_FIXED, MAX_STRING_BYTES)) == NULL) {
        goto NoMem;
    }

    if ((FUSDisconnectMsg = LocalAlloc(LMEM_FIXED, MAX_STRING_BYTES)) == NULL) {
        goto NoMem;
    }

    szText = ServerLoadString(ghModuleWin, pSMsg->TitleId, NULL, &f);
    cchTitle = wsprintf(szTitle, L"%s", szText);
    cchTitle = (cchTitle + 1) * sizeof(WCHAR);

    szText = ServerLoadString(ghModuleWin, pSMsg->MessageId, NULL, &f);
    cchMessage = wsprintf(FUSDisconnectMsg, L"%s\\%s %s", pSMsg->pDomain, pSMsg->pUserName, szText);
    cchMessage = (cchMessage + 1) * sizeof(WCHAR);

    /*
     * Create list entry.
     */
    if ((pchi = LocalAlloc(LPTR, sizeof(CTXHARDERRORINFO))) == NULL) {
        goto NoMem;
    } else if ((pchi->pTitle = LocalAlloc(LPTR, cchTitle + sizeof(WCHAR))) == NULL) {
        goto NoMem;
    } else if ((pchi->pMessage = LocalAlloc(LPTR, cchMessage + sizeof(WCHAR))) == NULL) {
        goto NoMem;
    }

    /*
     * Initialize.
     */

    pchi->ClientId  = pMsg->h.ClientId;
    pchi->MessageId = pMsg->MessageId;
    pchi->Timeout   = pSMsg->Timeout;
    pchi->pResponse = pSMsg->pResponse;
    pchi->pStatus   = pSMsg->pStatus;
    pchi->hEvent    = pSMsg->hEvent;
    pchi->DoNotWait = pSMsg->DoNotWait;
    pchi->Style     = pSMsg->Style;
    pchi->CountPending = FALSE;
    pchi->DoNotWaitForCorrectDesktop = FALSE;

    pchi->pTitle[cchTitle / sizeof(WCHAR)] = L'\0';
    RtlCopyMemory(pchi->pTitle, szTitle, cchTitle);

    pchi->pMessage[cchMessage / sizeof(WCHAR)] = L'\0';
    RtlCopyMemory(pchi->pMessage, FUSDisconnectMsg, cchMessage);

    /*
     * Link in at the head.
     */
    EnterCrit();

    pchi->pchiNext = gpchiList;
    gpchiList = pchi;

    LeaveCrit();

    LocalFree(szTitle);
    LocalFree(FUSDisconnectMsg);

    /*
     * Start message thread if not running, otherwise signal thread.
     */
    if (hMessageThread == NULL) {
        Status = RtlCreateUserThread(NtCurrentProcess(),
                                     NULL,
                                     TRUE,
                                     0,
                                     0,
                                     0,
                                     RemoteMessageThread,
                                     NULL,
                                     &hMessageThread,
                                     &ClientId);
        if (NT_SUCCESS(Status)) {
            /*
             * Add thread to server thread pool.
             */
            CsrAddStaticServerThread(hMessageThread, &ClientId, 0);
            NtResumeThread(hMessageThread, NULL);
        } else {
            RIPMSGF1(RIP_WARNING,
                     "Cannot start RemoteMessageThread, Status 0x%x",
                     Status);
        }
    } else {
        if (g_hDoMessageEvent == NULL) {
            return STATUS_UNSUCCESSFUL;
        }

        Status = NtSetEvent(g_hDoMessageEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            RIPMSGF2(RIP_WARNING,
                     "NtSetEvent(0x%x) failed with Status 0x%x",
                     g_hDoMessageEvent,
                     Status);
            return Status;
        }
    }

    return STATUS_SUCCESS;

NoMem:
    if (szTitle) {
        LocalFree(szTitle);
    }

    if (FUSDisconnectMsg) {
        LocalFree(FUSDisconnectMsg);
    }

    if (pchi) {
        if (pchi->pMessage) {
            LocalFree(pchi->pMessage);
        }

        if (pchi->pTitle) {
            LocalFree(pchi->pTitle);
        }

        LocalFree(pchi);
    }

    if (!pSMsg->DoNotWait) {
        ReplyMessageToTerminalServer(
                STATUS_NO_MEMORY,
                pSMsg->pStatus,
                0, // response is NA at this case, since we havent gotten one.
                pSMsg->pResponse,
                pSMsg->hEvent);
    }

    return STATUS_NO_MEMORY;
}


/******************************************************************************\
* RemoteMessageThread
\******************************************************************************/
NTSTATUS RemoteMessageThread(
    PVOID pVoid)
{
    HARDERROR_MSG hemsg;
    PCTXHARDERRORINFO pchi, *ppchi;
    UNICODE_STRING Message, Title;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;

    UNREFERENCED_PARAMETER(pVoid);

    /*
     * Create sync event.
     */
    InitializeObjectAttributes(&ObjA, NULL, 0, NULL, NULL);
    Status = NtCreateEvent(&g_hDoMessageEvent, EVENT_ALL_ACCESS, &ObjA,
                           NotificationEvent, FALSE);

    if (!NT_SUCCESS(Status)) {
        RIPMSGF1(RIP_WARNING, "NtCreateEvent failed, Status = 0x%x", Status);
        goto Exit;
    }

    while (!gbExitInProgress) {
        EnterCrit();

        if (gpchiList != NULL) {

            /*
             * Find last entry
             */
            for (ppchi = &gpchiList; *ppchi != NULL && (*ppchi)->pchiNext != NULL;
                 ppchi = &(*ppchi)->pchiNext) {
                 /* do nothing */;
            }

            /*
             * Found it.
             */
            if ((pchi = *ppchi) != NULL) {

                /*
                 * Unlink from the list.
                 */
                for (ppchi = &gpchiList; *ppchi != NULL && *ppchi != pchi;
                    ppchi = &(*ppchi)->pchiNext) {
                    /* do nothing */;
                }

                if (*ppchi != NULL) {
                    *ppchi = pchi->pchiNext;
                }

                LeaveCrit();

                /*
                 *  Make strings unicode
                 */
                RtlInitUnicodeString(&Title, pchi->pTitle);
                RtlInitUnicodeString(&Message, pchi->pMessage);

                /*
                 *  Initialize harderror message struct
                 */
                hemsg.h.ClientId = pchi->ClientId;
                hemsg.Status = STATUS_SERVICE_NOTIFICATION;
                hemsg.NumberOfParameters = 3;
                hemsg.UnicodeStringParameterMask = 3;
                hemsg.ValidResponseOptions = OptionOk;
                hemsg.Parameters[0] = (ULONG_PTR)&Message;
                hemsg.Parameters[1] = (ULONG_PTR)&Title;
                hemsg.Parameters[2] = (ULONG_PTR)pchi->Style;

                /*
                 * Place message in harderror queue.
                 */
                UserHardErrorEx(NULL, &hemsg, pchi);
            } else {
                LeaveCrit();
            }
        } else {
            LeaveCrit();
        }

        if (gpchiList == NULL) {
            UserAssert(g_hDoMessageEvent != NULL);

            Status = NtWaitForSingleObject(g_hDoMessageEvent, FALSE, NULL);

            UserAssert(NT_SUCCESS(Status));

            NtResetEvent(g_hDoMessageEvent, NULL);
        }
    }

    NtClose(g_hDoMessageEvent);
    g_hDoMessageEvent = NULL;

Exit:
    UserExitWorkerThread(Status);
    return Status;
}

/******************************************************************************\
* HardErrorRemove
\******************************************************************************/
VOID HardErrorRemove(
    PCTXHARDERRORINFO pchi)
{
    /*
     * Notify ICASRV's RPC thread if waiting.
     */
    if (!pchi->DoNotWait) {
        ReplyMessageToTerminalServer(
                STATUS_SUCCESS,
                pchi->pStatus,
                pchi->Response,
                pchi->pResponse,
                pchi->hEvent);
    }

    EnterCrit();

    if (pchi->CountPending) {
        UserAssert(PendingMessages <= MAX_MESSAGES_PER_SESSION);
        PendingMessages--;
    }

    LocalFree(pchi->pMessage);
    LocalFree(pchi->pTitle);
    LocalFree(pchi);

    LeaveCrit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\instdev.c ===
/**************************************************************************\
* Module Name: instdev.c
*
* Device handling routine for CSRSS.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Created: 13-Mar-97
*
* History:
*   13-Mar-97 created by PaulaT
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "ntuser.h"
#include <dbt.h>
#include <pnpmgr.h>


/**************************************************************************\
* SrvDeviceEvent
*
* User-mode PNP manager (in services.exe) has a message to deliver to an
* app that has registered for this notification but services.exe isn't
* in WinSta0\Default so we need a CSRSS thread to simply send the message.
*
* PaulaT    06/04/97    Created.
* JasonSch  02/22/01    Removed bogus try/except.
\**************************************************************************/
ULONG
SrvDeviceEvent(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    NTSTATUS Status;
    PDEVICEEVENTMSG a = (PDEVICEEVENTMSG)&m->u.ApiMessageData;
    USERTHREAD_USEDESKTOPINFO utudi;

    UNREFERENCED_PARAMETER(ReplyStatus);

    //
    // Set the desktop to the active desktop before sending the
    // message.
    //

    utudi.hThread = NULL;
    utudi.drdRestore.pdeskRestore = NULL;
    Status = NtUserSetInformationThread(NtCurrentThread(),
                                        UserThreadUseActiveDesktop,
                                        &utudi, sizeof(utudi));
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "SrvDeviceEvent: NtUserSetInformationThread failed 0x%x\n", Status);
        goto Exit;
    }

    //
    // Verify the window handle is still valid. If not, let the caller know
    // so it can be purged from the notification window list that the
    // user-mode pnp manager keeps.
    //

    if (a->hWnd != HWND_BROADCAST && !IsWindow(a->hWnd)) {
        Status = STATUS_INVALID_HANDLE;
        goto ResetDesktop;
    }

    if (a->dwFlags) {

        //
        // This is a query so we have to send the message but use
        // timeouts so an app can't stall us forever.
        //

        RIPMSG3(RIP_VERBOSE, "SrvDeviceEvent: Sending WM_DEVICECHANGE to 0x%x, w 0x%p, l 0x%p",
                a->hWnd,
                a->wParam,
                a->lParam);


        if (!SendMessageTimeout(a->hWnd, WM_DEVICECHANGE, a->wParam, a->lParam,
                                SMTO_ABORTIFHUNG | SMTO_NORMAL,
                                PNP_NOTIFY_TIMEOUT, &a->dwResult)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    } else {
        //
        // It's not a query so just post it and return. We don't
        // care what the app returns.
        //

        RIPMSG3(RIP_VERBOSE, "SrvDeviceEvent: Posting WM_DEVICECHANGE to 0x%x, w 0x%p, l 0x%p",
                a->hWnd,
                a->wParam,
                a->lParam);

        if (!PostMessage(a->hWnd, WM_DEVICECHANGE, a->wParam, a->lParam)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

ResetDesktop:

    //
    // Reset this thread's desktop back to NULL before returning. This
    // decrements the desktop's reference count.
    //

    NtUserSetInformationThread(NtCurrentThread(),
                               UserThreadUseDesktop,
                               &utudi, sizeof(utudi));

Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\msgbeep.c ===
/****************************** Module Header ******************************\
* Module Name: msgbeep.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains ConsolePlaySound.
*
* History:
*  06-26-91 NigelT      Created it with some wood and a few nails.
*  05-07-92 SteveDav    Getting closer to the real thing.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include "ntuser.h"

/***************************************************************************\
*
* ConsolePlaySound
*
* Play the Open sound for console applications.
*
\***************************************************************************/
VOID ConsolePlaySound(
    VOID)
{
    NtUserCallOneParam(USER_SOUND_OPEN, SFI_PLAYEVENTSOUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>
#include "usersrv.h"
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>
#include <stdio.h>
#include "heap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\server\harderr.c ===
/**************************** Module Header ********************************\
* Module Name: harderr.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Hard error handler
*
* History:
* 07-03-91 JimA                Created scaffolding.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntlpcapi.h>
#include <winsta.h>

VOID UserHardErrorEx(
    PCSR_THREAD pt,
    PHARDERROR_MSG pmsg,
    PCTXHARDERRORINFO pCtxHEInfo);

VOID ProcessHardErrorRequest(
    BOOL fNewThread);


#ifdef PRERELEASE
HARDERRORINFO hiLastProcessed;
#endif

CONST UINT wIcons[] = {
    0,
    MB_ICONINFORMATION,
    MB_ICONEXCLAMATION,
    MB_ICONSTOP
};

CONST UINT wOptions[] = {
    MB_ABORTRETRYIGNORE,
    MB_OK,
    MB_OKCANCEL,
    MB_RETRYCANCEL,
    MB_YESNO,
    MB_YESNOCANCEL,
    MB_OK,              // OptionShutdownSystem
    MB_OK,              // OptionOkNoWait
    MB_CANCELTRYCONTINUE
};

CONST DWORD dwResponses[] = {
    ResponseNotHandled, // MessageBox error
    ResponseOk,         // IDOK
    ResponseCancel,     // IDCANCEL
    ResponseAbort,      // IDABORT
    ResponseRetry,      // IDRETRY
    ResponseIgnore,     // IDIGNORE
    ResponseYes,        // IDYES
    ResponseNo,         // IDNO
    ResponseNotHandled, // Error as IDCLOSE can't show up
    ResponseNotHandled, // error as IDHELP can't show up
    ResponseTryAgain,   // IDTRYAGAIN
    ResponseContinue    // IDCONTINUE
};

CONST DWORD dwResponseDefault[] = {
    ResponseAbort,      // OptionAbortRetryIgnore
    ResponseOk,         // OptionOK
    ResponseOk,         // OptionOKCancel
    ResponseCancel,     // OptionRetryCancel
    ResponseYes,        // OptionYesNo
    ResponseYes,        // OptionYesNoCancel
    ResponseOk,         // OptionShutdownSystem
    ResponseOk,         // OptionOKNoWait
    ResponseCancel      // OptionCancelTryContinue
};

/*
 *  Citrix SendMessage entry point to harderror handler and cleanup routine
 */
VOID HardErrorInsert(PCSR_THREAD, PHARDERROR_MSG, PCTXHARDERRORINFO);
VOID HardErrorRemove(PCTXHARDERRORINFO);

/***************************************************************************\
* LogErrorPopup
*
* Histo