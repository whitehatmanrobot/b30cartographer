           //

            Table[0].Link.EntryCount = PO_MAX_RANGE_ARRAY-1;
            Table = Table[0].Link.Next;
            if (!Table) {
                PopInternalError (POP_HIBER);
            }
            Index = 1;
        }

        Table[Index].Range.PageNo    = 0;
        Table[Index].Range.StartPage = StartPage;
        Table[Index].Range.EndPage   = StartPage + Length;
        Table[Index].Range.CheckSum  = 0;

        //
        // Handle the corner case where the last run exactly matches
        // the end of the bitmap.
        //
        if (StartPage + Length == HiberContext->MemoryMap.SizeOfBitMap) {
            break;
        }

        Length = RtlFindNextForwardRunClear(&HiberContext->MemoryMap,
                                            (ULONG)(StartPage + Length),
                                            &StartIndex);
        StartPage = StartIndex;
    }

    Table[0].Link.EntryCount = Index;
    return HiberContext->Status;
}

NTSTATUS
PopSaveHiberContext (
    IN PPOP_HIBER_CONTEXT  HiberContext
    )
/*++

Routine Description:

    Called at HIGH_LEVEL just before the sleep operation to
    make a snap shot of the system memory as defined by
    the memory image array.   Cloning and applying
    checksum of the necessary pages occurs here.

Arguments:

    HiberContext    - The memory map

Return Value:

    Status

--*/
{
    POP_MCB_CONTEXT         CurrentMcb;
    PPO_MEMORY_IMAGE        MemImage;
    PPOP_MEMORY_RANGE       Range;
    PPO_MEMORY_RANGE_ARRAY  Table;
    ULONG                   Index;
    PFN_NUMBER              sp, ep;
    DUMP_MDL                DumpMdl;
    PMDL                    Mdl;
    PUCHAR                  cp;
    PLIST_ENTRY             Link;
    PFN_NUMBER              PageNo;
    PFN_NUMBER              Pages;
    NTSTATUS                Status;
    PPFN_NUMBER             TablePage;
    ULONGLONG               StartCount;


    //
    // Hal had better have interrupts disabled here
    //

    if (KeDisableInterrupts() != FALSE) {
        PopInternalError (POP_HIBER);
    }

    MemImage = HiberContext->MemoryImage;
    HiberContext->CurrentMcb = &CurrentMcb;

    //
    // Get the current state of the processor
    //

    RtlZeroMemory(&PoWakeState, sizeof(KPROCESSOR_STATE));
    KeSaveStateForHibernate(&PoWakeState);
    HiberContext->WakeState = &PoWakeState;

    //
    // If there's something already in the memory image signature then
    // the system is now waking up.
    //

    if (MemImage->Signature) {

#ifndef HIBERNATE_PRESERVE_BPS
        //
        // If the debugger was active, reset it
        //

        if (KdDebuggerEnabled  &&  !KdPitchDebugger) {
            KdDebuggerEnabled = FALSE;
            KdInitSystem (0, NULL);
        }
#endif // HIBERNATE_PRESERVE_BPS

        //
        // Loader feature to breakin to the debugger when someone
        // presses the space bar while coming back from hibernate
        //

        if (KdDebuggerEnabled) {

            if (MemImage->Signature == PO_IMAGE_SIGNATURE_BREAK)
            {
                DbgBreakPoint();
            }
            //
            // Notify the debugger we are coming back from hibernate
            //

        }

        return STATUS_WAKE_SYSTEM;
    }

    //
    // Set a non-zero value in the signature for the next time
    //

    MemImage->Signature += 1;

    //
    // Initialize hibernation driver stack
    //
    // N.B. We must reset the display and do any INT10 here. Otherwise
    // the realmode stack in the HAL will get used to do the callback
    // later and that memory will be modified.
    //

    if (HiberContext->WriteToFile) {

        if (InbvIsBootDriverInstalled()) {

            PUCHAR Bitmap1, Bitmap2;

            Bitmap1 = InbvGetResourceAddress(2); // hibernation bitmap
            Bitmap2 = InbvGetResourceAddress(5); // logo bitmap

            InbvEnableDisplayString(TRUE);
            InbvAcquireDisplayOwnership();
            InbvResetDisplay();  // required to reset display
            InbvSolidColorFill(0,0,639,479,0);

            if (Bitmap1 && Bitmap2) {
                InbvBitBlt(Bitmap1, 190, 279);
                InbvBitBlt(Bitmap2, 217, 111);
            }

            InbvSetProgressBarSubset(0, 100);
            InbvSetProgressBarCoordinates(303,282);
        } else {
            InbvResetDisplay(); // required to reset display
        }

        StartCount = HIBER_GET_TICK_COUNT(NULL);
        Status = IoInitializeDumpStack (HiberContext->DumpStack, NULL);
        HiberContext->PerfInfo.InitTicks += HIBER_GET_TICK_COUNT(NULL) - StartCount;

        if (!NT_SUCCESS(Status)) {
            PoPrint (PO_HIBERNATE, ("PopSave: dump driver initialization failed %08x\n", Status));
            return Status;
        }
    }

    PERFINFO_HIBER_PAUSE_LOGGING();

    //          **************************************
    //          FROM HERE OUT NO MEMORY CAN BE EDITED
    //          **************************************
    PoHiberInProgress = TRUE;

    //
    // From here out no memory can be edited until the system wakes up, unless
    // that memory has been explicitly accounted for.  The list of memory which
    // is allowed to be edited is:
    //
    //      - the local stack on each processor
    //      - the kernel debuggers global data
    //      - the page containing the 16 PTEs used by MM for MmMapMemoryDumpMdl
    //      - the restoration table pages
    //      - the page containing the MemImage structure
    //      - the page containing IoPage
    //


    //
    // Clone required pages
    // (note the MemImage srtucture present at system wake will
    // be the one cloned here)
    //

    Link = HiberContext->ClonedRanges.Flink;
    while (Link != &HiberContext->ClonedRanges) {
        Range = CONTAINING_RECORD (Link, POP_MEMORY_RANGE, Link);
        Link = Link->Flink;

        ASSERT(Range->CloneVa);
        cp = Range->CloneVa;
        sp = Range->StartPage;
        ep = Range->EndPage;
        Mdl = (PMDL) DumpMdl;

        while (sp < ep) {
            PopCreateDumpMdl (Mdl, sp, ep);
            memcpy (cp, Mdl->MappedSystemVa, Mdl->ByteCount);
            cp += Mdl->ByteCount;
            sp += Mdl->ByteCount >> PAGE_SHIFT;
        }
    }

    //
    // Assign page numbers to ranges
    //
    // N.B. We do this here to basically prove that it can be done
    //      and to gather some statistics. With the addition of compression,
    //      the PageNo field of the Table entries is only applicable to the
    //      table pages since uncertain compression ratios do not allow us to
    //      predict where each memory range will be written.
    //

    TablePage = &MemImage->FirstTablePage;
    Table  = HiberContext->TableHead;
    PageNo = PO_FIRST_RANGE_TABLE_PAGE;
    while (Table) {
        *TablePage = PageNo;
        PageNo += 1;

        for (Index=1; Index <= Table[0].Link.EntryCount; Index++) {
            Table[Index].Range.PageNo = PageNo;
            Pages = Table[Index].Range.EndPage - Table[Index].Range.StartPage;
            PageNo += Pages;
            MemImage->TotalPages += Pages;
        }

        TablePage = &Table[0].Link.NextTable;
        Table = Table[0].Link.Next;
    }
    MemImage->LastFilePage = PageNo;

    PoPrint (PO_HIBERNATE, ("PopSave: NoFree pages %08x\n", MemImage->NoFreePages));
    PoPrint (PO_HIBERNATE, ("PopSave: Memory pages %08x (%dMB)\n", MemImage->TotalPages, MemImage->TotalPages/(PAGE_SIZE/16)));
    PoPrint (PO_HIBERNATE, ("PopSave: File   pages %08x (%dMB)\n", MemImage->LastFilePage, MemImage->LastFilePage/(PAGE_SIZE/16)));
    PoPrint (PO_HIBERNATE, ("PopSave: HiberPte %08x for %x\n", MemImage->HiberVa, MemImage->NoHiberPtes));

    //
    // File should be large enough, but check
    //

    if (HiberContext->WriteToFile  &&  PageNo > PopHiberFile.FilePages) {
        PoPrint (PO_HIBERNATE, ("PopSave: File too small - need %x\n", PageNo));
        return STATUS_DISK_FULL;
    }

    //
    // Write the hiberfile image
    //

    Status = PopWriteHiberImage (HiberContext, MemImage, &PopHiberFile);

    PERFINFO_HIBER_DUMP_PERF_BUFFER();

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // If debugging, do it again into a second image
    //

    if (PopSimulate & POP_DEBUG_HIBER_FILE) {
        Status = PopWriteHiberImage (HiberContext, MemImage, &PopHiberFileDebug);
    }

    return Status;
}


NTSTATUS
PopWriteHiberImage (
    IN PPOP_HIBER_CONTEXT   HiberContext,
    IN PPO_MEMORY_IMAGE     MemImage,
    IN PPOP_HIBER_FILE      HiberFile
    )
{
    PPOP_MCB_CONTEXT        CMcb;
    PPO_MEMORY_RANGE_ARRAY  Table;
    ULONG                   Index;
    PFN_NUMBER              sp, ep;
    DUMP_MDL                DumpMdl;
    PMDL                    Mdl;
    PUCHAR                  cp;
    PFN_NUMBER              PageNo;
    PFN_NUMBER              Pages;
    PVOID                   IoPage;
    PPFN_NUMBER             TablePage;
    ULONG                   LastPercent;
    ULONG                   i;
    ULONG                   temp;
    ULONG_PTR               CompressedWriteOffset = 0;
    PVOID                   CloneVa;
    ULONG PoWakeCheck;

    LONGLONG           EndCount;
    LARGE_INTEGER           TickFrequency;

    HiberContext->PerfInfo.StartCount = HIBER_GET_TICK_COUNT(&TickFrequency);

    //
    // Set the sector locations for the proper file
    //

    CMcb = (PPOP_MCB_CONTEXT) HiberContext->CurrentMcb;
    CMcb->FirstMcb = HiberFile->NonPagedMcb;
    CMcb->Mcb = HiberFile->NonPagedMcb;
    CMcb->Base = 0;
    IoPage = HiberContext->IoPage;

    //
    // Write the free page map page
    //

    RtlZeroMemory (IoPage, PAGE_SIZE);
    if (HiberContext->LoaderMdl) {
        //
        // The hibernation file has one page to hold the free page map.
        // If MmHiberPages is more pages than would fit, it's not possible
        // to pass enough free pages to guarantee being able to reload the
        // hibernation image, so don't hibernate.
        //

        if (MmHiberPages > PAGE_SIZE / sizeof (ULONG)) {
            return STATUS_NO_MEMORY;
        }

        MemImage->NoFreePages = HiberContext->LoaderMdl->ByteCount >> PAGE_SHIFT;
        //
        // Hibernate only if the number of free pages on the MDL is more than
        // the required MmHiberPages.
        //

        if (MemImage->NoFreePages >= MmHiberPages) {
            cp = (PUCHAR) MmGetMdlPfnArray( HiberContext->LoaderMdl );
              
#if defined(_AMD64_)      

            //      
            // These pages are reserved for loader use. They must live
            // under 4GB space. It is safe to assume the pfns of these 
            // pages are of 32-bit values and only save their low dwords. 
            //      

            for (i = 0; i < MmHiberPages; i++) {
                *((PULONG)IoPage + i) = *(PLONG)((PPFN_NUMBER)cp + i);
            }
#else
            memcpy (IoPage, cp, MmHiberPages * sizeof(PFN_NUMBER));
#endif
            MemImage->NoFreePages = MmHiberPages;
        } else {
            return STATUS_NO_MEMORY;
        }
    } else {

        //
        // If there are no free pages available to pass to the loader, don't
        // hibernate.

        return STATUS_NO_MEMORY;
    }

    MemImage->FreeMapCheck = PoSimpleCheck(0, IoPage, PAGE_SIZE);
    PopWriteHiberPages (HiberContext, IoPage, 1, PO_FREE_MAP_PAGE, NULL);

    //
    // Write the processors saved context
    //

    RtlZeroMemory (IoPage, PAGE_SIZE);
    memcpy (IoPage, HiberContext->WakeState, sizeof(KPROCESSOR_STATE));
    PoWakeCheck =
    MemImage->WakeCheck = PoSimpleCheck(0, IoPage, sizeof(KPROCESSOR_STATE));
    PopWriteHiberPages (HiberContext, IoPage, 1, PO_PROCESSOR_CONTEXT_PAGE, NULL);
    temp = PoSimpleCheck(0, IoPage, sizeof(KPROCESSOR_STATE));
    if (MemImage->WakeCheck != temp) {
        DbgPrint("Checksum for context page changed from %lx to %lx\n",
                 MemImage->WakeCheck, temp);
        KeBugCheckEx(INTERNAL_POWER_ERROR, 3, MemImage->WakeCheck, temp, __LINE__);
    }
    temp = PoSimpleCheck(0, IoPage, PAGE_SIZE);
    if (MemImage->WakeCheck != temp) {
        DbgPrint("Checksum for partial context page %lx doesn't match full %lx\n",
                 MemImage->WakeCheck, temp);
        KeBugCheckEx(INTERNAL_POWER_ERROR, 4, MemImage->WakeCheck, temp, __LINE__);
    }

    //
    // Before computing checksums, remove all breakpoints so they are not
    // written in the saved image
    //
#ifndef HIBERNATE_PRESERVE_BPS
    if (KdDebuggerEnabled  &&
        !KdPitchDebugger &&
        !(PopSimulate & POP_IGNORE_HIBER_SYMBOL_UNLOAD)) {

        KdDeleteAllBreakpoints();
    }
#endif // HIBERNATE_PRESERVE_BPS

    //
    // Run each range, put its checksum in the restoration table
    // and write each range to the file
    //

    Table  = HiberContext->TableHead;
    LastPercent = 100;

    HiberContext->PerfInfo.PagesProcessed = 0;

    TablePage = &MemImage->FirstTablePage;
    PageNo = PO_FIRST_RANGE_TABLE_PAGE;
    PopResetRangeEnum(HiberContext);

    while (Table) {

        // Keep track of where the page tables have been written

        *TablePage = PageNo;
        PageNo++;

        for (Index=1; Index <= Table[0].Link.EntryCount; Index++) {
            PopIOResume (HiberContext, FALSE);

            PopGetNextRange(HiberContext, &sp, &ep, &CloneVa);

            if ((Table[Index].Range.StartPage != sp) ||
                (Table[Index].Range.EndPage != ep)) {

                PoPrint(PO_ERROR,("PopWriteHiberImage: Table entry %p [%lx-%lx] does not match next range [%lx-%lx]\n",
                    Table+Index,
                    Table[Index].Range.StartPage,
                    Table[Index].Range.EndPage,
                    sp,
                    ep));
                PopInternalAddToDumpFile( HiberContext, sizeof(POP_HIBER_CONTEXT), NULL, NULL, NULL, NULL );
                PopInternalAddToDumpFile( Table, PAGE_SIZE, NULL, NULL, NULL, NULL );                
                KeBugCheckEx( INTERNAL_POWER_ERROR,
                              0x107,
                              POP_HIBER,
                              (ULONG_PTR)HiberContext,
                              (ULONG_PTR)Table );
            }

            Table[Index].Range.PageNo = PageNo;

            //
            // Write the data to hiber file
            //

            if (CloneVa) {

                //
                // Use the cloned data which is already mapped
                //

                Pages = ep - sp;

                // Compute the cloned range's Checksum

                Table[Index].Range.CheckSum = 0;

                // Add the pages to the compressed page set
                // (effectively writing them out)

                PopAddPagesToCompressedPageSet(TRUE,
                                               HiberContext,
                                               &CompressedWriteOffset,
                                               CloneVa,
                                               Pages,
                                               &PageNo);
                HiberContext->PerfInfo.PagesProcessed += (ULONG)Pages;

                // Update the progress bar

                i = (ULONG)((HiberContext->PerfInfo.PagesProcessed * 100) / MemImage->TotalPages);

                if (i != LastPercent) {
                    LastPercent = i;
                    PopUpdateHiberComplete(HiberContext, LastPercent);
                }

            } else {

                //
                // Map a chunk and write it, loop until done
                //
                Mdl = (PMDL) DumpMdl;

                // Initialize Check Sum

                Table[Index].Range.CheckSum = 0;

                while (sp < ep) {
                    PopCreateDumpMdl (Mdl, sp, ep);

                    Pages = Mdl->ByteCount >> PAGE_SHIFT;

                    // Add pages to compressed page set
                    // (effectively writing them out)

                    PopAddPagesToCompressedPageSet(TRUE,
                                                   HiberContext,
                                                   &CompressedWriteOffset,
                                                   Mdl->MappedSystemVa,
                                                   Pages,
                                                   &PageNo);
                    sp += Pages;
                    HiberContext->PerfInfo.PagesProcessed += (ULONG)Pages;

                    // Update the progress bar

                    i = (ULONG)((HiberContext->PerfInfo.PagesProcessed * 100) / MemImage->TotalPages);
                    if (i != LastPercent) {
                        LastPercent = i;
                        PopUpdateHiberComplete(HiberContext, LastPercent);
                    }
                }
            }
        }

        // Terminate the compressed page set, since the next page
        // (a table page) is uncompressed.

        PopEndCompressedPageSet(HiberContext, &CompressedWriteOffset, &PageNo);

        TablePage = &Table[0].Link.NextTable;
        Table = Table[0].Link.Next;
    }


    //
    // Now that the range checksums have been added to the
    // restoration tables they are now complete.  Compute their
    // checksums and write them into the file
    //

    Table = HiberContext->TableHead;
    PageNo = PO_FIRST_RANGE_TABLE_PAGE;
    while (Table) {
        Table[0].Link.CheckSum = 0;
        PopWriteHiberPages (HiberContext, Table, 1, PageNo, NULL);

        PageNo = Table[0].Link.NextTable;
        Table = Table[0].Link.Next;
    }

    //
    // File is complete write a valid header
    //

    if (MemImage->WakeCheck != PoWakeCheck) {
        DbgPrint("MemImage->WakeCheck %lx doesn't make PoWakeCheck %lx\n",
                 MemImage->WakeCheck,
                 PoWakeCheck);
        //
        // subcode 5 is used in other places.  So it's much harder to diagnose this
        // bugcheck.  Cut our losses here and start using subcode 0x109.
        //
        // KeBugCheckEx( INTERNAL_POWER_ERROR, 5, MemImage->WakeCheck, PoWakeCheck, __LINE__);
        KeBugCheckEx( INTERNAL_POWER_ERROR,
                      0x109,
                      POP_HIBER,
                      MemImage->WakeCheck,
                      PoWakeCheck );
    }

    //
    // Fill in perf information so we can read it after hibernation
    //
    EndCount = HIBER_GET_TICK_COUNT(&TickFrequency);
    HiberContext->PerfInfo.ElapsedTime = (ULONG)((EndCount - HiberContext->PerfInfo.StartCount)*1000 / TickFrequency.QuadPart);
    HiberContext->PerfInfo.IoTime = (ULONG)(HiberContext->PerfInfo.IoTicks*1000 / TickFrequency.QuadPart);
    HiberContext->PerfInfo.CopyTime = (ULONG)(HiberContext->PerfInfo.CopyTicks*1000 / TickFrequency.QuadPart);
    HiberContext->PerfInfo.InitTime = (ULONG)(HiberContext->PerfInfo.InitTicks*1000 / TickFrequency.QuadPart);
    HiberContext->PerfInfo.FileRuns = PopHiberFile.McbSize / sizeof(LARGE_INTEGER) - 1;

    MemImage->Signature = PO_IMAGE_SIGNATURE;
    MemImage->PerfInfo = HiberContext->PerfInfo;
    MemImage->CheckSum = PoSimpleCheck(0, MemImage, sizeof(*MemImage));
    PopWriteHiberPages (HiberContext, MemImage, 1, PO_IMAGE_HEADER_PAGE, NULL);

    //
    // Image completely written flush the controller
    //
    PoPrint (PO_ERROR, ("PopWriteHiberImage: About to actually flush the controller\r\n"));
    if (HiberContext->WriteToFile) {
        while (NT_SUCCESS (HiberContext->Status) &&
               (DmaIoPtr != NULL) &&
               ((DmaIoPtr->Busy.Size != 0) || (DmaIoPtr->Used.Size != 0))) {
            PopIOResume (HiberContext, TRUE);
        }

        HiberContext->DumpStack->Init.FinishRoutine();
    }
    
    PoPrint (PO_ERROR, ("PopWriteHiberImage: Back from flushing the controller.  Status (0x%x)\r\n", HiberContext->Status));
    
    if (PopSimulate & POP_ENABLE_HIBER_PERF) {
        PopDumpStatistics(&HiberContext->PerfInfo);
    }

    //
    // Failed to write the hiberfile.
    //
    if (!NT_SUCCESS(HiberContext->Status)) {
#if DBG
        PoPrint (PO_ERROR, ("PopWriteHiberImage: Error occured writing the hiberfile. (%x)\n", HiberContext->Status));
        PopInternalAddToDumpFile( HiberContext, sizeof(POP_HIBER_CONTEXT), NULL, NULL, NULL, NULL );
        KeBugCheckEx( INTERNAL_POWER_ERROR,
                      0x10A,
                      POP_HIBER,
                      (ULONG_PTR)HiberContext,
                      HiberContext->Status );
#else
        return( HiberContext->Status );
#endif
    }

    //
    // Before sleeping, if the check memory bit is set verify the
    // dump process didn't edit any memory pages
    //

    if (PopSimulate & POP_TEST_CRC_MEMORY) {
        if (!(PopSimulate & POP_DEBUG_HIBER_FILE) ||
            (HiberFile == &PopHiberFileDebug)) {
        }
    }

    //
    // Tell the debugger we are hibernating
    //

    if (!(PopSimulate & POP_IGNORE_HIBER_SYMBOL_UNLOAD)) {

        KD_SYMBOLS_INFO SymbolInfo = {0};
        SymbolInfo.BaseOfDll = (PVOID)KD_HIBERNATE;

        DebugService2(NULL, &SymbolInfo, BREAKPOINT_UNLOAD_SYMBOLS);
    }

    //
    // If we want to perform a reset instead of a power down, return an
    // error so we don't power down
    //

    if (PopSimulate & POP_RESET_ON_HIBER) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Success, continue with power off operation
    //

    return STATUS_SUCCESS;
}

VOID
PopDumpStatistics(
    IN PPO_HIBER_PERF PerfInfo
    )
{
    LONGLONG EndCount;
    LARGE_INTEGER TickFrequency;

    EndCount = HIBER_GET_TICK_COUNT(&TickFrequency);
    PerfInfo->ElapsedTime = (ULONG)((EndCount - PerfInfo->StartCount)*1000 / TickFrequency.QuadPart);
    PerfInfo->IoTime = (ULONG)(PerfInfo->IoTicks*1000 / TickFrequency.QuadPart);
    PerfInfo->CopyTime = (ULONG)(PerfInfo->CopyTicks*1000 / TickFrequency.QuadPart);
    PerfInfo->InitTime = (ULONG)(PerfInfo->InitTicks*1000 / TickFrequency.QuadPart);
    PerfInfo->FileRuns = PopHiberFile.McbSize / sizeof(LARGE_INTEGER) - 1;
    DbgPrint("HIBER: %lu Pages written in %lu Dumps (%lu runs).\n",
             PerfInfo->PagesWritten,
             PerfInfo->DumpCount,
             PerfInfo->FileRuns);
    DbgPrint("HIBER: %lu Pages processed (%d %% compression)\n",
             PerfInfo->PagesProcessed,
             PerfInfo->PagesWritten*100/PerfInfo->PagesProcessed);
    DbgPrint("HIBER: Elapsed time %3d.%03d seconds\n",
             PerfInfo->ElapsedTime / 1000,
             PerfInfo->ElapsedTime % 1000);
    DbgPrint("HIBER: I/O time     %3d.%03d seconds (%2d%%)  %d MB/sec\n",
             PerfInfo->IoTime / 1000,
             PerfInfo->IoTime % 1000,
             PerfInfo->ElapsedTime ? PerfInfo->IoTime*100/PerfInfo->ElapsedTime : 0,
             (PerfInfo->IoTime/100000) ? (PerfInfo->PagesWritten/(1024*1024/PAGE_SIZE)) / (PerfInfo->IoTime / 100000) : 0);
    DbgPrint("HIBER: Init time     %3d.%03d seconds (%2d%%)\n",
             PerfInfo->InitTime / 1000,
             PerfInfo->InitTime % 1000,
             PerfInfo->ElapsedTime ? PerfInfo->InitTime*100/PerfInfo->ElapsedTime : 0);
    DbgPrint("HIBER: Copy time     %3d.%03d seconds (%2d%%)  %d Bytes\n",
             PerfInfo->CopyTime / 1000,
             PerfInfo->CopyTime % 1000,
             PerfInfo->ElapsedTime ? PerfInfo->CopyTime*100/PerfInfo->ElapsedTime : 0,
             PerfInfo->BytesCopied );

}


VOID
PopUpdateHiberComplete (
    IN PPOP_HIBER_CONTEXT   HiberContext,
    IN ULONG                Percent
    )
{
    CHAR                   Buffer[200];

    if (InbvIsBootDriverInstalled()) {

        InbvUpdateProgressBar(Percent + 1);

    } else {

        sprintf (Buffer, "PopSave: %d%%\r", Percent);
        PoPrint (PO_HIBER_MAP, ("%s", Buffer));
        if (HiberContext->WriteToFile) {
            InbvDisplayString ((PUCHAR) Buffer);
        }
    }

#if 0
    if ((Percent > 0) &&
        ((Percent % 10) == 0) &&
        (PopSimulate & POP_ENABLE_HIBER_PERF)) {
        DbgPrint("HIBER: %d %% done\n",Percent);
        PopDumpStatistics(&HiberContext->PerfInfo);
    }
#endif
}

VOID
PopEndCompressedPageSet(
   IN PPOP_HIBER_CONTEXT   HiberContext,
   IN OUT PULONG_PTR       CompressedBufferOffset,
   IN OUT PPFN_NUMBER      SetFilePage
   )
/*++

Routine Description:

   Terminates a compressed page set, flushing whatever remains in the compression
   buffer to the Hiber file. A termination of a compressed page set allows uncompressed
   pages to the be written out to the Hiber file.

   See PopAddPagesToCompressedPageSet for more information on compressed page sets.

Arguments:

   HiberContext            - The Hiber Context.

   CompressedBufferOffset  - Similar to same parameter in PopAddPagesToCompressedPageSet.

                             Should be the CompressedBufferOffset value received
                             from the last call to PopAddPagesToCompressedPageSet.
                             Will be reset to 0 after this call in preparation
                             for the beginning of a new compressed page set.

   SetFilePage             - Similar to same parameter in PopAddPagsToCompressedPageSet.

                             Should be the SetFilePAge value received from the last
                             call to PopAddPagesToCompressedPageSet. Will be reset
                             to the next available file page after the end of this
                             compressed page set.

Return Value:

   None.

--*/
{
    PFN_NUMBER Pages;
    PCOMPRESSION_BLOCK Block = HiberContext->CompressionBlock;

    // is there are any blocked data?
    if (Block->Ptr != Block->Buffer) {
        // yes, flush the block
        PopAddPagesToCompressedPageSet (FALSE,        // no buffering -- compress now
                                        HiberContext,
                                        CompressedBufferOffset,
                                        Block->Buffer,
                                        (PFN_NUMBER) ((Block->Ptr - Block->Buffer) >> PAGE_SHIFT),
                                        SetFilePage);

        // reset block to empty
        Block->Ptr = Block->Buffer;
    }


    // Figure out how many pages remain in the compression buffer.  Don't
    // use BYTES_TO_PAGES because that will truncate to ULONG.

    Pages = (PFN_NUMBER) ((*CompressedBufferOffset + (PAGE_SIZE-1)) >> PAGE_SHIFT);

    if (Pages > 0) {

        // Write the remaining pages out

        PopWriteHiberPages(HiberContext,
                           (PVOID)HiberContext->CompressedWriteBuffer,
                           Pages,
                           *SetFilePage,
                           NULL);

        // Reflect our usage of the hiber file

        *SetFilePage = *SetFilePage + Pages;
    }

    *CompressedBufferOffset = 0;
}

VOID
PopAddPagesToCompressedPageSet(
   IN BOOLEAN              AllowDataBuffering,
   IN PPOP_HIBER_CONTEXT   HiberContext,
   IN OUT PULONG_PTR       CompressedBufferOffset,
   IN PVOID                StartVa,
   IN PFN_NUMBER           NumPages,
   IN OUT PPFN_NUMBER      SetFilePage
   )
/*++

Routine Description:

   This routine is the central call needed to write out memory pages
   in a compressed fashion.

   This routine takes a continuous range of mapped pages and adds
   them to a compressed page set. A compressed page set is merely
   a stream of compressed buffers written out contiguously within
   the Hiber file. Such a contiguous layout maximizes the benefit
   gained from compression by writing compressed output into
   the smallest possible space.

   In order to accomplish such a layout, this routine continually
   compresses pages and adds them to the compression buffer pointed to
   by the Hiber context. Once a certain point in that buffer is reached,
   it is written out to the Hiber file and the buffer is reset to the
   beginning. Each write-out of the compression buffer is placed
   right after the end of the last compression buffer written.

   Because of the buffering used in this algorithm, compressed buffers
   may remain in the compression buffer even after the last needed
   call to PopAddPagesToCompressedPageSet. In order to fully flush
   the buffer, PopEndCompressedPageSet must be called.

   Note that in order to write any uncompressed pages to the Hiber
   file, the compressed page set needs to be terminated with
   PopEndCompressedPageSet. After a compressed page set is terminated,
   a new set can be initiated with a call to PopAddPagesToCompressedPageSet.

   N.B. A chunk of a compressed page set that has been committed to the
        Hiber file in one write operation is called a compressed page set fragment
        in other places within this file.

Arguments:

   AllowDataBuffering      - If true input pages will be buffered, otherwise
                           - compressed and [possibly] written immediately

   HiberContext            - The Hiber context

   CompressedBufferOffset  - An offset into the Hiber context's compression buffer
                             where the addition of the next compressed buffer will
                             occurr.

                             This offset should be set to 0 at the beginning of
                             every compressed page set. After every call,
                             to PopAddPagesToCompressedPageSet this offset
                             will be modified to reflect the current usage of
                             the compression buffer.

   StartVa                 - The starting virtual address of the pages to
                             add to the compressed page set.

   NumPages                - The number of pages to add to the compressed page set.

   SetFilePage             - A pointer to first page in the Hiber file that will receive
                             the next write-out of the compression buffer.

                             This page should be set to the first available Hiber file
                             page when the compressed page set is begun. The page will
                             be reset to reflect the current usage of the Hiber file
                             by the compressed page set after each call to
                             PopAddPagesToCompressedPageSet.

Return Value:

   NONE.

--*/
{
    ULONG_PTR BufferOffset = *CompressedBufferOffset;
    PUCHAR Page = (PUCHAR)StartVa;
    PFN_NUMBER i;
    ULONG CompressedSize;
    PFN_NUMBER NumberOfPagesToCompress;
    ULONG MaxCompressedSize;
    ULONG AlignedCompressedSize;
    PUCHAR CompressedBuffer;

    if (AllowDataBuffering) {
        PCOMPRESSION_BLOCK Block = HiberContext->CompressionBlock;

        // Yes, try to buffer output
        if (Block->Ptr != Block->Buffer) {
            // Find # of free pages left in block
            NumberOfPagesToCompress = (PFN_NUMBER)
                                      ((Block->Buffer + sizeof (Block->Buffer) - Block->Ptr) >> PAGE_SHIFT);

            // If it's exceed available truncate
            if (NumberOfPagesToCompress > NumPages) {
                NumberOfPagesToCompress = NumPages;
            }

            // Any free space left?
            if (NumberOfPagesToCompress != 0) {
                HbCopy(HiberContext, Block->Ptr, Page, NumberOfPagesToCompress << PAGE_SHIFT);
                NumPages -= NumberOfPagesToCompress;
                Page += NumberOfPagesToCompress << PAGE_SHIFT;
                Block->Ptr += NumberOfPagesToCompress << PAGE_SHIFT;
            }

            // Is block full?
            if (Block->Ptr == Block->Buffer + sizeof (Block->Buffer)) {
                // Yes, flush the block
                PopAddPagesToCompressedPageSet (FALSE,       // no buffering
                                                HiberContext,
                                                CompressedBufferOffset,
                                                Block->Buffer,
                                                (PFN_NUMBER) ((Block->Ptr - Block->Buffer) >> PAGE_SHIFT),
                                                SetFilePage);

                // Reset block to empty
                Block->Ptr = Block->Buffer;
            }
        }

        NumberOfPagesToCompress = sizeof (Block->Buffer) >> PAGE_SHIFT;

        // While too much to compress -- compress from original location
        while (NumPages >= NumberOfPagesToCompress) {
            // Write pages
            PopAddPagesToCompressedPageSet (FALSE,     // no buffering
                                            HiberContext,
                                            CompressedBufferOffset,
                                            Page,
                                            NumberOfPagesToCompress,
                                            SetFilePage);

            // adjust pointer and counter
            Page += NumberOfPagesToCompress << PAGE_SHIFT;
            NumPages -= NumberOfPagesToCompress;
        }

        // If anything left save it in block
        // N.B.: either NumPages == 0 or there is enough space in Block
        if (NumPages != 0) {
            HbCopy (HiberContext, Block->Ptr, Page, NumPages << PAGE_SHIFT);
            Block->Ptr += NumPages << PAGE_SHIFT;
        }

        // done
        return;
    }

    // First make sure values of constants match our assumptions

#if XPRESS_HEADER_SIZE < XPRESS_HEADER_STRING_SIZE + 8
#error -- XPRESS_HEADER_SIZE shall be at least (XPRESS_HEADER_STRING_SIZE + 8)
#endif

#if XPRESS_MAX_SIZE < PAGE_SIZE || XPRESS_MAX_SIZE % PAGE_SIZE != 0
#error -- XPRESS_MAX_SIZE shall be multiple of PAGE_SIZE
#endif

#if (XPRESS_ALIGNMENT & (XPRESS_ALIGNMENT - 1)) != 0
#error -- XPRESS_ALIGNMENT shall be power of 2
#endif

#if XPRESS_HEADER_SIZE % XPRESS_ALIGNMENT != 0
#error -- XPRESS_HEADER_SIZE shall be multiple of XPRESS_ALIGNMENT
#endif

    // make sure that compressed buffer and its header will fit into output buffer
#if XPRESS_MAX_SIZE + XPRESS_HEADER + PAGE_SIZE  - 1 > (POP_COMPRESSED_PAGE_SET_SIZE << PAGE_SHIFT)
#error -- POP_COMPRESSED_PAGE_SET_SIZE is too small
#endif

    // Real compression starts here

    // Loop through all the pages ...
    for (i = 0; i < NumPages; i += NumberOfPagesToCompress) {

        NumberOfPagesToCompress = XPRESS_MAX_PAGES;
        if (NumberOfPagesToCompress > NumPages - i) {
            NumberOfPagesToCompress = NumPages - i;
        }

        // If compressed data occupies more than 87.5% = 7/8 of original store data as is
        MaxCompressedSize = ((ULONG)NumberOfPagesToCompress * 7) * (PAGE_SIZE / 8);


        // Is the buffer use beyond the write-out threshold?

        //
        // N.B. The buffer must extend sufficiently beyond the threshold
        //      the allow the last compression operation (that one that writes
        //      beyond the threshold) to always succeed.
        //

        if (BufferOffset + (NumberOfPagesToCompress << PAGE_SHIFT) + XPRESS_HEADER_SIZE > (POP_COMPRESSED_PAGE_SET_SIZE << PAGE_SHIFT)) {
            // Write out the compression buffer bytes below the threshold

            PopWriteHiberPages(HiberContext,
                               (PVOID)HiberContext->CompressedWriteBuffer,
                               BufferOffset >> PAGE_SHIFT,
                               *SetFilePage,
                               NULL);

            // We have used some pages in the Hiber file with the above write,
            // indicate that our next Hiber file page will be beyond those used pages.

            *SetFilePage = *SetFilePage + (BufferOffset >> PAGE_SHIFT);

            // Move buffer bytes that are above the write-out threshold to the
            // beginning of the buffer

            if (BufferOffset & (PAGE_SIZE - 1)) {
                HbCopy(HiberContext,
                       HiberContext->CompressedWriteBuffer,
                       HiberContext->CompressedWriteBuffer + (BufferOffset & ~(PAGE_SIZE - 1)),
                       (ULONG)BufferOffset & (PAGE_SIZE - 1));
            }

            // Reset the buffer offset back to the beginning of the buffer but right
            // after any above-threshold buffer bytes that we will move to the beginning
            // of the buffer

            BufferOffset &= PAGE_SIZE - 1;
        }


        // Remember output position

        CompressedBuffer = HiberContext->CompressedWriteBuffer + BufferOffset;

        // Clear the header
        RtlZeroMemory (CompressedBuffer, XPRESS_HEADER_SIZE);


        // Compress pages into the compression buffer

        if (HIBER_USE_DMA (HiberContext)) {
            // Try to resume IO calling callback each 8192 bytes
            CompressedSize = XpressEncode ((XpressEncodeStream) (HiberContext->CompressionWorkspace),
                                           CompressedBuffer + XPRESS_HEADER_SIZE,
                                           MaxCompressedSize,
                                           (PVOID) Page,
                                           (ULONG)NumberOfPagesToCompress << PAGE_SHIFT,
                                           PopIOCallback,
                                           HiberContext,
                                           8192);
        } else {
            // No need for callbacks -- compress everything at once
            CompressedSize = XpressEncode ((XpressEncodeStream) (HiberContext->CompressionWorkspace),
                                            CompressedBuffer + XPRESS_HEADER_SIZE,
                                            MaxCompressedSize,
                                            (PVOID) Page,
                                            (ULONG)NumberOfPagesToCompress << PAGE_SHIFT,
                                            NULL,
                                            NULL,
                                            0);
        }

        // If compression failed copy data as is original

        if (CompressedSize >= MaxCompressedSize) {
            CompressedSize = (ULONG)NumberOfPagesToCompress << PAGE_SHIFT;
            HbCopy (HiberContext,
                    CompressedBuffer + XPRESS_HEADER_SIZE,
                    (PVOID) Page,
                    CompressedSize);
        }

        //
        // Fill the header
        //


        // Magic bytes (LZNT1 block cannot start from 0x81,0x81)
        RtlCopyMemory (CompressedBuffer, XPRESS_HEADER_STRING, XPRESS_HEADER_STRING_SIZE);


        // Size of original and compressed data
        {
            ULONG dw = ((CompressedSize - 1) << 10) + ((ULONG)NumberOfPagesToCompress - 1);

#if XPRESS_MAX_SIZE > (1 << 22)
#error -- XPRESS_MAX_SIZE shall not exceed 4 MB
#endif

            CompressedBuffer[XPRESS_HEADER_STRING_SIZE] = (UCHAR) dw;
            CompressedBuffer[XPRESS_HEADER_STRING_SIZE+1] = (UCHAR) (dw >>  8);
            CompressedBuffer[XPRESS_HEADER_STRING_SIZE+2] = (UCHAR) (dw >> 16);
            CompressedBuffer[XPRESS_HEADER_STRING_SIZE+3] = (UCHAR) (dw >> 24);
        }

        // Align compressed data on 8-byte boundary
        AlignedCompressedSize = (CompressedSize + (XPRESS_ALIGNMENT - 1)) & ~(XPRESS_ALIGNMENT - 1);
        if (CompressedSize != AlignedCompressedSize) {
            // Fill up data with zeroes until aligned
            RtlZeroMemory (CompressedBuffer + XPRESS_HEADER_SIZE + CompressedSize, AlignedCompressedSize - CompressedSize);
        }

        // Indicate our new usage of the buffer

        BufferOffset += AlignedCompressedSize + XPRESS_HEADER_SIZE;

        // Move on to the virtual address of the next page

        Page += NumberOfPagesToCompress << PAGE_SHIFT;
    }

    *CompressedBufferOffset = BufferOffset;
}


VOID
PopIORegionMove (
    IN IOREGION *To,      // ptr to region descriptor to put bytes to
    IN IOREGION *From,        // ptr to region descriptor to get bytes from
    IN LONG Bytes         // # of bytes to move from the beginning of one region to the end of another
    )
{
    ASSERT((Bytes & (PAGE_SIZE-1)) == 0);

    if (To->Size != To->End - To->Ptr) {
        ASSERT (To->Ptr + To->Size == From->Ptr);
        To->Size += Bytes;
        ASSERT (To->Size <= To->End - To->Ptr);
    } else {
        ASSERT (To->Beg + To->SizeOvl == From->Ptr);
        To->SizeOvl += Bytes;
        ASSERT (To->Size + To->SizeOvl <= To->End - To->Beg);
    }

    ASSERT (Bytes <= From->Size && From->Size <= From->End - From->Ptr);
    From->Size -= Bytes;
    From->Ptr += Bytes;
    if (From->Ptr == From->End) {
        ASSERT (From->Size == 0);
        From->Ptr = From->Beg;
        From->Size = From->SizeOvl;
        From->SizeOvl = 0;
    }
}

VOID
XPRESS_CALL
PopIOCallback (
    PVOID Context,
    int compressed
    )
{
    PPOP_HIBER_CONTEXT HiberContext = Context;

    UNREFERENCED_PARAMETER (compressed);

    if (HiberContext == NULL || DmaIoPtr == NULL) {
        return;
    }

    if (DmaIoPtr->Busy.Size == 0 && DmaIoPtr->Used.Size == 0)
        return;

    PopIOResume (Context, FALSE);
}

BOOLEAN PopIOResume (
    IN PPOP_HIBER_CONTEXT   HiberContext,
    IN BOOLEAN Complete
    )
{
    NTSTATUS status;

    // If there were error don't even bother
    if (!NT_SUCCESS(HiberContext->Status)) {
        return(FALSE);
    }

    if (DmaIoPtr == NULL) {
        return(TRUE);
    }

    // if delayed operation then resume or complete it
    while (DmaIoPtr->Busy.Size != 0) {

        status = HiberContext->DumpStack->Init.WritePendingRoutine (Complete?IO_DUMP_WRITE_FINISH:IO_DUMP_WRITE_RESUME,
                                                                    NULL,
                                                                    NULL,
                                                                    DmaIoPtr->DumpLocalData);

        if (status == STATUS_PENDING) {
            // Pending IO; shall never happen if Complete
            ASSERT (!Complete);
            return(TRUE);
        }

        // If there were error then don't care
        if (!NT_SUCCESS (status)) {
            HiberContext->Status = status;
            return(FALSE);
        }

        // Now, resume PopWriteHiberPages
        PopWriteHiberPages (HiberContext,
                            NULL,
                            0,
                            0,
                            &DmaIoPtr->HiberWritePagesLocals);
        if (!NT_SUCCESS (HiberContext->Status)) {
            return(FALSE);
        }

        // If pending IO completed and we had to wait -- do not start new one
        if (DmaIoPtr->Busy.Size == 0 && Complete) {
            return(TRUE);
        }

        // If not completed and do no wait -- return
        if (DmaIoPtr->Busy.Size != 0 && !Complete) {
            return(TRUE);
        }
    }

    while (DmaIoPtr->Used.Size >= PAGE_SIZE) {
        ULONG_PTR               i, j;
        ULONG_PTR               NoPages;
        ULONG_PTR               Length;
        PUCHAR                  PageVa;
        PFN_NUMBER              FilePage;

        // Obtain size of region waiting for IO
        PageVa = DmaIoPtr->Used.Ptr;
        NoPages = (Length = DmaIoPtr->Used.Size) >> PAGE_SHIFT;
        // Make sure all pages should be contiguous
        i = DmaIoPtr->Used.Ptr - DmaIoPtr->Used.Beg;
        ASSERT (((i | Length) & (PAGE_SIZE-1)) == 0);
        i >>= PAGE_SHIFT;

        // Starting file offset (in pages)
        FilePage = DmaIoPtr->FilePage[i];

        // Increase counter while contiguous and used
        if (HIBER_USE_DMA (HiberContext)) {
            // If DMA is allowed write page-by-page
            j = 1;
        } else {
            // Write as many pages as possible
            j = 0;
            do {
                ++j;
            } while ((j != NoPages) &&
                     (DmaIoPtr->FilePage[i + j] == FilePage + j));
        }

        // Re-evaluate # of pages and length of block
        Length = (NoPages = j) << PAGE_SHIFT;

        // Start IO
        PopWriteHiberPages (HiberContext, PageVa, NoPages, FilePage, &DmaIoPtr->HiberWritePagesLocals);
        if (!NT_SUCCESS (HiberContext->Status)) {
            return(FALSE);
        }

        // If pending then return immediately (even if need to complete)
        if (DmaIoPtr->Busy.Size != 0) {
            return(TRUE);
        }
    }

    return(TRUE);
}


VOID
PopIOWrite (
    IN PPOP_HIBER_CONTEXT   HiberContext,
    IN PUCHAR               Ptr,
    IN LONG                 Bytes,
    IN PFN_NUMBER           FilePage
    )
{
    LONG i, Size;

    // Do not bother if don't writing and/or was an error
    if (!HiberContext->WriteToFile || !NT_SUCCESS(HiberContext->Status)) {
        return;
    }

    ASSERT ((Bytes & (PAGE_SIZE-1)) == 0);

    while (Bytes > 0) {
        // Complete or Resume IO
        do {
            if (!PopIOResume (HiberContext, (BOOLEAN) (DmaIoPtr->Free.Size == 0))) {
                return;
            }
        } while (DmaIoPtr->Free.Size == 0);

        // Find how much can we write
        Size = DmaIoPtr->Free.Size;
        ASSERT ((Size & (PAGE_SIZE-1)) == 0);
        if (Size > Bytes) {
            Size = Bytes;
        }
        ASSERT (Size != 0);
        // Copy and adjust pointers

        HbCopy (HiberContext, DmaIoPtr->Free.Ptr, Ptr, Size);

        Ptr += Size;
        Bytes -= Size;

        // Remember current page # index
        i = (ULONG)(DmaIoPtr->Free.Ptr - DmaIoPtr->Free.Beg);
        ASSERT ((i & (PAGE_SIZE-1)) == 0);
        i >>= PAGE_SHIFT;

        // Mark free memory as used
        PopIORegionMove (&DmaIoPtr->Used, &DmaIoPtr->Free, Size);

        // Remember FilePage for newly used pages
        do {
            DmaIoPtr->FilePage[i] = FilePage;
            ++i;
            ++FilePage;
        } while ((Size -= PAGE_SIZE) != 0);
    }

    // Resume IO
    PopIOResume (HiberContext, FALSE);
}


VOID
PopWriteHiberPages (
    IN PPOP_HIBER_CONTEXT   HiberContext,
    IN PVOID                ArgPageVa,
    IN PFN_NUMBER           ArgNoPages,
    IN PFN_NUMBER           ArgFilePage,
    IN HIBER_WRITE_PAGES_LOCALS *Locals
    )
/*++

Routine Description:

    Routine to write pages into the hibernation file.
    Caller must map pages to virtual addresses.

Arguments:

    HiberContext    - The hibernation context structure

    PageVa          - Virtual address of the first page to write

    NoPage          - Number of consective pages to write

    FilePage        - Page address in hiber file to write this
                      run of pages.

    PendingIOStatus - If NULL then pass IO request to PopIOWrite,
                      otherwise it's call from PopIOResume for delayed
                      IO; used to return # of bytes written and pending

Return Value:

    None

--*/

{
    DUMP_MDL DumpMdl;
#define X(type,name) type name
    HIBER_WRITE_PAGES_LOCALS_LIST (X)
#undef  X
    ULONGLONG StartCount, EndCount;

    PhysBase = 0;
    pa.QuadPart = 0;

    //
    // Copy arguments to local variables
    //
    PageVa = ArgPageVa;
    NoPages = ArgNoPages;
    FilePage = ArgFilePage;

    //
    // Allow debugger to break in when we are hibernating.
    //

    KdCheckForDebugBreak ();

    //
    // If a file isn't being written, then ignore
    //

    if (!HiberContext->WriteToFile) {
        return ;
    }

    //
    // If there's been some sort of error, don't bother
    // writing anymore
    //

    if (!NT_SUCCESS(HiberContext->Status)) {
        return ;
    }

    Mdl = (PMDL) DumpMdl;
    if (Locals != NULL) {
        // If we have async IO make sure that hand-made MDL will be
        // stored in safe place preserved between resume calls
        Mdl = (PMDL) Locals->DumpMdl;

        if (DmaIoPtr->Busy.Size != 0) {
            // There was pending IO -- resume execution from the point we stopped
#define X(type,name) name = Locals->name;
            HIBER_WRITE_PAGES_LOCALS_LIST (X)
#undef  X
            goto ResumeIO;
        }

        // Mark current region as busy
        ASSERT (PageVa == DmaIoPtr->Used.Ptr);
        PopIORegionMove (&DmaIoPtr->Busy, &DmaIoPtr->Used, (ULONG)NoPages << PAGE_SHIFT);
    } else if (HiberContext->DumpStack->Init.WritePendingRoutine != 0 &&
               DmaIoPtr != NULL &&
               DmaIoPtr->DumpLocalData != NULL) {
        if (!DmaIoPtr->DmaInitialized) {
            ULONGLONG xStartCount = HIBER_GET_TICK_COUNT(NULL);
            Status = HiberContext->DumpStack->Init.WritePendingRoutine (IO_DUMP_WRITE_INIT,
                                                                        NULL,
                                                                        NULL,
                                                                        DmaIoPtr->DumpLocalData);
            HiberContext->PerfInfo.InitTicks += HIBER_GET_TICK_COUNT(NULL) - xStartCount;
            if (Status != STATUS_SUCCESS) {
                DmaIoPtr->UseDma = FALSE;
            }
            DmaIoPtr->DmaInitialized = TRUE;
            DmaIoPtr->HiberWritePagesLocals.Status = STATUS_SUCCESS;
        }

        PopIOWrite (HiberContext, PageVa, (ULONG)NoPages << PAGE_SHIFT, FilePage);
        return;
    }

    //
    // Page count must be below 4GB byte length
    //

    if (NoPages > ((((ULONG_PTR) -1) << PAGE_SHIFT) >> PAGE_SHIFT)) {
        PopInternalError (POP_HIBER);
    }

    //
    // Loop while there's data to be written
    //

    CMcb = (PPOP_MCB_CONTEXT) HiberContext->CurrentMcb;
    MdlPage = MmGetMdlPfnArray( Mdl );

    FileBase = (ULONGLONG) FilePage << PAGE_SHIFT;
    Length   = NoPages << PAGE_SHIFT;

    while (Length != 0) {

        //
        // If this IO is outside the current Mcb locate the
        // proper Mcb
        //

        if (FileBase < CMcb->Base || FileBase >= CMcb->Base + CMcb->Mcb[0].QuadPart) {

            //
            // If io is before this mcb, search from the begining
            //

            if (FileBase < CMcb->Base) {
                CMcb->Mcb = CMcb->FirstMcb;
                CMcb->Base = 0;
            }

            //
            // Find the Mcb which covers the start of the io and
            // make it the current mcb
            //

            while (FileBase >= CMcb->Base + CMcb->Mcb[0].QuadPart) {
                CMcb->Base += CMcb->Mcb[0].QuadPart;
                CMcb->Mcb += 2;
            }
        }

        //
        // Determine physical IoLocation and IoLength to write.
        //

        McbOffset  = FileBase - CMcb->Base;
        IoLocation.QuadPart = CMcb->Mcb[1].QuadPart + McbOffset;

        //
        // If the IoLength is beyond the Mcb, limit it to the Mcb
        //

        if (McbOffset + Length > (ULONGLONG) CMcb->Mcb[0].QuadPart) {
            IoLength = (ULONG) (CMcb->Mcb[0].QuadPart - McbOffset);
        } else {
            IoLength = (ULONG) Length;
        }

        //
        // If the IoLength is more pages then the largest Mdl size
        // then shrink it
        //

        NoPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES (PageVa, IoLength);
        if (NoPages > IO_DUMP_MAX_MDL_PAGES) {
            IoLength -= (ULONG)((NoPages - IO_DUMP_MAX_MDL_PAGES) << PAGE_SHIFT);
            NoPages = IO_DUMP_MAX_MDL_PAGES;
        }

//
// Debugging only
// Make sure that we may handle non-page aligned IO
// (simulate fragmented hiberfil.sys)
//
//        if (IoLength > 512) IoLength = 512;
//

        if (HIBER_USE_DMA (HiberContext)) {
            ULONG Size;

            // Do not write accross page boundaries
            // to avoid memory allocation that HAL may do;
            // Because of MCB's partial IOs may be smaller than one page

            Size = PAGE_SIZE - (ULONG)((ULONG_PTR)PageVa & (PAGE_SIZE - 1));
            if (IoLength > Size) {
                IoLength = Size;
            }
        }

        //
        // Build the Mdl for the Io
        //

        MmInitializeMdl(Mdl, PageVa, IoLength);
        Mdl->MappedSystemVa = PageVa;
        Mdl->MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;
        for (i=0; i < NoPages; i++) {
            pa = MmGetPhysicalAddress((PVOID) (((ULONG_PTR)PageVa) + (i << PAGE_SHIFT)));
            MdlPage[i] = (PFN_NUMBER) (pa.QuadPart >> PAGE_SHIFT);
        }

        //
        // Write the data
        //

        StartCount = HIBER_GET_TICK_COUNT(NULL);

        if (Locals != NULL && HIBER_USE_DMA (HiberContext)) {
            Status = HiberContext->DumpStack->Init.WritePendingRoutine (IO_DUMP_WRITE_START,
                                                                        &IoLocation,
                                                                        Mdl,
                                                                        DmaIoPtr->DumpLocalData);

            if (Status != STATUS_PENDING && !NT_SUCCESS (Status)) {
                DBGOUT (("WriteDMA returned bad status 0x%x -- will use PIO\n", Status));
                DmaIoPtr->UseDma = FALSE;
                goto RetryWithPIO;
            }
        } else {
            RetryWithPIO:
            Status = HiberContext->DumpStack->Init.WriteRoutine (&IoLocation, Mdl);
        }

        EndCount = HIBER_GET_TICK_COUNT(NULL);
        HiberContext->PerfInfo.IoTicks += EndCount - StartCount;

        //
        // Keep track of the number of pages written, and dump device calls
        // made for performance metric reasons
        //

        HiberContext->PerfInfo.PagesWritten += (ULONG)NoPages;
        HiberContext->PerfInfo.DumpCount    += 1;

        //
        // Io complete or will be complete
        //

        Length   -= IoLength;
        FileBase += IoLength;
        PageVa   = (PVOID) (((PUCHAR) PageVa) + IoLength);

        // Check status
        if (Locals != NULL) {
            if (Status == STATUS_PENDING) {
#define X(type,name) Locals->name = name
                HIBER_WRITE_PAGES_LOCALS_LIST (X)
#undef  X
                return;
                ResumeIO:
                Status = STATUS_SUCCESS;
            }
        }

        if (!NT_SUCCESS(Status)) {
            HiberContext->Status = Status;
            break;
        }
    }

    if (Locals != NULL) {
        // Completed IO request -- mark region as free
        ASSERT (PageVa == DmaIoPtr->Busy.Ptr + DmaIoPtr->Busy.Size);
        PopIORegionMove (&DmaIoPtr->Free, &DmaIoPtr->Busy, DmaIoPtr->Busy.Size);
    }
}


UCHAR
PopGetHiberFlags(
    VOID
    )
/*++

Routine Description:

    Determines any hibernation flags which need to be written
    into the hiber image and made visible to the osloader at
    resume time

Arguments:

    None

Return Value:

    UCHAR containing hibernation flags. Currently defined flags:
        PO_HIBER_APM_RECONNECT

--*/

{
    UCHAR Flags=0;
#if defined(i386)
    PULONG ApmActive;
    NTSTATUS Status;
    UCHAR ValueBuff[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuff;
    ULONG ResultLength;
    HANDLE ApmActiveKey;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING Name;
#endif

    PAGED_CODE();

#if defined(i386)
    //
    // Open the APM active key to determine if APM is running.
    //
    RtlInitUnicodeString(&Name, PopApmActiveFlag);
    InitializeObjectAttributes(&ObjectAttributes,
                               &Name,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);
    Status = ZwOpenKey(&ApmActiveKey,
                       KEY_READ,
                       &ObjectAttributes);
    if (NT_SUCCESS(Status)) {

        //
        // Query the Active value. A value of 1 indicates that APM is running.
        //
        RtlInitUnicodeString(&Name, PopApmFlag);
        Status = ZwQueryValueKey(ApmActiveKey,
                                 &Name,
                                 KeyValuePartialInformation,
                                 ValueInfo,
                                 sizeof(ValueBuff),
                                 &ResultLength);
        ZwClose(ApmActiveKey);
        if (NT_SUCCESS(Status) && (ValueInfo->Type == REG_DWORD)) {
            ApmActive = (PULONG)&ValueInfo->Data;
            if (*ApmActive == 1) {
                Flags |= PO_HIBER_APM_RECONNECT;
            }
        }
    }

#endif

#if defined(i386) || defined(_AMD64_)            

    //
    // Remember if no-execute is enabled
    //

    if (MmPaeMask & 0x8000000000000000UI64) {
        Flags |= PO_HIBER_NO_EXECUTE;
    }

#endif

    return(Flags);
}


PMDL
PopSplitMdl(
    IN PMDL Original,
    IN ULONG SplitPages
    )
/*++

Routine Description:

    Splits a new MDL of length SplitPages out from the original MDL.
    This is needed so that when we have an enormous MDL of spare pages
    we do not have to map the whole thing, just the part we need.

Arguments:

    Original - supplies the original MDL. The length of this MDL will
               be decreated by SplitPages

    SplitPages - supplies the length (in pages) of the new MDL.

Return Value:

    pointer to newly allocated MDL
    NULL if a new MDL could not be allocated

--*/

{
    PMDL NewMdl;
    ULONG Length;
    PPFN_NUMBER SourcePages;
    PPFN_NUMBER DestPages;

    Length = SplitPages << PAGE_SHIFT;

    NewMdl = ExAllocatePoolWithTag(NonPagedPool,
                                   MmSizeOfMdl(NULL, Length),
                                   POP_HMAP_TAG);
    if (NewMdl == NULL) {
        return(NULL);
    }
    MmInitializeMdl(NewMdl, NULL, Length);
    DestPages = (PPFN_NUMBER)(NewMdl + 1);
    SourcePages = (PPFN_NUMBER)(Original + 1) + BYTES_TO_PAGES(Original->ByteCount) - SplitPages;
    RtlCopyMemory(DestPages, SourcePages, SplitPages * sizeof(PFN_NUMBER));
    Original->ByteCount = Original->ByteCount - Length;

    return(NewMdl);
}


PSECURITY_DESCRIPTOR
PopCreateHiberFileSecurityDescriptor(
    VOID
    )
/*++

Routine Description:

    This routine allocates and initializes the default security descriptor
    for the hiber file.

    The caller is responsible for freeing the allocated security descriptor
    when he is done with it.

Arguments:

    None

Return Value:

    Pointer to an initialized security descriptor if successful.

    A null pointer otherwise

--*/

{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR SecurityDescriptor=NULL;
    PACL Acl=NULL;
    PACL AclCopy=NULL;
    PSID WorldSid=NULL;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    ULONG AceLength;
    ULONG AclLength;
    PACE_HEADER AceHeader;

    PAGED_CODE();

    //
    // Allocate and initialize the SIDs we will need.
    //
    WorldSid  = ExAllocatePoolWithTag(PagedPool, RtlLengthRequiredSid(1), POP_HIBR_TAG);
    if (WorldSid  == NULL) {
        goto Done;
    }

    if ((!NT_SUCCESS(RtlInitializeSid(WorldSid, &WorldAuthority, 1)))) {
        goto Done;
    }

    *(RtlSubAuthoritySid(WorldSid, 0)) = SECURITY_WORLD_RID;

    ASSERT(RtlValidSid(WorldSid));

    //
    // Compute the size of the ACE list
    //
    AceLength = (SeLengthSid(WorldSid)  -
                 sizeof(ULONG)          +
                 sizeof(ACCESS_ALLOWED_ACE)); 
    //
    // Allocate and initialize the ACL
    //
    AclLength = AceLength + sizeof(ACL);
    Acl = ExAllocatePoolWithTag(PagedPool, AclLength, POP_HIBR_TAG);
    if (Acl == NULL) {
        DbgPrint("PopCreateHiberFileSecurityDescriptor: couldn't allocate ACL\n");
        goto Done;
    }

    Status = RtlCreateAcl(Acl, AclLength, ACL_REVISION);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("PopCreateHiberFileSecurityDescriptor: couldn't initialize ACL\n");
        goto Done;
    }

    //
    // Now add the ACEs to the ACL
    //
    Status = RtlAddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    DELETE,
                                    WorldSid);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("PopCreateHiberFileSecurityDescriptor: RtlAddAce failed status %08lx\n", Status);
        goto Done;
    }

    //
    // Make the ACEs inheritable
    //
    Status = RtlGetAce(Acl,0,&AceHeader);
    ASSERT(NT_SUCCESS(Status));
    AceHeader->AceFlags |= CONTAINER_INHERIT_ACE;

    //
    // We are finally ready to allocate and initialize the security descriptor
    // Allocate enough space to hold both the security descriptor and the
    // ACL.  This allows us to free the whole thing at once when we are
    // done with it.
    //
    SecurityDescriptor = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(SECURITY_DESCRIPTOR) + AclLength,
                            POP_HIBR_TAG
                            );

    if (SecurityDescriptor == NULL) {
        DbgPrint("PopCreateHiberFileSecurityDescriptor: Couldn't allocate Sec. Desc.\n");
        goto Done;
    }

    AclCopy = (PACL)((PISECURITY_DESCRIPTOR)SecurityDescriptor+1);
    RtlCopyMemory(AclCopy, Acl, AclLength);

    Status = RtlCreateSecurityDescriptor( SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION );
    if (!NT_SUCCESS(Status)) {
        DbgPrint("PopCreateHiberFileSecurityDescriptor: CreateSecDesc failed %08lx\n",Status);
        ExFreePool(SecurityDescriptor);
        goto Done;
    }

    Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                           TRUE,
                                           AclCopy,
                                           FALSE );
    if (!NT_SUCCESS(Status)) {
        DbgPrint("PopCreateHiberFileSecurityDescriptor: SetDacl failed %08lx\n",Status);
        ExFreePool(SecurityDescriptor);
        goto Done;
    }

    //
    // free any allocations we made
    //
Done:
    if (WorldSid!=NULL) {
        ExFreePool(WorldSid);
    }
    if (Acl!=NULL) {
        ExFreePool(Acl);
    }

    return(SecurityDescriptor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\misc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module implements miscellaneous power management functions

Author:

    Ken Reneris (kenr) 19-July-1994

Revision History:

--*/


#include "pop.h"


#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE,PoInitializeDeviceObject)
#pragma alloc_text(PAGE,PopCleanupPowerState)
#pragma alloc_text(PAGE,PopChangeCapability)
#pragma alloc_text(PAGE,PopExceptionFilter)
#pragma alloc_text(PAGELK,PopSystemStateString)
#pragma alloc_text(PAGE,PopOpenPowerKey)
#pragma alloc_text(PAGE,PopInitializePowerPolicySimulate)
#pragma alloc_text(PAGE,PopSaveHeuristics)
#pragma alloc_text(PAGE,PoInvalidateDevicePowerRelations)
#pragma alloc_text(PAGE,PoGetLightestSystemStateForEject)
#pragma alloc_text(PAGE,PoGetDevicePowerState)
#pragma alloc_text(PAGE, PopUnlockAfterSleepWorker)

#if DBG
#pragma alloc_text(PAGE, PopPowerActionString)
#pragma alloc_text(PAGE, PopAssertPolicyLockOwned)
#endif

#endif

//
// TCP/IP checksum that we use if it is available
//

ULONG
tcpxsum(
   IN ULONG cksum,
   IN PUCHAR buf,
   IN ULONG_PTR len
   );

VOID
PoInitializeDeviceObject (
    IN PDEVOBJ_EXTENSION   DeviceObjectExtension
    )
{
    //
    // default to unspecified power states, not Inrush, Pageable.
    //

    DeviceObjectExtension->PowerFlags = 0L;

    PopSetDoSystemPowerState(DeviceObjectExtension, PowerSystemUnspecified);
    PopSetDoDevicePowerState(DeviceObjectExtension, PowerDeviceUnspecified);

    DeviceObjectExtension->Dope = NULL;
}

VOID
PoRunDownDeviceObject (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    KIRQL   OldIrql;
    PDEVOBJ_EXTENSION    doe;
    PDEVICE_OBJECT_POWER_EXTENSION  pdope;

    doe = (PDEVOBJ_EXTENSION) DeviceObject->DeviceObjectExtension;

    //
    // force off any idle counter that may be active
    //

    PoRegisterDeviceForIdleDetection(
        DeviceObject, 0, 0, PowerDeviceUnspecified
        );

    PopLockIrpSerialList( &OldIrql );
    if (PopFindIrpByDeviceObject(DeviceObject, DevicePowerState) ||
        PopFindIrpByDeviceObject(DeviceObject, SystemPowerState))
    {

        PopInternalAddToDumpFile( NULL, 0, DeviceObject, NULL, NULL, NULL );
        KeBugCheckEx(
            DRIVER_POWER_STATE_FAILURE,
            DEVICE_DELETED_WITH_POWER_IRPS,
            (ULONG_PTR) DeviceObject,
            0,
            0
            );
    }
    PopUnlockIrpSerialList( OldIrql );

    //
    // knock down notify structures attached to this DO.
    //
    PopRunDownSourceTargetList(DeviceObject);

    //
    // knock down the dope
    //
    pdope = doe->Dope;
    if (pdope) {
        ASSERT(ExPageLockHandle);
        MmLockPagableSectionByHandle(ExPageLockHandle);
        PopAcquireVolumeLock ();
        PopLockDopeGlobal(&OldIrql);
        if (pdope->Volume.Flink) {
            RemoveEntryList (&pdope->Volume);
            doe->Dope->Volume.Flink = NULL;
            doe->Dope->Volume.Blink = NULL;
        }

        doe->Dope = NULL;
        ExFreePool(pdope);
        PopUnlockDopeGlobal(OldIrql);
        PopReleaseVolumeLock ();
        MmUnlockPagableImageSection (ExPageLockHandle);
    }
}

VOID
PopCleanupPowerState (
    IN OUT PUCHAR       PowerState
    )
/*++

Routine Description:

    Used to cleanup the Thread->Tcb.PowerState or the Process->Pcb.PowerState
    during thread or process rundown

Arguments:

    PowerState          - Which power state to cleanup

Return Value:

    None

--*/
{
    ULONG               OldFlags;

    //
    // If power state is set, clean it up
    //

    if (*PowerState) {
        PopAcquirePolicyLock ();

        //
        // Get current settings and clear them
        //

        OldFlags = *PowerState | ES_CONTINUOUS;
        *PowerState = 0;

        //
        // Account for attribute settings which are being cleared
        //

        PopApplyAttributeState (ES_CONTINUOUS, OldFlags);

        //
        // Done
        //

        PopReleasePolicyLock (TRUE);
    }
}


VOID
PoNotifySystemTimeSet (
    VOID
    )
/*++

Routine Description:

    Called by KE after a new system time has been set.  Enqueues
    a notification to the proper system components that the time
    has been changed.

Arguments:

    None

Return Value:

    None

--*/
{
    KIRQL       OldIrql;

    if (PopEventCallout) {
        KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);
        ExNotifyCallback (ExCbSetSystemTime, NULL, NULL);
        PopGetPolicyWorker (PO_WORKER_TIME_CHANGE);
        PopCheckForWork (TRUE);
        KeLowerIrql (OldIrql);
    }
}


VOID
PopChangeCapability (
    IN PBOOLEAN PresentFlag,
    IN BOOLEAN IsPresent
    )
{
    //
    // If feature wasn't present before, it is now.  Re-compute policies
    // as system capabilities changed
    //

    if (*PresentFlag != IsPresent) {
        *PresentFlag = IsPresent;
        PopResetCurrentPolicies ();
        PopSetNotificationWork (PO_NOTIFY_CAPABILITIES);
    }
}


#if DBG

VOID
PopAssertPolicyLockOwned(
    VOID
    )
{
    PAGED_CODE();
    ASSERT (PopPolicyLockThread == KeGetCurrentThread());
}

#endif // DBG


VOID
FASTCALL
PopInternalAddToDumpFile (
    IN OPTIONAL PVOID DataBlock,
    IN OPTIONAL ULONG DataBlockSize,
    IN OPTIONAL PDEVICE_OBJECT  DeviceObject,
    IN OPTIONAL PDRIVER_OBJECT  DriverObject,
    IN OPTIONAL PDEVOBJ_EXTENSION Doe,
    IN OPTIONAL PDEVICE_OBJECT_POWER_EXTENSION  Dope
    )
/*++

Routine Description:

    Called just before bugchecking.  This function will ensure that
    things we care about get into the dump file for later debugging.
    
    It should be noted that many of the parameters can be derived
    from each other.  However, since we're about to bugcheck, we run
    a risk of double-faulting while we're chasing pointers.  Therefore,
    we give the caller the option to override some of the pointers by
    sending us a pointer directly.

Arguments:

    DataBlock - Generic block of memory to place into the dump file.
    
    DataBlockSize - Size of DataBlock (in bytes).
    
    DeviceObject - DEVICE_OBJECT to place into dump file.
    
    DriverObject - DRIVER_OBJECT to place into dump file.
                   N.B. This overrides a value we may find in DeviceObject->DriverObject
                   
    Doe - DEVOBJ_EXTENSION to place into dump file.
          N.B. This overrides a value we may find in DeviceObject->DeviceObjectExtension
          
    Dope - DEVICE_OBJECT_POWER_EXTENSION to place into the dump file.
           N.B. This overrides a value we may find in Doe->Dope (or by induction, DeviceObject->DeviceObjectExtension->Dope

Return Value:

    None

--*/


{
    PDRIVER_OBJECT lPDriverObject = NULL;
    PDEVOBJ_EXTENSION lPDoe = NULL;
    PDEVICE_OBJECT_POWER_EXTENSION  lPDope = NULL;

    //
    // Insert any parameters that were sent in.
    //
    if( DataBlock ) {
        IoAddTriageDumpDataBlock(
                PAGE_ALIGN(DataBlock),
                (DataBlockSize ? BYTES_TO_PAGES(DataBlockSize) : PAGE_SIZE) );
    }

    if( DeviceObject ) {
        IoAddTriageDumpDataBlock(DeviceObject, sizeof(DEVICE_OBJECT));
    }

    if( DriverObject ) {
        lPDriverObject = DriverObject;
    } else if( (DeviceObject) && (DeviceObject->DriverObject) ) {
        lPDriverObject = DeviceObject->DriverObject;
    }
    if( lPDriverObject ) {
        IoAddTriageDumpDataBlock(lPDriverObject, lPDriverObject->Size);

        if( lPDriverObject->DriverName.Buffer ) {
            IoAddTriageDumpDataBlock(lPDriverObject->DriverName.Buffer, lPDriverObject->DriverName.Length);
        }
    }


    if( Doe ) {
        lPDoe = Doe;
    } else if( DeviceObject ) {
        lPDoe = DeviceObject->DeviceObjectExtension;
    }
    if( lPDoe ) {
        IoAddTriageDumpDataBlock(PAGE_ALIGN(lPDoe), sizeof(DEVOBJ_EXTENSION));        
        
        if( lPDoe->DeviceNode ) {
            IoAddTriageDumpDataBlock(PAGE_ALIGN(lPDoe->DeviceNode), PAGE_SIZE);
        }
        if( lPDoe->AttachedTo ) {
            IoAddTriageDumpDataBlock(PAGE_ALIGN(lPDoe->AttachedTo), PAGE_SIZE);
        }
        if( lPDoe->Vpb ) {
            IoAddTriageDumpDataBlock(PAGE_ALIGN(lPDoe->Vpb), PAGE_SIZE);
        }
    }


    if( Dope ) {
        lPDope = Dope;
    } else if( lPDoe ) {
        lPDope = lPDoe->Dope;
    }
    if( lPDope ) {
        IoAddTriageDumpDataBlock(PAGE_ALIGN(lPDope), sizeof(DEVICE_OBJECT_POWER_EXTENSION));
    }


    //
    // Globals that may be of interest.
    //
    IoAddTriageDumpDataBlock(PAGE_ALIGN(&PopHiberFile), sizeof(POP_HIBER_FILE));

    
    IoAddTriageDumpDataBlock(PAGE_ALIGN(&PopAction), sizeof(POP_POWER_ACTION));
    if(PopAction.DevState) { 
        IoAddTriageDumpDataBlock(PAGE_ALIGN(&(PopAction.DevState)), sizeof(POP_DEVICE_SYS_STATE));
    }
    if(PopAction.HiberContext) {
        IoAddTriageDumpDataBlock(PAGE_ALIGN(&(PopAction.HiberContext)), sizeof(POP_HIBER_CONTEXT));
    }


    IoAddTriageDumpDataBlock(PAGE_ALIGN(&PopCB), sizeof(POP_COMPOSITE_BATTERY));
    if(PopCB.StatusIrp) {
        IoAddTriageDumpDataBlock(PAGE_ALIGN(&(PopCB.StatusIrp)), sizeof(IRP));
    }


    IoAddTriageDumpDataBlock(PAGE_ALIGN(PopAttributes), sizeof(POP_STATE_ATTRIBUTE) * POP_NUMBER_ATTRIBUTES);
}


VOID
FASTCALL
_PopInternalError (
    IN ULONG    BugCode
    )
{
    KeBugCheckEx( INTERNAL_POWER_ERROR,
                  POP_INTERNAL, 
                  BugCode, 
                  0, 
                  0);
}

EXCEPTION_DISPOSITION
PopExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionInfo,
    IN BOOLEAN AllowRaisedException
    )
{
    //
    // If handler wants raised expceptions, check the exception code
    //

    if (AllowRaisedException) {
        switch (ExceptionInfo->ExceptionRecord->ExceptionCode) {
            case STATUS_INVALID_PARAMETER:
            case STATUS_INVALID_PARAMETER_1:
            case STATUS_INVALID_PARAMETER_2:
                return EXCEPTION_EXECUTE_HANDLER;
        }
    }

    //
    // Not allowed
    //

    PoPrint (PO_ERROR, ("PoExceptionFilter: exr %x, cxr %x",
                            ExceptionInfo->ExceptionRecord,
                            ExceptionInfo->ContextRecord
                        ));


    PopInternalAddToDumpFile( ExceptionInfo->ExceptionRecord,
                              sizeof(EXCEPTION_RECORD),
                              NULL,
                              NULL,
                              NULL,
                              NULL );
    PopInternalAddToDumpFile( ExceptionInfo->ContextRecord,
                              sizeof(CONTEXT),
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    KeBugCheckEx( INTERNAL_POWER_ERROR,
                  0x101,
                  POP_MISC,
                  (ULONG_PTR)ExceptionInfo,
                  0 );
}

PCHAR
PopSystemStateString(
    IN SYSTEM_POWER_STATE   SystemState
    )
// This function is not DBG because...
{
    PCHAR      p;

    switch (SystemState) {
        case PowerSystemUnspecified:    p = "Unspecified";      break;
        case PowerSystemWorking:        p = "Working";          break;
        case PowerSystemSleeping1:      p = "Sleeping1";        break;
        case PowerSystemSleeping2:      p = "Sleeping2";        break;
        case PowerSystemSleeping3:      p = "Sleeping3";        break;
        case PowerSystemHibernate:      p = "Hibernate";        break;
        case PowerSystemShutdown:       p = "Shutdown";         break;
        default:                        p = "?";
    }

    return p;
}



#if DBG
PCHAR
PopPowerActionString(
    IN POWER_ACTION     PowerAction
    )
// This function is not DBG because...
{
    PCHAR      p;

    switch (PowerAction) {
        case PowerActionNone:           p = "None";             break;
        case PowerActionSleep:          p = "Sleep";            break;
        case PowerActionHibernate:      p = "Hibernate";        break;
        case PowerActionShutdown:       p = "Shutdown";         break;
        case PowerActionShutdownReset:  p = "ShutdownReset";    break;
        case PowerActionShutdownOff:    p = "ShutdownOff";      break;
        case PowerActionWarmEject:      p = "WarmEject";        break;
        default:                        p = "?";
    }

    return p;
}
#endif

#if DBG

//
// PowerTrace variables
//
ULONG   PoPowerTraceControl = 0L;
ULONG   PoPowerTraceCount = 0L;
PCHAR   PoPowerTraceMinorCode[] = {
        "wait", "seq", "set", "query"
        };
PCHAR   PoPowerTracePoint[] = {
        "calldrv", "present", "startnxt", "setstate", "complete"
        };
PCHAR   PoPowerType[] = {
        "sys", "dev"
        };



VOID
PoPowerTracePrint(
    ULONG    TracePoint,
    ULONG_PTR Caller,
    ULONG_PTR CallerCaller,
    ULONG_PTR DeviceObject,
    ULONG_PTR Arg1,
    ULONG_PTR Arg2
    )
/*
    Example:

PLOG,00015,startnxt,c@ffea1345,cc@ffea5643,do@80081234,irp@8100ff00,ios@8100ff10,query,sys,3
*/
{
    PIO_STACK_LOCATION  Isp;
    PCHAR               tracename;
    ULONG               j;
    ULONG               tp;

    UNREFERENCED_PARAMETER (Caller);
    UNREFERENCED_PARAMETER (CallerCaller);

    PoPowerTraceCount++;

    if (PoPowerTraceControl & TracePoint) {
        tracename = NULL;
        tp = TracePoint;
        for (j = 0; j < 33; tp = tp >> 1, j = j+1)
        {
            if (tp & 1) {
                tracename = PoPowerTracePoint[j];
                j = 33;
            }
        }

        DbgPrint("PLOG,%05ld,%8s,do@%08lx",
            PoPowerTraceCount,tracename,DeviceObject
            );
        if ((TracePoint == POWERTRACE_CALL) ||
            (TracePoint == POWERTRACE_PRESENT) ||
            (TracePoint == POWERTRACE_STARTNEXT))
        {
            DbgPrint(",irp@%08lx,isp@%08lx",Arg1,Arg2);
            Isp = (PIO_STACK_LOCATION)Arg2;
            DbgPrint(",%5s", PoPowerTraceMinorCode[Isp->MinorFunction]);
            if ((Isp->MinorFunction == IRP_MN_SET_POWER) ||
                (Isp->MinorFunction == IRP_MN_QUERY_POWER))
            {
                DbgPrint(",%s,%d",
                    PoPowerType[Isp->Parameters.Power.Type],
                    ((ULONG)Isp->Parameters.Power.State.DeviceState)-1  // hack - works for sys state too
                    );
            }
        } else if (TracePoint == POWERTRACE_SETSTATE) {
            DbgPrint(",,,,%s,%d", PoPowerType[Arg1], Arg2-1);
        } else if (TracePoint == POWERTRACE_COMPLETE) {
            DbgPrint(",irp@%08lx,isp@%08lx",Arg1,Arg2);
        }
        DbgPrint("\n");
    }
    return;
}

#endif

ULONG PoSimpleCheck(IN ULONG                PartialSum,
                    IN PVOID                SourceVa,
                    IN ULONG_PTR            Length)
{
   // Just use the TCP/IP check sum
   //

   return tcpxsum(PartialSum, (PUCHAR)SourceVa, Length);
}

NTSTATUS
PopOpenPowerKey (
    OUT PHANDLE Handle
    )
/*++

Routine Description:

    Open and return the handle to the power policy key in the registry

Arguments:

    Handle      - Handle to power policy key

Return Value:

    Status

--*/
{
    UNICODE_STRING          UnicodeString;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    NTSTATUS                Status;
    HANDLE                  BaseHandle;
    ULONG                   disposition;

    //
    // Open current control set
    //

    InitializeObjectAttributes(
            &ObjectAttributes,
            &CmRegistryMachineSystemCurrentControlSet,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

    Status = ZwOpenKey (
                &BaseHandle,
                KEY_READ | KEY_WRITE,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Open power branch
    //

    RtlInitUnicodeString (&UnicodeString, PopRegKey);

    InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            BaseHandle,
            (PSECURITY_DESCRIPTOR) NULL
            );

    Status = ZwCreateKey (
                Handle,
                KEY_READ | KEY_WRITE,
                &ObjectAttributes,
                0,
                (PUNICODE_STRING) NULL,
                REG_OPTION_NON_VOLATILE,
                &disposition
                );

    ZwClose (BaseHandle);
    return Status;
}

VOID
PopInitializePowerPolicySimulate(
    VOID
    )
/*++

Routine Description:

    Reads PopSimulate out of the registry. Also applies any overrides that might
    be required as a result of the installed system (hydra for example)

Arguments:

    NONE.

Return Value:

    Status

--*/
{
    UNICODE_STRING          UnicodeString;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    NTSTATUS                Status;
    HANDLE                  BaseHandle;
    HANDLE                  Handle;
    ULONG                   Length;
    ULONG                   disposition;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION   Inf;
        ULONG Data;
    } PartialInformation;


    PAGED_CODE();

    //
    // Open current control set
    //
    InitializeObjectAttributes(
        &ObjectAttributes,
        &CmRegistryMachineSystemCurrentControlSet,
        OBJ_CASE_INSENSITIVE,
        NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );
    Status = ZwOpenKey(
        &BaseHandle,
        KEY_READ,
        &ObjectAttributes
        );
    if (!NT_SUCCESS(Status)) {

        goto done;

    }

    // Get the right key
    RtlInitUnicodeString (&UnicodeString, PopSimulateRegKey);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        BaseHandle,
        (PSECURITY_DESCRIPTOR) NULL
        );
    Status = ZwCreateKey(
        &Handle,
        KEY_READ,
        &ObjectAttributes,
        0,
        (PUNICODE_STRING) NULL,
        REG_OPTION_NON_VOLATILE,
        &disposition
        );
    ZwClose(BaseHandle);
    if(!NT_SUCCESS(Status)) {

       goto done;

    }

    //
    // Get the value of the simulation
    //
    RtlInitUnicodeString (&UnicodeString,PopSimulateRegName);
    Status = ZwQueryValueKey(
        Handle,
        &UnicodeString,
        KeyValuePartialInformation,
        &PartialInformation,
        sizeof (PartialInformation),
        &Length
        );
    ZwClose (Handle);
    if (!NT_SUCCESS(Status)) {

       goto done;

    }

    //
    // Check to make sure the retrieved data makes sense
    //
    if(PartialInformation.Inf.DataLength != sizeof(ULONG))  {

       goto done;

    }

    //
    // Initialize PopSimulate
    //
    PopSimulate = *((PULONG)(PartialInformation.Inf.Data));

done:
    return;
}

VOID
PopSaveHeuristics (
    VOID
    )
/*++

Routine Description:

    Open and return the handle to the power policy key in the registry

Arguments:

    Handle      - Handle to power policy key

Return Value:

    Status

--*/
{
    HANDLE                  handle;
    UNICODE_STRING          UnicodeString;
    NTSTATUS                Status;

    ASSERT_POLICY_LOCK_OWNED();

    Status = PopOpenPowerKey (&handle);
    if (NT_SUCCESS(Status)) {

        PopHeuristics.Dirty = FALSE;

        RtlInitUnicodeString (&UnicodeString, PopHeuristicsRegName);
        Status = ZwSetValueKey (
                    handle,
                    &UnicodeString,
                    0L,
                    REG_BINARY,
                    &PopHeuristics,
                    sizeof (PopHeuristics)
                    );
        ZwClose(handle);
    }
}

VOID
PoInvalidateDevicePowerRelations(
    PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    This routine is called by IoInvalidateDeviceRelations when the
    type of invalidation is for power relations.

    It will will knock down the notify network around the supplied
    device object.

Arguments:

    DeviceObject - supplies the address of the device object whose
            power relations are now invalid.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    PopRunDownSourceTargetList(DeviceObject);
    return;
}

NTSTATUS
PoGetLightestSystemStateForEject(
    IN   BOOLEAN              DockBeingEjected,
    IN   BOOLEAN              HotEjectSupported,
    IN   BOOLEAN              WarmEjectSupported,
    OUT  PSYSTEM_POWER_STATE  LightestSleepState
    )
/*++

Routine Description:

    This routine is called by ntos\pnp\pnpevent.c to determine the lightest
    sleep state an eject operation can be executed in. This function is to be
    called after all appropriate batteries/power adapters have been *removed*,
    but before the eject has occured.

Arguments:

    DockBeingEjected    - TRUE iff a dock is among the items that may be
                          ejected.

    HotEjectSupported   - TRUE if the device being ejected supports S0 VCR
                          style eject.

    WarmEjectSupported  - TRUE if the device being ejected supports S1-S4
                          style warm ejection.

    LightestSleepState  - Set to the lightest sleep state the device can be
                          ejected in. On error, this is set to
                          PowerSystemUnspecified.

    N.B. If both HotEjectSupported and WarmEjectSupported are FALSE, it is
         assumed this device is "user" ejectable in S0 (ie. Hot ejectable).

Return Value:

    NTSTATUS - If there is insufficient power to do the indicated operation,
               STATUS_INSUFFICIENT_POWER is returned.

--*/
{
    SYSTEM_BATTERY_STATE            systemBatteryInfo;
    UNICODE_STRING                  unicodeString;
    NTSTATUS                        status;
    HANDLE                          handle;
    ULONG                           length;
    ULONG                           currentPercentage;
    UCHAR                           ejectPartialInfo[SIZEOF_EJECT_PARTIAL_INFO];
    PUNDOCK_POWER_RESTRICTIONS      undockRestrictions;
    PKEY_VALUE_PARTIAL_INFORMATION  partialInfoHeader;

    PAGED_CODE();

    //
    // Preinit sleep to failure.
    //
    *LightestSleepState = PowerSystemUnspecified;

    //
    // If neither, then it's a "user" assisted hot eject.
    //
    if ((!HotEjectSupported) && (!WarmEjectSupported)) {

        HotEjectSupported = TRUE;
    }

    //
    // If it's not a dock device being ejected, we assume no great changes
    // in power will occur after the eject. Therefore our policy is simple,
    // if we can't do hot eject, we'll try warm eject in the best possible
    // sleep state.
    //
    if (!DockBeingEjected) {

        if (HotEjectSupported) {

            *LightestSleepState = PowerSystemWorking;

        } else {

            ASSERT(WarmEjectSupported);
            *LightestSleepState = PowerSystemSleeping1;
        }

        return STATUS_SUCCESS;
    }

    //
    // We are going to eject a dock, so we retrieve our undock power policy.
    //
    status = PopOpenPowerKey (&handle);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    // Get the right key

    RtlInitUnicodeString (&unicodeString, PopUndockPolicyRegName);

    status = ZwQueryValueKey (
        handle,
        &unicodeString,
        KeyValuePartialInformation,
        &ejectPartialInfo[0],
        sizeof (ejectPartialInfo),
        &length
        );

    ZwClose (handle);
    if ((!NT_SUCCESS(status)) && (status != STATUS_OBJECT_NAME_NOT_FOUND)) {

        return status;
    }

    // Check to make sure the retrieved data makes sense

    partialInfoHeader = (PKEY_VALUE_PARTIAL_INFORMATION) ejectPartialInfo;

    undockRestrictions =
        (PUNDOCK_POWER_RESTRICTIONS) (ejectPartialInfo + SIZEOF_PARTIAL_INFO_HEADER);

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // These defaults match Win9x behavior. 0% for sleep undock means
        // we always allow undock into Sx. This is bad for some laptops, but
        // legal for those that have reserve power we don't see.
        //
        undockRestrictions->HotUndockMinimumCapacity = 10; // In percent
        undockRestrictions->SleepUndockMinimumCapacity = 0; // In percent

    } else if (partialInfoHeader->DataLength <
        FIELD_OFFSET(UNDOCK_POWER_RESTRICTIONS, HotUndockMinimumCapacity)) {

        return STATUS_REGISTRY_CORRUPT;

    } else if (undockRestrictions->Version != 1) {

        //
        // We cannot interpret the information stored in the registry. Bail.
        //
        return STATUS_UNSUCCESSFUL;

    } else if ((partialInfoHeader->DataLength < sizeof(UNDOCK_POWER_RESTRICTIONS)) ||
        (undockRestrictions->Size != partialInfoHeader->DataLength)) {

        //
        // Malformed for version 1.
        //
        return STATUS_REGISTRY_CORRUPT;
    }

    //
    // Retrieve all the fun battery info. Note that we do not examine the
    // AC power adapter information as the best bus we have today (ACPI) doesn't
    // let us know if an AC adapter is leaving when we undock (so we assume all
    // will). If the vendor *did* put his adapter in the AML namespace, we would
    // enter CRITICAL shutdown immediately upon change driver in our current
    // design.
    //
    status = NtPowerInformation(
        SystemBatteryState,
        NULL,
        0,
        &systemBatteryInfo,
        sizeof(systemBatteryInfo)
        ) ;

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Convert current capacity in milliwatt hours to percentage remaining. We
    // should really make a decision based on the amount of time remaining under
    // peak milliwatt usage, but we do not collect enough information for this
    // today...
    //
    if (systemBatteryInfo.MaxCapacity == 0) {

        currentPercentage = 0;

    } else {

        //
        // Did we "wrap" around?
        //
        if ((systemBatteryInfo.RemainingCapacity * 100) <=
            systemBatteryInfo.RemainingCapacity) {

            currentPercentage = 0;
        } else {

            currentPercentage = (systemBatteryInfo.RemainingCapacity * 100)/
                                 systemBatteryInfo.MaxCapacity;
        }
    }

    //
    // Pick the appropriate sleep state based on our imposed limits.
    //
    if ((currentPercentage >= undockRestrictions->HotUndockMinimumCapacity) &&
        HotEjectSupported) {

        *LightestSleepState = PowerSystemWorking;

    } else if (WarmEjectSupported) {

        if (currentPercentage >= undockRestrictions->SleepUndockMinimumCapacity) {

            *LightestSleepState = PowerSystemSleeping1;

        } else  {

            *LightestSleepState = PowerSystemHibernate;
        }

    } else {

        status = STATUS_INSUFFICIENT_POWER;
    }

    return status;
}


VOID
PoGetDevicePowerState(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    OUT DEVICE_POWER_STATE  *DevicePowerState
    )
/*++

Routine Description:

    This routine gets the power state of a given device. The object should be
    the Physical Device Object for a *Started* WDM device stack.

Arguments:

    PhysicalDeviceObject - Device object representing the bottom of a WDM
                           device stack.

    DevicePowerState - Receives the power state of the given device.

Return Value:

    None.

--*/
{
    PDEVOBJ_EXTENSION   doe;
    DEVICE_POWER_STATE  deviceState;

    PAGED_CODE();

    doe = PhysicalDeviceObject->DeviceObjectExtension;
    deviceState = PopLockGetDoDevicePowerState(doe);

    if (deviceState == PowerDeviceUnspecified) {

        //
        // The PDO isn't bothering to call PoSetPowerState. Since this API
        // shouldn't be called on non-started devices, we will call it D0.
        //
        deviceState = PowerDeviceD0;
    }

    *DevicePowerState = deviceState;
}

VOID
PopUnlockAfterSleepWorker(
    IN PVOID NotUsed
    )
/*++

Routine Description:

    This work item performs the unlocking of code and worker threads that
    corresponds to the locking done at the beginning of NtSetSystemPowerState.

    The unlocking is queued off to a delayed worker thread because it is likely
    to block on disk I/O, which will force the resume to get stuck waiting for
    the disks to spin up.

Arguments:

    NotUsed - not used

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER (NotUsed);

    MmUnlockPagableImageSection(ExPageLockHandle);
    ExSwapinWorkerThreads(TRUE);
    ExNotifyCallback (ExCbPowerState, (PVOID) PO_CB_SYSTEM_STATE_LOCK, (PVOID) 1);

    //
    // Signal that unlocking is done and it is safe to lock again.
    //
    KeSetEvent(&PopUnlockComplete, 0, FALSE);

}


NTSTATUS
PopLoggingInformation(
    OUT PVOID * Buffer,
    OUT ULONG * BufferSize
    )
/*++

Routine Description:

    This routine walks the list of logging reasons, allocating
    space for a packed array of the reasons, and copying the 
    reasons into that array.

Arguments:

    Buffer - receives buffer containing logging information.
             Buffer must be freed with ExFreePool
    BufferSize - receives the size of the buffer

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    ULONG ReasonCount,ReasonSize;
    PLIST_ENTRY Entry;
    PSYSTEM_POWER_STATE_DISABLE_REASON destReason;
    PSYSTEM_POWER_STATE_DISABLE_LIST pList;
     
    ReasonCount = 0;
    ReasonSize = 0;
    Entry = PowerStateDisableReasonListHead.Flink;

    //
    // find out how much space we need
    //
    while (Entry != &PowerStateDisableReasonListHead) {
        pList = CONTAINING_RECORD( 
                            Entry, 
                            SYSTEM_POWER_STATE_DISABLE_LIST, 
                            ListEntry);
        ReasonCount += 1;
        ReasonSize += sizeof(SYSTEM_POWER_STATE_DISABLE_REASON)+ pList->Reason->PowerReasonLength;

        Entry = Entry->Flink;
    }

    //
    // if there aren't any reasons, then we allocate space for one reason
    //
    if (ReasonCount == 0) {
        ReasonSize = sizeof(SYSTEM_POWER_STATE_DISABLE_REASON);
    }

    //
    // add in room for the returned buffer size.
    //
    ReasonSize += sizeof(ULONG);

    //
    // bugbug tag
    //
    *Buffer = ExAllocatePoolWithTag(PagedPool,ReasonSize,POP_COMMON_BUFFER_TAG);

    if (!*Buffer) {
        *BufferSize = 0;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    *BufferSize = ReasonSize;
    **(PULONG *)Buffer = ReasonSize;
    destReason = (PSYSTEM_POWER_STATE_DISABLE_REASON) (PCHAR)(*(PCHAR *)Buffer + sizeof(ULONG));

    //
    // now fill in the reasons
    //
    if (ReasonCount != 0) {
        Entry = PowerStateDisableReasonListHead.Flink;       

        while (ReasonCount != 0 &&
               Entry != &PowerStateDisableReasonListHead) {
        
            pList = CONTAINING_RECORD( 
                                Entry, 
                                SYSTEM_POWER_STATE_DISABLE_LIST, 
                                ListEntry);

            RtlCopyMemory(
                (UNALIGNED PSYSTEM_POWER_STATE_DISABLE_REASON)destReason,
                pList->Reason,
                sizeof(SYSTEM_POWER_STATE_DISABLE_REASON) +pList->Reason->PowerReasonLength);

            destReason = (PSYSTEM_POWER_STATE_DISABLE_REASON)(PCHAR)((PCHAR)destReason + (sizeof(SYSTEM_POWER_STATE_DISABLE_REASON)+ pList->Reason->PowerReasonLength));

            Entry = Entry->Flink;
            ReasonCount -= 1;
        }
    } else {        
        //
        // in the case of no reasons, just zero the memory and set the reason code
        // to none.
        //
        RtlZeroMemory(destReason, sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
        destReason->PowerReasonCode = SPSD_REASON_NONE;
    }
        
    return(STATUS_SUCCESS);

}

NTSTATUS
PopDestroyLoggingList(
    VOID
    )
/*++

Routine Description:

    This routine destroys and tears down the list of 
    SYSTEM_POWER_STATE_DISABLE_REASON records.       

Arguments:

    None.       

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    PLIST_ENTRY Entry;
    PSYSTEM_POWER_STATE_DISABLE_LIST pList;

    Entry = PowerStateDisableReasonListHead.Flink;

    //
    // walk the list of records
    //
    while (Entry != &PowerStateDisableReasonListHead) {
        
        //
        // get the record
        //
        pList = CONTAINING_RECORD( 
                            Entry, 
                            SYSTEM_POWER_STATE_DISABLE_LIST, 
                            ListEntry);
        
        //
        // get the next entry
        //
        Entry = Entry->Flink;

        //
        // now remove this entry from the list
        //
        RemoveEntryList(&pList->ListEntry);

        //
        // now deallocate the entry
        //
        ExFreePool(pList->Reason);
        ExFreePool(pList);    
        
    }

    return(STATUS_SUCCESS);

}

PSYSTEM_POWER_STATE_DISABLE_LIST
PopGetReasonListByReasonCode(
    IN  ULONG ReasonCode
    )
/*++

Routine Description:

    This routine locates a SYSTEM_POWER_STATE_DISABLE_LIST
    record in the global list of records.    
    
Arguments:

    ReasonCode - reason code to search for.       

Return Value:

    Pointer to SYSTEM_POWER_STATE_DISABLE_LIST record.  NULL if no record
    currently exists with this reason code

--*/
{
    PLIST_ENTRY Entry;
    PSYSTEM_POWER_STATE_DISABLE_LIST pList = NULL;    
    BOOLEAN FoundRecord;

    Entry = PowerStateDisableReasonListHead.Flink;
    FoundRecord = FALSE;

    //
    // walk the list of records
    //
    while (Entry != &PowerStateDisableReasonListHead) {
        
        //
        // get the record
        //
        pList = CONTAINING_RECORD( 
                            Entry, 
                            SYSTEM_POWER_STATE_DISABLE_LIST, 
                            ListEntry);

        if (pList->Reason->PowerReasonCode == ReasonCode) {
            FoundRecord = TRUE;
            break;
        }
        
        //
        // get the next entry
        //
        Entry = Entry->Flink;
        
    }

    if (!FoundRecord) {
        pList = NULL;        
    }
    
    return(pList);
    
}



NTSTATUS
PopInsertLoggingEntry(
    IN  PSYSTEM_POWER_STATE_DISABLE_REASON Reason
    )
/*++

Routine Description:

    This routine inserts a SYSTEM_POWER_STATE_DISABLE_REASON
    record into the list of records.
    
    Internally, we use a SYSTEM_POWER_STATE_DISABLE_LIST to track
    this list, and this memory must be freed via ExFreePool.
    
    Further, we assume that the SYSTEM_POWER_STATE_DISABLE_REASON has been
    allocated via ExAllocatePoolWithTag.

Arguments:

    Reason - pointer to the record to be inserted.       

Return Value:

    NTSTATUS code indicating outcome.

--*/

{
    PSYSTEM_POWER_STATE_DISABLE_LIST pList;

    //
    // make sure the reason code isn't already in the list.
    //
    pList = PopGetReasonListByReasonCode(Reason->PowerReasonCode);
    if (pList) {
        return(STATUS_OBJECT_NAME_EXISTS);
    }

    pList = ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(SYSTEM_POWER_STATE_DISABLE_LIST),
                        POP_COMMON_BUFFER_TAG);
    if (!pList) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pList->Reason = Reason;

    InsertTailList(&PowerStateDisableReasonListHead, &pList->ListEntry);

    return(STATUS_SUCCESS);

}


PSYSTEM_POWER_STATE_DISABLE_REASON
PopGetReasonRecordByReasonCode(
    IN  ULONG ReasonCode
    )
/*++

Routine Description:

    This routine locates a SYSTEM_POWER_STATE_DISABLE_LIST
    record in the global list of records.    
    
    BUGBUG is this a safe API to use?  reason might get deallocated
    while we are using it?
    
Arguments:

    ReasonCode - reason code to search for.       

Return Value:

    Pointer to SYSTEM_POWER_STATE_DISABLE_LIST record.  NULL if no record
    currently exists with this reason code

--*/
{
    PSYSTEM_POWER_STATE_DISABLE_LIST pList;    
    
    pList = PopGetReasonListByReasonCode(ReasonCode);

    if (!pList) {
        return(NULL);        
    }

    return(pList->Reason);
    
}


NTSTATUS
PopRemoveReasonRecordByReasonCode(
    IN  ULONG ReasonCode
    )
/*++

Routine Description:

    This routine locates a SYSTEM_POWER_STATE_DISABLE_REASON
    record in the global list of records and removes it,
    deallocating the space for the record as well.
    
Arguments:

    ReasonCode - reason code to search for.       

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    PSYSTEM_POWER_STATE_DISABLE_LIST pList;    
    
    pList = PopGetReasonListByReasonCode(ReasonCode);

    if (!pList) {
        return(STATUS_NOT_FOUND);        
    }

    RemoveEntryList(&pList->ListEntry);
    ExFreePool(pList->Reason);
    ExFreePool(pList);    
    
    return(STATUS_SUCCESS);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\notify.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Po/Driver Notify functions

Author:

    Bryan Willman (bryanwi) 11-Mar-97

Revision History:

--*/


#include "pop.h"

//
// constants
//
#define POP_RECURSION_LIMIT 30

//
// macros
//
#define IS_DO_PDO(DeviceObject) \
((DeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE) && (DeviceObject->DeviceObjectExtension->DeviceNode))


//
// procedures private to notification
//
NTSTATUS
PopEnterNotification(
    PPOWER_CHANNEL_SUMMARY  PowerChannelSummary,
    PDEVICE_OBJECT          DeviceObject,
    PPO_NOTIFY              NotificationFunction,
    PVOID                   NotificationContext,
    ULONG                   NotificationType,
    PDEVICE_POWER_STATE     DeviceState,
    PVOID                   *NotificationHandle
    );

NTSTATUS
PopBuildPowerChannel(
    PDEVICE_OBJECT          DeviceObject,
    PPOWER_CHANNEL_SUMMARY  PowerChannelSummary,
    ULONG                   RecursionThrottle
    );

NTSTATUS
PopCompleteFindIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
PopFindPowerDependencies(
    PDEVICE_OBJECT          DeviceObject,
    PPOWER_CHANNEL_SUMMARY  PowerChannelSummary,
    ULONG                   RecursionThrottle
    );


VOID
PopPresentNotify(
    PDEVICE_OBJECT          DeviceObject,
    PPOWER_CHANNEL_SUMMARY  PowerChannelSummary,
    ULONG                   NotificationType
    );

//
// Speced (public) entry points
//

NTKERNELAPI
NTSTATUS
PoRegisterDeviceNotify (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PPO_NOTIFY       NotificationFunction,
    IN PVOID            NotificationContext,
    IN ULONG            NotificationType,
    OUT PDEVICE_POWER_STATE  DeviceState,
    OUT PVOID           *NotificationHandle
    )
/*++

Routine Description:

    Registers the caller to receive notification of power state changes or
    dependency invalidations related to the "channel" underneath and including
    the Physical Device Object (PDO) refereced via DeviceObject.

    The "channel" is the set of PDOs, always including the one supplied
    by DeviceObject, which form the hardware stack necessary to perform
    operations.  The channel is on when all of these PDOs are on.  It is off
    when any of them is not on.

Arguments:

    DeviceObject - supplies a PDO

    NotificationFunction - routine to call to post the notification

    NotificationContext - argument passed through as is to the NotificationFunction

    NotificationType - mask of the notifications that the caller wishes to recieve.
        Note that INVALID will always be reported, regardless of whether the
        caller asked for it.

    DeviceState - the current state of the PDO, as last reported to the
        system via PoSetPowerState

    NotificationHandle - reference to the notification instance, used to
        cancel the notification.

Return Value:

    Standard NTSTATUS values, including:
        STATUS_INVALID_PARAMETER if DeviceObject is not a PDO, or
        any other parameter is nonsense.

        STATUS_SUCCESS

        STATUS_INSUFFICIENT_RESOURCES - ususally out of memory

--*/
{
    NTSTATUS        status;
    PPOWER_CHANNEL_SUMMARY  pchannel;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // return error for nonsense parameters, or DeviceObject not PDO
    //
    if ( (NotificationFunction == NULL) ||
         (NotificationType == 0)        ||
         (NotificationHandle == NULL)   ||
         (DeviceState == NULL)          ||
         (DeviceObject == NULL) )
    {
        return  STATUS_INVALID_PARAMETER;
    }

    if ( ! (IS_DO_PDO(DeviceObject)) ) {
        return  STATUS_INVALID_PARAMETER;
    }

    //
    // acquire the notification channel lock, since we will be
    // changing channel structures
    //
    ExAcquireResourceExclusiveLite(&PopNotifyLock, TRUE);

    //
    // if the channel isn't already in place, create it
    //
    if (!PopGetDope(DeviceObject)) {
            ExReleaseResourceLite(&PopNotifyLock);
            return STATUS_INSUFFICIENT_RESOURCES;
    }

    pchannel = &(DeviceObject->DeviceObjectExtension->Dope->PowerChannelSummary);


    if (pchannel->Signature == 0) {

        //
        // we do NOT already have a channel, bug GetDope has
        // inited the notify list and set the signature and owner for us
        //

        if (!NT_SUCCESS(status = PopBuildPowerChannel(DeviceObject, pchannel, 0))) {
            ExReleaseResourceLite(&PopNotifyLock);
            return status;
        }
        pchannel->Signature = (ULONG)POP_PNCS_TAG;
    }


    //
    // since we are here, pchannel points to a filled in power channel for
    // the request PDO, so we just add this notification instance to it
    // and we are done
    //
    status = PopEnterNotification(
        pchannel,
        DeviceObject,
        NotificationFunction,
        NotificationContext,
        NotificationType,
        DeviceState,
        NotificationHandle
        );
    ExReleaseResourceLite(&PopNotifyLock);
    return status;
}


NTKERNELAPI
NTSTATUS
PoCancelDeviceNotify (
    IN PVOID            NotificationHandle
    )
/*++

Routine Description:

    Check that NotificationHandle points to a notify block and that
    it makes sense to cancel it.  Decrement ref count.  If new ref count
    is 0, blast the entry, cut it from the list, and free its memory.

Arguments:

    NotificationHandle - reference to the notification list entry of interest

Return Value:

--*/
{
    PPOWER_NOTIFY_BLOCK pnb;
    KIRQL                OldIrql;


    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    pnb = (PPOWER_NOTIFY_BLOCK)NotificationHandle;


    ExAcquireResourceExclusiveLite(&PopNotifyLock, TRUE);
    PopLockDopeGlobal(&OldIrql);

    //
    // check for blatant errors
    //
    if ( (!pnb) ||
         (pnb->Signature != (ULONG)POP_PNB_TAG) ||
         (pnb->RefCount < 0) )
    {
        ASSERT(0);                          // force a break on a debug build
        ExReleaseResourceLite(&PopNotifyLock);
        PopUnlockDopeGlobal(OldIrql);
        return  STATUS_INVALID_HANDLE;
    }

    //
    // decrement ref count.  if it's 0 afterwards we are done with this node
    //
    pnb->RefCount--;

    if (pnb->RefCount == 0) {

        //
        // blast it all, just to be paranoid (it's a low freq operation)
        //
        RemoveEntryList(&(pnb->NotifyList));
        pnb->Signature = POP_NONO;
        pnb->RefCount = -1;
        pnb->NotificationFunction = NULL;
        pnb->NotificationContext = 0L;
        pnb->NotificationType = 0;
        InitializeListHead(&(pnb->NotifyList));

        if (pnb->Invalidated) {
            PopInvalidNotifyBlockCount--;
        }

        ExFreePool(pnb);

    }

    PopUnlockDopeGlobal(OldIrql);
    ExReleaseResourceLite(&PopNotifyLock);
    return STATUS_SUCCESS;
}

//
// worker code
//

NTSTATUS
PopEnterNotification(
    PPOWER_CHANNEL_SUMMARY  PowerChannelSummary,
    PDEVICE_OBJECT          DeviceObject,
    PPO_NOTIFY              NotificationFunction,
    PVOID                   NotificationContext,
    ULONG                   NotificationType,
    PDEVICE_POWER_STATE     DeviceState,
    PVOID                   *NotificationHandle
    )
/*++

Routine Description:

    Scans the Power Notification Instance list of the power channel
    looking for one that matches the parameters, which we'll use
    if possible.

    If no candidate is found, make a new one and put it on the list.


Arguments:

    PowerChannelSummary - pointer to the power channel structure for the devobj

    DeviceObject - supplies a PDO

    NotificationFunction - routine to call to post the notification

    NotificationContext - argument passed through as is to the NotificationFunction

    NotificationType - mask of the notifications that the caller wishes to recieve.
        Note that INVALID will always be reported, regardless of whether the
        caller asked for it.

    DeviceState - the current state of the PDO, as last reported to the
        system via PoSetPowerState

    NotificationHandle - reference to the notification instance, used to
        cancel the notification.

Return Value:

    Standard NTSTATUS values, including:

        STATUS_SUCCESS

        STATUS_INSUFFICIENT_RESOURCES - ususally out of memory

--*/
{
    PLIST_ENTRY     plist;
    PPOWER_NOTIFY_BLOCK   pnb;
    KIRQL           oldIrql;

    PopLockDopeGlobal(&oldIrql);

    //
    // run the notify list looking for an existing instance to use
    //
    for (plist = PowerChannelSummary->NotifyList.Flink;
         plist != &(PowerChannelSummary->NotifyList);
         plist = plist->Flink)
    {
        pnb = CONTAINING_RECORD(plist, POWER_NOTIFY_BLOCK, NotifyList);
        if ( (pnb->NotificationFunction == NotificationFunction) &&
             (pnb->NotificationContext == NotificationContext)   &&
             (pnb->NotificationType == NotificationType) )
        {
            //
            // we have found an existing list entry that works for us
            //
            pnb->RefCount++;
            *DeviceState = PopLockGetDoDevicePowerState(DeviceObject->DeviceObjectExtension);
            *NotificationHandle = (PVOID)pnb;
            return STATUS_SUCCESS;
        }
    }

    //
    // didn't find an instance we can use, so make a new one
    //
    pnb = ExAllocatePoolWithTag(NonPagedPool, sizeof(POWER_NOTIFY_BLOCK), POP_PNB_TAG);
    if (!pnb) {
        PopUnlockDopeGlobal(oldIrql);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pnb->Signature = (ULONG)(POP_PNB_TAG);
    pnb->RefCount = 1;
    pnb->Invalidated = FALSE;
    InitializeListHead(&(pnb->NotifyList));
    pnb->NotificationFunction = NotificationFunction;
    pnb->NotificationContext = NotificationContext;
    pnb->NotificationType = NotificationType;
    pnb->PowerChannel = PowerChannelSummary;
    InsertHeadList(&(PowerChannelSummary->NotifyList), &(pnb->NotifyList));
    *DeviceState = PopLockGetDoDevicePowerState(DeviceObject->DeviceObjectExtension);
    *NotificationHandle = (PVOID)pnb;
    PopUnlockDopeGlobal(oldIrql);
    return STATUS_SUCCESS;
}

NTSTATUS
PopBuildPowerChannel(
    PDEVICE_OBJECT          DeviceObject,
    PPOWER_CHANNEL_SUMMARY  PowerChannelSummary,
    ULONG                   RecursionThrottle
    )
/*++

Routine Description:

    Adds DeviceObject to the power notify channel focused at PowerChannelSummary,
    and then repeat on dependencies.

Arguments:

    DeviceObject - supplies a PDO

    PowerChannelSummary - the power channel structure to add to the PDO's run list

    RecursionThrottle - number of times we're recursed into this routine,
        punt if it exceeds threshold

Return Value:

    Standard NTSTATUS values, including:

        STATUS_SUCCESS

        STATUS_INSUFFICIENT_RESOURCES - ususally out of memory

--*/
{
    PLIST_ENTRY                     pSourceHead;
    PPOWER_NOTIFY_SOURCE            pSourceEntry, pEntry;
    PPOWER_NOTIFY_TARGET            pTargetEntry;
    KIRQL                           OldIrql;
    PDEVICE_OBJECT_POWER_EXTENSION  pdope;
    PLIST_ENTRY                     plink;


    //
    // bugcheck if we get all confused
    //
    if ( ! (IS_DO_PDO(DeviceObject))) {

        PopInternalAddToDumpFile ( PowerChannelSummary, sizeof(POWER_CHANNEL_SUMMARY), DeviceObject, NULL, NULL, NULL );
        
        //
        // subcode 2 is used alot here (including the call in _PopInternalError, which is
        // used all over the place.  So it's essentially undiagnosable.  Cut our losses
        // here and start using subcode POP_SYS.
        //
        // KeBugCheckEx(INTERNAL_POWER_ERROR, 2, 1, (ULONG_PTR)DeviceObject, (ULONG_PTR)PowerChannelSummary);
        KeBugCheckEx( INTERNAL_POWER_ERROR, // bugcheck code
                      POP_SYS,              // subcode
                      0x100,                // unique identifier
                      (ULONG_PTR)DeviceObject, 
                      (ULONG_PTR)PowerChannelSummary);
    }

    if (RecursionThrottle > POP_RECURSION_LIMIT) {
        ASSERT(0);
        return STATUS_STACK_OVERFLOW;
    }

    if (!PopGetDope(DeviceObject)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // allocate entries in case we need them
    //
    pSourceEntry =
        ExAllocatePoolWithTag(NonPagedPool, sizeof(POWER_NOTIFY_SOURCE), POP_PNSC_TAG);

    pTargetEntry =
        ExAllocatePoolWithTag(NonPagedPool, sizeof(POWER_NOTIFY_TARGET), POP_PNTG_TAG);

    if ((!pSourceEntry) || (!pTargetEntry)) {
        if (pSourceEntry) ExFreePool(pSourceEntry);
        if (pTargetEntry) ExFreePool(pTargetEntry);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // run the source list
    //
    PopLockDopeGlobal(&OldIrql);

    pdope = DeviceObject->DeviceObjectExtension->Dope;
    pSourceHead = &(pdope->NotifySourceList);

    for (plink = pSourceHead->Flink;
         plink != pSourceHead;
         plink = plink->Flink)
    {
        pEntry = CONTAINING_RECORD(plink, POWER_NOTIFY_SOURCE, List);

        if (pEntry->Target->ChannelSummary == PowerChannelSummary) {
            //
            // the supplied device object already points to the supplied
            // channel, so just say we're done.
            //
            ExFreePool(pSourceEntry);
            ExFreePool(pTargetEntry);
            return STATUS_SUCCESS;
        }
    }

    //
    // we're not already in the list, so use the source and target entries
    // we created above
    //
    pSourceEntry->Signature = POP_PNSC_TAG;
    pSourceEntry->Target = pTargetEntry;
    pSourceEntry->Dope = pdope;
    InsertHeadList(pSourceHead, &(pSourceEntry->List));

    pTargetEntry->Signature = POP_PNTG_TAG;
    pTargetEntry->Source = pSourceEntry;
    pTargetEntry->ChannelSummary = PowerChannelSummary;
    pdope = CONTAINING_RECORD(PowerChannelSummary, DEVICE_OBJECT_POWER_EXTENSION, PowerChannelSummary);
    InsertHeadList(&(pdope->NotifyTargetList), &(pTargetEntry->List));

    //
    // adjust the counts in the PowerChannelSummary
    //
    PowerChannelSummary->TotalCount++;
    if (PopGetDoDevicePowerState(DeviceObject->DeviceObjectExtension) == PowerDeviceD0) {
        PowerChannelSummary->D0Count++;
    }

    //
    // at this point the one PDO we know about refers to the channel
    // so we now look for things it depends on...
    //
    PopUnlockDopeGlobal(OldIrql);
    PopFindPowerDependencies(DeviceObject, PowerChannelSummary, RecursionThrottle);
    return STATUS_SUCCESS;
}


NTSTATUS
PopCompleteFindIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Irp);

    KeSetEvent((PKEVENT)Context, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
PopFindPowerDependencies(
    PDEVICE_OBJECT          DeviceObject,
    PPOWER_CHANNEL_SUMMARY  PowerChannelSummary,
    ULONG                   RecursionThrottle
    )
/*++

Routine Description:

    Get the power relations for device object, step through them
    looking for pdos.  call PopBuildPowerChannel to add PDOs to
    channel inclusion list.  recurse into non-pdos looking for pdos.

Arguments:

    DeviceObject - supplies a PDO

    PowerChannel - the power channel structure to add to the PDO's run list

    RecursionThrottle - number of times we're recursed into this routine,
        punt if it exceeds threshold

Return Value:

    Standard NTSTATUS values, including:

        STATUS_SUCCESS

        STATUS_INSUFFICIENT_RESOURCES - ususally out of memory

--*/
{
    PDEVICE_RELATIONS   pdr;
    KEVENT              findevent;
    ULONG               i;
    PIRP                irp;
    PIO_STACK_LOCATION  irpsp;
    PDEVICE_OBJECT      childDeviceObject;
    NTSTATUS            status;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);


    if (RecursionThrottle > POP_RECURSION_LIMIT) {
        ASSERT(0);
        return STATUS_STACK_OVERFLOW;
    }

    //
    // allocate and fill an irp to send to the device object
    //
    irp = IoAllocateIrp(
        (CCHAR)(DeviceObject->StackSize),
        TRUE
        );

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpsp = IoGetNextIrpStackLocation(irp);
    irpsp->MajorFunction = IRP_MJ_PNP;
    irpsp->MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
    irpsp->Parameters.QueryDeviceRelations.Type = PowerRelations;
    irpsp->DeviceObject = DeviceObject;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    IoSetCompletionRoutine(
        irp,
        PopCompleteFindIrp,
        (PVOID)(&findevent),
        TRUE,
        TRUE,
        TRUE
        );

    KeInitializeEvent(&findevent, SynchronizationEvent, FALSE);
    KeResetEvent(&findevent);

    IoCallDriver(DeviceObject, irp);

    KeWaitForSingleObject(
        &findevent,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    //
    // we have in hand the completed irp, if it worked, it will list
    // device objects that the subject device object has a power relation with
    //

    if (!NT_SUCCESS(irp->IoStatus.Status)) {
        return irp->IoStatus.Status;
    }

    pdr = (PDEVICE_RELATIONS)(irp->IoStatus.Information);
    IoFreeIrp(irp);

    if (!pdr) {
        return STATUS_SUCCESS;
    }

    if (pdr->Count == 0) {
        ExFreePool(pdr);
        return STATUS_SUCCESS;
    }

    //
    // walk the pdr, for each entry, either add it as a reference and recurse down
    // (if it's a pdo) or skip the add and simply recurse down (for a !pdo)
    //
    RecursionThrottle++;
    status = STATUS_SUCCESS;
    for (i = 0; i < pdr->Count; i++) {
        childDeviceObject = pdr->Objects[i];
        if (IS_DO_PDO(childDeviceObject)) {
            status = PopBuildPowerChannel(
                    childDeviceObject,
                    PowerChannelSummary,
                    RecursionThrottle
                    );
        } else {
            status = PopFindPowerDependencies(
                    childDeviceObject,
                    PowerChannelSummary,
                    RecursionThrottle
                    );
        }
        if (!NT_SUCCESS(status)) {
            goto Exit;
        }
    }

Exit:
    //
    // regardless of how far we got before we hit any errors,
    // we must deref the device objects in the list and free the list itself
    //
    for (i = 0; i < pdr->Count; i++) {
        ObDereferenceObject(pdr->Objects[i]);
    }
    ExFreePool(pdr);

    return status;
}

VOID
PopStateChangeNotify(
    PDEVICE_OBJECT  DeviceObject,
    ULONG           NotificationType
    )
/*++

Routine Description:

    Called by PoSetPowerState to execute notifications.

Arguments:

    Dope - the dope for the dev obj that expereinced the change

    NotificationType - what happened

Return Value:

--*/
{
    PPOWER_CHANNEL_SUMMARY  pchannel;
    PDEVICE_OBJECT_POWER_EXTENSION  Dope;
    PLIST_ENTRY             pSourceHead;
    PPOWER_NOTIFY_SOURCE    pSourceEntry;
    PPOWER_NOTIFY_TARGET    pTargetEntry;
    PLIST_ENTRY             plink;
    KIRQL                   oldIrql;
    KIRQL                   oldIrql2;

    oldIrql = KeGetCurrentIrql();

    if (oldIrql != PASSIVE_LEVEL) {
        //
        // caller had BETTER be doing a Power up, and we will use
        // the DopeGlobal local to protect access
        //
        PopLockDopeGlobal(&oldIrql2);
    } else {
        //
        // caller could be going up or down, we can just grab the resource
        //
        oldIrql2 = PASSIVE_LEVEL;
        ExAcquireResourceExclusiveLite(&PopNotifyLock, TRUE);
    }

    Dope = DeviceObject->DeviceObjectExtension->Dope;
    ASSERT((Dope));

    //
    // run the notify source structures hanging off the dope
    //
    pSourceHead = &(Dope->NotifySourceList);
    for (plink = pSourceHead->Flink;
         plink != pSourceHead;
         plink = plink->Flink)
    {
        pSourceEntry = CONTAINING_RECORD(plink, POWER_NOTIFY_SOURCE, List);
        ASSERT((pSourceEntry->Signature == POP_PNSC_TAG));

        pTargetEntry = pSourceEntry->Target;
        ASSERT((pTargetEntry->Signature == POP_PNTG_TAG));

        pchannel = pTargetEntry->ChannelSummary;

        if (NotificationType & PO_NOTIFY_D0) {
            //
            // going to D0
            //
            pchannel->D0Count++;
            if (pchannel->D0Count == pchannel->TotalCount) {
                PopPresentNotify(DeviceObject, pchannel, NotificationType);
            }
        } else if (NotificationType & PO_NOTIFY_TRANSITIONING_FROM_D0) {
            //
            // dropping from D0
            //
            ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
            pchannel->D0Count--;
            if (pchannel->D0Count == (pchannel->TotalCount - 1)) {
                PopPresentNotify(DeviceObject, pchannel, NotificationType);
            }
        } else if (NotificationType & PO_NOTIFY_INVALID) {
            PopPresentNotify(DeviceObject, pchannel, NotificationType);
        }
    }

    if (oldIrql != PASSIVE_LEVEL) {
        PopUnlockDopeGlobal(oldIrql2);
    } else {
        ExReleaseResourceLite(&PopNotifyLock);
    }

    return;
}

VOID
PopPresentNotify(
    PDEVICE_OBJECT          DeviceObject,
    PPOWER_CHANNEL_SUMMARY  PowerChannelSummary,
    ULONG                   NotificationType
    )
/*++

Routine Description:

    Run the device object's list of notify nodes, and call the handler
    each one refers to.

Arguments:

    DeviceObject - device object that is the source of the notification,
                    is NOT necessarily the device object that the power
                    channel applies to

    PowerChannelSummary - base of list of notification blocks to call through

    NotificationType - what sort of event occurred

Return Value:

--*/
{
    PLIST_ENTRY     plisthead;
    PLIST_ENTRY     plist;
    PPOWER_NOTIFY_BLOCK   pnb;

    plisthead = &(PowerChannelSummary->NotifyList);
    for (plist = plisthead->Flink; plist != plisthead;) {
        pnb = CONTAINING_RECORD(plist, POWER_NOTIFY_BLOCK, NotifyList);
        ASSERT(pnb->Invalidated == FALSE);
        if ( (NotificationType & PO_NOTIFY_INVALID) ||
             (pnb->NotificationType & NotificationType) )
        {
            (pnb->NotificationFunction)(
                DeviceObject,
                pnb->NotificationContext,
                NotificationType,
                0
                );
        }
        if (NotificationType & PO_NOTIFY_INVALID) {
            //
            // this pnb is no longer valid, so take it off the list.
            // right now this is all we do.
            // N.B. caller is holding the right locks...
            //
            plist = plist->Flink;
            RemoveEntryList(&(pnb->NotifyList));
            InitializeListHead(&(pnb->NotifyList));
            pnb->Invalidated = TRUE;
            PopInvalidNotifyBlockCount += 1;
        } else {
            plist = plist->Flink;
        }
    }
    return;
}


VOID
PopRunDownSourceTargetList(
    PDEVICE_OBJECT          DeviceObject
    )
/*++

Routine Description:

    This routine runs the source and target lists for the notify
    network hanging off a particular device object.  It knocks down
    these entries and their mates, and sends invalidates for notify
    blocks as needed.

    The caller is expected to be holding PopNotifyLock and the
    PopDopeGlobalLock.

Arguments:

    DeviceObject - supplies the address of the device object to
        be cut out of the notify network.

    D0Count - 1 if the D0Count in target channel summaries is to
        be decremented (run down devobj is in d0) else 0.

Return Value:

--*/
{
    PDEVICE_OBJECT_POWER_EXTENSION  Dope;
    PDEVOBJ_EXTENSION               Doe;
    PLIST_ENTRY                     pListHead;
    PLIST_ENTRY                     plink;
    PPOWER_NOTIFY_SOURCE            pSourceEntry;
    PPOWER_NOTIFY_TARGET            pTargetEntry;
    PPOWER_CHANNEL_SUMMARY          targetchannel;
    ULONG                           D0Count;
    KIRQL                           OldIrql;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);


    Doe = DeviceObject->DeviceObjectExtension;
    Dope = DeviceObject->DeviceObjectExtension->Dope;

    PopLockIrpSerialList(&OldIrql);
    if (PopGetDoSystemPowerState(Doe) == PowerDeviceD0) {
        D0Count = 1;
    } else {
        D0Count = 0;
    }
    PopUnlockIrpSerialList(OldIrql);

    if (!Dope) {
        return;
    }

    //
    // run all of the source nodes for the device object
    //
    pListHead = &(Dope->NotifySourceList);
    for (plink = pListHead->Flink; plink != pListHead; ) {
        pSourceEntry = CONTAINING_RECORD(plink, POWER_NOTIFY_SOURCE, List);
        ASSERT((pSourceEntry->Signature == POP_PNSC_TAG));

        pTargetEntry = pSourceEntry->Target;
        ASSERT((pTargetEntry->Signature == POP_PNTG_TAG));

        //
        // free the target node
        //
        targetchannel = pTargetEntry->ChannelSummary;
        RemoveEntryList(&(pTargetEntry->List));
        pTargetEntry->Signature = POP_NONO;
        ExFreePool(pTargetEntry);
        targetchannel->TotalCount--;
        targetchannel->D0Count -= D0Count;

        //
        // have PopPresentNotify call anybody listening, and remove
        // notify blocks for us
        //
        PopPresentNotify(DeviceObject, targetchannel, PO_NOTIFY_INVALID);

        //
        // knock down the source entry
        //
        plink = plink->Flink;
        RemoveEntryList(&(pSourceEntry->List));
        pSourceEntry->Signature = POP_NONO;
        ExFreePool(pSourceEntry);
    }

    //
    // run the target list and shoot down the targets and their source mates
    //
    pListHead = &(Dope->NotifyTargetList);
    for (plink = pListHead->Flink; plink != pListHead; ) {
        pTargetEntry = CONTAINING_RECORD(plink, POWER_NOTIFY_TARGET, List);
        ASSERT((pTargetEntry->Signature == POP_PNTG_TAG));

        pSourceEntry = pTargetEntry->Source;
        ASSERT((pSourceEntry->Signature == POP_PNSC_TAG));

        //
        // free the source node on the other end
        //
        RemoveEntryList(&(pSourceEntry->List));
        pSourceEntry->Signature = POP_NONO;
        ExFreePool(pSourceEntry);

        //
        // free this target node
        //
        plink = plink->Flink;
        RemoveEntryList(&(pTargetEntry->List));
        pTargetEntry->Signature = POP_NONO;
        ExFreePool(pTargetEntry);
    }

    //
    // since we ran our own target list, and emptied it, we should
    // also have shot down our own notify list.  So this devobj's
    // channel summary should be totally clean now.
    //
    Dope->PowerChannelSummary.TotalCount = 0;
    Dope->PowerChannelSummary.D0Count = 0;
    ASSERT(Dope->PowerChannelSummary.NotifyList.Flink == &(Dope->PowerChannelSummary.NotifyList));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\ntapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntapi.c

Abstract:

    NT api level routines for the po component reside in this file

Author:

    Bryan Willman (bryanwi) 14-Nov-1996

Revision History:

--*/


#include "pop.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtSetThreadExecutionState)
#pragma alloc_text(PAGE, NtRequestWakeupLatency)
#pragma alloc_text(PAGE, NtInitiatePowerAction)
#pragma alloc_text(PAGE, NtGetDevicePowerState)
#pragma alloc_text(PAGE, NtCancelDeviceWakeupRequest)
#pragma alloc_text(PAGE, NtIsSystemResumeAutomatic)
#pragma alloc_text(PAGE, NtRequestDeviceWakeup)
#pragma alloc_text(PAGELK, NtSetSystemPowerState)
#endif

extern POBJECT_TYPE IoFileObjectType;

WORK_QUEUE_ITEM PopShutdownWorkItem;
WORK_QUEUE_ITEM PopUnlockAfterSleepWorkItem;
KEVENT          PopUnlockComplete;
extern ERESOURCE ExpTimeRefreshLock;


extern ULONG MmZeroPageFile;
extern
VOID
PopZeroHiberFile(
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject
    );



NTSYSAPI
NTSTATUS
NTAPI
NtSetThreadExecutionState(
    IN EXECUTION_STATE NewFlags,                // ES_xxx flags
    OUT EXECUTION_STATE *PreviousFlags
    )
/*++

Routine Description:

    Implements Win32 API functionality.  Tracks thread execution state
    attributes.  Keeps global count of all such attributes set.

Arguments:

    NewFlags        - Attributes to set or pulse

    PreviousFlags   - Threads 'set' attributes before applying NewFlags

Return Value:

    Status

--*/
{
    ULONG               OldFlags;
    PKTHREAD            Thread;
    KPROCESSOR_MODE     PreviousMode;
    NTSTATUS            Status;

    PAGED_CODE();

    Thread = KeGetCurrentThread();
    Status = STATUS_SUCCESS;

    //
    // Verify no reserved bits set
    //

    if (NewFlags & ~(ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED | ES_CONTINUOUS)) {
        return STATUS_INVALID_PARAMETER;
    }

    try {
        //
        // Verify callers params
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteUlong (PreviousFlags);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    //
    // Get current flags
    //

    OldFlags = Thread->PowerState | ES_CONTINUOUS;

    if (NT_SUCCESS(Status)) {

        PopAcquirePolicyLock ();

        //
        // If the continous bit is set, modify current thread flags
        //

        if (NewFlags & ES_CONTINUOUS) {
            Thread->PowerState = (UCHAR) NewFlags;
            PopApplyAttributeState (NewFlags, OldFlags);
        } else {
            PopApplyAttributeState (NewFlags, 0);
        }

        //
        // Release the lock here, but don't steal the poor caller's thread to
        // do the work. Otherwise we can get in weird message loop deadlocks as
        // this thread is waiting for the USER32 thread, which is broadcasting a
        // system message to this thread's window.
        //
        PopReleasePolicyLock (FALSE);
        PopCheckForWork(TRUE);

        //
        // Return the results
        //

        try {
            *PreviousFlags = OldFlags;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }
    }

    return Status;
}

NTSYSAPI
NTSTATUS
NTAPI
NtRequestWakeupLatency(
    IN LATENCY_TIME latency             // LT_xxx flags
    )
/*++

Routine Description:

    Tracks process wakeup latecy attribute.  Keeps global count
    of all such attribute settings.

Arguments:

    latency     - Current latency setting for process

Return Value:

    Status

--*/
{
    PEPROCESS   Process;
    ULONG       OldFlags, NewFlags;


    PAGED_CODE();

    //
    // Verify latency is known
    //

    switch (latency) {
        case LT_DONT_CARE:
            NewFlags = ES_CONTINUOUS;
            break;

        case LT_LOWEST_LATENCY:
            NewFlags = ES_CONTINUOUS | POP_LOW_LATENCY;
            break;

        default:
            return STATUS_INVALID_PARAMETER;
    }


    Process = PsGetCurrentProcess();
    PopAcquirePolicyLock ();

    //
    // Get changes
    //

    OldFlags = Process->Pcb.PowerState | ES_CONTINUOUS;

    //
    // Udpate latency flag in process field
    //

    Process->Pcb.PowerState = (UCHAR) NewFlags;

    //
    // Handle flags
    //

    PopApplyAttributeState (NewFlags, OldFlags);

    //
    // Done
    //

    PopReleasePolicyLock (TRUE);
    return STATUS_SUCCESS;
}

NTSYSAPI
NTSTATUS
NTAPI
NtInitiatePowerAction(
    IN POWER_ACTION SystemAction,
    IN SYSTEM_POWER_STATE LightestSystemState,
    IN ULONG Flags,                 // POWER_ACTION_xxx flags
    IN BOOLEAN Asynchronous
    )
/*++

Routine Description:

    Implements functionality for Win32 APIs to initiate a power
    action.   Causes s/w initiated trigger of requested action.

Arguments:

    SystemAction    - The action to initiate

    LightestSystemState  - If a sleep action, the minimum state which must be
                           entered

    Flags           - Attributes of action

    Asynchronous    - Function should initiate action and return, or should wait
                      for the action to complete before returning

Return Value:

    Status

--*/
{
    KPROCESSOR_MODE         PreviousMode;
    POWER_ACTION_POLICY     Policy;
    POP_ACTION_TRIGGER      Trigger;
    PPOP_TRIGGER_WAIT       Wait = NULL;
    NTSTATUS                Status = STATUS_SUCCESS;

    PAGED_CODE();

    
    //
    // If caller is user mode make some verifications
    //
    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        if( SystemAction == PowerActionWarmEject ) {
            // This makes no sense coming from usermode.
            return STATUS_INVALID_PARAMETER;
        }

        if (!SeSinglePrivilegeCheck( SeShutdownPrivilege, PreviousMode )) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }
    }

    if( (LightestSystemState > PowerSystemMaximum) ||
        (SystemAction > PowerActionWarmEject) ||
        (Flags & POWER_ACTION_LIGHTEST_FIRST) ||
        ARE_POWER_ACTION_POLICY_FLAGS_BOGUS(Flags) ) {
        return STATUS_INVALID_PARAMETER;
    }


    //
    // Build a policy & trigger to cause the action
    //
    RtlZeroMemory (&Policy, sizeof(Policy));
    Policy.Action = SystemAction;
    Policy.Flags  = Flags;
    
    RtlZeroMemory (&Trigger, sizeof(Trigger));
    Trigger.Type  = PolicyInitiatePowerActionAPI;
    Trigger.Flags = PO_TRG_SET;


    //
    // If the caller requested a synchronous operation, create
    // an event here that we can attach to the action being
    // applied.
    //
    if (!Asynchronous) {
        Wait = ExAllocatePoolWithTag (
                    NonPagedPool,
                    sizeof (POP_TRIGGER_WAIT),
                    POP_PACW_TAG
                    );
        if (!Wait) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory (Wait, sizeof(POP_TRIGGER_WAIT));
        Wait->Status = STATUS_SUCCESS;
        Wait->Trigger = &Trigger;
        KeInitializeEvent (&Wait->Event, NotificationEvent, FALSE);
        Trigger.Flags |= PO_TRG_SYNC;
        Trigger.Wait = Wait;
    }

    
    //
    // Acquire lock, fire it, and release the lock.
    //
    PopAcquirePolicyLock ();

    try {

        PopSetPowerAction(
            &Trigger,
            0,
            &Policy,
            LightestSystemState,
            SubstituteLightestOverallDownwardBounded
            );

    } except (PopExceptionFilter(GetExceptionInformation(), TRUE)) {
        Status = GetExceptionCode();
    }
    PopReleasePolicyLock (TRUE);


    //
    // If we're doing a synchronous operation, wait for it.
    //
    if( Wait ) {


        if (Wait->Link.Flink) {

            //
            // The wait block was queued.  We need to wait here for him
            // to finish.  Otherwise, we can assume he either failed
            // or succeeded immediately.
            //
            ASSERT(NT_SUCCESS(Status));
            Status = KeWaitForSingleObject (&Wait->Event, Suspended, KernelMode, TRUE, NULL);

            //
            // Remove wait block from the queue
            //
            PopAcquirePolicyLock ();
            RemoveEntryList (&Wait->Link);
            PopReleasePolicyLock (FALSE);
        }
        
        //
        // If everything's okay, remember the wait status.
        //
        if (NT_SUCCESS(Status)) {
            Status = Wait->Status;
        }

        ExFreePool (Wait);
    }

    return Status;
}

NTSYSAPI
NTSTATUS
NTAPI
NtSetSystemPowerState (
    IN POWER_ACTION SystemAction,
    IN SYSTEM_POWER_STATE LightestSystemState,
    IN ULONG Flags                  // POWER_ACTION_xxx flags
    )
/*++

Routine Description:

    N.B. This function is only called by Winlogon.

    Winlogon calls this function in response to the policy manager calling
    PopStateCallout once user mode operations have completed.

Arguments:

    SystemAction        - The current system action being processed.

    LightestSystemState - The min system state for the action.

    Flags               - The attribute flags for the action.


Return Value:

    Status

--*/
{
    KPROCESSOR_MODE         PreviousMode;
    NTSTATUS                Status, Status2;
    POWER_ACTION_POLICY     Action;
    BOOLEAN                 QueryDevices;
    BOOLEAN                 TimerRefreshLockOwned;
    BOOLEAN                 BootStatusUpdated;
    BOOLEAN                 VolumesFlushed;
    BOOLEAN                 PolicyLockOwned;
    PVOID                   WakeTimerObject;
    PVOID                   S4DozeObject;
    HANDLE                  S4DozeTimer;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    TIMER_BASIC_INFORMATION TimerInformation;
    POP_ACTION_TRIGGER      Trigger;
    SYSTEM_POWER_STATE      DeepestSystemState;
    ULONGLONG               WakeTime;
    ULONGLONG               SleepTime = 0;
    TIME_FIELDS             WakeTimeFields;
    LARGE_INTEGER           DueTime;
    POP_SUBSTITUTION_POLICY SubstitutionPolicy;
    NT_PRODUCT_TYPE         NtProductType;
    PIO_ERROR_LOG_PACKET    ErrLog;
    BOOLEAN                 WroteErrLog=FALSE;

    
    
    //
    // Check parameters
    //
    if( (LightestSystemState >= PowerSystemMaximum)     ||
        (LightestSystemState <= PowerSystemUnspecified) ||
        (SystemAction > PowerActionWarmEject)           ||
        (SystemAction < PowerActionReserved)            ||
        ARE_POWER_ACTION_POLICY_FLAGS_BOGUS(Flags) ) {
        PoPrint( PO_ERROR, ("NtSetSystemPowerState: Bad parameters!\n") );
        PoPrint( PO_ERROR, ("                       SystemAction: 0x%x\n", (ULONG)SystemAction) );
        PoPrint( PO_ERROR, ("                       LightestSystemState: 0x%x\n", (ULONG)LightestSystemState) );
        PoPrint( PO_ERROR, ("                       Flags: 0x%x\n", (ULONG)Flags) );

        return STATUS_INVALID_PARAMETER;
    }
    
    //
    // Verify callers access
    //
    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        if (!SeSinglePrivilegeCheck( SeShutdownPrivilege, PreviousMode )) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }
        
        
        //
        // Turn into kernel mode operation.  This essentially calls back into
        // ourselves, but it means that handles that may be opened from here on
        // will stay around if our caller goes away.
        //

        return ZwSetSystemPowerState (SystemAction, LightestSystemState, Flags);
    }

    //
    // disable registry's lazzy flusher
    //
    CmSetLazyFlushState(FALSE);

    //
    // Setup
    //

    Status = STATUS_SUCCESS;
    TimerRefreshLockOwned = FALSE;
    BootStatusUpdated = FALSE;
    VolumesFlushed = FALSE;
    S4DozeObject = NULL;
    WakeTimerObject = NULL;
    WakeTime = 0;

    RtlZeroMemory (&Action, sizeof(Action));
    Action.Action = SystemAction;
    Action.Flags  = Flags;

    RtlZeroMemory (&Trigger, sizeof(Trigger));
    Trigger.Type  = PolicySetPowerStateAPI;
    Trigger.Flags = PO_TRG_SET;

    //
    // Lock any code dealing with shutdown or sleep
    //
    // PopUnlockComplete event is used to make sure that any previous unlock
    // has completed before we try and lock everything again.
    //

    ASSERT(ExPageLockHandle);
    KeWaitForSingleObject(&PopUnlockComplete, WrExecutive, KernelMode, FALSE, NULL);
    MmLockPagableSectionByHandle(ExPageLockHandle);
    ExNotifyCallback (ExCbPowerState, (PVOID) PO_CB_SYSTEM_STATE_LOCK, (PVOID) 0);
    ExSwapinWorkerThreads(FALSE);

    //
    // Acquire policy manager lock
    //

    PopAcquirePolicyLock ();
    PolicyLockOwned = TRUE;

    //
    // If we're not in the callout state, don't re-enter.
    // The caller (paction.c) will handle the collision.
    //

    if (PopAction.State != PO_ACT_IDLE  &&  PopAction.State != PO_ACT_CALLOUT) {
        PoPrint (PO_PACT, ("NtSetSystemPowerState: already committed\n"));
        PopReleasePolicyLock (FALSE);
        MmUnlockPagableImageSection (ExPageLockHandle);
        ExSwapinWorkerThreads(TRUE);
        KeSetEvent(&PopUnlockComplete, 0, FALSE);

        //
        // try to catch weird case where we exit this routine with the
        // time refresh lock held.
        //
        ASSERT(!ExIsResourceAcquiredExclusive(&ExpTimeRefreshLock));
        return STATUS_ALREADY_COMMITTED;
    }

    if (PopAction.State == PO_ACT_IDLE) {
        //
        // If there is no other request, we want to clean up PopAction before we start,
        // PopSetPowerAction() will not do this after we set State=PO_ACT_SET_SYSTEM_STATE.
        //
        PopResetActionDefaults();
    }
    //
    // Update to action state to setting the system state
    //

    PopAction.State = PO_ACT_SET_SYSTEM_STATE;

    //
    // Set status to cancelled to start off as if this is a new request
    //

    Status = STATUS_CANCELLED;

    try {

        //
        // Verify params and promote the current action.
        //
        PopSetPowerAction(
            &Trigger,
           0,
           &Action,
           LightestSystemState,
           SubstituteLightestOverallDownwardBounded
           );

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        ASSERT (!NT_SUCCESS(Status));
    }

    //
    // Lagecy hal support.  If the original action was PowerDown
    // change the action to be power down (as presumbly even if
    // there's no handler HalReturnToFirmware will know what to do)
    //

    if (SystemAction == PowerActionShutdownOff) {
        PopAction.Action = PowerActionShutdownOff;
    }


    if( (SystemAction == PowerActionShutdown) ||
        (SystemAction == PowerActionShutdownReset) ||
        (SystemAction == PowerActionShutdownOff) ) {
    
        //
        // If we're going down and there's a hiberfile allocated, and
        // the user wants things secure, then go zero the hiberfile.
        //
        if( (PopHiberFile.FileHandle) && // do we have a hiberfile?
            (PopHiberFile.FileObject) && // make double sure.
            (MmZeroPageFile) ) {         // policy is set to zero the pagefile.
            
            PopZeroHiberFile(PopHiberFile.FileHandle, PopHiberFile.FileObject);
        }
    
    }

    
    //
    // Allocate the DevState here. From this point out we must be careful
    // that we never release the policy lock with State == PO_ACT_SET_SYSTEM_STATE
    // and PopAction.DevState not valid. Otherwise there is a race condition
    // with PopRestartSetSystemState.
    //
    PopAllocateDevState();
    if (PopAction.DevState == NULL) {
        PopAction.State = PO_ACT_IDLE;
        PopReleasePolicyLock(FALSE);
        MmUnlockPagableImageSection( ExPageLockHandle );
        ExSwapinWorkerThreads(TRUE);
        KeSetEvent(&PopUnlockComplete, 0, FALSE);
        //
        // try to catch weird case where we exit this routine with the
        // time refresh lock held.
        //
        ASSERT(!ExIsResourceAcquiredExclusive(&ExpTimeRefreshLock));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // At this point in the cycle, its not possible to abort the operation
    // so this is a good time to ensure that the CPU is back running as close
    // to 100% as we can make it.
    //
    PopSetPerfFlag( PSTATE_DISABLE_THROTTLE_NTAPI, FALSE );
    PopUpdateAllThrottles();

    S4DozeTimer = (HANDLE)-1;
    QueryDevices = FALSE;       // Only needed to keep the compiler happy
    DeepestSystemState = PowerSystemUnspecified; // Only needed to keep the compiler happy

    //
    // While there's some action pending handle it.
    //
    // N.B. We will never get here if no sleep states are supported, as
    // NtInitiatePowerAction will fail (PopVerifyPowerActionPolicy will return
    // Disabled == TRUE). Therefore we won't accidentally querying for S0. Note
    // that all the policy limitations were also verified at some point too.
    //

    for (; ;) {
        //
        // N.B. The system must be in the working state to be here
        //

        if (!PolicyLockOwned) {
            PopAcquirePolicyLock ();
            PolicyLockOwned = TRUE;
        }

        //
        // If there's nothing to do, stop
        //

        if (PopAction.Action == PowerActionNone) {
            break;
        }

        //
        // Hibernate actions are converted to sleep actions before here.
        //

        ASSERT (PopAction.Action != PowerActionHibernate);

        //
        // We're handling it - clear update flags
        //

        PopAction.Updates &= ~(PO_PM_USER | PO_PM_REISSUE | PO_PM_SETSTATE);

        //
        // If the last operation was cancelled, update state for the
        // new operation
        //

        if (Status == STATUS_CANCELLED) {

            //
            // If Re-issue is set we may need to abort back to PopSetPowerAction
            // to let apps know of the promotion
            //

            if (PopAction.Updates & PO_PM_REISSUE) {

                //
                // Only abort if apps notificiation is allowed
                //

                if (!(PopAction.Flags & (POWER_ACTION_CRITICAL))  &&
                     (PopAction.Flags & (POWER_ACTION_QUERY_ALLOWED |
                                         POWER_ACTION_UI_ALLOWED))
                    ) {

                    // abort with STATUS_CANCELLED to PopSetPowerAction
                    PopGetPolicyWorker (PO_WORKER_ACTION_NORMAL);
                    break;
                }
            }

            //
            // Get limits and start (over) with the first sleep state to try.
            //
            PopActionRetrieveInitialState(
                &PopAction.LightestState,
                &DeepestSystemState,
                &PopAction.SystemState,
                &QueryDevices
                );

            ASSERT (PopAction.SystemState != PowerActionNone);

            if ((PopAction.Action == PowerActionShutdown) ||
                (PopAction.Action == PowerActionShutdownReset) ||
                (PopAction.Action == PowerActionShutdownOff)) {

                //
                // This is a shutdown.
                //
                PopAction.Shutdown = TRUE;

            }

            Status = STATUS_SUCCESS;
        }

        //
        // Quick debug check. Our first sleep state must always be valid, ie
        // validation doesn't change it.
        //
#if DBG
        if (QueryDevices && (PopAction.SystemState < PowerSystemShutdown)) {

            SYSTEM_POWER_STATE TempSystemState;

            TempSystemState = PopAction.SystemState;
            PopVerifySystemPowerState(&TempSystemState, SubstituteLightestOverallDownwardBounded);

            if ((TempSystemState != PopAction.SystemState) ||
                (TempSystemState == PowerSystemWorking)) {

                PopInternalError (POP_INFO);
            }
        }
#endif

        //
        // If not success, abort SetSystemPowerState operation
        //

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Only need the lock while updating PopAction.Action + Updates, and
        // can not hold the lock while sending irps to device drivers
        //

        PopReleasePolicyLock(FALSE);
        PolicyLockOwned = FALSE;

        //
        // Fish PopSimulate out of the registry so that it can
        // modify some of our sleep/hiber behavior.
        //

        PopInitializePowerPolicySimulate();

        //
        // Dump any previous device state error
        //

        PopReportDevState (FALSE);

        //
        // What would be our next state to try?
        //
        PopAction.NextSystemState = PopAction.SystemState;
        if (PopAction.Flags & POWER_ACTION_LIGHTEST_FIRST) {

            //
            // We started light, now we deepen our sleep state.
            //
            SubstitutionPolicy = SubstituteDeepenSleep;

        } else {

            //
            // We started deep, now we're lightening up.
            //
            SubstitutionPolicy = SubstituteLightenSleep;
        }

        PopAdvanceSystemPowerState(&PopAction.NextSystemState,
                                   SubstitutionPolicy,
                                   PopAction.LightestState,
                                   DeepestSystemState);

        //
        // If allowed, query devices
        //

        PopAction.IrpMinor = IRP_MN_QUERY_POWER;
        if (QueryDevices) {

            //
            // Issue query to devices
            //

            Status = PopSetDevicesSystemState (FALSE);

            //
            // If the last operation was a failure, but wasn't a total abort
            // continue with next best state
            //

            if (!NT_SUCCESS(Status) && Status != STATUS_CANCELLED) {

                //
                // Try next sleep state
                //
                PopAction.SystemState = PopAction.NextSystemState;

                //
                // If we're already exhausted all possible states, check
                // if we need to continue regardless of the device failures.
                //

                if (PopAction.SystemState == PowerSystemWorking) {

                    if (PopAction.Flags & POWER_ACTION_CRITICAL) {

                        //
                        // It's critical.  Stop querying and since the devices
                        // aren't particularly happy with any of the possible
                        // states, might as well use the max state
                        //

                        ASSERT( PopAction.Action != PowerActionWarmEject );
                        ASSERT( !(PopAction.Flags & POWER_ACTION_LIGHTEST_FIRST) );

                        QueryDevices = FALSE;
                        PopAction.SystemState = DeepestSystemState;
                        PopAction.Flags &= ~POWER_ACTION_LIGHTEST_FIRST;

                    } else {

                        //
                        // The query failure is final.  Don't retry
                        //

                        break;
                    }
                }

                //
                // Try new settings
                //

                Status = STATUS_SUCCESS;
                continue;
            }
        }

        //
        // If some error, start over
        //

        if (!NT_SUCCESS(Status)) {
            continue;
        }

        //
        // Flush out any D irps on the queue. There shouldn't be any, but by
        // setting LastCall == TRUE this also resets PopCallSystemState so that
        // any D irps which occur as a side-effect of flushing the volumes get
        // processed correctly.
        //
        PopSystemIrpDispatchWorker(TRUE);

        //
        // If this is a server and we are going into hibernation, write an entry
        // into the eventlog. This allows for easy tracking of system downtime
        // by searching the eventlog for hibernate/resume events.
        //
        if (RtlGetNtProductType(&NtProductType) &&
            (NtProductType != NtProductWinNt)   &&
            (PopAction.SystemState == PowerSystemHibernate)) {

            ErrLog = IoAllocateGenericErrorLogEntry(sizeof(IO_ERROR_LOG_PACKET));
            if (ErrLog) {

                //
                // Fill it in and write it out
                //
                ErrLog->FinalStatus = STATUS_HIBERNATED;
                ErrLog->ErrorCode = STATUS_HIBERNATED;
                IoWriteErrorLogEntry(ErrLog);
                WroteErrLog = TRUE;
            }
        }


        //
        // Get hibernation context
        //


        Status = PopAllocateHiberContext ();
        if (!NT_SUCCESS(Status) || (PopAction.Updates & (PO_PM_REISSUE | PO_PM_SETSTATE))) {
              continue;
        }

        //
        // If boot status hasn't already been updated then do so now.
        //

        if(!BootStatusUpdated) {

            if(PopAction.Shutdown) {

                NTSTATUS bsdStatus;
                HANDLE bsdHandle;

                bsdStatus = RtlLockBootStatusData(&bsdHandle);

                if(NT_SUCCESS(bsdStatus)) {

                    BOOLEAN t = TRUE;

                    RtlGetSetBootStatusData(bsdHandle,
                                            FALSE,
                                            RtlBsdItemBootShutdown,
                                            &t,
                                            sizeof(t),
                                            NULL);

                    RtlUnlockBootStatusData(bsdHandle);
                }
            }

            BootStatusUpdated = TRUE;
        }

        //
        // If not already flushed, flush the volumes
        //

        if (!VolumesFlushed) {
            VolumesFlushed = TRUE;
            PopFlushVolumes ();
        }

        //
        // Enter the SystemState
        //

        PopAction.IrpMinor = IRP_MN_SET_POWER;
        if (PopAction.Shutdown) {

            //
            // Force reacquisition of the dev list. We will be telling Pnp
            // to unload all possible devices, and therefore Pnp needs us to
            // release the Pnp Engine Lock.
            //
            IoFreePoDeviceNotifyList(&PopAction.DevState->Order);
            PopAction.DevState->GetNewDeviceList = TRUE;

            //
            // We shut down via a system worker thread so that the
            // current active process will exit cleanly.
            //

            if (PsGetCurrentProcess() != PsInitialSystemProcess) {
                ExInitializeWorkItem(&PopShutdownWorkItem,
                                     &PopGracefulShutdown,
                                     NULL);

                ExQueueWorkItem(&PopShutdownWorkItem,
                                PO_SHUTDOWN_QUEUE);

                // Clean up in prep for wait...
                ASSERT(!PolicyLockOwned);

                //
                // If we acquired the timer refresh lock (can happen if we promoted to shutdown)
                // then we need to release it so that suspend actually suspends.
                //
                if (TimerRefreshLockOwned) {
                    ExReleaseTimeRefreshLock();
                }

                // And sleep until we're terminated.

                // Note that we do NOT clean up the dev state -- it's now
                // owned by the shutdown worker thread.

                // Note that we also do not unlock the pagable image
                // section referred to by ExPageLockHandle -- this keeps
                // all of our shutdown code in memory.

                KeSuspendThread(KeGetCurrentThread());

                return STATUS_SYSTEM_SHUTDOWN;
            } else {
                PopGracefulShutdown (NULL);
            }
        }

        //
        // Get the timer refresh lock to hold off automated time of day
        // adjustments.  On wake the time will be explicitly reset from Cmos
        //

        if (!TimerRefreshLockOwned) {
            TimerRefreshLockOwned = TRUE;
            ExAcquireTimeRefreshLock(TRUE);
        }

        // This is where PopAllocateHiberContext used to be before bug #212420

        //
        // If there's a Doze to S4 timeout set, and this wasn't an S4 action
        // and the system can support and S4 state, set a timer for the doze time
        //
        // N.B. this must be set before the paging devices are turned off
        //

        if (S4DozeObject) {
            S4DozeObject = NULL;
            NtClose (S4DozeTimer);
        }

        if (PopPolicy->DozeS4Timeout  &&
            !S4DozeObject &&
            PopAction.SystemState != PowerSystemHibernate &&
            SystemAction != PowerActionHibernate &&
            PopCapabilities.SystemS4 &&
            PopCapabilities.SystemS5 &&
            PopCapabilities.HiberFilePresent) {

            //
            // Create a timer to wake the machine up when we need to hibernate
            //

            InitializeObjectAttributes (&ObjectAttributes, NULL, 0, NULL, NULL);

            Status2 = NtCreateTimer (
                        &S4DozeTimer,
                        TIMER_ALL_ACCESS,
                        &ObjectAttributes,
                        NotificationTimer
                        );

            if (NT_SUCCESS(Status2)) {

                //
                // Get the timer object for this timer
                //

                Status2 = ObReferenceObjectByHandle (
                             S4DozeTimer,
                             TIMER_ALL_ACCESS,
                             NULL,
                             KernelMode,
                             &S4DozeObject,
                             NULL
                             );

                ASSERT(NT_SUCCESS(Status2));
                ObDereferenceObject(S4DozeObject);
            }
        }

        //
        // Inform drivers of the system sleeping state
        //

        Status = PopSetDevicesSystemState (FALSE);
        if (!NT_SUCCESS(Status)) {
            continue;
        }

        //
        // Drivers have been informed, this operation is now committed,
        // get the next wakeup time
        //

        RtlZeroMemory (&WakeTimeFields, sizeof (WakeTimeFields));

        if (!(PopAction.Flags & POWER_ACTION_DISABLE_WAKES)) {
            //
            // Set S4Doze wakeup timer
            //

            if (S4DozeObject) {
                DueTime.QuadPart = -(LONGLONG) (US2SEC*US2TIME) * PopPolicy->DozeS4Timeout;
                NtSetTimer(S4DozeTimer, &DueTime, NULL, NULL, TRUE, 0, NULL);
            }

            ExGetNextWakeTime(&WakeTime, &WakeTimeFields, &WakeTimerObject);
        }

        //
        // Only enable RTC wake if the system is going to an S-state that
        // supports the RTC wake.
        //
        if (PopCapabilities.RtcWake != PowerSystemUnspecified &&
            PopCapabilities.RtcWake >= PopAction.SystemState &&
            WakeTime) {

#if DBG
            ULONGLONG       InterruptTime;

            InterruptTime = KeQueryInterruptTime();
            PoPrint (PO_PACT, ("Wake alarm set%s: %d:%02d:%02d %d (%d seconds from now)\n",
                WakeTimerObject == S4DozeObject ? " for s4doze" : "",
                WakeTimeFields.Hour,
                WakeTimeFields.Minute,
                WakeTimeFields.Second,
                WakeTimeFields.Year,
                (WakeTime - InterruptTime) / (US2TIME * US2SEC)
                ));
#endif
            HalSetWakeEnable(TRUE);
            HalSetWakeAlarm(WakeTime, &WakeTimeFields);

        } else {

            HalSetWakeEnable(TRUE);
            HalSetWakeAlarm( 0, NULL );

        }

        //
        // Capture the last sleep time.
        //
        SleepTime = KeQueryInterruptTime();

        //
        // Implement system handler for sleep operation
        //

        Status = PopSleepSystem (PopAction.SystemState,
                                 PopAction.HiberContext);
        //
        // A sleep or shutdown operation attempt was performed, clean up
        //

        break;
    }

    //
    // If the system slept successfully, update the system time to
    // match the CMOS clock.
    //
    if (NT_SUCCESS(Status)) {
        PopAction.SleepTime = SleepTime;
        ASSERT(TimerRefreshLockOwned);
        ExUpdateSystemTimeFromCmos (TRUE, 1);

        PERFINFO_HIBER_START_LOGGING();
    }

    //
    // If DevState was allocated, notify drivers the system is awake
    //

    if (PopAction.DevState) {

        //
        // Log any failures
        //

        PopReportDevState (TRUE);

        //
        // Notify drivers that the system is now running
        //
        PopSetDevicesSystemState (TRUE);

    }

    //
    // Free the device notify list. This must be done before acquiring
    // the policy lock, otherwise we can deadlock with the PNP device
    // tree lock.
    //
    ASSERT(PopAction.DevState != NULL);
    IoFreePoDeviceNotifyList(&PopAction.DevState->Order);

    //
    // Get the policy lock for the rest of the cleanup
    //

    if (!PolicyLockOwned) {
        PopAcquirePolicyLock ();
        PolicyLockOwned = TRUE;
    }

    //
    // Cleanup DevState
    //
    PopCleanupDevState ();

    if (NT_SUCCESS(Status)) {

        //
        // Now that the time has been fixed, record the last state
        // the system has awoken from and the current time
        //

        PopAction.LastWakeState = PopAction.SystemState;
        PopAction.WakeTime = KeQueryInterruptTime();


        //
        // See if we woke up because of the RTC...
        //
        if (S4DozeObject) {

            NtQueryTimer (S4DozeTimer,
                          TimerBasicInformation,
                          &TimerInformation,
                          sizeof (TimerInformation),
                          NULL);

            if (TimerInformation.TimerState) {

                //
                // Yes, we woke up because the RTC fired.
                //
                PoPrint (PO_PACT, ("Wake with S4 timer expired\n"));
                PoPrint (PO_PACT, ("Pop: Elapsed time since RTC fired: %d\r\n", (PopAction.WakeTime - WakeTime)) );

                if( WakeTimerObject == S4DozeObject ) {

                    //
                    // We woke up from the RTC, but we need to deal
                    // with a couple of whacky BIOS issues here.
                    // 1. Some BIOS's say they do, but don't really
                    //    support waking from the RTC.  For these, we
                    //    need to make sure the RTC didn't expire a really
                    //    long time ago and that we're just waking up because
                    //    someone hit the wakeup button.
                    // 2. Some BIOS's say that a user is present (signal
                    //    a button event) when we wake up because they want
                    //    the screen to come on and show their branding.
                    //    So we need to see if the RTC expired a *really*
                    //    short time ago and if so, assume there really isn't
                    //    a user present.
                    //
                    BOOLEAN MoveToS4 = FALSE;

                    if( !AnyBitsSet (PopFullWake, PO_FULL_WAKE_STATUS | PO_FULL_WAKE_PENDING) ) {
                        //
                        // We don't think any user is around, so see how long ago
                        // the RTC expired.
                        //
                        if( (PopAction.WakeTime - WakeTime) <
                            (SYS_IDLE_REENTER_TIMEOUT * US2TIME * US2SEC) ) {

                            //
                            // It fired semi-recently. so we should probably
                            // move aggressively into S4
                            //
                            MoveToS4 = TRUE;
                        }
                    } else {
                        //
                        // We think a user is present.  But some BIOS's tell us
                        // a user is present when we wake up when there really isn't.
                        //
                        if( (PopAction.WakeTime - WakeTime) <
                            (SYS_IGNORE_USERPRESENT_AND_BELIEVE_RTC * US2TIME * US2SEC) ) {

                            //
                            // The RTC fired *very* recently, so ignore the fact that
                            // we've been told a user is around and move aggressively
                            // into S4.
                            //
                            MoveToS4 = TRUE;

                            //
                            // Let's also hide the fact that the BIOS lied to us about
                            // a user being present.  This will help smooth things over
                            // if something bad happens on the hibernate path and we have
                            // to come up unexpectedly.
                            //
                            InterlockedAnd( &PopFullWake, ~(PO_FULL_WAKE_STATUS|PO_FULL_WAKE_PENDING) );
                        }

                    }

                    if( MoveToS4 ) {
                        PopAction.Action = PowerActionSleep;
                        PopAction.LightestState = PowerSystemHibernate;
                        PopAction.Updates |= PO_PM_REISSUE;

                        PopInitSIdle();
                    }
                }
            }
        }
    }

    
    //
    // Free anything that's left of the hiber context
    //

    PopFreeHiberContext (TRUE);

    //
    // Clear out PopAction unless we have promoted directly to hibernate
    //
    if ((PopAction.Updates & PO_PM_REISSUE) == 0) {
        PopResetActionDefaults();
    }

    //
    // We are no longer active
    // We don't check for work here as this may be "the thread" from winlogon.
    // So we explicitly queue pending policy work off to a worker thread below
    // after setting the win32k wake notifications.
    //

    PopAction.State = PO_ACT_CALLOUT;
    PopReleasePolicyLock (FALSE);

    //
    // If there's been some sort of error, make sure gdi is enabled
    //

    if (!NT_SUCCESS(Status)) {
        PopDisplayRequired (0);
    }

    //
    // If some win32k wake event is pending, tell win32k
    //

    if (PopFullWake & PO_FULL_WAKE_PENDING) {
        PopSetNotificationWork (PO_NOTIFY_FULL_WAKE);
    } else if (PopFullWake & PO_GDI_ON_PENDING) {
        PopSetNotificationWork (PO_NOTIFY_DISPLAY_REQUIRED);
    }

    //
    // If the timer refresh lock was acquired, release it
    //

    if (TimerRefreshLockOwned) {
        ExReleaseTimeRefreshLock();
    } else {
        //
        // try to catch weird case where we exit this routine with the
        // time refresh lock held.
        //
        ASSERT(!ExIsResourceAcquiredExclusive(&ExpTimeRefreshLock));
    }

    //
    // Unlock pageable code. The unlock is queued off to a delayed worker queue
    // since it is likely to block on pagable code, registry, etc. The PopUnlockComplete
    // event is used to prevent the unlock from racing with a subsequent lock.
    //
    ExQueueWorkItem(&PopUnlockAfterSleepWorkItem, DelayedWorkQueue);

    //
    // If a timer for s4 dozing was allocated, close it
    //

    if (S4DozeObject) {
        NtClose (S4DozeTimer);
    }

    //
    // If we wrote an errlog message indicating that we were hibernating, write a corresponding
    // one to indicate we have woken.
    //
    if (WroteErrLog) {

        ErrLog = IoAllocateGenericErrorLogEntry(sizeof(IO_ERROR_LOG_PACKET));
        if (ErrLog) {

            //
            // Fill it in and write it out
            //
            ErrLog->FinalStatus = STATUS_RESUME_HIBERNATION;
            ErrLog->ErrorCode = STATUS_RESUME_HIBERNATION;
            IoWriteErrorLogEntry(ErrLog);
        }
    }

    //
    // Finally, we can revert the throttle back to a normal value
    //
    PopSetPerfFlag( PSTATE_DISABLE_THROTTLE_NTAPI, TRUE );
    PopUpdateAllThrottles();

    //
    // Done - kick off the policy worker thread to process any outstanding work in
    // a worker thread.
    //
    PopCheckForWork(TRUE);
    //
    // enable registry's lazzy flusher
    //
    CmSetLazyFlushState(TRUE);

    //
    // try to catch weird case where we exit this routine with the
    // time refresh lock held.
    //
    ASSERT(!ExIsResourceAcquiredExclusive(&ExpTimeRefreshLock));
    return Status;
}


NTSYSAPI
NTSTATUS
NTAPI
NtRequestDeviceWakeup(
    IN HANDLE Device
    )
/*++

Routine Description:

    This routine requests a WAIT_WAKE Irp on the specified handle.

    If the handle is to a device object, the WAIT_WAKE irp is sent
    to the top of that device's stack.

    If a WAIT_WAKE is already outstanding on the device, this routine
    increments the WAIT_WAKE reference count and return success.

Arguments:

    Device - Supplies the device which should wake the system

Return Value:

    NTSTATUS

--*/

{
    UNREFERENCED_PARAMETER (Device);

    return(STATUS_NOT_IMPLEMENTED);
}


NTSYSAPI
NTSTATUS
NTAPI
NtCancelDeviceWakeupRequest(
    IN HANDLE Device
    )
/*++

Routine Description:

    This routine cancels a WAIT_WAKE irp sent to a device previously
    with NtRequestDeviceWakeup.

    The WAIT_WAKE reference count on the device is decremented. If this
    count goes to zero, the WAIT_WAKE irp is cancelled.

Arguments:

    Device - Supplies the device which should wake the system

Return Value:

    NTSTATUS

--*/

{
    UNREFERENCED_PARAMETER (Device);

    return(STATUS_NOT_IMPLEMENTED);
}


NTSYSAPI
BOOLEAN
NTAPI
NtIsSystemResumeAutomatic(
    VOID
    )
/*++

Routine Description:

    Returns whether or not the most recent wake was automatic
    or due to a user action.

Arguments:

    None

Return Value:

    TRUE - The system was awakened due to a timer or device wake

    FALSE - The system was awakened due to a user action

--*/

{
    if (AnyBitsSet(PopFullWake, PO_FULL_WAKE_STATUS | PO_FULL_WAKE_PENDING)) {
        return(FALSE);
    } else {
        return(TRUE);
    }
}


NTSYSAPI
NTSTATUS
NTAPI
NtGetDevicePowerState(
    IN HANDLE Device,
    OUT DEVICE_POWER_STATE *State
    )
/*++

Routine Description:

    Queries the current power state of a device.

Arguments:

    Device - Supplies the handle to a device.

    State - Returns the current power state of the device.

Return Value:

    NTSTATUS

--*/

{
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    PDEVOBJ_EXTENSION   doe;
    KPROCESSOR_MODE     PreviousMode;
    DEVICE_POWER_STATE dev_state;

    PAGED_CODE();

    //
    // Verify caller's parameter
    //
    ASSERT(Device);
    ASSERT(State);
    
    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteUlong((PULONG)State);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
            return(status);
        }
    }

    //
    // Reference the file object in order to get to the device object
    // in question.
    //
    status = ObReferenceObjectByHandle(Device,
                                       0L,
                                       IoFileObjectType,
                                       KeGetPreviousMode(),
                                       (PVOID *)&fileObject,
                                       NULL);
    if (!NT_SUCCESS(status)) {
        return(status);
    }

    //
    // Get the address of the target device object.
    //
    status = IoGetRelatedTargetDevice(fileObject, &deviceObject);

    //
    // Now that we have the device object, we are done with the file object
    //
    ObDereferenceObject(fileObject);
    if (!NT_SUCCESS(status)) {
        return(status);
    }

    doe = deviceObject->DeviceObjectExtension;
    dev_state = PopLockGetDoDevicePowerState(doe);
    try {
        *State = dev_state;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    ObDereferenceObject(deviceObject);
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\pbatt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pbatt.c

Abstract:

    This module interfaces the policy manager to the composite device

Author:

    Ken Reneris (kenr) 17-Jan-1997

Revision History:

--*/


#include "pop.h"


//
// Internal prototypes
//


VOID
PopRecalculateCBTriggerLevels (
    ULONG     Flags
    );

VOID
PopComputeCBTime (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PopRecalculateCBTriggerLevels)
#pragma alloc_text(PAGE, PopCompositeBatteryDeviceHandler)
#pragma alloc_text(PAGE, PopComputeCBTime)
#pragma alloc_text(PAGE, PopResetCBTriggers)
#pragma alloc_text(PAGE, PopCurrentPowerState)
#endif

VOID
PopCompositeBatteryUpdateThrottleLimit(
    IN  ULONG   CurrentCapacity
    )
/*++

Routine Description:

    This routine is called to update the ThrottleLimit in each of the
    processor's PRCB.

    We update the ThrottleLimit based on the percentage of the battery's
    capacity that remains.  I.e. we are called to throttle the processor
    to lower frequencies as the battery runs down.

    This function was broken out because it cannot be paged code

Arguments:

    CurrentCapacity - PercentageCapacity remaining...

Return Value:

    None

--*/
{
    KAFFINITY               currentAffinity;
    KAFFINITY               processors;
    PPROCESSOR_PERF_STATE   perfStates;
    PPROCESSOR_POWER_STATE  pState;
    ULONG                   perfStatesCount;
    ULONG                   i;
    KIRQL                   oldIrql;
#if DBG
    ULONGLONG               currentTime;
    UCHAR                   t[40];

    currentTime = KeQueryInterruptTime();
    PopTimeString(t, currentTime);
#endif


    //
    // Walk the processors and set each one's PRCB based
    // on our incoming %-remaining of the battery's life.
    //
    currentAffinity = 1;
    processors = KeActiveProcessors;
    while (processors) {

        if (!(processors & currentAffinity)) {

            currentAffinity <<= 1;
            continue;

        }

        KeSetSystemAffinityThread( currentAffinity );
        processors &= ~currentAffinity;
        currentAffinity <<= 1;

        //
        // We need to be running at DISPATCH_LEVEL to access the
        // structures referenced within the pState...
        //
        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        pState = &(KeGetCurrentPrcb()->PowerState);

        //
        // Does this processor support throttling?
        //
        if ((pState->Flags & PSTATE_SUPPORTS_THROTTLE) == 0) {

            //
            // No, then we don't care about it...
            //
            KeLowerIrql( oldIrql );
            continue;

        }

        //
        // Look at the power structure and get the array of
        // perf states supported. Note that we change the
        // perfStatesCount by subtracting one so that we don't
        // have to worry about overrruning the array during
        // the for loop
        //
        pState = &(KeGetCurrentPrcb()->PowerState);
        perfStates = pState->PerfStates;
        perfStatesCount = (pState->PerfStatesCount - 1);

        //
        // See which throttle point is best for this power
        // capacity. Note that we have pre-calculated which
        // capacity matches which state, so its only a matter
        // of walking the array...
        //
        for (i = pState->KneeThrottleIndex; i < perfStatesCount; i++) {

            if (perfStates[i].MinCapacity <= CurrentCapacity) {

                break;

            }

        }

        //
        // Update the throttle limit index
        //
        if (pState->ThrottleLimitIndex != i) {

            pState->ThrottleLimitIndex = (UCHAR) i;
#if DBG
            PoPrint(
                PO_THROTTLE,
                ("PopApplyThermalThrottle - %s - New Limit (%d) Index (%d)\n",
                 t,perfStates[i].PercentFrequency,i)
                );
#endif

            //
            // Force a throttle update
            //
            PopUpdateProcessorThrottle();

        }

        //
        // Revert back to our previous IRQL
        //
        KeLowerIrql( oldIrql );

    } // while

    //
    // Revert to the affinity of the original thread
    //
    KeRevertToUserAffinityThread();

}

VOID
PopCompositeBatteryDeviceHandler (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    This function is the irp handler function to handle the completion
    of the composite battery irp.   When there is a composite battery
    present one IRP is always outstanding to the device.  On completion
    this IRP is recycled to the next request.

    N.B. PopPolicyLock must be held.

Arguments:

    DeviceObject    - DeviceObject of the battery device

    Irp             - Irp which has completed

    Context         - n/a

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PVOID                   InputBuffer;
    ULONG                   InputBufferLength, OutputBufferLength;
    ULONG                   IoctlCode;
    ULONG                   i;
    ULONG                   currentCapacity;
#if DBG
    ULONGLONG               currentTime;
    UCHAR                   t[40];

    currentTime = KeQueryInterruptTime();
    PopTimeString(t, currentTime);
#endif

    UNREFERENCED_PARAMETER (Context);

    ASSERT_POLICY_LOCK_OWNED();
    ASSERT (Irp == PopCB.StatusIrp);
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        //
        // Handle the completed request
        //

        switch (PopCB.State) {
            case PO_CB_READ_TAG:
            case PO_CB_WAIT_TAG:
                
                //
                // A new battery has appeared on the system.  We need to
                // go read the tag information and reset the battery
                // triggers.
                //
                PoPrint(PO_BATT, ("PopCB: New battery tag\n"));

                //
                // Reset the triggers.
                //
                // We reset PO_TRG_SET, so the level will be recalculated.
                //
                // Note that on battery tag change,  we don't want to make 
                // the actions happen again.  If the trigger has not yet
                // been set off, it will still be armed.
                //

                PopResetCBTriggers (PO_TRG_SET);
                PopCB.State = PO_CB_READ_INFO;
                PopCB.Tag = PopCB.u.Tag;

                // Ensure that the power state passed in is bad, so QUERY_STATUS
                // will return immediately.
                PopCB.Status.PowerState = (ULONG) -1;
                break;

            case PO_CB_READ_INFO:
                
                //
                // Read the info directly into our 'Info' field, then ask
                // ourselves to go read the 'Status', thus performing some
                // verification.
                //
                PoPrint(PO_BATT, ("PopCB: info read\n"));
                PopCB.State = PO_CB_READ_STATUS;
                RtlCopyMemory (&PopCB.Info, &PopCB.u.Info, sizeof(PopCB.Info));
                break;

            case PO_CB_READ_STATUS:
            {
                PSYSTEM_POWER_POLICY    SystemPolicy;
                PPROCESSOR_POWER_POLICY ProcessorPolicy;

                //
                // Status has been read, check it
                //

                PoPrint(PO_BATT, ("PopCB: Status PwrState %x, Cap %x, Volt %x, Cur %x\n",
                    PopCB.u.Status.PowerState,
                    PopCB.u.Status.Capacity,
                    PopCB.u.Status.Voltage,
                    PopCB.u.Status.Current
                    ));

                PopCB.StatusTime = KeQueryInterruptTime();

                //
                // Check if the current policy should be ac or dc
                //

                if (PopCB.u.Status.PowerState & BATTERY_POWER_ON_LINE) {
                    ProcessorPolicy = &PopAcProcessorPolicy;
                    SystemPolicy = &PopAcPolicy;
                } else {
                    ProcessorPolicy = &PopDcProcessorPolicy;
                    SystemPolicy = &PopDcPolicy;
                }

                //
                // Did the policy change?
                //

                if (PopPolicy != SystemPolicy || PopProcessorPolicy != ProcessorPolicy) {

                    //
                    // Change the active policy and reset the battery triggers
                    //
                    PopProcessorPolicy = ProcessorPolicy;
                    PopPolicy = SystemPolicy;

                    //
                    // Reset triggers.
                    //
                    // In this case we re-arm both the user and system triggers.
                    // The system trigger will be disarmed when we recalculate
                    // trigger levels if the capacity was already below that level.
                    //
                    PopResetCBTriggers (PO_TRG_SET | PO_TRG_USER | PO_TRG_SYSTEM);
                    PopSetNotificationWork (
                        PO_NOTIFY_ACDC_CALLBACK |
                        PO_NOTIFY_POLICY |
                        PO_NOTIFY_PROCESSOR_POLICY
                        );

                    //
                    // Recompute thermal throttle and cooling mode
                    //
                    // Note that PopApplyThermalThrottle will take care of any dynamic
                    // throttling that might need to happen due to the AC/DC transition.
                    //
                    PopApplyThermalThrottle ();
                    PopIdleUpdateIdleHandlers();

                    //
                    // Recompute system idle values
                    //
                    PopInitSIdle ();

                }

                //
                // Did battery cross resolution setting?
                // Correction... Has it changed at all.  If so, all apps should be updated,
                // even if it hasn't crossed a resolution setting.  Otherwise, if one app
                // queries the current status, it could be displaying a different value than
                // the battery meter.
                //

                if ((PopCB.u.Status.Capacity != PopCB.Status.Capacity) ||
                        PopCB.Status.PowerState != PopCB.u.Status.PowerState) {
                    PopSetNotificationWork (PO_NOTIFY_BATTERY_STATUS);
                    PopCB.State = PO_CB_READ_EST_TIME;
                }

                PopRecalculateCBTriggerLevels (PO_TRG_SYSTEM);

                //
                // Update current battery status
                //

                memcpy (&PopCB.Status, &PopCB.u.Status, sizeof (PopCB.Status));

                //
                // Check for discharging and if any discharge policies have tripped
                //

                if (SystemPolicy == &PopDcPolicy) {
                    for (i=0; i < PO_NUM_POWER_LEVELS; i++) {
                        if (PopCB.Status.Capacity <= PopCB.Trigger[i].Battery.Level) {

                            //
                            // Fire this power action
                            //
                            PopSetPowerAction(
                                &PopCB.Trigger[i],
                                PO_NOTIFY_BATTERY_STATUS,
                                &SystemPolicy->DischargePolicy[i].PowerPolicy,
                                SystemPolicy->DischargePolicy[i].MinSystemState,
                                SubstituteLightestOverallDownwardBounded
                                );

                            PopCB.State = PO_CB_READ_EST_TIME;

                        } else {

                            //
                            // Clear the trigger for this event
                            //

                            PopCB.Trigger[i].Flags &= ~(PO_TRG_USER|PO_TRG_SYSTEM);
                        }

                    }

                    //
                    // Figure out what our current capacity is while guarding
                    // against whacky UI...
                    //
                    if (PopCB.Info.FullChargedCapacity > PopCB.Status.Capacity) {

                        currentCapacity = PopCB.Status.Capacity * 100 /
                            PopCB.Info.FullChargedCapacity;

                    } else {

                        //
                        // Assume that the battery is fully charged...
                        // This will cause us to reset the throttle limiter
                        //
                        currentCapacity = 100;

                    }

                } else {

                    //
                    // Assume that the battery is fully charged...
                    // This will cause us to reset the throttle limiter
                    //
                    currentCapacity = 100;

                }

                //
                // This is kind of silly code to put in here, but since
                // want to minize our synchronization elsewhere, we have
                // to examine every processor's powerstate and update
                // the throttlelimitindex on each. This may be actually
                // a smart thing to do if not all processors support
                // the same set of states
                //
                PopCompositeBatteryUpdateThrottleLimit( currentCapacity );

                //
                // If there's a thread waiting or if we notified user (since
                // the response to the notify will be to read the power status) for
                // power state, read the est time now else read new status
                //

                if (PopCB.ThreadWaiting) {
                    PopCB.State = PO_CB_READ_EST_TIME;
                }
                break;
            }
            case PO_CB_READ_EST_TIME:
                //
                // Estimated time is read after sucessful status
                // read and (currently) only when there's a thread
                // waiting for the system power state
                //

                PoPrint(PO_BATT, ("PopCB: EstTime read\n"));
                PopCB.EstTime = PopCB.u.EstTime;

                PopCB.EstTimeTime = KeQueryInterruptTime();
                PopComputeCBTime();

                //
                // Signal waiting threads
                //

                PopCB.ThreadWaiting = FALSE;
                KeSetEvent (&PopCB.Event, 0, FALSE);

                //
                // Go back are read status
                //

                PopCB.State = PO_CB_READ_STATUS;
                break;

            default:
                PopInternalAddToDumpFile( Irp, sizeof(IRP), DeviceObject, NULL, NULL, NULL );
                KeBugCheckEx( INTERNAL_POWER_ERROR,
                              0x300,
                              POP_BATT,
                              (ULONG_PTR)DeviceObject,
                              (ULONG_PTR)Irp );
                break;
        }

    } else {
        //
        // some sort of error, if the request was canceld re-issue
        // it else backup to reinitialize
        //

        if (Irp->IoStatus.Status != STATUS_CANCELLED) {

            //
            // This occurs under two circumstances.  It is either the first time
            // through, or a battery was removed so the Irp failed during our
            // attempt to tag change.
            //

            //
            // If this is already a read-tag request then there's no battery present
            //

            PopCB.State = (PopCB.State == PO_CB_READ_TAG) ? PO_CB_WAIT_TAG : PO_CB_READ_TAG;
            PoPrint(PO_BATT, ("PopCB: error %x - new state %d\n",
                Irp->IoStatus.Status,
                PopCB.State
                ));
        } else {
            PoPrint(PO_BATT, ("PopCB: irp cancelled\n"));
            PopRecalculateCBTriggerLevels (PO_TRG_SYSTEM | PO_TRG_USER);
        }
    }

    //
    // If new state is none, then there's no battery
    //

    if (PopCB.State != PO_CB_NONE) {

        //
        // Issue new request based on current state
        //

        IrpSp = IoGetNextIrpStackLocation(Irp);
        IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        IoctlCode = IOCTL_BATTERY_QUERY_INFORMATION;
        PopCB.u.QueryInfo.BatteryTag = PopCB.Tag;
        InputBuffer = &PopCB.u.QueryInfo;
        InputBufferLength = sizeof(PopCB.u.QueryInfo);

        switch (PopCB.State) {
            case PO_CB_READ_TAG:
                PoPrint(PO_BATT, ("PopCB: query tag\n"));
                IoctlCode = IOCTL_BATTERY_QUERY_TAG;
                PopCB.u.Tag = (ULONG) 0;
                InputBufferLength = sizeof(ULONG);
                OutputBufferLength = sizeof(PopCB.Tag);
                break;

            case PO_CB_WAIT_TAG:
                PoPrint(PO_BATT, ("PopCB: query tag\n"));

                //
                // Battery is gone.  Wait for it to appear
                //

                IoctlCode = IOCTL_BATTERY_QUERY_TAG;
                PopCB.u.Tag = (ULONG) -1;
                InputBufferLength = sizeof(ULONG);
                OutputBufferLength = sizeof(PopCB.Tag);

                //
                // Notify battery status change, and wake any threads
                //

                PopSetNotificationWork (PO_NOTIFY_BATTERY_STATUS);

                if (PopCB.ThreadWaiting) {
                    PopCB.ThreadWaiting = FALSE;
                    KeSetEvent (&PopCB.Event, 0, FALSE);
                }

                break;

            case PO_CB_READ_INFO:
                PoPrint(PO_BATT, ("PopCB: query info\n"));
                PopCB.u.QueryInfo.InformationLevel = BatteryInformation;
                OutputBufferLength = sizeof(PopCB.Info);
                break;

            case PO_CB_READ_STATUS:
                //
                // Calculate next wait
                //

                PopCB.u.Wait.BatteryTag   = PopCB.Tag;
                PopCB.u.Wait.PowerState   = PopCB.Status.PowerState;
                PopCB.u.Wait.Timeout      = (ULONG) -1;
                if (PopCB.ThreadWaiting) {
                    PopCB.u.Wait.Timeout  = 0;
                }

                i = (PopCB.Info.FullChargedCapacity *
                     PopPolicy->BroadcastCapacityResolution) / 100;
                if (!i) {
                    i = 1;
                }

                if (PopCB.Status.Capacity > i) {
                    PopCB.u.Wait.LowCapacity  =  PopCB.Status.Capacity - i;
                } else {
                    PopCB.u.Wait.LowCapacity  = 0;
                }

                PopCB.u.Wait.HighCapacity = PopCB.Status.Capacity + i;
                if (PopCB.u.Wait.HighCapacity < i) {
                    // avoid rare case of overflow
                    PopCB.u.Wait.HighCapacity = (ULONG) -1;
                }

                //
                // Check limits against power policies
                //

                for (i=0; i < PO_NUM_POWER_LEVELS; i++) {
                    if (PopCB.Trigger[i].Flags & PO_TRG_SET) {

                        if (PopCB.Trigger[i].Battery.Level < PopCB.Status.Capacity   &&
                            PopCB.Trigger[i].Battery.Level > PopCB.u.Wait.LowCapacity) {

                            PopCB.u.Wait.LowCapacity = PopCB.Trigger[i].Battery.Level;
                        }

                        if (PopCB.Trigger[i].Battery.Level > PopCB.Status.Capacity   &&
                            PopCB.Trigger[i].Battery.Level < PopCB.u.Wait.HighCapacity) {

                            PopCB.u.Wait.HighCapacity = PopCB.Trigger[i].Battery.Level;
                        }
                    }
                }

                IoctlCode = IOCTL_BATTERY_QUERY_STATUS;
                InputBuffer = &PopCB.u.Wait;
                InputBufferLength = sizeof(PopCB.u.Wait);
                OutputBufferLength = sizeof(PopCB.Status);
                PoPrint(PO_BATT, ("PopCB: timeout %x, pwrstate %x, low %x - high %x\n",
                    PopCB.u.Wait.Timeout,
                    PopCB.u.Wait.PowerState,
                    PopCB.u.Wait.LowCapacity,
                    PopCB.u.Wait.HighCapacity
                    ));

                break;

            case PO_CB_READ_EST_TIME:
                PoPrint(PO_BATT, ("PopCB: query est time\n"));
                PopCB.u.QueryInfo.InformationLevel = BatteryEstimatedTime;
                PopCB.u.QueryInfo.AtRate = 0;
                OutputBufferLength = sizeof(PopCB.EstTime);
                break;

            default:
                PopInternalAddToDumpFile( IrpSp, sizeof(IO_STACK_LOCATION), DeviceObject, NULL, NULL, NULL );
                KeBugCheckEx( INTERNAL_POWER_ERROR,
                              0x301,
                              POP_BATT,
                              (ULONG_PTR)DeviceObject,
                              (ULONG_PTR)IrpSp );
                break;
        }

        //
        // Submit IRP
        //

        IrpSp->Parameters.DeviceIoControl.IoControlCode = IoctlCode;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
        Irp->AssociatedIrp.SystemBuffer = &PopCB.u;
        Irp->UserBuffer = &PopCB.u;
        Irp->PendingReturned = FALSE;
        Irp->Cancel = FALSE;
        IoSetCompletionRoutine (Irp, PopCompletePolicyIrp, NULL, TRUE, TRUE, TRUE);
        IoCallDriver (DeviceObject, Irp);

    } else {
        //
        // Battery has disappeared  (state is PO_CB_NONE)
        //

        PoPrint(PO_BATT, ("PopCB: Battery removed\n"));
        PopSetNotificationWork (PO_NOTIFY_BATTERY_STATUS);

        //
        // Set policy to AC
        //

        if (PopPolicy != &PopAcPolicy) {
            PopPolicy = &PopAcPolicy;
            PopProcessorPolicy = &PopAcProcessorPolicy;
            PopSetNotificationWork(
                PO_NOTIFY_ACDC_CALLBACK |
                PO_NOTIFY_POLICY |
                PO_NOTIFY_PROCESSOR_POLICY
                );
            PopApplyThermalThrottle();
            PopIdleUpdateIdleHandlers();
            PopInitSIdle ();
        }

        //
        // Wake any threads
        //

        if (PopCB.ThreadWaiting) {
            PopCB.ThreadWaiting = FALSE;
            KeSetEvent (&PopCB.Event, 0, FALSE);
        }

        //
        // Cleanup
        //

        IoFreeIrp (Irp);
        PopCB.StatusIrp = NULL;
        ObDereferenceObject (DeviceObject);
    }
}


VOID
PopRecalculateCBTriggerLevels (
    ULONG     Flags
    )
/*++

Routine Description:

    This function is invoked to set the trigger battery levels based on the power
    policy.  This will be invoked whenever the power policy is changed, or whenever
    there is a battery status change that could affect these settings.

    N.B. PopPolicyLock must be held.

Arguments:

    Flags- The flags to set if the level has already been passed:
        example: When user changes alarm leve, we don't want clear
        PO_TRG_USER|PO_TRG_SYSTEM. If the recalculation was caused by a change
        (startup, or AC unplug), we just want to set PO_TRG_SYSTEM because we
        still want the user notification.

Return Value:

    None.

--*/
{
    PSYSTEM_POWER_LEVEL     DPolicy;
    ULONG                   i;

    //
    // Calculate any level settings
    //

    for (i=0; i < PO_NUM_POWER_LEVELS; i++) {
        DPolicy = &PopPolicy->DischargePolicy[i];

        //
        // If this setting not calculated handle it
        //

        if (!(PopCB.Trigger[i].Flags & PO_TRG_SET)  &&  DPolicy->Enable) {

            //
            // Compute battery capacity setting for percentage
            //

            PopCB.Trigger[i].Flags |= PO_TRG_SET;
            PopCB.Trigger[i].Battery.Level =
                PopCB.Info.FullChargedCapacity * DPolicy->BatteryLevel / 100 +
                PopCB.Info.FullChargedCapacity / 200;

            //
            // Make sure setting is not below the lowest default
            //

            if (PopCB.Trigger[i].Battery.Level < PopCB.Info.DefaultAlert1) {
                PopCB.Trigger[i].Battery.Level = PopCB.Info.DefaultAlert1;
            }

            //
            // Skip system action if battery capacity was already below level.
            // This will occur on startup, when a battery is changed,
            // and when AC comes or goes.
            //

            if (PopCB.Status.Capacity < PopCB.Trigger[i].Battery.Level) {
                PopCB.Trigger[i].Flags |= Flags;
            }
        }
    }
}


VOID
PopComputeCBTime (
    VOID
    )
/*++

Routine Description:

    This function is invoked after the battery status & estimated time
    have been read from the battery.  This function can apply heuristics
    or other knowedge to improve the extimated time.

    N.B. PopPolicyLock must be held.

Arguments:

    None

Return Value:

    None.

--*/
{
    // for now just use the batteries value
    PopCB.AdjustedEstTime = PopCB.EstTime;
}

VOID
PopResetCBTriggers (
    IN UCHAR    Flags
    )
/*++

Routine Description:

    This function clears the requested bits from the batteries trigger flags.

    N.B. PopPolicyLock must be held.

Arguments:

    Flags       - Bits to clear

Return Value:

    Status

--*/
{
    ULONG       i;

    ASSERT_POLICY_LOCK_OWNED();

    //
    // Clear flag bits
    //

    Flags = ~Flags;
    for (i=0; i < PO_NUM_POWER_LEVELS; i++) {
        PopCB.Trigger[i].Flags &= Flags;
    }

    //
    // Reread battery status
    //

    if (PopCB.StatusIrp) {
        IoCancelIrp (PopCB.StatusIrp);
    }
}

NTSTATUS
PopCurrentPowerState (
    OUT PSYSTEM_BATTERY_STATE  PowerState
    )
/*++

Routine Description:

    This function returns the current system battery state.  If needed,
    this function will cause the composite battery irp to get the
    current battery status, then converts that information into a more
    readable SYSTEM_BATTERY_STATE structure which is retuned back
    to the user.

    N.B. PopPolicyLock must be held.
    N.B. The function may drop the PopPolicyLock

Arguments:

    PowerState      - pointer to a structure which will recieve the
                      current system battery state.

Return Value:

    Status

--*/
{
    ULONGLONG       CurrentTime;
    NTSTATUS        Status;


    ASSERT_POLICY_LOCK_OWNED();

    Status = STATUS_SUCCESS;
    RtlZeroMemory (PowerState, sizeof(SYSTEM_BATTERY_STATE));

    //
    // Wait for valid state in PopCB
    //

    do {

        //
        // If there's not a composite battery, then return
        //

        if (PopCB.State == PO_CB_NONE || PopCB.State == PO_CB_WAIT_TAG) {
            PowerState->AcOnLine = (PopPolicy == &PopAcPolicy ? TRUE : FALSE);

            // Indicate no battery found...
            PERFINFO_POWER_BATTERY_LIFE_INFO(-1, 0);

            return STATUS_SUCCESS;
        }

        //
        // If device state not being read, we need to wait
        //

        if (PopCB.State == PO_CB_READ_STATUS) {
            //
            // If last EstTime was calculated within PO_MAX_CB_CACHE_TIME,
            // use the current data.  (note this implies status was sucessfully
            // read just before time was calcualted)
            //

            CurrentTime = KeQueryInterruptTime();
            if (CurrentTime - PopCB.EstTimeTime < PO_MAX_CB_CACHE_TIME) {
                break;
            }
        }

        //
        // Need new status.  If no other threads are waiting for
        // system power state, then setup for wait
        //

        if (!PopCB.ThreadWaiting) {
            PopCB.ThreadWaiting = TRUE;
            KeResetEvent (&PopCB.Event);

            //
            // If read status is in progress, cancel it so we
            // can read status now
            //

            if (PopCB.State == PO_CB_READ_STATUS) {
                IoCancelIrp (PopCB.StatusIrp);
            }
        }

        //
        // Wait for status update
        //

        PopReleasePolicyLock (FALSE);
        Status = KeWaitForSingleObject (&PopCB.Event, Executive, KernelMode, TRUE, NULL);
        PopAcquirePolicyLock ();
    } while (NT_SUCCESS(Status));

    //
    // Generate power state
    //

    PowerState->AcOnLine       = (PopCB.Status.PowerState & BATTERY_POWER_ON_LINE) ? TRUE : FALSE;
    PowerState->BatteryPresent = TRUE;
    PowerState->Charging       = (PopCB.Status.PowerState & BATTERY_CHARGING) ? TRUE : FALSE;
    PowerState->Discharging    = (PopCB.Status.PowerState & BATTERY_DISCHARGING) ? TRUE : FALSE;
    PowerState->MaxCapacity    = PopCB.Info.FullChargedCapacity;
    PowerState->RemainingCapacity = PopCB.Status.Capacity;
    PowerState->Rate           = PopCB.Status.Current;
    PowerState->EstimatedTime  = PopCB.AdjustedEstTime;
    PowerState->DefaultAlert1  = PopCB.Info.DefaultAlert1;
    PowerState->DefaultAlert2  = PopCB.Info.DefaultAlert2;

    PERFINFO_POWER_BATTERY_LIFE_INFO(PowerState->RemainingCapacity, PowerState->Rate);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\paction.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    paction.c

Abstract:

    This module implements power action handling for triggered
    power actions

Author:

    Ken Reneris (kenr) 17-Jan-1997

Revision History:

--*/

#include "pop.h"


//
// Interal prototypes
//

VOID
PopPromoteActionFlag (
    OUT PUCHAR      Updates,
    IN ULONG        UpdateFlag,
    IN ULONG        Flags,
    IN BOOLEAN      Set,
    IN ULONG        FlagBit
    );

NTSTATUS
PopIssueActionRequest (
    IN BOOLEAN              Promote,
    IN POWER_ACTION         Action,
    IN SYSTEM_POWER_STATE   PowerState,
    IN ULONG                Flags
    );

VOID
PopCompleteAction (
    PPOP_ACTION_TRIGGER     Trigger,
    NTSTATUS                Status
    );

NTSTATUS
PopDispatchStateCallout(
    IN PKWIN32_POWERSTATE_PARAMETERS Parms,
    IN PULONG SessionId  OPTIONAL
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PoShutdownBugCheck)
#pragma alloc_text(PAGE, PopPromoteActionFlag)
#pragma alloc_text(PAGE, PopSetPowerAction)
#pragma alloc_text(PAGE, PopCompareActions)
#pragma alloc_text(PAGE, PopPolicyWorkerAction)
#pragma alloc_text(PAGE, PopIssueActionRequest)
#pragma alloc_text(PAGE, PopCriticalShutdown)
#pragma alloc_text(PAGE, PopCompleteAction)
#pragma alloc_text(PAGE, PopPolicyWorkerActionPromote)
#pragma alloc_text(PAGE, PopDispatchStateCallout)
#endif


VOID
PoShutdownBugCheck (
    IN BOOLEAN  AllowCrashDump,
    IN ULONG    BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4
    )
/*++

Routine Description:

    This function is used to issue a controlled shutdown & then a bug
    check.  This type of bugcheck can only be issued on a working system.

Arguments:

    AllowCrashDump  - If FALSE crashdump will be disabled

    BugCode         - The bug code for the shutdown

Return Value:

    Does not return

--*/
{
    POP_SHUTDOWN_BUG_CHECK          BugCode;


    //
    // If crash dumps aren't allowed for this bugcheck, then go clear
    // the current crash dump state
    //

    if (!AllowCrashDump) {
        IoConfigureCrashDump (CrashDumpDisable);
    }

    //
    // Indicate the bugcheck to issue once the system has been shutdown
    //

    BugCode.Code = BugCheckCode;
    BugCode.Parameter1 = BugCheckParameter1;
    BugCode.Parameter2 = BugCheckParameter2;
    BugCode.Parameter3 = BugCheckParameter3;
    BugCode.Parameter4 = BugCheckParameter4;
    PopAction.ShutdownBugCode = &BugCode;

    //
    // Initiate a critical shutdown event
    //

    ZwInitiatePowerAction (
        PowerActionShutdown,
        PowerSystemSleeping3,
        POWER_ACTION_OVERRIDE_APPS | POWER_ACTION_DISABLE_WAKES | POWER_ACTION_CRITICAL,
        FALSE
        );

    //
    // Should not return, but just in case...
    //

    KeBugCheckEx (
        BugCheckCode,
        BugCheckParameter1,
        BugCheckParameter2,
        BugCheckParameter3,
        BugCheckParameter4
        );
}

VOID
PopCriticalShutdown (
    POP_POLICY_DEVICE_TYPE  Type
    )
/*++

Routine Description:

    Issue a critical system shutdown.  No application notification
    (presumably they've ignored the issue til now), flush OS state
    and shut off.

    N.B. PopPolicyLock must be held.

Arguments:

    Type            - Root cause of critical shutdown

Return Value:

    None.

--*/
{
    POP_ACTION_TRIGGER      Trigger;
    POWER_ACTION_POLICY     Action;

    ASSERT_POLICY_LOCK_OWNED();

    PoPrint (PO_ERROR, ("PopCriticalShutdown: type %x\n", Type));

    //
    // Go directly to setting the power state
    //

    RtlZeroMemory (&Action, sizeof(Action));
    Action.Action = PowerActionShutdownOff;
    Action.Flags  = POWER_ACTION_OVERRIDE_APPS |
                    POWER_ACTION_DISABLE_WAKES |
                    POWER_ACTION_CRITICAL;

    RtlZeroMemory (&Trigger, sizeof(Trigger));
    Trigger.Type  = Type;
    Trigger.Flags = PO_TRG_SET;

    try {

        //
        // The substitution policy and LightestState do not matter here as
        // the action restricts this to a shutdown.
        //
        PopSetPowerAction(
            &Trigger,
            0,
            &Action,
            PowerSystemHibernate,
            SubstituteLightestOverallDownwardBounded
            );

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ASSERT (!GetExceptionCode());
    }
}


VOID
PopSetPowerAction(
    IN PPOP_ACTION_TRIGGER      Trigger,
    IN ULONG                    UserNotify,
    IN PPOWER_ACTION_POLICY     ActionPolicy,
    IN SYSTEM_POWER_STATE       LightestState,
    IN POP_SUBSTITUTION_POLICY  SubstitutionPolicy
    )
/*++

Routine Description:

    This function is called to "fire" an ActionPolicy.  If there
    is already an action being taken this action is merged in, else
    a new power action is initiated.

    N.B. PopPolicyLock must be held.

Arguments:

    Trigger         - Action trigger structure (for ActionPolicy).

    UserNotify      - Additional USER notifications to fire if trigger occurs

    ActionPolicy    - This action policy which has fired.

    LightestState   - For sleep type actions, the minimum sleeping
                      state which must be entered for this operation.
                      (Inferred to be PowerSystemHibernate for
                      PowerActionHibernate and PowerActionWarmEject)

    SubstitutionPolicy - Specifies how LightestState should be treated if it
                         is not supported.

Return Value:

    None.

--*/
{
    UCHAR           Updates;
    ULONG           i, Flags;
    BOOLEAN         Pending;
    BOOLEAN         Disabled;
    POWER_ACTION    Action;

    ASSERT_POLICY_LOCK_OWNED();

    if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
        PERFINFO_SET_POWER_ACTION LogEntry;

        LogEntry.PowerAction = (ULONG) ActionPolicy->Action;
        LogEntry.LightestState = (ULONG) LightestState;
        LogEntry.Trigger = Trigger;

        PerfInfoLogBytes(PERFINFO_LOG_TYPE_SET_POWER_ACTION,
                         &LogEntry,
                         sizeof(LogEntry));
    }

    //
    // If the trigger isn't set, then we're done
    //

    if (!(Trigger->Flags & PO_TRG_SET)) {
        PopCompleteAction (Trigger, STATUS_SUCCESS);
        return ;
    }

    PoPrint (PO_PACT, ("PopSetPowerAction: %s, Flags %x, Min=%s\n",
                        PopPowerActionString(ActionPolicy->Action),
                        ActionPolicy->Flags,
                        PopSystemStateString(LightestState)
                        ));

    //
    // Round request to system capabilities
    //
    PopVerifySystemPowerState(&LightestState, SubstitutionPolicy);
    Disabled = PopVerifyPowerActionPolicy (ActionPolicy);
    if (Disabled) {
        PopCompleteAction (Trigger, STATUS_NOT_SUPPORTED);
        return ;
    }

    //
    // If system action not already triggered, do so now
    //

    Pending = FALSE;
    if (!(Trigger->Flags & PO_TRG_SYSTEM)) {
        Trigger->Flags |= PO_TRG_SYSTEM;
        Action = ActionPolicy->Action;
        Flags = ActionPolicy->Flags;

        //
        // If state is idle, then clear residue values
        //

        if (PopAction.State == PO_ACT_IDLE) {

            PopResetActionDefaults();
        }

        //
        // If the action is for something other then none, then check it against the
        // current action
        //

        if (Action != PowerActionNone) {
            Updates = 0;

            //
            // Hibernate actions are treated like sleep actions with a min state
            // of hibernate. Warm ejects are like sleeps that start light and
            // deepen only as neccessary, but we do not map them to the same
            // action because we don't want to be constrained by the users
            // power policy.
            //

            if (Action == PowerActionWarmEject) {

                ASSERT (LightestState <= PowerSystemHibernate);
                Flags |= POWER_ACTION_LIGHTEST_FIRST;
            }

            if (Action == PowerActionHibernate) {

                ASSERT (LightestState <= PowerSystemHibernate);
                LightestState = PowerSystemHibernate;
            }

            //
            // Is this action is as good as the current action?
            //

            if ( PopCompareActions(Action, PopAction.Action) >= 0) {
                //
                // allow the absence of query_allowed, ui_allowed.
                //

                PopPromoteActionFlag (&Updates, PO_PM_USER, Flags, FALSE, POWER_ACTION_QUERY_ALLOWED);
                PopPromoteActionFlag (&Updates, PO_PM_USER, Flags, FALSE, POWER_ACTION_UI_ALLOWED);

                //
                // Always favor the deepest sleep first, and restart if we
                // switch.
                //
                PopPromoteActionFlag (&Updates, PO_PM_SETSTATE, Flags, FALSE, POWER_ACTION_LIGHTEST_FIRST);

                //
                // If this is a sleep action, then make sure Lightest is at least whatever
                // the current policy is set for
                //

                if (Action == PowerActionSleep  &&  LightestState < PopPolicy->MinSleep) {
                    LightestState = PopPolicy->MinSleep;
                }

                //
                // If LightestState is more restrictive (deeper) than the one
                // specified by the current action, promote it.
                //

                if (LightestState > PopAction.LightestState) {
                    PopAction.LightestState = LightestState;
                    Updates |= PO_PM_SETSTATE;
                }
            }

            //
            // Promote the critical & override_apps flags
            //

            PopPromoteActionFlag (&Updates, PO_PM_USER, Flags, TRUE, POWER_ACTION_OVERRIDE_APPS);
            PopPromoteActionFlag (&Updates, PO_PM_USER | PO_PM_SETSTATE, Flags, TRUE, POWER_ACTION_CRITICAL);

            //
            // Promote disable_wake flag.  No updates are needed for this - it will be
            // picked up in NtSetSystemPowerState regardless of the params passed from
            // user mode
            //

            PopPromoteActionFlag (&Updates, 0, Flags, TRUE, POWER_ACTION_DISABLE_WAKES);

            //
            // If the new action is more agressive then the old action, promote it
            //

            if ( PopCompareActions(Action, PopAction.Action) > 0) {

                //
                // If we are promoting, the old action certainly cannot be a
                // shutdown, as that is the deepest action.
                //

                ASSERT(PopCompareActions(PopAction.Action, PowerActionShutdownOff) < 0);

                //
                // If we are promoting into a deeper *action*, and the new
                // action is hibernate or shutdown, then we want to reissue.
                //
                // ADRIAO N.B. 08/02/1999 -
                //     We might want to reissue for hibernate only if the new
                // state brings in POWER_ACTION_CRITICAL to the mix. This is
                // because there are two scenario's for hibernate, one where
                // the user selects standby then hibernate in quick succession
                // (consider a lid switch set to hiber, and the user closes the
                // lid after selecting standby), or this might be hibernate due
                // to low battery (ie, we're deepening standby). Believe it or
                // not, the user can disable the "critical flag" in the critical
                // power-down menu.
                //

                if (PopCompareActions(Action, PowerActionHibernate) >= 0) {

                    Updates |= PO_PM_REISSUE;
                }

                Updates |= PO_PM_USER | PO_PM_SETSTATE;
                PopAction.Action = Action;
            }

            if (Action == PowerActionHibernate) {

                Action = PowerActionSleep;
            }

            //
            // PopAction.Action may be explicitely set to PowerActionHibernate
            // by NtSetSystemPowerState during a wake.
            //
            if (PopAction.Action == PowerActionHibernate) {

                PopAction.Action = PowerActionSleep;
            }

            //
            // If the current action was updated, then get a worker
            //

            if (Updates) {

                Pending = TRUE;
                if (PopAction.State == PO_ACT_IDLE  ||  PopAction.State == PO_ACT_NEW_REQUEST) {

                    //
                    // New request
                    //

                    PopAction.State = PO_ACT_NEW_REQUEST;
                    PopAction.Status = STATUS_SUCCESS;
                    PopGetPolicyWorker (PO_WORKER_ACTION_NORMAL);

                } else {

                    //
                    // Something outstanding.  Promote it.
                    //

                    PopAction.Updates |= Updates;
                    PopGetPolicyWorker (PO_WORKER_ACTION_PROMOTE);
                }
            }
        }
    }


    //
    // If user events haven't been handled, do it now
    //

    if (!(Trigger->Flags & PO_TRG_USER)) {
        Trigger->Flags |= PO_TRG_USER;

        //
        // If there's an eventcode for the action, dispatch it
        //

        if (ActionPolicy->EventCode) {
            // if event code already queued, drop it
            for (i=0; i < POP_MAX_EVENT_CODES; i++) {
                if (PopEventCode[i] == ActionPolicy->EventCode) {
                    break;
                }
            }

            if (i >= POP_MAX_EVENT_CODES) {
                // not queued, add it
                for (i=0; i < POP_MAX_EVENT_CODES; i++) {
                    if (!PopEventCode[i]) {
                        PopEventCode[i] = ActionPolicy->EventCode;
                        UserNotify |= PO_NOTIFY_EVENT_CODES;
                        break;
                    }
                }

                if (i >= POP_MAX_EVENT_CODES) {
                    PoPrint (PO_WARN, ("PopAction: dropped user event %x\n", ActionPolicy->EventCode));
                }
            }
        }

        PopSetNotificationWork (UserNotify);
    }

    //
    // If sync request, queue it or complete it
    //

    if (Trigger->Flags & PO_TRG_SYNC) {
        if (Pending) {
            InsertTailList (&PopActionWaiters, &Trigger->Wait->Link);
        } else {
            PopCompleteAction (Trigger, STATUS_SUCCESS);
        }
    }
}

LONG
PopCompareActions(
    IN POWER_ACTION     FutureAction,
    IN POWER_ACTION     CurrentAction
    )
/*++

Routine Description:

    Used to determine whether the current action should be promoted to the
    future action or not.

    N.B. PopPolicyLock must be held.

Arguments:

    FutureAction    - Action which we are now being asked to do.

    CurrentAction   - Action which we are currently doing.

Return Value:

    Zero if the current and future actions are identical.

    Positive if the future action should be used.

    Negative if the current action is already more important than the future
    request.

--*/
{
    //
    // We could just return (FutureAction - CurrentAction) if it weren't for
    // PowerActionWarmEject, which is less important than sleeping (because
    // sleeping may be induced by critically low power). So we "insert"
    // PowerActionWarmEject right before PowerActionSleep.
    //
    if (FutureAction == PowerActionWarmEject) {

        FutureAction = PowerActionSleep;

    } else if (FutureAction >= PowerActionSleep) {

        FutureAction++;
    }

    if (CurrentAction == PowerActionWarmEject) {

        CurrentAction = PowerActionSleep;

    } else if (CurrentAction >= PowerActionSleep) {

        CurrentAction++;
    }

    return (FutureAction - CurrentAction);
}

VOID
PopPromoteActionFlag (
    OUT PUCHAR      Updates,
    IN ULONG        UpdateFlag,
    IN ULONG        Flags,
    IN BOOLEAN      Set,
    IN ULONG        FlagBit
    )
/*++

Routine Description:

    Used to merge existing action flags with new action flags.
    The FlagBit bit in PopAction.Flags is promoted to  set/clear
    according UpdateFlag.  If a change occured Updates is
    updated.

    N.B. PopPolicyLock must be held.

Arguments:

    Updates         - Current outstanding updates to the power action
                      which is in progress

    UpdateFlag      - Bit(s) to set into Updates if a change is made

    Flags           - Flags to test for FlagBit

    Set             - To test either set or clear

    FlagBit         - The bit to check in Flags

Return Value:

    None.

--*/
{
    ULONG   New, Current;
    ULONG   Mask;

    Mask = Set ? 0 : FlagBit;
    New = (Flags & FlagBit) ^ Mask;
    Current = (PopAction.Flags & FlagBit) ^ Mask;

    //
    // If the bit is not set accordingly in Flags but is set accordingly in
    // PoAction.Flags then update it
    //

    if (New & ~Current) {
        PopAction.Flags = (PopAction.Flags | New) & ~Mask;
        *Updates |= (UCHAR) UpdateFlag;
    }
}


ULONG
PopPolicyWorkerAction (
    VOID
    )
/*++

Routine Description:

    Dispatch function for: worker_action_normal.   This worker
    thread checks for an initial pending action and synchronously
    issued it to USER.  The thread is returned after the USER
    has completed the action.  (e.g., apps have been notified if
    allowed, etc..)

Arguments:

    None.

Return Value:

    None.

--*/
{
    POWER_ACTION            Action;
    SYSTEM_POWER_STATE      LightestState;
    ULONG                   Flags;
    NTSTATUS                Status;
    PLIST_ENTRY             Link;
    PPOP_TRIGGER_WAIT       SyncRequest;


    PopAcquirePolicyLock ();

    if (PopAction.State == PO_ACT_NEW_REQUEST) {
        //
        // We'll handle this update
        //

        Action        = PopAction.Action;
        LightestState = PopAction.LightestState;
        Flags         = PopAction.Flags;

        PopAction.State = PO_ACT_CALLOUT;

        //
        // Perform callout
        //

        Status = PopIssueActionRequest (FALSE, Action, LightestState, Flags);

        //
        // Clear switch triggers
        //

        PopResetSwitchTriggers ();

        //
        // If the system was sleeping
        //

        if (!NT_SUCCESS(Status)) {

            PoPrint (PO_WARN | PO_PACT,
                     ("PopPolicyWorkerAction: action request %d failed %08lx\n", Action, Status));

        }

        if (PopAction.Updates & PO_PM_REISSUE) {

            //
            // There's a new outstanding request.  Claim it.
            //

            PopAction.Updates &= ~PO_PM_REISSUE;
            PopAction.State = PO_ACT_NEW_REQUEST;
            PopGetPolicyWorker (PO_WORKER_ACTION_NORMAL);

        } else {

            //
            // All power actions are complete.
            //
            if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
                PERFINFO_SET_POWER_ACTION_RET LogEntry;

                LogEntry.Trigger = (PVOID)(ULONG_PTR)Action;
                LogEntry.Status = Status;

                PerfInfoLogBytes(PERFINFO_LOG_TYPE_SET_POWER_ACTION_RET,
                                 &LogEntry,
                                 sizeof(LogEntry));
            }

            PopAction.Status = Status;
            PopAction.State = PO_ACT_IDLE;


            if (IsListEmpty(&PopActionWaiters)) {

                //
                // If there was an error and no one is waiting for it, issue a notify
                //

                if (!NT_SUCCESS(Status)) {
                    PopSetNotificationWork (PO_NOTIFY_STATE_FAILURE);
                }

            } else {

                //
                // Free any synchronous waiters
                //

                for (Link = PopActionWaiters.Flink; Link != &PopActionWaiters; Link = Link->Flink) {
                    SyncRequest = CONTAINING_RECORD (Link, POP_TRIGGER_WAIT, Link);
                    PopCompleteAction (SyncRequest->Trigger, Status);
                }
            }

            //
            // Let promotion worker check for anything else
            //

            PopGetPolicyWorker (PO_WORKER_ACTION_PROMOTE);

        }
    }

    PopReleasePolicyLock (FALSE);
    return 0;
}

VOID
PopCompleteAction (
    PPOP_ACTION_TRIGGER     Trigger,
    NTSTATUS                Status
    )
{
    PPOP_TRIGGER_WAIT       SyncRequest;

    if (Trigger->Flags & PO_TRG_SYNC) {
        Trigger->Flags &= ~PO_TRG_SYNC;

        SyncRequest = Trigger->Wait;
        SyncRequest->Status = Status;
        KeSetEvent (&SyncRequest->Event, 0, FALSE);
    }
}


ULONG
PopPolicyWorkerActionPromote (
    VOID
    )
/*++

Routine Description:

    Dispatch function for: worker_action_promote.   This worker
    thread checks for a pending promotion needed for a power
    action request in USER and calls USER with the promotion.
    This function, PopPolicyWorkerAction, and NtSetSystemPowerState
    corridinate to handle ordering issues of when each function
    is called.

    N.B. Part of the cleanup from PopPolicyWorkerAction is to invoke
    this function.  So this worker function may have 2 threads
    at any one time.  (But in this case, the normal action worker
    thread would only find a promotion turning into to a new
    request and then exit back to a normal action worker)

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG                   Updates;
    NTSTATUS                Status;

    PopAcquirePolicyLock ();

    if (PopAction.Updates) {

        //
        // Get update info
        //

        Updates  = PopAction.Updates;

        //
        // Handle based on state of original request worker
        //

        switch (PopAction.State) {
            case PO_ACT_IDLE:

                //
                // Normal worker is no longer in progress, this is no
                // longer a promotion. If the updates have PO_PM_REISSUE
                // then turn this into a new request, else the promotion can
                // be skipped as the original operation completion
                // was good enough
                //

                if (Updates & PO_PM_REISSUE) {
                    PopAction.State = PO_ACT_NEW_REQUEST;
                    PopGetPolicyWorker (PO_WORKER_ACTION_NORMAL);
                } else {
                    Updates = 0;
                }

                break;

            case PO_ACT_SET_SYSTEM_STATE:

                //
                // If reissue or setstate is set, abort the current operation.
                //

                if (Updates & (PO_PM_REISSUE | PO_PM_SETSTATE)) {
                    PopRestartSetSystemState ();
                }
                break;

            case PO_ACT_CALLOUT:

                //
                // Worker is in the callout.  Call again to issue the promotion
                //

                Status = PopIssueActionRequest (
                                TRUE,
                                PopAction.Action,
                                PopAction.LightestState,
                                PopAction.Flags
                                );

                if (NT_SUCCESS(Status)) {
                    //
                    // Promotion worked, clear the updates we performed
                    //

                    PopAction.Updates &= ~Updates;

                } else {
                    //
                    // If the state has changed, test again else do nothing
                    // (the original worker thread will recheck on exit)
                    //

                    if (PopAction.State != PO_ACT_CALLOUT) {
                        PopGetPolicyWorker (PO_WORKER_ACTION_PROMOTE);
                    }
                }
                break;

            default:
                PoPrint (PO_ERROR, ("PopAction: invalid state %d\n", PopAction.State));
        }
    }

    PopReleasePolicyLock (FALSE);
    return 0;
}

NTSTATUS
PopIssueActionRequest (
    IN BOOLEAN              Promote,
    IN POWER_ACTION         Action,
    IN SYSTEM_POWER_STATE   LightestState,
    IN ULONG                Flags
    )
/*++

Routine Description:

    This function is used by the normal action worker or the promtion worker
    when its time to call USER or NtSetSystemPowerState with a new request.

Arguments:

    Promote          - Indicates flag for USER call

    Action           - The action to take

    LightestState    - The minimum power state to enter

    Flags            - Flags for the action to take.  E.g., how it should be processed


Return Value:

    Status as returned from USER or NtSetSystemPowerState

--*/
{
    BOOLEAN         DirectCall;
    NTSTATUS        Status;
    ULONG           Console;


    //
    // If there's no vector to call, then its a direct call
    //

    DirectCall = PopStateCallout ? FALSE : TRUE;

    //
    // If the critical flag is set and it's a ShutdownReset or ShutdownOff,
    // then it's done via a direct call.
    //

    if ((Flags & POWER_ACTION_CRITICAL) &&
        (Action == PowerActionShutdownReset ||
         Action == PowerActionShutdown      ||
         Action == PowerActionShutdownOff)) {

        DirectCall = TRUE;
    }

    //
    // If this is a direct call, then drop any reissue flag
    //

    if (DirectCall) {
        PopAction.Updates &= ~PO_PM_REISSUE;
    }

    //
    // If the policy has lock console set, make sure it's set in
    // the flags as well
    //

    if (PopPolicy->WinLogonFlags & WINLOGON_LOCK_ON_SLEEP) {
        Flags |= POWER_ACTION_LOCK_CONSOLE;
    }

    //
    // Debug
    //

    PoPrint (PO_PACT, ("PowerAction: %s%s, Min=%s, Flags %x\n",
                        Promote ? "Promote, " : "",
                        PopPowerActionString(Action),
                        PopSystemStateString(LightestState),
                        Flags
                        ));

    if (DirectCall) {
        PoPrint (PO_PACT, ("PowerAction: Setting with direct call\n"));
    }

    //
    // Drop lock while performing callout to dispatch request
    //

    PopReleasePolicyLock (FALSE);
    if (DirectCall) {
        Status = ZwSetSystemPowerState (Action, LightestState, Flags);
    } else {

        WIN32_POWERSTATE_PARAMETERS Parms;
        Parms.Promotion = Promote;
        Parms.SystemAction = Action;
        Parms.MinSystemState = LightestState;
        Parms.Flags = Flags;
        Parms.fQueryDenied = FALSE;

        
        if (!Promote) {
            
            //
            // we want to deliver some messages to only the console session.
            // lets find out active console session here, and ask that active console win2k 
            // to block the  console switch while we are in power switch
            //

            LARGE_INTEGER ShortSleep;
            ShortSleep.QuadPart = -10 * 1000 * 10; // 10 milliseconds

            Status = STATUS_UNSUCCESSFUL;
            do {

                Console = SharedUserData->ActiveConsoleId;

                if (Console != -1) {

                    //
                    // lets ask this console session, not to switch console,
                    // untill we are done with power callouts.
                    //
                    Parms.PowerStateTask = PowerState_BlockSessionSwitch;
                    Status = PopDispatchStateCallout(&Parms, &Console);

                    if (Status == STATUS_CTX_NOT_CONSOLE) {

                        //
                        // we failed to block status switch
                        // loop again
                        Console = (ULONG) -1;
                    }

                }

                if (Console == -1) {
                    //
                    // we are in session switch, wait till we get a valid active console session
                    //
                    KeDelayExecutionThread(KernelMode, FALSE, &ShortSleep);
                }

            } while (Console == -1);

            ASSERT(NT_SUCCESS(Status));
        }


        Parms.PowerStateTask = PowerState_Init;
        Status = PopDispatchStateCallout(&Parms, NULL);

        if (!Promote && NT_SUCCESS(Status)) {

            Parms.PowerStateTask = PowerState_QueryApps;
            Status = PopDispatchStateCallout(&Parms, NULL);

            if (!NT_SUCCESS(Status) || Parms.fQueryDenied) {

                //
                // ISSUE-2000/11/28-jamesca:
                //
                // Win32k depends on PowerState_QueryFailed to unset the
                // fInProgress bit, set during PowerState_Init.  Ideally, some
                // other operation should be used to do that, without having to
                // issue a PowerState_QueryFailed cancel message to sessions
                // (and apps) that never received PowerState_QueryApps query.
                //
                Parms.PowerStateTask = PowerState_QueryFailed;
                PopDispatchStateCallout(&Parms, NULL);

            } else {

                Parms.PowerStateTask = PowerState_SuspendApps;
                PopDispatchStateCallout(&Parms, NULL);

                Parms.PowerStateTask = PowerState_ShowUI;
                PopDispatchStateCallout(&Parms, NULL);

                Parms.PowerStateTask = PowerState_NotifyWL;
                Status = PopDispatchStateCallout(&Parms, &Console);
                
                if( !NT_SUCCESS(Status) ) {
                    //
                    // Someone failed the request.  We should notify win32k.sys
                    // and let him notify the world that we aren't really
                    // going down.
                    //
                    // Note that some services may not really know what to
                    // do if we send down a QueryFailed message right now,
                    // so once we're done here, fall through and send down
                    // the ResumeApps message too.
                    //
                    Parms.PowerStateTask = PowerState_QueryFailed;
                    PopDispatchStateCallout(&Parms, NULL);
                }
                
                Parms.PowerStateTask = PowerState_ResumeApps;
                PopDispatchStateCallout(&Parms, NULL);

            }

        }

        if (!Promote) {
            
            //
            // we are done with power callouts, now its ok if active console session switches
            //
            Parms.PowerStateTask = PowerState_UnBlockSessionSwitch;
            PopDispatchStateCallout(&Parms, &Console);

        }

    }

    PopAcquirePolicyLock ();
    return Status;
}

VOID
PopResetActionDefaults(
    VOID
    )
/*++

Routine Description:

    This function is used to initialize the current PopAction to reflect
    the idle state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PopAction.Updates       = 0;
    PopAction.Shutdown      = FALSE;
    PopAction.Action        = PowerActionNone;
    PopAction.LightestState = PowerSystemUnspecified;
    PopAction.Status        = STATUS_SUCCESS;
    PopAction.IrpMinor      = 0;
    PopAction.SystemState   = PowerSystemUnspecified;

    //
    // When we promote a power action (say from idle), various flags must be
    // agreed upon by both actions to stay around. We must set those flags
    // here otherwise they can never be set after promoting (idle).
    //
    PopAction.Flags = (
       POWER_ACTION_QUERY_ALLOWED |
       POWER_ACTION_UI_ALLOWED |
       POWER_ACTION_LIGHTEST_FIRST
       );
}

VOID
PopActionRetrieveInitialState(
    IN OUT  PSYSTEM_POWER_STATE  LightestSystemState,
    OUT     PSYSTEM_POWER_STATE  DeepestSystemState,
    OUT     PSYSTEM_POWER_STATE  InitialSystemState,
    OUT     PBOOLEAN             QueryDevices
    )
/*++

Routine Description:

    This function is used to determine the lightest, deepest, and initial Sx
    states prior to putting the system to sleep, or turning it off. Power
    policies for sleep are also applied if the action is a sleep.

Arguments:

    LightestSystemState - Lightest sleep state. May be adjusted if the action
                          in progress is a shutdown.

    DeepestSystemState  - Deepest sleep state possible.

    InitialSystemState  - State to start with.

    QueryDevices        - TRUE if devices should be queries, FALSE if devices
                          shouldn't be queried.

Return Value:

    None.

--*/
{
    //
    // Check if the action is a shutdown.  If so, map it to the appropiate
    // system shutdown state
    //
    if ((PopAction.Action == PowerActionShutdown) ||
        (PopAction.Action == PowerActionShutdownReset) ||
        (PopAction.Action == PowerActionShutdownOff)) {

        //
        // This is a shutdown.  The lightest we can do is S5.
        //
        *LightestSystemState = PowerSystemShutdown;
        *DeepestSystemState  = PowerSystemShutdown;

    } else if (PopAction.Action == PowerActionWarmEject) {

        //
        // Warm Ejects have an implicit policy of either S1-S4 or S4-S4.
        // The caller passes in LightestSystemState to choose the lightest,
        // and the deepest is always a hibernate.
        //
        *DeepestSystemState = PowerSystemHibernate;
        PopVerifySystemPowerState (DeepestSystemState, SubstituteLightenSleep);

    } else {

        //
        // This a sleep request. Min is current set to the best the hardware
        // can do relative to our caller. We apply the minimum from the current
        // policy here. We also choose the maximum from either the policy or
        // the default for current latency setting. Note that all of these
        // values in PopPolicy have been verified at some point.
        //
        // Note that PopSetPowerAction fixes up PowerActionHibernate long before
        // we get here.
        //

        if (PopAttributes[POP_LOW_LATENCY_ATTRIBUTE].Count &&
            (PopPolicy->MaxSleep >= PopPolicy->ReducedLatencySleep)) {

            *DeepestSystemState = PopPolicy->ReducedLatencySleep;
        } else {

            *DeepestSystemState = PopPolicy->MaxSleep;
        }

        if (PopPolicy->MinSleep > *LightestSystemState) {

            *LightestSystemState = PopPolicy->MinSleep;
        }
    }

    //
    // If there's an explicit min state which is deeper than the
    // max state, then raise the max to allow it
    //

    if (*LightestSystemState > *DeepestSystemState) {
        *DeepestSystemState = *LightestSystemState;
    }

    //
    // We query devices unless this is a critical operation with no range.
    //

    *QueryDevices = TRUE;

    if ((PopAction.Flags & POWER_ACTION_CRITICAL) &&
        *LightestSystemState == *DeepestSystemState) {

        *QueryDevices = FALSE;
    }

    //
    // Pick the appropriate initial state.
    //
    if (PopAction.Flags & POWER_ACTION_LIGHTEST_FIRST) {

        *InitialSystemState = *LightestSystemState;

    } else {

        *InitialSystemState = *DeepestSystemState;
    }
}


NTSTATUS
PopDispatchStateCallout(
    IN PKWIN32_POWERSTATE_PARAMETERS Parms,
    IN PULONG SessionId  OPTIONAL
    )
/*++

Routine Description:

    Dispatches a session state callout to PopStateCallout

Arguments:

    Parms     - Supplies the parameters

    SessionId - Optionally, supplies the specific session the callout should be
                dispatched to.  If not present, the callout will be dispatched
                to all sessions.

Return Value:

    NTSTATUS code.

Note:

    For compatibility reasons, the previous behavior of MmDispatchSessionCallout
    only returning the status of the callout to session 0 has been maintained.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS, CallStatus = STATUS_NOT_FOUND;
    PVOID OpaqueSession;
    KAPC_STATE ApcState;

    if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
        PERFINFO_PO_SESSION_CALLOUT LogEntry;

        LogEntry.SystemAction = Parms->SystemAction;
        LogEntry.MinSystemState = Parms->MinSystemState;
        LogEntry.Flags = Parms->Flags;
        LogEntry.PowerStateTask = Parms->PowerStateTask;

        PerfInfoLogBytes(PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT,
                         &LogEntry,
                         sizeof(LogEntry));
    }

    if (ARGUMENT_PRESENT(SessionId)) {
        //
        // Dispatch only to the specified session.
        //

        ASSERT(*SessionId != (ULONG)-1);

        if ((PsGetCurrentProcess()->Flags & PS_PROCESS_FLAGS_IN_SESSION) &&
            (*SessionId == PsGetCurrentProcessSessionId())) {
            //
            // If the call is from a user mode process, and we are asked to call
            // the current session, call directly.
            //
            CallStatus = PopStateCallout((PVOID)Parms);

        } else {
            //
            // Attach to the specified session.
            //
            OpaqueSession = MmGetSessionById(*SessionId);
            if (OpaqueSession) {

                Status = MmAttachSession(OpaqueSession, &ApcState);
                ASSERT(NT_SUCCESS(Status));

                if (NT_SUCCESS(Status)) {
                    CallStatus = PopStateCallout((PVOID)Parms);
                    Status = MmDetachSession(OpaqueSession, &ApcState);
                    ASSERT(NT_SUCCESS(Status));
                }

                Status = MmQuitNextSession(OpaqueSession);
                ASSERT(NT_SUCCESS(Status));
            }
        }

    } else {
        //
        // Should be dispatched to all sessions.
        //
        for (OpaqueSession = MmGetNextSession(NULL);
             OpaqueSession != NULL;
             OpaqueSession = MmGetNextSession(OpaqueSession)) {

            if ((PsGetCurrentProcess()->Flags & PS_PROCESS_FLAGS_IN_SESSION) &&
                (MmGetSessionId(OpaqueSession) == PsGetCurrentProcessSessionId())) {
                //
                // If the call is from a user mode process, and we are asked to
                // call the current session, call directly.
                //
                if (MmGetSessionId(OpaqueSession) == 0) {
                    CallStatus = PopStateCallout((PVOID)Parms);
                } else {
                    PopStateCallout((PVOID)Parms);
                }

            } else {
                //
                // Attach to the specified session.
                //
                Status = MmAttachSession(OpaqueSession, &ApcState);
                ASSERT(NT_SUCCESS(Status));

                if (NT_SUCCESS(Status)) {
                    if (MmGetSessionId(OpaqueSession) == 0) {
                        CallStatus = PopStateCallout((PVOID)Parms);
                    } else {
                        PopStateCallout((PVOID)Parms);
                    }

                    Status = MmDetachSession(OpaqueSession, &ApcState);
                    ASSERT(NT_SUCCESS(Status));
                }
            }
        }
    }

    if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
        PERFINFO_PO_SESSION_CALLOUT_RET LogEntry;

        LogEntry.Status = CallStatus;

        PerfInfoLogBytes(PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT_RET,
                         &LogEntry,
                         sizeof(LogEntry));
    }

    return(CallStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\pocall.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pocall

Abstract:

    PoCallDriver and related routines.

Author:

    Bryan Willman (bryanwi) 14-Nov-1996

Revision History:

--*/

#include "pop.h"



PIRP
PopFindIrpByInrush(
    );


NTSTATUS
PopPresentIrp(
    PIO_STACK_LOCATION  IrpSp,
    PIRP                Irp,
    PVOID               ReturnAddress
    );

VOID
PopPassivePowerCall(
    PVOID   Parameter
    );

NTSTATUS
PopCompleteRequestIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

#if 0
#define PATHTEST(a) DbgPrint(a)
#else
#define PATHTEST(a)
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, PopSystemIrpDispatchWorker)
#endif


NTKERNELAPI
NTSTATUS
PoCallDriver (
    IN PDEVICE_OBJECT   DeviceObject,
    IN OUT PIRP         Irp
    )
/*++

Routine Description:

    This is the routine that must be used to send an
    IRP_MJ_POWER irp to device drivers.

    It performs specialized synchronization on power operations
    for device drivers.

    NOTE WELL:

        All callers to PoCallDriver MUST set the current io
        stack location parameter value SystemContext to 0,
        unless they are passing on an IRP to lower drivers,
        in which case they must copy the value from above.

Arguments:

    DeviceObject - the device object the irp is to be routed to

    Irp - pointer to the irp of interest

Return Value:

    Normal NTSTATUS data.

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpsp;
    PDEVOBJ_EXTENSION   doe;
    KIRQL               oldIrql;


    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(KeGetCurrentIrql()<=DISPATCH_LEVEL);
    PopLockIrpSerialList(&oldIrql);


    irpsp = IoGetNextIrpStackLocation(Irp);
    doe = DeviceObject->DeviceObjectExtension;
    irpsp->DeviceObject = DeviceObject;

    ASSERT(irpsp->MajorFunction == IRP_MJ_POWER);

    PoPowerTrace(POWERTRACE_CALL,DeviceObject,Irp,irpsp);
    if (DeviceObject->Flags & DO_POWER_NOOP) {
        PATHTEST("PoCallDriver #01\n");
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0L;

        // we *don't* need to call PoStartNextPowerIrp() because we'll
        // never enqueue anything for this DO, so there will never be
        // any other IRP to run.

        IoCompleteRequest(Irp, 0);
        PopUnlockIrpSerialList(oldIrql);
        return STATUS_SUCCESS;
    }

    if (irpsp->MinorFunction != IRP_MN_SET_POWER &&
        irpsp->MinorFunction != IRP_MN_QUERY_POWER) {

        PopUnlockIrpSerialList(oldIrql);

        return IofCallDriverSpecifyReturn (DeviceObject, Irp, _ReturnAddress());
    }

    //
    // We never query going up, so being inrush sensitive
    // only matters for SET_POWER to D0
    // If this is an inrush sensitive DevObj, and we're going TO PowerDeviceD0,
    // then serialize on the gobal Inrush flag.
    //
    if ((irpsp->MinorFunction == IRP_MN_SET_POWER) &&
        (irpsp->Parameters.Power.Type == DevicePowerState) &&
        (irpsp->Parameters.Power.State.DeviceState == PowerDeviceD0) &&
        (PopGetDoDevicePowerState(doe) != PowerDeviceD0) &&
        (DeviceObject->Flags & DO_POWER_INRUSH))
    {
        PATHTEST("PoCallDriver #02\n");

        if (PopInrushIrpPointer == Irp) {

            //
            // This irp has already been identified as an INRUSH irp,
            // and it is the active inrush irp,
            // so it can actually just continue on, after we increment
            // the ref count
            //
            PATHTEST("PoCallDriver #03\n");
            ASSERT((irpsp->Parameters.Power.SystemContext & POP_INRUSH_CONTEXT) == POP_INRUSH_CONTEXT);
            PopInrushIrpReferenceCount++;
            if (PopInrushIrpReferenceCount > 256) {

                PopInternalAddToDumpFile ( irpsp, sizeof(IO_STACK_LOCATION), DeviceObject, NULL, NULL, NULL );
                KeBugCheckEx(INTERNAL_POWER_ERROR, 0x400, 1, (ULONG_PTR)irpsp, (ULONG_PTR)DeviceObject);
            }

        } else if ((!PopInrushIrpPointer) && (!PopInrushPending)) {

            //
            // This is a freshly starting inrush IRP, AND there is not
            // already an inrush irp, so mark this as an inrush irp,
            // note that inrush is active, and continue
            //
            PATHTEST("PoCallDriver #04\n");
            PopInrushIrpPointer = Irp;
            PopInrushIrpReferenceCount = 1;
            irpsp->Parameters.Power.SystemContext = POP_INRUSH_CONTEXT;

            //
            // Inrush irps will cause us to free the processor throttling.
            //
            PopPerfHandleInrush ( TRUE );

        } else {

            PATHTEST("PoCallDriver #05\n");
            ASSERT(PopInrushIrpPointer || PopInrushPending);
            //
            // There is already an active Inrush irp, and this one isn't it.
            // OR there is an inrush irp blocked on the queue, in either case,
            // mark this as an inrush irp and enqueue it.
            //
            doe->PowerFlags |= POPF_DEVICE_PENDING;
            irpsp->Parameters.Power.SystemContext = POP_INRUSH_CONTEXT;
            InsertTailList(
                &PopIrpSerialList,
                &(Irp->Tail.Overlay.ListEntry)
                );
            PopIrpSerialListLength++;

            #if DBG
            if (PopIrpSerialListLength > 10) {
                DbgPrint("WARNING: PopIrpSerialListLength > 10!!!\n");
            }
            if (PopIrpSerialListLength > 100) {
                DbgPrint("WARNING: PopIrpSerialListLength > **100**!!!\n");
                PopInternalAddToDumpFile ( &PopIrpSerialList, PAGE_SIZE, DeviceObject, NULL, NULL, NULL );
                KeBugCheckEx(INTERNAL_POWER_ERROR, 0x401, 2, (ULONG_PTR)&PopIrpSerialList, (ULONG_PTR)DeviceObject);
            }
            #endif

            PopInrushPending = TRUE;
            PopUnlockIrpSerialList(oldIrql);
            return STATUS_PENDING;
        }
    }

    //
    // See if there is already a power irp active for this
    // device object.  If not, send this one on.  If so, enqueue
    // it to wait.
    //
    if (irpsp->Parameters.Power.Type == SystemPowerState) {

        PATHTEST("PoCallDriver #06\n");

        if (doe->PowerFlags & POPF_SYSTEM_ACTIVE) {

            //
            // we already have one active system power state irp for the devobj,
            // so enqueue this one on the global power irp holding list,
            // and set the pending bit.
            //
            PATHTEST("PoCallDriver #07\n");
            doe->PowerFlags |= POPF_SYSTEM_PENDING;
            InsertTailList(
                &PopIrpSerialList,
                (&(Irp->Tail.Overlay.ListEntry))
                );
            PopIrpSerialListLength++;

            #if DBG
            if (PopIrpSerialListLength > 10) {
                DbgPrint("WARNING: PopIrpSerialListLength > 10!!!\n");
            }
            if (PopIrpSerialListLength > 100) {
                DbgPrint("WARNING: PopIrpSerialListLength > **100**!!!\n");
                PopInternalAddToDumpFile ( &PopIrpSerialList, PAGE_SIZE, DeviceObject, NULL, NULL, NULL );
                KeBugCheckEx(INTERNAL_POWER_ERROR, 0x402, 3, (ULONG_PTR)&PopIrpSerialList, (ULONG_PTR)DeviceObject);
            }
            #endif

            PopUnlockIrpSerialList(oldIrql);
            return STATUS_PENDING;
        } else {
            PATHTEST("PoCallDriver #08\n");
            doe->PowerFlags |= POPF_SYSTEM_ACTIVE;
        }
    }

    if (irpsp->Parameters.Power.Type == DevicePowerState) {

        PATHTEST("PoCallDriver #09\n");

        if ((doe->PowerFlags & POPF_DEVICE_ACTIVE) ||
            (doe->PowerFlags & POPF_DEVICE_PENDING))
        {
            //
            // we already have one active device power state irp for the devobj,
            // OR we're behind an inrush irp (if pending but not active)
            // so enqueue this irp on the global power irp holdinglist,
            // and set the pending bit.
            //
            PATHTEST("PoCallDriver #10\n");
            doe->PowerFlags |= POPF_DEVICE_PENDING;
            InsertTailList(
                &PopIrpSerialList,
                &(Irp->Tail.Overlay.ListEntry)
                );
            PopIrpSerialListLength++;

            #if DBG
            if (PopIrpSerialListLength > 10) {
                DbgPrint("WARNING: PopIrpSerialListLength > 10!!!\n");
            }
            if (PopIrpSerialListLength > 100) {
                DbgPrint("WARNING: PopIrpSerialListLength > **100**!!!\n");
                PopInternalAddToDumpFile ( &PopIrpSerialList, PAGE_SIZE, DeviceObject, NULL, NULL, NULL );
                KeBugCheckEx(INTERNAL_POWER_ERROR, 0x403, 4, (ULONG_PTR)&PopIrpSerialList, (ULONG_PTR)DeviceObject);
            }
            #endif

            PopUnlockIrpSerialList(oldIrql);
            return STATUS_PENDING;
        } else {
            PATHTEST("PoCallDriver #11\n");
            doe->PowerFlags |= POPF_DEVICE_ACTIVE;
        }
    }

    //
    // If we get here it's time to send this IRP on to the driver.
    // If the driver is NOT marked INRUSH and it IS marked PAGABLE
    // (which is hopefully the normal case) we will arrange to call
    // it from PASSIVE_LEVEL.
    //
    // If it is NOT pagable or IS INRUSH, we will arrange to call
    // it from DPC level.
    //
    // Note that if a driver is marked INRUSH, it will ALWAYS be called
    // from DPC level with power irps, even though some of them may not
    // be inrush irps.
    //
    // having your driver be both PAGABLE and INRUSH is incorrect
    //


    ASSERT(irpsp->DeviceObject->DeviceObjectExtension->PowerFlags & (POPF_DEVICE_ACTIVE | POPF_SYSTEM_ACTIVE));
    PopUnlockIrpSerialList(oldIrql);
    status = PopPresentIrp(irpsp, Irp, _ReturnAddress());
    return status;
}


NTSTATUS
PopPresentIrp(
    PIO_STACK_LOCATION  IrpSp,
    PIRP                Irp,
    PVOID               ReturnAddress
    )
/*++

Routine Description:

    When PoCallDriver, PoCompleteRequest, etc, need to actually present
    an Irp to a devobj, they call PopPresentIrp.

    This routine will compute whether the Irp should be presented at
    PASSIVE or DISPATCH level, and make an appropriately structured call

Arguments:

    IrpSp - provides current stack location  in Irp of interest

    Irp - provides irp of interest

Return Value:

    Normal NTSTATUS data.

--*/
{
    NTSTATUS            status;
    PWORK_QUEUE_ITEM    pwi;
    PDEVICE_OBJECT      devobj;
    BOOLEAN             PassiveLevel;
    KIRQL               OldIrql;

    PATHTEST("PopPresentIrp #01\n");
    devobj = IrpSp->DeviceObject;

    ASSERT (IrpSp->MajorFunction == IRP_MJ_POWER);
    PassiveLevel = TRUE;
    if (IrpSp->MinorFunction == IRP_MN_SET_POWER &&
        (!(devobj->Flags & DO_POWER_PAGABLE) || (devobj->Flags & DO_POWER_INRUSH)) ) {

        if ((PopCallSystemState & PO_CALL_NON_PAGED) ||
            ( (IrpSp->Parameters.Power.Type == DevicePowerState &&
               IrpSp->Parameters.Power.State.DeviceState == PowerDeviceD0) ||
              (IrpSp->Parameters.Power.Type == SystemPowerState &&
               IrpSp->Parameters.Power.State.SystemState == PowerSystemWorking)) ) {

            PassiveLevel = FALSE;
        }
    }

    PoPowerTrace(POWERTRACE_PRESENT,devobj,Irp,IrpSp);
    if (PassiveLevel)
    {
        //
        // WARNING: A WORK_QUEUE_ITEM must fit in the DriverContext field of an IRP
        //
        ASSERT(sizeof(WORK_QUEUE_ITEM) <= sizeof(Irp->Tail.Overlay.DriverContext));

        #if DBG
        if ((IrpSp->Parameters.Power.SystemContext & POP_INRUSH_CONTEXT) == POP_INRUSH_CONTEXT) {
            //
            // we are sending an inrush irp off to a passive dispatch devobj
            // this is *probably* a bug
            //
            KdPrint(("PopPresentIrp: inrush irp to passive level dispatch!!!\n"));
            PopInternalAddToDumpFile ( IrpSp, sizeof(IO_STACK_LOCATION), devobj, NULL, NULL, NULL );
            KeBugCheckEx(INTERNAL_POWER_ERROR, 0x404, 5, (ULONG_PTR)IrpSp, (ULONG_PTR)devobj);
        }
        #endif

        PATHTEST("PopPresentIrp #02\n");

        //
        // If we're already at passive level, just dispatch the irp
        //

        if (KeGetCurrentIrql() == PASSIVE_LEVEL) {

            status = IofCallDriverSpecifyReturn(IrpSp->DeviceObject, Irp, ReturnAddress);

        } else {

            //
            // Irp needs to be queued to some worker thread before
            // it can be dispatched. Mark it pending
            //

            IrpSp->Control |= SL_PENDING_RETURNED;
            status = STATUS_PENDING;

            PopLockWorkerQueue(&OldIrql);

            if (PopCallSystemState & PO_CALL_SYSDEV_QUEUE) {

                //
                // Queue to dedicated system power worker thread
                //

                InsertTailList (&PopAction.DevState->PresentIrpQueue, &(Irp->Tail.Overlay.ListEntry));
                KeSetEvent (&PopAction.DevState->Event, IO_NO_INCREMENT, FALSE);

            } else {

                //
                // Queue to generic system worker thread
                //

                pwi = (PWORK_QUEUE_ITEM)(&(Irp->Tail.Overlay.DriverContext[0]));
                ExInitializeWorkItem(pwi, PopPassivePowerCall, Irp);
                ExQueueWorkItem(pwi, DelayedWorkQueue);
            }

            PopUnlockWorkerQueue(OldIrql);
        }

    } else {
        //
        // Non-blocking request.  To ensure proper behaviour, dispatch
        // the irp from dispatch_level
        //
            PATHTEST("PopPresentIrp #03\n");
#if DBG
        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
        status = IofCallDriverSpecifyReturn(IrpSp->DeviceObject, Irp, ReturnAddress);
        KeLowerIrql(OldIrql);
#else
        status = IofCallDriverSpecifyReturn(IrpSp->DeviceObject, Irp, ReturnAddress);
#endif
    }

    return status;
}


VOID
PopPassivePowerCall(
    PVOID   Parameter
    )
{
    PIO_STACK_LOCATION irpsp;
    PIRP               Irp;
    PDEVICE_OBJECT      devobj;
    NTSTATUS            status;

    //
    // Parameter points to Irp we are to send to driver
    //
    PATHTEST("PopPassivePowerCall #01\n");
    Irp = (PIRP)Parameter;
    irpsp = IoGetNextIrpStackLocation(Irp);
    devobj = irpsp->DeviceObject;
    status = IofCallDriverSpecifyReturn(devobj, Irp, NULL);
    return;
}


NTKERNELAPI
VOID
PoStartNextPowerIrp(
    IN PIRP             Irp
    )
/*++

Routine Description:

    This procedure must be applied to every power irp, and only
    power irps, when a driver is finished with them.

    It will force post-irp completion items relevent to the irp
    to execute:

    a.  If the irp is an inrush irp, and this is the top of the
        inrush irp stack, then this particular inrush irp is done,
        and we go find the next inrush irp (if any) and dispatch it.

    b.  If step a. did NOT send an irp to the dev obj we came
        from, it is eligible for step c, otherwise it is not.

    c.  If anything is pending on the dev obj, of the type that
        just completed, find the waiting irp and post it to the
        driver.

    This routine will NOT complete the Irp, the driver must do that.

Arguments:

    Irp - pointer to the irp of interest

Return Value:

    VOID.

--*/
{
    PIO_STACK_LOCATION  irpsp;
    PIO_STACK_LOCATION  nextsp = NULL;
    PIO_STACK_LOCATION  secondsp = NULL;
    PDEVICE_OBJECT      deviceObject;
    PDEVOBJ_EXTENSION   doe;
    KIRQL               oldirql;
    PIRP                nextirp;
    PIRP                secondirp;
    PIRP                hangirp;

    ASSERT( Irp );

    irpsp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpsp->MajorFunction == IRP_MJ_POWER);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    deviceObject = irpsp->DeviceObject;
    doe = deviceObject->DeviceObjectExtension;
    nextirp = NULL;
    secondirp = NULL;

    PoPowerTrace(POWERTRACE_STARTNEXT,deviceObject,Irp,irpsp);

//
//  a. if (partially completed inrush irp)
//      run any pending non-inrush irps on this DeviceObject, would be queued up
//      as DevicePowerState irps since inrush is always DevicePowerState
//
//  b. else if (fully complete inrush irp)
//      clear the ir busy flag
//      find next inrush irp that applies to any DeviceObject
//          find any irps in queue for same DeviceObject ahead of inrush irp
//              if no leader, and target DeviceObject not DEVICE_ACTIVE, present inrush irp
//              else an active normal irp will unplug it all, so ignore that DeviceObject
//              [this makes sure next inrush is unstuck, wherever it is]
//      if no irp was presented, or an irp was presented to a DeviceObject other than us
//          look for next pending (non-inrush) irp to run on this DeviceObject
//          [this makes sure this DeviceObject is unstuck]
//
//  c. else [normal irp has just completed]
//      find next irp of same type that applies to this DeviceObject
//      if (it's an inrush irp) && (inrush flag is set)
//          don't try to present anything
//      else
//          present the irp
//


    PATHTEST("PoStartNextPowerIrp #01\n");
    PopLockIrpSerialList(&oldirql);

    if (PopInrushIrpPointer == Irp) {

        ASSERT((irpsp->Parameters.Power.SystemContext & POP_INRUSH_CONTEXT) == POP_INRUSH_CONTEXT);
        PATHTEST("PoStartNextPowerIrp #02\n");

        if (PopInrushIrpReferenceCount > 1) {
            //
            // case a.
            // we have an inrush irp, and it has NOT completed all of its power
            // management work.  therefore, do NOT try to run the next inrush
            // irp, but do try to run any non-inrush irp pending on this
            // device object
            //
            PATHTEST("PoStartNextPowerIrp #03\n");
            PopInrushIrpReferenceCount--;
            ASSERT(PopInrushIrpReferenceCount >= 0);

            nextirp = PopFindIrpByDeviceObject(deviceObject, DevicePowerState);
            if (nextirp) {
                PATHTEST("PoStartNextPowerIrp #04\n");
                nextsp = IoGetNextIrpStackLocation(nextirp);

                if ( ! ((nextsp->Parameters.Power.SystemContext & POP_INRUSH_CONTEXT) == POP_INRUSH_CONTEXT)) {
                    PATHTEST("PoStartNextPowerIrp #05\n");
                    RemoveEntryList((&(nextirp->Tail.Overlay.ListEntry)));
                    PopIrpSerialListLength--;
                } else {
                    PATHTEST("PoStartNextPowerIrp #06\n");
                    nextirp = NULL;
                }
            }

            if (!nextirp) {
                //
                // there's no more device irp waiting for this do, so
                // we can clear DO pending and active
                // but what if there's another inrush irp! no worries, it
                // will be run when the one we just partially finished completes.
                //
                PATHTEST("PoStartNextPowerIrp #07\n");
                doe->PowerFlags = doe->PowerFlags & ~POPF_DEVICE_ACTIVE;
                doe->PowerFlags = doe->PowerFlags & ~POPF_DEVICE_PENDING;
            }

            PopUnlockIrpSerialList(oldirql);

            if (nextirp) {
                PATHTEST("PoStartNextPowerIrp #08\n");
                ASSERT(nextsp->DeviceObject->DeviceObjectExtension->PowerFlags & POPF_DEVICE_ACTIVE);
                PopPresentIrp(nextsp, nextirp, NULL);
            }

            return;         // end of case a.
        } else {
            //
            // case b.
            // we've just completed the last work item of an inrush irp, so we
            // want to try to make the next inrush irp runnable.
            //
            PATHTEST("PoStartNextPowerIrp #09\n");
            PopInrushIrpReferenceCount--;
            ASSERT(PopInrushIrpReferenceCount == 0);
            nextirp = PopFindIrpByInrush();

            if (nextirp) {
                PATHTEST("PoStartNextPowerIrp #10\n");
                ASSERT(PopInrushPending);
                nextsp = IoGetNextIrpStackLocation(nextirp);
                hangirp = PopFindIrpByDeviceObject(nextsp->DeviceObject, DevicePowerState);

                if (hangirp) {
                    //
                    // if we get where, there is a non inrush irp in front of the next inrush
                    // irp, so try to run the non-inrush one, and set flags for later
                    //
                    PATHTEST("PoStartNextPowerIrp #11\n");
                    nextirp = hangirp;
                    PopInrushIrpPointer = NULL;
                    PopInrushIrpReferenceCount = 0;
                    nextsp = IoGetNextIrpStackLocation(nextirp);

                    //
                    // Can allow processor voltages to swing again
                    //
                    PopPerfHandleInrush ( FALSE );

                    if (!(nextsp->DeviceObject->DeviceObjectExtension->PowerFlags & POPF_DEVICE_ACTIVE)) {
                        PATHTEST("PoStartNextPowerIrp #12\n");
                        RemoveEntryList((&(nextirp->Tail.Overlay.ListEntry)));
                        nextsp->DeviceObject->DeviceObjectExtension->PowerFlags |= POPF_DEVICE_ACTIVE;
                        PopIrpSerialListLength--;
                    } else {
                        PATHTEST("PoStartNextPowerIrp #13\n");
                        nextirp = NULL;
                        nextsp = NULL;
                    }
                } else {
                    //
                    // we did find another inrush irp, and it's NOT block by a normal
                    // irp, so we will run it.
                    //
                    PATHTEST("PoStartNextPowerIrp #14\n");
                    RemoveEntryList((&(nextirp->Tail.Overlay.ListEntry)));
                    nextsp->DeviceObject->DeviceObjectExtension->PowerFlags |= POPF_DEVICE_ACTIVE;
                    PopIrpSerialListLength--;
                    PopInrushIrpPointer = nextirp;
                    PopInrushIrpReferenceCount = 1;
                }
            } else { // nextirp
                //
                // this inrush irp is done, and we didn't find any others
                //
                PATHTEST("PoStartNextPowerIrp #15\n");
                nextsp = NULL;
                PopInrushIrpPointer = NULL;
                PopInrushIrpReferenceCount = 0;

                //
                // Can allow processor voltages to swing again
                //
                PopPerfHandleInrush ( FALSE );

            }

            //
            // see if *either* of the above possible irps is posted against
            // this devobj.  if not, see if there's one to run here
            //
            if ( ! ((nextsp) && (nextsp->DeviceObject == deviceObject))) {
                //
                // same is if nextsp == null or nextsp->do != do..
                // either case, there may be one more irp to run
                //
                PATHTEST("PoStartNextPowerIrp #16\n");
                secondirp = PopFindIrpByDeviceObject(deviceObject, DevicePowerState);
                if (secondirp) {
                    PATHTEST("PoStartNextPowerIrp #17\n");
                    secondsp =  IoGetNextIrpStackLocation(secondirp);
                    RemoveEntryList((&(secondirp->Tail.Overlay.ListEntry)));
                    secondsp->DeviceObject->DeviceObjectExtension->PowerFlags |= POPF_DEVICE_ACTIVE;
                    PopIrpSerialListLength--;
                } else {
                    PATHTEST("PoStartNextPowerIrp #18\n");
                    secondsp = NULL;

                    //
                    // nextsp/nextirp are not pending against us AND
                    // secondsp/secondirp are not pending against us, SO
                    // clear both pending and active flags
                    //
                    doe->PowerFlags = doe->PowerFlags & ~POPF_DEVICE_ACTIVE;
                    doe->PowerFlags = doe->PowerFlags & ~POPF_DEVICE_PENDING;
                }

            } else {
                PATHTEST("PoStartNextPowerIrp #19\n");
                secondirp = NULL;
                secondsp = NULL;
                //
                // nextsp/nextirp is coming right at us, so pending/active stay set
                //
            }
        } // end of case b.

    } else if (irpsp->MinorFunction == IRP_MN_SET_POWER ||
               irpsp->MinorFunction == IRP_MN_QUERY_POWER) {

        //
        // case c.
        //
        // might be pending inrush to run, might be just non-inrush to run
        //
        if (irpsp->Parameters.Power.Type == DevicePowerState) {
            PATHTEST("PoStartNextPowerIrp #20\n");

            if ((PopInrushIrpPointer == NULL) && (PopInrushPending)) {
                //
                // it may be that the completion of the ordinary irp
                // that brought us here has made some inrush irp runnable, AND
                // there isn't currently an active inrush irp, and there might be one pending
                // so try to find and run the next inrush irp
                //
                PATHTEST("PoStartNextPowerIrp #21\n");
                nextirp = PopFindIrpByInrush();

                if (nextirp) {
                    PATHTEST("PoStartNextPowerIrp #22\n");
                    nextsp =  IoGetNextIrpStackLocation(nextirp);

                    if (!(nextsp->DeviceObject->DeviceObjectExtension->PowerFlags & POPF_DEVICE_ACTIVE)) {
                        //
                        // we've found an inrush irp, and it's runnable...
                        //
                        PATHTEST("PoStartNextPowerIrp #23\n");
                        RemoveEntryList((&(nextirp->Tail.Overlay.ListEntry)));
                        PopIrpSerialListLength--;
                        nextsp->DeviceObject->DeviceObjectExtension->PowerFlags |= POPF_DEVICE_ACTIVE;
                        PopInrushIrpPointer = nextirp;
                        PopInrushIrpReferenceCount = 1;

                        //
                        // Running Inrush irp. Disable processor throttling.
                        //
                        PopPerfHandleInrush ( TRUE );

                    } else {
                        PATHTEST("PoStartNextPowerIrp #24\n");
                        nextirp = NULL;
                        nextsp = NULL;
                    }
                } else {
                    //
                    // no more inrush irps in queue
                    //
                    PATHTEST("PoStartNextPowerIrp #25\n");
                    nextsp = NULL;
                    PopInrushPending = FALSE;
                }
            } else { // end of inrush
                PATHTEST("PoStartNextPowerIrp #26\n");
                nextirp = NULL;
                nextsp = NULL;
            }

            //
            // look for for next devicepowerstate irp for this DeviceObject
            // unless we're already found an inrush irp, and it's for us
            //
            if  ( ! ((nextirp) && (nextsp->DeviceObject == deviceObject))) {
                PATHTEST("PoStartNextPowerIrp #27\n");
                secondirp = PopFindIrpByDeviceObject(deviceObject, DevicePowerState);

                if (!secondirp) {
                    PATHTEST("PoStartNextPowerIrp #28\n");
                    doe->PowerFlags = doe->PowerFlags & ~POPF_DEVICE_ACTIVE;
                    doe->PowerFlags = doe->PowerFlags & ~POPF_DEVICE_PENDING;
                }
            } else {
                PATHTEST("PoStartNextPowerIrp #29\n");
                secondirp = NULL;
            }


        } else if (irpsp->Parameters.Power.Type == SystemPowerState) {

            //
            // look for next systempowerstate irp for this DeviceObject
            //
            PATHTEST("PoStartNextPowerIrp #30\n");
            nextirp = NULL;
            nextsp = NULL;
            secondirp = PopFindIrpByDeviceObject(deviceObject, SystemPowerState);
            if (!secondirp) {
                PATHTEST("PoStartNextPowerIrp #31\n");
                doe->PowerFlags = doe->PowerFlags & ~POPF_SYSTEM_ACTIVE;
                doe->PowerFlags = doe->PowerFlags & ~POPF_SYSTEM_PENDING;
            }
        }

        if (secondirp) {
            PATHTEST("PoStartNextPowerIrp #33\n");
            secondsp =  IoGetNextIrpStackLocation(secondirp);
            RemoveEntryList((&(secondirp->Tail.Overlay.ListEntry)));
            PopIrpSerialListLength--;
        }

    } else {  // end of case c.
        PoPrint(PO_POCALL, ("PoStartNextPowerIrp: Irp @ %08x, minor function %d\n",
                    Irp, irpsp->MinorFunction
                    ));
    }


    PopUnlockIrpSerialList(oldirql);

    //
    // case b. and case c. might both make two pending irps runnable,
    // could be a normal irp and an inrush irp, or only 1 of the two, or neither of the two
    //
    if (nextirp || secondirp) {

        if (nextirp) {
            PATHTEST("PoStartNextPowerIrp #34\n");
            ASSERT(nextsp->DeviceObject->DeviceObjectExtension->PowerFlags & (POPF_DEVICE_ACTIVE | POPF_SYSTEM_ACTIVE));
            PopPresentIrp(nextsp, nextirp, NULL);
        }

        if (secondirp) {
            PATHTEST("PoStartNextPowerIrp #35\n");
            ASSERT(secondsp->DeviceObject->DeviceObjectExtension->PowerFlags & (POPF_DEVICE_ACTIVE | POPF_SYSTEM_ACTIVE));
            PopPresentIrp(secondsp, secondirp, NULL);
        }
    }
    return;
}


PIRP
PopFindIrpByInrush(
    )
/*++

Routine Description:

    This procedure runs the irp serial list (which contains all
    waiting irps, be they queued up on a single device object or
    multiple inrush irps) looking for the first inrush irp.
    If one is found, it's address is returned, with it still enqueued
    in the list.

    Caller must be holding PopIrpSerialList lock.

Arguments:

Return Value:

--*/
{
    PLIST_ENTRY         item;
    PIRP                irp;
    PIO_STACK_LOCATION  irpsp;

    item = PopIrpSerialList.Flink;
    while (item != &PopIrpSerialList) {

        irp = CONTAINING_RECORD(item, IRP, Tail.Overlay.ListEntry);
        irpsp = IoGetNextIrpStackLocation(irp);

        if ((irpsp->Parameters.Power.SystemContext & POP_INRUSH_CONTEXT) == POP_INRUSH_CONTEXT) {
            //
            // we've found an inrush irp
            //
            return irp;
        }
        item = item->Flink;
    }
    return NULL;
}

PIRP
PopFindIrpByDeviceObject(
    PDEVICE_OBJECT  DeviceObject,
    POWER_STATE_TYPE    Type
    )
/*++

Routine Description:

    This procedure runs the irp serial list (which contains all
    waiting irps, be they queued up on a single device object or
    multiple inrush irps) looking for the first irp that applies
    the the supplied device driver.  If one is found, its address,
    while still in the list, is returned.  Else, null is returned.

    Caller must be holding PopIrpSerialList lock.

Arguments:

    DeviceObject - address of device object we're looking for the next irp for

    Type - whether an irp of type SystemPowerState, DevicePowerState, etc, is wanted

Return Value:

    address of found irp, or null if none.

--*/
{
    PLIST_ENTRY         item;
    PIRP                irp;
    PIO_STACK_LOCATION  irpsp;

    for(item = PopIrpSerialList.Flink;
        item != &PopIrpSerialList;
        item = item->Flink)
    {
        irp = CONTAINING_RECORD(item, IRP, Tail.Overlay.ListEntry);
        irpsp = IoGetNextIrpStackLocation(irp);

        if (irpsp->DeviceObject == DeviceObject) {
            //
            // we've found a waiting irp that applies to the device object
            // the caller is interested in
            //
            if (irpsp->Parameters.Power.Type == Type) {
                //
                // irp is of the type that the caller wants
                //
                return irp;
            }
        }
    }
    return NULL;
}


NTSTATUS
PoRequestPowerIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PREQUEST_POWER_COMPLETE CompletionFunction,
    IN PVOID Context,
    OUT PIRP *ResultIrp OPTIONAL
    )
/*++

Routine Description:

    This allocates a device power irp and sends it to the top of the
    PDO stack for the passed device object.  When the irp completes,
    the CompletionFunction is called.

Arguments:

    DeviceObject      - address of a device object whose stack is to get the
                        device power irp

    MinorFunction     - Minor function code for power irp

    DeviceState       - The DeviceState to send in the irp

    CompletionFunction- The requestor's completion function to invoke once the
                        irp has completed

    Context           - The requestor's context for the completion function

    Irp               - Irp which is only valid until CompletionFunction is called

Return Value:

    Status of the request

--*/
{
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    PDEVICE_OBJECT          TargetDevice;
    POWER_ACTION            IrpAction;


    ASSERT(DeviceObject);

    TargetDevice = IoGetAttachedDeviceReference (DeviceObject);
    Irp = IoAllocateIrp ((CCHAR) (TargetDevice->StackSize+2), FALSE);
    if (!Irp) {
        ObDereferenceObject (TargetDevice);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SPECIALIRP_WATERMARK_IRP(Irp, IRP_SYSTEM_RESTRICTED);

    //
    // For debugging, keep a list of all outstanding irps allocated
    // through this function
    //

    IrpSp = IoGetNextIrpStackLocation(Irp);
    ExInterlockedInsertTailList(
        &PopRequestedIrps,
        (PLIST_ENTRY) &IrpSp->Parameters.Others.Argument1,
        &PopIrpSerialLock
        );
    IrpSp->Parameters.Others.Argument3 = Irp;
    IoSetNextIrpStackLocation (Irp);

    //
    // Save the datum needed to complete this request
    //

    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->DeviceObject = TargetDevice;
    IrpSp->Parameters.Others.Argument1 = (PVOID) DeviceObject;
    IrpSp->Parameters.Others.Argument2 = (PVOID) (ULONG_PTR) MinorFunction;
    IrpSp->Parameters.Others.Argument3 = (PVOID) (ULONG_PTR) PowerState.DeviceState;
    IrpSp->Parameters.Others.Argument4 = (PVOID) Context;
    IoSetNextIrpStackLocation (Irp);

    //
    // Build the power irp
    //

    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = IRP_MJ_POWER;
    IrpSp->MinorFunction = MinorFunction;
    IrpSp->DeviceObject = TargetDevice;
    switch (MinorFunction) {
        case IRP_MN_WAIT_WAKE:
            IrpSp->Parameters.WaitWake.PowerState = PowerState.SystemState;
            break;

        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:
            IrpSp->Parameters.Power.SystemContext = POP_DEVICE_REQUEST;
            IrpSp->Parameters.Power.Type = DevicePowerState;
            IrpSp->Parameters.Power.State.DeviceState = PowerState.DeviceState;

            //
            // N.B.
            //
            //     You would think we stamp every D-state IRP with
            // PowerActionNone. However, we have a special scenario to consider
            // for hibernation. Let's say S4 goes to a stack. If the device is
            // on the hibernate path, one of two designs for WDM is possible:
            // (BTW, we chose the 2nd)
            //
            // 1) The FDO sees an S-IRP but because it's device is on the
            //    hibernate path, it simply forwards the S Irp down. The PDO
            //    takes note of the S-IRP being PowerSystemHibernate, and it
            //    records hardware settings. Upon wake-up, the stack receives
            //    an S0 IRP, which the FDO converts into a D0 request. Upon
            //    receiving the D0 IRP, the PDO restores the settings.
            // 2) The FDO *always* requests the corresponding D IRP, regardless
            //    of if it's on the hibernate path. The D-IRP also comes stamped
            //    with the PowerAction in ShutdownType (ie, PowerActionSleeping,
            //    PowerActionShutdown, PowerActionHibernate). Now the PDO can
            //    identify transitions to D3 for the purpose of hibernation. The
            //    PDO would *not* actually transition into D3, but it would save
            //    it's state, and restore it at D0 time.
            //
            // < These are mutually exclusive designs >
            //
            // The reason we choose #2 as a design is so miniport models can
            // expose only D IRPs as neccessary, and S IRPs can be abstracted
            // out. There is a penalty for this design in that PoRequestPowerIrp
            // doesn't *take* a PowerAction or the old S-IRP, so we pick up the
            // existing action that the system is already undertaking.
            // Therefore, if the device powers itself on when the system decides
            // to begin a hibernation. the stack may receive nonsensical data
            // like an IRP_MN_SET_POWER(DevicePower, D0, PowerActionHibernate).
            //

            IrpAction = PopMapInternalActionToIrpAction (
                PopAction.Action,
                PopAction.SystemState,
                TRUE // UnmapWarmEject
                );

            IrpSp->Parameters.Power.ShutdownType = IrpAction;

            //
            // Log the call.
            //

            if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
                PopLogNotifyDevice(TargetDevice, NULL, Irp);
            }
            break;
        default:
            ObDereferenceObject (TargetDevice);
            IoFreeIrp (Irp);
            return STATUS_INVALID_PARAMETER_2;
    }

    IoSetCompletionRoutine(
        Irp,
        PopCompleteRequestIrp,
        (PVOID) CompletionFunction,
        TRUE,
        TRUE,
        TRUE
        );

    if (ResultIrp) {
        *ResultIrp = Irp;
    }

    PoCallDriver(TargetDevice, Irp);
    return STATUS_PENDING;
}

NTSTATUS
PopCompleteRequestIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    Completion routine for PoRequestPowerChange.  Invokes the
    requestor's completion routine, and free resources associated
    with the request

Arguments:

    DeviceObject      - The target device which the request was sent

    Irp               - The irp completing

    Context           - The requestor's completion routine

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED is returned to IO

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PREQUEST_POWER_COMPLETE CompletionFunction;
    POWER_STATE             PowerState;
    KIRQL                   OldIrql;

    //
    // Log the completion.
    //

    if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
        PERFINFO_PO_NOTIFY_DEVICE_COMPLETE LogEntry;
        LogEntry.Irp = Irp;
        LogEntry.Status = Irp->IoStatus.Status;
        PerfInfoLogBytes(PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE_COMPLETE,
                         &LogEntry,
                         sizeof(LogEntry));
    }

    //
    // Dispatch to requestor's completion function
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    CompletionFunction = (PREQUEST_POWER_COMPLETE) (ULONG_PTR) Context;
    PowerState.DeviceState = (DEVICE_POWER_STATE) ((ULONG_PTR)IrpSp->Parameters.Others.Argument3);

    if (CompletionFunction) {
        CompletionFunction (
            (PDEVICE_OBJECT) IrpSp->Parameters.Others.Argument1,
            (UCHAR)          (ULONG_PTR)IrpSp->Parameters.Others.Argument2,
            PowerState,
            (PVOID)          IrpSp->Parameters.Others.Argument4,
            &Irp->IoStatus
            );
    }


    //
    // Cleanup
    //

    IoSkipCurrentIrpStackLocation(Irp);
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    KeAcquireSpinLock (&PopIrpSerialLock, &OldIrql);
    RemoveEntryList ((PLIST_ENTRY) &IrpSp->Parameters.Others.Argument1);
    KeReleaseSpinLock (&PopIrpSerialLock, OldIrql);

    //
    // Mark the irp CurrentLocation as completed (to catch multiple completes)
    //

    Irp->CurrentLocation = (CCHAR) (Irp->StackCount + 2);

    ObDereferenceObject (DeviceObject);
    IoFreeIrp (Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
PopSystemIrpDispatchWorker (
    IN BOOLEAN  LastCall
    )
/*++

Routine Description:

    This routine runs whenever the policy manager calls us to tell us
    that a big burst of system irps, which need to be dispatched from
    a private thread (this one) rather than from an executive worker
    thread.  This is mostly to avoid deadlocks at sleep time.

Globals:

    PopWorkerLock - protects access to the queue, and avoids races
                        over using this routine or using exec worker

    PopWorkerItemQueue - list of irps to send off...

Arguments:

    LastCall - Indicates irps are to be sent normally

Return Value:

--*/
{
    PLIST_ENTRY Item;
    PIRP        Irp;
    KIRQL       OldIrql;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    PopLockWorkerQueue(&OldIrql);

    //
    // Dispatch everything on the queue
    //

    if (PopAction.DevState != NULL) {
        while (!IsListEmpty(&PopAction.DevState->PresentIrpQueue)) {
            Item = RemoveHeadList(&PopAction.DevState->PresentIrpQueue);
            Irp = CONTAINING_RECORD(Item, IRP, Tail.Overlay.ListEntry);

            PopUnlockWorkerQueue(OldIrql);
            PopPassivePowerCall(Irp);
            PopLockWorkerQueue(&OldIrql);
        }
    }

    if (LastCall) {
        PopCallSystemState = 0;
    }

    PopUnlockWorkerQueue(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\podata.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    podata.c

Abstract:

    This module contains the global read/write data for the I/O system.

Author:

    N. Yoshiyama [IBM Corp] 07-April-1994 ( Depends on Microsoft's design )

Revision History:


--*/

#include "pop.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
#include "initguid.h"       // define PO guids
#include "poclass.h"
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA



//
// Define the global data for the Power Management.
//

//
// Power Locks
//

//
// Protects the IRP serial list.
//
KSPIN_LOCK  PopIrpSerialLock;

//
// Protects all Dope structures and dependents,
// including all Notify and Idle operations.
//
KSPIN_LOCK  PopDopeGlobalLock;

//
// Must be held during creation or
// destruction of power notify channel
// structures.
ERESOURCE   PopNotifyLock;


//
// PoPowerSequence - The current power sequence value.  Forever counts
// up each time the machine is resumed from a suspend or hibernate
//
ULONG           PoPowerSequence;

//
// PopInvalidNotifyBlockCount is the number of power notify blocks which
// have been invalidated but not fully closed up and freed.  Should be 0
// most of the time.  Non-0 indicates callers have failed to clean up
// in response to an Invalidate notify.
//
ULONG           PopInvalidNotifyBlockCount;

//
// Irp serializtion and Inrush serialization - pocall.c and related
//
LIST_ENTRY      PopIrpSerialList;
ULONG           PopIrpSerialListLength;
BOOLEAN         PopInrushPending;
PIRP            PopInrushIrpPointer;
LONG            PopInrushIrpReferenceCount;

//
// PopSystemIrpDisptachWorker control, etc
//
KSPIN_LOCK      PopWorkerLock;
ULONG           PopCallSystemState;


//
// For debugging, a list of all the outstanding PoRequestPowerIrps
//
LIST_ENTRY      PopRequestedIrps;

//
// For logging supported power states, a list of reason structures.
//
LIST_ENTRY PowerStateDisableReasonListHead;

//
// Idle detection service - see idle.c
//
// When adding to, removing from, or scanning the IdleDetectList, code
// must be at DPC_LEVEL and must hold the PopGlobalDopeLock
//
LIST_ENTRY      PopIdleDetectList;

//
// A timer & defered procedure call to process idle scans
//
KTIMER          PopIdleScanTimer;
KDPC            PopIdleScanDpc;
LARGE_INTEGER   PopIdleScanTime;

//
// Two scan modes, performance, conservation...
//
BOOLEAN         PopIdleDetectionMode = PO_IDLE_PERFORMANCE;

//
// This value holds all Power Management Simulation Flags
//
ULONG           PopSimulate = POP_ENABLE_HIBER_PERF;

//
// These defines are only used to initialize these global variables,
// so it makes sense to pair them all up. The global variables are
// all used for idle state transition calculations
//

//
// When throttling down an idle processor, keep it at least 30% active
//
#define IDLE_DEFAULT_MIN_THROTTLE       30
ULONG   PopIdleDefaultMinThrottle           = IDLE_DEFAULT_MIN_THROTTLE;

//
// When a processor is throttled down, queue a timer to verify that a
// processor does not go significantly "busy" and never returns to
// the idle loop for a throttle adjustment
// N.B idle values are in microseconds
//
#define IDLE_THROTTLE_CHECK_RATE        30000       // 30ms
ULONG   PopIdleThrottleCheckRate            = IDLE_THROTTLE_CHECK_RATE;

//
// If the throttle check timer noticies a processor has not returned
// to the idle loop for at least 100ms, then abort it's throttle
//
#define IDLE_THROTTLE_CHECK_TIMEOUT     100000      // 100ms
ULONG   PopIdleThrottleCheckTimeout         = IDLE_THROTTLE_CHECK_TIMEOUT;

//
// To promote from Idle 0 the processor must be more then 90% idle over
// the last 10 seconds
//
#define IDLE_FROM_0_DELAY               10000000    // 10 seconds
#define IDLE_FROM_0_IDLE_PERCENT        90          // > 90% to promote from idle 0
ULONG   PopIdleFrom0Delay                   = IDLE_FROM_0_DELAY;
ULONG   PopIdleFrom0IdlePercent             = IDLE_FROM_0_IDLE_PERCENT;

//
// First idle handler checks no more then every 100ms
// idle below 20%
//
#define IDLE_0_TIME_CHECK               500000      // 500ms
ULONG   PopIdle0TimeCheck                   = IDLE_0_TIME_CHECK;

//
// When in other idle state check every 100ms
//
#define IDLE_TIME_CHECK                 100000       // 100ms
ULONG   PopIdleTimeCheck                    = IDLE_TIME_CHECK;

//
// To demote to Idle 0 the processor must be less then 80% idle in a 100ms window
//
#define IDLE_TO_0_PERCENT               80
ULONG   PopIdleTo0Percent                   = IDLE_TO_0_PERCENT;

//
// The default demotion occurs at less then 50% idle for 100ms
// N.B. The implementation assumes that IDLE_DEFAULT_DEMOTE_TIME divides
// into IDLE_DEFAULT_PROMOTE_TIME evenly
//
#define IDLE_DEFAULT_DEMOTE_PERCENT     50
#define IDLE_DEFAULT_DEMOTE_TIME        100000
ULONG   PopIdleDefaultDemotePercent         = IDLE_DEFAULT_DEMOTE_PERCENT;
ULONG   PopIdleDefaultDemoteTime            = IDLE_DEFAULT_DEMOTE_TIME;

//
// The default promotion occurs at more then 70% idle for 500ms
//
#define IDLE_DEFAULT_PROMOTE_TIME       500000      // 500ms
#define IDLE_DEFAULT_PROMOTE_PERCENT    70
ULONG   PopIdleDefaultPromotePercent        = IDLE_DEFAULT_PROMOTE_PERCENT;
ULONG   PopIdleDefaultPromoteTime           = IDLE_DEFAULT_PROMOTE_TIME;

//
// We define special extra global variables to handle promotion to/from
// C1. The reason that we do this is so that we can more finely tune these
// values.
//
ULONG   PopIdleDefaultDemoteToC1Percent     = IDLE_DEFAULT_DEMOTE_PERCENT;
ULONG   PopIdleDefaultDemoteToC1Time        = IDLE_DEFAULT_DEMOTE_TIME;
ULONG   PopIdleDefaultPromoteFromC1Percent  = IDLE_DEFAULT_PROMOTE_PERCENT;
ULONG   PopIdleDefaultPromoteFromC1Time     = IDLE_DEFAULT_PROMOTE_TIME;

//
// We convert PopIdleFrom0Delay (which is in ms) over to KeTimeIncrement
// intervals. This is the number of ticks needed for processor to be idle before
// we consider a promotion out of the Idle0 state
//
ULONG PopIdle0PromoteTicks;

//
// We convert PopIdleFrom0Delay and PopIdleFrom0IdlePercent percent into
// KeTimeIncrement inverals. This is the number of ticks allowed to acculate the
// the PromoteTicks time
//
ULONG PopIdle0PromoteLimit;


//
// These global variables and definitions all relate to CPU throttle management
//

//
// A value that defines the period of time, in microseconds (us) between
// intervals to check the processor busyness for the purposes of processor
// throttling by the idle thread. Note that we need to convert this value
// to KeTimeIncrement intervals. We store the converted number in
// PopPerfTimeTicks
//
#define PROC_PERF_TIME_DELTA            50000       // 50ms
ULONG   PopPerfTimeDelta                    = PROC_PERF_TIME_DELTA;
ULONG   PopPerfTimeTicks                    = 0;

//
// A value that defines the period of time, in microseconds (us) between
// intervals to check the processor busyness for the purposes of processor
// throttling by a DPC routine. Note that we need to convert this value
// to KeTimeIncrement intervals. We store the converted number in
// PopPerfCriticalTimeTicks.
//
#define PROC_PERF_CRITICAL_TIME_DELTA   300000      // 300ms
ULONG   PopPerfCriticalTimeDelta            = PROC_PERF_CRITICAL_TIME_DELTA;
ULONG   PopPerfCriticalTimeTicks            = 0;

//
// A percentage value that is added to the current CPU busyness percentage
// to determine if the processor is too busy for the current performance
// state and must be promoted. The closer the value is to zero, the harder it
// is for the processor to promote itself during times of extreme workloads
//
#define PROC_PERF_CRITICAL_FREQUENCY_DELTA  0       // 0%
ULONG   PopPerfCriticalFrequencyDelta       = PROC_PERF_CRITICAL_FREQUENCY_DELTA;

//
// A percentage value where lower means that the overall IncreaseLevel will
// actually be higher (and thus promotions won't occur as frequently) that
// indicates what percentage of the delta betwene the current state and the
// state to promote to should be used to set the promote level. A suggested
// value would be 20%
//
#define PROC_PERF_INCREASE_PERC_MOD     20          //  20%
ULONG   PopPerfIncreasePercentModifier      = PROC_PERF_INCREASE_PERC_MOD;

//
// A percentage value where lower means that the overall IncreaseLevel will
// actually be higher (and thus promotions won't occur as frequently) that
// indicates how many extra percentage points to remove from the promote level.
// It should be noted that if this value is particularly high, confusion migh
// result due to overlapping windows. A suggested value would be 1%
//
#define PROC_PERF_INCREASE_ABS_MOD      1           // 1%
ULONG   PopPerfIncreaseAbsoluteModifier     = PROC_PERF_INCREASE_ABS_MOD;

//
// A percentage value where higher means that the overall DecreaseLevel will
// actually be lower (and thus demotions won't occur as frequently) that
// indicates what percentage of the delta between the current state and the
// state to demote to should be used to set the demote level. A suggested
// value is 30%
//
#define PROC_PERF_DECREASE_PERC_MOD     30          // 50%
ULONG   PopPerfDecreasePercentModifier      = PROC_PERF_DECREASE_PERC_MOD;

//
// A percentage value where higher means that the overall DecreaseLevel will
// actually be lower (and thus demotions won't occur as frequently) that
// indicates how many extra percentage points to subtract from the demote
// level. It should be noted that if the value is particularly high, then it
// might not be possible to demote from this state. A suggested value would be
// 1%
//
#define PROC_PERF_DECREASE_ABS_MOD      1           // 1%
ULONG   PopPerfDecreaseAbsoluteModifier     = PROC_PERF_DECREASE_ABS_MOD;

//
// A value that defines the period of time, in microseconds (us) that must
// have occured before a throttle increase can be considered. This value is
// used as the basis for calculating the promotion time for each throttle
// step
//
#define PROC_PERF_INCREASE_TIME         10000       // 10 ms
#define PROC_PERF_INCREASE_MINIMUM_TIME 150000      // 150 ms
ULONG   PopPerfIncreaseTimeValue            = PROC_PERF_INCREASE_TIME;
ULONG   PopPerfIncreaseMinimumTime          = PROC_PERF_INCREASE_MINIMUM_TIME;
//
// A value that defines the period of time, in microseconds (us) that must
// have occured before a throttle decrease can be considered. This value is
// used as the basis for calculating the demotion time for each throttle
// step
//
#define PROC_PERF_DECREASE_TIME         10000       // 10 ms
#define PROC_PERF_DECREASE_MINIMUM_TIME 500000      // 500 ms
ULONG   PopPerfDecreaseTimeValue            = PROC_PERF_DECREASE_TIME;
ULONG   PopPerfDecreaseMinimumTime          = PROC_PERF_DECREASE_MINIMUM_TIME;

//
// A percentage value that represents at what point of battery capacity we
// will start forcing down the throttle when we are in Degraded Throttling
// mode. For example, a value of 50% means that we will start throttling
// down the CPU when the battery reaches 50%
//
#define PROC_PERF_DEGRADE_MIN_CAP       50          // 50%
ULONG   PopPerfDegradeThrottleMinCapacity   = PROC_PERF_DEGRADE_MIN_CAP;

//
// A percentage value that represents the lowest frequency we can force the
// throttle down to when we are in the Degraded Throttling mode. For example,
// a value of 30% means that we will never force the CPU below 30%
//
#define PROC_PERF_DEGRADE_MIN_FREQ      30          // 30%
ULONG   PopPerfDegradeThrottleMinFrequency  = PROC_PERF_DEGRADE_MIN_FREQ;

//
// A percentage value that represents the maximum amount of time that was
// spent in C3 for the last quanta before the idle loop will deside that
// it should optimize power for C3 usage. A sample value would be 50%
//
#define PROC_PERF_MAX_C3_FREQUENCY      50          // 50%
ULONG   PopPerfMaxC3Frequency               = PROC_PERF_MAX_C3_FREQUENCY;


#if DBG

//
// PoDebug - Debug level
//

ULONG PoDebug = PO_ERROR;

#endif

//
// PopPolicyLock - Protects policy data structures
//
ERESOURCE   PopPolicyLock;

//
// PopWorkerSpinLock - Protects worker dispatch data
// PopWorkerPending - A set bit for each worker cataogry which is pending
// PopWorkerStatus - A clear bit for each worker catagory being serived
//
KSPIN_LOCK  PopWorkerSpinLock;
ULONG       PopWorkerPending;
ULONG       PopWorkerStatus;

//
// PopNotifyEvents - PO_NOTIFY_xxx events which have fired.
//
LONG        PopNotifyEvents;

//
// PopVolumeLock - protects PopVolumeDevices from insertion.  (removal is
// protected by the policy lock
//
KGUARDED_MUTEX  PopVolumeLock;
KGUARDED_MUTEX PopRequestWakeLock;

//
// PopVolumeDevices - a list of off device objects which have had a VPBs attached
//
LIST_ENTRY PopVolumeDevices = {0};

//
// PopRequestWakeLock - synchronizes NtRequest/CancelDeviceWakeup
//


//
// PopPolicyWorker - Work queue item to get another worker thread
//
WORK_QUEUE_ITEM PopPolicyWorker;

//
// PopIdle - Pointer to Array of idle handlers.
//
PPOP_IDLE_HANDLER PopIdle;

//
// PopIdleHandlerLookAsideList - List to allocate storage from for idle
//  handlers.
//
NPAGED_LOOKASIDE_LIST PopIdleHandlerLookAsideList;

//
// PopAttribute - Book keeping
//
POP_STATE_ATTRIBUTE PopAttributes[POP_NUMBER_ATTRIBUTES] = {
    0, PopSystemRequiredSet,    FALSE,  0,
    0, PopDisplayRequired,       TRUE,  0,    // 0, PopSetNotificationWork,  TRUE,   PO_NOTIFY_DISPLAY_REQUIRED,
    0, PopUserPresentSet,       FALSE,  0,
    0, PopAttribNop,            FALSE,  0,
    0, PopSetNotificationWork,  TRUE,   PO_NOTIFY_CAPABILITIES
    };

//
// PopFullWake - Flag to indicate the system has transistioned from
// a quite wake to a full wake
//
LONG PopFullWake;

//
// PoHiberInProgress - True when in the critical hibernation section
//
BOOLEAN PoHiberInProgress;

//
// PopShutdownCleanly - Controls whether clean shutdown sequence should
// be used.
//
ULONG PopShutdownCleanly = 0;

//
// PopDispatchPolicyIrps - Used to prevent policy irps from dispatching
// until the base drivers are loaded
//
BOOLEAN PopDispatchPolicyIrps;

//
// PopSystemIdleTimer - Timer used to get idle system detection worker
//
KTIMER PoSystemIdleTimer;

//
// PopSIdle - tracks the idle state of the system
//
POP_SYSTEM_IDLE PopSIdle;

//
// PopPolicyLockThread - Conains the current owning thread of the
// policy mutex.
//
PKTHREAD PopPolicyLockThread = NULL;

//
// PopAcPolicy - current power policy being implemented while on AC
// PopDcPolicy - current power policy being implemented while not on AC
// PopPolicy - current active policy
//
SYSTEM_POWER_POLICY PopAcPolicy = {0};
SYSTEM_POWER_POLICY PopDcPolicy = {0};
PSYSTEM_POWER_POLICY PopPolicy = NULL;

//
// PopAcProcessorPolicy - current processor power policy being implemented on AC
// PopDcProcessorPolicy - current processor power policy being implemented on DC
// PopProcessorPolicy   - current active policy
//
PROCESSOR_POWER_POLICY PopAcProcessorPolicy = {0};
PROCESSOR_POWER_POLICY PopDcProcessorPolicy = {0};
PPROCESSOR_POWER_POLICY PopProcessorPolicy = NULL;

//
// PopAction - Current power action being taken
//
POP_POWER_ACTION PopAction = {0};

//
// Spinlock that protects the thermal zones
//
KSPIN_LOCK  PopThermalLock;

//
// PopSwitches - list of button and lid devices currently opened
//
LIST_ENTRY PopSwitches = {0};

//
// User-present work item
//
WORK_QUEUE_ITEM PopUserPresentWorkItem = {0};

//
// Performance counter frequency used by throttle.c
//
LARGE_INTEGER PopPerfCounterFrequency;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif

//
// Notify worker dispatch
//
const POP_NOTIFY_WORK  PopNotifyWork[PO_NUMBER_NOTIFY] = {
    PopDispatchCallback,                PO_CB_BUTTON_COLLISION,
    PopDispatchFullWake,                0,
    PopDispatchCallback,                PO_CB_SYSTEM_POWER_POLICY,
    PopDispatchAcDcCallback,            0,
    PopDispatchPolicyCallout,           0,
    PopDispatchDisplayRequired,         0,
    PopDispatchCallout,                 PsW32SystemPowerState,
    PopDispatchEventCodes,              0,
    PopDispatchCallout,                 PsW32CapabilitiesChanged,
    PopDispatchSetStateFailure,         0,
    PopDispatchCallback,                PO_CB_PROCESSOR_POWER_POLICY,
    PopDispatchProcessorPolicyCallout,  0
    };

//
// PopAcRegName
// PopDcRegName - registry location under current control set to store
//                and retrieve current policy settings from
//
const WCHAR PopRegKey[] = L"Control\\Session Manager\\Power";
const WCHAR PopAcRegName[] = L"AcPolicy";
const WCHAR PopDcRegName[] = L"DcPolicy";
const WCHAR PopUndockPolicyRegName[] = L"UndockPowerPolicy";
const WCHAR PopAdminRegName[] = L"PolicyOverrides";
const WCHAR PopHeuristicsRegName[] = L"Heuristics";
const WCHAR PopCompositeBatteryName[] = L"\\Device\\CompositeBattery";
const WCHAR PopSimulateRegKey[] = L"Control\\Session Manager";
const WCHAR PopSimulateRegName[] = L"PowerPolicySimulate";
const WCHAR PopHiberFileName[] = L"\\hiberfil.sys";
const WCHAR PopDebugHiberFileName[] = L"\\hiberfil.dbg";
const WCHAR PopDumpStackPrefix[] = L"hiber_";
const WCHAR PopApmActiveFlag[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ApmActive";
const WCHAR PopApmFlag[] = L"Active";
const WCHAR PopAcProcessorRegName[] = L"AcProcessorPolicy";
const WCHAR PopDcProcessorRegName[] = L"DcProcessorPolicy";

//
// PopAdminPolcy - Administrator overrides to apply to the current policy
//
ADMINISTRATOR_POWER_POLICY PopAdminPolicy = {0};

//
// PopCapabilities - Misc information on how the systems actual functions
//
SYSTEM_POWER_CAPABILITIES PopCapabilities; // nonpaged

//
// PopEventCallout - callout to USER for power events
//
PKWIN32_POWEREVENT_CALLOUT PopEventCallout; // nonpaged

//
// PopStateCallout - callout to USER for power state changes
//
PKWIN32_POWERSTATE_CALLOUT PopStateCallout = NULL;

//
// PopThermal - list of thermal zones currently opened
//
LIST_ENTRY PopThermal; // nonpaged

//
// PopCoolingMode - system is in active or passive cooling mode
//
ULONG   PopCoolingMode = 0;

//
// PopCB - composite battery
//
POP_COMPOSITE_BATTERY PopCB; // nonpaged

//
// PopPolicyIrpQueue - Policy irps which have completed are put onto
// this queue for processingby the worker thread
//
LIST_ENTRY PopPolicyIrpQueue; // nonpaged

//
// PopEventCode - Queued event codes
//
ULONG PopEventCode[POP_MAX_EVENT_CODES] = {0};

//
// PopWorkerTypes - Worker functions for each policy worker type
//
const POP_WORKER_TYPES PopWorkerTypes[] = {
    PopPolicyWorkerMain,
    PopPolicyWorkerActionPromote,
    PopPolicyWorkerAction,
    PopPolicyWorkerNotify,
    PopPolicySystemIdle,
    PopPolicyTimeChange
    };

//
// PopActionWaiters - Queue of synchronous action requests
//
LIST_ENTRY PopActionWaiters = {0};


//
// PopHeuristics - Presistant settings are heuristics which are not part
// of the saved policy structures
//
POP_HEURISTICS PopHeuristics = {0};

#ifdef ALLOC_DATA_PRAGMA
#pragma  const_seg()
#pragma  data_seg()
#endif

//
// PopPowerStateHandler - Handlers for the various supported power states
//
POWER_STATE_HANDLER PopPowerStateHandlers[PowerStateMaximum] = {0};

//
// PopPowerStateNotifyHandler - Handler to be notify before and after invoking
// PopPowerStateHandlers
//

POWER_STATE_NOTIFY_HANDLER PopPowerStateNotifyHandler = {0};

//
// PopHiberFile - information on the hibernation file
// PopHiberFileDebug - a second hibernation file for debugging
//
POP_HIBER_FILE  PopHiberFile = { NULL };
POP_HIBER_FILE  PopHiberFileDebug = { NULL };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\pinfo.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pinfo.c

Abstract:

    This module implements the generic power policy information interfaces

Author:

    Ken Reneris (kenr) 17-Jan-1997

Revision History:

--*/


#include "pop.h"

//
// Internal prototypes
//


NTSTATUS
PopVerifySystemPowerPolicy (
    IN BOOLEAN  Ac,
    IN PSYSTEM_POWER_POLICY InputPolicy,
    OUT PSYSTEM_POWER_POLICY PowerPolicy
    );

NTSTATUS
PopVerifyProcessorPowerPolicy (
    IN BOOLEAN  Ac,
    IN PPROCESSOR_POWER_POLICY InputPolicy,
    OUT PPROCESSOR_POWER_POLICY PowerPolicy
    );

VOID
PopVerifyThrottle (
    IN PUCHAR   Throttle,
    IN UCHAR    Min
    );

NTSTATUS
PopApplyPolicy (
    IN BOOLEAN              UpdateRegistry,
    IN BOOLEAN              AcPolicy,
    IN PSYSTEM_POWER_POLICY NewPolicy,
    IN ULONG                PolicyLength
    );

NTSTATUS
PopApplyProcessorPolicy (
    IN BOOLEAN                  UpdateRegistry,
    IN BOOLEAN                  AcPolicy,
    IN PPROCESSOR_POWER_POLICY  NewPolicy,
    IN ULONG                    PolicyLength
    );

VOID
PopFilterCapabilities(
    IN PSYSTEM_POWER_CAPABILITIES SourceCapabilities,
    OUT PSYSTEM_POWER_CAPABILITIES FilteredCapabilities
    );

BOOLEAN
PopUserIsAdmin(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtPowerInformation)
#pragma alloc_text(PAGE, PopApplyAdminPolicy)
#pragma alloc_text(PAGE, PopApplyPolicy)
#pragma alloc_text(PAGE, PopVerifySystemPowerPolicy)
#pragma alloc_text(PAGE, PopVerifyPowerActionPolicy)
#pragma alloc_text(PAGE, PopVerifySystemPowerState)
#pragma alloc_text(PAGE, PopAdvanceSystemPowerState)
#pragma alloc_text(PAGE, PopResetCurrentPolicies)
#pragma alloc_text(PAGE, PopNotifyPolicyDevice)
#pragma alloc_text(PAGE, PopConnectToPolicyDevice)
#pragma alloc_text(PAGE, PopFilterCapabilities)
#pragma alloc_text(PAGE, PopUserIsAdmin)
#endif

extern PFN_NUMBER MmHighestPhysicalPage;

NTSTATUS
NtPowerInformation (
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )
/*++

Routine Description:

    This function optionally sets, and gets current power policy information
    based on the InformationLevel.

Arguments:

    InformationLevel    - Specifies what the user wants us to do/get.

    InputBuffer         - Input to set InformationLevel information.

    InputBufferLength   - Size, in bytes, of InputBuffer

    OutputBuffer        - Buffer to return InformationLevel information.

    OutputBufferLength  - Size, in bytes, of OutputBuffer

Return Value:

    Status

--*/
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    PVOID                       ReturnBuffer = NULL;
    ULONG                       ReturnBufferLength = 0;
    KPROCESSOR_MODE             PreviousMode;
    PPOWER_STATE_HANDLER        PowerHandler = NULL;
    PBOOLEAN                    CapFlag = NULL;
    BOOLEAN                     Enable = FALSE;
    ULONG                       HandlerType = 0;
    SYSTEM_POWER_STATE          RtcWake;
    PVOID                       SafeInputBuffer = NULL;
    PVOID                       LogBuffer = NULL;
    ULONG                       LogBufferSize;

    union {
        PROCESSOR_POWER_POLICY      ProcessorPowerPolicy;
        SYSTEM_POWER_POLICY         SystemPowerPolicy;
        SYSTEM_BATTERY_STATE        SystemBatteryState;
        SYSTEM_POWER_INFORMATION    SystemPowerInformation;
        PROCESSOR_POWER_INFORMATION ProcessorPowerInfo[MAXIMUM_PROCESSORS];
        SYSTEM_POWER_CAPABILITIES   SystemPowerCapabilities;
        EXECUTION_STATE             SystemExecutionState;
    } Buf;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    //
    // If caller is user mode make some verifications
    //
    if (PreviousMode != KernelMode) {


        //
        // Check privileges if he's trying to do anything
        // invasive.
        //
        // That means we'll skip checking for any privileges
        // if he's asking for any of the verify calls, or
        // if he didn't send in an input buffer (implying that
        // he's not doing anything invasive).
        //
        if( (InformationLevel != VerifySystemPolicyAc)    &&
            (InformationLevel != VerifySystemPolicyDc)    &&
            (InformationLevel != VerifyProcessorPowerPolicyAc) &&
            (InformationLevel != VerifyProcessorPowerPolicyDc) &&
            (InputBuffer) ) {

            //
            // Make access check
            //
            if (InformationLevel == SystemReserveHiberFile) {

                //
                // Only allow callers that have create pagefile privilege
                // to enable/disable the hibernate file
                //
                if (!SeSinglePrivilegeCheck(SeCreatePagefilePrivilege,PreviousMode)) {
                    return STATUS_PRIVILEGE_NOT_HELD;
                }

            } else {

                if (!SeSinglePrivilegeCheck( SeShutdownPrivilege, PreviousMode )) {
                    return STATUS_PRIVILEGE_NOT_HELD;
                }

            }

        }



        //
        // Verify addresses.
        //
        // Note that we'll get the side effect that these addresses
        // will be locked for a single access.
        //
        try {
            if (InputBuffer) {
                ProbeForRead (
                    InputBuffer,
                    InputBufferLength,
                    InputBufferLength >= sizeof (ULONG) ? sizeof(ULONG) : sizeof(UCHAR)
                    );

                //
                // Copy the buffer into a local buffer.  Do this so we
                // guard against someone freeing the buffer out from
                // under us.
                //
                SafeInputBuffer = ExAllocatePoolWithTag( PagedPool,
                                                         InputBufferLength,
                                                         POP_MEM_TAG );
                if( !SafeInputBuffer ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    RtlCopyMemory( SafeInputBuffer, InputBuffer, InputBufferLength );
                }
            }
    
            if (OutputBuffer) {
                ProbeForWrite (OutputBuffer, OutputBufferLength, sizeof(ULONG));
            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {
              Status = GetExceptionCode();
        }

    }

    if( !NT_SUCCESS(Status) ) {
        //
        // Something bad.
        if( SafeInputBuffer ) {
            ExFreePool(SafeInputBuffer);
        }
        return Status;
    }



    //
    // If we got called from usermode, and there was an input buffer, then
    // we should have already assigned SafeInputBuffer.
    // 
    // If SafeInputBuffer isn't set, assume either we came from kernelmode, or
    // we didn't get sent an inputbuffer.  Either way, just use the value
    // of InputBuffer.  It's either NULL, or it came from kernelmode and can
    // be trusted.
    //
    if( !SafeInputBuffer ) {
        SafeInputBuffer = InputBuffer;
    }


    //
    // Lock the database and handle the request.
    //
    PopAcquirePolicyLock ();
    switch (InformationLevel) {
        case SystemPowerPolicyAc:
        case SystemPowerPolicyDc:

            //
            // We can be asked to set the system power policy
            // through this mechanism if the user sent us an input buffer.
            //
            if (SafeInputBuffer) {

                if( InputBufferLength >= sizeof(SYSTEM_POWER_POLICY) ) {

                    Status = PopApplyPolicy (
                                TRUE,
                                (InformationLevel == SystemPowerPolicyAc) ? TRUE : FALSE,
                                (PSYSTEM_POWER_POLICY) SafeInputBuffer,
                                InputBufferLength
                                );
                } else {
                    Status = STATUS_BUFFER_TOO_SMALL;
                }

            }

            //
            // Return current AC policy
            //
            if( NT_SUCCESS(Status) ) {
                ReturnBuffer = (InformationLevel == SystemPowerPolicyAc) ? &PopAcPolicy : &PopDcPolicy;
                ReturnBufferLength = sizeof(SYSTEM_POWER_POLICY);
            }
            break;

        case ProcessorPowerPolicyAc:
        case ProcessorPowerPolicyDc:

            //
            // We can be asked to set the processor power policy
            // through this mechanism if the user sent us an input buffer.
            //
            if (SafeInputBuffer) {

                if( InputBufferLength >= sizeof(PROCESSOR_POWER_POLICY) ) {

                    Status = PopApplyProcessorPolicy(
                                    TRUE,
                                    (InformationLevel == ProcessorPowerPolicyAc) ? TRUE : FALSE,
                                    (PPROCESSOR_POWER_POLICY) SafeInputBuffer,
                                    InputBufferLength
                                    );
                } else {
                    Status = STATUS_INVALID_PARAMETER;
                }

            }

            //
            // Return current AC processor policy
            //
            if( NT_SUCCESS(Status) ) {
                ReturnBuffer = (InformationLevel == ProcessorPowerPolicyAc) ? &PopAcProcessorPolicy : &PopDcProcessorPolicy;
                ReturnBufferLength = sizeof(PROCESSOR_POWER_POLICY);
            }
            break;

        case AdministratorPowerPolicy:
            
            //
            // If we were sent a SafeInputBuffer, then this implies the caller
            // wants to actually set the ADMINISTRATOR_POWER_POLICY too.
            //
            if (SafeInputBuffer) {

                // this action requires Administrator priv's
                if (PopUserIsAdmin()) {

                    if( InputBufferLength >= sizeof(PADMINISTRATOR_POWER_POLICY) ) {
                        Status = PopApplyAdminPolicy(
                                        TRUE,
                                        (PADMINISTRATOR_POWER_POLICY) SafeInputBuffer,
                                        InputBufferLength
                                        );
                        if( NT_SUCCESS(Status) ) {
                            Status = PopResetCurrentPolicies ();
                        }
                    } else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                    }

                } else {
                    Status = STATUS_ACCESS_DENIED;
                }

            }

            //
            // Return administrator policy
            //
            if( NT_SUCCESS(Status) ) {
                ReturnBuffer = &PopAdminPolicy;
                ReturnBufferLength = sizeof(PopAdminPolicy);
            }
            break;

        case VerifySystemPolicyAc:
        case VerifySystemPolicyDc:

            //
            // Copy the incoming policy into the output buffer,
            // filtering it against current system capabilities along 
            // the way.
            //
            if (SafeInputBuffer && OutputBuffer) {

                if (InputBufferLength >= sizeof (SYSTEM_POWER_POLICY)) {
                    Status = PopVerifySystemPowerPolicy(
                                (InformationLevel == VerifySystemPolicyAc) ? TRUE : FALSE, // get AC or DC policy
                                SafeInputBuffer, 
                                &Buf.SystemPowerPolicy
                                );
                } else {
                    Status = STATUS_BUFFER_TOO_SMALL;
                }

            } else {
                Status = STATUS_INVALID_PARAMETER;
            }

            //
            // Return the filtered policy
            //
            if( NT_SUCCESS(Status) ) {
                ReturnBuffer = &Buf.SystemPowerPolicy;
                ReturnBufferLength = sizeof(SYSTEM_POWER_POLICY);
            }
            break;

        case VerifyProcessorPowerPolicyAc:
        case VerifyProcessorPowerPolicyDc:

            //
            // Copy the incoming policy into the output buffer,
            // filtering it against current system capabilities along 
            // the way.
            //
            if (SafeInputBuffer && OutputBuffer) {

                if (InputBufferLength >= sizeof (PROCESSOR_POWER_POLICY)) {

                    Status = PopVerifyProcessorPowerPolicy(
                                    (InformationLevel == VerifyProcessorPowerPolicyAc) ? TRUE : FALSE, // get AC or DC policy
                                    SafeInputBuffer,
                                    &Buf.ProcessorPowerPolicy
                                    );
                } else {
                    Status = STATUS_BUFFER_TOO_SMALL;
                }

            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
            
            //
            // Return the filtered policy
            //
            if( NT_SUCCESS(Status) ) {
                ReturnBuffer = &Buf.ProcessorPowerPolicy;
                ReturnBufferLength = sizeof(PROCESSOR_POWER_POLICY);
            }
            break;

        case SystemPowerPolicyCurrent:

            if ((SafeInputBuffer) || (InputBufferLength != 0)) {
                Status = STATUS_INVALID_PARAMETER;
            }

            //
            // Return current policy
            //
            ReturnBuffer = PopPolicy;
            ReturnBufferLength = sizeof(PopAcPolicy);
            break;

        case ProcessorPowerPolicyCurrent:

            //
            // Return current policy
            //
            if ((SafeInputBuffer) || (InputBufferLength != 0)) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                ReturnBuffer = PopProcessorPolicy;
                ReturnBufferLength = sizeof(PopAcProcessorPolicy);
            }

            break;

        case SystemPowerCapabilities:

            //
            // Only accept input if we are allowing the simulation of 
            // capabilities (for testing).
            //
            if (SafeInputBuffer) {
                if ((PopSimulate & POP_SIM_CAPABILITIES) && (InputBufferLength == sizeof(PopCapabilities))) {
                    memcpy (&PopCapabilities, SafeInputBuffer, InputBufferLength);
                    Status = PopResetCurrentPolicies ();
                    PopSetNotificationWork (PO_NOTIFY_CAPABILITIES);
                } else {
                    Status = STATUS_INVALID_PARAMETER;
                }
            }

            
            //
            // Make sure our global PopCapabilities makes sense, then return a
            // filtered version to the caller.
            //
            if( NT_SUCCESS(Status) ) {
                PopCapabilities.FullWake = (PopFullWake & PO_FULL_WAKE_STATUS) ? TRUE : FALSE;
                PopCapabilities.DiskSpinDown =
                    PopAttributes[POP_DISK_SPINDOWN_ATTRIBUTE].Count ? TRUE : FALSE;

                PopFilterCapabilities(&PopCapabilities, &Buf.SystemPowerCapabilities);

                ReturnBuffer = &Buf.SystemPowerCapabilities;
                ReturnBufferLength = sizeof(PopCapabilities);
            }
            break;

        case SystemBatteryState:
            
            //
            // Retrieve a copy of the current system battery state
            //
            if ((SafeInputBuffer) || (InputBufferLength != 0)) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                Status = PopCurrentPowerState (&Buf.SystemBatteryState);
                ReturnBuffer = &Buf.SystemBatteryState;
                ReturnBufferLength = sizeof(Buf.SystemBatteryState);
            }
            break;

        case SystemPowerStateHandler:
            
            //
            // Caller must be kernel mode with the proper parameters
            //
            if( PreviousMode != KernelMode ) {
                Status = STATUS_ACCESS_DENIED;
            } else if( (OutputBuffer) || 
                       (OutputBufferLength != 0) ||
                       (!SafeInputBuffer) || 
                       (InputBufferLength < sizeof(POWER_STATE_HANDLER)) ) {
                Status = STATUS_INVALID_PARAMETER;
            }

            //
            // Make sure the handler type is of a form that we
            // support.
            //
            if( NT_SUCCESS(Status) ) {
                PowerHandler = (PPOWER_STATE_HANDLER) SafeInputBuffer;
                HandlerType = PowerHandler->Type;

                if( HandlerType >= PowerStateMaximum ) {
                    Status = STATUS_INVALID_PARAMETER;
                }
            }

            
            //
            // Handler can only be registered once.
            //
            if( NT_SUCCESS(Status) ) {
                PowerHandler = (PPOWER_STATE_HANDLER) SafeInputBuffer;
                HandlerType = PowerHandler->Type;

                //
                // He can only be registered once UNLESS it's the
                // PowerStateShutdownOff handler.  That's because
                // we've set a default shutdown handler and would
                // sure welcome someone else (e.g. hal) to come along
                // and overwrite our default.
                //
                if( (PopPowerStateHandlers[HandlerType].Handler) ) {
                    
                    //
                    // There's already a handler here.  The only way
                    // we're going to let this request through is if
                    // they're setting the PowerStateShutdownOff
                    // handler *AND* the current handler is pointing
                    // to PopShutdownHandler().
                    //
                    if( !((HandlerType == PowerStateShutdownOff) &&
                          (PopPowerStateHandlers[HandlerType].Handler == PopShutdownHandler)) ) {
                        Status = STATUS_INVALID_PARAMETER;
                    }
                }

            }


            //
            // Set the new handler
            //
            if( NT_SUCCESS(Status) ) {
                PowerHandler = (PPOWER_STATE_HANDLER) SafeInputBuffer;
                HandlerType = PowerHandler->Type;
                    
                PopPowerStateHandlers[HandlerType] = *PowerHandler;
                PopPowerStateHandlers[HandlerType].Spare[0] = 0;
                PopPowerStateHandlers[HandlerType].Spare[1] = 0;
                PopPowerStateHandlers[HandlerType].Spare[2] = 0;
    
                CapFlag = NULL;
                RtcWake = PowerSystemUnspecified;
                switch (HandlerType) {
                    case PowerStateSleeping1:
                        if (!(PopSimulate & POP_IGNORE_S1)) {
                            CapFlag = &PopCapabilities.SystemS1;
                        }
                        RtcWake = PowerSystemSleeping1;
                        break;
    
                    case PowerStateSleeping2:
                        if (!(PopSimulate & POP_IGNORE_S2)) {
                            CapFlag = &PopCapabilities.SystemS2;
                        }
                        RtcWake = PowerSystemSleeping2;
                        break;
    
                    case PowerStateSleeping3:
                        if (!(PopSimulate & POP_IGNORE_S3)) {
                            CapFlag = &PopCapabilities.SystemS3;
                        }
                        RtcWake = PowerSystemSleeping3;
                        break;
    
                    case PowerStateSleeping4:
                        if (!(PopSimulate & POP_IGNORE_S4)) {
                            CapFlag = &PopCapabilities.SystemS4;
                        }
                        RtcWake = PowerSystemHibernate;
                        break;
    
                    case PowerStateShutdownOff:
                        CapFlag = &PopCapabilities.SystemS5;
                        break;
    
                    default:
                        break;
                }
    
                if (!PopPowerStateHandlers[HandlerType].RtcWake) {
                    RtcWake = PowerSystemUnspecified;
                }
    
                if (RtcWake > PopCapabilities.RtcWake) {
                    PopCapabilities.RtcWake = RtcWake;
                }
    
                if (CapFlag) {
                    PopSetCapability (CapFlag);
                }
            }

            break;
        
        case SystemPowerStateNotifyHandler:
            
            //
            // Caller must be kernel mode with the proper parameters
            //
            if( PreviousMode != KernelMode ) {
                Status = STATUS_ACCESS_DENIED;
            } else if( (OutputBuffer) || 
                       (OutputBufferLength != 0) ||
                       (!SafeInputBuffer) || 
                       (InputBufferLength < sizeof(POWER_STATE_NOTIFY_HANDLER)) ) {
                Status = STATUS_INVALID_PARAMETER;
            }


            //
            // Notify handler can only be registered once.
            //

            if ( NT_SUCCESS(Status) &&
                 PopPowerStateNotifyHandler.Handler &&
                ((PPOWER_STATE_NOTIFY_HANDLER)SafeInputBuffer)->Handler) {
                Status = STATUS_INVALID_PARAMETER;
            }


            //
            // Set new handler
            //
            if( NT_SUCCESS(Status) ) {
                RtlCopyMemory(&PopPowerStateNotifyHandler,
                              SafeInputBuffer,
                              sizeof(POWER_STATE_NOTIFY_HANDLER));
            }

            break;

        case ProcessorStateHandler:
        case ProcessorStateHandler2:
            //
            // Set the processor state handler.
            // Caller must be kernel mode with the proper parameters
            //
            if( PreviousMode != KernelMode ) {
                Status = STATUS_ACCESS_DENIED;
            } else if( OutputBuffer || 
                       !SafeInputBuffer ||
                       ((InformationLevel == ProcessorStateHandler2) && (InputBufferLength < sizeof(PROCESSOR_STATE_HANDLER2))) ||
                       ((InformationLevel == ProcessorStateHandler) && (InputBufferLength < sizeof(PROCESSOR_STATE_HANDLER))) ) {
                Status = STATUS_INVALID_PARAMETER;
            }

            //
            // Install handlers
            //
            if( NT_SUCCESS(Status) ) {
                try {
                    if (InformationLevel == ProcessorStateHandler2) {
                        PopInitProcessorStateHandlers2 ((PPROCESSOR_STATE_HANDLER2) SafeInputBuffer);
                    } else {
                        PopInitProcessorStateHandlers ((PPROCESSOR_STATE_HANDLER) SafeInputBuffer);
                    }
                } except (PopExceptionFilter(GetExceptionInformation(), FALSE)) {
                }

                //
                // Reset policies as capabilities may have changed
                //

                Status = PopResetCurrentPolicies ();
            }
            break;

        case SystemReserveHiberFile:
            
            //
            // Commit/Decommit storage for our hiberfile.
            //

            if( (!SafeInputBuffer) || (InputBufferLength != sizeof(BOOLEAN)) ||
                (OutputBuffer) || (OutputBufferLength != 0) ) {
                Status = STATUS_INVALID_PARAMETER;
            }


            if( NT_SUCCESS(Status) ) {

                //
                // If we're coming from usermode, release the policy lock
                // before we fiddle with the hiberfile settings.
                //
                Enable = *((PBOOLEAN) SafeInputBuffer);
                if (PreviousMode != KernelMode) {
                    //
                    // Turn into kernel mode operation.  This essentially calls back into
                    // ourselves, but it means that handles that may be opened from here on
                    // will stay around if our caller goes away.
                    //
                    PopReleasePolicyLock (FALSE);
                    Status = ZwPowerInformation(SystemReserveHiberFile,
                                                &Enable,
                                                sizeof (Enable),
                                                NULL,
                                                0);
                    PopAcquirePolicyLock ();
                    break;
                }
                
                
                Status = PopEnableHiberFile (Enable);
            }

            break;
        
        case SystemPowerInformation:

            //
            // Return PopSIdle's contents to the user.
            //
            if ((SafeInputBuffer) || (InputBufferLength != 0)) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                Buf.SystemPowerInformation.MaxIdlenessAllowed = PopSIdle.Sensitivity;
                Buf.SystemPowerInformation.Idleness = PopSIdle.Idleness;
                Buf.SystemPowerInformation.TimeRemaining = (PopSIdle.Timeout - PopSIdle.Time) * SYS_IDLE_WORKER;
                Buf.SystemPowerInformation.CoolingMode = (UCHAR) PopCoolingMode;
                ReturnBuffer = &Buf.SystemPowerInformation;
                ReturnBufferLength = sizeof(SYSTEM_POWER_INFORMATION);
            }

            break;

        case ProcessorInformation:

            //
            // Retrieve a PROCESSOR_POWER_INFORMATION structure (for each processor) for the user.
            //
            if ((SafeInputBuffer) || (InputBufferLength != 0)) {
                Status = STATUS_INVALID_PARAMETER;
            } else {

                PopProcessorInformation ( Buf.ProcessorPowerInfo, sizeof(Buf.ProcessorPowerInfo), &ReturnBufferLength );
                ReturnBuffer = &Buf.ProcessorPowerInfo;
            }
            break;

        case SystemPowerStateLogging:
            
            if (InputBuffer) {

                Status = STATUS_INVALID_PARAMETER;

            } else {
            
                Status = PopLoggingInformation (&LogBuffer,&LogBufferSize);
                ReturnBuffer = LogBuffer;
                ReturnBufferLength = LogBufferSize;
            }
            break;

        case SystemPowerLoggingEntry:
        {    
            PSYSTEM_POWER_LOGGING_ENTRY pSystemPowerLoggingEntry;

            if( (PreviousMode != KernelMode) || 
                (!InputBuffer)               ||
                (InputBufferLength != sizeof(SYSTEM_POWER_LOGGING_ENTRY)) ||
                (OutputBuffer) ) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
            
                pSystemPowerLoggingEntry = (PSYSTEM_POWER_LOGGING_ENTRY)InputBuffer; 
                //
                // if we're logging a sytem power state disable reason, 
                // insert the entry.
                //
                if (pSystemPowerLoggingEntry->LoggingType == LOGGING_TYPE_SPSD) {
                    Status = PopInsertLoggingEntry( pSystemPowerLoggingEntry->LoggingEntry );
                } else {
                    // 
                    // we've gotten a power state transition message.  
                    // This isn't implemented for this release.
                    // 
                    ASSERT( pSystemPowerLoggingEntry->LoggingType == LOGGING_TYPE_POWERTRANSITION );
                    Status = STATUS_NOT_IMPLEMENTED;
                }
            }
        }
            break;

        case LastWakeTime:


            //
            // Retrieve the timestamp of the last time we woke up.
            //
            if ((SafeInputBuffer) || (InputBufferLength != 0)) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                ReturnBuffer = &PopAction.WakeTime;
                ReturnBufferLength = sizeof(PopAction.WakeTime);
            }
            break;

        case LastSleepTime:

            //
            // Retrieve the timestamp of the last time we slept.
            //
            if ((SafeInputBuffer) || (InputBufferLength != 0)) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                ReturnBuffer = &PopAction.SleepTime;
                ReturnBufferLength = sizeof(PopAction.SleepTime);
            }
            break;

        case SystemExecutionState:

            //
            // Build and return a EXECUTION_STATE structure.
            //
            if ((SafeInputBuffer) || (InputBufferLength != 0)) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                ReturnBuffer = &Buf.SystemExecutionState;
                ReturnBufferLength = sizeof(Buf.SystemExecutionState);
                if (PopAttributes[POP_SYSTEM_ATTRIBUTE].Count) {
                    Buf.SystemExecutionState |= ES_SYSTEM_REQUIRED;
                }
                if (PopAttributes[POP_DISPLAY_ATTRIBUTE].Count) {
                    Buf.SystemExecutionState |= ES_DISPLAY_REQUIRED;
                }
                if (PopAttributes[POP_USER_ATTRIBUTE].Count) {
                    Buf.SystemExecutionState |= ES_USER_PRESENT;
                }
            }
            break;

        default:
            Status = STATUS_INVALID_PARAMETER;

    }


    //
    // If we allocated some memory for a safe local input buffer,
    // which we would only do if we got called from user-mode with
    // an InputBuffer, then free it now.
    //
    if( (PreviousMode != KernelMode) && SafeInputBuffer ) {
        ExFreePool(SafeInputBuffer);
        SafeInputBuffer = NULL;
    }


    //
    // If there's a return buffer, return it
    //
    if (NT_SUCCESS(Status)  &&  OutputBuffer  &&  ReturnBuffer) {
        if (OutputBufferLength < ReturnBufferLength) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            // be extra careful
            try {
                memcpy (OutputBuffer, ReturnBuffer, ReturnBufferLength);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }

        }
    }

    //
    // Here, we assume that if they didn't send us an input buffer,
    // then we didn't fiddle with the policy settings (i.e. we did
    // some read operation).  In that case, there's no need to go
    // check for work when we release the lock.
    //
    PopReleasePolicyLock((BOOLEAN)(InputBuffer != NULL));

    if (LogBuffer) {
        ExFreePool(LogBuffer);
    }

    return Status;
}

NTSTATUS
PopApplyAdminPolicy (
    IN BOOLEAN                      UpdateRegistry,
    IN PADMINISTRATOR_POWER_POLICY  NewPolicy,
    IN ULONG                        PolicyLength
    )
/*++

Routine Description:

    This function will verify that the incoming data looks reasonable,
    and if it does, it will copy the incoming ADMINISTRATOR_POWER_POLICY
    onto the private global PopAdminPolicy.
    
    N.B. PopPolicyLock must be held.

Arguments:

    UpdateRegistry  - TRUE if the policy being applied should be set in the register
                      as the current policy

    NewPolicy       - The policy to apply

    PolicyLength    - Length of incoming buffer (specified in bytes)

Return Value:

    None

--*/
{
    ADMINISTRATOR_POWER_POLICY  Policy;
    UNICODE_STRING              UnicodeString;
    HANDLE                      handle;
    NTSTATUS                    Status = STATUS_SUCCESS;

    
    PoAssert(PO_ERROR, (PolicyLength == sizeof(ADMINISTRATOR_POWER_POLICY)) );
    if (PolicyLength < sizeof (ADMINISTRATOR_POWER_POLICY)) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    if (PolicyLength > sizeof (ADMINISTRATOR_POWER_POLICY)) {
        return STATUS_BUFFER_OVERFLOW;
    }

    memcpy (&Policy, NewPolicy, sizeof(Policy));

    //
    // Verify values fall within proper range.  We need to be
    // careful here because these are the system overrides
    // for other policies that may try to get applied.
    //

    if (Policy.MinSleep < PowerSystemSleeping1 ||
        Policy.MinSleep > PowerSystemHibernate ||
        Policy.MaxSleep < PowerSystemSleeping1 ||
        Policy.MaxSleep > PowerSystemHibernate ||
        Policy.MinSleep > Policy.MaxSleep ||
        Policy.MinVideoTimeout > Policy.MaxVideoTimeout ||
        Policy.MinSpindownTimeout > Policy.MaxSpindownTimeout) {
        PoAssert(PO_ERROR,FALSE && ("PopApplyAdminPolicy: Bad input policy."));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the policy hasn't changed, return
    //

    if (!memcmp (&Policy, &PopAdminPolicy, sizeof(Policy))) {
        return Status;
    }

    //
    // Change it
    //

    memcpy (&PopAdminPolicy, &Policy, sizeof(Policy));

    //
    // Update registry copy of policy
    //

    if (UpdateRegistry) {

        Status = PopOpenPowerKey (&handle);
        if (NT_SUCCESS(Status)) {

            RtlInitUnicodeString (&UnicodeString, PopAdminRegName);

            Status = ZwSetValueKey (
                            handle,
                            &UnicodeString,
                            0L,
                            REG_BINARY,
                            &Policy,
                            sizeof(ADMINISTRATOR_POWER_POLICY)
                            );

            ZwClose (handle);
        }
    }

    return Status;
}

NTSTATUS
PopApplyPolicy (
    IN BOOLEAN              UpdateRegistry,
    IN BOOLEAN              AcPolicy,
    IN PSYSTEM_POWER_POLICY NewPolicy,
    IN ULONG                PolicyLength
    )
/*++

Routine Description:

    Update either the PopAcPolicy, or PopDcPolicy
    (as specified by the incoming BOOLEAN AcPolicy).

    N.B. PopPolicyLock must be held.

Arguments:

    UpdateRegistry  - TRUE if the policy being applied should be set in the register
                      as the current policy

    AcPolicy        - TRUE if the new policy is for the systems AC policy, FALSE for the DC policy

    NewPolicy       - The policy to apply
    
    PolicyLength    - Length of incoming buffer (specified in bytes)

Return Value:

    None

--*/
{
    ULONG                   i;
    BOOLEAN                 DischargeChanged;
    SYSTEM_POWER_POLICY     OrigPolicy, Policy;
    PSYSTEM_POWER_POLICY    SystemPolicy;
    PSYSTEM_POWER_LEVEL     DPolicy, SPolicy;
    UNICODE_STRING          UnicodeString;
    HANDLE                  handle;
    NTSTATUS                Status = STATUS_SUCCESS;
    const WCHAR*            RegName;

        
    PoAssert(PO_ERROR, (PolicyLength == sizeof(SYSTEM_POWER_POLICY)) );
    if (PolicyLength < sizeof (SYSTEM_POWER_POLICY)) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    if (PolicyLength > sizeof (SYSTEM_POWER_POLICY)) {
        return STATUS_BUFFER_OVERFLOW;
    }
    
    
    //
    // Setup for system policy change
    //

    if (AcPolicy) {
        RegName = PopAcRegName;
        SystemPolicy = &PopAcPolicy;
    } else {
        RegName = PopDcRegName;
        SystemPolicy = &PopDcPolicy;
    }

    //
    // Convert policy to current system capabilities
    //

    memcpy (&OrigPolicy, NewPolicy, sizeof (SYSTEM_POWER_POLICY));
    Status = PopVerifySystemPowerPolicy (AcPolicy, &OrigPolicy, &Policy);

    //
    // If the policy hasn't changed, return
    //

    if (!memcmp (&Policy, SystemPolicy, sizeof(SYSTEM_POWER_POLICY))) {
        return STATUS_SUCCESS;
    }

    //
    // Check if any discharge setting has changed
    //

    DischargeChanged = FALSE;
    DPolicy = SystemPolicy->DischargePolicy;
    SPolicy = Policy.DischargePolicy;
    for (i=0; i < PO_NUM_POWER_LEVELS; i++) {
        if (SPolicy[i].Enable != DPolicy[i].Enable) {
            DischargeChanged = TRUE;
            break;
        }

        if (SPolicy[i].Enable && memcmp (&SPolicy[i], &DPolicy[i], sizeof (SYSTEM_POWER_LEVEL))) {
            DischargeChanged = TRUE;
            break;
        }
    }

    //
    // Change it
    //

    memcpy (SystemPolicy, &Policy, sizeof(SYSTEM_POWER_POLICY));

    //
    // If this is the active policy, changes need to take effect now
    //

    if (SystemPolicy == PopPolicy) {
        //
        // Changing the active policy
        //

        PopSetNotificationWork (PO_NOTIFY_POLICY | PO_NOTIFY_POLICY_CALLBACK);

        //
        // If any discharge policy has changed, reset the composite
        // battery triggers
        //

        if (DischargeChanged) {
            PopResetCBTriggers (PO_TRG_SET | PO_TRG_SYSTEM | PO_TRG_USER);
        }

        //
        // Recompute thermal throttle and cooling mode
        //

        PopApplyThermalThrottle ();

        //
        // Recompute system idle values
        //

        PopInitSIdle ();
    }

    //
    // Update registry copy of policy
    //

    if (UpdateRegistry) {

        Status = PopOpenPowerKey (&handle);
        if (NT_SUCCESS(Status)) {

            RtlInitUnicodeString (&UnicodeString, RegName);

            Status = ZwSetValueKey (
                        handle,
                        &UnicodeString,
                        0L,
                        REG_BINARY,
                        &OrigPolicy,
                        sizeof (SYSTEM_POWER_POLICY)
                        );

            ZwClose (handle);
        }
    }

    return Status;
}

NTSTATUS
PopApplyProcessorPolicy (
    IN BOOLEAN                  UpdateRegistry,
    IN BOOLEAN                  AcPolicy,
    IN PPROCESSOR_POWER_POLICY  NewPolicy,
    IN ULONG                    PolicyLength
    )
/*++

Routine Description:

    Update either the PopAcProcessorPolicy, or PopDcProcessorPolicy
    (as specified by the incoming BOOLEAN AcPolicy).

    N.B. PopPolicyLock must be held.


    N.B. PopPolicyLock must be held.

Arguments:

    UpdateRegistry  - TRUE if the policy being applied should be set in the register
                      as the current policy

    AcPolicy        - TRUE if the new policy is for the systems AC policy, FALSE for the DC policy

    NewPolicy       - The policy to apply

Return Value:

    None

--*/
{
    PROCESSOR_POWER_POLICY  OrigPolicy;
    PROCESSOR_POWER_POLICY  Policy;
    PPROCESSOR_POWER_POLICY SystemPolicy;
    UNICODE_STRING          UnicodeString;
    HANDLE                  handle;
    NTSTATUS                Status = STATUS_SUCCESS;
    const WCHAR*            RegName;

    
    PoAssert(PO_ERROR,(PolicyLength == sizeof (PROCESSOR_POWER_POLICY)));
    
    //
    // Setup for system policy change
    //
    if (AcPolicy) {

        RegName = PopAcProcessorRegName;
        SystemPolicy = &PopAcProcessorPolicy;

    } else {

        RegName = PopDcProcessorRegName;
        SystemPolicy = &PopDcProcessorPolicy;

    }

    //
    // Convert policy to current system capabilities
    //
    if (PolicyLength < sizeof (PROCESSOR_POWER_POLICY)) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    if (PolicyLength > sizeof (PROCESSOR_POWER_POLICY)) {
        return STATUS_BUFFER_OVERFLOW;
    }
    memcpy (&OrigPolicy, NewPolicy, sizeof (PROCESSOR_POWER_POLICY));
    Status = PopVerifyProcessorPowerPolicy (AcPolicy, &OrigPolicy, &Policy);

    //
    // If the policy hasn't changed, return
    //
    if (!memcmp (&Policy, SystemPolicy, sizeof(PROCESSOR_POWER_POLICY))) {
        return STATUS_SUCCESS;
    }

    //
    // Change it
    //
    memcpy (SystemPolicy, &Policy, sizeof(PROCESSOR_POWER_POLICY));

    //
    // If this is the active policy, changes need to take effect now
    //
    if (SystemPolicy == PopProcessorPolicy) {

        //
        // Changing the active policy
        //
        PopSetNotificationWork(
            PO_NOTIFY_PROCESSOR_POLICY | PO_NOTIFY_PROCESSOR_POLICY_CALLBACK
            );

        //
        // Recompute current throttle policy....
        //
        PopUpdateAllThrottles();
        Status = PopIdleUpdateIdleHandlers();

    }

    //
    // Update registry copy of policy
    //
    if (UpdateRegistry) {

        Status = PopOpenPowerKey (&handle);
        if (NT_SUCCESS(Status)) {

            RtlInitUnicodeString (&UnicodeString, RegName);
            Status = ZwSetValueKey (
                            handle,
                            &UnicodeString,
                            0L,
                            REG_BINARY,
                            &OrigPolicy,
                            sizeof (PROCESSOR_POWER_POLICY)
                            );
            ZwClose (handle);

        }

    }

    return Status;

}

NTSTATUS
PopVerifySystemPowerPolicy (
    IN BOOLEAN  Ac,
    IN PSYSTEM_POWER_POLICY InputPolicy,
    OUT PSYSTEM_POWER_POLICY PowerPolicy
    )
/*++

Routine Description:

    This function copies the InputPolicy to the output PowerPolicy and
    adjusts it to represent system capabilities and other requirements.
    If the input policy has some setting which can not be adjusted, an
    error status is raised.

    N.B. PopPolicyLock must be held.

Arguments:

    Ac           - Policy is to be adjusted as an AC or DC policy
    InputPolicy  - The source policy to adjust
    PowerPolicy  - The returned policy which can be used as is

Return Value:

    None

--*/
{
    ULONG                   i;
    PSYSTEM_POWER_LEVEL     DPolicy;
    NTSTATUS                Status = STATUS_SUCCESS;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Ac);

    //
    // Setup initial output structure
    //
    memcpy (PowerPolicy, InputPolicy, sizeof (SYSTEM_POWER_POLICY));


    //
    // Only revision 1 currently supported
    //
    if (PowerPolicy->Revision != 1) {
        PoAssert(PO_NOTIFY, FALSE);
        return STATUS_INVALID_PARAMETER;
    }

    
    //
    // some win9x upgrades or very old NT builds might have maxsleep set to S4. Fix that here.
    //
    if (PowerPolicy->MaxSleep > PowerSystemSleeping3) {
        PowerPolicy->MaxSleep = PowerSystemSleeping3;
    }

    //
    // Limit settings to administrator policy
    //
    if (PowerPolicy->MinSleep < PopAdminPolicy.MinSleep) {

        PowerPolicy->MinSleep = PopAdminPolicy.MinSleep;

    }
    if (PowerPolicy->MaxSleep > PopAdminPolicy.MaxSleep) {

        PowerPolicy->MaxSleep = PopAdminPolicy.MaxSleep;

    }
    if (PowerPolicy->VideoTimeout < PopAdminPolicy.MinVideoTimeout) {

        PowerPolicy->VideoTimeout = PopAdminPolicy.MinVideoTimeout;

    }
    if (PowerPolicy->VideoTimeout > PopAdminPolicy.MaxVideoTimeout) {

        PowerPolicy->VideoTimeout = PopAdminPolicy.MaxVideoTimeout;

    }
    if (PowerPolicy->SpindownTimeout < PopAdminPolicy.MinSpindownTimeout) {

        PowerPolicy->SpindownTimeout = PopAdminPolicy.MinSpindownTimeout;

    }
    if ((ULONG) PowerPolicy->SpindownTimeout > (ULONG) PopAdminPolicy.MaxSpindownTimeout) {

        PowerPolicy->SpindownTimeout = PopAdminPolicy.MaxSpindownTimeout;

    }

    //
    // Verify all the power action policies, and adjust all system
    // states to match what is supported by this platform
    //
    // NOTE: Don't bother to check the return values here.  
    // These may fail here, but we should continue on.
    //
    PopVerifyPowerActionPolicy(&PowerPolicy->PowerButton);
    PopVerifyPowerActionPolicy(&PowerPolicy->SleepButton);
    PopVerifyPowerActionPolicy(&PowerPolicy->LidClose);
    PopVerifyPowerActionPolicy(&PowerPolicy->Idle);

    PopVerifySystemPowerState(
        &PowerPolicy->LidOpenWake,
        SubstituteLightestOverallDownwardBounded
        );
    PopVerifySystemPowerState(
        &PowerPolicy->MinSleep,
        SubstituteLightestOverallDownwardBounded
        );
    PopVerifySystemPowerState(
        &PowerPolicy->MaxSleep,
        SubstituteLightestOverallDownwardBounded
        );
    PopVerifySystemPowerState(
        &PowerPolicy->ReducedLatencySleep,
        SubstituteLightestOverallDownwardBounded
        );
    for (i = 0; i < PO_NUM_POWER_LEVELS; i++) {

        DPolicy = &PowerPolicy->DischargePolicy[i];
        if (DPolicy->Enable) {

            PopVerifyPowerActionPolicy (
                &PowerPolicy->DischargePolicy[i].PowerPolicy
                );
            PopVerifySystemPowerState(
                &PowerPolicy->DischargePolicy[i].MinSystemState,
                SubstituteLightestOverallDownwardBounded
                );

            //
            // If the action is standby, make sure the min state is S3 or lighter
            //
            if ((PowerPolicy->DischargePolicy[i].PowerPolicy.Action == PowerActionSleep) &&
                (PowerPolicy->DischargePolicy[i].MinSystemState > PowerSystemSleeping3)) {

                PowerPolicy->DischargePolicy[i].MinSystemState = PowerSystemSleeping3;
                PopVerifySystemPowerState(
                    &PowerPolicy->DischargePolicy[i].MinSystemState,
                    SubstituteLightestOverallDownwardBounded
                    );

            }
            if (DPolicy->BatteryLevel > 100) {

                DPolicy->BatteryLevel = 100;

            }

        }

    }
    PopVerifyPowerActionPolicy(&PowerPolicy->OverThrottled);

    //
    // Adjust other values based on capabilities
    //
    if (!PopCapabilities.ProcessorThrottle) {

        PowerPolicy->OptimizeForPower = FALSE;
        PowerPolicy->FanThrottleTolerance = PO_NO_FAN_THROTTLE;
        PowerPolicy->ForcedThrottle = PO_NO_FORCED_THROTTLE;

    }
    if (!PopCapabilities.ThermalControl) {

        PowerPolicy->FanThrottleTolerance = PO_NO_FAN_THROTTLE;

    }

    //
    // Sanity
    //
    if (!PowerPolicy->BroadcastCapacityResolution) {

        PowerPolicy->BroadcastCapacityResolution = 100;

    }

    //
    // If the system supports only S4 (legacy) there is no point in
    // idly hibernating the system as we can't turn it off anyway.
    //
    if ((PowerPolicy->Idle.Action == PowerActionHibernate) &&
        (!PopCapabilities.SystemS5)) {

        PowerPolicy->Idle.Action = PowerActionNone;

    }
    if (PowerPolicy->Idle.Action == PowerActionNone) {

        PowerPolicy->IdleTimeout = 0;

    }
    if (PowerPolicy->IdleTimeout &&
        PowerPolicy->IdleTimeout < PO_MIN_IDLE_TIMEOUT) {

        PowerPolicy->IdleTimeout = PO_MIN_IDLE_TIMEOUT;

    }
    if (PowerPolicy->IdleSensitivity > 100 - PO_MIN_IDLE_SENSITIVITY) {

        PowerPolicy->IdleSensitivity = 100 - PO_MIN_IDLE_SENSITIVITY;

    }
    if ((PowerPolicy->IdleTimeout > 0) &&
        (PowerPolicy->IdleSensitivity == 0)) {

        //
        // This is basically saying "timeout when the system has been idle
        // for X minutes, but never declare the system idle" This makes no
        // sense, so we will set the idle sensitivity to the minimum.
        //
        PowerPolicy->IdleSensitivity = 100 - PO_MIN_IDLE_SENSITIVITY;

    }
    if (PowerPolicy->MaxSleep < PowerPolicy->MinSleep) {

        PowerPolicy->MaxSleep = PowerPolicy->MinSleep;

    }
    if (PowerPolicy->ReducedLatencySleep > PowerPolicy->MinSleep) {

        PowerPolicy->ReducedLatencySleep = PowerPolicy->MinSleep;

    }

    //
    // Ignore whatever the user said what the minimum throttle and force the
    // system to pick whatever the hardware supports as the min throttle
    //
    PowerPolicy->MinThrottle = 0;

    //
    // Verify all the throttle percentages which are defined to be
    // between 0 and 100.  PopVerifyThrottle will ensure the values
    // are something sane.
    //
    PopVerifyThrottle(&PowerPolicy->FanThrottleTolerance, PO_MAX_FAN_THROTTLE);
    PopVerifyThrottle(&PowerPolicy->MinThrottle, PO_MIN_MIN_THROTTLE);
    PopVerifyThrottle(&PowerPolicy->ForcedThrottle, PowerPolicy->MinThrottle);

    if (PowerPolicy->FanThrottleTolerance != PO_NO_FAN_THROTTLE ||
        PowerPolicy->ForcedThrottle != PO_NO_FORCED_THROTTLE) {

        PowerPolicy->OptimizeForPower = TRUE;

    }

    return Status;

}

NTSTATUS
PopVerifyProcessorPowerPolicy (
    IN BOOLEAN  Ac,
    IN PPROCESSOR_POWER_POLICY InputPolicy,
    OUT PPROCESSOR_POWER_POLICY PowerPolicy
    )
/*++

Routine Description:

    This function copies the InputPolicy to the output PowerPolicy and
    adjusts it to represent processor capabilities and other requirements.
    If the input policy has some setting which can not be adjusted, an
    error status is raised.

    N.B. PopPolicyLock must be held.

Arguments:

    Ac           - Policy is to be adjusted as an AC or DC policy
    InputPolicy  - The source policy to adjust
    PowerPolicy  - The returned policy which can be used as is

Return Value:

    None

--*/
{
    PPROCESSOR_POWER_POLICY_INFO    pPolicy;
    ULONG                           i;
    NTSTATUS                        Status = STATUS_SUCCESS;


    PAGED_CODE();

    
    //
    // Setup initial output structure
    //
    memcpy (PowerPolicy, InputPolicy, sizeof(PROCESSOR_POWER_POLICY));

    //
    // Only revision 1 currently supported
    //
    if (PowerPolicy->Revision != 1) {
        PoAssert(PO_NOTIFY, FALSE);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Sanity check each level of the policy
    //
    for (i = 0; i < 3; i++) {

        pPolicy = &(PowerPolicy->Policy[i]);

        //
        // We don't allow demotion to Idle0 unless the machine is MP
        //
        if (i == 0 && KeNumberProcessors == 1) {

           pPolicy->DemotePercent = 0;
           pPolicy->AllowDemotion = 0;

        }

        //
        // Don't allow promotions past the last state
        //
        if (i == 2) {

            pPolicy->PromotePercent = 0;
            pPolicy->PromoteLimit   = 0;
            pPolicy->AllowPromotion = 0;

        }

        //
        // Time check must be smaller than Demote Limit (if there is one)
        //
        if (pPolicy->TimeCheck < pPolicy->DemoteLimit) {

            pPolicy->TimeCheck = pPolicy->DemoteLimit;

        }

        if (pPolicy->DemotePercent == 0 &&
            pPolicy->AllowPromotion &&
            pPolicy->TimeCheck < pPolicy->PromoteLimit) {

            pPolicy->TimeCheck = pPolicy->PromoteLimit;

        }

    }

    if (PowerPolicy->DynamicThrottle >= PO_THROTTLE_MAXIMUM) {

        if (Ac) {

            PowerPolicy->DynamicThrottle = PO_THROTTLE_NONE;

        } else {

            PowerPolicy->DynamicThrottle = PO_THROTTLE_CONSTANT;

        }

    }


    return Status;

}

VOID
PopVerifyThrottle (
    IN PUCHAR   Throttle,
    IN UCHAR    Min
    )
/*++

Routine Description:

    This function checks & edits the input throttle value, ensuring
    it's at least as big as 'Min', but smaller than POP_PERF_SCALE.
    
    The resulting percentage is then rounded.

Arguments:

    Throttle    - pointer to a uchar which contains some value
                  which represents a percentage between 0 and 100.
    
    Min         - Minimum percentage we need to check against.

Return Value:

    Boolean to indicate action was demoted to a disabled state

--*/
{
    UCHAR   t;

    if( !Throttle ) {
        return;
    }
    
    t = *Throttle;

    //
    // Make sure it's not below the specificied min.
    //
    if (t < Min) {
        t = Min;
    }

    //
    // Make sure max is POP_PERF_SCALE%
    //
    if (t > POP_PERF_SCALE) {
        t = POP_PERF_SCALE;
    }

    //
    // Round the throttle up to the first supported value
    // Note that we don't need to check against ProcessorMinThrottle
    // or any other value since PopRoundThrottle() will do that for us.
    //

    PopRoundThrottle(t, NULL, Throttle, NULL, NULL);

}


BOOLEAN
PopVerifyPowerActionPolicy (
    IN PPOWER_ACTION_POLICY Action
    )
/*++

Routine Description:

    This function checks & edits the input Action to represent
    system capabilities and other requirements.

    N.B. PopPolicyLock must be held.

Arguments:

    Action      - Power action policy to check / verify

Return Value:

    Boolean to indicate action was demoted to a disabled state

--*/
{
    POWER_ACTION    LastAction;
    BOOLEAN         Disabled = FALSE;
    BOOLEAN         HiberSupport;
    ULONG           SleepCount;
    NTSTATUS        Status;
    PNP_VETO_TYPE   VetoType;
    SYSTEM_POWER_CAPABILITIES   PowerCapabilities;

    PAGED_CODE();

    if( !Action ) {
        return FALSE;
    }

    //
    // Verify reserved flag bits are clear
    //

    if( (!Action) ||
        ARE_POWER_ACTION_POLICY_FLAGS_BOGUS(Action->Flags) ) {

        //
        // N.B. - Later POWER_ACTION_LIGHTEST_FIRST?
        //

        // reserved bit set in action flags
        
        PoAssert(PO_NOTIFY,FALSE && ("PopVerifyPowerActionPolicy - Bad incoming Action."));
        return FALSE;
    }

    //
    // If the action is critical, then do not notify any applications
    //

    if (Action->Flags & POWER_ACTION_CRITICAL) {
        Action->Flags &= ~(POWER_ACTION_QUERY_ALLOWED | POWER_ACTION_UI_ALLOWED);
        Action->Flags |= POWER_ACTION_OVERRIDE_APPS;
    }

    //
    // If any legacy drivers are installed, then no sleeping states
    // are allowed at all.
    //
    if ((Action->Action == PowerActionSleep) ||
        (Action->Action == PowerActionHibernate)) {

        Status = IoGetLegacyVetoList(NULL, &VetoType);
        if (NT_SUCCESS(Status) &&
            (VetoType != PNP_VetoTypeUnknown)) {

            Action->Action = PowerActionNone;
            return(TRUE);
        }
    }

    //
    // Some components may disable some capabilities.  So filter them here.
    //

    PopFilterCapabilities(&PopCapabilities, &PowerCapabilities);

    //
    // Count the supported sleeping states
    //

    SleepCount = 0;
    HiberSupport = FALSE;
    if (PowerCapabilities.SystemS1) {
        SleepCount += 1;
    }

    if (PowerCapabilities.SystemS2) {
        SleepCount += 1;
    }

    if (PowerCapabilities.SystemS3) {
        SleepCount += 1;
    }

    if (PowerCapabilities.SystemS4  &&  PowerCapabilities.HiberFilePresent) {
        HiberSupport = TRUE;
    }

    //
    // Verify the requested action is supported.
    //

    do {
        LastAction = Action->Action;
        switch (Action->Action) {
            case PowerActionNone:
                // can do nothing, not a problem
                break;

            case PowerActionReserved:
                // used to be doze action.  does not exist anymore make it sleep,
                // 
                // N.B. Intentionally fall through to the PowerActionSleep 
                // block to perform further checks.
                Action->Action = PowerActionSleep;
            
            case PowerActionSleep:
                //
                // if no sleeping states supported, adjust action to be none
                //

                if (SleepCount < 1) {
                    Disabled = TRUE;
                    Action->Action = PowerActionNone;
                }
                break;

            case PowerActionHibernate:
                //
                // if no hibernate support, try sleep
                //

                if (!HiberSupport) {
                    Action->Action = PowerActionSleep;

                    // if no sleeping states supported, adjust action to be none
                    if (SleepCount < 1) {
                        Disabled = TRUE;
                        Action->Action = PowerActionNone;
                    }
                }
                break;

            case PowerActionShutdown:
            case PowerActionShutdownReset:
                // all systems support shutdown & shutdown reset
                break;

            case PowerActionShutdownOff:
                // If action shutdown is not available, use Shutdown
                if (!PowerCapabilities.SystemS5) {
                    Action->Action = PowerActionShutdown;
                }
                break;

            case PowerActionWarmEject:
                //
                // This is a system action associated with an individual device.
                //

                break;

            default:
                // unknown power action setting
                PoAssert( PO_NOTIFY, FALSE );
        }

    } while (LastAction != Action->Action);

    return Disabled;
}

VOID
PopAdvanceSystemPowerState (
    IN OUT PSYSTEM_POWER_STATE      PowerState,
    IN     POP_SUBSTITUTION_POLICY  SubstitutionPolicy,
    IN     SYSTEM_POWER_STATE       LightestSystemState,
    IN     SYSTEM_POWER_STATE       DeepestSystemState
    )
/*++

Routine Description:

    This function uses the substitution policy to advance the sleep state
    (lighten or deepen) as appropriate.

    N.B. PopPolicyLock must be held.

Arguments:

    PowerState         - System power state to advance.

    SubstitutionPolicy - see definitions in pop.h.

Return Value:

    None

--*/
{
    SYSTEM_POWER_STATE      State;

    PAGED_CODE();

    //
    // Verify value is valid
    //
    if( !PowerState ) {
        PoAssert(PO_NOTIFY, PowerState);
        return;
    }

    State = *PowerState;
    if (State < PowerSystemSleeping1) {
        PoAssert(PO_NOTIFY, FALSE && ("PopAdvanceSystemPowerState - Invalid PowerState"));
        return;
    }

    if (State >= PowerSystemShutdown) {

        //
        // There is nowhere else to go for these states.
        //
        *PowerState = PowerSystemWorking;
        return;
    }

    switch(SubstitutionPolicy) {

        case SubstituteLightestOverallDownwardBounded:
            *PowerState = (State - 1);
            PopVerifySystemPowerState(PowerState, SubstitutionPolicy);

            //
            // There are three cases to consider:
            // 1. We received in S1, which was previously validated. We try S0
            //    and it is automatically accepted. There are no other options
            //    as we started in the lightest overall (S1). Thus we are
            //    finished.
            // 2. We passed in Sx-1 for verification, but got back Sx. This
            //    means we were already at the lightest state (Sx), and we've
            //    exhausted the possibilities. Thus we are finished and so
            //    we return PowerSystemWorking.
            // 3. We passed in Sx-1 and didn't get Sx. This means we've advanced
            //    to another state, although it may be the last if Sx was S1, as
            //    rule (1) is actually a special case of this rule.
            //
            if (*PowerState == State) {

                *PowerState = PowerSystemWorking;
            }
            break;

        case SubstituteLightenSleep:
            *PowerState = (State - 1);
            PopVerifySystemPowerState(PowerState, SubstitutionPolicy);
            break;

        case SubstituteDeepenSleep:
            //
            // Per above, Deepen goes straight into Hibernate.
            //
            if (State == PowerSystemHibernate) {

                *PowerState = PowerSystemWorking;
                break;

            }
            *PowerState = (State + 1);
            PopVerifySystemPowerState(PowerState, SubstitutionPolicy);
            break;

        default:
            PoAssert( PO_NOTIFY, FALSE );
            break;
    }

    if ((*PowerState != PowerSystemWorking) &&
        ((*PowerState < LightestSystemState) ||
         (*PowerState > DeepestSystemState))) {

        *PowerState = PowerSystemWorking;
    }
}


VOID
PopVerifySystemPowerState (
    IN OUT PSYSTEM_POWER_STATE      PowerState,
    IN     POP_SUBSTITUTION_POLICY  SubstitutionPolicy
    )
/*++

Routine Description:

    This function checks & edits the input PowerState to represent
    system capabilities and other requirements.

    N.B. PopPolicyLock must be held.

Arguments:

    PowerState         - System power state to check / verify

    SubstitutionPolicy - See definitions in pop.h

Return Value:

    None

--*/
{
    SYSTEM_POWER_STATE      State;
    BOOLEAN                 HibernateAllowed;

    PAGED_CODE();

    //
    // Verify input
    //
    if( !PowerState ) {
        PoAssert(PO_NOTIFY, PowerState);
        return;
    }



    //
    // PowerSystemShutdown is not allowed in any structures.  It is generated
    // internally for the sole use of quering drivers before performing
    // a system shutdown
    //
    State = *PowerState;
    if( (State == PowerSystemUnspecified) ||
        (State >= PowerSystemShutdown) ) {
        PoAssert(PO_NOTIFY, FALSE && ("PopVerifySystemPowerState - Invalid PowerState"));
        return;
    }


    //
    // The working state is always supported
    //

    if (State == PowerSystemWorking) {
        return ;
    }

    //
    // Verify the power state is supported.  If not, pick the next best state
    //
    HibernateAllowed = TRUE;

    switch(SubstitutionPolicy) {

        case SubstituteLightestOverallDownwardBounded:
        case SubstituteLightenSleep:

            //
            // In LightenSleep, we lighten the power state passed in until
            // we reach PowerStateWorking. Then we give up.
            //
            // In LightestOverall, instead of stopping, we turn around and
            // choose the lightest non-S0 sleep state overall, which may be
            // deeper than the one passed in. Note that we do *not* progress
            // into Hibernation though.
            //

            if (State == PowerSystemHibernate &&
                (!PopCapabilities.SystemS4 || !PopCapabilities.HiberFilePresent)) {
                State = PowerSystemSleeping3;
            }
            if (State == PowerSystemSleeping3 && !PopCapabilities.SystemS3) {
                State = PowerSystemSleeping2;
            }
            if (State == PowerSystemSleeping2 && !PopCapabilities.SystemS2) {
                State = PowerSystemSleeping1;
            }
            if (State == PowerSystemSleeping1 && !PopCapabilities.SystemS1) {
                State = PowerSystemWorking;
            }

            if (State != PowerSystemWorking) {
                break;
            }

            if (SubstitutionPolicy != SubstituteLightestOverallDownwardBounded) {
                break;
            }

            //
            // Rounding down lead to PowerSystemWorking.  Try to rounding up
            // towards deeper sleep states. Block the rounding at S3 however.
            //
            State = State + 1;
            HibernateAllowed = FALSE;

            //
            // Fall through...
            //

        case SubstituteDeepenSleep:

            if (State == PowerSystemSleeping1 && !PopCapabilities.SystemS1) {
                State = PowerSystemSleeping2;
            }
            if (State == PowerSystemSleeping2 && !PopCapabilities.SystemS2) {
                State = PowerSystemSleeping3;
            }
            if (State == PowerSystemSleeping3 && !PopCapabilities.SystemS3) {
                State = PowerSystemHibernate;
            }

            if (State == PowerSystemHibernate &&
                (!HibernateAllowed ||
                 !PopCapabilities.SystemS4 ||
                 !PopCapabilities.HiberFilePresent)) {

                // nothing good supported, disable it
                State = PowerSystemWorking;
            }

            break;

        default:
            PoAssert(PO_NOTIFY, FALSE && ("PopVerifySystemPowerState - Invalid substitution policy."));
            break;
    }

    *PowerState = State;
}

NTSTATUS
PopResetCurrentPolicies (
    VOID
    )
/*++

Routine Description:

    Reads the current policies from the registry and applies them.

    N.B. PopPolicyLock must be held.

Arguments:

    None

Return Value:

    None

--*/
{
    HANDLE                          handle;
    NTSTATUS                        Status = STATUS_SUCCESS;
    PSYSTEM_POWER_POLICY            RegPolicy;
    UNICODE_STRING                  UnicodeString;
    ULONG                           Length;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION  Inf;
        union {
            SYSTEM_POWER_POLICY        PowerPolicy;
        } Data;
    } PartialInformation;

    ASSERT_POLICY_LOCK_OWNED();

    //
    // Initialize & open registry
    //

    RegPolicy = (PSYSTEM_POWER_POLICY) PartialInformation.Inf.Data;

    Status = PopOpenPowerKey (&handle);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Read AC policy and apply it
    //

    RtlInitUnicodeString (&UnicodeString, PopAcRegName);
    Status = ZwQueryValueKey (
                    handle,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    &PartialInformation,
                    sizeof (PartialInformation),
                    &Length
                    );

    if (!NT_SUCCESS(Status)) {
        PopDefaultPolicy (RegPolicy);
        Length = sizeof(SYSTEM_POWER_POLICY);
    } else {
        Length -= FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
    }

    PopApplyPolicy (FALSE, TRUE, RegPolicy, Length);

    //
    // Read DC policy and apply it
    //

    RtlInitUnicodeString (&UnicodeString, PopDcRegName);
    Status = ZwQueryValueKey (
                    handle,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    &PartialInformation,
                    sizeof (PartialInformation),
                    &Length
                    );

    if (!NT_SUCCESS(Status)) {
        PopDefaultPolicy (RegPolicy);
        Length = sizeof(SYSTEM_POWER_POLICY);
    } else {
        Length -= FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
    }

    Status = PopApplyPolicy (FALSE, FALSE, RegPolicy, Length);

    ZwClose (handle);

    return Status;
}


NTSTATUS
PopNotifyPolicyDevice (
    IN PVOID        Notification,
    IN PVOID        Context
    )
/*++

Routine Description:

    This function is the notinficant handle for when a new
    policy device appears.

Arguments:

    Notification    - PnP notification

    Context         - Context registered on notification

Return Value:

    None

--*/
{
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION   Change;
    POP_POLICY_DEVICE_TYPE              DeviceType;


    //
    // It's okay for Context to come in as NULL, so only
    // check Notification.
    //
    if( !Notification ) {
        PoAssert(PO_NOTIFY, Notification);
        return STATUS_INVALID_PARAMETER;
    }

    PAGED_CODE();

    Change = (PDEVICE_INTERFACE_CHANGE_NOTIFICATION) Notification;
    DeviceType = (POP_POLICY_DEVICE_TYPE) ((ULONG_PTR)Context);

    //
    // If it's not a device arrival, then we don't care
    //

    if (memcmp (&Change->Event, &GUID_DEVICE_INTERFACE_ARRIVAL, sizeof (GUID))) {
        return STATUS_SUCCESS;
    }

    PopAcquirePolicyLock ();
    PopConnectToPolicyDevice (DeviceType, Change->SymbolicLinkName);
    PopReleasePolicyLock (TRUE);
    return STATUS_SUCCESS;
}


VOID
PopConnectToPolicyDevice (
    IN POP_POLICY_DEVICE_TYPE   DeviceType,
    IN PUNICODE_STRING          DriverName
    )
/*++

Routine Description:

    This function attempts to connect to the policy device specified.
    If the device is opened, the devices status IRP is allocated and
    sent to the device's IRP handler for initial dispatch.

Arguments:

    DeviceType      - Policy device type of device to connect

    DeviceName      - Device name to attempt to open

Return Value:

    If the device is connected, the *PresetFlag is set to TRUE and
    an initial IRP is queued for the IRP handler.

--*/
{
    UNICODE_STRING              UnicodeString;
    HANDLE                      DriverHandle;
    PDEVICE_OBJECT              DeviceObject;
    PFILE_OBJECT                FileObject;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    PIRP                        Irp;
    PIO_STACK_LOCATION          IrpSp;
    PVOID                       Context;
    POP_IRP_HANDLER             IrpHandler;
    PPOP_SWITCH_DEVICE          SwitchDevice;
    PPOP_THERMAL_ZONE           ThermalZone;
    NTSTATUS                    Status;

    PAGED_CODE();

    ASSERT_POLICY_LOCK_OWNED();

    Irp = NULL;
    DeviceObject = NULL;

    //
    // If this is a new battery, then handle the composite battery device is
    // the device to open
    //
    if (DeviceType == PolicyDeviceBattery) {

        //
        // If the composite battery is already opened, kick the irp handler
        //
        if (PopCB.StatusIrp) {

            // Don't need to kick the IRP handler.  When a new battery is added,
            // the battery tag for the composite battery will change, causing
            // the irp to complete.
            PoPrint(PO_WARN, ("PopConnectToPolicyDevice: Battery already connected - not done\n"));
            return ;

        }

        //
        // Try to open the composite battery now
        //
        RtlInitUnicodeString(&UnicodeString, PopCompositeBatteryName);
        DriverName = &UnicodeString;

    }

    //
    // Open the device
    //
    InitializeObjectAttributes(
        &ObjA,
        DriverName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        0
        );
    Status = ZwOpenFile(
        &DriverHandle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &ObjA,                              // Object
        &IOSB,                              // io status block
        FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
        FILE_SYNCHRONOUS_IO_ALERT           // open options
        );
    if (!NT_SUCCESS(Status)) {
        PoPrint(PO_WARN, ("PopConnectToPolicyDevice: Device open failed %x\n", Status));
        goto Done;

    }

    //
    // Get a pointer to the device object
    //
    Status = ObReferenceObjectByHandle(
        DriverHandle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,     // desired access
        NULL,
        KernelMode,
        &FileObject,
        NULL
        );
    ASSERT (NT_SUCCESS(Status));
    
    DeviceObject = IoGetAttachedDeviceReference(FileObject->DeviceObject);
    PoAssert(PO_ERROR, (DeviceObject != NULL));
    ObDereferenceObject(FileObject);
    ZwClose(DriverHandle);

    if (!NT_SUCCESS(Status)) {
        PoPrint(PO_WARN, ("PopConnectToPolicyDevice: ObReferenceObjectByHandle failed %x\n", Status));
        goto Done;

    }

    //
    // Get an IRP for the device
    //
    Irp = IoAllocateIrp ((CCHAR) (DeviceObject->StackSize + 1), FALSE);
    if (!Irp) {
        goto Done;
    }

    IrpSp = IoGetNextIrpStackLocation(Irp);

    //
    // Setup based on device type
    //
    Context = NULL;
    IrpHandler = NULL;

    switch (DeviceType) {
        case PolicyDeviceSystemButton:
            SwitchDevice = ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof (*SwitchDevice),
                POP_PSWT_TAG
                );
            if (!SwitchDevice) {
                PoPrint(PO_WARN, ("PopConnectToPolicyDevice: ExAllocatePoolWithTag for SystemButton (%x) failed\n", sizeof (*SwitchDevice)));
                goto Done;
            }

            RtlZeroMemory (SwitchDevice, sizeof(*SwitchDevice));
            SwitchDevice->IsInitializing = TRUE;
            SwitchDevice->Opened = TRUE;
            InsertTailList (&PopSwitches, &SwitchDevice->Link);
            IrpHandler = PopSystemButtonHandler;
            Context = SwitchDevice;
            break;

       case PolicyDeviceBattery:

            //
            // Loading up the composite battery - status irp is NULL.
            //
            PopSetCapability (&PopCapabilities.SystemBatteriesPresent);
            IrpHandler = PopCompositeBatteryDeviceHandler;
            PopCB.StatusIrp = Irp;
            break;

       case PolicyDeviceThermalZone:

            //
            // New thermal zone
            //
            ThermalZone = ExAllocatePoolWithTag (
                NonPagedPool,
                sizeof (*ThermalZone),
                POP_THRM_TAG
                );
            if (!ThermalZone) {
                PoPrint(PO_WARN, ("PopConnectToPolicyDevice: ExAllocatePoolWithTag for ThermalZone (%x) failed\n", sizeof (*ThermalZone)));
                goto Done;

            }

            //
            // Initialize thermal zone structure
            //
            RtlZeroMemory(
                ThermalZone,
                sizeof(POP_THERMAL_ZONE)
                );
            KeInitializeTimer(&ThermalZone->PassiveTimer);
            KeInitializeDpc(
                &ThermalZone->PassiveDpc,
                PopThermalZoneDpc,
                ThermalZone
                );
            ThermalZone->Mode = PO_TZ_INVALID_MODE;
            ThermalZone->ActivePoint = (UCHAR) -1;
            ThermalZone->PendingActivePoint = (UCHAR) -1;
            ThermalZone->Throttle = PO_TZ_NO_THROTTLE;
            ThermalZone->OverThrottled.Type = PolicyDeviceThermalZone;
            ThermalZone->OverThrottled.Flags = PO_TRG_SET;
            ThermalZone->Irp = Irp;

            //
            // Setup the capabilities of the thermal zones and get ready to
            // ask the thermal zone about itself...
            //
            PopSetCapability (&PopCapabilities.ThermalControl);
            Context = ThermalZone;
            IrpHandler = PopThermalDeviceHandler;

            //
            // Finally, add the thermal zone to the list of thermal zones
            //
            ExInterlockedInsertTailList(
                &PopThermal,
                &ThermalZone->Link,
                &PopThermalLock
                );

            break;

        default:
            PopInternalError (POP_INFO);
    }

    //
    // Fill in values for IrpHandler dispatch
    //
    IrpSp->Parameters.Others.Argument1 = (PVOID) DeviceObject;
    IrpSp->Parameters.Others.Argument2 = (PVOID) Context;
    IrpSp->Parameters.Others.Argument3 = (PVOID) IrpHandler;
    IoSetNextIrpStackLocation (Irp);

    //
    // Fill in error to irp so irp handler will re-dispatch it
    //
    IrpSp = IoGetNextIrpStackLocation(Irp);
    Irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
    IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    IrpSp->Parameters.DeviceIoControl.IoControlCode = 0;
    IrpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
    IrpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;

    //
    // Give irp to the completion handler which will dispatch it
    //
    PopCompletePolicyIrp (DeviceObject, Irp, Context);
    
    //
    // set Irp and DeviceObject to NULL so we don't delete them upon
    // exiting this routine
    //
    Irp = NULL;
    DeviceObject = NULL;

Done:
    if (Irp) {
        IoFreeIrp (Irp);
    }

    if (DeviceObject) {
        ObDereferenceObject( DeviceObject );
    }

}

POWER_ACTION
PopMapInternalActionToIrpAction (
    IN POWER_ACTION        Action,
    IN SYSTEM_POWER_STATE  SystemPowerState,
    IN BOOLEAN             UnmapWarmEject
    )
/*++

Routine Description:

    This function maps an internal action and power state to the appropriate
    PowerAction a driver should see in it's S-IRP.

Arguments:

    Action           - The action we are using internally

    SystemPowerState - The system power state for that action

    UnmapWarmEject   - If TRUE, PowerActionWarmEject is converted to
                       PowerActionSleep or PowerActionHibernate as appropriate.

Return Value:

    The appropriate PowerAction to place in the ShutdownType field of an S-IRP.

--*/
{
    PoAssert(PO_NOTIFY, (Action != PowerActionHibernate));

    if (Action != PowerActionWarmEject) {

        //
        // We aren't doing a warm eject, so we simply return the original
        // power action unless it's the sleep is S4, in which case we switch
        // it to PowerActionHibernate.
        //

        return (SystemPowerState != PowerSystemHibernate) ? Action :
                                                            PowerActionHibernate;
    }

    if (UnmapWarmEject) {

        //
        // This is a warm eject operation, but not neccessarily for this device.
        //

        return (SystemPowerState != PowerSystemHibernate) ? PowerActionSleep :
                                                            PowerActionHibernate;
    }

    //
    // This is a warm eject operation, so we should only see a sleep state
    // (S1-S4). We do the check here because we could get a D0 request in
    // response to our S IRP, and stamp D-IRPs with the current power action.
    //

    PoAssert( PO_NOTIFY,
              (SystemPowerState >= PowerSystemSleeping1) && (SystemPowerState <= PowerSystemHibernate) );

    return PowerActionWarmEject;
}


VOID
PopFilterCapabilities(
    IN PSYSTEM_POWER_CAPABILITIES SourceCapabilities,
    OUT PSYSTEM_POWER_CAPABILITIES FilteredCapabilities
    )
/*++

Routine Description:

    This routine filters the actual reported capabilities of the system into
    the visible capabilities of the system. Some capabilities will be hidden
    based on the presence of legacy drivers.

Arguments:

    SourceCapabilities - Supplies the original capabilities

    FilteredCapabilities - Returns the filtered capabilities.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PNP_VETO_TYPE VetoType;
    PWSTR VetoList,p;
    SIZE_T VetoListLength;
    PSYSTEM_POWER_STATE_DISABLE_REASON pReason;
    PLIST_ENTRY NextEntry;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    UNICODE_STRING UniVga;

    PAGED_CODE();

    RtlCopyMemory(FilteredCapabilities, SourceCapabilities, sizeof(SYSTEM_POWER_CAPABILITIES));

    //
    // If any legacy drivers are installed, then no sleeping states
    // are allowed at all.
    //
    Status = IoGetLegacyVetoList(&VetoList, &VetoType);
    if (NT_SUCCESS(Status)) {
        if (VetoType != PNP_VetoTypeUnknown) {

            PoPrint(PO_WARN,
                    ("PopFilterCapabilities: disabling sleep states due to legacy %s: %ws\n",
                    (VetoType == PNP_VetoLegacyDriver) ? "driver" : "device",
                    VetoList));
            FilteredCapabilities->SystemS1 = FALSE;
            FilteredCapabilities->SystemS2 = FALSE;
            FilteredCapabilities->SystemS3 = FALSE;
            FilteredCapabilities->SystemS4 = FALSE;

            //
            // try to remember that we're turning off S1-S4 because of this.
            //
            // We need to record the list of drivers causing the veto,
            // so we walk to VetoList to get the length.
            //
            VetoListLength = 0;
            p = VetoList;
            while(*p) {
                VetoListLength += (wcslen(p)+1)*sizeof(WCHAR);
                p = (PWSTR)((PCHAR)VetoList + VetoListLength);
            }

            VetoListLength += 1*sizeof(WCHAR);

            //
            // alloc and initialize the entry, then insert it.
            //
            pReason = ExAllocatePoolWithTag(
                                    PagedPool,
                                    sizeof(SYSTEM_POWER_STATE_DISABLE_REASON) + VetoListLength,
                                    POP_COMMON_BUFFER_TAG);
            if (pReason) {
                RtlZeroMemory(pReason,sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
                pReason->AffectedState[PowerStateSleeping1] = TRUE;
                pReason->AffectedState[PowerStateSleeping2] = TRUE;
                pReason->AffectedState[PowerStateSleeping3] = TRUE;
                pReason->AffectedState[PowerStateSleeping4] = TRUE;
                pReason->PowerReasonCode = SPSD_REASON_LEGACYDRIVER;
                pReason->PowerReasonLength = (ULONG)VetoListLength;
                RtlCopyMemory(
                        (PCHAR)((PCHAR)pReason+sizeof(SYSTEM_POWER_STATE_DISABLE_REASON)),
                        VetoList,
                        VetoListLength);
                
                Status = PopInsertLoggingEntry(pReason);
                if (Status != STATUS_SUCCESS) {
                    ExFreePool(pReason);
                }
                
            }


        }
        if (VetoList != NULL) {
            ExFreePool(VetoList);
        }
    }

#if defined(i386)    

    if (SharedUserData->ProcessorFeatures[PF_PAE_ENABLED]) {
	
        //
        // Enable hibernation in PAE mode when
        //   - all physical pages live in 32bit address space
        //   - no-execute feature is enabled
        //   - total memory <= 2GB ( Note: This is an artificial 
        //     restriction. This should be removed in future.)
        //

        if (MmHighestPhysicalPage >= (1 << (32 - PAGE_SHIFT)) ||
            !(MmPaeMask & 0x8000000000000000UI64) ||
            SharedUserData->NumberOfPhysicalPages > (1 << (31 - PAGE_SHIFT))) {

            FilteredCapabilities->SystemS4 = FALSE;

            //
            // try to remember that we're turning off S4 because of this
            //

            pReason = ExAllocatePoolWithTag(
                                    PagedPool,
                                    sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                                    POP_COMMON_BUFFER_TAG);
            if (pReason) {
                RtlZeroMemory(pReason,sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
                pReason->AffectedState[PowerStateSleeping4] = TRUE;
                pReason->PowerReasonCode = SPSD_REASON_PAEMODE;
            
                Status = PopInsertLoggingEntry(pReason);
                if (Status != STATUS_SUCCESS) {
                        ExFreePool(pReason);
                }
            }    
        }
    }

#endif

#if defined(_AMD64_)   

    //
    // If physical memory is more than 4GBytes then hibernation is disabled
    //

    if (MmHighestPhysicalPage >= (1 << (32 - PAGE_SHIFT))) {
        FilteredCapabilities->SystemS4 = FALSE;

        //
        // try to remember that we're turning off S4 because of this
        //

        pReason = ExAllocatePoolWithTag(
                                PagedPool,
                                sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                                POP_COMMON_BUFFER_TAG);
        if (pReason) {
            RtlZeroMemory(pReason,sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
            pReason->AffectedState[PowerStateSleeping4] = TRUE;
            pReason->PowerReasonCode = SPSD_REASON_NOOSPM;
            
            Status = PopInsertLoggingEntry(pReason);
            if (Status != STATUS_SUCCESS) {
                    ExFreePool(pReason);
            }
            
        }
    }

#endif

    //
    // The pnp VGA driver prevents all standby states.  If it's loaded
    // then we have to disable S1-S3.  This is because it will veto it
    // anyway, and we want to avoid potential confusion for the user by
    // just preventing the functionality.
    //
    RtlInitUnicodeString(&UniVga,L"VGAPNP.SYS");
    NextEntry = PsLoadedModuleList.Flink;
    while (NextEntry != &PsLoadedModuleList) {

        DataTableEntry = CONTAINING_RECORD (NextEntry,
                                            KLDR_DATA_TABLE_ENTRY,
                                            InLoadOrderLinks);
    
        if (RtlEqualUnicodeString (&UniVga,
                                   &DataTableEntry->BaseDllName,
                                   TRUE)) {
            FilteredCapabilities->SystemS1 = FALSE;
            FilteredCapabilities->SystemS2 = FALSE;
            FilteredCapabilities->SystemS3 = FALSE;
            //
            // try to remember that we're turning off S1-S3 because of this
            //
            pReason = ExAllocatePoolWithTag(
                                    PagedPool,
                                    sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                                    POP_COMMON_BUFFER_TAG);
            if (pReason) {
                RtlZeroMemory(pReason,sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
                pReason->AffectedState[PowerStateSleeping1] = TRUE;
                pReason->AffectedState[PowerStateSleeping2] = TRUE;
                pReason->AffectedState[PowerStateSleeping3] = TRUE;
                pReason->PowerReasonCode = SPSD_REASON_DRIVERDOWNGRADE;
                
                Status = PopInsertLoggingEntry(pReason);
                if (Status != STATUS_SUCCESS) {
                    ExFreePool(pReason);
                }
                
            }

            break;
        }

        NextEntry = NextEntry->Flink;
    }

    //
    // If we previously tried and failed to hibernate, then we need to 
    // disable any further attempts.
    //
    if( PopFailedHibernationAttempt ) {
        //
        // try to remember that we're turning off S4 because of this
        //
        pReason = ExAllocatePoolWithTag(
                                PagedPool,
                                sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                                POP_COMMON_BUFFER_TAG);
        if (pReason) {
            RtlZeroMemory(pReason,sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
            pReason->AffectedState[PowerStateSleeping4] = TRUE;
            pReason->PowerReasonCode = SPSD_REASON_PREVIOUSATTEMPTFAILED;
            
            Status = PopInsertLoggingEntry(pReason);
            if (Status != STATUS_SUCCESS) {
                    ExFreePool(pReason);
            }
            
        }
        FilteredCapabilities->SystemS4 = FALSE;

    }

}


BOOLEAN
PopUserIsAdmin(
    VOID
    )
/*++

Routine Description:

    Determines whether the current user is an administrator and therefore suitably
    privileged to change the administrative power policy.

Arguments:

    None

Return Value:

    TRUE - user is an administrator

    FALSE - user is not an administrator

--*/

{
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    PACCESS_TOKEN Token;
    BOOLEAN IsAdmin;

    PAGED_CODE();

    SeCaptureSubjectContext(&SubjectContext);
    SeLockSubjectContext(&SubjectContext);
    Token = SeQuerySubjectContextToken(&SubjectContext);
    IsAdmin = SeTokenIsAdmin(Token);
    SeUnlockSubjectContext(&SubjectContext);
    SeReleaseSubjectContext(&SubjectContext);

    return(IsAdmin);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\pidle.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pidle.c

Abstract:

    This module implements processor idle functionality

Author:

    Ken Reneris (kenr) 17-Jan-1997

Revision History:

--*/


#include "pop.h"

#if DBG
#define IDLE_DEBUG_TABLE_SIZE   400
ULONGLONG   ST[IDLE_DEBUG_TABLE_SIZE];
ULONGLONG   ET[IDLE_DEBUG_TABLE_SIZE];
ULONGLONG   TD[IDLE_DEBUG_TABLE_SIZE];
#endif

VOID
PopPromoteFromIdle0 (
    IN PPROCESSOR_POWER_STATE PState,
    IN PKTHREAD Thread
    );

VOID
FASTCALL
PopDemoteIdleness (
    IN PPROCESSOR_POWER_STATE   PState,
    IN PPOP_IDLE_HANDLER        IdleState
    );

VOID
FASTCALL
PopPromoteIdleness (
    IN PPROCESSOR_POWER_STATE   PState,
    IN PPOP_IDLE_HANDLER        IdleState
    );

VOID
FASTCALL
PopIdle0 (
    IN PPROCESSOR_POWER_STATE PState
    );

VOID
PopConvertUsToPerfCount (
    IN OUT PULONG   UsTime
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PoInitializePrcb)
#pragma alloc_text(PAGE, PopInitProcessorStateHandlers)
#pragma alloc_text(PAGE, PopInitProcessorStateHandlers2)
#endif


#if defined(i386) && !defined(NT_UP)

PPROCESSOR_IDLE_FUNCTION PopIdle0Function = PopIdle0;

VOID
FASTCALL
PopIdle0SMT (
    IN PPROCESSOR_POWER_STATE PState
    );

//
// PopIdle0Function is a pointer to Idle0 function.
//

#if 0
VOID
(FASTCALL *PopIdle0Function) (
    IN PPROCESSOR_POWER_STATE PState
    ) = PopIdle0;
#endif

#else

#define PopIdle0Function PopIdle0

#endif


VOID
FASTCALL
PoInitializePrcb (
    PKPRCB      Prcb
    )
/*++

Routine Description:

    Initialize PowerState structure within processor's Prcb
    before it enters the idle loop

Arguments:

    Prcb        Prcb for current processor which is initializing

Return Value:

    None.

--*/
{
    //
    // Zero power state structure
    //
    RtlZeroMemory(&Prcb->PowerState, sizeof(Prcb->PowerState));

    //
    // Initialize to legacy function with promotion from it disabled
    //

    Prcb->PowerState.Idle0KernelTimeLimit = (ULONG) -1;
    Prcb->PowerState.IdleFunction = PopIdle0;
    Prcb->PowerState.CurrentThrottle = POP_PERF_SCALE;

    //
    // Initialize the adaptive throttling subcomponents
    //
    KeInitializeDpc(
        &(Prcb->PowerState.PerfDpc),
        PopPerfIdleDpc,
        Prcb
        );
    KeSetTargetProcessorDpc(
        &(Prcb->PowerState.PerfDpc),
        Prcb->Number
        );
    KeInitializeTimer(
        (PKTIMER) &(Prcb->PowerState.PerfTimer)
        );

}


VOID
PopInitProcessorStateHandlers (
    IN  PPROCESSOR_STATE_HANDLER    InputBuffer
    )
/*++

Routine Description:

    Install processor state handlers. This routine simply translates the old-style
    PROCESSOR_STATE_HANDLER structure into a new-style PROCESSOR_STATE_HANDLER2
    structure and calls PopInitProcessorStateHandlers2

Arguments:

    InputBuffer     - Handlers

Return Value:

    None.

--*/
{
    PPROCESSOR_STATE_HANDLER StateHandler1 = (PPROCESSOR_STATE_HANDLER)InputBuffer;
    PPROCESSOR_STATE_HANDLER2 StateHandler2;
    UCHAR PerfStates;
    ULONG i;
    UCHAR Frequency;

    //
    // Allocate a buffer large enough to hold the larger structure
    //
    if (StateHandler1->ThrottleScale > 1) {
        PerfStates = StateHandler1->ThrottleScale;
    } else {
        PerfStates = 0;
    }
    StateHandler2 = ExAllocatePoolWithTag(PagedPool,
                                          sizeof(PROCESSOR_STATE_HANDLER2) +
                                          sizeof(PROCESSOR_PERF_LEVEL) * (PerfStates-1),
                                          'dHoP');
    if (!StateHandler2) {
        ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
    }
    StateHandler2->NumPerfStates = PerfStates;

    //
    // Fill in common information
    //
    StateHandler2->NumIdleHandlers = StateHandler1->NumIdleHandlers;
    for (i=0;i<MAX_IDLE_HANDLERS;i++) {
        StateHandler2->IdleHandler[i] = StateHandler1->IdleHandler[i];
    }

    //
    // Install our thunk that converts between the old and the new throttling
    // interfaces
    //
    PopRealSetThrottle = StateHandler1->SetThrottle;
    PopThunkThrottleScale = StateHandler1->ThrottleScale;
    StateHandler2->SetPerfLevel = PopThunkSetThrottle;
    StateHandler2->HardwareLatency = 0;

    //
    // Generate a perf level handler for each throttle step.
    //
    for (i=0; i<StateHandler2->NumPerfStates;i++) {

        Frequency = (UCHAR)((PerfStates-i)*POP_PERF_SCALE/PerfStates);
        StateHandler2->PerfLevel[i].PercentFrequency = Frequency;
    }

    //
    // We have built up our table, call off to PopInitProcessorStateHandlers2 for the rest
    // of the work. Note that this can raise an exception if there is an error.
    //
    try {
        PopInitProcessorStateHandlers2(StateHandler2);
    } finally {
        ExFreePool(StateHandler2);
    }
}


VOID
PopInitProcessorStateHandlers2 (
    IN  PPROCESSOR_STATE_HANDLER2    InputBuffer
    )
/*++

Routine Description:

    Install processor state handlers

Arguments:

    InputBuffer     - Handlers

Return Value:

    None.

--*/
{
    PPROCESSOR_STATE_HANDLER2   processorHandler;
    ULONG                       last;
    ULONG                       i;
    ULONG                       j;
    ULONG                       max;
    POP_IDLE_HANDLER            newIdle[MAX_IDLE_HANDLERS];
    POP_IDLE_HANDLER            tempIdle[MAX_IDLE_HANDLERS];
    NTSTATUS                    status;

    processorHandler = (PPROCESSOR_STATE_HANDLER2) InputBuffer;

    //
    // Install processor throttle support if present
    //
    status = PopSetPerfLevels(processorHandler);
    if (!NT_SUCCESS(status)) {

        ExRaiseStatus(status);

    }

    //
    // If there aren't any idle handlers, then we must deregister the old
    // handlers (if any)
    //
    if ((KeNumberProcessors > 1 && processorHandler->NumIdleHandlers < 1) ||
        (KeNumberProcessors == 1 && processorHandler->NumIdleHandlers <= 1)) {

        //
        // Use NULL and 0 to indicate the number of elements...
        //
        PopIdleSwitchIdleHandlers( NULL, 0 );
        return;

    }

    //
    // Get ready to build a set of idle state handlers
    //
    RtlZeroMemory(newIdle, sizeof(POP_IDLE_HANDLER) * MAX_IDLE_HANDLERS );
    RtlZeroMemory(tempIdle, sizeof(POP_IDLE_HANDLER) * MAX_IDLE_HANDLERS );

    //
    // We don't support more than 3 handlers ...
    //
    max = processorHandler->NumIdleHandlers;
    if (max > MAX_IDLE_HANDLERS) {

        max = MAX_IDLE_HANDLERS;

    }

    //
    // Look at all the handlers provided to us...
    //
    for (last = i = 0; i < max; i++) {

        //
        // Ensure they were passed in ascending order
        //
        j = processorHandler->IdleHandler[i].HardwareLatency;
        ASSERT (j >= last  &&  j <= 1000);
        last = j;

        //
        // Fill in some defaults
        //
        tempIdle[i].State       = (UCHAR) i;
        tempIdle[i].IdleFunction= processorHandler->IdleHandler[i].Handler;
        tempIdle[i].Latency     = j;

        //
        // Convert latency to perf rate scale
        //
        PopConvertUsToPerfCount(&tempIdle[i].Latency);

    }

    //
    // Apply policy to this set of states
    //
    status = PopIdleUpdateIdleHandler( newIdle, tempIdle, max );
    ASSERT( NT_SUCCESS( status ) );
    if (!NT_SUCCESS( status ) ) {

        return;

    }

    //
    // Initialize each processors idle info to start idle savings
    //
    PopIdleSwitchIdleHandlers( newIdle, max );
}

NTSTATUS
PopIdleSwitchIdleHandler(
    IN  PPOP_IDLE_HANDLER   NewHandler,
    IN  ULONG               NumElements
    )
/*++

Routine Description:

    This routine is responsible for switching the idle handler on the
    current processor for the specified new one.

    N.B. This function is only callable at DISPATCH_LEVEL

Arguments:

    NewHandler  - Pointer to new handlers
    NumElements - Number of elements in the array

Return Value:

    NTSTATUS

--*/
{
    PKPRCB                  prcb;
    PKTHREAD                thread;
    PPROCESSOR_POWER_STATE  pState;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // We need to know where the following data structures are
    //
    prcb = KeGetCurrentPrcb();
    pState = &(prcb->PowerState);
    thread = prcb->IdleThread;

    //
    // Update the current IdleHandler and IdleState to reflect what was
    // given to us
    //
    pState->IdleState         = NewHandler;
    pState->IdleHandlers      = NewHandler;
    pState->IdleHandlersCount = NumElements;
    if ( NewHandler) {

        //
        // Reset the timers to indicate that there is an idle handler
        // available
        //
        pState->Idle0KernelTimeLimit = thread->KernelTime + PopIdle0PromoteTicks;
        pState->Idle0LastTime = thread->KernelTime + thread->UserTime;
        pState->PromotionCheck = NewHandler[0].PromoteCount;

    } else {

        //
        // Setting these to Zero should indicate that there are no idle
        // handlers available
        //
        pState->Idle0KernelTimeLimit = (ULONG) -1;
        pState->Idle0LastTime = 0;
        pState->PromotionCheck = 0;
        pState->IdleFunction = PopIdle0Function;

    }

#if defined(i386) && !defined(NT_UP)
    if (prcb->MultiThreadProcessorSet != prcb->SetMember) {

        //
        // This processor is a member of a simultaneous
        // multi threading processor set.  Use the SMT
        // version of PopIdle0.
        //
        PopIdle0Function = PopIdle0SMT;
        pState->IdleFunction = PopIdle0SMT;

    }
    if (PopProcessorPolicy->DisableCStates) {

        //
        // PERF: We don't any throttling to operate on the machine
        //
        pState->IdleFunction = PopIdle0Function;
        RtlInterlockedSetBits( &(pState->Flags), PSTATE_DISABLE_CSTATES );

    } else {

        RtlInterlockedClearBits( &(pState->Flags), PSTATE_DISABLE_CSTATES );

    }
#endif

    //
    // Success
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PopIdleSwitchIdleHandlers(
    IN  PPOP_IDLE_HANDLER   NewHandler,
    IN  ULONG               NumElements
    )
/*++

Routine Description:

    This routine is responsible for swapping each processor's idle handler
    routine for a new one....

Arguments:

    NewHandler  - Pointer to the array of new handlers
    NumElements - Number of elements in the array

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFICCIENT_RESOURCES

--*/
{
    KAFFINITY               currentAffinity;
    KAFFINITY               processors;
    KIRQL                   oldIrql;
    NTSTATUS                status = STATUS_SUCCESS;
    PPOP_IDLE_HANDLER       tempHandler = NULL;

    ASSERT( NumElements <= MAX_IDLE_HANDLER );

    if (NewHandler) {

        //
        // Step 1. Allocate a new set of handlers to hold the copy that we
        // will need to keep around
        //
        tempHandler = ExAllocateFromNPagedLookasideList(
            &PopIdleHandlerLookAsideList
            );
        if (tempHandler == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            return status;

        }

        //
        // Step 2. Make sure that this new handler is in a consistent state,
        // and copy the buffer that was passed to us
        //
        RtlZeroMemory(
            tempHandler,
            sizeof(POP_IDLE_HANDLER) * MAX_IDLE_HANDLER
            );
        RtlCopyMemory(
            tempHandler,
            NewHandler,
            sizeof(POP_IDLE_HANDLER) * NumElements
            );

    } else {

        tempHandler = NULL;

    }

    //
    // Step 3. Iterate over the processors
    //
    currentAffinity = 1;
    processors = KeActiveProcessors;
    while (processors) {

        if (!(currentAffinity & processors)) {

            currentAffinity <<= 1;
            continue;

        }
        KeSetSystemAffinityThread( currentAffinity );
        processors &= ~currentAffinity;
        currentAffinity <<= 1;

        //
        // Step 4. Swap out old handler. Indicate that we want to free it
        //
        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        PopIdleSwitchIdleHandler( tempHandler, NumElements );
        KeLowerIrql(oldIrql);

    }

    //
    // Step 5. At this point, all of the processors should have been updated
    // and we are still running on the "last" processor in the machine. This
    // is a good point to update PopIdle to point to the new value. Note that
    // PopIdle isn't actually used for any else than storing a pointer to
    // the handler, but if there was something there already, then it should
    // be freed
    //
    if (PopIdle != NULL) {

        ExFreeToNPagedLookasideList(
            &PopIdleHandlerLookAsideList,
            PopIdle
            );

    }
    PopIdle = tempHandler;

    //
    // Step 6. At this point, its safe to return to the original processor
    // and to back to the previous IRQL...
    //
    KeRevertToUserAffinityThread();

    //
    // Done
    //
    return status;
}

NTSTATUS
PopIdleUpdateIdleHandler(
    IN  PPOP_IDLE_HANDLER   NewHandler,
    IN  PPOP_IDLE_HANDLER   OldHandler,
    IN  ULONG               NumElements
    )
/*++

Routine Description:

    This routine takes the information stored in OldHandler (such as latency,
    and IdleFunction) and uses that to build the new idle handlers...

Arguements:

    NewHandler  - pointer to the new idle handlers
    OldHandler  - pointer to the old idle handlers
    NumElements - number of elements in the old idle handlers

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    ULONG       i;
    ULONG       max;
    ULONG       realMax;

    //
    // We don't support more than 3 handlers ...
    //
    realMax = max = NumElements;
    if (max > MAX_IDLE_HANDLERS) {

        realMax = max = MAX_IDLE_HANDLERS;

    }

    //
    // Cap the max based upon what the policy supports
    //
    if (max > PopProcessorPolicy->PolicyCount) {

        max = PopProcessorPolicy->PolicyCount;

    }

    //
    // Update the temp handler with the new policy
    //
    for (i = 0; i < max; i++) {

        NewHandler[i].State         = (UCHAR) i;
        NewHandler[i].Latency       = OldHandler[i].Latency;
        NewHandler[i].IdleFunction  = OldHandler[i].IdleFunction;
        NewHandler[i].TimeCheck     = PopProcessorPolicy->Policy[i].TimeCheck;
        NewHandler[i].PromoteLimit  = PopProcessorPolicy->Policy[i].PromoteLimit;
        NewHandler[i].PromotePercent= PopProcessorPolicy->Policy[i].PromotePercent;
        NewHandler[i].DemoteLimit   = PopProcessorPolicy->Policy[i].DemoteLimit;
        NewHandler[i].DemotePercent = PopProcessorPolicy->Policy[i].DemotePercent;

        //
        // Convert all the time units to the correct units
        //
        PopConvertUsToPerfCount(&NewHandler[i].TimeCheck);
        PopConvertUsToPerfCount(&NewHandler[i].DemoteLimit);
        PopConvertUsToPerfCount(&NewHandler[i].PromoteLimit);

        //
        // Fill in the table that allows for promotion / demotion
        //
        if (PopProcessorPolicy->Policy[i].AllowDemotion) {

            NewHandler[i].Demote    = (UCHAR) i-1;

        } else {

            NewHandler[i].Demote    = (UCHAR) i;

        }
        if (PopProcessorPolicy->Policy[i].AllowPromotion) {

            NewHandler[i].Promote   = (UCHAR) i+1;

        } else {

            NewHandler[i].Promote   = (UCHAR) i;

        }

    }

    //
    // Make sure that the boundary cases are well respected...
    //
    NewHandler[0].Demote = 0;
    NewHandler[(max-1)].Promote = (UCHAR) (max-1);

    //
    // We let PopVerifyHandler fill in all the details associated with
    // the fact that we don't want to allow demotion/promotion from these
    // states
    //
    NewHandler[0].DemotePercent = 0;
    NewHandler[(max-1)].PromotePercent = 0;

    //
    // Handle the states that we don't have a policy handler in place for
    //
    for (; i < realMax; i++) {

        //
        // The only pieces of data that we really need are the latency and the
        // idle handler function
        //
        NewHandler[i].State         = (UCHAR) i;
        NewHandler[i].Latency       = OldHandler[i].Latency;
        NewHandler[i].IdleFunction  = OldHandler[i].IdleFunction;

    }

    //
    // Sanity check the new handler
    //
    status = PopIdleVerifyIdleHandlers( NewHandler, max );
    ASSERT( NT_SUCCESS( status ) );
    return status;
}

NTSTATUS
PopIdleUpdateIdleHandlers(
    VOID
    )
/*++

Routine Description:

    This routine is called to update the idle handlers when the state of the
    machine warrants a possible change in policy

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN                 foundProcessor = FALSE;
    KAFFINITY               currentAffinity;
    KAFFINITY               processors;
    KIRQL                   oldIrql;
    NTSTATUS                status = STATUS_SUCCESS;
    PKPRCB                  prcb;
    PPOP_IDLE_HANDLER       tempHandler = NULL;
    PPROCESSOR_POWER_STATE  pState;
    ULONG                   numElements = 0;

    //
    // Step 1. Allocate a new set of handlers to hold the copy that we
    // will need to keep around
    //
    tempHandler = ExAllocateFromNPagedLookasideList(
        &PopIdleHandlerLookAsideList
        );
    if (tempHandler == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory(
        tempHandler,
        sizeof(POP_IDLE_HANDLER) * MAX_IDLE_HANDLER
        );

    //
    // Step 2. Iterate over the processors
    //
    currentAffinity = 1;
    processors = KeActiveProcessors;
    while (processors) {

        if (!(currentAffinity & processors)) {

            currentAffinity <<= 1;
            continue;

        }
        KeSetSystemAffinityThread( currentAffinity );
        processors &= ~currentAffinity;
        currentAffinity <<= 1;

        //
        // Can't look at the processors without being at DPC level
        //
        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

        //
        // We need to find a template to get the processor info from
        //
        if (!foundProcessor) {

            //
            // Step 3. If we haven't already found a processor so that we
            // create a new idle handler, then do so now. Note that it is
            // possible that this processor has no mask, in which case we
            // should clean up and return.
            //
            // N.B. That it is still safe to return at this point since
            // we haven't touch a single processor's data structures, so
            // we are in no danger of corrupting something...
            //
            prcb = KeGetCurrentPrcb();
            pState = &(prcb->PowerState);
            if (pState->IdleHandlers == NULL) {

                //
                // No idle handlers to update
                //
                ExFreeToNPagedLookasideList(
                    &PopIdleHandlerLookAsideList,
                    tempHandler
                    );
                KeLowerIrql( oldIrql );
                KeRevertToUserAffinityThread();
                return STATUS_SUCCESS;

            }
            numElements = pState->IdleHandlersCount;

            //
            // Update the temp handler with the new policy
            //
            status = PopIdleUpdateIdleHandler(
                tempHandler,
                pState->IdleHandlers,
                numElements
                );
            ASSERT( NT_SUCCESS( status ) );
            if (!NT_SUCCESS( status ) ) {

                //
                // No idle handlers to update
                //
                ExFreeToNPagedLookasideList(
                    &PopIdleHandlerLookAsideList,
                    tempHandler
                    );
                KeLowerIrql( oldIrql );
                KeRevertToUserAffinityThread();
                return status;

            }

            //
            // Remember that we have found the processor information
            //
            foundProcessor = TRUE;

        }

        //
        // Step 4. Swap out old handler. Indicate that we want to free it
        //
        PopIdleSwitchIdleHandler( tempHandler, numElements );

        //
        // Revert back to original irql
        //
        KeLowerIrql(oldIrql);

    }

    //
    // Step 5. At this point, all of the processors should have been updated
    // and we are still running on the "last" processor in the machine. This
    // is a good point to update PopIdle to point to the new value. Note that
    // PopIdle isn't actually used for any else than storing a pointer to
    // the handler, but if there was something there already, then it should
    // be freed
    //
    if (PopIdle != NULL) {

        ExFreeToNPagedLookasideList(
            &PopIdleHandlerLookAsideList,
            PopIdle
            );

    }
    PopIdle = tempHandler;

    //
    // Step 6. At this point, its safe to return to the original processor.
    //
    KeRevertToUserAffinityThread();

    //
    // Done
    //
    return status;

}

NTSTATUS
PopIdleVerifyIdleHandlers(
    IN  PPOP_IDLE_HANDLER   NewHandler,
    IN  ULONG               NumElements
    )
/*++

Routine Description:

    This routine is called to sanity check a set of idle handlers. It will
    correct the errors (if it can) or return a failure code (if it cannot)

Arguments:

    NewHandler  - Array of Handlers
    NumElements - Number of Elements in the Array to actually verify. This
                  may be smaller than the actual number of elements in the
                  array

Return Value:

    NTSTATUS

--*/
{
    ULONG   i;

    //
    // Sanity Check
    //
    ASSERT( NewHandler != NULL );
    ASSERT( NumElements );

    //
    // Sanity check rules of multi-processors. We don't allow demotion from
    // Idle0 unless the machine is MP
    //
    if (KeNumberProcessors == 1 && NewHandler[0].DemotePercent != 0) {

        NewHandler[0].DemotePercent = 0;

    }

    //
    // first state.Demote must always be zero.
    //
    NewHandler[0].Demote = 0;

    //
    // Sanity check idle values. These numbers are stored in the policy
    // as MicroSeconds, we need to take the opportunity to convert them to
    // PerfCount units...
    //
    for (i = 0; i < NumElements; i++) {

        //
        // =============================
        // TimeCheck
        //
        // Time, in microseconds, that must expire before promotion or 
        // demotion is considered.
        //
        // - Must be larger than DemoteLimit.
        // - If there's a DemotePercent, then we will use PromoteLimit
        //   to move the process into a more active state.  If that's the
        //   case, then TimeCheck needs to be >= PromoteLimit.
        // =============================
        //
        if (NewHandler[i].TimeCheck < NewHandler[i].DemoteLimit) {
            NewHandler[i].TimeCheck = NewHandler[i].DemoteLimit;
        }

        if( (NewHandler[i].DemotePercent == 0) &&
            (NewHandler[i].TimeCheck < NewHandler[i].PromoteLimit) ) {
            NewHandler[i].TimeCheck = NewHandler[i].PromoteLimit;
        }

        
        //
        // =============================
        // DemotePercent and PromotePercent
        //
        // Value, expressed as a percentage, that scales the threshold at 
        // which the power policy manager decreases/increases the performance 
        // of the processor.
        //
        // - He needs to be <= 100
        // =============================
        //
        if( NewHandler[i].DemotePercent > 100 ) {
            NewHandler[i].DemotePercent = 100;
        }
        if( NewHandler[i].PromotePercent > 100 ) {
            NewHandler[i].PromotePercent = 100;
        }
        


        //
        // =============================
        // DemoteLimit
        //
        // Minimum amount of time, in microseconds, that must be spent in the 
        // idle loop to avoid demotion.
        //
        // - This needs to be some percentage of TimeCheck.  If the processor
        //   is running slow, then we need to reduce TimeCheck by the same
        //   percentage.  In other words, 1000us in the idle loop on a 500MHz
        //   processor is similar to 833us in the idle loop on a 600MHz processor.
        //   NOTE: It's possible that DemotePercent is 0, in which case we want 
        //   to end up with DemoteLimit also set to zero.
        // =============================
        //
        NewHandler[i].DemoteLimit = (NewHandler[i].TimeCheck * NewHandler[i].DemotePercent) / 100;

        
        
        
        //
        // =============================
        // PromoteCount
        //
        // Number of TimeCheck intervals in PromoteLimit.
        //
        // - This makes no sense if TimeCheck is zero though.  In that case,
        //   PromoteCount and PromoteLimit should be disabled by setting
        //   them to -1.
        // =============================
        //
        
        //
        // Compute promote count as # of time checks
        //
        if( NewHandler[i].TimeCheck ) {
            NewHandler[i].PromoteCount = NewHandler[i].PromoteLimit / NewHandler[i].TimeCheck;
        } else {
            //
            // Set PromotePercent to zero so that we'll fall into the 'else'
            // block below and nuke PomoteCount and PromoteLimit.
            NewHandler[i].PromotePercent = 0;
        }



        //
        // =============================
        // PromoteLimit
        //
        // Time, in microseconds, that must be exceeded to cause promotion to a deeper
        // idle state..
        //
        // - This needs to be scaled down by PromotePercent.
        //
        // NOTE: If PromotePercent is zero, then this is sort of non-sensical
        // and we're going to disable PromoteCount and PromoteLimit by
        // setting them to -1.
        // =============================
        //
        if (NewHandler[i].PromotePercent) {
            NewHandler[i].PromoteLimit = (NewHandler[i].PromoteLimit * NewHandler[i].PromotePercent) / 100;
        } else {
            NewHandler[i].PromoteCount = (ULONG) -1;
            NewHandler[i].PromoteLimit = (ULONG) -1;
        }

    }

    //
    // Sanity check the last state
    //
    i = NumElements - 1;
    NewHandler[i].Promote = (UCHAR) i;
    NewHandler[i].PromoteLimit = (ULONG) -1;
    NewHandler[i].PromotePercent = 0;


    //
    // We are happy with this policy...
    //
    return STATUS_SUCCESS;
}

VOID
PopConvertUsToPerfCount (
    IN OUT PULONG   UsTime
    )
{
    LARGE_INTEGER   li;
    LONGLONG        temp;

    if (*UsTime) {

        //
        // Try to avoid Divide by Zero Errors...
        //
        temp = (US2SEC * MAXSECCHECK * 100L) / *UsTime;
        if (!temp) {

            *UsTime = (ULONG) -1;
            return;

        }

        //
        // Get scale of idle times
        //
        KeQueryPerformanceCounter (&li);
        li.QuadPart = (li.QuadPart*MAXSECCHECK*100L) / temp;
        ASSERT (li.HighPart == 0);
        *UsTime = li.LowPart;
    }
}




//
// ----------------
//

VOID
FASTCALL
PopIdle0 (
    IN PPROCESSOR_POWER_STATE   PState
    )
/*++

Routine Description:

    No idle optmiziations.

    N.B. This function is called with interrupts disabled from the idle loop

Arguments:

    PState      - Current processors power state structure

Return Value:

    None.

--*/
{
    PKTHREAD    Thread = KeGetCurrentThread();

    //
    // Performance Throttling Check
    //

    //
    // This piece of code really belongs in the functions that will eventually
    // call this one, PopIdle0 or PopProcessorIdle, to save a function call.
    //
    if ( (PState->Flags & PSTATE_ADAPTIVE_THROTTLE) &&
        !(PState->Flags & PSTATE_DISABLE_THROTTLE) ) {

        PopPerfIdle( PState );

    }


    //
    // If the idle thread's kernel time has exceeded the target idle time, then
    // check for possible promotion from Idle0
    //

    if (Thread->KernelTime > PState->Idle0KernelTimeLimit &&
        !(PState->Flags & PSTATE_DISABLE_CSTATES) ) {

        //
        // Must enable interrupts prior to calling PopPromoteFromIdle
        // to avoid spinning on system locks with interrupts disabled.
        //

        _enable();
        PopPromoteFromIdle0 (PState, Thread);
        return ;
    }

#if defined(NT_UP)
    // use legacy function
    HalProcessorIdle ();
#endif
}


#if defined(i386) && !defined(NT_UP)

VOID
FASTCALL
PopIdle0SMT (
    IN PPROCESSOR_POWER_STATE   PState
    )
/*++

Routine Description:

    No idle optmiziations.

    N.B. This function is called with interrupts disabled from the idle loop

Arguments:

    PState      - Current processors power state structure

Return Value:

    None.

--*/
{
    PKTHREAD    Thread = KeGetCurrentThread();
    PKPRCB      Prcb = KeGetCurrentPrcb();

    //
    // Performance Throttling Check
    //

    //
    // This piece of code really belongs in the functions that will eventually
    // call this one, PopIdle0 or PopProcessorIdle, to save a function call.
    //
    if ( (PState->Flags & PSTATE_ADAPTIVE_THROTTLE) &&
        !(PState->Flags & PSTATE_DISABLE_THROTTLE) ) {

        PopPerfIdle( PState );

    }

    //
    // If this is a Simultaneous Multi Threading processor and other
    // processors in this set are NOT idle, promote this processor
    // immediately OR if the idle thread's kernel time has exceeded
    // the target idle time, then check for possible promotion from Idle0.
    //

    if ((KeIsSMTSetIdle(Prcb) == FALSE) ||
        (Thread->KernelTime > PState->Idle0KernelTimeLimit)) {

        //
        // Must enable interrupts prior to calling PopPromoteFromIdle
        // to avoid spinning on system locks with interrupts disabled.
        //

        _enable();
        PopPromoteFromIdle0 (PState, Thread);
        return ;
    }
}

#endif

VOID
FASTCALL
PopProcessorIdle (
    IN PPROCESSOR_POWER_STATE   PState
    )
/*++

Routine Description:

    For now this function is coded in C

    N.B. This function is called with interrupts disabled from the idle loop

Arguments:

    PState      - Current processors power state structure

Return Value:

    None.

--*/
{
    PPOP_IDLE_HANDLER   IdleState;
    LARGE_INTEGER       Delta;
    ULONG               IdleTime;
    BOOLEAN             DemoteNow;

    IdleState = (PPOP_IDLE_HANDLER) PState->IdleState;

    //
    // Performance Throttling Check
    //

    //
    // This piece of code really belongs in the functions that will eventually
    // call this one, PopIdle0 or PopProcessorIdle, to save a function call.
    //
    if ( (PState->Flags & PSTATE_ADAPTIVE_THROTTLE) &&
        !(PState->Flags & PSTATE_DISABLE_THROTTLE) ) {

        PopPerfIdle( PState );

    }

#if DBG
    if (!PState->LastCheck) {
        IdleState->IdleFunction (&PState->IdleTimes);
        PState->TotalIdleStateTime[IdleState->State] += (ULONG)(PState->IdleTimes.EndTime - PState->IdleTimes.StartTime);
        PState->TotalIdleTransitions[IdleState->State] += 1;
        PState->LastCheck = PState->IdleTimes.EndTime;
        PState->IdleTime1 = 0;
        PState->IdleTime2 = 0;
        PState->PromotionCheck = IdleState->PromoteCount;
        PState->DebugCount = 0;
        return ;
    }
#endif

    //
    // Determine how long since last check
    //

    Delta.QuadPart = PState->IdleTimes.EndTime - PState->LastCheck;

    //
    // Accumulate last idle time
    //

    IdleTime = (ULONG) (PState->IdleTimes.EndTime - PState->IdleTimes.StartTime);
    if (IdleTime > IdleState->Latency) {
        PState->IdleTime1 += IdleTime - IdleState->Latency;
    }

#if DBG
    PState->DebugDelta = Delta.QuadPart;
    PState->DebugCount += 1;
    if (PState->DebugCount < IDLE_DEBUG_TABLE_SIZE) {
        ST[PState->DebugCount] = PState->IdleTimes.StartTime;
        ET[PState->DebugCount] = PState->IdleTimes.EndTime;
        TD[PState->DebugCount] = PState->IdleTimes.EndTime - PState->IdleTimes.StartTime;
    }
#endif

    //
    // If over check interval, check fine grain idleness
    //

    if (Delta.HighPart ||  Delta.LowPart > IdleState->TimeCheck) {
        PState->LastCheck = PState->IdleTimes.EndTime;

        //
        // Demote idleness?
        //

        if (PState->IdleTime1 < IdleState->DemoteLimit) {

#if defined(i386) && !defined(NT_UP)

            //
            // Don't demote if this is an SMT processor and any other
            // member of the SMT set is not idle.
            //

            PKPRCB Prcb = KeGetCurrentPrcb();

            if ((KeIsSMTSetIdle(Prcb) == FALSE) &&
                (Prcb->SetMember != Prcb->MultiThreadProcessorSet)) {
                PState->IdleTime1 = 0;
                return;
            }

#endif


            PopDemoteIdleness (PState, IdleState);
#if DBG
            PState->DebugCount = 0;
#endif
            return ;
        }
#if DBG
        PState->DebugCount = 0;
#endif

        //
        // Clear demotion idle time check, and accumulate stat for promotion check
        //

        PState->IdleTime2 += PState->IdleTime1;
        PState->IdleTime1  = 0;

        //
        // Time to check for promotion?
        //

        PState->PromotionCheck -= 1;
        if (!PState->PromotionCheck) {

            //
            // Promote idleness?
            //

            if (PState->IdleTime2 > IdleState->PromoteLimit) {
                PopPromoteIdleness (PState, IdleState);
                return;
            }

            PState->PromotionCheck = IdleState->PromoteCount;
            PState->IdleTime2 = 0;
        }
    }

    //
    // Call system specific power handler handler
    //
    DemoteNow = IdleState->IdleFunction (&PState->IdleTimes);

    //
    // If the handler returns TRUE, then the demote to less power savings state
    //

    if (DemoteNow) {
        PopDemoteIdleness (PState, IdleState);
#if DBG
        PState->DebugCount = 0;
#endif
    } else {
        PState->TotalIdleStateTime[IdleState->State] += PState->IdleTimes.EndTime - PState->IdleTimes.StartTime;
        PState->TotalIdleTransitions[IdleState->State] += 1;
    }
}


VOID
FASTCALL
PopDemoteIdleness (
    IN PPROCESSOR_POWER_STATE   PState,
    IN PPOP_IDLE_HANDLER        IdleState
    )
/*++

Routine Description:

    Processor is not idle enough.  Use a less agressive idle handler (or
    increase processors throttle control).

Arguments:

    PState      - Current processors power state structure

    IdleState   - Current idle state for the current processor

Return Value:

    None.

--*/
{
#if !defined(NT_UP)
    PKPRCB              Prcb;
    PKTHREAD            Thread;
#endif
    PPOP_IDLE_HANDLER   Idle;

    //
    // Clear idleness for next check
    //

    PState->IdleTime1 = 0;
    PState->IdleTime2 = 0;

    PERFINFO_POWER_IDLE_STATE_CHANGE( PState, -1 );

#if !defined(NT_UP)

    //
    // If this is a demotion to the non-blocking idle handler then
    // clear this processors bit in the PoSleepingSummary
    //

    if ((PState->Flags & PSTATE_DISABLE_THROTTLE) ||
        IdleState->Demote == PO_IDLE_COMPLETE_DEMOTION) {

        Prcb = CONTAINING_RECORD (PState, KPRCB, PowerState);
        InterlockedAndAffinity ((PLONG_PTR)&PoSleepingSummary, ~Prcb->SetMember);
        Thread = Prcb->IdleThread;
        PState->Idle0KernelTimeLimit = Thread->KernelTime + PopIdle0PromoteTicks;
        PState->Idle0LastTime = Prcb->KernelTime + Prcb->UserTime;
        PState->IdleFunction = PopIdle0Function;
        return ;
    }

#endif

    //
    // Demote to next idle state
    //
    Idle = PState->IdleHandlers;
    PState->PromotionCheck = Idle[IdleState->Demote].PromoteCount;
    PState->IdleState = (PVOID) &Idle[IdleState->Demote];
}

VOID
PopPromoteFromIdle0 (
    IN PPROCESSOR_POWER_STATE PState,
    IN PKTHREAD Thread
    )
/*++

Routine Description:

    Processor is using Idle0 and the required idle time has elasped.
    Check idle precentage to see if a promotion out of Idle0 should occur.

Arguments:

    PState      - Current processors power state structure

    Thread      - Idle thread for the current processor

Return Value:

    None.

--*/
{
    ULONG               etime;
    PKPRCB              Prcb;
    PPOP_IDLE_HANDLER   Idle;

    //
    // Compute elapsed system time
    //

    Prcb  = CONTAINING_RECORD (PState, KPRCB, PowerState);
    etime = Prcb->UserTime + Prcb->KernelTime - PState->Idle0LastTime;
    Idle = PState->IdleHandlers;

    //
    // Has the processor been idle enough to promote?
    //

    if (etime < PopIdle0PromoteLimit) {
        KEVENT DummyEvent;

        //
        // Promote to the first real idle handler
        //

        PERFINFO_POWER_IDLE_STATE_CHANGE( PState, 0 );

        PState->IdleTime1 = 0;
        PState->IdleTime2 = 0;
        PState->PromotionCheck = Idle[0].PromoteCount;
        PState->IdleState = Idle;
        PState->IdleFunction = PopProcessorIdle;
        PState->LastCheck = KeQueryPerformanceCounter(NULL).QuadPart;
        PState->IdleTimes.StartTime = PState->LastCheck;
        PState->IdleTimes.EndTime   = PState->LastCheck;
        InterlockedOrAffinity ((PLONG_PTR)&PoSleepingSummary, Prcb->SetMember);

        //
        // Once SleepingSummary is set, make sure no one is in the
        // middle of a context switch by aquiring & releasing the
        // dispatcher database lock
        //

        KeInitializeEvent(&DummyEvent, SynchronizationEvent, TRUE);
        KeResetEvent (&DummyEvent);
        return ;
    }

    //
    // Set for next compare
    //

    PState->Idle0KernelTimeLimit = Thread->KernelTime + PopIdle0PromoteTicks;
    PState->Idle0LastTime = Prcb->UserTime + Prcb->KernelTime;
}



VOID
FASTCALL
PopPromoteIdleness (
    IN PPROCESSOR_POWER_STATE   PState,
    IN PPOP_IDLE_HANDLER        IdleState
    )
/*++

Routine Description:

    Processor is idle enough to be promoted to the next idle handler.
    If the processor is already at its max idle handler, check to
    see if the processors throttle control can be reduced.  If any
    processor is not running at it's best speed, a timer is used to
    watch for some changes from idle to busy.

Arguments:

    PState      - Current processors power state structure

    IdleState   - Current idle state for the current processor

Return Value:

    None.

--*/
{
    PPOP_IDLE_HANDLER   Idle;

    //
    // Clear idleness for next check
    //
    PState->IdleTime2 = 0;
    PERFINFO_POWER_IDLE_STATE_CHANGE( PState, 1 );

    //
    // If already fully promoted, then nothing more to do.
    //
    if (IdleState->Promote == PO_IDLE_THROTTLE_PROMOTION) {

        PState->PromotionCheck = IdleState->PromoteCount;
        return;

    }

    //
    // Promote to next idle state
    //
    Idle = PState->IdleHandlers;
    PState->PromotionCheck = Idle[IdleState->Promote].PromoteCount;
    PState->IdleState = (PVOID) &Idle[IdleState->Promote];
}

VOID
PopProcessorInformation (
    OUT PPROCESSOR_POWER_INFORMATION    ProcInfo,
    IN  ULONG                           ProcInfoLength,
    OUT PULONG                          ReturnBufferLength
    )
{
    KAFFINITY                   Summary;
    KAFFINITY                   Mask;
    KIRQL                       OldIrql;
    PPOP_IDLE_HANDLER           IdleState;
    PKPRCB                      Prcb;
    PPROCESSOR_POWER_STATE      PState;
    PROCESSOR_POWER_INFORMATION TempInfo;
    ULONG                       Processor;
    ULONG                       MaxMhz;
    ULONG                       BufferSize = 0;
    ULONG                       MaxIdleState = 0;
    ULONG                       i;
    ULONG                       j;

    //
    // The best way to grab the state of the idle handlers is to raise to
    // DISPATCH_LEVEL, grab the current PRCB and look at the handler there.
    // The alternative is to find the last processor, switch to it, and then
    // look at the PopIdle global. As an FYI, we cannot just arbitrarily
    // look at it since the code that updates it might have already run past
    // *this* processor...
    //
    KeRaiseIrql( DISPATCH_LEVEL, &OldIrql );
    Prcb = KeGetCurrentPrcb();
    PState = &(Prcb->PowerState);
    IdleState = PState->IdleHandlers;
    if (IdleState) {

        for (i = 0, MaxIdleState = 1; ;) {

            j = IdleState[i].Promote;
            if (j == 0  ||  j == i || j == PO_IDLE_THROTTLE_PROMOTION) {

                break;

            }

            i = j;
            MaxIdleState += 1;

        }

    }
    KeLowerIrql( OldIrql );

    Summary = KeActiveProcessors;
    Processor = 0;
    Mask = 1;
    while (Summary) {

        if (!(Mask & Summary)) {

            Mask <<= 1;
            continue;

        }

        if (ProcInfoLength < BufferSize + sizeof(PROCESSOR_POWER_INFORMATION)) {

            break;

        }

        //
        // Run in the context of the target processor
        //
        KeSetSystemAffinityThread( Mask );
        Summary &= ~Mask;
        Mask <<= 1;

        //
        // Lets play safe
        //
        KeRaiseIrql( DISPATCH_LEVEL, &OldIrql );

        //
        // Get the current PState block...
        //
        Prcb = KeGetCurrentPrcb();
        PState = &Prcb->PowerState;

        MaxMhz = Prcb->MHz;

        TempInfo.Number = Processor;
        TempInfo.MaxMhz = MaxMhz;

        TempInfo.CurrentMhz = (MaxMhz * PState->CurrentThrottle) / POP_PERF_SCALE;
        TempInfo.MhzLimit = (MaxMhz * PState->ThermalThrottleLimit) / POP_PERF_SCALE;

        //
        // In theory, we could recalculate this number here, but I'm not sure
        // that there is a benefit to doing that
        //
        TempInfo.MaxIdleState = MaxIdleState;

        //
        // Determine what the current Idle state is...
        //
        TempInfo.CurrentIdleState = 0;
        if (PState->IdleFunction != PopIdle0Function) {

            IdleState = PState->IdleState;
            if (IdleState != NULL) {

                TempInfo.CurrentIdleState = IdleState->State;

            }

        }

        //
        // At this point, we have captured the info that we need and can safely
        // drop back to a lower irql
        //
        KeLowerIrql( OldIrql );

        //
        // Copy the temp structure we just created over...
        //
        RtlCopyMemory(ProcInfo, &TempInfo, sizeof(PROCESSOR_POWER_INFORMATION) );
        ProcInfo += 1;
        BufferSize += sizeof (PROCESSOR_POWER_INFORMATION);

        //
        // Next
        //
        Processor = Processor + 1;

    }
    KeRevertToUserAffinityThread();

    *ReturnBufferLength = BufferSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\poinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    poinit.c

Abstract:

    Initialize power management component

Author:

    Ken Reneris (kenr) 19-July-1994

Revision History:

--*/


#include "pop.h"

VOID
PopRegisterForDeviceNotification (
    IN LPGUID                   Guid,
    IN POP_POLICY_DEVICE_TYPE   DeviceType
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PoInitSystem)
#pragma alloc_text(INIT, PopRegisterForDeviceNotification)
#pragma alloc_text(INIT, PoInitDriverServices)
#pragma alloc_text(PAGE, PoInitHiberServices)
#pragma alloc_text(PAGE, PopDefaultPolicy)
#pragma alloc_text(PAGE, PopDefaultProcessorPolicy)
#endif

BOOLEAN
PoInitSystem(
    IN ULONG  Phase
    )
/*++

Routine Description:

    This routine initializes the Power Manager.

Arguments:

    None

Return Value:

    The function value is a BOOLEAN indicating whether or not the Power Manager
    was successfully initialized.

--*/

{
    HANDLE                              handle;
    ULONG                               Length, i;
    UNICODE_STRING                      UnicodeString;
    NTSTATUS                            Status = STATUS_SUCCESS;
    PADMINISTRATOR_POWER_POLICY         AdminPolicy;
    PPOP_HEURISTICS                     HeuristicData;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION   Inf;
        union {
            POP_HEURISTICS              Heuristics;
            ADMINISTRATOR_POWER_POLICY  AdminPolicy;
        } Data;
    } PartialInformation;

    if (Phase == 0) {
        //
        // irp serialization, notify network, etc.
        //
        KeInitializeSpinLock(&PopIrpSerialLock);
        KeInitializeSpinLock(&PopThermalLock);
        InitializeListHead(&PopIrpSerialList);
        InitializeListHead(&PopRequestedIrps);
        ExInitializeResourceLite(&PopNotifyLock);
        PopInvalidNotifyBlockCount = 0;
        PopIrpSerialListLength = 0;
        PopInrushPending = FALSE;
        PopInrushIrpPointer = NULL;
        PopInrushIrpReferenceCount = 0;

        KeInitializeSpinLock(&PopWorkerLock);
        PopCallSystemState = 0;

        ExInitializeWorkItem(&PopUnlockAfterSleepWorkItem,PopUnlockAfterSleepWorker,NULL);
        KeInitializeEvent(&PopUnlockComplete, SynchronizationEvent, TRUE);

        //
        // logging
        //
        InitializeListHead(&PowerStateDisableReasonListHead);

        //
        // poshtdwn.c
        //
        PopInitShutdownList();

        //
        // idle.c
        //
        KeInitializeSpinLock(&PopDopeGlobalLock);
        InitializeListHead(&PopIdleDetectList);

        //
        // sidle.c
        //

        KeInitializeTimer(&PoSystemIdleTimer);
        KeQueryPerformanceCounter(&PopPerfCounterFrequency);

        //
        // policy workers
        //

        KeInitializeSpinLock (&PopWorkerSpinLock);
        InitializeListHead (&PopPolicyIrpQueue);
        ExInitializeWorkItem (&PopPolicyWorker, PopPolicyWorkerThread, UIntToPtr(PO_WORKER_STATUS));
        PopWorkerStatus = 0xffffffff;

        //
        // Policy manager
        //

        ExInitializeResourceLite (&PopPolicyLock);
        KeInitializeGuardedMutex (&PopVolumeLock);
        InitializeListHead (&PopVolumeDevices);
        InitializeListHead (&PopSwitches);
        InitializeListHead (&PopThermal);
        InitializeListHead (&PopActionWaiters);
        ExInitializeNPagedLookasideList(
            &PopIdleHandlerLookAsideList,
            NULL,
            NULL,
            0,
            (sizeof(POP_IDLE_HANDLER) * MAX_IDLE_HANDLERS),
            POP_IDLE_TAG,
            (sizeof(POP_IDLE_HANDLER) * MAX_IDLE_HANDLERS * 3)
            );
        PopAction.Action = PowerActionNone;

        PopDefaultPolicy (&PopAcPolicy);
        PopDefaultPolicy (&PopDcPolicy);
        PopPolicy = &PopAcPolicy;

        PopDefaultProcessorPolicy( &PopAcProcessorPolicy );
        PopDefaultProcessorPolicy( &PopDcProcessorPolicy );
        PopProcessorPolicy = &PopAcProcessorPolicy;

        PopAdminPolicy.MinSleep = PowerSystemSleeping1;
        PopAdminPolicy.MaxSleep = PowerSystemHibernate;
        PopAdminPolicy.MinVideoTimeout = 0;
        PopAdminPolicy.MaxVideoTimeout = (ULONG) -1;
        PopAdminPolicy.MinSpindownTimeout = 0;
        PopAdminPolicy.MaxSpindownTimeout = (ULONG) -1;

        PopFullWake = PO_FULL_WAKE_STATUS | PO_GDI_STATUS;
        PopCoolingMode = PO_TZ_ACTIVE;

        //
        // Initialize composite battery status
        //

        KeInitializeEvent(&PopCB.Event, NotificationEvent, FALSE);
        for (i=0; i < PO_NUM_POWER_LEVELS; i++) {
            PopCB.Trigger[i].Type = PolicyDeviceBattery;
        }

        //
        // Note the code overloads some POP flags into an ES flags
        // Verify there's no overlap
        //

        ASSERT (!( (ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED | ES_USER_PRESENT) &
                   (POP_LOW_LATENCY | POP_DISK_SPINDOWN)
                 ) );


        //
        // Set the default shutdown handler just in case there's hal out there
        // that never registers a shutdown handler of his own.  This will avoid
        // the possible scenario where someone asks the machine to shutdown and
        // it fails to call a shutdown handler (there isn't one), so it simply
        // reboots instead.
        //
        PopPowerStateHandlers[PowerStateShutdownOff].Type = PowerStateShutdownOff;
        PopPowerStateHandlers[PowerStateShutdownOff].RtcWake = FALSE;
        PopPowerStateHandlers[PowerStateShutdownOff].Handler = PopShutdownHandler;


    }

    if (Phase == 1) {

        //
        // Reload PopSimulate to pick up any overrides
        //
        PopInitializePowerPolicySimulate();

        //
        // For testing, if simulate flag is set turn on
        //

        if (PopSimulate & POP_SIM_CAPABILITIES) {
            PopCapabilities.SystemBatteriesPresent = TRUE;
            PopCapabilities.BatteryScale[0].Granularity = 100;
            PopCapabilities.BatteryScale[0].Capacity = 400;
            PopCapabilities.BatteryScale[1].Granularity = 10;
            PopCapabilities.BatteryScale[1].Capacity = 0xFFFF;
            PopCapabilities.RtcWake = PowerSystemSleeping3;
            PopCapabilities.DefaultLowLatencyWake = PowerSystemSleeping1;
        }

        //
        // For testing, if super simulate flag set turn all the capabilities
        // we can on
        //

        if (PopSimulate & POP_SIM_ALL_CAPABILITIES) {
            PopCapabilities.PowerButtonPresent = TRUE;
            PopCapabilities.SleepButtonPresent = TRUE;
            PopCapabilities.LidPresent = TRUE;
            PopCapabilities.SystemS1 = TRUE;
            PopCapabilities.SystemS2 = TRUE;
            PopCapabilities.SystemS3 = TRUE;
            PopCapabilities.SystemS4 = TRUE;
            PopAttributes[POP_DISK_SPINDOWN_ATTRIBUTE].Count += 1;
        }

        //
        // Load current status and policie information
        //

        PopAcquirePolicyLock ();

        Status = PopOpenPowerKey (&handle);
        if (NT_SUCCESS(Status)) {
            //
            // Read heuristics structure
            //

            RtlInitUnicodeString (&UnicodeString, PopHeuristicsRegName);
            Status = ZwQueryValueKey (
                            handle,
                            &UnicodeString,
                            KeyValuePartialInformation,
                            &PartialInformation,
                            sizeof (PartialInformation),
                            &Length
                            );

            Length -= FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
            HeuristicData = (PPOP_HEURISTICS) PartialInformation.Inf.Data;

            if (NT_SUCCESS(Status)  &&
                Length == sizeof(PopHeuristics)) {

                //
                // If we see a version 2 heuristics field, it probably has a
                // bogus IoTransferWeight. So restart the sampling by setting
                // the number of samples to zero and update the version to the
                // current one. This little hack was put into place approx
                // build 1920 and can be probably be removed sometime after
                // shipping NT5 beta3
                //

                if (HeuristicData->Version <= POP_HEURISTICS_VERSION_CLEAR_TRANSFER) {
                    HeuristicData->Version = POP_HEURISTICS_VERSION;
                    HeuristicData->IoTransferSamples = 0;
                }
                if (HeuristicData->Version == POP_HEURISTICS_VERSION) {
                    //
                    // Restore values
                    //

                    RtlCopyMemory (&PopHeuristics, HeuristicData, sizeof(*HeuristicData));
                }
            }

            //
            // Verify sane values
            //

            PopHeuristics.Version = POP_HEURISTICS_VERSION;
            if (!PopHeuristics.IoTransferWeight) {
                PopHeuristics.IoTransferWeight = 999999;
                PopHeuristics.IoTransferSamples = 0;
                PopHeuristics.IoTransferTotal = 0;
            }

            //
            // Read administrator policy.
            //

            RtlInitUnicodeString (&UnicodeString, PopAdminRegName);
            Status = ZwQueryValueKey (
                            handle,
                            &UnicodeString,
                            KeyValuePartialInformation,
                            &PartialInformation,
                            sizeof (PartialInformation),
                            &Length
                            );


            if (NT_SUCCESS(Status)) {
                Length -= FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
                AdminPolicy = (PADMINISTRATOR_POWER_POLICY) PartialInformation.Inf.Data;
                try {
                    Status = PopApplyAdminPolicy (FALSE, AdminPolicy, Length);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    ASSERT (GetExceptionCode());
                }
            } else if(Status == STATUS_OBJECT_NAME_NOT_FOUND) {

                // It's okay if it isn't there.  The key is optional.
                Status = STATUS_SUCCESS;
            }
            NtClose (handle);
        }

        //
        // Read and apply the current policies
        //
        Status = PopResetCurrentPolicies ();
        PopReleasePolicyLock (FALSE);
    
        //
        // Turn on idle detection
        //
        PopIdleScanTime.HighPart = 0;
        PopIdleScanTime.LowPart = 10*1000*1000 * PO_IDLE_SCAN_INTERVAL;

        KeInitializeTimer(&PopIdleScanTimer);
        KeSetTimerEx(
            &PopIdleScanTimer,
            PopIdleScanTime,
            PO_IDLE_SCAN_INTERVAL*1000,  // call wants milliseconds
            &PopIdleScanDpc                                                                                                              
            );
    
    }

    //
    // Success
    //

    return (BOOLEAN)NT_SUCCESS(Status);
}

VOID
PopDefaultPolicy (
    IN OUT PSYSTEM_POWER_POLICY Policy
    )
{
    ULONG       i;


    RtlZeroMemory (Policy, sizeof(SYSTEM_POWER_POLICY));
    Policy->Revision             = 1;
    Policy->PowerButton.Action   = PowerActionShutdownOff;
    Policy->SleepButton.Action   = PowerActionSleep;
    Policy->LidClose.Action      = PowerActionNone;
    Policy->LidOpenWake          = PowerSystemWorking;
    Policy->MinSleep             = PowerSystemSleeping1;
    Policy->MaxSleep             = PowerSystemSleeping3;
    Policy->ReducedLatencySleep  = PowerSystemSleeping1;
    Policy->WinLogonFlags        = 0;
    Policy->FanThrottleTolerance = PO_NO_FAN_THROTTLE;
    Policy->ForcedThrottle       = PO_NO_FORCED_THROTTLE;
    Policy->OverThrottled.Action = PowerActionNone;
    Policy->BroadcastCapacityResolution = 25;
    for (i=0; i < NUM_DISCHARGE_POLICIES; i++) {
        Policy->DischargePolicy[i].MinSystemState = PowerSystemSleeping1;
    }
}

VOID
PopDefaultProcessorPolicy(
    IN OUT PPROCESSOR_POWER_POLICY Policy
    )
{
    int i;

    RtlZeroMemory(Policy, sizeof(PROCESSOR_POWER_POLICY));
    Policy->Revision = 1;
    Policy->PolicyCount = 3;

    for (i = 0; i < 3; i++) {

        //
        // Initialize the entries to some common values
        //
        Policy->Policy[i].TimeCheck      = PopIdleTimeCheck;
        Policy->Policy[i].PromoteLimit   = PopIdleDefaultPromoteTime;
        Policy->Policy[i].DemoteLimit    = PopIdleDefaultDemoteTime;
        Policy->Policy[i].PromotePercent = (UCHAR) PopIdleDefaultPromotePercent;
        Policy->Policy[i].DemotePercent  = (UCHAR) PopIdleDefaultDemotePercent;
        Policy->Policy[i].AllowDemotion  = 1;
        Policy->Policy[i].AllowPromotion = 1;

        //
        // Special cases
        //
        if (i == 0) {

            Policy->Policy[i].PromoteLimit   = PopIdleDefaultPromoteFromC1Time;
            Policy->Policy[i].PromotePercent = (UCHAR) PopIdleDefaultPromoteFromC1Percent;
            Policy->Policy[i].TimeCheck      = PopIdle0TimeCheck;

            //
            // Do Something special if we are a multiprocessor machine..
            //
            if (KeNumberProcessors > 1) {

                Policy->Policy[i].DemotePercent = (UCHAR) PopIdleTo0Percent;

            } else {

                Policy->Policy[i].DemotePercent = 0;
                Policy->Policy[i].AllowDemotion = 0;

            }

        } else if (i == 1) {

            Policy->Policy[i].DemoteLimit   = PopIdleDefaultDemoteToC1Time;
            Policy->Policy[i].DemotePercent = (UCHAR) PopIdleDefaultDemoteToC1Percent;

        } else if (i == 2) {

            Policy->Policy[i].AllowPromotion = 0;
            Policy->Policy[i].PromoteLimit = (ULONG) -1;
            Policy->Policy[i].PromotePercent = 0;

        }

    }


}


VOID
PoInitDriverServices (
    IN ULONG Phase
    )
{
    ULONG           TickRate;
    LARGE_INTEGER   PerfRate;

    if (Phase == 0) {
        TickRate = KeQueryTimeIncrement();
        KeQueryPerformanceCounter (&PerfRate);

        //
        // Connect to any policy devices which arrive
        //

        PopRegisterForDeviceNotification (
                (LPGUID) &GUID_CLASS_INPUT,
                PolicyDeviceSystemButton
                );

        PopRegisterForDeviceNotification (
                (LPGUID) &GUID_DEVICE_THERMAL_ZONE,
                PolicyDeviceThermalZone
                );

        PopRegisterForDeviceNotification (
                (LPGUID) &GUID_DEVICE_SYS_BUTTON,
                PolicyDeviceSystemButton
                );

        PopRegisterForDeviceNotification (
                (LPGUID) &GUID_DEVICE_BATTERY,
                PolicyDeviceBattery
                );


        //
        // Initialize global idle values
        //
        PopIdle0PromoteTicks = PopIdleFrom0Delay * US2TIME / TickRate + 1;
        PopIdle0PromoteLimit = (PopIdleFrom0Delay * US2TIME / TickRate) * 100 /
            PopIdleFrom0IdlePercent;

        //
        // Initialize global perf values
        //
        PopPerfTimeTicks         = PopPerfTimeDelta * US2TIME / TickRate + 1;
        PopPerfCriticalTimeTicks = PopPerfCriticalTimeDelta * US2TIME / TickRate + 1;

        //
        // Initialize DPC for idle device timer
        //
        KeInitializeDpc(&PopIdleScanDpc, PopScanIdleList, NULL);
        return ;
    }
}


VOID
PopRegisterForDeviceNotification (
    IN LPGUID                   Guid,
    IN POP_POLICY_DEVICE_TYPE   DeviceType
    )
{
    NTSTATUS    Status;
    PVOID       junk;

    Status = IoRegisterPlugPlayNotification (
                    EventCategoryDeviceInterfaceChange,
                    0,
                    Guid,
                    IoPnpDriverObject,
                    PopNotifyPolicyDevice,
                    (PVOID) (ULONG_PTR) DeviceType,
                    &junk
                    );

    ASSERT (NT_SUCCESS(Status));
}

VOID
PoInitHiberServices (
    IN BOOLEAN  Setup
    )
/*++

Routine Description:

    This routine reserves the hiberfile if the function has been enabled.
    It is called after autocheck (chkdsk) has run and  the paging files
    have been opened.  (as performing IO to the hiberfil before this
    time will mark the volume as dirty causing chkdsk to be required)

    N.B. Caller's pervious mode must be kernel mode

Arguments:

    SetupBoot     - if TRUE this is text mode setup boot
                    if FALSE this is normal system boot

Return Value:

    none

--*/
{
    NTSTATUS Status;
    SYSTEM_POWER_CAPABILITIES   PowerCapabilities;

    UNREFERENCED_PARAMETER (Setup);

    //
    // If a hiber file was reserved before then try to reserve one this
    // time too.
    //
    Status = ZwPowerInformation(SystemPowerCapabilities,
                                NULL,
                                0,
                                &PowerCapabilities,
                                sizeof(SYSTEM_POWER_CAPABILITIES));
    ASSERT(NT_SUCCESS(Status));

    if (PopHeuristics.HiberFileEnabled) {
        PopAcquirePolicyLock();
        PopEnableHiberFile(TRUE);

        //
        // If the system does not support S4 anymore (because someone enabled PAE
        // or installed a legacy driver) then delete the hiberfile now. Note we have
        // to enable it before disabling it or the file doesn't get deleted.
        //
        // Also force HiberFileEnabled back to TRUE in PopHeuristics. This is so we
        // will try and reenable hibernation on the next boot. So if someone boots to
        // safe mode, hibernation will still be enabled after they reboot.
        //
        if (!PowerCapabilities.SystemS4) {
            PopEnableHiberFile(FALSE);
            PopHeuristics.HiberFileEnabled = TRUE;
            PopHeuristics.Dirty = TRUE;
            PopSaveHeuristics();
        }
        PopReleasePolicyLock(TRUE);
    }


    //
    // Base drivers are loaded, start dispatching policy irps
    //

    PopDispatchPolicyIrps = TRUE;
    PopGetPolicyWorker (PO_WORKER_MAIN);
    PopCheckForWork (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\pop.h ===
/*++ BUILD Version: 0002

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pop.h

Abstract:

    This module contains the private structure definitions and APIs used by
    the NT Power Manager.

Author:


Revision History:


--*/

#ifndef _POP_
#define _POP_


#ifndef FAR
#define FAR
#endif

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4706)   // assignment within conditional

#include "ntos.h"
#include "ntiolog.h"
#include "ntiologc.h"
#include "poclass.h"
#include "zwapi.h"
#include "wdmguid.h"
#include "..\io\ioverifier.h"

#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"

//
// constants
//
#define PO_IDLE_SCAN_INTERVAL  1       // scan interval in seconds

//
// Values for ios.Parameters.SystemContext
#define POP_NO_CONTEXT      0
#define POP_FLAG_CONTEXT    1                         // if true, it's flags
#define POP_DEVICE_REQUEST  (0x2 | POP_FLAG_CONTEXT)  // an irp sent by RequestPowerChange
#define POP_INRUSH_CONTEXT  (0x4 | POP_FLAG_CONTEXT)  // the active INRUSH irp
#define POP_COUNT_CONTEXT   0xff000000                // byte used for next counting
#define POP_COUNT_SHIFT     24


//
// pool tags
//
#define POP_DOPE_TAG    'EPOD'      // Device Object Power Extension
#define POP_POWI_TAG    'IWOP'      // power work item
#define POP_THRM_TAG    'mrhT'
#define POP_PSWT_TAG    'twSP'
#define POP_PSTA_TAG    'atsP'
#define POP_PDSS_TAG    'ssDP'
#define POP_VOLF_TAG    'floV'
#define POP_HMAP_TAG    'pamH'
#define POP_CLON_TAG    'NOLC'
#define POP_HIBR_TAG    'rbih'
#define POP_IDLE_TAG    'eldi'

#define POP_DPC_TAG     'PDNP'      // power abort dpc
#define POP_PNCS_TAG    'SCNP'      // power channel summary
#define POP_PNSC_TAG    'CSNP'      // power notify source
#define POP_PNTG_TAG    'GTNP'      // power notify target
#define POP_PNB_TAG     ' BNP'      // power notify block

// tags used in hiber process
#define POP_MEM_TAG             ' meM'
#define POP_DEBUG_RANGE_TAG     'RGBD'
#define POP_DEBUGGER_TAG        ' gbD'
#define POP_STACK_TAG           'cats'
#define POP_PCR_TAG             ' rcp'
#define POP_PCRB_TAG            'brcp'
#define POP_COMMON_BUFFER_TAG   'fubc'
#define POP_MEMIMAGE_TAG        'gmiM'
#define POP_PACW_TAG            'WcAP'

#define POP_NONO        'ONON'      // freed structure, compare with pool
                                    // tag to see what it was


// debugging

#define PopInternalError(a) _PopInternalError( (a << 16) | __LINE__ )

// Bugcheck sub-codes
#define POP_IRP          1
#define POP_INTERNAL     2
#define POP_NTAPI        3
#define POP_BATT         4
#define POP_THERMAL      5
#define POP_INFO         6
#define POP_MISC         7
#define POP_SYS          8
#define POP_IDLE         9
#define POP_HIBER       10


// bugcheck reason codes
#define DEVICE_DELETED_WITH_POWER_IRPS         1
#define DEVICE_SYSTEM_STATE_HUNG               2
#define DEVICE_IRP_PENDING_ERROR               3

//
// Debug
//

#if DBG
    extern ULONG PoDebug;
    #define PoPrint(l,m)    if(l & PoDebug) DbgPrint m
    #define PoAssert(l,m)   if(l & PoDebug) ASSERT(m)
#else
    #define PoPrint(l,m)
    #define PoAssert(l,m)
#endif

#define PO_ERROR            0x00000001
#define PO_WARN             0x00000002
#define PO_BATT             0x00000004
#define PO_PACT             0x00000008
#define PO_NOTIFY           0x00000010
#define PO_THERM            0x00000020
#define PO_THROTTLE         0x00000040
#define PO_HIBERNATE        0x00000080
#define PO_POCALL           0x00000200
#define PO_SYSDEV           0x00000400
#define PO_THROTTLE_DETAIL  0x10000000
#define PO_THERM_DETAIL     0x20000000
#define PO_SIDLE            0x40000000
#define PO_HIBER_MAP        0x80000000


extern  ULONG       PopSimulate;

#define POP_SIM_CAPABILITIES                0x00000001
#define POP_SIM_ALL_CAPABILITIES            0x00000002
#define POP_ALLOW_AC_THROTTLE               0x00000004
#define POP_IGNORE_S1                       0x00000008
#define POP_IGNORE_UNSUPPORTED_DRIVERS      0x00000010
#define POP_IGNORE_S3                       0x00000020
#define POP_IGNORE_S2                       0x00000040
#define POP_LOOP_ON_FAILED_DRIVERS          0x00000080
#define POP_CRC_MEMORY                      0x00000100
#define POP_IGNORE_CRC_FAILURES             0x00000200
#define POP_TEST_CRC_MEMORY                 0x00000400
#define POP_DEBUG_HIBER_FILE                0x00000800
#define POP_RESET_ON_HIBER                  0x00001000
#define POP_IGNORE_S4                       0x00002000
//#define POP_USE_S4BIOS                      0x00004000
#define POP_IGNORE_HIBER_SYMBOL_UNLOAD      0x00008000
#define POP_ENABLE_HIBER_PERF               0x00010000
#define POP_WAKE_DEVICE_AFTER_SLEEP         0x00020000
#define POP_WAKE_DEADMAN                    0x00040000

//
// These hold the current values for the power policy
//
extern ULONG    PopIdleDefaultMinThrottle;
extern ULONG    PopIdleThrottleCheckRate;
extern ULONG    PopIdleThrottleCheckTimeout;
extern ULONG    PopIdleFrom0Delay;
extern ULONG    PopIdleFrom0IdlePercent;
extern ULONG    PopIdle0PromoteTicks;
extern ULONG    PopIdle0PromoteLimit;
extern ULONG    PopIdle0TimeCheck;
extern ULONG    PopIdleTimeCheck;
extern ULONG    PopIdleTo0Percent;
extern ULONG    PopIdleDefaultDemotePercent;
extern ULONG    PopIdleDefaultDemoteTime;
extern ULONG    PopIdleDefaultPromotePercent;
extern ULONG    PopIdleDefaultPromoteTime;
extern ULONG    PopIdleDefaultDemoteToC1Percent;
extern ULONG    PopIdleDefaultDemoteToC1Time;
extern ULONG    PopIdleDefaultPromoteFromC1Percent;
extern ULONG    PopIdleDefaultPromoteFromC1Time;

//
// These hold the current values for the throttle policy
//
extern ULONG    PopPerfTimeDelta;
extern ULONG    PopPerfTimeTicks;
extern ULONG    PopPerfCriticalTimeDelta;
extern ULONG    PopPerfCriticalTimeTicks;
extern ULONG    PopPerfCriticalFrequencyDelta;
extern ULONG    PopPerfIncreasePercentModifier;
extern ULONG    PopPerfIncreaseAbsoluteModifier;
extern ULONG    PopPerfDecreasePercentModifier;
extern ULONG    PopPerfDecreaseAbsoluteModifier;
extern ULONG    PopPerfIncreaseTimeValue;
extern ULONG    PopPerfIncreaseMinimumTime;
extern ULONG    PopPerfDecreaseTimeValue;
extern ULONG    PopPerfDecreaseMinimumTime;
extern ULONG    PopPerfDegradeThrottleMinCapacity;
extern ULONG    PopPerfDegradeThrottleMinFrequency;
extern ULONG    PopPerfMaxC3Frequency;

//
// Universal Power Data - stored in DeviceObject->DeviceObjectExtension->PowerFlags
//

#define POPF_SYSTEM_STATE       0xf         // 4 bits for S0 to S5
#define POPF_DEVICE_STATE       0xf0        // 4 bits to hold D0 to D3


#define POPF_SYSTEM_ACTIVE      0x100       // True if S irp active at this DO
#define POPF_SYSTEM_PENDING     0x200       // True if S irp pending (0x100 must be 1)
#define POPF_DEVICE_ACTIVE      0x400       // same as SYSTEM_ACTIVE but for DEVICE
#define POPF_DEVICE_PENDING     0x800       // same as SYSTEM_PENDING but for DEVICE

#define PopSetDoSystemPowerState(doe, value) \
    {doe->PowerFlags &= ~POPF_SYSTEM_STATE; doe->PowerFlags |= (value & POPF_SYSTEM_STATE);}

#define PopGetDoSystemPowerState(doe) \
    (doe->PowerFlags & POPF_SYSTEM_STATE)

#define PopSetDoDevicePowerState(doe, value) \
    {doe->PowerFlags &= ~POPF_DEVICE_STATE; doe->PowerFlags |= ((value << 4) & POPF_DEVICE_STATE);}

#define PopGetDoDevicePowerState(doe) \
    ((doe->PowerFlags & POPF_DEVICE_STATE) >> 4)

DEVICE_POWER_STATE
PopLockGetDoDevicePowerState(
    IN PDEVOBJ_EXTENSION Doe
    );



//
// Power work queue item declaration
//

//
// Power Irp Serialization data
//
extern  KSPIN_LOCK      PopIrpSerialLock;
extern  LIST_ENTRY      PopIrpSerialList;
extern  ULONG           PopIrpSerialListLength;
extern  BOOLEAN         PopInrushPending;
extern  PIRP            PopInrushIrpPointer;
extern  LONG            PopInrushIrpReferenceCount;


#define PopLockIrpSerialList(OldIrql) \
    KeAcquireSpinLock(&PopIrpSerialLock, OldIrql);

#define PopUnlockIrpSerialList(OldIrql) \
    KeReleaseSpinLock(&PopIrpSerialLock, OldIrql);

//
// PopSystemIrpDispatchWorker control, etc
//
extern KSPIN_LOCK   PopWorkerLock;
extern ULONG        PopCallSystemState;
#define PO_CALL_SYSDEV_QUEUE        0x01
#define PO_CALL_NON_PAGED           0x02

extern  LIST_ENTRY  PopRequestedIrps;

#define PopLockWorkerQueue(OldIrql) \
    KeAcquireSpinLock(&PopWorkerLock, OldIrql);

#define PopUnlockWorkerQueue(OldIrql) \
    KeReleaseSpinLock(&PopWorkerLock, OldIrql);


//
// Idle Detection State
//
extern  KDPC            PopIdleScanDpc;
extern  LARGE_INTEGER   PopIdleScanTime;
extern  KTIMER          PopIdleScanTimer;
extern  LIST_ENTRY      PopIdleDetectList;
extern  KSPIN_LOCK      PopDopeGlobalLock;

#define PopLockDopeGlobal(OldIrql) \
    KeAcquireSpinLock(&PopDopeGlobalLock, OldIrql)

#define PopUnlockDopeGlobal(OldIrql) \
    KeReleaseSpinLock(&PopDopeGlobalLock, OldIrql)


#define                 PO_IDLE_CONSERVATION    FALSE
#define                 PO_IDLE_PERFORMANCE     TRUE
extern  BOOLEAN         PopIdleDetectionMode;


//
// Notify structures
//
extern  ERESOURCE       PopNotifyLock;
extern  ULONG           PopInvalidNotifyBlockCount;

typedef struct _POWER_CHANNEL_SUMMARY {
    ULONG           Signature;
    ULONG           TotalCount;
    ULONG           D0Count;
    LIST_ENTRY      NotifyList; // or invalid list entry if invalid
} POWER_CHANNEL_SUMMARY, *PPOWER_CHANNEL_SUMMARY;

typedef struct  _DEVICE_OBJECT_POWER_EXTENSION {

    // embedded idle control variables
    LONG                IdleCount;
    ULONG               ConservationIdleTime;
    ULONG               PerformanceIdleTime;
    PDEVICE_OBJECT      DeviceObject;
    LIST_ENTRY          IdleList;                   // our link into global idle list
    UCHAR               DeviceType;
    DEVICE_POWER_STATE  State;

    // notify vars
    LIST_ENTRY          NotifySourceList;       // Head of list of source structures, one
                                                // element in list for each notify channel
                                                // we support.

    LIST_ENTRY          NotifyTargetList;       // Mirror to sources list.

    POWER_CHANNEL_SUMMARY PowerChannelSummary;  // record of states of devobjs
                                                // that make up power channel

    // misc
    LIST_ENTRY          Volume;

} DEVICE_OBJECT_POWER_EXTENSION, *PDEVICE_OBJECT_POWER_EXTENSION;


typedef struct _POWER_NOTIFY_BLOCK {
    ULONG           Signature;
    LONG            RefCount;
    LIST_ENTRY      NotifyList;
    PPO_NOTIFY      NotificationFunction;
    PVOID           NotificationContext;
    ULONG           NotificationType;
    PPOWER_CHANNEL_SUMMARY  PowerChannel;
    BOOLEAN         Invalidated;
} POWER_NOTIFY_BLOCK, *PPOWER_NOTIFY_BLOCK;

//
// Each devobj which is part of a power channel with a notify posted on it
// has a list of these structurs.  PoSetPowerState runs this list to go find
// who to notify
//
typedef struct _POWER_NOTIFY_SOURCE {
    ULONG                           Signature;
    LIST_ENTRY                      List;
    struct _POWER_NOTIFY_TARGET     *Target;
    PDEVICE_OBJECT_POWER_EXTENSION  Dope;
} POWER_NOTIFY_SOURCE, *PPOWER_NOTIFY_SOURCE;

//
// There is a target structure for each source structure, the target structure is used
// to find the actual notify list, AND to get back to the source structure for cleanup.
//
typedef struct _POWER_NOTIFY_TARGET {
    ULONG                       Signature;
    LIST_ENTRY                  List;
    PPOWER_CHANNEL_SUMMARY      ChannelSummary;
    PPOWER_NOTIFY_SOURCE        Source;
} POWER_NOTIFY_TARGET, *PPOWER_NOTIFY_TARGET;

//
// Policy worker thread
//  There is never more then one worker thread of each type.  Dispatching is
//  is always done via MAIN_POLICY_WORKER type which may then alter its type
//  to something else to allow another main policy worker thread to start if
//  needed
//


#define PO_WORKER_MAIN              0x00000001
#define PO_WORKER_ACTION_PROMOTE    0x00000002
#define PO_WORKER_ACTION_NORMAL     0x00000004
#define PO_WORKER_NOTIFY            0x00000008
#define PO_WORKER_SYS_IDLE          0x00000010
#define PO_WORKER_TIME_CHANGE       0x00000020
#define PO_WORKER_STATUS            0x80000000

typedef ULONG
(*POP_WORKER_TYPES) (
    VOID
    );

extern KSPIN_LOCK PopWorkerSpinLock;
extern ULONG PopWorkerStatus;
extern ULONG PopWorkerPending;
extern LONG PopNotifyEvents;



//
// Policy irp handler
//

typedef VOID
(*POP_IRP_HANDLER) (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

extern const POP_WORKER_TYPES    PopWorkerTypes[];
extern LIST_ENTRY          PopPolicyIrpQueue;
extern WORK_QUEUE_ITEM     PopPolicyWorker;


//
// Notification bits for policy notifcation worker thread
//

typedef struct {
    VOID                    (*Function)(ULONG);
    ULONG                   Arg;
} POP_NOTIFY_WORK, *PPOP_NOTIFY_WORK;

#define PO_NOTIFY_BUTTON_RECURSE            0x00000001
#define PO_NOTIFY_FULL_WAKE                 0x00000002
#define PO_NOTIFY_POLICY_CALLBACK           0x00000004
#define PO_NOTIFY_ACDC_CALLBACK             0x00000008
#define PO_NOTIFY_POLICY                    0x00000010
#define PO_NOTIFY_DISPLAY_REQUIRED          0x00000020
#define PO_NOTIFY_BATTERY_STATUS            0x00000040
#define PO_NOTIFY_EVENT_CODES               0x00000080
#define PO_NOTIFY_CAPABILITIES              0x00000100
#define PO_NOTIFY_STATE_FAILURE             0x00000200
#define PO_NOTIFY_PROCESSOR_POLICY_CALLBACK 0x00000400
#define PO_NOTIFY_PROCESSOR_POLICY          0x00000800
#define PO_NUMBER_NOTIFY                    12

#define POP_MAX_EVENT_CODES     4
extern ULONG PopEventCode[];
extern BOOLEAN PopDispatchPolicyIrps;

//
// Types for POP_ACTION_TRIGGER
//

typedef enum {
    PolicyDeviceSystemButton,
    PolicyDeviceThermalZone,
    PolicyDeviceBattery,
    PolicyInitiatePowerActionAPI,
    PolicySetPowerStateAPI,
    PolicyImmediateDozeS4,
    PolicySystemIdle
} POP_POLICY_DEVICE_TYPE;

//
// Types of sleep promotion/substitution.
//
typedef enum {

    //
    // Power state is lightened until all alternatives have been exhausted.
    //
    SubstituteLightenSleep,

    //
    // Power state is lightened until all alternatives have been exhausted. If
    // no alternatives were available, lightest overall *sleeping* state is
    // chosen (bounded between S1 and S3.)
    //
    SubstituteLightestOverallDownwardBounded,

    //
    // Power state is deepened until it is advanced beyond PowerSystemHibernate,
    // in which case all alternatives have been exhausted.
    //
    SubstituteDeepenSleep

} POP_SUBSTITUTION_POLICY;

//
// Wait structure for synchronous triggers
//

typedef struct _POP_TRIGGER_WAIT {
    KEVENT                  Event;
    NTSTATUS                Status;
    LIST_ENTRY              Link;
    struct _POP_ACTION_TRIGGER  *Trigger;
} POP_TRIGGER_WAIT, *PPOP_TRIGGER_WAIT;

//
// Trigger state for something which causes an action
//

typedef struct _POP_ACTION_TRIGGER {
    POP_POLICY_DEVICE_TYPE  Type;
    UCHAR                   Flags;
    UCHAR                   Spare[3];

    union {
        struct {
            ULONG           Level;
        } Battery;

        PPOP_TRIGGER_WAIT   Wait;
    } ;

} POP_ACTION_TRIGGER, *PPOP_ACTION_TRIGGER;

#define PO_TRG_USER             0x01    // User action initiated
#define PO_TRG_SYSTEM           0x02    // System action initiated
#define PO_TRG_SYNC             0x20    // Trigger is synchronous
#define PO_TRG_SET              0x80    // Event enabled or disabled

//
// Structure to track systems power state for policy manager
// from composite battery device
//

#define PO_NUM_POWER_LEVELS    4

typedef struct _POP_COMPOSITE_BATTERY {
    //
    // State of composite battery processing
    //

    UCHAR                   State;
    UCHAR                   Spare[3];

    //
    // Connection to composite battery
    //

    ULONG                   Tag;

    //
    // Battery status and time it was valid
    //

    ULONGLONG               StatusTime;
    BATTERY_STATUS          Status;

    //
    // Battery trigger flags to indicate which discharge
    // actions have already fired
    //

    POP_ACTION_TRIGGER      Trigger[PO_NUM_POWER_LEVELS];

    //
    // Battery estimated time and time it was computed
    //

    ULONGLONG               EstTimeTime;
    ULONG                   EstTime;            // from battery
    ULONG                   AdjustedEstTime;

    //
    // Battery information
    //

    BATTERY_INFORMATION     Info;

    //
    // Info on outstanding status request to composite battery.
    // The state machine for the battery is handled such that
    // outstanding requests are sent into this structure, then
    // the "State" field is set (which specifies the request).
    // We then read info out of this union and fill in the
    // appropriate field in this POP_COMPOSITE_BATTERY
    // structure.
    //

    PIRP                    StatusIrp;
    union {
        ULONG                       Tag;
        ULONG                       EstTime;
        BATTERY_STATUS              Status;
        BATTERY_INFORMATION         Info;
        BATTERY_WAIT_STATUS         Wait;
        BATTERY_QUERY_INFORMATION   QueryInfo;
    } u;

    //
    // Info for threads to wait for the current power state to
    // be computed.
    //

    BOOLEAN                 ThreadWaiting;
    KEVENT                  Event;

} POP_COMPOSITE_BATTERY;

// state values for POP_COMOSITE_BATTERY.State

#define PO_CB_NONE                  0
#define PO_CB_READ_TAG              1
#define PO_CB_WAIT_TAG              2
#define PO_CB_READ_INFO             3
#define PO_CB_READ_STATUS           4
#define PO_CB_READ_EST_TIME         5

#define PO_MAX_CB_CACHE_TIME        50000000 // 5 seconds

extern POP_COMPOSITE_BATTERY PopCB;

//
// Structure to track thermal zone state
//

typedef struct _POP_THERMAL_ZONE {

    //
    // List of all thermal zones
    //

    LIST_ENTRY              Link;

    //
    // Current state with driver
    //

    UCHAR                   State;
    UCHAR                   Flags;

    //
    // Cooling mode of thermal zone
    //

    UCHAR                   Mode;
    UCHAR                   PendingMode;

    //
    // Active cooling
    //

    UCHAR                   ActivePoint;
    UCHAR                   PendingActivePoint;

    //
    // Passive cooling state
    //

    LONG                    Throttle;

    ULONGLONG               LastTime;
    ULONG                   SampleRate;
    ULONG                   LastTemp;
    KTIMER                  PassiveTimer;
    KDPC                    PassiveDpc;

    POP_ACTION_TRIGGER      OverThrottled;

    //
    // Irp for talking with the thermal driver
    //

    PIRP                    Irp;

    //
    // Thermal info being read
    //

    THERMAL_INFORMATION     Info;

} POP_THERMAL_ZONE, *PPOP_THERMAL_ZONE;

// POP_THERMAL_ZONE.State
#define PO_TZ_NO_STATE      0
#define PO_TZ_READ_STATE    1
#define PO_TZ_SET_MODE      2
#define PO_TZ_SET_ACTIVE    3

// POP_THERMAL_ZONE.Flags
#define PO_TZ_THROTTLING    0x01
#define PO_TZ_CLEANUP       0x80

#define PO_TZ_THROTTLE_SCALE    10      // temp reported in 1/10ths kelin
#define PO_TZ_NO_THROTTLE   (100 * PO_TZ_THROTTLE_SCALE)

// PopCoolingMode
#define PO_TZ_ACTIVE        0
#define PO_TZ_PASSIVE       1
#define PO_TZ_INVALID_MODE  2

//
// Action timeouts
//

#define POP_ACTION_TIMEOUT              30
#define POP_ACTION_CANCEL_TIMEOUT       5

//
// Structure to track button & lid devices
//
typedef struct _POP_SWITCH_DEVICE {

    //
    // List of all switch devices
    //
    LIST_ENTRY                      Link;

    //
    // Current status
    //
    BOOLEAN                         GotCaps;
    BOOLEAN                         IsInitializing;
    BOOLEAN                         IsFailed;
    UCHAR                           TriggerState;
    ULONG                           IrpBuffer;
    ULONG                           Caps;

    //
    // Only valid for switches that
    // trigger both opening and shutting.
    // I.e. a lid switch.
    //
    BOOLEAN                         Opened;

} POP_SWITCH_DEVICE, *PPOP_SWITCH_DEVICE;

//
// Bookkeeping for Thread->PowerState and registered attributes set in the system
//

typedef struct {
    LONG                    Count;
    VOID                    (*Set)(ULONG);
    BOOLEAN                 NotifyOnClear;
    ULONG                   Arg;
} POP_STATE_ATTRIBUTE, *PPOP_STATE_ATTRIBUTE;


//
// N.B. These values correspond to the Log2 of the various
//      ES_... values as defined in ntpoapi.h.  See
//      PopApplyAttributeState() to see how these values are
//      dependent on this.
//      
#define POP_SYSTEM_ATTRIBUTE        0
#define POP_DISPLAY_ATTRIBUTE       1
#define POP_USER_ATTRIBUTE          2
#define POP_LOW_LATENCY_ATTRIBUTE   3
#define POP_DISK_SPINDOWN_ATTRIBUTE 4
#define POP_NUMBER_ATTRIBUTES       5
extern POP_STATE_ATTRIBUTE PopAttributes[];

// Flags for Thread->PowerState
// ES_SYSTEM_REQUIRED, ES_DISPLAY_REQUIRED

// Internal attrib flags
// NOTE: this flags are stored in the same flags values as ES_ flags, so they
// can not overlapped
#define POP_LOW_LATENCY             0x08
#define POP_DISK_SPINDOWN           0x10

//
// Presistant settings and heuristics which are not part of the
// saved policy structures
//

typedef struct {
    ULONG                   Version;
    BOOLEAN                 Dirty;
    BOOLEAN                 GetDumpStackVerified;
    BOOLEAN                 HiberFileEnabled;

    //
    // System idle heuristics
    //

    ULONG                   IoTransferTotal;
    ULONG                   IoTransferSamples;
    ULONG                   IoTransferWeight;

} POP_HEURISTICS, *PPOP_HEURISTICS;
extern POP_HEURISTICS PopHeuristics;

//
// Version 2 of the heuristics was always starting off
// with IoTransferWeight set to 99999. This is way too
// high and takes quite a while to get down to a reasonable
// level. With version three, we are smart enough to treat
// IoTransferSamples==0 as the starting point and start off
// much closer to reality.
//
// Version 3 of the heuristics were all built with garbage
// values for IoTransferWeight since the IoOtherTransfers
// counter is using pointers as values. So we upgrade that
// version as well.
//
// Version 4 of the heuristics has the IoOtherTransfers removed.
//
// Version 5 of the heuristics is the current version and is built
// with the corrected IoOtherTransfers.
//
// When a version 2, 3, or 4 heuristics is loaded from the registry,
// we upgrade it to 5, and zero the IoTransferSamples.
//
#define POP_HEURISTICS_VERSION_CLEAR_TRANSFER 0x04
#define POP_HEURISTICS_VERSION       0x05


typedef struct _POP_SHUTDOWN_BUG_CHECK {
    ULONG Code;
    ULONG_PTR Parameter1;
    ULONG_PTR Parameter2;
    ULONG_PTR Parameter3;
    ULONG_PTR Parameter4;
} POP_SHUTDOWN_BUG_CHECK, *PPOP_SHUTDOWN_BUG_CHECK;


//
// Memory map information
//


typedef struct _POP_MEMORY_RANGE {
    LIST_ENTRY              Link;
    ULONG                   Tag;
    PFN_NUMBER              StartPage;
    PFN_NUMBER              EndPage;
    PVOID                   CloneVa;
} POP_MEMORY_RANGE, *PPOP_MEMORY_RANGE;

//
// Attention: not exceed HIBER_PTES in boot\inc\bldr.h
//

#define POP_MAX_MDL_SIZE        16

#define PO_MAX_MAPPED_CLONES (64*1024*1024)
#define POP_FREE_THRESHOLD      256             // Leave 1MB to 2MB on the free list
#define POP_FREE_ALLOCATE_SIZE  (256)           // allocate 1024kb at a time

typedef struct _POP_HIBER_CONTEXT {

    //
    // Flags which control the type of hiber operation
    //

    BOOLEAN                 WriteToFile;
    BOOLEAN                 ReserveLoaderMemory;
    BOOLEAN                 ReserveFreeMemory;
    BOOLEAN                 VerifyOnWake;
    BOOLEAN                 Reset;
    UCHAR                   HiberFlags;

    //
    // Hibernate link file
    //

    BOOLEAN                 LinkFile;
    HANDLE                  LinkFileHandle;

    //
    // Map of memory pages and how they should be handled
    // during the hibernate operation
    //

    KSPIN_LOCK              Lock;
    BOOLEAN                 MapFrozen;
    RTL_BITMAP              MemoryMap;
    LIST_ENTRY              ClonedRanges;
    ULONG                   ClonedRangeCount;

    //
    // placeholders for enumerating through the ranges
    //
    PLIST_ENTRY             NextCloneRange;
    PFN_NUMBER              NextPreserve;

    //
    // Pages of memory collected out of the system
    //

    PMDL                    LoaderMdl;
    PMDL                    Clones;
    PUCHAR                  NextClone;
    PFN_NUMBER              NoClones;
    PMDL                    Spares;
    ULONGLONG               PagesOut;

    //
    // hiber file io
    //

    PVOID                   IoPage;
    PVOID                   CurrentMcb;
    PDUMP_STACK_CONTEXT     DumpStack;
    PKPROCESSOR_STATE       WakeState;

    //
    // Misc
    //

    ULONG                   NoRanges;
    ULONG_PTR               HiberVa;
    PHYSICAL_ADDRESS        HiberPte;
    NTSTATUS                Status;

    //
    // For generating the image
    //

    PPO_MEMORY_IMAGE        MemoryImage;
    PPO_MEMORY_RANGE_ARRAY  TableHead;

    // Compression

    PUCHAR CompressionWorkspace;
    PUCHAR CompressedWriteBuffer;
    PULONG PerformanceStats; // Performance Stats

    PVOID  CompressionBlock; // It's of COMPRESSION_BLOCK type (see hiber.c)
    PVOID  DmaIO;            // It's of IOREGIONS type (see hiber.c)
    PVOID  TemporaryHeap;    // It's of POP_HIBER_HEAP type (see hiber.c)

    //
    // Perf info
    //
    PO_HIBER_PERF   PerfInfo;
} POP_HIBER_CONTEXT, *PPOP_HIBER_CONTEXT;

extern ULONG PopMaxPageRun;
extern BOOLEAN PoHiberInProgress;
extern BOOLEAN PopFailedHibernationAttempt;  // we tried to hibernate and failed.

typedef struct {
    HANDLE                  FileHandle;
    PFILE_OBJECT            FileObject;
    PFN_NUMBER              FilePages;
    PLARGE_INTEGER          NonPagedMcb;
    PLARGE_INTEGER          PagedMcb;
    ULONG                   McbSize;
    ULONG                   McbCheck;
} POP_HIBER_FILE, *PPOP_HIBER_FILE;
extern POP_HIBER_FILE  PopHiberFile;
extern POP_HIBER_FILE  PopHiberFileDebug;

//
// Policy manager action in progress state
//

#define MAX_SYSTEM_POWER_IRPS   20

typedef struct _POP_DEVICE_POWER_IRP {
    SINGLE_LIST_ENTRY       Free;
    PIRP                    Irp;
    PPO_DEVICE_NOTIFY       Notify;
    LIST_ENTRY              Pending;
    LIST_ENTRY              Complete;
    LIST_ENTRY              Abort;
    LIST_ENTRY              Failed;
} POP_DEVICE_POWER_IRP, *PPOP_DEVICE_POWER_IRP;


typedef struct _POP_DEVICE_SYS_STATE {
    //
    // Current device notification
    //

    UCHAR                   IrpMinor;
    SYSTEM_POWER_STATE      SystemState;

    //
    // Device notification synchronization
    //

    KEVENT                  Event;
    KSPIN_LOCK              SpinLock;
    PKTHREAD                Thread;

    //
    // Notification list
    //

    BOOLEAN                 GetNewDeviceList;
    PO_DEVICE_NOTIFY_ORDER  Order;

    //
    // Current device notification state
    //

    NTSTATUS                Status;
    PDEVICE_OBJECT          FailedDevice;
    BOOLEAN                 Waking;
    BOOLEAN                 Cancelled;
    BOOLEAN                 IgnoreErrors;
    BOOLEAN                 IgnoreNotImplemented;
    BOOLEAN                 WaitAny;
    BOOLEAN                 WaitAll;

    //
    // PoCall's present irp queue for pagable irp
    //

    LIST_ENTRY              PresentIrpQueue;

    //
    // Head pointers
    //

    POP_DEVICE_POWER_IRP    Head;

    //
    // Structure to track each outstanding device power irp
    //

    POP_DEVICE_POWER_IRP    PowerIrpState[MAX_SYSTEM_POWER_IRPS];

} POP_DEVICE_SYS_STATE, *PPOP_DEVICE_SYS_STATE;



//
// Tests to see if any POWER_ACTION.Flags are set that shouldn't be
//
#define ARE_POWER_ACTION_POLICY_FLAGS_BOGUS(_flags) (  (_flags) &                      \
                                                      ~(POWER_ACTION_QUERY_ALLOWED  |  \
                                                        POWER_ACTION_UI_ALLOWED     |  \
                                                        POWER_ACTION_OVERRIDE_APPS  |  \
                                                        POWER_ACTION_LIGHTEST_FIRST |  \
                                                        POWER_ACTION_LOCK_CONSOLE   |  \
                                                        POWER_ACTION_DISABLE_WAKES  |  \
                                                        POWER_ACTION_CRITICAL) )



typedef struct _POP_POWER_ACTION {
    //
    // Current state of power action
    //

    UCHAR                   Updates;
    UCHAR                   State;
    BOOLEAN                 Shutdown;

    //
    // Current desired power action
    //

    POWER_ACTION            Action;
    SYSTEM_POWER_STATE      LightestState;
    ULONG                   Flags;
    NTSTATUS                Status;

    UCHAR                   IrpMinor;
    SYSTEM_POWER_STATE      SystemState;
    SYSTEM_POWER_STATE      NextSystemState;
    PPOP_SHUTDOWN_BUG_CHECK ShutdownBugCode;

    //
    // Current state of device notifiations for the system state
    //

    PPOP_DEVICE_SYS_STATE   DevState;

    //
    // Hibernation context
    //

    PPOP_HIBER_CONTEXT      HiberContext;

    //
    // For debugging.  The last state which worked and when
    //

    SYSTEM_POWER_STATE      LastWakeState;
    ULONGLONG               WakeTime;
    ULONGLONG               SleepTime;

} POP_POWER_ACTION, *PPOP_POWER_ACTION;

//
// PO_PM_USER - Update to action which effects usermode, but if the current
// operation is passed to NtSetSystemPowerState or happens to complete, these
// updates can be ignored
//
// PO_PM_REISSUE - Update to the action which effects the system.
//
// PO_PM_SETSTATE - Update to the action which effects NtSetSystemPowerState
//

#define PO_PM_USER              0x01    // nice to inform user mode, but not needed
#define PO_PM_REISSUE           0x02    // sleep promotoed to shutdown
#define PO_PM_SETSTATE          0x04    // recomputed something to do with the viable state

#define PO_ACT_IDLE                 0
#define PO_ACT_NEW_REQUEST          1
#define PO_ACT_CALLOUT              2
#define PO_ACT_SET_SYSTEM_STATE     3

extern POP_POWER_ACTION PopAction;
extern LIST_ENTRY PopActionWaiters;

//
//
//

extern LONG PopFullWake;

#define PO_FULL_WAKE_STATUS         0x01
#define PO_FULL_WAKE_PENDING        0x02
#define PO_GDI_STATUS               0x04
#define PO_GDI_ON_PENDING           0x08

#define AllBitsSet(a,b)    ( ((a) & (b)) == (b) )
#define AnyBitsSet(a,b)    ( (a) & (b) )


//
// Misc constants
//

#define PO_NO_FORCED_THROTTLE       100
#define PO_NO_FAN_THROTTLE          100
#define PO_MAX_FAN_THROTTLE          20
#define PO_MIN_MIN_THROTTLE          20
#define PO_MIN_IDLE_TIMEOUT          60
#define PO_MIN_IDLE_SENSITIVITY      10


//
// Processor idle handler info
//

typedef struct _POP_IDLE_HANDLER {
    ULONG       Latency;
    ULONG       TimeCheck;
    ULONG       DemoteLimit;
    ULONG       PromoteLimit;
    ULONG       PromoteCount;
    UCHAR       Demote;
    UCHAR       Promote;
    UCHAR       PromotePercent;
    UCHAR       DemotePercent;
    UCHAR       State;
    UCHAR       Spare[3];
    PPROCESSOR_IDLE_HANDLER IdleFunction;
} POP_IDLE_HANDLER, *PPOP_IDLE_HANDLER;

#define MAX_IDLE_HANDLER            3
#define PO_IDLE_COMPLETE_DEMOTION   (0)
#define PO_IDLE_THROTTLE_PROMOTION  (MAX_IDLE_HANDLER+1)

#define US2TIME                         10L             // scale microseconds by 10 to get 100ns
#define US2SEC                          1000000L
#define MAXSECCHECK                     10L             // max wait below is 10s

typedef struct _POP_SYSTEM_IDLE {
    //
    // Current idle settings
    //

    LONG                    Idleness;
    ULONG                   Time;
    ULONG                   Timeout;
    ULONG                   Sensitivity;
    POWER_ACTION_POLICY     Action;
    SYSTEM_POWER_STATE      MinState;

    //
    // Current idle stats
    //

    BOOLEAN                 IdleWorker;
    BOOLEAN                 Sampling;
    ULONGLONG               LastTick;
    ULONGLONG               LastIoTransfer;
    ULONG                   LastIoCount;
} POP_SYSTEM_IDLE, *PPOP_SYSTEM_IDLE;

//
// System idle worker once every 15 seconds.
// N.B. value must divide into 60secs evenly
//
#define SYS_IDLE_WORKER                 15      // 15 seconds
#define SYS_IDLE_CHECKS_PER_MIN         (60/SYS_IDLE_WORKER)
#define SYS_IDLE_SAMPLES                240     // 1hr worth of samples
#define SYS_IDLE_IO_SCALER              100

// defaults for system idle detection on a system wake used
// to re-enter a system sleep when a full wake does not occur

#define SYS_IDLE_REENTER_SENSITIVITY    80
#define SYS_IDLE_REENTER_TIMEOUT       (2*60)   // 2 minutes
#define SYS_IDLE_REENTER_TIMEOUT_S4    (5*60)   // 5 minutes
                                                
//
// even if someone tells us a user is present,
// if we woke up because of the RTC within this
// time limit, then assume there really isn't a
// user present and go to S4 anyway.
//
#define SYS_IGNORE_USERPRESENT_AND_BELIEVE_RTC  (10)

extern POP_SYSTEM_IDLE PopSIdle;


extern SYSTEM_POWER_POLICY PopAcPolicy;
extern SYSTEM_POWER_POLICY PopDcPolicy;
extern PSYSTEM_POWER_POLICY PopPolicy;
extern PROCESSOR_POWER_POLICY PopAcProcessorPolicy;
extern PROCESSOR_POWER_POLICY PopDcProcessorPolicy;
extern PPROCESSOR_POWER_POLICY PopProcessorPolicy;
extern POWER_STATE_HANDLER PopPowerStateHandlers[];
extern POWER_STATE_NOTIFY_HANDLER PopPowerStateNotifyHandler;
extern const POP_NOTIFY_WORK  PopNotifyWork[];
extern PPOP_IDLE_HANDLER PopIdle;
extern NPAGED_LOOKASIDE_LIST PopIdleHandlerLookAsideList;
extern KEVENT PopDumbyEvent;
extern ADMINISTRATOR_POWER_POLICY PopAdminPolicy;
extern const WCHAR PopRegKey[];
extern const WCHAR PopAcRegName[];
extern const WCHAR PopDcRegName[];
extern const WCHAR PopAdminRegName[];
extern const WCHAR PopUndockPolicyRegName[];
extern const WCHAR PopHeuristicsRegName[];
extern const WCHAR PopCompositeBatteryName[];
extern const WCHAR PopSimulateRegKey[];
extern const WCHAR PopSimulateRegName[];
extern const WCHAR PopHiberFileName[];
extern const WCHAR PopDebugHiberFileName[];
extern const WCHAR PopDumpStackPrefix[];
extern const WCHAR PopApmActiveFlag[];
extern const WCHAR PopApmFlag[];
extern const WCHAR PopAcProcessorRegName[];
extern const WCHAR PopDcProcessorRegName[];

extern LIST_ENTRY PopSwitches;
extern LIST_ENTRY PopThermal;
extern KSPIN_LOCK PopThermalLock;
extern ULONG PopCoolingMode;
extern ULONG PopLowLatency;
extern ULONG PopSystemIdleTime;

extern PKWIN32_POWEREVENT_CALLOUT PopEventCallout;
extern PKWIN32_POWERSTATE_CALLOUT PopStateCallout;

extern WORK_QUEUE_ITEM PopUserPresentWorkItem;

extern WORK_QUEUE_ITEM PopUnlockAfterSleepWorkItem;
extern KEVENT          PopUnlockComplete;

VOID
PopEventCalloutDispatch (
    IN PSPOWEREVENTTYPE EventNumber,
    IN ULONG_PTR Code
    );

extern LIST_ENTRY PopVolumeDevices;

//
// Undocking policy info
//

typedef struct _UNDOCK_POWER_RESTRICTIONS {

    ULONG Version;
    ULONG Size;
    ULONG HotUndockMinimumCapacity; // In percent
    ULONG SleepUndockMinimumCapacity; // In percent

} UNDOCK_POWER_RESTRICTIONS, *PUNDOCK_POWER_RESTRICTIONS;

#define SIZEOF_PARTIAL_INFO_HEADER \
    FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)

#define SIZEOF_EJECT_PARTIAL_INFO \
    SIZEOF_PARTIAL_INFO_HEADER + sizeof(UNDOCK_POWER_RESTRICTIONS)


//
// logging info
//
extern LIST_ENTRY PowerStateDisableReasonListHead;

typedef struct _SYSTEM_POWER_STATE_DISABLE_LIST {
    LIST_ENTRY ListEntry;	
    PSYSTEM_POWER_STATE_DISABLE_REASON Reason;
} SYSTEM_POWER_STATE_DISABLE_LIST, *PSYSTEM_POWER_STATE_DISABLE_LIST;

NTSTATUS
PopLoggingInformation(
    OUT PVOID * Buffer,
    OUT ULONG * BufferSize
    );

NTSTATUS
PopInsertLoggingEntry(
    IN PSYSTEM_POWER_STATE_DISABLE_REASON Reason
    );

NTSTATUS
PopRemoveReasonRecordByReasonCode(
    IN ULONG ReasonCode
    );


//
// Prototypes
//

extern ERESOURCE PopPolicyLock;
extern PKTHREAD  PopPolicyLockThread;

#if DBG
    #define ASSERT_POLICY_LOCK_OWNED()  PopAssertPolicyLockOwned()
#else
    #define ASSERT_POLICY_LOCK_OWNED()
#endif

extern KGUARDED_MUTEX PopVolumeLock;

#define PopAcquireVolumeLock() KeAcquireGuardedMutex(&PopVolumeLock)
#define PopReleaseVolumeLock() KeReleaseGuardedMutex(&PopVolumeLock)

#define ClearMember(Member, Set) \
    Set = Set & (~((ULONG_PTR)1 << (Member)))

#if defined(_WIN64)

#define InterlockedOrAffinity(Target, Set)  {                               \
            LONGLONG _i, _j;                                                \
            _j = (*Target);                                                 \
            do {                                                            \
                _i = _j;                                                    \
                _j = InterlockedCompareExchange64((Target),                 \
                                                  (_i | (Set)),             \
                                                  _i);                      \
            } while (_i != _j) ;                                            \
        }

#else

#define InterlockedOrAffinity(Target, Set) InterlockedOr(Target, Set)

#endif // defined(_WIN64)

#if defined(_WIN64)

#define InterlockedAndAffinity(Target, Set)  {                              \
            LONGLONG _i, _j;                                                \
            _j = (*Target);                                                 \
            do {                                                            \
                _i = _j;                                                    \
                _j = InterlockedCompareExchange64((Target),                 \
                                                  (_i & (Set)),             \
                                                  _i);                      \
            } while (_i != _j) ;                                            \
        }

#else

#define InterlockedAndAffinity(Target, Set) InterlockedAnd(Target, Set)

#endif // defined(_WIN64)

// attrib.c

VOID
PopApplyAttributeState (
    IN ULONG NewFlag,
    IN ULONG OldFlag
    );

VOID
PopAttribNop (
    IN ULONG Arg
    );

VOID
PopSystemRequiredSet (
    IN ULONG Arg
    );

VOID
PopDisplayRequired (
    IN ULONG Arg
    );

VOID
PopUserPresentSet (
    IN ULONG Arg
    );

// pocall.c

VOID
PopSystemIrpDispatchWorker(
    IN BOOLEAN  LastCall
    );

PIRP
PopFindIrpByDeviceObject(
    PDEVICE_OBJECT  DeviceObject,
    POWER_STATE_TYPE    Type
    );

VOID
PopSystemIrpsActive (
    VOID
    );

// hiber.c

NTSTATUS
PopEnableHiberFile (
    IN BOOLEAN Enable
    );

VOID
PopCloneStack (
    IN PPOP_HIBER_CONTEXT    HiberContext
    );

NTSTATUS
PopAllocateHiberContext (
    VOID
    );

VOID
PopFreeHiberContext (
    BOOLEAN ContextBlock
    );

NTSTATUS
PopBuildMemoryImageHeader (
    IN PPOP_HIBER_CONTEXT  HiberContext,
    IN SYSTEM_POWER_STATE  SystemState
    );

NTSTATUS
PopSaveHiberContext (
    IN PPOP_HIBER_CONTEXT   HiberContext
    );

VOID
PopHiberComplete (
    IN NTSTATUS           Status,
    IN PPOP_HIBER_CONTEXT HiberContext
    );

VOID
PopFixContext (
    OUT PCONTEXT Context
    );

ULONG
PopGatherMemoryForHibernate (
    IN PPOP_HIBER_CONTEXT   HiberContext,
    IN PFN_NUMBER           NoPages,
    IN PMDL                 *Mdl,
    IN BOOLEAN              Wait
    );

// idle.c

VOID
PopScanIdleList (
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    );


PDEVICE_OBJECT_POWER_EXTENSION
PopGetDope(
    IN PDEVICE_OBJECT    DeviceObject
    );


// misc.c


VOID
FASTCALL
PopInternalAddToDumpFile (
    IN OPTIONAL PVOID DataBlock,
    IN OPTIONAL ULONG DataBlockSize,
    IN OPTIONAL PDEVICE_OBJECT  DeviceObject,
    IN OPTIONAL PDRIVER_OBJECT  DriverObject,
    IN OPTIONAL PDEVOBJ_EXTENSION Doe,
    IN OPTIONAL PDEVICE_OBJECT_POWER_EXTENSION  Dope
    );


VOID
FASTCALL
_PopInternalError (
    IN ULONG    BugCode
    );

#if DBG
VOID
PopAssertPolicyLockOwned(
    VOID
    );
#endif

NTSTATUS
PopAttachToSystemProcess (
    VOID
    );

#define PopSetCapability(_pflag_) PopChangeCapability(_pflag_, TRUE)
#define PopClearCapability(_pflag_) PopChangeCapability(_pflag_, FALSE)

VOID
PopChangeCapability(
    IN PBOOLEAN PresentFlag,
    IN BOOLEAN IsPresent
    );

EXCEPTION_DISPOSITION
PopExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionInformation,
    IN BOOLEAN AllowRaisedException
    );

VOID
PopSaveHeuristics (
    VOID
    );

PCHAR
PopSystemStateString (
    IN SYSTEM_POWER_STATE SystemState
    );

#if DBG
PCHAR
PopPowerActionString (
    IN POWER_ACTION PowerAction
    );
#endif

NTSTATUS
PopOpenPowerKey (
    OUT PHANDLE handle
    );

VOID
PopInitializePowerPolicySimulate(
    VOID
    );

VOID
PopUnlockAfterSleepWorker(
    IN PVOID NotUsed
    );

// paction.c

VOID
PopCriticalShutdown (
    POP_POLICY_DEVICE_TYPE  Type
    );

VOID
PopSetPowerAction (
    IN PPOP_ACTION_TRIGGER      Trigger,
    IN ULONG                    UserNotify,
    IN PPOWER_ACTION_POLICY     ActionPolicy,
    IN SYSTEM_POWER_STATE       LightestState,
    IN POP_SUBSTITUTION_POLICY  SubstitutionPolicy
    );

LONG
PopCompareActions(
    POWER_ACTION                FutureAction,
    POWER_ACTION                CurrentAction
    );

ULONG
PopPolicyWorkerAction (
    VOID
    );

ULONG
PopPolicyWorkerActionPromote (
    VOID
    );

VOID
PopResetActionDefaults(
    VOID
    );

VOID
PopActionRetrieveInitialState(
    IN OUT  PSYSTEM_POWER_STATE  LightestSystemState,
    OUT     PSYSTEM_POWER_STATE  DeepestSystemState,
    OUT     PSYSTEM_POWER_STATE  InitialSystemState,
    OUT     PBOOLEAN             QueryDevices
    );

// pbatt.c

VOID
PopCompositeBatteryDeviceHandler (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
PopCurrentPowerState (
    OUT PSYSTEM_BATTERY_STATE  PowerState
    );

VOID
PopResetCBTriggers (
    UCHAR   Flags
    );


// switch.c

VOID
PopLidHandler (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

VOID
PopSystemButtonHandler (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

VOID
PopResetSwitchTriggers (
    VOID
    );


// pidle.c

VOID
PopInitProcessorStateHandlers (
    IN  PPROCESSOR_STATE_HANDLER    InputBuffer
    );

VOID
PopInitProcessorStateHandlers2 (
    IN  PPROCESSOR_STATE_HANDLER2   InputBuffer
    );

NTSTATUS
PopIdleSwitchIdleHandler(
    IN  PPOP_IDLE_HANDLER   NewHandler,
    IN  ULONG               NumElements
    );

NTSTATUS
PopIdleSwitchIdleHandlers(
    IN  PPOP_IDLE_HANDLER   NewHandler,
    IN  ULONG               NumElements
    );

NTSTATUS
PopIdleUpdateIdleHandler(
    IN  PPOP_IDLE_HANDLER   NewHandler,
    IN  PPOP_IDLE_HANDLER   OldHandler,
    IN  ULONG               NumElements
    );

NTSTATUS
PopIdleUpdateIdleHandlers(
    VOID
    );

NTSTATUS
PopIdleVerifyIdleHandlers(
    IN  PPOP_IDLE_HANDLER   NewHandler,
    IN  ULONG               NumElements
    );

VOID
PopProcessorInformation (
    OUT PPROCESSOR_POWER_INFORMATION    ProcInfo,
    IN  ULONG                           ProcInfoLength,
    OUT PULONG                          ReturnBufferLength
    );

// pinfo.c


BOOLEAN
PopVerifyPowerActionPolicy (
    IN PPOWER_ACTION_POLICY Action
    );

VOID
PopVerifySystemPowerState (
    IN OUT PSYSTEM_POWER_STATE      PowerState,
    IN     POP_SUBSTITUTION_POLICY  SubstitutionPolicy
    );

VOID
PopAdvanceSystemPowerState (
    IN OUT PSYSTEM_POWER_STATE      PowerState,
    IN     POP_SUBSTITUTION_POLICY  SubstitutionPolicy,
    IN     SYSTEM_POWER_STATE       LightestSystemState,
    IN     SYSTEM_POWER_STATE       DeepestSystemState
    );

NTSTATUS
PopNotifyPolicyDevice (
    IN PVOID        Notification,
    IN PVOID        Context
    );

NTSTATUS
PopApplyAdminPolicy (
    IN BOOLEAN                      UpdateRegistry,
    IN PADMINISTRATOR_POWER_POLICY  NewPolicy,
    IN ULONG                        PolicyLength
    );

NTSTATUS
PopResetCurrentPolicies (
    VOID
    );

VOID
PopConnectToPolicyDevice (
    IN POP_POLICY_DEVICE_TYPE   DeviceType,
    IN PUNICODE_STRING          DriverName
    );

POWER_ACTION
PopMapInternalActionToIrpAction (
    IN POWER_ACTION        Action,
    IN SYSTEM_POWER_STATE  SystemPowerState,
    IN BOOLEAN             UnmapWarmEject
    );

// poinit.c

VOID
PopDefaultPolicy (
    IN OUT PSYSTEM_POWER_POLICY Policy
    );

VOID
PopDefaultProcessorPolicy(
    IN OUT PPROCESSOR_POWER_POLICY Policy
    );

// postate.c

VOID
PopRequestPowerChange (
    IN PDEVOBJ_EXTENSION PowerExtension,
    IN POWER_STATE      SystemPowerState,
    IN ULONG            DevicePowerState
    );

VOID
PopStateChange (
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    );

NTSTATUS
PopSetPowerComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#define PopIsStateDatabaseIdle()                        \
    (IsListEmpty (&PopStateChangeInProgress)  &&        \
     IsListEmpty (&PopSyncStateChangeQueue)   &&        \
     IsListEmpty (&PopAsyncStateChangeQueue) )


// pwork.c

VOID
PopAcquirePolicyLock(
    VOID
    );

VOID
PopReleasePolicyLock(
    IN BOOLEAN CheckForWork
    );

VOID
PopGetPolicyWorker (
    IN ULONG   WorkerType
    );

VOID
PopCheckForWork (
    IN BOOLEAN GetWorker
    );

NTSTATUS
PopCompletePolicyIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

VOID
PopPolicyWorkerThread (
    PVOID Context
    );

ULONG
PopPolicyWorkerMain (
    VOID
    );

VOID
PopSetNotificationWork (
    IN ULONG    Flags
    );

ULONG
PopPolicyWorkerNotify (
    VOID
    );

ULONG
PopPolicyTimeChange (
    VOID
    );

VOID
PopDispatchCallback (
    IN ULONG Arg
    );

VOID
PopDispatchAcDcCallback (
    IN ULONG Arg
    );

VOID
PopDispatchCallout (
    IN ULONG Arg
    );

VOID
PopDispatchProcessorPolicyCallout (
    IN ULONG Arg
    );

VOID
PopDispatchPolicyCallout (
    IN ULONG Arg
    );

VOID
PopDispatchDisplayRequired (
    IN ULONG Arg
    );

VOID
PopDispatchFullWake (
    IN ULONG Arg
    );

VOID
PopDispatchEventCodes (
    IN ULONG Arg
    );

VOID
PopDispatchSetStateFailure (
    IN ULONG Arg
    );

// sidle.c

VOID
PopInitSIdle (
    VOID
    );

ULONG
PopPolicySystemIdle (
    VOID
    );

// sys.c

DECLSPEC_NORETURN
VOID
PopShutdownSystem (
    IN POWER_ACTION SystemAction
    );

NTSTATUS
PopSleepSystem (
    IN SYSTEM_POWER_STATE   SystemState,
    IN PVOID Memory
    );


VOID
PopCheckIdleDevState (
    IN PPOP_DEVICE_SYS_STATE    DevState,
    IN BOOLEAN                  LogErrors,
    IN BOOLEAN                  FreeAll
    );

VOID
PopRestartSetSystemState (
    VOID
    );

NTSTATUS
PopShutdownHandler (
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );


// sysdev.c

VOID
PopAllocateDevState(
    VOID
    );

VOID
PopCleanupDevState (
    VOID
    );

VOID
PopReportDevState (
    IN BOOLEAN                  LogErrors
    );

NTSTATUS
PopSetDevicesSystemState (
    IN BOOLEAN Wake
    );

VOID
PopLogNotifyDevice (
    IN PDEVICE_OBJECT   TargetDevice,
    IN OPTIONAL PPO_DEVICE_NOTIFY Notify,
    IN PIRP             Irp
    );

// thermal.c

PUCHAR
PopTimeString(
    OUT PUCHAR      TimeString,
    IN  ULONGLONG   CurrentTime
    );

VOID
PopThermalDeviceHandler (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

VOID
PopThermalZoneDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
PopApplyThermalThrottle (
    VOID
    );

//
// throttle.c - dynamic CPU voltage throttling
//

//
// scale that performance levels are kept in. This is the units in the
// PROCESSOR_PERF_LEVEL scale and what is used internally to track CPU
// performance levels.
//
#define POP_PERF_SCALE POWER_PERF_SCALE
#define POP_CUR_TIME(X) (X->KernelTime + X->UserTime)


UCHAR
PopCalculateBusyPercentage(
    IN  PPROCESSOR_POWER_STATE  PState
    );

UCHAR
PopCalculateC3Percentage(
    IN  PPROCESSOR_POWER_STATE  PState
    );

VOID
PopCalculatePerfDecreaseLevel(
    IN  PPROCESSOR_PERF_STATE   PerfStates,
    IN  ULONG                   PerfStatesCount
    );

VOID
PopCalculatePerfIncreaseDecreaseTime(
    IN  PPROCESSOR_PERF_STATE       PerfStates,
    IN  ULONG                       PerfStatesCount,
    IN  PPROCESSOR_STATE_HANDLER2   PerfHandler
    );

VOID
PopCalculatePerfIncreaseLevel(
    IN  PPROCESSOR_PERF_STATE   PerfStates,
    IN  ULONG                   PerfStatesCount
    );

VOID
PopCalculatePerfMinCapacity(
    IN  PPROCESSOR_PERF_STATE   PerfStates,
    IN  ULONG                   PerfStatesCount
    );

UCHAR
PopGetThrottle(
    VOID
    );

VOID
PopPerfHandleInrush(
    IN  BOOLEAN EnableHandler
    );

VOID
PopPerfIdle(
    IN  PPROCESSOR_POWER_STATE  PState
    );

VOID
PopPerfIdleDpc(
    IN  PKDPC   Dpc,
    IN  PVOID   DpcContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    );

VOID
PopRoundThrottle(
    IN UCHAR Throttle,
    OUT OPTIONAL PUCHAR RoundDown,
    OUT OPTIONAL PUCHAR RoundUp,
    OUT OPTIONAL PUCHAR RoundDownIndex,
    OUT OPTIONAL PUCHAR RoundUpIndex
    );

VOID
PopSetPerfFlag(
    IN  ULONG   PerfFlag,
    IN  BOOLEAN Clear
    );

NTSTATUS
PopSetPerfLevels(
    IN PPROCESSOR_STATE_HANDLER2 ProcessorHandler
    );

NTSTATUS
PopSetThrottle(
    IN  PPROCESSOR_POWER_STATE  PState,
    IN  PPROCESSOR_PERF_STATE   PerfStates,
    IN  ULONG                   Index,
    IN  ULONG                   SystemTime,
    IN  ULONG                   IdleTime
    );

NTSTATUS
PopSetTimer(
    IN  PPROCESSOR_POWER_STATE  PState,
    IN  UCHAR                   Index
    );

//
// Some globals that thunk the old processor throttling callout into the
// new one.
//
NTSTATUS
FASTCALL
PopThunkSetThrottle(
    IN UCHAR Throttle
    );

VOID
PopUpdateAllThrottles(
    VOID
    );

VOID
PopUpdateProcessorThrottle(
    VOID
    );

extern PSET_PROCESSOR_THROTTLE PopRealSetThrottle;
extern UCHAR                   PopThunkThrottleScale;
extern LARGE_INTEGER           PopPerfCounterFrequency;

// volume.c

VOID
PopFlushVolumes (
    VOID
    );

// notify.c

VOID
PopStateChangeNotify(
    PDEVICE_OBJECT  DeviceObject,
    ULONG           NotificationType
    );

VOID
PopRunDownSourceTargetList(
    PDEVICE_OBJECT          DeviceObject
    );

// poshtdwn.c
NTSTATUS
PopInitShutdownList (
    VOID
    );

DECLSPEC_NORETURN
VOID
PopGracefulShutdown (
    IN PVOID WorkItemParameter
    );

#endif // _POP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\poshtdwn.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    poshtdwn.c

Abstract:

    Shutdown-related routines and structures

Author:

    Rob Earhart (earhart) 01-Feb-2000

Revision History:

--*/

#include "pop.h"

#if DBG
BOOLEAN
PopDumpFileObject(
    IN PVOID Object,
    IN PUNICODE_STRING ObjectName,
    IN ULONG_PTR HandleCount,
    IN ULONG_PTR PointerCount,
    IN PVOID Parameter
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PopInitShutdownList)
#pragma alloc_text(PAGE, PoRequestShutdownEvent)
#pragma alloc_text(PAGE, PoRequestShutdownWait)
#pragma alloc_text(PAGE, PoQueueShutdownWorkItem)
#pragma alloc_text(PAGELK, PopGracefulShutdown)
#if DBG
#pragma alloc_text(PAGELK, PopDumpFileObject)
#endif
#endif

KEVENT PopShutdownEvent;
KGUARDED_MUTEX PopShutdownListMutex;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

BOOLEAN PopShutdownListAvailable = FALSE;

//
// This list will contain a set of threads that we need to wait
// for when we're about to shutdown.
//
SINGLE_LIST_ENTRY PopShutdownThreadList;


//
// List containing a set of worker routines that
// we need to process before we can shutdown the
// machine.
//
LIST_ENTRY PopShutdownQueue;

typedef struct _PoShutdownThreadListEntry {
    SINGLE_LIST_ENTRY ShutdownThreadList;
    PETHREAD Thread;
} POSHUTDOWNLISTENTRY, *PPOSHUTDOWNLISTENTRY;

NTSTATUS
PopInitShutdownList(
    VOID
    )
{
    PAGED_CODE();

    KeInitializeEvent(&PopShutdownEvent,
                      NotificationEvent,
                      FALSE);
    PopShutdownThreadList.Next = NULL;
    InitializeListHead(&PopShutdownQueue);
    KeInitializeGuardedMutex(&PopShutdownListMutex);

    PopShutdownListAvailable = TRUE;

    return STATUS_SUCCESS;
}

NTSTATUS
PoRequestShutdownWait(
    IN PETHREAD Thread
    )
/*++

Routine Description:

    This function will add the caller's thread onto an internal
    list that we'll wait for before we shutdown.

Arguments:

    Thread      - Pointer to the caller's thread.
                  

Return Value:

    NTSTATUS.

--*/
{
    PPOSHUTDOWNLISTENTRY Entry;

    PAGED_CODE();

    Entry = (PPOSHUTDOWNLISTENTRY)
        ExAllocatePoolWithTag(PagedPool|POOL_COLD_ALLOCATION,
                              sizeof(POSHUTDOWNLISTENTRY),
                              'LSoP');
    if (! Entry) {
        return STATUS_NO_MEMORY;
    }

    Entry->Thread = Thread;
    ObReferenceObject(Thread);

    KeAcquireGuardedMutex(&PopShutdownListMutex);

    if (! PopShutdownListAvailable) {
        ObDereferenceObject(Thread);
        ExFreePool(Entry);
        KeReleaseGuardedMutex(&PopShutdownListMutex);
        return STATUS_UNSUCCESSFUL;
    }

    PushEntryList(&PopShutdownThreadList,
                  &Entry->ShutdownThreadList);

    KeReleaseGuardedMutex(&PopShutdownListMutex);

    return STATUS_SUCCESS;
}

NTSTATUS
PoRequestShutdownEvent(
    OUT PVOID *Event OPTIONAL
    )
/*++

Routine Description:

    This function will add the caller's thread onto an internal
    list that we'll wait for before we shutdown.

Arguments:

    Event       - If the parameter exists, it will recieve a pointer
                  to our PopShutdownEvent.
                  

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS             Status;

    PAGED_CODE();

    if (Event != NULL) {
        *Event = NULL;
    }

    Status = PoRequestShutdownWait(PsGetCurrentThread());
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (Event != NULL) {
        *Event = &PopShutdownEvent;
    }

    return STATUS_SUCCESS;
}

NTKERNELAPI
NTSTATUS
PoQueueShutdownWorkItem(
    IN PWORK_QUEUE_ITEM WorkItem
    )
/*++

Routine Description:

    This function appends WorkItem onto our internal list of things
    to run down when we're about to shutdown.  Subsystems can use this
    as a mechanism to get notified whey we're going down so they can do
    any last minute cleanup.

Arguments:

    WorkItem    - Pointer to work item to be added onto our
                  list which will be run down before we shutdown.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT(WorkItem);
    ASSERT(WorkItem->WorkerRoutine);

    KeAcquireGuardedMutex(&PopShutdownListMutex);   

    if (PopShutdownListAvailable) {
        InsertTailList(&PopShutdownQueue,
                       &WorkItem->List);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_SYSTEM_SHUTDOWN;
    }

    KeReleaseGuardedMutex(&PopShutdownListMutex);

    return Status;
}

#if DBG

extern POBJECT_TYPE IoFileObjectType;

BOOLEAN
PopDumpFileObject(
    IN PVOID Object,
    IN PUNICODE_STRING ObjectName,
    IN ULONG_PTR HandleCount,
    IN ULONG_PTR PointerCount,
    IN PVOID Parameter
    )
{
    PFILE_OBJECT File;
    PULONG       NumberOfFilesFound;

    UNREFERENCED_PARAMETER(ObjectName);
    ASSERT(Object);
    ASSERT(Parameter);

    File = (PFILE_OBJECT) Object;
    NumberOfFilesFound = (PULONG) Parameter;

    ++*NumberOfFilesFound;
    DbgPrint("\t0x%0p : HC %d, PC %d, Name %.*ls\n",
             Object, HandleCount, PointerCount,
             File->FileName.Length,
             File->FileName.Buffer);

    return TRUE;
}
#endif // DBG

VOID
PopGracefulShutdown (
    IN PVOID WorkItemParameter
    )
/*++

Routine Description:

    This function is only called as a HyperCritical work queue item.
    It's responsible for gracefully shutting down the system.

Return Value:

    This function never returns.

--*/
{
    PVOID         Context;

    UNREFERENCED_PARAMETER(WorkItemParameter);

    //
    // Shutdown executive components (there's no turning back after this).
    //

    PERFINFO_SHUTDOWN_LOG_LAST_MEMORY_SNAPSHOT();

    if (!PopAction.ShutdownBugCode) {
        HalEndOfBoot();
    }

    if (PoCleanShutdownEnabled()) {
        //
        // Terminate all processes.  This will close all the handles and delete
        // all the address spaces.  Note the system process is kept alive.
        //
        PsShutdownSystem ();
        //
        // Notify every system thread that we're shutting things
        // down...
        //

        KeSetEvent(&PopShutdownEvent, 0, FALSE);

        //
        // ... and give all threads which requested notification a
        // chance to clean up and exit.
        //

        KeAcquireGuardedMutex(&PopShutdownListMutex);

        PopShutdownListAvailable = FALSE;

        KeReleaseGuardedMutex(&PopShutdownListMutex);

        {
            PLIST_ENTRY Next;
            PWORK_QUEUE_ITEM WorkItem;

            while (PopShutdownQueue.Flink != &PopShutdownQueue) {
                Next = RemoveHeadList(&PopShutdownQueue);
                WorkItem = CONTAINING_RECORD(Next,
                                             WORK_QUEUE_ITEM,
                                             List);
                WorkItem->WorkerRoutine(WorkItem->Parameter);
            }
        }

        {
            PSINGLE_LIST_ENTRY   Next;
            PPOSHUTDOWNLISTENTRY ShutdownEntry;

            while (TRUE) {
                Next = PopEntryList(&PopShutdownThreadList);
                if (! Next) {
                    break;
                }

                ShutdownEntry = CONTAINING_RECORD(Next,
                                                  POSHUTDOWNLISTENTRY,
                                                  ShutdownThreadList);
                KeWaitForSingleObject(ShutdownEntry->Thread,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                ObDereferenceObject(ShutdownEntry->Thread);
                ExFreePool(ShutdownEntry);
            }
        }
    }

    //
    // Terminate Plug-N-Play.
    //
    PpShutdownSystem (TRUE, 0, &Context);

    ExShutdownSystem (0);

    //
    // Send first-chance shutdown IRPs to all drivers that asked for it.
    //
    IoShutdownSystem (0);

    if (PoCleanShutdownEnabled()) {
        //
        // Wait for all the user mode processes to exit.
        //
        PsWaitForAllProcesses ();
    }

    //
    // Scrub the object directories
    //
    if (PoCleanShutdownEnabled() & PO_CLEAN_SHUTDOWN_OB) {
        ObShutdownSystem (0);
    }

    //
    // Close the registry and the associated handles/file objects.
    //
    CmShutdownSystem ();

    //
    // Swap in the worker threads, to keep them from paging
    //
    ExShutdownSystem(1);

    //
    // This call to MmShutdownSystem will flush all the mapped data and empty
    // the cache.  This gets the data out and dereferences all the file objects
    // so the drivers (ie: the network stack) can be cleanly unloaded. The
    // pagefile handles are closed, however the file objects backing them are
    // still referenced. Paging can continue, but no pagefile handles will
    // exist in the system handle table.
    //
    MmShutdownSystem (0);

    //
    // Flush the lazy writer cache
    //
    CcWaitForCurrentLazyWriterActivity();

    //
    // Send out last-chance shutdown IRPs, including shutdown IRPs to
    // filesystems. This is for notifications only - the filesystems are
    // still active and usable after this call. It is expected however that
    // no subsequent writes will be cached.
    //
    // ISSUE - 2002/02/21 - ADRIAO: Shutdown messages incomplete for filesystems
    //     Ideally we'd have a message to tell filesystems that the FS is no
    // longer in use. However, this needs to be done on a *per-device* basis
    // and ordering!
    //     The FS shutdown IRPs cannot be used in this fashion as filesystems
    // only register once against their control objects for this message. A
    // future solution might be to forward the powers IRP to mounted filesystems
    // with the expectation that the bottom of the FS stack will forward the
    // IRP back to the underlying storage stack. This would be symmetric with
    // how removals work in PnP.
    //
    IoShutdownSystem(1);

    //
    // Push any lazy writes that snuck in before we shutdown the filesystem
    // to the hardware.
    //
    CcWaitForCurrentLazyWriterActivity();

    //
    // This prevents us from making any more calls out to GDI.
    //
    PopFullWake = 0;

    ASSERT(PopAction.DevState);
    PopAction.DevState->Thread = KeGetCurrentThread();

    //
    // Inform drivers of the system shutdown state.
    // This will finish shutting down Io and Mm.
    // After this is complete,
    // NO MORE REFERENCES TO PAGABLE CODE OR DATA MAY BE MADE.
    //
    PopSetDevicesSystemState(FALSE);

#if DBG
    if (PoCleanShutdownEnabled()) {
        ULONG NumberOfFilesFoundAtShutdown = 0;
        // As of this time, no files should be open.
        DbgPrint("Looking for open files...\n");
        ObEnumerateObjectsByType(IoFileObjectType,
                                 &PopDumpFileObject,
                                 &NumberOfFilesFoundAtShutdown);
        DbgPrint("Found %d open files.\n", NumberOfFilesFoundAtShutdown);
        ASSERT(NumberOfFilesFoundAtShutdown == 0);
    }
#endif

    IoFreePoDeviceNotifyList(&PopAction.DevState->Order);

    //
    // Disable any wake alarms.
    //

    HalSetWakeEnable(FALSE);

    //
    // If this is a controlled shutdown bugcheck sequence, issue the
    // bugcheck now

    // ISSUE-2000/01/30-earhart Placement of ShutdownBugCode BugCheck
    // I dislike the fact that we're doing this controlled shutdown
    // bugcheck so late in the shutdown process; at this stage, too
    // much state has been torn down for this to be really useful.
    // Maybe if there's a debugger attached, we could shut down
    // sooner...

    if (PopAction.ShutdownBugCode) {
        KeBugCheckEx (PopAction.ShutdownBugCode->Code,
                      PopAction.ShutdownBugCode->Parameter1,
                      PopAction.ShutdownBugCode->Parameter2,
                      PopAction.ShutdownBugCode->Parameter3,
                      PopAction.ShutdownBugCode->Parameter4);
    }

    PERFINFO_SHUTDOWN_DUMP_PERF_BUFFER();

    PpShutdownSystem (TRUE, 1, &Context);

    ExShutdownSystem (2);

    if (PoCleanShutdownEnabled() & PO_CLEAN_SHUTDOWN_OB) {
        ObShutdownSystem (2);
    }

    //
    // Any allocated pool left at this point is a leak.
    //

    MmShutdownSystem (2);

    //
    // Implement shutdown style action -
    // N.B. does not return (will bugcheck in preference to returning).
    //

    PopShutdownSystem(PopAction.Action);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\postate.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    state.c

Abstract:

    Maintains state changes for power management power states
    for device objects

Author:

    Ken Reneris (kenr) 19-July-1994

Revision History:

--*/


#include "pop.h"



// sync rules - only PoSetPowerState ever writes to the
// StateValue entries in the psb.
//

NTKERNELAPI
POWER_STATE
PoSetPowerState (
    IN PDEVICE_OBJECT   DeviceObject,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE      State
    )
/*++

Routine Description:

    This routine stores the new power state for a device object,
    calling notification routines, if any, first.

    If the new state and old state are the same, this procedure
    is a noop

    A note on synchronization:

        No lock is acquire just to set the values.  This is because
        it is assumed that only this routine writes them, so locking
        is not necessary.

        If the notify list is to be run, a lock will be acquired.

Arguments:

    DeviceObject - pointer to the device object to set the power
            state for and to issue any notifications for

    Type - indicates whether System or Device state is being set

    State - the System or Device state to set

Return Value:

    The Old power state.

--*/
{
    PDEVOBJ_EXTENSION   doe;
    PDEVICE_OBJECT_POWER_EXTENSION  dope;
    POWER_STATE         OldState;
    BOOLEAN             change;
    ULONG               notificationmask;
    KIRQL               OldIrql2;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(DeviceObject);

    PoPowerTrace(POWERTRACE_SETSTATE,DeviceObject,(ULONG)Type,(ULONG)State.SystemState);

    doe = DeviceObject->DeviceObjectExtension;
    dope = doe->Dope;

    notificationmask = 0L;
    change = FALSE;

    PopLockIrpSerialList(&OldIrql2);

    switch (Type) {

    case SystemPowerState:
        OldState.SystemState = PopGetDoSystemPowerState(doe);
        if (OldState.SystemState != State.SystemState) {
            change = TRUE;
        }
        break;

    case DevicePowerState:
        OldState.DeviceState = PopGetDoDevicePowerState(doe);
        if (OldState.DeviceState != State.DeviceState) {
            change = TRUE;
            if (OldState.DeviceState == PowerDeviceD0) {
                notificationmask = PO_NOTIFY_TRANSITIONING_FROM_D0;
            } else if (State.DeviceState == PowerDeviceD0) {
                notificationmask = PO_NOTIFY_D0;
            }
        }
        break;
    default:
        OldState.SystemState = PowerSystemUnspecified;  // Never executed but keeps compiler happy
        break;
    }

    if (! change) {
        PopUnlockIrpSerialList(OldIrql2);
        return OldState;
    }

    //
    // We know what is going to happen.  Always store the changed
    // state first, so we can drop the lock and do the notification.
    //

    switch (Type) {

    case SystemPowerState:
        PopSetDoSystemPowerState(doe, State.SystemState);
        break;

    case DevicePowerState:
        PopSetDoDevicePowerState(doe, State.DeviceState);
        break;
    }

    PopUnlockIrpSerialList(OldIrql2);

    //
    // If anything to notify...
    //
    if (notificationmask && dope) {
        PopStateChangeNotify(DeviceObject, notificationmask);
    }

    return OldState;
}


DEVICE_POWER_STATE
PopLockGetDoDevicePowerState(
    IN PDEVOBJ_EXTENSION Doe
    )
/*++

Routine Description:

    Function which returns the power state of the specified device.
    Unlike PopGetDoDevicePowerState, this routine also acquires and
    releases the appropriate spinlock.

Arguments:

    Doe - Supplies the devobj_extension of the device.

Return Value:

    DEVICE_POWER_STATE

--*/

{
    KIRQL OldIrql;
    DEVICE_POWER_STATE State;

    PopLockIrpSerialList(&OldIrql);
    State = PopGetDoDevicePowerState(Doe);
    PopUnlockIrpSerialList(OldIrql);

    return(State);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\pwork.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pwork.c

Abstract:

    Main work dispatcher in the power policy manager

Author:

    Ken Reneris (kenr) 17-Jan-1997

Revision History:

--*/


#include "pop.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PopAcquirePolicyLock)
#pragma alloc_text(PAGE, PopReleasePolicyLock)
#pragma alloc_text(PAGE, PopPolicyWorkerMain)
#pragma alloc_text(PAGE, PopPolicyWorkerNotify)
#pragma alloc_text(PAGE, PopPolicyTimeChange)
#pragma alloc_text(PAGE, PopDispatchCallout)
#pragma alloc_text(PAGE, PopDispatchCallback)
#pragma alloc_text(PAGE, PopDispatchDisplayRequired)
#pragma alloc_text(PAGE, PopDispatchFullWake)
#pragma alloc_text(PAGE, PopDispatchEventCodes)
#pragma alloc_text(PAGE, PopDispatchAcDcCallback)
#pragma alloc_text(PAGE, PopDispatchPolicyCallout)
#pragma alloc_text(PAGE, PopDispatchSetStateFailure)
#endif


VOID
PopAcquirePolicyLock(
    VOID
    )
{
    PAGED_CODE();

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite (&PopPolicyLock, TRUE);
    //
    // Make sure we are not acquiring this recursively
    //
    ASSERT(PopPolicyLockThread == NULL);
    PopPolicyLockThread = KeGetCurrentThread();
}


VOID
PopReleasePolicyLock(
    IN BOOLEAN      CheckForWork
    )
{
    PAGED_CODE();

    ASSERT (PopPolicyLockThread == KeGetCurrentThread());
    PopPolicyLockThread = NULL;
    ExReleaseResourceLite(&PopPolicyLock);

    //
    // If CheckForWork is set, then this thread is about ready
    // to leave the policy manager and it may have set a worker
    // pending bit.
    //
    // N.B. the WorkerPending test is not synchronized, but
    // since we're only concered with bits the current thread
    // may have set that's OK.
    //

    if (CheckForWork  && (PopWorkerPending & PopWorkerStatus)) {

        //
        // Worker bit is unmasked and pending.  Turn this thread
        // into a worker.
        //

        //
        // Handle any pending work
        //

        PopPolicyWorkerThread (NULL);
    }

    KeLeaveCriticalRegion ();
}

VOID
PopGetPolicyWorker (
    IN ULONG    WorkerType
    )
/*++

Routine Description:

    This function enqueus a worker thread for the particular WorkerType.
    At a maximum one worker thread per type may be dispatched, and typically
    fewer threads are actually dispatched as any given worker thread will
    call the new highest priority non-busy dispatch function until all
    pending work is completed before existing.

Arguments:

    WorkerType      - Which worker to enqueue for dispatching

Return Value:

    None

--*/
{
    KIRQL       OldIrql;

    KeAcquireSpinLock (&PopWorkerSpinLock, &OldIrql);

    //
    // Set pending to get worker to dispatch to handler
    //

    PopWorkerPending |= WorkerType;

    KeReleaseSpinLock (&PopWorkerSpinLock, OldIrql);
}

NTSTATUS
PopCompletePolicyIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    This function handles the completion of a policy manager IRP.
    Policy manager IRPs have a stack location containing the irp
    handler function to dispatch too.  In this function the irp is
    queue to the irp complete queue and a main worker is allocated
    if needed to run the queue.

Arguments:

    DeviceObject    -

    Irp             - The irp which has completed

    Context         -

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    KIRQL       OldIrql;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Context);

    //
    // Put the irp on a queue for a worker thread
    //

    KeAcquireSpinLock (&PopWorkerSpinLock, &OldIrql);
    InsertTailList (&PopPolicyIrpQueue, &Irp->Tail.Overlay.ListEntry);

    //
    // Wait until base drivers are loaded before dispatching any policy irps
    //
    if (PopDispatchPolicyIrps) {

        //
        // Set pending to get worker to dispatch to handler
        //
        PopWorkerPending |= PO_WORKER_MAIN;

        //
        // If worker is not already running queue a thread
        //
        if ((PopWorkerStatus & (PO_WORKER_MAIN | PO_WORKER_STATUS)) ==
                (PO_WORKER_MAIN | PO_WORKER_STATUS) ) {

            PopWorkerStatus &= ~PO_WORKER_STATUS;
            ExQueueWorkItem (&PopPolicyWorker, DelayedWorkQueue);

        }

    }

    //
    // If this irp has been cancelled, then make sure to clear the cancel flag
    //
    if (Irp->IoStatus.Status == STATUS_CANCELLED) {

        Irp->Cancel = FALSE;

    }
    KeReleaseSpinLock (&PopWorkerSpinLock, OldIrql);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
PopCheckForWork (
    IN BOOLEAN GetWorker
    )
/*++

Routine Description:

    Checks for outstanding work and dispatches a worker if needed.

Arguments:

    None

Return Value:

    None

--*/
{
    KIRQL       Irql;

    //
    // If pending work, handle it
    //

    if (PopWorkerPending & PopWorkerStatus) {

        //
        // If current thread already owns the policy lock,
        // then just return - we will handle the work when the
        // lock is released
        //

        if (PopPolicyLockThread == KeGetCurrentThread()) {
            return ;
        }

        //
        // Handle the work
        //

        Irql = KeGetCurrentIrql();
        if (!GetWorker  &&  Irql < DISPATCH_LEVEL) {

            //
            // Use calling thread
            //

            KeEnterCriticalRegion ();
            PopPolicyWorkerThread (NULL);
            KeLeaveCriticalRegion ();

        } else {

            //
            // Get worker thread to handle it
            //

            KeAcquireSpinLock (&PopWorkerSpinLock, &Irql);
            if (PopWorkerStatus & PO_WORKER_STATUS) {
                PopWorkerStatus &= ~PO_WORKER_STATUS;
                ExQueueWorkItem (&PopPolicyWorker, DelayedWorkQueue);
            }
            KeReleaseSpinLock (&PopWorkerSpinLock, Irql);

        }
    }
}


VOID
PopPolicyWorkerThread (
    PVOID   Context
    )
/*++

Routine Description:

    Main policy manager worker thread dispatcher.   Sends the
    worker thread to the highest pending priority handler which
    does not already have a worker thread.  Loops until no
    handler can be dispatched too.

Arguments:

Return Value:

    None

--*/
{
    ULONG           WorkerType;
    ULONG           Mask;
    KIRQL           OldIrql;
    ULONG           i;
    ULONG           DelayedWork;

    PAGED_CODE();

    try {
        //
        // Dispatch
        //

        KeAcquireSpinLock (&PopWorkerSpinLock, &OldIrql);
        PopWorkerStatus |= (ULONG) ((ULONG_PTR)Context);

        DelayedWork = 0;
        while (WorkerType = (PopWorkerPending & PopWorkerStatus)) {

            //
            // Get highest priority worker
            //

            i = KeFindFirstSetRightMember(WorkerType);
            Mask = 1 << i;

            //
            // Clear pending and indicate busy status
            //

            PopWorkerPending &= ~Mask;
            PopWorkerStatus  &= ~Mask;
            KeReleaseSpinLock (&PopWorkerSpinLock, OldIrql);

            //
            // Dispatch to handler
            //

            DelayedWork |= PopWorkerTypes[i] ();

            //
            // No longer in progress
            //

            KeAcquireSpinLock (&PopWorkerSpinLock, &OldIrql);
            PopWorkerStatus |= Mask;
        }

        PopWorkerPending |= DelayedWork;
        KeReleaseSpinLock (&PopWorkerSpinLock, OldIrql);

    } except (PopExceptionFilter(GetExceptionInformation(), FALSE)) {

    }
}


ULONG
PopPolicyWorkerMain (
    VOID
    )
/*++

Routine Description:

    Main policy worker thread.   Dispatches any completed policy
    manager irps.

Arguments:

    None

Return Value:

    None

--*/
{
    IN PIRP             Irp;
    PIO_STACK_LOCATION  IrpSp;
    POP_IRP_HANDLER     IrpHandler;
    PLIST_ENTRY         Entry;


    PopAcquirePolicyLock ();

    //
    // Dispatch any policy irps which have completed
    //

    while (Entry = ExInterlockedRemoveHeadList (&PopPolicyIrpQueue, &PopWorkerSpinLock)) {
        Irp = CONTAINING_RECORD (Entry, IRP, Tail.Overlay.ListEntry);
        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // Dispatch irp to handler
        //

        IrpHandler = (POP_IRP_HANDLER) (ULONG_PTR) IrpSp->Parameters.Others.Argument3;
        IrpHandler ((PDEVICE_OBJECT) IrpSp->Parameters.Others.Argument1,
                    Irp,
                    (PVOID)          IrpSp->Parameters.Others.Argument2);
    }


    PopReleasePolicyLock (FALSE);
    PopCheckForWork (TRUE);

    return 0;
}

VOID
PopEventCalloutDispatch (
    IN PSPOWEREVENTTYPE EventNumber,
    IN ULONG_PTR Code
    )
{
    WIN32_POWEREVENT_PARAMETERS Parms;
    ULONG Console;
    PVOID OpaqueSession;
    KAPC_STATE ApcState;
    NTSTATUS Status;

    Parms.EventNumber = EventNumber;
    Parms.Code = Code;

    ASSERT(MmIsSessionAddress((PVOID)PopEventCallout));

    if (EventNumber == PsW32GdiOn || EventNumber == PsW32GdiOff) {
        //
        // These events go to the console session only.
        // The ActiveConsoleId session is stored with the SharedUserData.
        //
        Console = SharedUserData->ActiveConsoleId;

        //
        // Unfortunately, it is not guaranteed to be valid during a console
        // session change, and there is no way to know when that is happening,
        // so if it's not valid, just default to session 0, which is always
        // there.
        //
        if (Console == ((ULONG)-1)) {
            Console = 0;
        }

        if ((PsGetCurrentProcess()->Flags & PS_PROCESS_FLAGS_IN_SESSION) &&
            (Console == PsGetCurrentProcessSessionId())) {
            //
            // If the caller is already in the specified session, call directly.
            //
            PopEventCallout(&Parms);

        } else {
            //
            // Attach to the console session and dispatch the event.
            //
            OpaqueSession = MmGetSessionById(Console);
            if (OpaqueSession) {

                Status = MmAttachSession(OpaqueSession, &ApcState);
                ASSERT(NT_SUCCESS(Status));

                if (NT_SUCCESS(Status)) {

                    PopEventCallout(&Parms);

                    Status = MmDetachSession(OpaqueSession, &ApcState);
                    ASSERT(NT_SUCCESS(Status));
                }

                Status = MmQuitNextSession(OpaqueSession);
                ASSERT(NT_SUCCESS(Status));
            }
        }

    } else {
        //
        // All other events are broadcast to all sessions.
        //
        for (OpaqueSession = MmGetNextSession(NULL);
             OpaqueSession != NULL;
             OpaqueSession = MmGetNextSession(OpaqueSession)) {

            if ((PsGetCurrentProcess()->Flags & PS_PROCESS_FLAGS_IN_SESSION) &&
                (MmGetSessionId(OpaqueSession) == PsGetCurrentProcessSessionId())) {
                //
                // If the caller is already in the specified session, call directly.
                //
                PopEventCallout(&Parms);

            } else {
                //
                // Attach to the session and dispatch the event.
                //
                Status = MmAttachSession(OpaqueSession, &ApcState);
                ASSERT(NT_SUCCESS(Status));

                if (NT_SUCCESS(Status)) {

                    PopEventCallout(&Parms);

                    Status = MmDetachSession(OpaqueSession, &ApcState);
                    ASSERT(NT_SUCCESS(Status));
                }
            }
        }
    }
    return;
}



ULONG
PopPolicyTimeChange (
    VOID
    )
{
    PopEventCalloutDispatch (PsW32SystemTime, 0);
    return 0;
}


VOID
PopSetNotificationWork (
    IN ULONG    Flags
    )
/*++

Routine Description:

    Sets notification flags for the USER notification worker thread.
    Each bit is a different type of outstanding notification that
    is to be processed.

Arguments:

    Flags       - The notifications to set

Return Value:

    None

--*/
{
    //
    // Are the flags set
    //


    if ((PopNotifyEvents & Flags) != Flags) {
        PoPrint(PO_NOTIFY, ("PopSetNotificationWork: Queue notify of: %x\n", Flags));
        InterlockedOr (&PopNotifyEvents, Flags);
        PopGetPolicyWorker (PO_WORKER_NOTIFY);
    }
}


ULONG
PopPolicyWorkerNotify (
    VOID
    )
/*++

Routine Description:

    USER notification worker.  Processes each set bit in NotifyEvents.

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG               i;
    LONG                Flags;
    ULONG               Mask;
    const POP_NOTIFY_WORK* NotifyWork;

    //
    // If Win32 event callout is registered, then don't dispatch right now
    //

    if (!PopEventCallout) {
        return PO_WORKER_NOTIFY;
    }

    //
    // While events are pending collect them and dispatch them
    //

    while (Flags = InterlockedExchange (&PopNotifyEvents, 0)) {

        while (Flags) {

            //
            // Get change
            //

            i = KeFindFirstSetRightMember(Flags);
            Mask = 1 << i;
            Flags &= ~Mask;
            NotifyWork = PopNotifyWork + i;

            //
            // Dispatch it
            //

            NotifyWork->Function (NotifyWork->Arg);
        }
    }
    return 0;
}


VOID
PopDispatchCallout (
    IN ULONG Arg
    )
{
    PopEventCalloutDispatch (Arg, 0);
}

VOID
PopDispatchCallback (
    IN ULONG Arg
    )
{
    // Sundown: Arg is zero-extended
    ExNotifyCallback (ExCbPowerState, ULongToPtr(Arg), 0);
}

VOID
PopDispatchDisplayRequired (
    IN ULONG Arg
    )
/*++

Routine Description:

    Notify user32 of the current "display required" setting.  Zero, means
    the display may timeout.  Non-zero, means the display is in use
    until told otherwise.

--*/
{
    ULONG   i;

    UNREFERENCED_PARAMETER (Arg);

    i = PopAttributes[POP_DISPLAY_ATTRIBUTE].Count;
    PoPrint(PO_NOTIFY, ("PopNotify: DisplayRequired %x\n", i));

    //
    // If the display is in use but has not yet been turned on, then do so now
    //
    if (((PopFullWake & (PO_GDI_STATUS | PO_GDI_ON_PENDING)) == PO_GDI_ON_PENDING)) {

        PoPrint(PO_PACT, ("PopEventDispatch: gdi on\n"));
        InterlockedOr (&PopFullWake, PO_GDI_STATUS);
        PopEventCalloutDispatch (PsW32GdiOn, 0);
    }
    PopEventCalloutDispatch (PsW32DisplayState, i);
}

VOID
PopDispatchFullWake (
    IN ULONG Arg
    )
/*++

Routine Description:

    Notify user32 that the system has fully awoken.
    Also reset the idle detection to the current policy

--*/
{

    //
    // If we're not in the middle setting the system state, then check the pending
    // flags.
    //

    UNREFERENCED_PARAMETER (Arg);

    if (PopAction.State != PO_ACT_SET_SYSTEM_STATE) {

        //
        // Notify user32 of the wake events
        //

        if ((PopFullWake & (PO_GDI_STATUS | PO_GDI_ON_PENDING)) == PO_GDI_ON_PENDING) {
            PoPrint(PO_PACT, ("PopEventDispatch: gdi on\n"));
            InterlockedOr (&PopFullWake, PO_GDI_STATUS);
            PopEventCalloutDispatch (PsW32GdiOn, 0);
        }

        if ((PopFullWake & (PO_FULL_WAKE_STATUS | PO_FULL_WAKE_PENDING)) == PO_FULL_WAKE_PENDING) {
            PoPrint(PO_PACT, ("PopEventDispatch: full wake\n"));
            InterlockedOr (&PopFullWake, PO_FULL_WAKE_STATUS);
            PopEventCalloutDispatch (PsW32FullWake, 0);

            //
            // Reset the idle detection policy
            //

            PopAcquirePolicyLock();
            PopInitSIdle ();
            PopReleasePolicyLock (FALSE);
        }
    }
}


VOID
PopDispatchEventCodes (
    IN ULONG Arg
    )
/*++

Routine Description:

    Notify user32 of the queued event codes.

--*/
{
    ULONG       i;
    ULONG       Code;

    UNREFERENCED_PARAMETER (Arg);

    PopAcquirePolicyLock();
    for (i=0; i < POP_MAX_EVENT_CODES; i++) {
        if (PopEventCode[i]) {
            Code = PopEventCode[i];
            PopEventCode[i] = 0;
            PopReleasePolicyLock (FALSE);

            PoPrint(PO_NOTIFY, ("PopNotify: Event %x\n", Code));
            PopEventCalloutDispatch (PsW32EventCode, Code);

            PopAcquirePolicyLock ();
        }
    }

    PopResetSwitchTriggers();
    PopReleasePolicyLock(FALSE);
}


VOID
PopDispatchAcDcCallback (
    IN ULONG Arg
    )
/*++

Routine Description:

    Notify the system callback of the current policy as either
    being AC or DC

--*/
{
    UNREFERENCED_PARAMETER (Arg);

    ExNotifyCallback (
        ExCbPowerState,
        UIntToPtr(PO_CB_AC_STATUS),
        UIntToPtr((PopPolicy == &PopAcPolicy))
        );
}

VOID
PopDispatchPolicyCallout (
    IN ULONG Arg
    )
/*++

Routine Description:

    Notify user32 that the active policy has changed

--*/
{
    UNREFERENCED_PARAMETER (Arg);

    PoPrint(PO_NOTIFY, ("PopNotify: PolicyChanged\n"));
    PopEventCalloutDispatch (PsW32PowerPolicyChanged, PopPolicy->VideoTimeout);
}

VOID
PopDispatchProcessorPolicyCallout (
    IN ULONG Arg
    )
/*++

Routine Description:

    Not used right now. But required so that we don't have a NULL entry
    in the PopNotifyWork array

--*/
{
    UNREFERENCED_PARAMETER (Arg);

    PoPrint(PO_NOTIFY, ("PopNotify: ProcessorPolicyChanges\n"));
}

VOID
PopDispatchSetStateFailure (
    IN ULONG Arg
    )
/*++

Routine Description:

    Notify user32 that there was a failure during an async system state
    operation.  E.g., no error code was returned to anyone, yet the operation
    failed

--*/
{
    PO_SET_STATE_FAILURE    Failure;

    UNREFERENCED_PARAMETER (Arg);

    RtlZeroMemory (&Failure, sizeof(Failure));

    PopAcquirePolicyLock();

    //
    // If the action state is idle, check to see if we should notify
    // win32 of the failure
    //

    if (PopAction.State == PO_ACT_IDLE  && !NT_SUCCESS(PopAction.Status)  &&
        (PopAction.Flags & (POWER_ACTION_UI_ALLOWED | POWER_ACTION_CRITICAL)) ) {

        Failure.Status          = PopAction.Status;
        Failure.PowerAction     = PopAction.Action;
        Failure.MinState        = PopAction.LightestState;
        Failure.Flags           = PopAction.Flags;
    }

    //
    // Reset PopAction to the default.  Otherwise, any power requests following
    // this failure will refer to PopAction, which contains data from this
    // failed request.
    //
    PopResetActionDefaults();

    PopReleasePolicyLock (FALSE);

    if (!NT_SUCCESS(Failure.Status)) {
        PoPrint(PO_NOTIFY, ("PopNotify: set state failed (code %x)\n", Failure.Status));
        PopEventCalloutDispatch (PsW32SetStateFailed, (ULONG_PTR) &Failure);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\sidle.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sidle.c

Abstract:

    This module implements system idle functionality

Author:

    Ken Reneris (kenr) 17-Jan-1997

Revision History:

--*/


#include "pop.h"

ULONG
PopSqrt(
    IN ULONG    value
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PopInitSIdle)
#pragma alloc_text(PAGE, PopPolicySystemIdle)
#pragma alloc_text(PAGE, PoSystemIdleWorker)
#pragma alloc_text(PAGE, PopSqrt)
#endif


VOID
PopInitSIdle (
    VOID
    )
/*++

Routine Description:

    Initializes state for idle system detection

Arguments:

    Uses current policy

Return Value:

    None

--*/
{
    LARGE_INTEGER           li;
    POP_SYSTEM_IDLE         Idle;


    ASSERT_POLICY_LOCK_OWNED();

    //
    // Assume system idle detection is not enabled
    //

    Idle.Action.Action = PowerActionNone;
    Idle.MinState = PowerSystemSleeping1;
    Idle.Timeout = (ULONG) -1;
    Idle.Sensitivity = 100;

    //
    // Either set idle detection for the current policy or for
    // re-entering a sleep state in the case of a quite wake
    //

    if (AnyBitsSet (PopFullWake, PO_FULL_WAKE_STATUS | PO_FULL_WAKE_PENDING)) {

        //
        // Set system idle detection for the current policy
        //

        if (PopPolicy->Idle.Action != PowerActionNone &&
            PopPolicy->IdleTimeout  &&
            PopPolicy->IdleSensitivity) {

            Idle.Action = PopPolicy->Idle;
            Idle.Timeout = (PopPolicy->IdleTimeout + SYS_IDLE_WORKER - 1) / SYS_IDLE_WORKER;
            Idle.MinState = PopPolicy->MinSleep;
            Idle.Sensitivity = 66 + PopPolicy->IdleSensitivity / 3;
        }

    } else {

        //
        // System is not fully awake, set the system idle detection
        // code to re-enter the sleeping state quickly unless a full
        // wake happens
        //

        Idle.Action.Action = PopAction.Action;
        Idle.MinState = PopAction.LightestState;
        if (Idle.MinState == PowerSystemHibernate) {
            //
            // The timeout is a little longer for hibernate since it takes
            // so much longer to enter & exit this state.
            //
            Idle.Timeout = SYS_IDLE_REENTER_TIMEOUT_S4 / SYS_IDLE_WORKER;
        } else {
            Idle.Timeout = SYS_IDLE_REENTER_TIMEOUT / SYS_IDLE_WORKER;
        }
        //
        // Set Idle.Action.Flags to POWER_ACTION_QUERY_ALLOWED to insure 
        // that all normal power messages are broadcast when we re enter a low power state
        //
        Idle.Action.Flags = POWER_ACTION_QUERY_ALLOWED;
        Idle.Action.EventCode = 0;
        Idle.Sensitivity = SYS_IDLE_REENTER_SENSITIVITY;
    }

    //
    // See if idle detection has changed
    //

    if (RtlCompareMemory (&PopSIdle.Action, &Idle.Action, sizeof(POWER_ACTION_POLICY)) !=
        sizeof(POWER_ACTION_POLICY) ||
        PopSIdle.Timeout != Idle.Timeout ||
        PopSIdle.Sensitivity != Idle.Sensitivity) {

        PoPrint (PO_SIDLE, ("PoSIdle: new idle params set\n"));

        //
        // Clear current detection
        //

        KeCancelTimer(&PoSystemIdleTimer);
        PopSIdle.Time = 0;
        PopSIdle.IdleWorker = TRUE;

        //
        // Set new idle detection
        //

        PopSIdle.Action = Idle.Action;
        PopSIdle.MinState = Idle.MinState;
        PopSIdle.Timeout = Idle.Timeout;
        PopSIdle.Sensitivity = Idle.Sensitivity;

        //
        // If new action, enable system idle worker
        //

        if (PopSIdle.Action.Action) {
            li.QuadPart = -1 * SYS_IDLE_WORKER * US2SEC * US2TIME;
            KeSetTimerEx(&PoSystemIdleTimer, li, SYS_IDLE_WORKER*1000, NULL);
        }
    }
}


ULONG
PopPolicySystemIdle (
    VOID
    )
/*++

Routine Description:

    Power policy worker thread to trigger the system idle power action

Arguments:

    None

Return Value:

    None

--*/
{
    BOOLEAN                 SystemIdle;
    POP_ACTION_TRIGGER      Trigger;

    //
    // Take out the policy lock and check to see if the system is
    // idle
    //

    PopAcquirePolicyLock ();
    SystemIdle = PoSystemIdleWorker(FALSE);

    //
    // If heuristics are dirty, save a new copy
    //

    if (PopHeuristics.Dirty) {
        PopSaveHeuristics ();
    }

    //
    // Put system idle detection back to idle worker
    //

    PopSIdle.IdleWorker = TRUE;

    //
    // If system idle, trigger system idle action
    //

    if (SystemIdle) {

        //
        // On success or failure, reset the trigger
        //

        PopSIdle.Time = 0;
        PopSIdle.Sampling = FALSE;

        //
        // Invoke system state change
        //

        RtlZeroMemory (&Trigger, sizeof(Trigger));
        Trigger.Type  = PolicySystemIdle;
        Trigger.Flags = PO_TRG_SET;
        PopSetPowerAction (
           &Trigger,
           0,
           &PopSIdle.Action,
           PopSIdle.MinState,
           SubstituteLightestOverallDownwardBounded
           );
    }
    PopReleasePolicyLock (FALSE);
    return 0;
}


VOID
PopCaptureCounts (
    OUT PULONGLONG LastTick,
    OUT PLARGE_INTEGER CurrentTick,
    OUT PULONGLONG LastIoTransfer,
    OUT PULONGLONG CurrentIoTransfer
    )
{
    KIRQL OldIrql;

    //
    // Capture current tick and IO count.  Do it at dpc level so
    // the IO count will be reasonable on track with the tick count.
    //

    KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);

    *LastTick = PopSIdle.LastTick;
    *LastIoTransfer = PopSIdle.LastIoTransfer;

    KeQueryTickCount (CurrentTick);
    *CurrentIoTransfer = IoReadTransferCount.QuadPart + IoWriteTransferCount.QuadPart + IoOtherTransferCount.QuadPart;

    KeLowerIrql (OldIrql);
}

BOOLEAN
PoSystemIdleWorker (
    IN BOOLEAN IdleWorker
    )
/*++

Routine Description:

    Worker function called by an idle priority thread to watch
    for an idle system.

    N.B. To save on threads we use the zero paging thread from Mm
    to perform this check.  It can not be blocked.

Arguments:

    IdleWorker      - True if caller is at IdlePriority

Return Value:

    None

--*/
{
    LARGE_INTEGER               CurrentTick;
    ULONGLONG                   LastTick;
    LONG                        TickDiff;
    ULONG                       Processor;
    KAFFINITY                   Mask;
    ULONG                       NewTime;
    LONG                        ProcIdleness, ProcBusy;
    LONG                        percent;
    BOOLEAN                     GoodSample;
    BOOLEAN                     SystemIdle;
    BOOLEAN                     GetWorker;
    KAFFINITY                   Summary;
    PPROCESSOR_POWER_STATE      PState;
    ULONG                       i;
    LONG                        j;
    ULONGLONG                   CurrentIoTransfer, LastIoTransfer;
    LONGLONG                    IoTransferDiff;
    PKPRCB                      Prcb;


    if (IdleWorker) {

        //
        // Clear idle worker timer's signalled state
        //

        KeClearTimer (&PoSystemIdleTimer);
    }

    //
    // If the system required or user present attribute is set,
    // then don't bother with any checks
    //

    if (PopAttributes[POP_SYSTEM_ATTRIBUTE].Count ||
        PopAttributes[POP_USER_ATTRIBUTE].Count) {
            return FALSE;
    }

    //
    // If this is the wrong worker, don't bother
    //

    if (IdleWorker != PopSIdle.IdleWorker) {
        return FALSE;
    }

    GoodSample = FALSE;
    SystemIdle = FALSE;
    GetWorker  = FALSE;
    NewTime = PopSIdle.Time;

    PopCaptureCounts(&LastTick, &CurrentTick, &LastIoTransfer, &CurrentIoTransfer);

    //
    // If this is an initial sample, initialize starting sample
    //

    if (!PopSIdle.Sampling) {
        GoodSample = TRUE;
        goto Done;
    }

    //
    // Compute the number of ticks since the last check
    //

    TickDiff = (ULONG) (CurrentTick.QuadPart - LastTick);
    IoTransferDiff = CurrentIoTransfer - LastIoTransfer;

    //
    // if it's a poor sample, skip it
    //

    if ((TickDiff <= 0) || (IoTransferDiff < 0)) {
        PoPrint (PO_SIDLE, ("PoSIdle: poor sample\n"));
        PopSIdle.Sampling = FALSE;
        goto Done;
    }

    GoodSample = TRUE;

    //
    // Get lowest idleness of any processor
    //

    ProcIdleness = 100;
    Summary = KeActiveProcessors;
    Processor = 0;
    while (Summary) {
        if (Summary & 1) {
            Prcb = KiProcessorBlock[Processor];
            PState = &Prcb->PowerState;

            percent = (Prcb->IdleThread->KernelTime - PState->LastSysTime) * 100 / TickDiff;
            if (percent < ProcIdleness) {
                ProcIdleness = percent;
            }

        }

        Summary = Summary >> 1;
        Processor = Processor + 1;
    }

    if (ProcIdleness > 100) {
        ProcIdleness = 100;
    }
    ProcBusy = 100 - ProcIdleness;

    //
    // Normalize IO transfers to be some number per tick
    //

    IoTransferDiff = IoTransferDiff / TickDiff;

    //
    // If the system is loaded a bit, but not a lot calculate
    // how many IO transfers can occur for each percentage point
    // of being busy
    //

    if (ProcIdleness <= 90  &&  ProcIdleness >= 50) {

        i = (ULONG) IoTransferDiff / ProcBusy;

        //
        // Make running average of the result
        //

        if (PopHeuristics.IoTransferSamples < SYS_IDLE_SAMPLES) {

            if (PopHeuristics.IoTransferSamples == 0) {

                PopHeuristics.IoTransferTotal = i;
            }
            PopHeuristics.IoTransferTotal += i;
            PopHeuristics.IoTransferSamples += 1;

        } else {

            PopHeuristics.IoTransferTotal = PopHeuristics.IoTransferTotal + i -
                (PopHeuristics.IoTransferTotal / PopHeuristics.IoTransferSamples);

        }

        //
        // Determine weighting of transfers as percent busy and compare
        // to current weighting.  If the weighting has moved then update
        // the heuristic
        //

        i = PopHeuristics.IoTransferTotal / PopHeuristics.IoTransferSamples;
        j = PopHeuristics.IoTransferWeight - i;
        if (j < 0) {
            j = -j;
        }

        if (i > 0  &&  j > 2  &&  j > (LONG) PopHeuristics.IoTransferWeight/10) {
            PoPrint (PO_SIDLE, ("PoSIdle: updated weighting = %d\n", i));
            PopHeuristics.IoTransferWeight = i;
            PopHeuristics.Dirty = TRUE;
            GetWorker = TRUE;
        }
    }

    PopSIdle.Idleness = ProcIdleness;

    //
    // Reduce system idleness by the weighted transfers occuring
    //

    i = (ULONG) ((ULONGLONG) IoTransferDiff / PopHeuristics.IoTransferWeight);
    j = i - ProcBusy/2;
    if (j > 0) {
        PopSIdle.Idleness = ProcIdleness - PopSqrt(j * i);
    }

    //
    // Count how long the system has been more idle then the sensitivity setting
    //

    if (PopSIdle.Idleness >= (LONG) PopSIdle.Sensitivity) {

        NewTime = PopSIdle.Time + 1;
        if (NewTime >= PopSIdle.Timeout) {
            SystemIdle = TRUE;
            GetWorker = TRUE;
        }

    } else {

        //
        // System is not idle enough, reset the timeout
        //

        NewTime = 0;
        PopSIdle.Time = 0;
    }


    PoPrint (PO_SIDLE, ("PoSIdle: Proc %d, IoTran/Tick %d, IoAdjusted %d, Sens %d, count %d %d\n",
                ProcIdleness,
                (ULONG)IoTransferDiff,
                PopSIdle.Idleness,
                PopSIdle.Sensitivity,
                NewTime,
                PopSIdle.Timeout
                ));


Done:
    //
    // If we need a non-idle worker thread, queue it and don't update
    // last values for this sample since the non-idle thread will make
    // another sample shortly
    //

    if (GetWorker) {
        PopSIdle.IdleWorker = FALSE;
        PopGetPolicyWorker (PO_WORKER_SYS_IDLE);

        if (IdleWorker) {
            PopCheckForWork (TRUE);
        }

    } else {

        //
        // If this was a good sample, update
        //

        if (GoodSample) {
            PopSIdle.Time = NewTime;
            PopSIdle.LastTick = CurrentTick.QuadPart;
            PopSIdle.LastIoTransfer = CurrentIoTransfer;
            PopSIdle.Sampling = TRUE;

            Summary = KeActiveProcessors;
            Processor = 0;
            Mask = 1;
            for (; ;) {
                if (Summary & Mask) {
                    Prcb = KiProcessorBlock[Processor];
                    PState = &Prcb->PowerState;

                    PState->LastSysTime = Prcb->IdleThread->KernelTime;
                    Summary &= ~Mask;
                    if (!Summary) {
                        break;
                    }
                }

                Mask = Mask << 1;
                Processor = Processor + 1;
            }
        }
    }

    return SystemIdle;
}


ULONG
PopSqrt(
    IN ULONG    value
    )
/*++

Routine Description:

    Returns the integer square root of an operand between 0 and 9999.

Arguments:

    value           - Value to square root

Return Value:

    Square root rounded down

--*/
{
    ULONG       h, l, i;

    h = 100;
    l = 0;

    for (; ;) {
        i = l + (h-l) / 2;
        if (i*i > value) {
            h = i;
        } else {
            if (l == i) {
                break;
            }
            l = i;
        }
    }

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\switch.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    switch.c

Abstract:

    Button and lid support for the power policy manager

Author:

    Ken Reneris (kenr) 17-Jan-1997

Revision History:

--*/


#include "pop.h"


VOID
PopTriggerSwitch (
    IN PPOP_SWITCH_DEVICE SwitchDevice,
    IN ULONG Flag,
    IN PPOWER_ACTION_POLICY Action
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PopSystemButtonHandler)
#pragma alloc_text(PAGE, PopResetSwitchTriggers)
#pragma alloc_text(PAGE, PopTriggerSwitch)
#endif

VOID
PopSystemButtonHandler (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    This function is the irp handler function to handle the completion
    if a query switch status irp.   On completion this IRP is recycled
    to the next request.

    N.B. PopPolicyLock must be held.

Arguments:

    DeviceObject    - DeviceObject of the switch device

    Irp             - Irp which has completed

    Context         - type of switch device

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PPOP_SWITCH_DEVICE      SwitchDevice;
    ULONG                   IoctlCode;
    PLIST_ENTRY             ListEntry;
    ULONG                   DisabledCaps;

    ASSERT_POLICY_LOCK_OWNED();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    SwitchDevice = (PPOP_SWITCH_DEVICE) Context;

    if (NT_SUCCESS (Irp->IoStatus.Status)) {

        if (!SwitchDevice->GotCaps) {

            //
            // We have never gotten any button capabilities yet.
            // Try and get them now.
            //

            SwitchDevice->Caps = 0;
            if (SwitchDevice->IrpBuffer & SYS_BUTTON_POWER) {
                PopSetCapability (&PopCapabilities.PowerButtonPresent);
                SwitchDevice->Caps |= SYS_BUTTON_POWER;
            }

            if (SwitchDevice->IrpBuffer & SYS_BUTTON_SLEEP) {
                PopSetCapability (&PopCapabilities.SleepButtonPresent);
                SwitchDevice->Caps |= SYS_BUTTON_SLEEP;
            }

            if (SwitchDevice->IrpBuffer & SYS_BUTTON_LID) {
                PopSetCapability (&PopCapabilities.LidPresent);
                SwitchDevice->Caps |= SYS_BUTTON_LID;
            }

            SwitchDevice->IrpBuffer = 0;
            SwitchDevice->GotCaps = TRUE;

            //
            // If no capabilities, indicate failure to cause
            // the device to be closed
            //

            if (SwitchDevice->Caps == 0) {
                SwitchDevice->IsFailed = TRUE;
            }

        } else {

            //
            // We've been called before so we know what the buttons are supposed
            // to do.  Check to see if any of our buttons have triggered an
            // event.
            //

            PopTriggerSwitch (SwitchDevice, SYS_BUTTON_LID,   &PopPolicy->LidClose);
            PopTriggerSwitch (SwitchDevice, SYS_BUTTON_POWER, &PopPolicy->PowerButton);
            PopTriggerSwitch (SwitchDevice, SYS_BUTTON_SLEEP, &PopPolicy->SleepButton);

            //
            // If the wake button is signalled, drop the triggered states
            // and set the user as being present
            //

            if (SwitchDevice->IrpBuffer & SYS_BUTTON_WAKE) {
                SwitchDevice->TriggerState = 0;
                PopUserPresentSet (0);
            }
        }

        IoctlCode = IOCTL_GET_SYS_BUTTON_EVENT;

    } else {
        if (!SwitchDevice->IsInitializing) {
            //
            // Unexpected error
            //

            PoPrint (PO_ERROR, ("PopSystemButtonHandler: unexpected error %x\n", Irp->IoStatus.Status));
            SwitchDevice->GotCaps = FALSE;
            SwitchDevice->IsFailed = TRUE;
            IoctlCode = 0;
        } else {
            IoctlCode = IOCTL_GET_SYS_BUTTON_CAPS;
            SwitchDevice->IsInitializing = FALSE;
        }
    }

    if (SwitchDevice->IsFailed) {

        //
        // Close the device
        //

        PoPrint (PO_WARN, ("PopSystemButtonHandler: removing button device\n"));
        RemoveEntryList (&SwitchDevice->Link);
        IoFreeIrp (Irp);
        ObDereferenceObject (DeviceObject);

        //
        // Enumerate the remaining switch devices and disable capabilities
        // which no longer exist.
        //
        DisabledCaps = SwitchDevice->Caps;
        ExFreePool(SwitchDevice);

        ListEntry = PopSwitches.Flink;
        while (ListEntry != &PopSwitches) {
            SwitchDevice = CONTAINING_RECORD(ListEntry,
                                             POP_SWITCH_DEVICE,
                                             Link);
            DisabledCaps &= ~SwitchDevice->Caps;
            ListEntry = ListEntry->Flink;
        }
        if (DisabledCaps & SYS_BUTTON_POWER) {
            PoPrint(PO_WARN,("PopSystemButtonHandler : removing power button\n"));
            PopClearCapability (&PopCapabilities.PowerButtonPresent);
        }
        if (DisabledCaps & SYS_BUTTON_SLEEP) {
            PoPrint(PO_WARN,("PopSystemButtonHandler : removing sleep button\n"));
            PopClearCapability (&PopCapabilities.SleepButtonPresent);
        }
        if (DisabledCaps & SYS_BUTTON_LID) {
            PoPrint(PO_WARN,("PopSystemButtonHandler : removing lid switch\n"));
            PopClearCapability (&PopCapabilities.LidPresent);
        }

    } else {

        //
        // Send notify IRP to the device to wait for new switch state
        //

        IrpSp = IoGetNextIrpStackLocation(Irp);
        IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        IrpSp->Parameters.DeviceIoControl.IoControlCode = IoctlCode;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ULONG);
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(ULONG);
        Irp->AssociatedIrp.SystemBuffer = &SwitchDevice->IrpBuffer;
        IoSetCompletionRoutine (Irp, PopCompletePolicyIrp, NULL, TRUE, TRUE, TRUE);
        IoCallDriver (DeviceObject, Irp);
    }
}

VOID
PopTriggerSwitch (
    IN PPOP_SWITCH_DEVICE SwitchDevice,
    IN ULONG Flag,
    IN PPOWER_ACTION_POLICY Action
    )
{
    POP_ACTION_TRIGGER      Trigger;


    if ((SwitchDevice->Caps & SYS_BUTTON_LID) &&
        (Flag == SYS_BUTTON_LID)) {

        //
        // Somebody opened or closed a lid.
        //

        SwitchDevice->Opened = !(SwitchDevice->Opened);

        //
        // Notify the PowerState callback.
        //

        ExNotifyCallback (
            ExCbPowerState,
            UIntToPtr(PO_CB_LID_SWITCH_STATE),
            UIntToPtr(SwitchDevice->Opened)
            );


        //
        // Now tell win32k.sys that the lid is open.
        //
        if( SwitchDevice->Opened ) {
            PopDisplayRequired(0);
        }


    }

    //
    // Check if event is signalled
    //

    if (SwitchDevice->IrpBuffer & Flag) {

        if (SwitchDevice->TriggerState & Flag) {
            //
            // We're in the middle of servicing an action
            // just like this one already.
            //
            PopSetNotificationWork (PO_NOTIFY_BUTTON_RECURSE);

        } else {

            //
            // Initiate action for this event
            //

            RtlZeroMemory (&Trigger, sizeof(Trigger));
            Trigger.Type  = PolicyDeviceSystemButton;
            Trigger.Flags = PO_TRG_SET;

            PopSetPowerAction (
                &Trigger,
                0,
                Action,
                PowerSystemSleeping1,
                SubstituteLightestOverallDownwardBounded
                );

            SwitchDevice->TriggerState |= (UCHAR) Flag;
        }
    }
}


VOID
PopResetSwitchTriggers (
    VOID
    )
/*++

Routine Description:

    This function clears the triggered status on all switch devices

    N.B. PopPolicyLock must be held.

Arguments:

    None

Return Value:

    Status

--*/
{
    PLIST_ENTRY             Link;
    PPOP_SWITCH_DEVICE      SwitchDevice;

    ASSERT_POLICY_LOCK_OWNED();

    //
    // Clear flag bits
    //

    for (Link = PopSwitches.Flink; Link != &PopSwitches; Link = Link->Flink) {
        SwitchDevice = CONTAINING_RECORD (Link, POP_SWITCH_DEVICE, Link);
        SwitchDevice->TriggerState = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\suspend.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

Abstract:

    Suspend/Hibernate system

Author:

    Ken Reneris (kenr) 19-July-1994

Environment:

    Kernel mode

Revision History:

--*/


#include "pop.h"
#include "zwapi.h"

//
// Nothing right now, will put some worker code in there someday, I think.
//
// NtSetSystemPowerState is in ntapi.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=po

TARGETNAME=po
TARGETTYPE=LIBRARY
TARGETPATH=obj

BUILD_PRODUCES=ntospo$(NT_UP)

INCLUDES=..\..\inc;$(HALKIT_INC_PATH);$(SDKTOOLS_INC_PATH)

MSC_WARNING_LEVEL=/W4 /WX

SOURCES=..\attrib.c     \
        ..\paction.c    \
        ..\pbatt.c      \
        ..\pidle.c      \
        ..\pinfo.c      \
        ..\poinit.c     \
        ..\podata.c     \
        ..\postate.c    \
        ..\pocall.c     \
        ..\poshtdwn.c   \
        ..\pwork.c      \
        ..\switch.c     \
        ..\notify.c     \
        ..\hiber.c      \
        ..\idle.c       \
        ..\misc.c       \
        ..\ntapi.c      \
        ..\sidle.c      \
        ..\suspend.c    \
        ..\sys.c        \
        ..\sysdev.c     \
        ..\thermal.c    \
        ..\throttle.c   \
        ..\volume.c

NTTEST=

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\sysdev.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sysdev.c

Abstract:

    This module interfaces to the system power state IRPs for devices

Author:

    Ken Reneris (kenr) 17-Jan-1997

Revision History:

--*/


#include "pop.h"

//
// External used to determine if the device tree has changed between
// passes of informing devices of a system power state
//

extern ULONG IoDeviceNodeTreeSequence;


//
// Internal prototypes
//

VOID
PopSleepDeviceList (
    IN PPOP_DEVICE_SYS_STATE    DevState,
    IN PPO_NOTIFY_ORDER_LEVEL   Level
    );

VOID
PopWakeDeviceList (
    IN PPOP_DEVICE_SYS_STATE    DevState,
    IN PPO_NOTIFY_ORDER_LEVEL   Level
    );

VOID
PopNotifyDevice (
    IN PPOP_DEVICE_SYS_STATE    DevState,
    IN PPO_DEVICE_NOTIFY        Notify
    );

VOID
PopWaitForSystemPowerIrp (
    IN PPOP_DEVICE_SYS_STATE    DevState,
    IN BOOLEAN                  WaitForAll
    );

NTSTATUS
PopCompleteSystemPowerIrp (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

BOOLEAN
PopCheckSystemPowerIrpStatus  (
    IN PPOP_DEVICE_SYS_STATE    DevState,
    IN PIRP                     Irp,
    IN BOOLEAN                  AllowTestFailure
    );

VOID
PopDumpSystemIrp (
    IN PCHAR                    Desc,
    IN PPOP_DEVICE_POWER_IRP    PowerIrp
    );

VOID
PopResetChildCount(
    IN PLIST_ENTRY ListHead
    );

VOID
PopSetupListForWake(
    IN PPO_NOTIFY_ORDER_LEVEL Level,
    IN PLIST_ENTRY ListHead
    );

VOID
PopWakeSystemTimeout(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, PopSetDevicesSystemState)
#pragma alloc_text(PAGELK, PopWakeDeviceList)
#pragma alloc_text(PAGELK, PopSleepDeviceList)
#pragma alloc_text(PAGELK, PopResetChildCount)
#pragma alloc_text(PAGELK, PopSetupListForWake)
#pragma alloc_text(PAGELK, PopNotifyDevice)
#pragma alloc_text(PAGELK, PopWaitForSystemPowerIrp)
#pragma alloc_text(PAGELK, PopCompleteSystemPowerIrp)
#pragma alloc_text(PAGELK, PopCheckSystemPowerIrpStatus)
#pragma alloc_text(PAGELK, PopCleanupDevState)
#pragma alloc_text(PAGELK, PopRestartSetSystemState)
#pragma alloc_text(PAGELK, PopReportDevState)
#pragma alloc_text(PAGELK, PopDumpSystemIrp)
#pragma alloc_text(PAGELK, PopWakeSystemTimeout)
#pragma alloc_text(PAGE, PopAllocateDevState)
#endif

ULONG PopCurrentLevel=0;
LONG PopWakeTimer = 1;
KTIMER PopWakeTimeoutTimer;
KDPC   PopWakeTimeoutDpc;

NTSTATUS
PopSetDevicesSystemState (
    IN BOOLEAN  Wake
    )
/*++

Routine Description:

    Sends a system power irp of IrpMinor and SystemState from PopAction
    to all devices.

    N.B. Function is not re-entrant.
    N.B. Policy lock must be held.  This function releases and reacquires
         the policy lock.

Arguments:

    Wake  - TRUE if a transition to S0 should be broadcast to all drivers.
            FALSE if the appropriate sleep transition can be found in
            PopAction.DevState

Return Value:

    Status.
        SUCCESS     - all devices contacted without any errors.
        CANCELLED   - operation was aborted.
        Error       - error code of first failure.  All failed IRPs and related
                      device objects are on the Failed list.

--*/
{
    LONG                        i;
    BOOLEAN                     NotifyGdi;
    BOOLEAN                     DidIoMmShutdown = FALSE;
    PPO_DEVICE_NOTIFY           NotifyDevice;
    PLIST_ENTRY                 Link;
    PPOP_DEVICE_POWER_IRP       PowerIrp;
    POWER_ACTION                powerOperation;
    PPOP_DEVICE_SYS_STATE       DevState;
    PDEVICE_OBJECT              DeviceObject;

    ASSERT(PopAction.DevState );
    DevState = PopAction.DevState;

    //
    // Intialize DevState for this pass
    //

    DevState->IrpMinor = PopAction.IrpMinor;
    DevState->SystemState = PopAction.SystemState;
    DevState->Status = STATUS_SUCCESS;
    DevState->FailedDevice = NULL;
    DevState->Cancelled = FALSE;
    DevState->IgnoreErrors = FALSE;
    DevState->IgnoreNotImplemented = FALSE;
    DevState->Waking = Wake;
    NotifyGdi = FALSE;

    if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
        PERFINFO_SET_DEVICES_STATE LogEntry;

        LogEntry.SystemState = (ULONG) DevState->SystemState;
        LogEntry.IrpMinor = PopAction.IrpMinor;
        LogEntry.Waking = Wake;
        LogEntry.Shutdown = PopAction.Shutdown;

        PerfInfoLogBytes(PERFINFO_LOG_TYPE_SET_DEVICES_STATE,
                         &LogEntry,
                         sizeof(LogEntry));
    }


    //
    // If this is a set operation, and the Gdi state is on then we need to
    // notify gdi of the set power operation
    //

    if (PopAction.IrpMinor == IRP_MN_SET_POWER  &&
        AnyBitsSet (PopFullWake, PO_FULL_WAKE_STATUS | PO_GDI_STATUS)) {

        NotifyGdi = TRUE;
    }

    //
    // If the request is for Query on a shutdown operarion, ignore any
    // drivers which don't implment it.  If it's for a Set on a
    // shutdown operation, ignore any errors - the system is going to
    // shutdown
    //

    if (PopAction.Shutdown) {
        DevState->IgnoreNotImplemented = TRUE;
        if (PopAction.IrpMinor == IRP_MN_SET_POWER) {
            DevState->IgnoreErrors = TRUE;
        }
    }

    //
    // This function is not re-entrant, and the operation has been
    // serialized before here
    //

    ASSERT (DevState->Thread == KeGetCurrentThread());

    //
    // Notify all devices.
    //

    if (!Wake) {

        //
        // If it's time to update the device list, then do so
        //

        if (DevState->GetNewDeviceList) {
            DevState->GetNewDeviceList = FALSE;
            IoFreePoDeviceNotifyList (&DevState->Order);
            DevState->Status = IoBuildPoDeviceNotifyList (&DevState->Order);
        } else {
            //
            // Reset the active child count of each notification
            //
            for (i=0;i<=PO_ORDER_MAXIMUM;i++) {
                PopResetChildCount(&DevState->Order.OrderLevel[i].WaitSleep);
                PopResetChildCount(&DevState->Order.OrderLevel[i].ReadySleep);
                PopResetChildCount(&DevState->Order.OrderLevel[i].ReadyS0);
                PopResetChildCount(&DevState->Order.OrderLevel[i].WaitS0);
                PopResetChildCount(&DevState->Order.OrderLevel[i].Complete);
            }
        }

        if (NT_SUCCESS(DevState->Status)) {

            //
            // Notify all devices of operation in forward order.  Wait between each level.
            //
            for (i=PO_ORDER_MAXIMUM; i >= 0; i--) {

                //
                // Notify this list
                //
                if (DevState->Order.OrderLevel[i].DeviceCount) {

                    if ((NotifyGdi) &&
                        (i <= PO_ORDER_GDI_NOTIFICATION)) {

                        NotifyGdi = FALSE;
                        InterlockedExchange (&PopFullWake, 0);
                        if (PopEventCallout) {

                            //
                            // Turn off the special system irp dispatcher here
                            // as when we call into GDI it is going to block on its
                            // D irp and we are not going to get control back.
                            //

                            PopSystemIrpDispatchWorker(TRUE);
                            PopEventCalloutDispatch (PsW32GdiOff, DevState->SystemState);
                        }
                    }

                    //
                    // If we're shutting down and if we're done
                    // notifying paged devices, shut down filesystems
                    // and MM to free up all resources on the paging
                    // path (which we should no longer need).
                    //
                    if (PopAction.Shutdown &&
                        !DidIoMmShutdown   &&
                        (PopAction.IrpMinor == IRP_MN_SET_POWER) &&
                        (i < PO_ORDER_PAGABLE)) {

                        //
                        // Disable crash-dump stack. From this point on, we
                        // will get no logs.
                        //
                        IoConfigureCrashDump(CrashDumpDisable);

                        //
                        // At this point, we are about to drop the final refs
                        // on the pagefile file-objects. Since close IRPs go
                        // through pagable code, there should be no open handles
                        // in the system process at this point (note: we don't
                        // look for file objects without handles, the pagefiles
                        // being among them.)
                        //
                        if (PoCleanShutdownEnabled() & PO_CLEAN_SHUTDOWN_OB) {
                            ObShutdownSystem (1);
                        }

                        //
                        // ISSUE - 2002/02/20 - ADRIAO: Unwind of final closes
                        //    We should lock down close paths, so that unwind
                        // from closing the paging file will work properly.
                        // This is one reason why the clean shutdown code isn't
                        // enabled by default.
                        //

                        //
                        // Memory management will drop the pagefile file-object
                        // references, in theory allowing the filesystem stack
                        // to unload.
                        //
                        // NO MORE REFERENCES TO PAGABLE CODE OR DATA MAY BE
                        // MADE!
                        //
                        MmShutdownSystem(1);

                        DidIoMmShutdown = TRUE;
                    }

                    //
                    // Remove the warm eject node if we might have gotten here
                    // without a query.
                    //
                    if (PopAction.Flags & POWER_ACTION_CRITICAL) {

                        *DevState->Order.WarmEjectPdoPointer = NULL;
                    }

                    //
                    // Notify this list
                    //

                    PopCurrentLevel = i;
                    PopSleepDeviceList (DevState, &DevState->Order.OrderLevel[i]);
                    PopWaitForSystemPowerIrp (DevState, TRUE);
                }

                //
                // If there's been an error, stop and issue wakes to all devices
                //

                if (!NT_SUCCESS(DevState->Status)) {
                    Wake = TRUE;
                    if ((DevState->FailedDevice != NULL) &&
                        (PopAction.NextSystemState == PowerSystemWorking)) {

                        powerOperation = PopMapInternalActionToIrpAction(
                            PopAction.Action,
                            DevState->SystemState,
                            FALSE
                            );

                        if (powerOperation == PowerActionWarmEject) {
                            DeviceObject = *DevState->Order.WarmEjectPdoPointer;
                        } else {
                            DeviceObject = NULL;
                        }

                        IoNotifyPowerOperationVetoed(
                            powerOperation,
                            DeviceObject,
                            DevState->FailedDevice
                            );
                    }
                    break;
                }
            }
        }
        //
        // This will cause us to wake up all the devices after putting
        // them to sleep.  Useful for test automation.
        //

        if ((PopSimulate & POP_WAKE_DEVICE_AFTER_SLEEP) && (PopAction.IrpMinor == IRP_MN_SET_POWER)) {
            DbgPrint ("po: POP_WAKE_DEVICE_AFTER_SLEEP enabled.\n");
            Wake = TRUE;
            DevState->Status = STATUS_UNSUCCESSFUL;
        }
    }


    //
    // Verify we shut down everything
    //
    ASSERT((!PopAction.Shutdown) || (PopAction.IrpMinor != IRP_MN_SET_POWER) || DidIoMmShutdown);

    //
    // Some debugging code here.  If the debug flag is set, then loop on failed
    // devices and continue to retry them.  This will allow someone to step
    // them through the driver stack to determine where the failure is.
    //

    while ((PopSimulate & POP_LOOP_ON_FAILED_DRIVERS) &&
           !IsListEmpty(&PopAction.DevState->Head.Failed)) {

        Link = PopAction.DevState->Head.Failed.Flink;
        RemoveEntryList(Link);

        PowerIrp = CONTAINING_RECORD (Link, POP_DEVICE_POWER_IRP, Failed);
        PopDumpSystemIrp ("Retry", PowerIrp);

        IoFreeIrp (PowerIrp->Irp);
        NotifyDevice = PowerIrp->Notify;

        PowerIrp->Irp = NULL;
        PowerIrp->Notify = NULL;

        PushEntryList (
            &PopAction.DevState->Head.Free,
            &PowerIrp->Free
            );

        DbgBreakPoint ();
        PopNotifyDevice (DevState, NotifyDevice);
        PopWaitForSystemPowerIrp (DevState, TRUE);
    }

    //
    // If waking, send set power to the working state to all devices which where
    // send something else
    //

    DevState->Waking = Wake;
    if (DevState->Waking) {

        DevState->IgnoreErrors = TRUE;
        DevState->IrpMinor = IRP_MN_SET_POWER;
        DevState->SystemState = PowerSystemWorking;

        //
        // Notify all devices of the wake operation in reverse (level) order.
        //
        KeInitializeTimer(&PopWakeTimeoutTimer);
        KeInitializeDpc(&PopWakeTimeoutDpc, PopWakeSystemTimeout, NULL);

        for (i=0; i <= PO_ORDER_MAXIMUM; i++) {
            PopCurrentLevel = i;
            PopWakeDeviceList (DevState, &DevState->Order.OrderLevel[i]);

            PopWaitForSystemPowerIrp (DevState, TRUE);
            if (PopSimulate & POP_WAKE_DEADMAN) {
                KeCancelTimer(&PopWakeTimeoutTimer);
            }
        }

        // restore
        DevState->IrpMinor = PopAction.IrpMinor;
        DevState->SystemState = PopAction.SystemState;
    }

    //
    // Done
    //

    if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
        PERFINFO_SET_DEVICES_STATE_RET LogEntry;

        LogEntry.Status = DevState->Status;

        PerfInfoLogBytes(PERFINFO_LOG_TYPE_SET_DEVICES_STATE_RET,
                         &LogEntry,
                         sizeof(LogEntry));
    }


    return DevState->Status;
}



VOID
PopReportDevState (
    IN BOOLEAN                  LogErrors
    )
/*++

Routine Description:

    Verifies that the DevState structure is idle

Arguments:

    None

Return Value:

    None

--*/
{
    PIRP                        Irp;
    PLIST_ENTRY                 Link;
    PPOP_DEVICE_POWER_IRP       PowerIrp;
    PIO_ERROR_LOG_PACKET        ErrLog;

    if (!PopAction.DevState) {
        return ;
    }

    //
    // Cleanup any irps on the failed list
    //

    while (!IsListEmpty(&PopAction.DevState->Head.Failed)) {
        Link = PopAction.DevState->Head.Failed.Flink;
        RemoveEntryList(Link);

        PowerIrp = CONTAINING_RECORD (Link, POP_DEVICE_POWER_IRP, Failed);
        Irp = PowerIrp->Irp;

        PopDumpSystemIrp (
            LogErrors ? "Abort" : "fyi",
            PowerIrp
            );

        if (LogErrors) {
            ErrLog = IoAllocateErrorLogEntry (
                            PowerIrp->Notify->TargetDevice->DriverObject,
                            ERROR_LOG_MAXIMUM_SIZE
                            );

            if (ErrLog) {
                RtlZeroMemory (ErrLog, sizeof (*ErrLog));
                ErrLog->FinalStatus = Irp->IoStatus.Status;
                ErrLog->DeviceOffset.QuadPart = Irp->IoStatus.Information;
                ErrLog->MajorFunctionCode = IRP_MJ_POWER;
                ErrLog->UniqueErrorValue = (PopAction.DevState->IrpMinor << 16) | PopAction.DevState->SystemState;
                ErrLog->ErrorCode = IO_SYSTEM_SLEEP_FAILED;
                IoWriteErrorLogEntry (ErrLog);
            }
        }

        IoFreeIrp (Irp);
        PowerIrp->Irp = NULL;
        PowerIrp->Notify = NULL;

        PushEntryList (
            &PopAction.DevState->Head.Free,
            &PowerIrp->Free
            );
    }

    //
    // Errors have been purged, we can now allocate a new device notification list if needed
    //

    if (PopAction.DevState->Order.DevNodeSequence != IoDeviceNodeTreeSequence) {
        PopAction.DevState->GetNewDeviceList = TRUE;
    }
}


VOID
PopAllocateDevState(
    VOID
    )
/*++

Routine Description:

    Allocates and initialies the DevState structure.

Arguments:

    None

Return Value:

    PopAction.DevState != NULL if successful.
    PopAction.DevState == NULL otherwise.

--*/

{
    PPOP_DEVICE_SYS_STATE       DevState;
    ULONG i;

    PAGED_CODE();

    ASSERT(PopAction.DevState == NULL);

    //
    // Allocate a device state structure
    //

    DevState = (PPOP_DEVICE_SYS_STATE) ExAllocatePoolWithTag(NonPagedPool,
                                                             sizeof (POP_DEVICE_SYS_STATE),
                                                             POP_PDSS_TAG);
    if (!DevState) {
        PopAction.DevState = NULL;
        return;
    }

    RtlZeroMemory (DevState, sizeof(POP_DEVICE_SYS_STATE));
    DevState->Thread = KeGetCurrentThread();
    DevState->GetNewDeviceList = TRUE;

    KeInitializeSpinLock (&DevState->SpinLock);
    KeInitializeEvent (&DevState->Event, SynchronizationEvent, FALSE);

    DevState->Head.Free.Next = NULL;
    InitializeListHead (&DevState->Head.Pending);
    InitializeListHead (&DevState->Head.Complete);
    InitializeListHead (&DevState->Head.Abort);
    InitializeListHead (&DevState->Head.Failed);
    InitializeListHead (&DevState->PresentIrpQueue);

    for (i=0; i < MAX_SYSTEM_POWER_IRPS; i++) {
        DevState->PowerIrpState[i].Irp = NULL;
        PushEntryList (&DevState->Head.Free,
                       &DevState->PowerIrpState[i].Free);
    }

    for (i=0; i <= PO_ORDER_MAXIMUM; i++) {
        KeInitializeEvent(&DevState->Order.OrderLevel[i].LevelReady,
                          NotificationEvent,
                          FALSE);
        InitializeListHead(&DevState->Order.OrderLevel[i].WaitSleep);
        InitializeListHead(&DevState->Order.OrderLevel[i].ReadySleep);
        InitializeListHead(&DevState->Order.OrderLevel[i].Pending);
        InitializeListHead(&DevState->Order.OrderLevel[i].Complete);
        InitializeListHead(&DevState->Order.OrderLevel[i].ReadyS0);
        InitializeListHead(&DevState->Order.OrderLevel[i].WaitS0);
    }

    PopAction.DevState = DevState;

}

VOID
PopCleanupDevState (
    VOID
    )
/*++

Routine Description:

    Verifies that the DevState structure is idle

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Notify power irp code that the device system state irps
    // are done
    //

    PopSystemIrpDispatchWorker (TRUE);

    //
    // Verify all lists are empty
    //
    ASSERT(IsListEmpty(&PopAction.DevState->Head.Pending)  &&
           IsListEmpty(&PopAction.DevState->Head.Complete) &&
           IsListEmpty(&PopAction.DevState->Head.Abort)    &&
           IsListEmpty(&PopAction.DevState->Head.Failed)   &&
           IsListEmpty(&PopAction.DevState->PresentIrpQueue));

    ExFreePool (PopAction.DevState);
    PopAction.DevState = NULL;
}


#define STATE_DONE_WAITING          0
#define STATE_COMPLETE_IRPS         1
#define STATE_PRESENT_PAGABLE_IRPS  2
#define STATE_CHECK_CANCEL          3
#define STATE_WAIT_NOW              4


VOID
PopWaitForSystemPowerIrp (
    IN PPOP_DEVICE_SYS_STATE    DevState,
    IN BOOLEAN                  WaitForAll
    )
/*++

Routine Description:

    Called to wait for one or more system power irps to complete.  Handles
    final processing of any completed irp.

Arguments:

    DevState    - Current DevState structure

    WaitForAll  - If TRUE all outstanding IRPs are waited for, else any outstanding
                  irp will do

Return Value:

    None

--*/
{
    KIRQL                   OldIrql;
    ULONG                   State;
    BOOLEAN                 IrpCompleted;
    PIRP                    Irp;
    PLIST_ENTRY             Link;
    PPOP_DEVICE_POWER_IRP   PowerIrp;
    PPO_DEVICE_NOTIFY       Notify;
    NTSTATUS                Status;
    LARGE_INTEGER           Timeout;

    IrpCompleted = FALSE;
    KeAcquireSpinLock (&DevState->SpinLock, &OldIrql);

    //
    // Signal completion function that we are waiting
    //

    State = STATE_COMPLETE_IRPS;
    while (State != STATE_DONE_WAITING) {
        switch (State) {
            case STATE_COMPLETE_IRPS:
                //
                // Assume we're going to advance to the next state
                //

                State += 1;

                //
                // If there arn't any irps on the complete list, move to the
                // next state
                //

                if (IsListEmpty(&DevState->Head.Complete)) {
                    break;
                }

                //
                // Handle the completed irps
                //

                IrpCompleted = TRUE;
                while (!IsListEmpty(&DevState->Head.Complete)) {
                    Link = DevState->Head.Complete.Flink;
                    RemoveEntryList(Link);

                    PowerIrp = CONTAINING_RECORD (Link, POP_DEVICE_POWER_IRP, Complete);
                    Notify = PowerIrp->Notify;
                    PowerIrp->Complete.Flink = NULL;
                    Irp = PowerIrp->Irp;

                    //
                    // Verify the device driver called PoStartNextPowerIrp
                    //

                    if ((Notify->TargetDevice->DeviceObjectExtension->PowerFlags & POPF_SYSTEM_ACTIVE) ||
                        (Notify->DeviceObject->DeviceObjectExtension->PowerFlags & POPF_SYSTEM_ACTIVE)) {
                        PDEVICE_OBJECT DeviceObject = Notify->DeviceObject;
                        KeReleaseSpinLock (&DevState->SpinLock, OldIrql);
                        PopDumpSystemIrp  ("SYS STATE", PowerIrp);
                        PopInternalAddToDumpFile ( NULL, 0, DeviceObject, NULL, NULL, NULL );
                        PopInternalAddToDumpFile ( NULL, 0, Notify->TargetDevice, NULL, NULL, NULL );
                        KeBugCheckEx (
                            DRIVER_POWER_STATE_FAILURE,
                            0x500,
                            DEVICE_SYSTEM_STATE_HUNG,
                            (ULONG_PTR) Notify->TargetDevice,
                            (ULONG_PTR) DeviceObject );
                    }

                    //
                    // If success, or cancelled, or not implemented that's OK, then
                    // the irp is complete
                    //

                    if (PopCheckSystemPowerIrpStatus(DevState, Irp, TRUE)) {
                        //
                        // See if IRP is failure being allowed for testing
                        //

                        if (!PopCheckSystemPowerIrpStatus(DevState, Irp, FALSE)) {
                            KeReleaseSpinLock (&DevState->SpinLock, OldIrql);
                            PopDumpSystemIrp  ("ignored", PowerIrp);
                            KeAcquireSpinLock (&DevState->SpinLock, &OldIrql);
                        }

                        //
                        // Request is complete, free it
                        //

                        IoFreeIrp (Irp);

                        PowerIrp->Irp = NULL;
                        PowerIrp->Notify = NULL;
                        PushEntryList (
                            &DevState->Head.Free,
                            &PowerIrp->Free
                            );

                    } else {

                        //
                        // Some sort of error.  Keep track of the failure
                        //

                        ASSERT (!DevState->Waking);
                        InsertTailList(&DevState->Head.Failed, &PowerIrp->Failed);
                    }
                }
                break;

            case STATE_PRESENT_PAGABLE_IRPS:
                //
                // Assume we're going to advance to the next state
                //

                State += 1;

                //
                // If the last device that a system irp was sent to was pagable,
                // we use a thread to present them to the driver so it can page.
                //

                if (!(PopCallSystemState & PO_CALL_NON_PAGED)) {
                    KeReleaseSpinLock (&DevState->SpinLock, OldIrql);
                    PopSystemIrpDispatchWorker (FALSE);
                    KeAcquireSpinLock (&DevState->SpinLock, &OldIrql);
                }

                break;


            case STATE_CHECK_CANCEL:
                //
                // Assume we're going to advance to the next state
                //

                State += 1;

                //
                // If there's no error or we've already canceled move to the state
                //

                if (NT_SUCCESS(DevState->Status)  ||
                    DevState->Cancelled ||
                    DevState->Waking) {

                    break;
                }

                //
                // First time the error has been seen.  Cancel anything outstanding.
                // Build list of all pending irps
                //

                DevState->Cancelled = TRUE;
                for (Link  = DevState->Head.Pending.Flink;
                     Link != &DevState->Head.Pending;
                     Link  = Link->Flink) {

                    PowerIrp = CONTAINING_RECORD (Link, POP_DEVICE_POWER_IRP, Pending);
                    InsertTailList (&DevState->Head.Abort, &PowerIrp->Abort);
                }

                //
                // Drop completion lock and cancel irps on abort list
                //

                KeReleaseSpinLock (&DevState->SpinLock, OldIrql);

                for (Link  = DevState->Head.Abort.Flink;
                     Link != &DevState->Head.Abort;
                     Link  = Link->Flink) {

                    PowerIrp = CONTAINING_RECORD (Link, POP_DEVICE_POWER_IRP, Abort);
                    IoCancelIrp (PowerIrp->Irp);
                }

                KeAcquireSpinLock (&DevState->SpinLock, &OldIrql);
                InitializeListHead (&DevState->Head.Abort);

                //
                // After canceling check for more completed irps
                //

                State = STATE_COMPLETE_IRPS;
                break;

            case STATE_WAIT_NOW:
                //
                // Check for wait condition
                //

                if ((!WaitForAll && IrpCompleted) || IsListEmpty(&DevState->Head.Pending)) {

                    //
                    // Done. After waiting, verify there's at least struct on the
                    // free list. If not, recycle something off the failured list
                    //

                    if (!DevState->Head.Free.Next  &&  !IsListEmpty(&DevState->Head.Failed)) {
                        Link = DevState->Head.Failed.Blink;
                        PowerIrp = CONTAINING_RECORD (Link, POP_DEVICE_POWER_IRP, Failed);

                        RemoveEntryList(Link);
                        PowerIrp->Failed.Flink = NULL;
                        PowerIrp->Irp = NULL;
                        PowerIrp->Notify = NULL;

                        PushEntryList (
                            &DevState->Head.Free,
                            &PowerIrp->Free
                            );
                    }

                    State = STATE_DONE_WAITING;
                    break;
                }

                //
                // Signal completion function that we are waiting
                //

                DevState->WaitAll = TRUE;
                DevState->WaitAny = !WaitForAll;

                //
                // Drop locks and wait for event to be signalled
                //

                KeClearEvent  (&DevState->Event);
                KeReleaseSpinLock (&DevState->SpinLock, OldIrql);

                Timeout.QuadPart = DevState->Cancelled ?
                    POP_ACTION_CANCEL_TIMEOUT : POP_ACTION_TIMEOUT;
                Timeout.QuadPart = Timeout.QuadPart * US2SEC * US2TIME * -1;

                Status = KeWaitForSingleObject (
                            &DevState->Event,
                            Suspended,
                            KernelMode,
                            FALSE,
                            &Timeout
                            );

                KeAcquireSpinLock (&DevState->SpinLock, &OldIrql);

                //
                // No longer waiting
                //

                DevState->WaitAll = FALSE;
                DevState->WaitAny = FALSE;

                //
                // If this is a timeout, then dump all the pending irps
                //

                if (Status == STATUS_TIMEOUT) {

                    for (Link  = DevState->Head.Pending.Flink;
                         Link != &DevState->Head.Pending;
                         Link  = Link->Flink) {

                        PowerIrp = CONTAINING_RECORD (Link, POP_DEVICE_POWER_IRP, Pending);
                        InsertTailList (&DevState->Head.Abort, &PowerIrp->Abort);
                    }

                    KeReleaseSpinLock (&DevState->SpinLock, OldIrql);

                    for (Link  = DevState->Head.Abort.Flink;
                         Link != &DevState->Head.Abort;
                         Link  = Link->Flink) {

                        PowerIrp = CONTAINING_RECORD (Link, POP_DEVICE_POWER_IRP, Abort);
                        PopDumpSystemIrp  ("Waiting on", PowerIrp);
                    }

                    KeAcquireSpinLock (&DevState->SpinLock, &OldIrql);
                    InitializeListHead (&DevState->Head.Abort);
                }

                //
                // Check for completed irps
                //

                State = STATE_COMPLETE_IRPS;
                break;
        }
    }

    KeReleaseSpinLock (&DevState->SpinLock, OldIrql);
}


VOID
PopSleepDeviceList (
    IN PPOP_DEVICE_SYS_STATE    DevState,
    IN PPO_NOTIFY_ORDER_LEVEL   Level
    )
/*++

Routine Description:

    Sends Sx power irps to all devices in the supplied level

Arguments:

    DevState - Supplies the devstate

    Level - Supplies the level to send power irps to

Return Value:

    None. DevState->Status is set on error.

--*/
{
    PPO_DEVICE_NOTIFY       NotifyDevice;
    PLIST_ENTRY             Link;
    KIRQL                   OldIrql;

    ASSERT(!DevState->Waking);
    ASSERT(IsListEmpty(&Level->Pending));
    ASSERT(IsListEmpty(&Level->ReadyS0));
    ASSERT(IsListEmpty(&Level->WaitS0));

    //
    // Move any devices from the completed list back to their correct spots.
    //
    Link = Level->ReadyS0.Flink;
    while (Link != &Level->ReadyS0) {
        NotifyDevice = CONTAINING_RECORD (Link, PO_DEVICE_NOTIFY, Link);
        Link = NotifyDevice->Link.Flink;
        if (NotifyDevice->ChildCount) {
            InsertHeadList(&Level->WaitSleep, Link);
        } else {
            ASSERT(NotifyDevice->ActiveChild == 0);
            InsertHeadList(&Level->ReadySleep, Link);
        }
    }
    while (!IsListEmpty(&Level->Complete)) {
        Link = RemoveHeadList(&Level->Complete);
        NotifyDevice = CONTAINING_RECORD (Link, PO_DEVICE_NOTIFY, Link);
        if (NotifyDevice->ChildCount) {
            InsertHeadList(&Level->WaitSleep, Link);
        } else {
            ASSERT(NotifyDevice->ActiveChild == 0);
            InsertHeadList(&Level->ReadySleep, Link);
        }
    }

    ASSERT(!IsListEmpty(&Level->ReadySleep));
    Level->ActiveCount = Level->DeviceCount;

    KeAcquireSpinLock(&DevState->SpinLock, &OldIrql);

    while ((Level->ActiveCount) &&
           (NT_SUCCESS(DevState->Status))) {

        if (!IsListEmpty(&Level->ReadySleep)) {
            Link = RemoveHeadList(&Level->ReadySleep);
            InsertTailList(&Level->Pending, Link);
            KeReleaseSpinLock(&DevState->SpinLock, OldIrql);
            NotifyDevice = CONTAINING_RECORD (Link, PO_DEVICE_NOTIFY, Link);
            ASSERT(NotifyDevice->ActiveChild == 0);
            PopNotifyDevice(DevState, NotifyDevice);
        } else {

            if ((Level->ActiveCount) &&
                (NT_SUCCESS(DevState->Status))) {

                //
                // No devices are ready to receive IRPs yet, so wait for
                // one of the pending IRPs to complete.
                //
                ASSERT(!IsListEmpty(&Level->Pending));
                KeReleaseSpinLock(&DevState->SpinLock, OldIrql);
                PopWaitForSystemPowerIrp(DevState, FALSE);
            }

        }

        KeAcquireSpinLock(&DevState->SpinLock, &OldIrql);
    }
    KeReleaseSpinLock(&DevState->SpinLock, OldIrql);
}


VOID
PopResetChildCount(
    IN PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Enumerates the notify structures in the supplied list and
    sets their active child count to be equal to the total
    child count.

Arguments:

    ListHead - supplies the list head.

Return Value:

    None

--*/

{
    PPO_DEVICE_NOTIFY       Notify;
    PLIST_ENTRY             Link;

    Link = ListHead->Flink;
    while (Link != ListHead) {
        Notify = CONTAINING_RECORD (Link, PO_DEVICE_NOTIFY, Link);
        Link = Link->Flink;
        Notify->ActiveChild = Notify->ChildCount;
    }


}


VOID
PopSetupListForWake(
    IN PPO_NOTIFY_ORDER_LEVEL Level,
    IN PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Moves all devices that have WakeNeeded=TRUE from the specified
    list to either the ReadyS0 or WaitS0 lists.

Arguments:

    Level - Supplies the level

    ListHead - Supplies the list to be moved.

Return Value:

    None

--*/

{
    PPO_DEVICE_NOTIFY       NotifyDevice;
    PPO_DEVICE_NOTIFY       ParentNotify;
    PLIST_ENTRY             Link;

    Link = ListHead->Flink;
    while (Link != ListHead) {
        NotifyDevice = CONTAINING_RECORD (Link, PO_DEVICE_NOTIFY, Link);
        Link = NotifyDevice->Link.Flink;
        if (NotifyDevice->WakeNeeded) {
            --Level->ActiveCount;
            RemoveEntryList(&NotifyDevice->Link);
            ParentNotify = IoGetPoNotifyParent(NotifyDevice);
            if ((ParentNotify==NULL) ||
                (!ParentNotify->WakeNeeded)) {
                InsertTailList(&Level->ReadyS0, &NotifyDevice->Link);
            } else {
                InsertTailList(&Level->WaitS0, &NotifyDevice->Link);
            }
        }
    }

}


VOID
PopWakeDeviceList(
    IN PPOP_DEVICE_SYS_STATE    DevState,
    IN PPO_NOTIFY_ORDER_LEVEL   Level
    )
/*++

Routine Description:

    Sends S0 power irps to all devices that need waking in the
    given order level.

Arguments:

    DevState - Supplies the device state

    Level - supplies the level to send power irps to

Return Value:

    None. DevState->Status is set on error.

--*/

{
    PPO_DEVICE_NOTIFY       NotifyDevice;
    PLIST_ENTRY             Link;
    KIRQL                   OldIrql;

    ASSERT(DevState->Waking);
    ASSERT(IsListEmpty(&Level->Pending));
    ASSERT(IsListEmpty(&Level->WaitS0));

    Level->ActiveCount = Level->DeviceCount;
    //
    // Run through all the devices and put everything that has
    // WakeNeeded=TRUE onto the wake list.
    //
    PopSetupListForWake(Level, &Level->WaitSleep);
    PopSetupListForWake(Level, &Level->ReadySleep);
    PopSetupListForWake(Level, &Level->Complete);

    ASSERT((Level->DeviceCount == 0) ||
           (Level->ActiveCount == Level->DeviceCount) ||
           !IsListEmpty(&Level->ReadyS0));

    KeAcquireSpinLock(&DevState->SpinLock, &OldIrql);

    while (Level->ActiveCount < Level->DeviceCount) {

        if (!IsListEmpty(&Level->ReadyS0)) {
            Link = RemoveHeadList(&Level->ReadyS0);
            InsertTailList(&Level->Pending,Link);
            KeReleaseSpinLock(&DevState->SpinLock, OldIrql);
            NotifyDevice = CONTAINING_RECORD (Link, PO_DEVICE_NOTIFY, Link);

            //
            // Set the timer to go off if we are not done by the timeout period
            //
            if (PopSimulate & POP_WAKE_DEADMAN) {
                LARGE_INTEGER DueTime;
                DueTime.QuadPart = (LONGLONG)PopWakeTimer * -1 * 1000 * 1000 * 10;
                KeSetTimer(&PopWakeTimeoutTimer, DueTime, &PopWakeTimeoutDpc);
            }
            PopNotifyDevice(DevState, NotifyDevice);
        } else {

            //
            // No devices are ready to receive IRPs yet, so wait for
            // one of the pending IRPs to complete.
            //
            ASSERT(!IsListEmpty(&Level->Pending));
            KeReleaseSpinLock(&DevState->SpinLock, OldIrql);
            PopWaitForSystemPowerIrp(DevState, FALSE);
        }
        KeAcquireSpinLock(&DevState->SpinLock, &OldIrql);
    }
    KeReleaseSpinLock(&DevState->SpinLock, OldIrql);

    ASSERT(Level->ActiveCount == Level->DeviceCount);

}

VOID
PopLogNotifyDevice (
    IN PDEVICE_OBJECT   TargetDevice,
    IN OPTIONAL PPO_DEVICE_NOTIFY Notify,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine logs a Po device notification. It is a seperate
    function so that the local buffer does not eat stack space
    through the PoCallDriver call.

Arguments:

    TargetDevice - Device IRP is being sent to.

    Notify  - If present, supplies the power notify structure for the specified device
              This will only be present on Sx irps, not Dx irps.

    Irp - Pointer to the built Irp for PoCallDriver.

Return Value:

    None.

--*/
{
    UCHAR StackBuffer[256];
    ULONG StackBufferSize;
    PPERFINFO_PO_NOTIFY_DEVICE LogEntry;
    ULONG MaxDeviceNameLength;
    ULONG DeviceNameLength;
    ULONG CopyLength;
    ULONG RemainingSize;
    ULONG LogEntrySize;
    PIO_STACK_LOCATION IrpSp;

    //
    // Initialize locals.
    //

    StackBufferSize = sizeof(StackBuffer);
    LogEntry = (PVOID) StackBuffer;
    IrpSp = IoGetNextIrpStackLocation(Irp);

    //
    // Stack buffer should be large enough to contain at least the fixed
    // part of the LogEntry structure.
    //

    if (StackBufferSize < sizeof(PERFINFO_PO_NOTIFY_DEVICE)) {
        ASSERT(FALSE);
        return;
    }

    //
    // Fill in the LogEntry fields.
    //

    LogEntry->Irp = Irp;
    LogEntry->DriverStart = TargetDevice->DriverObject->DriverStart;
    LogEntry->MajorFunction = IrpSp->MajorFunction;
    LogEntry->MinorFunction = IrpSp->MinorFunction;
    LogEntry->Type          = IrpSp->Parameters.Power.Type;
    LogEntry->State         = IrpSp->Parameters.Power.State;

    if (Notify) {
        LogEntry->OrderLevel = Notify->OrderLevel;
        if (Notify->DeviceName) {

            //
            // Determine what the maximum device name length (excluding NUL) we
            // can fit into our stack buffer. Note that PERFINFO_NOTIFY_DEVICE
            // has space for the terminating NUL character.
            //

            RemainingSize = StackBufferSize - sizeof(PERFINFO_PO_NOTIFY_DEVICE);
            MaxDeviceNameLength = RemainingSize / sizeof(WCHAR);

            //
            // Determine the length of the device name and adjust the copy length.
            //

            DeviceNameLength = (ULONG) wcslen(Notify->DeviceName);
            CopyLength = DeviceNameLength;

            if (CopyLength > MaxDeviceNameLength) {
                CopyLength = MaxDeviceNameLength;
            }

            //
            // Copy CopyLength characters from the end of the DeviceName.
            // This way if our buffer is not enough, we get a more distinct part
            // of the name.
            //

            wcscpy(LogEntry->DeviceName,
                   Notify->DeviceName + DeviceNameLength - CopyLength);

        } else {

            //
            // There is no device name.
            //

            CopyLength = 0;
            LogEntry->DeviceName[CopyLength] = 0;
        }
    } else {
        LogEntry->OrderLevel = 0;
        CopyLength = 0;
        LogEntry->DeviceName[CopyLength] = 0;
    }

    //
    // Copied device name should be terminated: we had enough room for it.
    //

    ASSERT(LogEntry->DeviceName[CopyLength] == 0);

    //
    // Log the entry.
    //

    LogEntrySize = sizeof(PERFINFO_PO_NOTIFY_DEVICE);
    LogEntrySize += CopyLength * sizeof(WCHAR);

    PerfInfoLogBytes(PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE,
                     LogEntry,
                     LogEntrySize);

    //
    // We are done.
    //

    return;
}

VOID
PopNotifyDevice (
    IN PPOP_DEVICE_SYS_STATE    DevState,
    IN PPO_DEVICE_NOTIFY        Notify
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PPOP_DEVICE_POWER_IRP   PowerIrp;
    PSINGLE_LIST_ENTRY      Entry;
    PIO_STACK_LOCATION      IrpSp;
    PIRP                    Irp;
    ULONG                   SysCall;
    KIRQL                   OldIrql;
    PDEVICE_OBJECT          *WarmEjectDevice;
    POWER_ACTION            IrpAction;

    //
    // Set the SysCall state to match our notify current state
    //

    ASSERT(PopCurrentLevel == Notify->OrderLevel);
    SysCall = PO_CALL_SYSDEV_QUEUE;
    if (!(Notify->OrderLevel & PO_ORDER_PAGABLE)) {
        SysCall |= PO_CALL_NON_PAGED;
    }

    if (PopCallSystemState != SysCall) {
        PopLockWorkerQueue(&OldIrql);
        PopCallSystemState = SysCall;
        PopUnlockWorkerQueue(OldIrql);
    }

    //
    // Allocate an PowerIrp & Irp structures
    //

    PowerIrp = NULL;
    Irp = NULL;

    for (; ;) {
        Entry = PopEntryList(&DevState->Head.Free);
        if (Entry) {
            break;
        }

        PopWaitForSystemPowerIrp (DevState, FALSE);
    }

    PowerIrp = CONTAINING_RECORD(Entry, POP_DEVICE_POWER_IRP, Free);

    for (; ;) {
        Irp = IoAllocateIrp ((CHAR) Notify->TargetDevice->StackSize, FALSE);
        if (Irp) {
            break;
        }

        PopWaitForSystemPowerIrp (DevState, FALSE);
    }

    SPECIALIRP_WATERMARK_IRP(Irp, IRP_SYSTEM_RESTRICTED);

    if (!DevState->Waking) {

        //
        // If the device node list changed, then restart. This could have
        // happened when we dropped our list and then rebuilt it inbetween
        // queries for sleep states.
        //

        if (DevState->Order.DevNodeSequence != IoDeviceNodeTreeSequence) {

            PopRestartSetSystemState();
        }

        //
        // If there's been some sort of error, then abort
        //

        if (!NT_SUCCESS(DevState->Status)) {
            PushEntryList (&DevState->Head.Free, &PowerIrp->Free);
            IoFreeIrp (Irp);
            return ;            // abort
        }

        //
        // Mark notify as needing wake.
        //
        Notify->WakeNeeded = TRUE;
    } else {
        Notify->WakeNeeded = FALSE;
    }

    //
    // Put irp onto pending queue
    //

    PowerIrp->Irp = Irp;
    PowerIrp->Notify = Notify;

    ExInterlockedInsertTailList (
        &DevState->Head.Pending,
        &PowerIrp->Pending,
        &DevState->SpinLock
        );

    //
    // Setup irp
    //

    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    Irp->IoStatus.Information = 0;
    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = IRP_MJ_POWER;
    IrpSp->MinorFunction = DevState->IrpMinor;
    IrpSp->Parameters.Power.SystemContext = 0;
    IrpSp->Parameters.Power.Type = SystemPowerState;
    IrpSp->Parameters.Power.State.SystemState = DevState->SystemState;

    ASSERT(PopAction.Action != PowerActionHibernate);

    WarmEjectDevice = DevState->Order.WarmEjectPdoPointer;

    //
    // We need to determine the appropriate power action to place in our IRP.
    // For instance, we send PowerActionWarmEject to the devnode being warm
    // ejected, and we convert our internal PowerActionSleep to
    // PowerActionHibernate if the sleep state is S4.
    //

    IrpAction = PopMapInternalActionToIrpAction (
        PopAction.Action,
        DevState->SystemState,
        (BOOLEAN) (DevState->Waking || (*WarmEjectDevice != Notify->DeviceObject))
        );

    //
    // If we are sending a set power to the devnode to be warm ejected,
    // zero out the warm eject device field to signify we have handled to
    // requested operation.
    //
    if ((IrpAction == PowerActionWarmEject) &&
        (*WarmEjectDevice == Notify->DeviceObject) &&
        (DevState->IrpMinor == IRP_MN_SET_POWER)) {

        *WarmEjectDevice = NULL;
    }

    IrpSp->Parameters.Power.ShutdownType = IrpAction;

    IoSetCompletionRoutine (Irp, PopCompleteSystemPowerIrp, PowerIrp, TRUE, TRUE, TRUE);

    //
    // Log the call.
    //

    if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
        PopLogNotifyDevice(Notify->TargetDevice, Notify, Irp);
    }

    //
    // Give it to the driver, and continue
    //

    PoCallDriver (Notify->TargetDevice, Irp);
}

NTSTATUS
PopCompleteSystemPowerIrp (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )
/*++

Routine Description:

    IRP completion routine for system power irps.  Takes the irp from the
    DevState pending queue and puts it on the DevState complete queue.

Arguments:

    DeviceObect - The device object

    Irp         - The IRP

    Context     - Device power irp structure for this request

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PPOP_DEVICE_POWER_IRP   PowerIrp;
    PPOP_DEVICE_SYS_STATE   DevState;
    KIRQL                   OldIrql;
    BOOLEAN                 SetEvent;
    PPO_DEVICE_NOTIFY       Notify;
    PPO_DEVICE_NOTIFY       ParentNotify;
    PPO_NOTIFY_ORDER_LEVEL  Order;

    UNREFERENCED_PARAMETER (DeviceObject);

    PowerIrp = (PPOP_DEVICE_POWER_IRP) Context;
    DevState = PopAction.DevState;

    SetEvent = FALSE;

    //
    // Log the completion.
    //

    if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
        PERFINFO_PO_NOTIFY_DEVICE_COMPLETE LogEntry;
        LogEntry.Irp = Irp;
        LogEntry.Status = Irp->IoStatus.Status;
        PerfInfoLogBytes(PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE_COMPLETE,
                         &LogEntry,
                         sizeof(LogEntry));
    }

    KeAcquireSpinLock (&DevState->SpinLock, &OldIrql);

    //
    // Move irp from pending queue to complete queue
    //

    RemoveEntryList (&PowerIrp->Pending);
    PowerIrp->Pending.Flink = NULL;
    InsertTailList (&DevState->Head.Complete, &PowerIrp->Complete);

    //
    // Move notify from pending queue to the appropriate queue
    // depending on whether we are sleeping or waking.
    //
    Notify=PowerIrp->Notify;
    ASSERT(Notify->OrderLevel == PopCurrentLevel);
    Order = &DevState->Order.OrderLevel[Notify->OrderLevel];
    RemoveEntryList(&Notify->Link);
    InsertTailList(&Order->Complete, &Notify->Link);
    if (DevState->Waking) {
        ++Order->ActiveCount;
        IoMovePoNotifyChildren(Notify, &DevState->Order);
    } else {

        //
        // We will only decrement the parent's active count if the IRP was
        // completed successfully. Otherwise it is possible for a parent to
        // get put on the ReadySleep list even though its child has failed
        // the query/set irp.
        //
        if (NT_SUCCESS(Irp->IoStatus.Status) || DevState->IgnoreErrors) {
            --Order->ActiveCount;
            ParentNotify = IoGetPoNotifyParent(Notify);
            if (ParentNotify) {
                ASSERT(ParentNotify->ActiveChild > 0);
                if (--ParentNotify->ActiveChild == 0) {
                    RemoveEntryList(&ParentNotify->Link);
                    InsertTailList(&DevState->Order.OrderLevel[ParentNotify->OrderLevel].ReadySleep,
                               &ParentNotify->Link);
                }
            }
        }
    }

    //
    // If there is a wait any, then kick event
    // If there is a wait all, then check for empty pending queue
    //

    if ((DevState->WaitAny) ||
        (DevState->WaitAll && IsListEmpty(&DevState->Head.Pending))) {
        SetEvent = TRUE;
    }

    //
    // If the IRP is in error and it's the first such IRP start aborting
    // the current operation
    //

    if (!PopCheckSystemPowerIrpStatus(DevState, Irp, TRUE)  &&
        NT_SUCCESS(DevState->Status)) {

        //
        // We need to set the failed device here. If we are warm ejecting
        // however, the warm eject devnode will *legitimately* fail any queries
        // for S states it doesn't support. As we will be trying several Sx
        // states, the trick is to preserve any failed device that is *not*
        // warm eject devnode, and update failed device to the warm eject
        // devnode only if failed device is currently NULL.
        //

        if ((PopAction.Action != PowerActionWarmEject) ||
            (DevState->FailedDevice == NULL) ||
            (PowerIrp->Notify->DeviceObject != *DevState->Order.WarmEjectPdoPointer)) {

            DevState->FailedDevice = PowerIrp->Notify->DeviceObject;
        }

        DevState->Status = Irp->IoStatus.Status;
        SetEvent = TRUE;        // wake to cancel pending irps
    }

    KeReleaseSpinLock (&DevState->SpinLock, OldIrql);

    if (SetEvent) {
        KeSetEvent (&DevState->Event, IO_NO_INCREMENT, FALSE);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}



BOOLEAN
PopCheckSystemPowerIrpStatus  (
    IN PPOP_DEVICE_SYS_STATE    DevState,
    IN PIRP                     Irp,
    IN BOOLEAN                  AllowTestFailure
    )
// return FALSE if irp is some sort of unallowed error
{
    NTSTATUS    Status;


    Status = Irp->IoStatus.Status;

    //
    // If Status is sucess, then no problem
    //

    if (NT_SUCCESS(Status)) {
        return TRUE;
    }

    //
    // If errors are allowed, or it's a cancelled request no problem
    //

    if (DevState->IgnoreErrors || Status == STATUS_CANCELLED) {
        return TRUE;
    }

    //
    // Check to see if the error is that the driver doesn't implement the
    // request and if such a condition is allowed
    //

    if (Status == STATUS_NOT_SUPPORTED && DevState->IgnoreNotImplemented) {
        return TRUE;
    }

    //
    // For testing purposes, optionally let through unsupported device drivers
    //

    if (Status == STATUS_NOT_SUPPORTED &&
        AllowTestFailure &&
        (PopSimulate & POP_IGNORE_UNSUPPORTED_DRIVERS)) {

        return TRUE;
    }

    //
    // Some unexpected failure, treat it as an error
    //

    return FALSE;
}


VOID
PopRestartSetSystemState (
    VOID
    )
/*++

Routine Description:

    Aborts current system power state operation.

Arguments:

    None

Return Value:

    None

--*/
{
    KIRQL       OldIrql;

    KeAcquireSpinLock (&PopAction.DevState->SpinLock, &OldIrql);
    if (!PopAction.Shutdown  &&  NT_SUCCESS(PopAction.DevState->Status)) {
        PopAction.DevState->Status = STATUS_CANCELLED;
    }
    KeReleaseSpinLock (&PopAction.DevState->SpinLock, OldIrql);
    KeSetEvent (&PopAction.DevState->Event, IO_NO_INCREMENT, FALSE);
}


VOID
PopDumpSystemIrp (
    IN PCHAR                    Desc,
    IN PPOP_DEVICE_POWER_IRP    PowerIrp
    )
{
    PCHAR               IrpType;
    PPO_DEVICE_NOTIFY   Notify;

    Notify = PowerIrp->Notify;

    //
    // Dump errors to debugger
    //

    switch (PopAction.DevState->IrpMinor) {
        case IRP_MN_QUERY_POWER:    IrpType = "QueryPower";     break;
        case IRP_MN_SET_POWER:      IrpType = "SetPower";       break;
        default:                    IrpType = "?";              break;
    }

    DbgPrint ("%s: ", Desc);

    if (Notify->DriverName) {
        DbgPrint ("%ws ", Notify->DriverName);
    } else {
        DbgPrint ("%x ", Notify->TargetDevice->DriverObject);
    }

    if (Notify->DeviceName) {
        DbgPrint ("%ws ", Notify->DeviceName);
    } else {
        DbgPrint ("%x ", Notify->TargetDevice);
    }

    DbgPrint ("irp (%x) %s-%s status %x\n",
        PowerIrp->Irp,
        IrpType,
        PopSystemStateString(PopAction.DevState->SystemState),
        PowerIrp->Irp->IoStatus.Status
        );
}


VOID
PopWakeSystemTimeout(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is used to break into the kernel debugger if somebody is
    taking too long processing their S irps.

Arguments:

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    try {
        DbgBreakPoint();
    } except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\sys.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sys.c

Abstract:

    This module interfaces to the system power state handler functions

Author:

    Ken Reneris (kenr) 17-Jan-1997

Revision History:

--*/


#include "pop.h"
#include <inbv.h>
#include <stdio.h>

#if defined(i386) || defined(_AMD64_)

VOID
KeRestoreProcessorSpecificFeatures(
    VOID
    );

#endif

#if defined(i386)
VOID
KePrepareToLoseProcessorSpecificState(
    VOID
    );

__inline
LONGLONG
POP_GET_TICK_COUNT(
    VOID
    )
{
    _asm _emit 0x0f
    _asm _emit 0x31
}
#endif

//
// Internal shared context structure used to coordinate
// invoking a power state handler
//

typedef struct {
    PPOWER_STATE_HANDLER        Handler;
    PENTER_STATE_SYSTEM_HANDLER SystemHandler;
    PVOID                       SystemContext;
    PPOP_HIBER_CONTEXT          HiberContext;
    PPOWER_STATE_NOTIFY_HANDLER NotifyHandler;
    POWER_STATE_HANDLER_TYPE    NotifyState;
    BOOLEAN                     NotifyType;
    LONG                        NumberProcessors;
    volatile LONG               TargetCount;
    volatile ULONG              State;
    LONG                        HandlerBarrier;
} POP_SYS_CONTEXT, *PPOP_SYS_CONTEXT;

typedef struct {
    ULONG                       LastState;
    BOOLEAN                     InterruptEnable;
    KIRQL                       Irql;
    BOOLEAN                     FloatSaved;
    KFLOATING_SAVE              FloatSave;
    NTSTATUS                    Status;
} POP_LOCAL_CONTEXT, *PPOP_LOCAL_CONTEXT;


#define POP_SH_UNINITIALIZED                0
#define POP_SH_COLLECTING_PROCESSORS        1
#define POP_SH_SAVE_CONTEXT                 2
#define POP_SH_GET_STACKS                   3
#define POP_SH_DISABLE_INTERRUPTS           4
#define POP_SH_INVOKE_HANDLER               5
#define POP_SH_INVOKE_NOTIFY_HANDLER        6
#define POP_SH_RESTORE_INTERRUPTS           7
#define POP_SH_RESTORE_CONTEXT              8
#define POP_SH_COMPLETE                     9

extern ULONG    MmAvailablePages;
BOOLEAN         PopFailedHibernationAttempt = FALSE;  // we tried to hibernate and failed.
WCHAR           PopHibernationErrorSubtstitionString[128];

//
// Internal prototypes
//

NTSTATUS
PopInvokeSystemStateHandler (
    IN POWER_STATE_HANDLER_TYPE Type,
    IN PVOID Memory
    );

VOID
PopIssueNextState (
    IN PPOP_SYS_CONTEXT     Context,
    IN PPOP_LOCAL_CONTEXT   LocalContext,
    IN ULONG                NextState
    );

VOID
PopHandleNextState (
    IN PPOP_SYS_CONTEXT     Context,
    IN PPOP_LOCAL_CONTEXT   LocalContext
    );

VOID
PopInvokeStateHandlerTargetProcessor (
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    );

NTSTATUS
PopShutdownHandler (
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, PopShutdownSystem)
#pragma alloc_text(PAGELK, PopSleepSystem)
#pragma alloc_text(PAGELK, PopInvokeSystemStateHandler)
#pragma alloc_text(PAGELK, PopInvokeStateHandlerTargetProcessor)
#pragma alloc_text(PAGELK, PopIssueNextState)
#pragma alloc_text(PAGELK, PopHandleNextState)
#pragma alloc_text(PAGELK, PopShutdownHandler)
#endif


VOID
PopShutdownSystem (
    IN POWER_ACTION SystemAction
    )
/*++

Routine Description:

    Routine to implement a Shutdown style power actions

Arguments:

    SystemAction    - Action to implement (must be a valid shutdown type)

Return Value:

    Status

--*/
{

    //
    // Tell the debugger we are shutting down
    //

    KD_SYMBOLS_INFO SymbolInfo = {0};
    SymbolInfo.BaseOfDll = (PVOID)KD_REBOOT;
    DebugService2(NULL, &SymbolInfo, BREAKPOINT_UNLOAD_SYMBOLS);

    //
    // Perform the final shutdown operation
    //

    switch (SystemAction) {
        case PowerActionShutdownReset:

            //
            // Reset the system
            //

            PopInvokeSystemStateHandler (PowerStateShutdownReset, NULL);

            //
            // Didn't do it, go for legacy function
            //

            HalReturnToFirmware (HalRebootRoutine);
            break;

        case PowerActionShutdownOff:
        case PowerActionShutdown:

            //
            // Power down the system
            //

            PopInvokeSystemStateHandler (PowerStateShutdownOff, NULL);

            //
            // Didn't do it, go for legacy function
            //

            HalReturnToFirmware (HalPowerDownRoutine);

            //
            // Due to simulations we can try to power down on systems
            // which don't support it
            //

            PoPrint (PO_ERROR, ("PopShutdownSystem: HalPowerDownRoutine returned\n"));
            HalReturnToFirmware (HalRebootRoutine);
            break;
    
        default:
            //
            // Got some unexpected input...
            ASSERT(0);
            HalReturnToFirmware (HalRebootRoutine);
    
    }

    KeBugCheckEx (INTERNAL_POWER_ERROR, 5, 0, 0, 0);
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)           // Not all control paths return (due to infinite loop at end)
#endif

NTSTATUS
PopShutdownHandler (
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    )
{
    PKPRCB      Prcb;

    UNREFERENCED_PARAMETER (Context);
    UNREFERENCED_PARAMETER (SystemHandler);
    UNREFERENCED_PARAMETER (SystemContext);
    UNREFERENCED_PARAMETER (NumberProcessors);
    UNREFERENCED_PARAMETER (Number);

    KeDisableInterrupts();
    Prcb = KeGetCurrentPrcb();

    //
    // On processor 0 put up the shutdown screen
    //

    if (Prcb->Number == 0) {

        if (InbvIsBootDriverInstalled()) {

            PUCHAR Bitmap1, Bitmap2;

            if (!InbvCheckDisplayOwnership()) {
                InbvAcquireDisplayOwnership();
            }

            InbvResetDisplay();
            InbvSolidColorFill(0,0,639,479,0);
            InbvEnableDisplayString(TRUE);     // enable display string
            InbvSetScrollRegion(0,0,639,475);  // set to use entire screen

            Bitmap1 = InbvGetResourceAddress(3);
            Bitmap2 = InbvGetResourceAddress(5);

            if (Bitmap1 && Bitmap2) {
                InbvBitBlt(Bitmap1, 215, 282);
                InbvBitBlt(Bitmap2, 217, 111);
            }

        } else {

            ULONG i;

            //
            // Skip to middle of the display
            //

            for (i=0; i<25; i++) {
                InbvDisplayString ((PUCHAR)"\n");
            }

            InbvDisplayString ((PUCHAR)"                       ");  // 23 spaces
            InbvDisplayString ((PUCHAR)"The system may be powered off now.\n");
        }
    }

    //
    // Halt
    //

    for (; ;) {
        HalHaltSystem ();
    }
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


NTSTATUS
PopSleepSystem (
    IN SYSTEM_POWER_STATE   SystemState,
    IN PVOID Memory
    )
/*++

Routine Description:

    Routine to implement a Sleep style system power actions.

    N.B. All devices must already be in a compatible sleeping state.

Arguments:

    SystemState - System state to implement (must be a valid sleep type)

Return Value:

    Status

--*/
{
    POWER_STATE_HANDLER_TYPE    Type;
    NTSTATUS                    Status = STATUS_SUCCESS;


    switch (SystemState) {
        case PowerSystemSleeping1:  Type = PowerStateSleeping1;     break;
        case PowerSystemSleeping2:  Type = PowerStateSleeping2;     break;
        case PowerSystemSleeping3:  Type = PowerStateSleeping3;     break;
        case PowerSystemHibernate:  Type = PowerStateSleeping4;     break;

        default:
            PoAssert(PO_ERROR,FALSE && ("PopSleepSystem: Bad SYSTEM_POWER_STATE requested."));
            return STATUS_INVALID_PARAMETER;
    }

    Status =  PopInvokeSystemStateHandler (Type, Memory);

    if( !NT_SUCCESS(Status) && (SystemState == PowerSystemHibernate) ) {
        UNICODE_STRING  UnicodeString;

        _snwprintf( PopHibernationErrorSubtstitionString, sizeof(PopHibernationErrorSubtstitionString)/sizeof(WCHAR), L"0x%x", Status );
        RtlInitUnicodeString( &UnicodeString, PopHibernationErrorSubtstitionString );

        //
        // Tell someone.
        // We'll send in a friendly error code instead of the 
        // cryptic one we got back from PopInvokeSystemStateHandler()
        //

        IoRaiseInformationalHardError( STATUS_HIBERNATION_FAILURE, &UnicodeString, NULL );
        
        // Remember that we failed so we don't try again.
        PopFailedHibernationAttempt = TRUE;
    }

    return Status;
}


NTSTATUS
PopInvokeSystemStateHandler (
    IN POWER_STATE_HANDLER_TYPE Type,
    IN PPOP_HIBER_CONTEXT HiberContext
    )
/*++

Routine Description:

    Invokes a power state handler on every processor concurrently.

Arguments:

    Type        - Index to the handle to invoke

Return Value:

    Status

--*/
{
    KDPC                Dpc;
    KIRQL               OldIrql;
    KAFFINITY           Targets;
    ULONG               Processor;
    LONG                TargetCount;
    POP_SYS_CONTEXT     Context;
    POP_LOCAL_CONTEXT   LocalContext;
    POWER_STATE_HANDLER ShutdownHandler;
    KAFFINITY           ActiveProcessors;
    ULONG               result;

    //
    // No spinlocks can be held when this call is made
    //

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Get system state handler
    //

    RtlZeroMemory (&Context, sizeof(Context));
    RtlZeroMemory (&ShutdownHandler, sizeof(ShutdownHandler));
    Context.Handler = &ShutdownHandler;

    Context.NotifyHandler = &PopPowerStateNotifyHandler;
    Context.NotifyState = Type;

    if (Type != PowerStateMaximum) {
        Context.Handler = &PopPowerStateHandlers[Type];

        if (!Context.Handler->Handler) {
            return STATUS_DEVICE_DOES_NOT_EXIST;
        }
    }

    Context.NumberProcessors = (ULONG) KeNumberProcessors;
    Context.HandlerBarrier = KeNumberProcessors;
    Context.State = POP_SH_COLLECTING_PROCESSORS;
    Context.HiberContext = HiberContext;
    if (HiberContext) {
        Context.SystemContext = HiberContext;
        Context.SystemHandler = PopSaveHiberContext;
    }

    RtlZeroMemory (&LocalContext, sizeof(LocalContext));

    //
    // Before we freeze the machine, attempt to collect up as much memory
    // as we can from MM to avoid saving it into the hibernation file.
    //

    if (HiberContext && HiberContext->ReserveFreeMemory) {
        for (; ;) {

            if (MmAvailablePages < POP_FREE_THRESHOLD) {
                break;
            }

            //
            // Collect the pages
            //
            result = PopGatherMemoryForHibernate (HiberContext,
                                                  POP_FREE_ALLOCATE_SIZE,
                                                  &HiberContext->Spares,
                                                  FALSE);

            if (!result) {
                break;
            }
        }
    }

    //
    // Switch to boot processor and raise to DISPATCH_LEVEL level to
    // avoid getting any DPCs
    //

    KeSetSystemAffinityThread (1);
    KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);
    KeInitializeDpc (&Dpc, PopInvokeStateHandlerTargetProcessor, &Context);
    KeSetImportanceDpc (&Dpc, HighImportance);

    //
    // Collect and halt the other processors
    //

    Targets = KeActiveProcessors & (~1);

    while (Targets) {
        KeFindFirstSetLeftAffinity(Targets, &Processor);
        ClearMember (Processor, Targets);

        //
        // Prepare to wait
        //

        TargetCount = Context.TargetCount;

        //
        // Issue DPC to target processor
        //

        KeSetTargetProcessorDpc (&Dpc, (CCHAR) Processor);
        KeInsertQueueDpc (&Dpc, NULL, NULL);

        //
        // Wait for DPC to be processed
        //
        while (TargetCount == Context.TargetCount) ;
    }

    //
    // All processors halted and spinning at dispatch level
    //

    PopIssueNextState (&Context, &LocalContext, POP_SH_SAVE_CONTEXT);

#if defined(i386)

    //
    // Fast system call must be disabled until the context required
    // to support it is restored.
    //

    KePrepareToLoseProcessorSpecificState();

#endif

    //
    // Enter system state
    //

    if (HiberContext) {

        //
        // Get each processors stacks in the memory map for
        // special handling during hibernate
        //

        PopIssueNextState (&Context, &LocalContext, POP_SH_GET_STACKS);

        //
        // Build the rest of the map, and structures needed
        // to write the file
        //

        LocalContext.Status = PopBuildMemoryImageHeader (HiberContext, Type);

#ifdef HIBERNATE_PRESERVE_BPS
        //
        // Disable the kernel debugger breakpoints. We will reenable them after
        // resume. We do this here because this could in theory require an IPI.
        //

        KdDisableDebugger();
#endif //HIBERNATE_PRESERVE_BPS

        //
        // Disable interrupts on all processors
        //

        PopIssueNextState (&Context, &LocalContext, POP_SH_DISABLE_INTERRUPTS);

        //
        // With interrupts disabled on all the processors, the debugger
        // really can't work the way its supposed to.  It can't IPI the
        // other processors to get them to stop.  So we temporarily
        // change the kernel's notion of active processors, making it
        // think that the this processor is the only one it has to worry
        // about.
        //

        ActiveProcessors = KeActiveProcessors;
        KeActiveProcessors = 1;

        if (NT_SUCCESS(LocalContext.Status)) {

            //
            // Notify the Notify Handler of pending sleep
            //

            Context.NotifyType = TRUE; // notify before
            PopIssueNextState (&Context, &LocalContext, POP_SH_INVOKE_NOTIFY_HANDLER);


            //
            // Invoke the Power State handler
            //

            PopIssueNextState (&Context, &LocalContext, POP_SH_INVOKE_HANDLER);


            //
            // If the sleep was successful, clear the fully awake flag
            //

            if (NT_SUCCESS(LocalContext.Status)) {
                InterlockedExchange(&PopFullWake, PO_GDI_ON_PENDING);
                PoPowerSequence = PoPowerSequence + 1;
                PopSIdle.Time = 1;
            }


            //
            // Notify the Notify Handler of resume
            //

            Context.NotifyType = FALSE; // notify after
            PopIssueNextState (&Context, &LocalContext, POP_SH_INVOKE_NOTIFY_HANDLER);

        }

        //
        // Hiber is over, call while the machine still stopped to allow
        // memory verification, etc..
        //

        PopHiberComplete (LocalContext.Status, HiberContext);

        //
        // If there's a request for a reset here, do it
        //

        if (HiberContext->Reset) {
            Context.Handler = &PopPowerStateHandlers[PowerStateShutdownReset];
            Context.HiberContext = NULL;
            if (Context.Handler->Handler) {
                PopIssueNextState (&Context, &LocalContext, POP_SH_INVOKE_HANDLER);
            }
            HalReturnToFirmware (HalRebootRoutine);
        }

        //
        // If we are past this point, then we are guaranteed to have awakened
        // from Hibernation (or something went severely wrong).
        //
        // Our Hibercontext is no longer needed (in fact, we will free it soon).
        //
        // Thus we set its status value to indicate that this is a wake up.
        // This status value is used later on when the context is being freed
        //  in order to clear things no longer needed after the system awakens properly.
        //

        PERFINFO_HIBER_REINIT_TRACE();

        HiberContext->Status = STATUS_WAKE_SYSTEM;

        //
        // Now restore the kernel's previous notion of active processors
        // before we enable interrupts on the others.
        //

        KeActiveProcessors = ActiveProcessors;

        //
        // Restore interrupts on all processors
        //

        PopIssueNextState (&Context, &LocalContext, POP_SH_RESTORE_INTERRUPTS);

#ifdef HIBERNATE_PRESERVE_BPS
        //
        // Reenable the kernel debugger breakpoints. This will reset the
        // debugger if neccessary.
        //

        KdEnableDebugger();
#endif //HIBERNATE_PRESERVE_BPS

        //
        // We are returning from hibernate, and we need to tell the system
        // that win32k now owns the display again.
        //

        InbvSetDisplayOwnership(FALSE);

    } else {

        //
        // Notify the Notify Handler of pending sleep
        //

        Context.NotifyType = TRUE; // notify before
        PopIssueNextState (&Context, &LocalContext, POP_SH_INVOKE_NOTIFY_HANDLER);


        //
        // Invoke the sleep handle
        //
        if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
            PERFINFO_PO_PRESLEEP LogEntry;
#if defined(i386)
            if (PopAction.SystemState == PowerSystemSleeping3) {
                LogEntry.PerformanceFrequency.QuadPart = (ULONGLONG)KeGetCurrentPrcb()->MHz * 1000000;
                LogEntry.PerformanceCounter.QuadPart = 0;
            } else {
                LogEntry.PerformanceCounter = KeQueryPerformanceCounter(&LogEntry.PerformanceFrequency);
            }
#else
            LogEntry.PerformanceCounter = KeQueryPerformanceCounter(&LogEntry.PerformanceFrequency);
#endif

            PerfInfoLogBytes(PERFINFO_LOG_TYPE_PO_PRESLEEP,
                             &LogEntry,
                             sizeof(LogEntry));
        }
        PopIssueNextState (&Context, &LocalContext, POP_SH_INVOKE_HANDLER);
        if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
            PERFINFO_PO_POSTSLEEP LogEntry;
#if defined(i386)
            if (PopAction.SystemState == PowerSystemSleeping3) {
                LogEntry.PerformanceCounter.QuadPart = POP_GET_TICK_COUNT();
            } else {
                LogEntry.PerformanceCounter = KeQueryPerformanceCounter(NULL);
            }
#else
            LogEntry.PerformanceCounter = KeQueryPerformanceCounter(NULL);
#endif

            PerfInfoLogBytes(PERFINFO_LOG_TYPE_PO_POSTSLEEP,
                             &LogEntry,
                             sizeof(LogEntry));
        }

        //
        // If the sleep was successful, clear the fully awake flag
        //

        if (NT_SUCCESS(LocalContext.Status)) {

            //
            // If somebody has set display required, then turn the
            // display back on. Otherwise leave it off until there
            // is some user activity signalled.
            //

            if (PopAttributes[POP_DISPLAY_ATTRIBUTE].Count > 0) {
                InterlockedExchange(&PopFullWake, PO_GDI_ON_PENDING);
            } else {
                InterlockedExchange(&PopFullWake, 0);
            }
            PoPowerSequence = PoPowerSequence + 1;
            PopSIdle.Time = 1;
        }


        //
        // Notify the Notify Handler of resume
        //

        Context.NotifyType = FALSE; // notify after
        PopIssueNextState (&Context, &LocalContext, POP_SH_INVOKE_NOTIFY_HANDLER);

    }

    //
    // Restore other saved state on each processor
    //

    PopIssueNextState (&Context, &LocalContext, POP_SH_RESTORE_CONTEXT);

#if defined(i386)
    //
    // On x86, reload any processor specific data structures (MSRs).
    //

    if (NT_SUCCESS(LocalContext.Status)) {
        KeRestoreProcessorSpecificFeatures();
    }
#endif

    //
    // Let the other processor return
    //

    PopIssueNextState (&Context, &LocalContext, POP_SH_COMPLETE);

    //
    // Now that all processors have returned,
    // put all the available memory back into the system. We don't do
    // this earlier because on systems with large amounts of memory it
    // can take significant time to free it all and this triggers the
    // DPC timeouts.
    //

    if (HiberContext) {
        PopFreeHiberContext (FALSE);
    }

    //
    // If success, return status_success and count the number of
    // times the sleep state has worked
    //

    if (NT_SUCCESS(LocalContext.Status)) {
        LocalContext.Status = STATUS_SUCCESS;
        if (Context.Handler->Spare[0] != 0xff) {
            Context.Handler->Spare[0] += 1;
        }
    }

    //
    // Done
    //

    KeLowerIrql (OldIrql);
    return LocalContext.Status;
}

VOID
PopIssueNextState (
    IN PPOP_SYS_CONTEXT     Context,
    IN PPOP_LOCAL_CONTEXT   LocalContext,
    IN ULONG                NextState
    )
/*++

Routine Description:

    Called by the invoking processor to instruct all processors
    to the next state in the sequence needed to invoke/enter the
    target power handler.

Arguments:

    Context     - Shared context structure used to communicate the
                  state transitions

    NextState   - New target state to enter

Return Value:

    None

--*/
{
    //
    // Reset count for this operation
    //

    InterlockedExchange ((PVOID) &Context->TargetCount, 0);

    //
    // Issue new state
    //

    InterlockedExchange ((PVOID) &Context->State, NextState);

    //
    // Handle it ourselves
    //

    LocalContext->LastState = POP_SH_UNINITIALIZED;
    PopHandleNextState (Context, LocalContext);

    //
    // Wait for all processor to complete
    //

    while (Context->TargetCount != Context->NumberProcessors) {
        KeYieldProcessor ();
    }
}

VOID
PopHandleNextState (
    IN PPOP_SYS_CONTEXT     Context,
    IN PPOP_LOCAL_CONTEXT   LocalContext
    )
/*++

Routine Description:

    Wait for next state notification, and then handle it

Arguments:

    Context     - Shared context structure used to communicate the
                  state transitions

    LocalContext- Context local to this processor

Return Value:

    None

--*/
{
    NTSTATUS                Status;
    PPROCESSOR_POWER_STATE  PState;
    PKPRCB                  Prcb;

    Prcb = KeGetCurrentPrcb();
    PState = &Prcb->PowerState;

    //
    // Wait for new state
    //

    while (Context->State == LocalContext->LastState) {
        KeYieldProcessor ();
    }

    //
    // Pickup new state and handle it
    //

    LocalContext->LastState = Context->State;
    switch (LocalContext->LastState) {
        case POP_SH_SAVE_CONTEXT:
            Status = KeSaveFloatingPointState(&LocalContext->FloatSave);
            LocalContext->FloatSaved = NT_SUCCESS(Status) ? TRUE : FALSE;
            break;

        case POP_SH_GET_STACKS:
            PopCloneStack (Context->HiberContext);
            break;

        case POP_SH_DISABLE_INTERRUPTS:
            LocalContext->Irql = KeGetCurrentIrql();
            LocalContext->InterruptEnable = KeDisableInterrupts();
            break;

        case POP_SH_INVOKE_HANDLER:
            Status = Context->Handler->Handler (
                            Context->Handler->Context,
                            Context->SystemHandler,
                            Context->SystemContext,
                            Context->NumberProcessors,
                            &Context->HandlerBarrier
                            );

            LocalContext->Status = Status;
            break;

        case POP_SH_INVOKE_NOTIFY_HANDLER:

            if (Context->NotifyHandler->Handler) {

              Status = Context->NotifyHandler->Handler(
                              Context->NotifyState,
                              Context->NotifyHandler->Context,
                              Context->NotifyType
                              );

              //
              // Don't overwrite LocalContext->Status here.  It's been set
              // by the POP_SH_INVOKE_HANDLER code above and we don't want
              // to step on that.
              //
              ASSERT(NT_SUCCESS(Status));

            }
            break;

        case POP_SH_RESTORE_INTERRUPTS:
            KeEnableInterrupts(LocalContext->InterruptEnable);
            KeLowerIrql(LocalContext->Irql);
            break;

        case POP_SH_RESTORE_CONTEXT:

#if defined(_AMD64_)
            KeRestoreProcessorSpecificFeatures();
#endif
            if (LocalContext->FloatSaved) {
                KeRestoreFloatingPointState(&LocalContext->FloatSave);
            }

            if (PState->Flags & PSTATE_SUPPORTS_THROTTLE) {
                PState->PerfSetThrottle(PState->CurrentThrottle);
            }
            break;
    }

    //
    // Signal that we are in the new state
    //

    InterlockedIncrement (&Context->TargetCount);
}



VOID
PopInvokeStateHandlerTargetProcessor (
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    )
/*++

Routine Description:

    Called by target processors when invoking a power state
    handler.   Target processors wait for invoking processor
    to coordinate the states required to enter the particular
    power state handler.

Arguments:

    Dpc                 - Not used

    DeferredContext     - Shared context structure

Return Value:

    None

--*/
{
    POP_LOCAL_CONTEXT   LocalContext;
    PPOP_SYS_CONTEXT    Context;

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    Context = (PPOP_SYS_CONTEXT) DeferredContext;
    RtlZeroMemory (&LocalContext, sizeof(LocalContext));
    LocalContext.LastState = POP_SH_UNINITIALIZED;

    //
    // Handle new states
    //

    do {

        PopHandleNextState (Context, &LocalContext);

    } while (LocalContext.LastState != POP_SH_COMPLETE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\thermal.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    thermal.c

Abstract:

    This module interfaces the policy manager a thermal zone device

Author:

    Ken Reneris (kenr) 17-Jan-1997

Revision History:

--*/


#include "pop.h"
#include "stdio.h"          // for sprintf

VOID
PopThermalZoneCleanup (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

PUCHAR
PopTemperatureString (
    OUT PUCHAR  TempString,
    IN ULONG    TenthsKelvin
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PopThermalDeviceHandler)
#endif

PUCHAR
PopTemperatureString (
    OUT PUCHAR  TempString,
    IN ULONG    TenthsKelvin
    )
{
#if DBG
    ULONG   k, c, f;

    k = TenthsKelvin;
    if (k < 2732) {

        c = 2732 - k;
        f = c * 9 / 5 + 320;
#if 0
        sprintf(TempString, "%d.%dk, -%d.%dc, -%d.%df",
                    k / 10, k % 10,
                    c / 10, c % 10,
                    f / 10, f % 10
                    );
#else
        sprintf((PCHAR) TempString, "%d.%dK", k / 10, k % 10);
#endif

    } else {

        c = k - 2732;
        f = c * 9 / 5 + 320;
#if 0
        sprintf (TempString, "%d.%dk, %d.%dc, %d.%df",
                    k / 10, k % 10,
                    c / 10, c % 10,
                    f / 10, f % 10
                    );
#else
        sprintf((PCHAR) TempString, "%d.%dK", k / 10, k % 10);
#endif

    }
    return TempString;
#else
    UNREFERENCED_PARAMETER (TempString);
    UNREFERENCED_PARAMETER (TenthsKelvin);
    return (PUCHAR)"";
#endif
}

PUCHAR
PopTimeString(
    OUT PUCHAR      TimeString,
    IN  ULONGLONG   CurrentTime
    )
{
#if DBG
    LARGE_INTEGER   curTime;
    TIME_FIELDS     exCurTime;

    curTime.QuadPart = CurrentTime;
    RtlTimeToTimeFields( &curTime, &exCurTime );

    sprintf(
        (PCHAR) TimeString,
        "%d:%02d:%02d.%03d",
        exCurTime.Hour,
        exCurTime.Minute,
        exCurTime.Second,
        exCurTime.Milliseconds
        );
    return TimeString;
#else
    UNREFERENCED_PARAMETER (TimeString);
    UNREFERENCED_PARAMETER (CurrentTime);
    return (PUCHAR)"";
#endif
}

VOID
PopThermalUpdateThrottle(
    IN  PPOP_THERMAL_ZONE   ThermalZone,
    IN  ULONGLONG           CurrentTime
    )
/*++

Routine Description:

    This routine is called to recalculate the throttle value of the
    thermal zone

    This function is not re-entrant. Each ThermalZone can only be in this
    code exactly once

Arguments:

    ThermalZone - The structure for which the throttle value should be
                  recalculated
    CurrentTime - The time at which the kernel handler was invoked

Return Value:

    None

--*/
{
    BOOLEAN doThrottle      = FALSE;
    KIRQL   oldIrql;
    LONG    part1;
    LONG    part2;
    LONG    throttleDelta;
    LONG    currentThrottle = 0;
    LONG    minThrottle;
    LONG    minThrottle2;

    PKPRCB  prcb;
    UCHAR   t[40];
#if DBG
    UCHAR   s[40];
#endif

    //
    // If there are no processor throttling capablities, this function does
    // nothing useful. The same applies if the thermal zone does not belong
    // to a processor
    //
    if (!ThermalZone->Info.Processors) {

        return;

    }

    //
    // Make sure that we have the time in a format that we can print it out
    // Note that by using the time that was passed in (instead of fetching
    // again), we make sure that the printouts always read the same thing
    //
    PopTimeString(t, CurrentTime );

    //
    // Make sure to run on the context of the appropriate processor
    //
    KeSetSystemAffinityThread( ThermalZone->Info.Processors );

    //
    // Make sure to raise IRQL so that we can synchronize
    //
    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    //
    // Is there any support for throttling on this processor?
    //
    prcb = KeGetCurrentPrcb();
    if ((prcb->PowerState.Flags & PSTATE_SUPPORTS_THROTTLE) == 0) {

        KeLowerIrql( oldIrql );
        KeRevertToUserAffinityThread();
        return;

    }

    //
    // Do these calculations now, while its safe
    //
    minThrottle2 = (LONG) (PopPolicy->MinThrottle * PO_TZ_THROTTLE_SCALE);
    minThrottle = prcb->PowerState.ProcessorMinThrottle * PO_TZ_THROTTLE_SCALE;

    //
    // No longer need to lock with the processor
    //
    KeLowerIrql( oldIrql );
    KeRevertToUserAffinityThread();

    //
    // If Temperature isn't above the passive trip point, stop passive cooling
    //
    if (ThermalZone->Info.CurrentTemperature < ThermalZone->Info.PassiveTripPoint) {

        //
        // If we aren't already throttling, then there isn't much to do
        //
        if (!(ThermalZone->Flags & PO_TZ_THROTTLING) ) {

            return;

        }

        //
        // Make sure that we wait long enough...
        //
        if ( (CurrentTime  - ThermalZone->LastTime) < ThermalZone->SampleRate) {

            return;

        }

        //
        // We were throttling, so now we must stop
        //
        doThrottle = FALSE;
        currentThrottle = PO_TZ_NO_THROTTLE;
        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s - ending throttle #1\n",
             ThermalZone, t
            ) );

        //
        // Remove Thermal Throttle Flag since we are done throttling
        //

        KeSetSystemAffinityThread(ThermalZone->Info.Processors);
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

        prcb = KeGetCurrentPrcb();
        RtlInterlockedClearBits(&prcb->PowerState.Flags, PSTATE_THERMAL_THROTTLE_APPLIED);

        //
        // Set up timer to fire now that we have completed our thermal event.
        //
        PopSetTimer(&prcb->PowerState, prcb->PowerState.CurrentThrottle);
        
        KeLowerIrql(oldIrql);
        KeRevertToUserAffinityThread();

        
        goto PopThermalUpdateThrottleExit;

    }

    //
    // Are we already throttling?
    //
    if (!(ThermalZone->Flags & PO_TZ_THROTTLING) ) {

        //
        // Throttling is not enabled, but the thermal zone has exceeded
        // it's passive cooling point.  We need to start throttling
        //
        doThrottle = TRUE;
        currentThrottle = PO_TZ_NO_THROTTLE;

        ASSERT(
            ThermalZone->Info.SamplingPeriod &&
            ThermalZone->Info.SamplingPeriod < 4096
            );

        ThermalZone->SampleRate = 1000000 * ThermalZone->Info.SamplingPeriod;
        ThermalZone->LastTime = 0;
        ThermalZone->LastTemp = ThermalZone->Info.PassiveTripPoint;

        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s - starting to throttle\n",
             ThermalZone, t
            ) );

        //
        // Set Thermal Throttle Flag since we are now throttling
        //
        KeSetSystemAffinityThread(ThermalZone->Info.Processors);
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

        prcb = KeGetCurrentPrcb();
        RtlInterlockedSetBits(&prcb->PowerState.Flags, PSTATE_THERMAL_THROTTLE_APPLIED);
              
        KeLowerIrql(oldIrql);
        KeRevertToUserAffinityThread();

    } else if ( (CurrentTime  - ThermalZone->LastTime) < ThermalZone->SampleRate) {

        //
        // The sample period has not yet expired, so wait until it has
        //
        return;

    } else {

        //
        // We need to get the current throttle value since our calculations
        // will use it
        //
        // It is not necessary to synchronize access to this variable since
        // the flags are not also being accessed at the same time.
        //
//        KeAcquireSpinLock( &PopThermalLock, &oldIrql );
        currentThrottle = ThermalZone->Throttle;
//        KeReleaseSpinLock( &PopThermalLock, oldIrql );

    }

    //
    // Compute throttle adjustment
    //
    part1 = ThermalZone->Info.CurrentTemperature - ThermalZone->LastTemp;
    part2 = ThermalZone->Info.CurrentTemperature - ThermalZone->Info.PassiveTripPoint;
    throttleDelta =
        ThermalZone->Info.ThermalConstant1 * part1 +
        ThermalZone->Info.ThermalConstant2 * part2;
    PoPrint(
        PO_THERM,
        ("Thermal - Zone %p - %s - LastTemp %s ThrottleDelta = %d.%d%%\n",
         ThermalZone, t,
         PopTemperatureString(s, ThermalZone->LastTemp),
         (throttleDelta / 10),
         (throttleDelta % 10)
        ) );

    //
    // Only apply the throttle adjustment if it is in the same
    // direction as the tempature motion.
    //
    if ( (part1 ^ throttleDelta) >= 0) {

        currentThrottle -= throttleDelta;

#if DBG
        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s - Subtracting delta from throttle\n",
             ThermalZone, t)
            );

    } else {

        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s - TempDelta (%d.%d) ^ (%d.%d) < 0)\n",
             ThermalZone, t, (part1 / 10), (part1 % 10),
             (throttleDelta / 10), (throttleDelta % 10) )
            );

#endif
    }

    //
    // If throttle is over 100% then we're done throttling
    //
    if (currentThrottle > PO_TZ_NO_THROTTLE) {

        currentThrottle = PO_TZ_NO_THROTTLE;
        doThrottle = FALSE;
        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s - ending throttle #2\n",
             ThermalZone, t)
            );

    } else {

        //
        // Show the world what the two mininums are
        //
        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s - Min #1 %d.%d  Min #2 %d.%d \n",
             ThermalZone, t,
             (minThrottle / 10), (minThrottle % 10),
             (minThrottle2 / 10), (minThrottle2 % 10)
            ) );

        if (currentThrottle < minThrottle) {

            currentThrottle = minThrottle;

        }

        //
        // Remember to start throttling
        //
        doThrottle = TRUE;

    }

PopThermalUpdateThrottleExit:

    //
    // Do this at the end
    //
    ThermalZone->LastTemp = ThermalZone->Info.CurrentTemperature;
    ThermalZone->LastTime = CurrentTime;

    //
    // At this point, we will set and remember the value that we calculated
    // in the above function
    //
    KeAcquireSpinLock( &PopThermalLock, &oldIrql);
    if (doThrottle) {

        ThermalZone->Flags |= PO_TZ_THROTTLING;
        ThermalZone->Throttle = currentThrottle;

    } else {

        ThermalZone->Flags &= ~PO_TZ_THROTTLING;
        ThermalZone->Throttle = PO_TZ_NO_THROTTLE;

    }

    //
    // Apply thermal zone throttles to all effected processors
    //
    PoPrint(
        PO_THERM,
        ("Thermal - Zone %p - %s - throttle set to %d.%d\n",
         ThermalZone, t,
         (ThermalZone->Throttle / 10),
         (ThermalZone->Throttle % 10)
         )
        );

    KeReleaseSpinLock( &PopThermalLock, oldIrql );

    //
    // Make sure to apply the new throttle
    //
    PopApplyThermalThrottle ();

    //
    // Done
    //
    return;
}

VOID
PopThermalDeviceHandler (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    N.B. PopPolicyLock must be held.

Arguments:

    DeviceObject    - DeviceObject of the switch device

    Irp             - Irp which has completed

    Context         - type of switch device

Return Value:

    None.

--*/
{
    BOOLEAN                 sendActiveIrp = FALSE;
    PIO_STACK_LOCATION      irpSp;
    PPOP_THERMAL_ZONE       thermalZone;
    LARGE_INTEGER           dueTime;
    ULONGLONG               currentTime;
    ULONG                   activePoint;
#if DBG
    ULONG                   i;
    UCHAR                   s[40];
#endif
    UCHAR                   t[40];

    ASSERT_POLICY_LOCK_OWNED();

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    thermalZone = (PPOP_THERMAL_ZONE) Context;
    currentTime = KeQueryInterruptTime ();
    PopTimeString(t, currentTime );

    //
    // Irp had an error.  See if the thermal zone is being removed
    //
    if (Irp->IoStatus.Status == STATUS_NO_SUCH_DEVICE) {

        //
        // Thermal zone device has disappeared, clean up
        //
        thermalZone->State   = PO_TZ_NO_STATE;
        thermalZone->Flags  |= PO_TZ_CLEANUP;

        //
        // Pass it to the DPC function to ensure the timer & dpc are idle
        //
        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s - going away\n",
             thermalZone, t)
            );
        dueTime.QuadPart = -1;
        KeSetTimer (&thermalZone->PassiveTimer, dueTime, &thermalZone->PassiveDpc);

        //
        // Do not issue next IRP
        //
        return
            ;
    }

    //
    // If irp completed with success, handle it
    //
    if (NT_SUCCESS(Irp->IoStatus.Status)) {
        switch (thermalZone->State) {
        case PO_TZ_READ_STATE:

            //
            // Read of thermal information has completed.
            //
            PoPrint(
                PO_THERM,
                ("Thermal - Zone %p - %s\n  Current Temp: %s",
                 thermalZone, t,
                 PopTemperatureString(s, thermalZone->Info.CurrentTemperature)
                ) );
            PoPrint(
                PO_THERM,
                ("  Critical Trip: %s",
                 PopTemperatureString(s, thermalZone->Info.CriticalTripPoint)
                ) );
            PoPrint(
                PO_THERM,
                ("  Passive Trip: %s\n",
                 PopTemperatureString(s, thermalZone->Info.PassiveTripPoint)
                ) );
#if DBG
            for ( i=0; i < thermalZone->Info.ActiveTripPointCount; i++) {

                PoPrint(
                    PO_THERM,
                    ("  Active Trip %d: %s\n",
                     i,
                     PopTemperatureString(s, thermalZone->Info.ActiveTripPoint[i])
                    ) );
            }
#endif
            //
            // Update the throttle
            //
            PopThermalUpdateThrottle( thermalZone, currentTime );

            //
            // Check for change in active cooling
            //
            for (activePoint = 0; activePoint < thermalZone->Info.ActiveTripPointCount; activePoint++) {

                if (thermalZone->Info.CurrentTemperature >= thermalZone->Info.ActiveTripPoint[activePoint]) {

                    break;

                }

            }
            if (activePoint != thermalZone->ActivePoint) {

                PoPrint(
                    PO_THERM,
                    ("Thermal - Zone %p - %s - Pending Coooling Point is %x\n",
                     thermalZone, t, activePoint)
                    );
                thermalZone->PendingActivePoint = (UCHAR) activePoint;
                sendActiveIrp = TRUE;

            }

            //
            // Check for critical trip point
            //
            if (thermalZone->Info.CurrentTemperature > thermalZone->Info.CriticalTripPoint) {
                PoPrint(
                    PO_THERM | PO_ERROR,
                    ("Thermal - Zone %p - %s - Above critical (%x %x)\n",
                    thermalZone, t,
                    thermalZone->Info.CurrentTemperature,
                    thermalZone->Info.CriticalTripPoint
                    ));

                PopCriticalShutdown (PolicyDeviceThermalZone);
            }

            break;

            case PO_TZ_SET_MODE:

            //
            // Thermal zone cooling mode was successfully set
            //
            thermalZone->Mode = thermalZone->PendingMode;
            PoPrint(
                PO_THERM,
                ("Thermal - Zone %p - %s - cooling mode set to %x\n",
                 thermalZone, t, thermalZone->Mode)
                );

            //
            // We want to force a resend of the Active Trip Point irp since
            // there is a situation where the ACPI driver decides that as a
            // matter of policy, it will not actually turn on fans if the
            // system is in passive cooling mode. If we go back to active
            // mode, then we want to turn the fans on. The same holds true
            // if the fans are running and we transition to passive mode.
            //
            sendActiveIrp = TRUE;

            break;

        case PO_TZ_SET_ACTIVE:
            thermalZone->ActivePoint = thermalZone->PendingActivePoint;
            PoPrint(
                PO_THERM,
                ("Thermal - Zone %p - %s - active cooling point set to %x\n",
                 thermalZone, t, thermalZone->ActivePoint)
                );
            break;

        default:
            PopInternalAddToDumpFile( Irp, sizeof(IRP), DeviceObject, NULL, NULL, NULL );
            KeBugCheckEx( INTERNAL_POWER_ERROR,
                          0x500,
                          POP_THERMAL,
                          (ULONG_PTR)Irp,
                          (ULONG_PTR)DeviceObject );
        }

#if DBG
    } else if (Irp->IoStatus.Status != STATUS_DEVICE_NOT_CONNECTED &&
        Irp->IoStatus.Status != STATUS_CANCELLED) {

        //
        // Unexpected error
        //

        PoPrint(
            PO_ERROR,
            ("Thermal - Zone - %p - %s - unexpected error %x\n",
             thermalZone, t, Irp->IoStatus.Status));

#endif
    }

    //
    // Determine type of irp to send zone
    //
    irpSp = IoGetNextIrpStackLocation(Irp);
    if (sendActiveIrp) {

        //
        // Thermal zone active cooling point not current
        //
        thermalZone->State = PO_TZ_SET_ACTIVE;

        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_RUN_ACTIVE_COOLING_METHOD;
        irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ULONG);
        irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
        Irp->AssociatedIrp.SystemBuffer = &thermalZone->PendingActivePoint;

        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s Sending Run Cooling Method: %x\n",
             thermalZone, t, thermalZone->PendingActivePoint)
            );

    } else if (thermalZone->Mode != PopCoolingMode) {

        //
        // Thermal zone cooling mode does not match system cooling mode.
        //
        thermalZone->State       = PO_TZ_SET_MODE;
        thermalZone->PendingMode = (UCHAR) PopCoolingMode;

        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_THERMAL_SET_COOLING_POLICY;
        irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(thermalZone->PendingMode);
        irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
        Irp->AssociatedIrp.SystemBuffer = &thermalZone->PendingMode;

        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s - Sending Set Cooling Policy: %x\n",
             thermalZone, t, thermalZone->PendingMode)
            );

    } else {

        //
        // Issue query to get tempture of thermal zone
        //
        thermalZone->State = PO_TZ_READ_STATE;
        if (thermalZone->Flags & PO_TZ_THROTTLING  &&  thermalZone->SampleRate) {

            //
            // Compute time for next read
            //
            dueTime.QuadPart = thermalZone->LastTime + thermalZone->SampleRate;
            if (dueTime.QuadPart > (LONGLONG) currentTime) {

#if DBG
                PoPrint(
                    PO_THERM,
                    ("Thermal - Zone %x - %s waituntil",
                     thermalZone, t) );
                PoPrint(
                    PO_THERM,
                    (" %s (%d sec)\n",
                     PopTimeString(t, dueTime.QuadPart),
                     ( (thermalZone->SampleRate ) / (US2TIME * US2SEC) ) )
                    );
                PopTimeString(t, currentTime);
#endif

                //
                // Set timer for duration of wait
                //
                dueTime.QuadPart = currentTime - dueTime.QuadPart;
                KeSetTimer (&thermalZone->PassiveTimer, dueTime, &thermalZone->PassiveDpc);

            } else {

                //
                // Perform non-blocking IRP query information to get the Temperature now
                //
                thermalZone->Info.ThermalStamp = 0;

            }
        }

        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_THERMAL_QUERY_INFORMATION;
        irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(thermalZone->Info);
        irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(thermalZone->Info);
        Irp->AssociatedIrp.SystemBuffer = &thermalZone->Info;
        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s - Sending Query Temp - ThermalStamp = %x\n",
             thermalZone, t, thermalZone->Info.ThermalStamp) );

    }

    //
    // Send irp to driver
    //
    IoSetCompletionRoutine (Irp, PopCompletePolicyIrp, NULL, TRUE, TRUE, TRUE);
    IoCallDriver (DeviceObject, Irp);
}

VOID
PopThermalZoneCleanup (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    KIRQL                   oldIrql;
    PPOP_THERMAL_ZONE       thermalZone;

    ASSERT_POLICY_LOCK_OWNED();

    thermalZone = (PPOP_THERMAL_ZONE) Context;

    //
    // Acquire the Spinlock required to delete the thermal zone
    //
    KeAcquireSpinLock( &PopThermalLock, &oldIrql );

    //
    // Delete thermal zone from the linked list of thermal zones
    //
    RemoveEntryList (&thermalZone->Link);

    //
    // Remember what the irp associated with the thermal zone was
    //
    Irp = thermalZone->Irp;

    //
    // Make sure to cleanup the entry, so that any further reference is
    // bogus
    //
#if DBG
    RtlZeroMemory( thermalZone, sizeof(POP_THERMAL_ZONE) );
#endif

    //
    // Release the spinlock that was protecting the thermal zone
    //
    KeReleaseSpinLock( &PopThermalLock, oldIrql );

    //
    // Free the Irp that we had associated with it...
    //
    IoFreeIrp (Irp);

    //
    // Free the reference we had to the device object
    //
    ObDereferenceObject (DeviceObject);

    //
    // Finally, free the memory associated with the thermal zone
    //
    ExFreePool (thermalZone);
}

VOID
PopThermalZoneDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    Timer dpc used to unblock pending read of thermal zone Temperature
    in order to get the Temperature now

Arguments:

    DeferredConext  - ThermalZone

Return Value:

    None.

--*/
{
    PPOP_THERMAL_ZONE       thermalZone;
    PIO_STACK_LOCATION      irpSp;
#if DBG
    ULONGLONG               currentTime;
    UCHAR                   t[40];

    currentTime = KeQueryInterruptTime();
    PopTimeString(t, currentTime);
#endif

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    thermalZone = (PPOP_THERMAL_ZONE) DeferredContext;

    //
    // If cleanup is set queue the thread zone to be cleaned up
    //

    if (thermalZone->Flags & PO_TZ_CLEANUP) {

        //
        // The irp is idle, use it to queue the request to the cleanup procedure
        //

        irpSp = IoGetCurrentIrpStackLocation(thermalZone->Irp);
        irpSp += 1;     // get previous location
        irpSp->Parameters.Others.Argument3 = (PVOID) PopThermalZoneCleanup;
        PopCompletePolicyIrp (NULL, thermalZone->Irp, NULL);

    }

    //
    // Time to read current Temperature to adjust passive cooling throttle.
    // If the current state is reading, then cancel it to either to the
    // Temperature now or to issue a non-blocking thermal read state
    //

    if (thermalZone->State == PO_TZ_READ_STATE) {

#if DBG
        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s - Cancel Irp %p\n",
             thermalZone, t, thermalZone->Irp)
            );
#endif
        IoCancelIrp (thermalZone->Irp);

#if DBG
    } else {

        PoPrint(
            PO_THERM,
            ("Thermal - Zone %p - %s - In state %08lx\n",
             thermalZone, t, thermalZone->State )
            );

#endif
    }
}

VOID
PopApplyThermalThrottle (
    VOID
    )
/*++

Routine Description:

    Computes each processors best possible speed as dictated by thermal
    restrants.   Will also examine the thermal settings to determine if
    the cooling mode should be adjusted.

Arguments:


Return Value:

    None.

--*/
{
    KAFFINITY               processors;
    KAFFINITY               currentAffinity;
    KAFFINITY               thermalProcessors;
    KIRQL                   oldIrql;
    PLIST_ENTRY             link;
    PPOP_THERMAL_ZONE       thermalZone;
    PPROCESSOR_POWER_STATE  pState;
    UCHAR                   thermalLimit;
    UCHAR                   thermalLimitIndex;
    UCHAR                   forcedLimit;
    UCHAR                   forcedLimitIndex;
    UCHAR                   limit;
    UCHAR                   index;
    ULONG                   thermalThrottle;
    ULONG                   forcedThrottle;
    ULONG                   mode;
    ULONG                   processorNumber;
#if DBG
    ULONGLONG               currentTime;
    UCHAR                   t[40];

    currentTime = KeQueryInterruptTime();
    PopTimeString(t, currentTime);
#endif

    ASSERT_POLICY_LOCK_OWNED();

    //
    // If the system doesn't have processor throttle capabilities then
    // don't bother
    //
    if (!PopCapabilities.ProcessorThrottle) {

        return ;

    }

#if 0
    //
    // Compute overthrottled into thermal zone throttle units
    //
    MinThrottle = PopPolicy->MinThrottle * PO_TZ_THROTTLE_SCALE;
#endif

    //
    // Make sure to hold the spinlock for find the LCD. We don't actually
    // use the lock to walk the list, but we need it to reference the
    // Throttle Value
    //
    KeAcquireSpinLock( &PopThermalLock, &oldIrql );

    //
    // Get the LCD of the thermal zones
    //
    thermalThrottle = PO_TZ_NO_THROTTLE;
    thermalProcessors = 0;
    for (link = PopThermal.Flink; link != &PopThermal; link = link->Flink) {

        thermalZone = CONTAINING_RECORD (link, POP_THERMAL_ZONE, Link);

        //
        // Handle zones which are throttling
        //
        if (thermalZone->Flags & PO_TZ_THROTTLING) {

            //
            // Include processors for this zone
            //
            thermalProcessors |= thermalZone->Info.Processors;

            //
            // If zone is less then current thermal throttle, lower it
            //
            if ((ULONG) thermalZone->Throttle < thermalThrottle) {
                thermalThrottle = thermalZone->Throttle;
            }

            //
            // Until I can get the user guys to add a thermal tab such that
            // the OverThrottle policy becomes configurable by the user,
            // always putting the system to sleep on an overthrottle is a bad
            // idea. Note that there is some code in PopThermalDeviceHandler
            // that will have to be changed when the following is uncommented
            //
#if 0
            //
            // Check if zone has overthrottled the system
            //
            if ((ULONG) thermalZone->Throttle < MinThrottle) {
#if DBG
                PoPrint(
                    PO_THERM | PO_ERROR,
                    ("Thermal - Zone %p - %s -  overthrottled (%x %x)\n",
                     thermalZone, t, thermalZone->Throttle, MinThrottle)
                    );
#endif
                //
                // If we are going to do an S1-Critical standby, then we
                // will return immediately and not try to throttle the
                // CPU
                //
                PopSetPowerAction (
                    &thermalZone->OverThrottled,
                    0,
                    &PopPolicy->OverThrottled,
                    PowerSystemSleeping1,
                    SubstituteLightestOverallDownwardBounded
                    );

                return;

            } else {

                //
                // Zone is not overthrottled, make sure trigger is clear
                //
                thermalZone->OverThrottled.Flags &= ~(PO_TRG_USER | PO_TRG_SYSTEM);

            }
#endif

        }
    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &PopThermalLock, oldIrql );

#if DBG
    PoPrint(
        PO_THERM,
        ("PopApplyThermalThrottle - %s - Thermal throttle = %d.%d\n",
         t, (thermalThrottle / 10), (thermalThrottle % 10) )
        );
#endif

    //
    // Use Min of thermal throttle and forced system throttle
    //
    forcedThrottle = PopGetThrottle() * PO_TZ_THROTTLE_SCALE;
    if (thermalThrottle > forcedThrottle) {

        thermalThrottle = forcedThrottle;
#if DBG
        PoPrint(
            PO_THERM,
            ("PopApplyThermalThrottle - %s - Set to Forced throttle = %d.%d\n",
             t, (thermalThrottle / 10), (thermalThrottle % 10) )
            );
#endif

    }

    //
    // Check active vs. passive cooling
    //
    if (thermalThrottle <= (ULONG) PopPolicy->FanThrottleTolerance * PO_TZ_THROTTLE_SCALE) {

        //
        // Throttle is below tolerance, we should be in active cooling
        //
        mode = PO_TZ_ACTIVE;


    } else {

        //
        // Throttle is above tolerance.  If optimize for power is set then
        // use passive cooling else use active cooling
        //
        mode = PopPolicy->OptimizeForPower ? PO_TZ_PASSIVE : PO_TZ_ACTIVE;

    }

    //
    // If current cooling mode is not correct, update it
    //
    if (mode != PopCoolingMode) {

#if DBG
        ULONG   fanTolerance = (ULONG) PopPolicy->FanThrottleTolerance * PO_TZ_THROTTLE_SCALE;

        PoPrint(
            PO_THERM,
            ("PopApplyThermalThrottle - %s - Throttle (%d.%d) %s FanTolerance (%d.%d)\n",
             t, (thermalThrottle / 10), (thermalThrottle % 10),
             (thermalThrottle <= fanTolerance ? "<=" : ">"),
             (fanTolerance / 10), (fanTolerance % 10) )
            );
        PoPrint(
            PO_THERM,
            ("PopApplyThermalThrottle - %s - OptimizeForPower is %s\n",
             t, (PopPolicy->OptimizeForPower ? "True" : "False") )
            );
        PoPrint(
            PO_THERM,
            ("PopApplyThermalThrottle - %s -  Changing cooling mode to %s\n",
             t, (mode == PO_TZ_ACTIVE ? "Active" : "Passive") )
            );
#endif
        PopCoolingMode = mode;

        //
        // We are going to touch the Thermal list --- make sure that we hold
        // the correct lock
        //
        KeAcquireSpinLock(&PopThermalLock, &oldIrql );

        //
        // Cancel any blocked thermal reads in order to send set mode irps
        //
        for (link = PopThermal.Flink; link != &PopThermal; link = link->Flink) {

            thermalZone = CONTAINING_RECORD (link, POP_THERMAL_ZONE, Link);
            if (thermalZone->State == PO_TZ_READ_STATE) {

                IoCancelIrp (thermalZone->Irp);

            }

        }

        //
        // Done with the thermal lock
        //
        KeReleaseSpinLock(& PopThermalLock, oldIrql );

    }

    //
    // Set limit on effected processors
    //
    processorNumber = 0;
    currentAffinity = 1;
    processors = KeActiveProcessors;

    do {

        if (!(processors & currentAffinity)) {

            currentAffinity <<= 1;
            continue;

        }
        processors &= ~currentAffinity;

        //
        // We must run on the target processor
        //
        KeSetSystemAffinityThread(currentAffinity);

        //
        // We need to be running at DISPATCH_LEVEL to access the
        // structures referenced within the pState...
        //
        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        pState = &(KeGetCurrentPrcb()->PowerState);

        //
        // Does this processor support throttling?
        //
        if ((pState->Flags & PSTATE_SUPPORTS_THROTTLE) == 0) {

            //
            // No, then we don't care about it...
            //
            currentAffinity <<= 1;
            KeLowerIrql( oldIrql );
            continue;

        }

        //
        // Convert throttles to processor buck size. We need to
        // do this in the context of the target processor to make
        // sure that we get the correct set of perf levels
        //
        PopRoundThrottle(
            (UCHAR)(thermalThrottle/PO_TZ_THROTTLE_SCALE),
            &thermalLimit,
            NULL,
            &thermalLimitIndex,
            NULL
            );
        PopRoundThrottle(
            (UCHAR)(forcedThrottle/PO_TZ_THROTTLE_SCALE),
            &forcedLimit,
            NULL,
            &forcedLimitIndex,
            NULL
            );

#if DBG
        PoPrint(
            PO_THROTTLE,
            ("PopApplyThermalThrottle - %s - Thermal throttle = %d.%d -> Limit = %d\n",
             t, (thermalThrottle / 10), (thermalThrottle % 10),
             thermalLimit
             )
            );
        PoPrint(
            PO_THROTTLE,
            ("PopApplyThermalThrottle - %s - Forced throttle = %d.%d -> Limit = %d\n",
             t, (forcedThrottle / 10), (forcedThrottle % 10),
             forcedLimit
             )
            );
#endif

        //
        // Figure out which one we are going to use...
        //
        limit = (thermalProcessors & currentAffinity) ?
            thermalLimit : forcedLimit;
        index = (thermalProcessors & currentAffinity) ?
            thermalLimitIndex : forcedLimitIndex;

        //
        // Done with current affinity mask
        //
        currentAffinity <<= 1;

        //
        // Check processor limits for to see if value is okay
        //
        if (limit > pState->ProcessorMaxThrottle) {

#if DBG
            PoPrint(
                PO_THROTTLE,
                ("PopApplyThermalThrottle - %s - Limit (%d) > MaxThrottle (%d)\n",
                 t, limit, pState->ProcessorMaxThrottle)
                );
#endif
            limit = pState->ProcessorMaxThrottle;

        } else if (limit < pState->ProcessorMinThrottle) {

#if DBG
            PoPrint(
                PO_THROTTLE,
                ("PopApplyThermalThrottle - %s - Limit (%d) < MinThrottle (%d)\n",
                 t, limit, pState->ProcessorMinThrottle)
                );
#endif
            limit = pState->ProcessorMinThrottle;

        }

        //
        // Update the limit (if required...)
        //
        if (pState->ThermalThrottleLimit != limit) {

            pState->ThermalThrottleLimit = limit;
            pState->ThermalThrottleIndex = index;
#if DBG
            PoPrint(
                PO_THROTTLE,
                ("PopApplyThermalThrottle - %s - New Limit (%d) Index (%d)\n",
                 t, limit, index)
                );
#endif

        }

        //
        // Rever back to our previous IRQL
        //
        KeLowerIrql( oldIrql );

    } while (processors);

    //
    // We should revert back to the proper affinity
    //
    KeRevertToUserAffinityThread();

    //
    // Apply thermal throttles if necessary. Note we always do this
    // whether or not the limits were changed. This routine also gets
    // called whenever the system transitions from AC to DC, and that
    // may also require a throttle update due to dynamic throttling.
    //
    PopUpdateAllThrottles();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\throttle.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    throttle.c

Abstract:

    This module contains routines for controlling the voltaging throttling
    (SpeedStep) for a CPU. Note that this applies only to throttling for
    power savings, not throttling for thermal reasons.

    There are four different algorithms defined for voltage throttling.

    None - no voltage throttling will be used, the CPU always runs at 100% speed
           unless throttled for thermal reaons.

    Constant - CPU will be throttled to the next-lowest voltage step on DC, and
           always run at 100% on AC.

    Degrade - CPU will be throttled in proportion to the battery remaining.

    Adaptive - CPU throttle will vary to attempt to match the current CPU load.

Author:

    John Vert (jvert) 2/17/2000

Revision History:

--*/
#include "pop.h"

#define POP_THROTTLE_NON_LINEAR     1

//
// Globals representing currently available performance levels
//
PSET_PROCESSOR_THROTTLE PopRealSetThrottle;
UCHAR                   PopThunkThrottleScale;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PopGetThrottle)
#pragma alloc_text(PAGE, PopCalculatePerfDecreaseLevel)
#pragma alloc_text(PAGE, PopCalculatePerfIncreaseDecreaseTime)
#pragma alloc_text(PAGE, PopCalculatePerfIncreaseLevel)
#pragma alloc_text(PAGE, PopCalculatePerfMinCapacity)
#endif

UCHAR
PopCalculateBusyPercentage(
    IN  PPROCESSOR_POWER_STATE  PState
    )
/*++

Routine Description:

    This routine is called within the context of the target processor
    to determine how busy the processor was during the previous time
    period.

Arguments:

    PState  - Power State Information of the target processor

Return Value:

    Percentage value representing how busy the Processor is


--*/
{
    PKPRCB      prcb;
    PKTHREAD    thread;
    UCHAR       frequency;
    ULONGLONG   idle;
    ULONG       busy;
    ULONG       idleTimeDelta;
    ULONG       cpuTimeDelta;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( KeGetCurrentPrcb() == CONTAINING_RECORD( PState, KPRCB, PowerState ) );

    prcb = CONTAINING_RECORD( PState, KPRCB, PowerState );
    thread = prcb->IdleThread;

    //
    // Figure out the idle and cpu time deltas
    //
    idleTimeDelta = thread->KernelTime - PState->PerfIdleTime;
    cpuTimeDelta = POP_CUR_TIME(prcb) - PState->PerfSystemTime;
    idle = (idleTimeDelta * 100) / (cpuTimeDelta);

    //
    // We cannot be more than 100% idle, and if we are then we are
    // 0 busy (by definition), so apply the proper caps
    //
    if (idle > 100) {

        idle = 0;

    }

    busy = 100 - (UCHAR) idle;
    frequency = (UCHAR) (busy * PState->CurrentThrottle / POWER_PERF_SCALE);

    //
    // Remember what it was --- this will make debugging so much easier
    //
    prcb->PowerState.LastBusyPercentage = frequency;
    PoPrint(
        PO_THROTTLE_DETAIL,
        ("PopCalculateBusyPercentage: %d%% of %d%% (dCpu = %ld dIdle = %ld)\n",
         busy,
         PState->CurrentThrottle,
         cpuTimeDelta,
         idleTimeDelta
         )
        );
    return frequency;
}


UCHAR
PopCalculateC3Percentage(
    IN  PPROCESSOR_POWER_STATE  PState
    )
/*++

Routine Description:

    This routine is called within the context of the target processor
    to determine what percentage of time was spent in C3 during the previous
    time period.

Arguments:

    PState  - Power State Information of the target processor

Return Value:

    Percentage value

--*/
{
    PKPRCB          prcb;
    ULONGLONG       cpuTimeDelta;
    ULONGLONG       c3;
    LARGE_INTEGER   c3Delta;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( KeGetCurrentPrcb() == CONTAINING_RECORD( PState, KPRCB, PowerState ) );

    prcb = CONTAINING_RECORD( PState, KPRCB, PowerState );

    //
    // Calculate the C3 time delta in terms of nanosecs. The formulas for
    // conversion are taken from PopConvertUsToPerfCount
    //
    c3Delta.QuadPart = PState->TotalIdleStateTime[2] - PState->PreviousC3StateTime;
    c3Delta.QuadPart = (US2SEC * US2TIME * c3Delta.QuadPart) /
        PopPerfCounterFrequency.QuadPart;

    //
    // Now calculate the CpuTimeDelta in terms of nanosecs
    //
    cpuTimeDelta = (POP_CUR_TIME(prcb) - PState->PerfSystemTime) *
        KeTimeIncrement;

    //
    // Figure out the ratio of the two. Remember to cap it at 100%
    //
    c3 = c3Delta.QuadPart * 100 / cpuTimeDelta;
    if (c3 > 100) {

        c3 = 100;

    }

    //
    // Remember what it was --- this will make debugging so much easier
    //
    prcb->PowerState.LastC3Percentage = (UCHAR) c3;
    PoPrint(
        PO_THROTTLE_DETAIL,
        ("PopCalculateC3Percentage: C3 = %d%% (dCpu = %ld dC3 = %ld)\n",
         (UCHAR) c3,
         cpuTimeDelta,
         c3Delta.QuadPart
         )
        );
    return (UCHAR) c3;
}

VOID
PopCalculatePerfDecreaseLevel(
    IN  PPROCESSOR_PERF_STATE   PerfStates,
    IN  ULONG                   PerfStatesCount
    )
/*++

Routine Description:

    This routine calculate the lower bounds for each perf state

Arguments:

    PerfStates      - Array of Performance States
    PerfStatesCount - Number of element in array

Return Value:

    None

--*/
{
    //
    // We will be required to walk the PerfStates array several times and
    // the only way to safely keep track of which index we are looking at
    // versus which one we care about is to use two variables to keep track
    // of the various indexes.
    //
    ULONG   i;
    ULONG   deltaPerf;

    PAGED_CODE();

    //
    // Sanity check
    //
    if (PerfStatesCount == 0) {

        return;

    }

    //
    // Set the decrease value for the last element in the array
    //
    PerfStates[PerfStatesCount-1].DecreaseLevel = 0;

    //
    // Calculate the base decrease level
    //
    for (i = 0; i < (PerfStatesCount - 1); i++) {

        //
        // it should be noted that for the decrease level, the
        // deltaperf level calculated maybe different than the
        // deltaperf level calculated for the increase level. This
        // is due to how we walk the array and is non-trivial to fix.
        //
        deltaPerf = PerfStates[i].PercentFrequency -
            PerfStates[i+1].PercentFrequency;
        deltaPerf *= PopPerfDecreasePercentModifier;
        deltaPerf /= POWER_PERF_SCALE;
        deltaPerf += PopPerfDecreaseAbsoluteModifier;

        //
        // We can't have a delta perf that larger than the current
        // CPU frequency. This would cause the decrease level to go negative
        //
        if (deltaPerf > PerfStates[i+1].PercentFrequency) {

            deltaPerf = 0;

        } else {

            deltaPerf = PerfStates[i+1].PercentFrequency - deltaPerf;

        }

        //
        // Set the decrease level to the appropiate value
        //
        PerfStates[i].DecreaseLevel = (UCHAR) deltaPerf;

    }

#if DBG
    for (i = 0; i < PerfStatesCount; i++) {

        PoPrint(
            PO_THROTTLE,
            ("PopCalculatePerfDecreaseLevel: (%d) %d%% DecreaseLevel: %d%%\n",
             i,
             PerfStates[i].PercentFrequency,
             PerfStates[i].DecreaseLevel
             )
            );

    }
#endif
#if 0
    //
    // We want to eliminate demotions at the same voltage level
    // We want to guarantee that the DecreaseLevel gets set to a value
    // that will cause a voltage state transition
    //
    i = 0;
    while (i < PerfStatesCount) {

        //
        // Find the next non-linear state. We assume that "i" is currently
        // pointing at the highest-frequency state within a voltage band.
        // We are interested in finding the next highest-frequency state, but
        // at a lower voltage level
        //
        for (j = i + 1; j < PerfStatesCount; j++) {

            //
            // We known that there is a voltage change when the state is
            // marked as being non-linear
            //
            if (PerfStates[j].Flags & POP_THROTTLE_NON_LINEAR) {

                break;

            }

        }

        //
        // We want to find the previous state since that is the one
        // that the decrease level will be set to. Note that we aren't
        // worried about underflowing the array bounds since j starts at
        // i + 1.
        //
        j--;

        //
        // Set the decrease level of all the intervening states to this
        // new level
        //
        while (i < j) {

            PerfStates[i].DecreaseLevel = PerfStates[j].DecreaseLevel;
            i++;

        }

        //
        // Skip the Jth state since it is the bottom of the frequencies
        // available for the current voltage level.
        //
        i++;

    }
#endif
#if DBG
    for (i = 0; i < PerfStatesCount; i++) {

        PoPrint(
            PO_THROTTLE,
            ("PopCalculatePerfDecreaseLevel: (%d) %d%% DecreaseLevel: %d%%\n",
             i,
             PerfStates[i].PercentFrequency,
             PerfStates[i].DecreaseLevel
             )
            );

    }
#endif

}

VOID
PopCalculatePerfIncreaseDecreaseTime(
    IN  PPROCESSOR_PERF_STATE       PerfStates,
    IN  ULONG                       PerfStatesCount,
    IN  PPROCESSOR_STATE_HANDLER2   PerfHandler
    )
/*++

Routine Description:

    This routine calculate the lower bounds for each perf state

Arguments:

    PerfStates      - Array of Performance States
    PerfStatesCount - Number of element in array
    PerfHandler     - Information about the system latencies

Return Value:

    None

--*/
{
    ULONG   i;
    ULONG   time;
    ULONG   tickRate;

    PAGED_CODE();

    //
    // Sanity Check
    //
    if (PerfStatesCount == 0) {

        return;

    }

    //
    // Get the current tick rate
    //
    tickRate = KeQueryTimeIncrement();

    //
    // We can never increase from State 0
    //
    PerfStates[0].IncreaseTime = (ULONG) - 1;

    //
    // We can never decrease from State <x>
    //
    PerfStates[PerfStatesCount-1].DecreaseTime = (ULONG) -1;

    //
    // Might as tell say what the hardware latency is...
    //
    PoPrint(
        PO_THROTTLE,
        ("PopCalculatePerfIncreaseDecreaseTime: Hardware Latency %d us\n",
         PerfHandler->HardwareLatency
         )
        );

    //
    // Loop over the remaining elements to calculate their
    // increase and decrease times
    //
    for (i = 1; i < PerfStatesCount; i++) {

        //
        // DecreaseTime is calculated for the previous state
        // as function of wether or not the current state
        // is linear
        //
        time = PerfHandler->HardwareLatency * 10;
        if (PerfStates[i].Flags & POP_THROTTLE_NON_LINEAR) {

            time *= 10;
            time += PopPerfDecreaseTimeValue;

            //
            // We do have some minimums that we must respect
            //
            if (time < PopPerfDecreaseMinimumTime) {

                time = PopPerfDecreaseMinimumTime;

            }

        } else {

            time += PopPerfDecreaseTimeValue;

        }

        //
        // Time is in microseconds (us) and we need it in
        // units of KeTimeIncrement
        //
        PoPrint(
            PO_THROTTLE,
            ("PopCalculatePerfIncreaseDecreaseTime: (%d) %d%% DecreaseTime %d us\n",
             (i-1),
             PerfStates[i-1].PercentFrequency,
             time
             )
            );
        PerfStates[i-1].DecreaseTime = time * US2TIME / tickRate + 1;

        //
        // IncreaseTime is calculated for the current state
        // as a function of wether or not the current state
        // is linear
        //
        time = PerfHandler->HardwareLatency;
        if (PerfStates[i].Flags & POP_THROTTLE_NON_LINEAR) {

            time *= 10;
            time += PopPerfIncreaseTimeValue;

            //
            // We do have some minimums that we must respect
            //
            if (time < PopPerfIncreaseMinimumTime) {

                time = PopPerfIncreaseMinimumTime;

            }

        } else {

            time += PopPerfIncreaseTimeValue;

        }

        //
        // Time is in microseconds (us) and we need it in
        // units of KeTimeIncrement
        //
        PoPrint(
            PO_THROTTLE,
            ("PopCalculatePerfIncreaseDecreaseTime: (%d) %d%% IncreaseTime %d us\n",
             i,
             PerfStates[i].PercentFrequency,
             time
             )
            );
        PerfStates[i].IncreaseTime = time * US2TIME / tickRate + 1;
    }

#if DBG
    for (i = 0; i < PerfStatesCount; i++) {

        PoPrint(
            PO_THROTTLE,
            ("PopCalculatePerfIncreaseDecreaseTime: (%d) %d%% IncreaseTime: %d DecreaseTime: %d\n",
             i,
             PerfStates[i].PercentFrequency,
             PerfStates[i].IncreaseTime,
             PerfStates[i].DecreaseTime
             )
            );

    }
#endif

}

VOID
PopCalculatePerfIncreaseLevel(
    IN  PPROCESSOR_PERF_STATE   PerfStates,
    IN  ULONG                   PerfStatesCount
    )
/*++

Routine Description:

    This routine calculate the lower bounds for each perf state

Arguments:

    PerfStates      - Array of Performance States
    PerfStatesCount - Number of element in array

Return Value:

    None

--*/
{
    ULONG   i;
    ULONG   deltaPerf;

    PAGED_CODE();

    //
    // Sanity check
    //
    if (PerfStatesCount == 0) {

        return;

    }

    //
    // This guarantees that we cannot promote past this state
    //
    PerfStates[0].IncreaseLevel = POWER_PERF_SCALE + 1;

    //
    // Calculate the base increase level
    //
    for (i = 1; i < PerfStatesCount; i++) {

        //
        // it should be noted that for the decrease level, the
        // deltaperf level calculated maybe different than the
        // deltaperf level calculated for the increase level. This
        // is due to how we walk the array and is non-trivial to fix.
        //
        deltaPerf = PerfStates[i-1].PercentFrequency -
            PerfStates[i].PercentFrequency;
        deltaPerf *= PopPerfIncreasePercentModifier;
        deltaPerf /= POWER_PERF_SCALE;
        deltaPerf += PopPerfIncreaseAbsoluteModifier;

        //
        // We cannot cause the increase level to goto 0, so, if we work
        // out mathematically that this would happen, then the safe thing
        // to do is not allow for promotion out of this state...
        //
        if (deltaPerf > PerfStates[i].PercentFrequency) {

            deltaPerf = POWER_PERF_SCALE + 1;

        } else {

            deltaPerf = PerfStates[i].PercentFrequency - deltaPerf;

        }

        //
        // Set the decrease level to the appropiate value
        //
        PerfStates[i].IncreaseLevel = (UCHAR) deltaPerf;

    }

#if DBG
    for (i = 0; i < PerfStatesCount; i++) {

        PoPrint(
            PO_THROTTLE,
            ("PopCalculatePerfIncreaseLevel: (%d) %d%% IncreaseLevel: %d%%\n",
             i,
             PerfStates[i].PercentFrequency,
             PerfStates[i].IncreaseLevel
             )
            );

    }
#endif

}

VOID
PopCalculatePerfMinCapacity(
    IN  PPROCESSOR_PERF_STATE   PerfStates,
    IN  ULONG                   PerfStatesCount
    )
/*++

Routine Description:

    This routine is called to determine what the mininum battery capacity
    is for each of the states supported.

Arguments:

    PerfStates      - The states that this processor supports
    PerfStatesCount - The number of states that this processor supports
    PState          - Power Information about the current processor

Return Value:

    None

--*/
{
    UCHAR   i;
    UCHAR   kneeThrottleIndex = 0;
    UCHAR   num;
    UCHAR   total = (UCHAR) PopPerfDegradeThrottleMinCapacity;
    UCHAR   width = 0;

    PAGED_CODE();

    //
    // Sanity check...
    //
    if (!PerfStatesCount) {

        return;

    }

    //
    // Calculate the knee of the curve ... this is quick and avoids
    // having to pass this information around
    //
    for (i = (UCHAR) PerfStatesCount ; i >= 1; i--) {

        if (PerfStates[i-1].Flags & POP_THROTTLE_NON_LINEAR) {

            kneeThrottleIndex = i-1;
            break;

        }

    }

    //
    // Look at all the states that occur before the knee in the curve
    //
    for (i = 0; i < kneeThrottleIndex; i++) {

        //
        // Any of these steps can only run when the battery is at 100%
        //
        PerfStates[i].MinCapacity = 100;

    }

    //
    // Calculate the range for which we will clamp down the throttle.
    // Note that we are currently using a linear algorithm, but this
    // can be changed relatively easily...
    //
    num = ( (UCHAR)PerfStatesCount - kneeThrottleIndex);
    if (num != 0) {

        //
        // We do this here to avoid potential divide by zero errors.
        // What are are trying to accomplish is figure out how much
        // capacity we lose during each "step"
        //
        width = total / num;

    }

    //
    // Look at all the states from the knee of the curve to the end.
    // Starting at the highest state, set the min capacity and
    // subtract the appropriate value to get the capacity for the next
    // state
    //
    for (i = kneeThrottleIndex; i < PerfStatesCount; i++) {

        //
        // We put a floor onto how low we can force the throttle
        // down to. If this state is operating below that floor,
        // then we should set the MinCapacity to 0, which
        // reflects the fact that we don't want to degrade beyond this
        // point
        //
        if (PerfStates[i].PercentFrequency < PopPerfDegradeThrottleMinCapacity) {

            PoPrint(
                PO_THROTTLE,
                ("PopCalculatePerMinCapacity: (%d) %d%% below MinCapacity %d%%\n",
                 i,
                 PerfStates[i].PercentFrequency,
                 PopPerfDegradeThrottleMinCapacity
                 )
                );

            //
            // We modify the min capacity for the previous state since we
            // don't want to demote from that state. Also, once we start
            // being less than the min frequency, the min capacity will
            // always be 0 except for the last state. But that's okay
            // since we will look at each state in order. We also have
            // to make sure that we don't violate the array bounds, but
            // that can only happen if the perf states array is badly formed
            // or the min frequency is badly formed
            //
            if (i != 0 && PerfStates[i-1].PercentFrequency < PopPerfDegradeThrottleMinCapacity) {

                PerfStates[i-1].MinCapacity = 0;

            }
            PerfStates[i].MinCapacity = 0;
            continue;

        }

        PerfStates[i].MinCapacity = total;
        total = (UCHAR)(total - width);

    }

#if DBG
    for (i = 0; i < PerfStatesCount; i++) {

        PoPrint(
            PO_THROTTLE,
            ("PopCalculatePerfMinCapacity: (%d) %d%% MinCapacity: %d%%\n",
             i,
             PerfStates[i].PercentFrequency,
             PerfStates[i].MinCapacity
             )
            );

    }
#endif

}

UCHAR
PopGetThrottle(
    VOID
    )
/*++

Routine Description:

    Based on the current throttling policy and power state, returns
    the CPU throttle to be used (between PO_MIN_MIN_THROTTLE and 100)

Arguments:

    None

Return Value:

    Throttle to be used. Range is PO_MIN_MIN_THROTTLE (slowest) to 100 (fastest)

--*/

{
    PAGED_CODE();

    return(PopPolicy->ForcedThrottle);
}

VOID
PopPerfHandleInrush(
    IN  BOOLEAN EnableHandler
    )
/*++

Routine Description:

    This routine is responsible for enabling/disabling support for handling
    the case where we are processing an inrush irp

    In the enable case, it sets a bit in each PRCB (using an IPI) and
    forces an update on the current throttle *only*

Arguments:

    EnableHandler   - TRUE if we are processing an Inrush irp, false otherwise

Return Value:

    None

--*/
{
    KIRQL   oldIrql;

    //
    // Set the proper bit on all the processors
    //
    PopSetPerfFlag( PSTATE_DISABLE_THROTTLE_INRUSH, !EnableHandler );

    //
    // Make sure we are running at DPC level (to avoid pre-emption)
    //
    KeRaiseIrql ( DISPATCH_LEVEL, &oldIrql );

    //
    // Force an update on the current processor
    //
    PopUpdateProcessorThrottle();

    //
    // Done
    //
    KeLowerIrql( oldIrql );
}

VOID
PopPerfIdle(
    IN  PPROCESSOR_POWER_STATE  PState
    )
/*++

Routine Description:

    This routine is responsible for promoting or demoting the processor
    between various performance levels. It can *only* be called from within
    the context of the idle handler and the appropriate target processor

Arguments:

    PState  - power state of the processor that is idle

Return Value:

    None

--*/
{
    BOOLEAN                 forced = FALSE;
    BOOLEAN                 promoted = FALSE;
    BOOLEAN                 demoted = FALSE;
    PKPRCB                  prcb;
    PPROCESSOR_PERF_STATE   perfStates;
    UCHAR                   currentPerfState;
    UCHAR                   freq;
    UCHAR                   i;
    UCHAR                   j;
    ULONG                   idleTime;
    ULONG                   perfStatesCount;
    ULONG                   time;
    ULONG                   timeDelta;

    //
    // Sanity checks
    //
    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( KeGetCurrentPrcb() == CONTAINING_RECORD( PState, KPRCB, PowerState ) );

    //
    // This piece of code really belongs in the functions that will eventually
    // call this one, PopIdle0 or PopProcessorIdle, to save a function call.
    //
    if (!(PState->Flags & PSTATE_ADAPTIVE_THROTTLE) ) {

        return;

    }

    //
    // Has enough time expired?
    //
    prcb = CONTAINING_RECORD( PState, KPRCB, PowerState );
    time = POP_CUR_TIME(prcb);
    idleTime = prcb->IdleThread->KernelTime;
    timeDelta = time - PState->PerfSystemTime;
    if (timeDelta < PopPerfTimeTicks) {

        return;

    }

    //
    // Remember what our perf states are...
    //
    perfStates = PState->PerfStates;
    perfStatesCount = PState->PerfStatesCount;

    //
    // Find which bucket we are currently using to get current frequency
    //
    currentPerfState = PState->CurrentThrottleIndex;
    i = currentPerfState;

    //
    // At this point, we need to see if the number of C3 transitions have
    // exceeded a threshold value, and if so, then we really need to
    // throttle back to the KneeThrottleIndex since we save more power if
    // the processor is at 100% and in C3 then if the processor at 12.5%
    // busy and in C3. Make sure to remember the value for user informational
    // purposes.
    //
    freq = PopCalculateC3Percentage( PState );
    PState->LastC3Percentage = freq;
    if (freq >= PopPerfMaxC3Frequency &&
        !(PState->Flags & PSTATE_THERMAL_THROTTLE_APPLIED)) {

        //
        // Set the throttle to the lowest knee in the
        // the voltage and frequency curve
        //
        i = PState->KneeThrottleIndex;
        if (currentPerfState > i) {

            promoted = TRUE;

        } else if (currentPerfState < i) {

            demoted = TRUE;

        }

        //
        // remember why we are doing this
        //
        forced = TRUE;

        //
        // Skip directly to setting the throttle
        //
        goto PopPerfIdleSetThrottle;

    }

    //
    // Calculate how busy the CPU is
    //
    freq = PopCalculateBusyPercentage( PState );

    //
    // Have we exceeded the thermal throttle limit?
    //
    j = PState->ThermalThrottleIndex;
    if (freq > perfStates[j].IncreaseLevel) {

        //
        // The following code will force the frequency to be only
        // as busy as the thermal throttle limit will actually allow.
        // This removes the need for complicated algorithms later on
        //
        freq = perfStates[j].IncreaseLevel;
        i = j;

        //
        // Additionally if we are over our thermal limit, that's important
        // enough that we should ignore the time checks when deciding to
        // demote
        //
        forced = TRUE;

    }

    //
    // Is there an upper limit to what the throttle can goto?
    // Note that because we check these after we have checked the
    // thermal limit, it means that it is not possible for the
    // frequency to exceed the thermal limit that was specified
    //
    if (PState->Flags & PSTATE_DEGRADED_THROTTLE) {

        //
        // Make sure that we don't exceed the state that is specified
        //
        j = PState->ThrottleLimitIndex;
        if (freq >= perfStates[j].IncreaseLevel) {

            //
            // We must make a special allowance that says that if
            // if we are in a higher performance state then we are
            // permitted, then we must switch to the 'proper' state
            //
            forced = TRUE;
            freq = perfStates[j].IncreaseLevel;
            i = j;

        }

    } else if (PState->Flags & PSTATE_CONSTANT_THROTTLE) {

        j = PState->KneeThrottleIndex;
        if (freq >= perfStates[j].IncreaseLevel) {

            //
            // We must make a special allowance that says that if
            // if we are in a higher performance state then we are
            // permitted, then we must switch to the 'proper' state
            //
            forced = TRUE;
            freq = perfStates[j].IncreaseLevel;
            i = j;

        }

    } else if (!(PState->Flags & PSTATE_THERMAL_THROTTLE_APPLIED)) {

        //
        // This is the case that we are running in Adaptive throttle
        // mode and we need to make sure to clean up after switching
        // out of constant or degraded throttle mode...
        //
        //
        // If we are not in degraded throttle mode, then the min level
        // cannot be lower than the KneeThrottleIndex
        //
        if ( (i > PState->KneeThrottleIndex) ) {

            //
            // Promote to the knee of the curve
            //
            forced = TRUE;
            i = PState->KneeThrottleIndex;
            freq = perfStates[i].IncreaseLevel;

        }

    }

    //
    // Determine if there was a promotion or demotion in the previous...
    //
    if (i < currentPerfState) {

        promoted = TRUE;

    } else if (i > currentPerfState) {

        demoted = TRUE;

    }

    PoPrint(
        PO_THROTTLE_DETAIL,
        ("PopPerfIdle: Freq = %d%% (Adjusted)\n",
         freq
         )
        );

    //
    // Remember this value for user information purposes
    //
    PState->LastAdjustedBusyPercentage = freq;

    //
    // Find the processor frequency that best matches the one that we
    // have just calculated. Please note that the algorithm is written
    // in such a way that "i" can only travel in a single direction. It
    // is possible to collapse the following code down, but not without
    // allowing the possibility of "i" doing a "yo-yo" between two states
    // and thus never terminating the while loop.
    //
    if (perfStates[i].IncreaseLevel < freq) {

        //
        // Now, we must handle the cases where there are multiple voltage
        // steps above the knee in the curve and the case where there might
        // be frequency steps between the voltage steps. The easiest way
        // to do that is use to two indexes to look at the steps. We use
        // "j" to look at all of the steps and "i" to remember which one
        // we desired last.
        //
        j = i;
        while (perfStates[j].IncreaseLevel < freq) {

            //
            // Can we actually promote any further?
            //
            if (j == 0) {

                break;

            }

            //
            // Walk the state table. If we are in a degraded policy, then
            // this is automatically a promotion, otherwise, it is only a
            // promotion if the target state is marked as non-linear...
            //
            j--;
            if ((PState->Flags & PSTATE_DEGRADED_THROTTLE) ||
                (perfStates[j].Flags & POP_THROTTLE_NON_LINEAR)) {

                i = j;
                promoted = TRUE;

            }

        }

    } else if (perfStates[i].DecreaseLevel > freq) {

        //
        // We need the same logic as in the promote case. That is, we need
        // to walk the state table with two variables. The first one is the
        // current state and the second one remembers the one that the system
        // should transition too
        //
        j = i;
        do {

            if (j == (perfStatesCount - 1) ) {

                //
                // Can't demote further
                //
                break;

            }

            //
            // Walk the state table. If we are in a degraded policy, then
            // this is automatically a demotion, otherwise, it is only a
            // demotion if the target state is marked as non-linear
            //
            j++;
            if ((PState->Flags & PSTATE_DEGRADED_THROTTLE) ||
                (perfStates[j].Flags & POP_THROTTLE_NON_LINEAR) ) {

                i = j;
                demoted = TRUE;

            }

        } while ( perfStates[j].DecreaseLevel > freq );

    }

PopPerfIdleSetThrottle:

    //
    // We have to make special allowances if we were forced to throttle
    // because of various considerations (C3, thermal, degrade, constant)
    //
    if (!forced) {

        //
        // See if enough time has expired to justify changing
        // the throttle. This code is here because certain transitions
        // are fairly expensive (like those across a voltage state) while
        // others are fairly cheap. So the amount of time required before
        // we will consider promotion/demotion from the expensive states
        // might be longer than the interval at which we will run this
        // function
        //
        if ((promoted && timeDelta < perfStates[currentPerfState].IncreaseTime) ||
            (demoted  && timeDelta < perfStates[currentPerfState].DecreaseTime)) {

            //
            // We haven't had enough time in the current state to justify
            // the promotion or demotion. We don't update the bookkeeping
            // since we haven't considered the current interval as
            // as "success". So, we just return.
            //
            // N.B. It is very important that we don't update PState->
            // PerfSystemTime here. If we did, then it is possible that
            // TimeDelta would never exceed the required threshold
            //

            //
            // Base our actions for the timer based upon the current
            // state instead of the target state
            //
            PopSetTimer( PState, currentPerfState );
            return;

        }

    }

    PoPrint(
        PO_THROTTLE_DETAIL,
        ("PopPerfIdle: Index: %d vs %d (%s)\n",
         i,
         currentPerfState,
         (promoted ? "promoted" : (demoted ? "demoted" : "no change") )
         )
        );

    //
    // Note that we need to do this now because we dont want to exit this
    // path without having set or cancelled the timer as appropariate.
    //
    PopSetTimer( PState, i );

    //
    // Update the promote/demote count
    //
    if (promoted) {

        perfStates[currentPerfState].IncreaseCount++;
        PState->PromotionCount++;

    } else if (demoted) {

        perfStates[currentPerfState].DecreaseCount++;
        PState->DemotionCount++;

    } else {

        //
        // At this point, we realize that aren't promoting or demoting
        // and in fact, keeping the same performance level. So we should
        // just update the bookkeeping and return
        //
        PState->PerfIdleTime = idleTime;
        PState->PerfSystemTime = time;
        PState->PreviousC3StateTime = PState->TotalIdleStateTime[2];
        return;

    }

    PoPrint(
        PO_THROTTLE,
        ("PopPerfIdle: Index=%d (%d%%) %ld (dSystem) %ld (dIdle)\n",
         i,
         perfStates[i].PercentFrequency,
         (time - PState->PerfSystemTime),
         (idleTime - PState->PerfIdleTime)
         )
        );

    //
    // We have a new throttle. Update the bookkeeping to reflect the
    // amount of time that we spent in the previous state and reset the
    // count for the next state
    //
    PopSetThrottle(
        PState,
        perfStates,
        i,
        time,
        idleTime
        );
}

VOID
PopPerfIdleDpc(
    IN  PKDPC   Dpc,
    IN  PVOID   DpcContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )
/*++

Routine Description:

    This routine is run when the OS is worried that the CPU is not running
    at the maximum possible frequency and needs to be checked because the
    Idle loop will not be run anytime soon

Arguments:

    Dpc         - the dpc object
    DpcContext  - pointer to the current processors PRCB
    SysArg1     - not used
    SysArg2     - not used

Return Value:

    None

--*/
{
    PKPRCB                  prcb;
    PKTHREAD                idleThread;
    PPROCESSOR_PERF_STATE   perfStates;
    PPROCESSOR_POWER_STATE  pState;
    UCHAR                   currentPerfState;
    UCHAR                   freq;
    UCHAR                   i;
    ULONG                   idleTime;
    ULONG                   time;
    ULONG                   timeDelta;

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // We need to fetch the PRCB and the PState structres. We could
    // easily call KeGetCurrentPrcb() here but since we had room for a
    // single argument, why bother making inline call (which generates
    // more code and runs more slowly than using the context field). The
    // memory for the context field is already allocated anyways
    //
    prcb = (PKPRCB) DpcContext;
    pState = &(prcb->PowerState);

    //
    // Remember what the perf states are...
    //
    perfStates = pState->PerfStates;
    currentPerfState = pState->CurrentThrottleIndex;

    //
    // Make sure that we have some perf states to reference. Its possible
    // that the watchdog fired and in the mean time, the kernel received
    // notification to switch the state table
    //
    if (perfStates == NULL) {

        //
        // Note that we don't setup the timer to fire again. This is to
        // deal with the case where perf states go away and never come back
        //
        return;

    }

    //
    // Lets see if enough kernel time has expired since the last check
    //
    time = POP_CUR_TIME(prcb);
    timeDelta = time - pState->PerfSystemTime;
    if (timeDelta < PopPerfCriticalTimeTicks) {

        PopSetTimer( pState, currentPerfState );
        return;


    }

    //
    // We will need to remember these values if we set a new state
    //
    idleThread = prcb->IdleThread;
    idleTime = idleThread->KernelTime;

    //
    // Assume that if we got to this point, that we are at 100% busy.
    // We do this because if this routine runs, then its clear that
    // the idle loop isn't getting a chance to run, and thus, we are
    // busy.
    //
    i = 0;
    freq = perfStates[0].PercentFrequency;

    //
    // We might as well cancel the timer --- for sanity's sake
    //
    KeCancelTimer( (PKTIMER) &(pState->PerfTimer) );

    //
    // Have we exceeded the thermal throttle limit?
    //
    if (freq > pState->ThermalThrottleLimit) {

        //
        // The following code will force the frequency to be only
        // as busy as the thermal throttle limit will actually allow.
        // This removes the need for complicated algorithms later on
        //
        freq = pState->ThermalThrottleLimit;
        i = pState->ThermalThrottleIndex;

        //
        // If we don't hit 100% due to thermal reasons, we should cause
        // the watchdog timer to reset itself
        //
        PopSetTimer( pState, currentPerfState );

    }

    //
    // Is there an upper limit to what the throttle can goto?
    // Note that because we check these after we have checked the
    // thermal limit, it means that it is not possible for the
    // frequency to exceed the thermal limit that was specified
    //
    if (pState->Flags & PSTATE_DEGRADED_THROTTLE) {

        //
        // Make sure that we don't exceed the state that is specified
        //
        i = pState->ThrottleLimitIndex;
        freq = perfStates[i].PercentFrequency;
        
    } else if (pState->Flags & PSTATE_CONSTANT_THROTTLE) {

        i = pState->KneeThrottleIndex;
        freq = perfStates[i].PercentFrequency;
        
    }

    //
    // Remember these values for user information purposes
    //
    pState->LastBusyPercentage = 100;
    pState->LastAdjustedBusyPercentage = freq;

    //
    // Let the world know
    //
    PoPrint(
        PO_THROTTLE,
        ("PopPerfIdleDpc: %d%% vs %d%% (Time: %ld Delta: %ld)\n",
         freq,
         pState->CurrentThrottle,
         time,
         timeDelta
         )
        );
    PoPrint(
        PO_THROTTLE,
        ("PopPerfIdleDpc: Index=%d (%d%%) %ld (dSystem) %ld (dIdle)\n",
         i,
         perfStates[i].PercentFrequency,
         (time - pState->PerfSystemTime),
         (idleTime - pState->PerfIdleTime)
         )
        );

    //
    // Update the promote/demote count
    //
    if (i < currentPerfState) {

        perfStates[currentPerfState].IncreaseCount++;
        pState->PromotionCount++;

    } else if (i > currentPerfState) {

        perfStates[currentPerfState].DecreaseCount++;
        pState->DemotionCount++;

    } else {

        //
        // Its in theory possible for us to be running at the max
        // state when this routines gets called
        //
        return;

    }

    //
    // Set the new throttle
    //
    PopSetThrottle(
        pState,
        perfStates,
        i,
        time,
        idleTime
        );
}

VOID
PopRoundThrottle(
    IN UCHAR Throttle,
    OUT OPTIONAL PUCHAR RoundDown,
    OUT OPTIONAL PUCHAR RoundUp,
    OUT OPTIONAL PUCHAR RoundDownIndex,
    OUT OPTIONAL PUCHAR RoundUpIndex
    )
/*++

Routine Description:

    Given an arbitrary throttle percentage, computes the closest
    match in the possible throttle steps. Both the lower and higher
    matches are returned.

Arguments:

    Throttle - supplies the percentage throttle

    RoundDown - Returns the closest match, rounded down.

    RoundUp - Returns the closest match, rounded up.

Return Value:

    None

--*/

{
    KIRQL                   oldIrql;
    PKPRCB                  prcb;
    PPROCESSOR_PERF_STATE   perfStates;
    PPROCESSOR_POWER_STATE  pState;
    UCHAR                   low;
    UCHAR                   lowIndex;
    UCHAR                   high;
    UCHAR                   highIndex;
    UCHAR                   i;


    //
    // We need to get the this processor's power capabilities
    //
    prcb = KeGetCurrentPrcb();
    pState = &(prcb->PowerState);

    //
    // Make sure that we are synchronized with the idle thread and
    // other routines that access these data structures
    //
    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    perfStates = pState->PerfStates;

    //
    // Does this processor support throttling?
    //
    if ((pState->Flags & PSTATE_SUPPORTS_THROTTLE) == 0) {

        low = high = Throttle;
        lowIndex = highIndex = 0;
        goto PopRoundThrottleExit;

    }
    ASSERT( perfStates != NULL );

    //
    // Check if the supplied throttle is out of range
    //
    if (Throttle < pState->ProcessorMinThrottle) {

        Throttle = pState->ProcessorMinThrottle;

    } else if (Throttle > pState->ProcessorMaxThrottle) {

        Throttle = pState->ProcessorMaxThrottle;

    }

    //
    // Initialize our search space to something reasonable...
    //
    low = high = perfStates[0].PercentFrequency;
    lowIndex = highIndex = 0;

    //
    // Look at all the available perf states
    //
    for (i = 0; i < pState->PerfStatesCount; i++) {

        if (low > Throttle) {

            if (perfStates[i].PercentFrequency < low) {

                low = perfStates[i].PercentFrequency;
                lowIndex = i;

            }

        } else if (low < Throttle) {

            if (perfStates[i].PercentFrequency <= Throttle &&
                perfStates[i].PercentFrequency > low) {

                low = perfStates[i].PercentFrequency;
                lowIndex = i;

            }

        }

        if (high < Throttle) {

            if (perfStates[i].PercentFrequency > high) {

                high = perfStates[i].PercentFrequency;
                highIndex = i;

            }

        } else if (high > Throttle) {

            if (perfStates[i].PercentFrequency >= Throttle &&
                perfStates[i].PercentFrequency < high) {

                high = perfStates[i].PercentFrequency;
                highIndex = i;

            }

        }

    }

PopRoundThrottleExit:

    //
    // Revert back to the previous IRQL
    //
    KeLowerIrql( oldIrql );

    //
    // Fill in the pointers provided by the caller
    //
    if (ARGUMENT_PRESENT(RoundUp)) {

        *RoundUp = high;
        if (ARGUMENT_PRESENT(RoundUpIndex)) {

            *RoundUpIndex = highIndex;

        }

    }
    if (ARGUMENT_PRESENT(RoundDown)) {

        *RoundDown = low;
        if (ARGUMENT_PRESENT(RoundDownIndex)) {

            *RoundDownIndex = lowIndex;

        }

    }

}

VOID
PopSetPerfFlag(
    IN  ULONG   PerfFlag,
    IN  BOOLEAN Clear
    )
/*++

Routine Description:

    There are certain times when we want to set certain flags for each
    processor. This function will safely set or clear the specified flag

Arguments:

    PerfFlag    - The bits to set or clear
    Clear       - Should we set or clear

Return Value:

    None        - We can't return the old flag because they are allowed to
                  vary in the case that its an MP system...

--*/
{
    PKPRCB  prcb;
    ULONG   processorNumber;
    PULONG  flags;

    //
    // For each processor in the system.
    //

    for (processorNumber = 0;
         processorNumber < MAXIMUM_PROCESSORS;
         processorNumber++) {

        prcb = KeGetPrcb(processorNumber);
        if (prcb != NULL) {

            //
            // Get the address of the PowerState.Flags field in
            // this processor's PRCB and set/clear appropriately.
            //

            flags = &prcb->PowerState.Flags;

            if (Clear) {
                RtlInterlockedClearBits(flags, PerfFlag);
            } else {
                RtlInterlockedSetBits(flags, PerfFlag);
            }
        }
    }
}

NTSTATUS
PopSetPerfLevels(
    IN PPROCESSOR_STATE_HANDLER2 ProcessorHandler
    )
/*++

Routine Description:

    Recomputes the table of processor performance levels

Arguments:

    ProcessorHandler - Supplies the processor state handler structure

Return Value:

    NTSTATUS

--*/

{
    BOOLEAN                     failedAllocation = FALSE;
    KAFFINITY                   processors;
    KAFFINITY                   currentAffinity;
    KIRQL                       oldIrql;
    NTSTATUS                    status = STATUS_SUCCESS;
    PKPRCB                      prcb;
    PPROCESSOR_PERF_STATE       perfStates = NULL;
    PPROCESSOR_PERF_STATE       tempStates;
    PPROCESSOR_POWER_STATE      pState;
    UCHAR                       freq;
    UCHAR                       kneeThrottleIndex = 0;
    UCHAR                       minThrottle;
    UCHAR                       maxThrottle;
    UCHAR                       thermalThrottleIndex = 0;
    ULONG                       i;
    ULONG                       perfStatesCount = 0;

    //
    // Default to no perf states - ie: these should be remembered
    // as not being settable
    //
    maxThrottle = minThrottle = POP_PERF_SCALE;

    //
    // The first step is to convert the data that was passed to us
    // in PROCESSOR_PERF_LEVEL format over to the PROCESSOR_PERF_STATE
    // format
    //
    if (ProcessorHandler->NumPerfStates) {

        //
        // Because we are going to allocate the perfStates array first
        // so that we can work on it, then copy it to each processor,
        // we must still allocate the memory from non-paged pool.
        // The reason being that we will raising IRQL when we are touching
        // the individual processors.
        //
        perfStatesCount = ProcessorHandler->NumPerfStates;
        perfStates = ExAllocatePoolWithTag(
            NonPagedPool,
            perfStatesCount * sizeof(PROCESSOR_PERF_STATE),
            'sPoP'
            );
        if (perfStates == NULL) {

            //
            // We can handle this case. We will set the return code to
            // an appropriate failure code and we will clean up the existing
            // processor states. The reason we do this is because this
            // function only gets called if the current states are invalid,
            // so keeping the current ones would make no sense.
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            perfStatesCount = 0;
            goto PopSetPerfLevelsSetNewStates;

        }
        RtlZeroMemory(
            perfStates,
            perfStatesCount * sizeof(PROCESSOR_PERF_STATE)
            );

        //
        // For completeness, we should make sure that the highest performance
        // state has its flag set.
        //
        perfStates[0].Flags |= POP_THROTTLE_NON_LINEAR;

        //
        // Initialize each of the PROCESSOR_PERF_STATE entries
        //
        for (i = 0; i < perfStatesCount; i++) {

            perfStates[i].PercentFrequency =
                ProcessorHandler->PerfLevel[i].PercentFrequency;

            //
            // If this is a Processor Performance State (Frequency and Voltage),
            // then mark it as a Non-Linear state.
            //
            ASSERT(ProcessorHandler->PerfLevel[i].Flags);
            if (ProcessorHandler->PerfLevel[i].Flags & PROCESSOR_STATE_TYPE_PERFORMANCE) {
              perfStates[i].Flags |= POP_THROTTLE_NON_LINEAR;
            }

        }

        //
        // Calculate the increase level, decrease level, increase time,
        // decrease time, and min capacity information
        //
        PopCalculatePerfIncreaseLevel( perfStates, perfStatesCount );
        PopCalculatePerfDecreaseLevel( perfStates, perfStatesCount );
        PopCalculatePerfMinCapacity( perfStates, perfStatesCount );
        PopCalculatePerfIncreaseDecreaseTime(
            perfStates,
            perfStatesCount,
            ProcessorHandler
            );

        //
        // Calculate where the knee in the performance curve is...
        //
        for (i = (UCHAR) perfStatesCount; i >= 1; i--) {

            if (perfStates[i-1].Flags & POP_THROTTLE_NON_LINEAR) {

                kneeThrottleIndex = (UCHAR) i-1;
                break;

            }

        }

        //
        // Find the minimum throttle value which is greater than the
        // PopIdleDefaultMinThrottle and the current maximum throttle
        //
        minThrottle = POP_PERF_SCALE;
        maxThrottle = 0;
        for (i = 0; i < perfStatesCount; i ++) {

            freq = perfStates[i].PercentFrequency;
            if (freq < minThrottle && freq >= PopIdleDefaultMinThrottle) {

                minThrottle = freq;

            }
            if (freq > maxThrottle && freq >= PopIdleDefaultMinThrottle) {

                //
                // Note that for now, the thermal throttle index should
                // be the same as the max throttle index
                //
                maxThrottle = freq;
                thermalThrottleIndex = (UCHAR) i;

            }

        }

        //
        // Make sure that we can run at *SOME* speed
        //
        ASSERT( maxThrottle >= PopIdleDefaultMinThrottle );

        //
        // Set the Time Delta and Time ticks for the idle loop based upon
        // the hardware latency...
        //
        PopPerfTimeDelta = ProcessorHandler->HardwareLatency;
        PopPerfTimeTicks = PopPerfTimeDelta * US2TIME / KeQueryTimeIncrement() + 1;

    }

PopSetPerfLevelsSetNewStates:

    //
    // At this point, we need to update the status of all the processors
    //

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    processors = KeActiveProcessors;
    currentAffinity = 1;
    while (processors) {

        if (!(processors & currentAffinity)) {

            currentAffinity <<= 1;
            continue;

        }

        //
        // Remember that we did this processor and make sure that
        // we are actually running on that processor. This ensures
        // that we are synchronized with the DPC and idle loop routines
        //
        processors &= ~currentAffinity;
        KeSetSystemAffinityThread(currentAffinity);
        currentAffinity <<= 1;

        //
        // To make sure that we aren't pre-empted, we must raise to
        // DISPATCH_LEVEL...
        //
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql );

        //
        // Get the PRCB nad PPROCESSOR_POWER_STATE structures that
        // we will need to manipulate
        //
        prcb = KeGetCurrentPrcb();
        pState = &(prcb->PowerState);

        //
        // Remember what our thermal limit is. Since we precalculate this
        // value, it doesn't matter if we have perf states or not...
        //
        pState->ThermalThrottleLimit = maxThrottle;
        pState->ThermalThrottleIndex = thermalThrottleIndex;

        //
        // Likewise, remember what the min and max throttle values for the
        // processor are. Since we precalculate these numbers, it doesn't
        // matter if processor throttling is supported or not
        //
        pState->ProcessorMinThrottle = minThrottle;
        pState->ProcessorMaxThrottle = maxThrottle;

        //
        // To get the bookkeeping to work out correctly, we will
        // set the current throttle to 0% (which isn't possible, or
        // shouldn't be...), set the current index to the last state,
        // and set the tick count to the current time
        //
        pState->PerfTickCount = POP_CUR_TIME(prcb);
        if (perfStatesCount) {

            pState->CurrentThrottleIndex = (UCHAR) (perfStatesCount - 1);
            pState->CurrentThrottle = perfStates[(perfStatesCount-1)].PercentFrequency;

        } else {

            pState->CurrentThrottle = POP_PERF_SCALE;
            pState->CurrentThrottleIndex = 0;

        }

        //
        // Reset the Knee index. This indicates where the knee
        // in the performance curve is.
        //
        pState->KneeThrottleIndex = kneeThrottleIndex;

        //
        // Reset the throttle limit index. This value ranges between the
        // knee and the end of the curve, starting with the knee.
        //
        pState->ThrottleLimitIndex = kneeThrottleIndex;

        //
        // Reset these values since it doesn't make much sense to keep
        // track of them globally instead of on a "per-perf-state" basis
        //
        pState->PromotionCount = 0;
        pState->DemotionCount = 0;

        //
        // Reset these values to something that makes sense. We can assume
        // that we started at 100% busy and 0% C3 Idle
        //
        pState->LastBusyPercentage = 100;
        pState->LastC3Percentage = 0;

        //
        // If there is already a perf state present for this processor
        // then free it. Note that since we are pre-empting everyone else
        // this should be a safe operation..
        //
        if (pState->PerfStates) {

            ExFreePool(pState->PerfStates);
            pState->PerfStates = NULL;
            pState->PerfStatesCount = 0;

        }

        //
        // At this point, we have to distinguish our behaviour based on
        // whether or not we have new perfs states...
        //
        if (perfStates) {

            //
            // We do, so lets allocate some memory and make a copy of
            // the template that we have already created. Note that we
            // wish we could allocate these structures from an NPAGED
            // lookaside list, but we can't because we don't know how many
            // elements we will need to allocate
            //
            tempStates = ExAllocatePoolWithTag(
                NonPagedPool,
                perfStatesCount * sizeof(PROCESSOR_PERF_STATE),
                'sPoP'
                );
            if (tempStates == NULL) {

                //
                // Not being able to allocate this structure is surely
                // fatal. We currently depend on the structures being
                // symmetric. I guess one way to handle this is to set
                // an error flag and then clean up all the allocations
                // once we exist this iterate-the-processors loop.
                //
                status = STATUS_INSUFFICIENT_RESOURCES;
                failedAllocation = TRUE;

                //
                // Make sure that we don't indicate that this thread
                // supports throttling
                //
                RtlInterlockedClearBits( &(pState->Flags), PSTATE_SUPPORTS_THROTTLE );
                pState->PerfSetThrottle = NULL;
                KeLowerIrql( oldIrql );
                continue;

            } else {

                //
                // Copy the template to the one associated wit hthe
                // processor
                //
                RtlCopyMemory(
                    tempStates,
                    perfStates,
                    perfStatesCount * sizeof(PROCESSOR_PERF_STATE)
                    );
                pState->PerfStates = tempStates;
                pState->PerfStatesCount = (UCHAR) perfStatesCount;

            }

            //
            // Remember that we support processor throttling.
            //
            RtlInterlockedClearBits( &(pState->Flags), PSTATE_CLEAR_MASK);
            RtlInterlockedSetBits(
                &(pState->Flags),
                (PSTATE_SUPPORTS_THROTTLE | PSTATE_NOT_INITIALIZED)
                );
            pState->PerfSetThrottle = ProcessorHandler->SetPerfLevel;

            //
            // Actually set the throttle the appropriate value (since
            // we are already running on the target processor...)
            //
            PopUpdateProcessorThrottle();

            //
            // Set Timer to make sure that if we are currently a 100% busy
            // that we don't get stuck at the state we just set.
            //
            PopSetTimer(pState, pState->CurrentThrottleIndex);

        } else {

            //
            // Remember that we do not support processor throttling.
            // Note that we don't have to call PopUpdateProcessorThrottle
            // since without a PopSetThrottle function, its a No-Op.
            //
            RtlInterlockedClearBits( &(pState->Flags), PSTATE_CLEAR_MASK);
            RtlInterlockedSetBits( &(pState->Flags), PSTATE_NOT_INITIALIZED);
            pState->PerfSetThrottle = NULL;

        }

        //
        // At this point, we are done the work for this processors and
        // we should return to our previous IRQL
        //
        KeLowerIrql( oldIrql );

    } // while

    //
    // did we fail an allocation (thus requiring a cleanup)?
    //
    if (failedAllocation) {

        processors = KeActiveProcessors;
        currentAffinity = 1;
        while (processors) {

            if (!(processors & currentAffinity)) {

                currentAffinity <<= 1;
                continue;

            }

            //
            // Do the usual setup...
            //
            processors &= ~currentAffinity;
            KeSetSystemAffinityThread(currentAffinity);
            currentAffinity <<= 1;

            //
            // We need to be running at DPC level to avoid synchronization
            // issues.
            //
            KeRaiseIrql(DISPATCH_LEVEL, &oldIrql );

            //
            // Get the power state information from the processor
            //
            prcb = KeGetCurrentPrcb();
            pState = &(prcb->PowerState);

            //
            // Set everything so that we don't support throttling
            //
            pState->ThermalThrottleLimit = POP_PERF_SCALE;
            pState->ThermalThrottleIndex = 0;
            pState->ProcessorMinThrottle = POP_PERF_SCALE;
            pState->ProcessorMaxThrottle = POP_PERF_SCALE;
            pState->CurrentThrottle      = POP_PERF_SCALE;
            pState->PerfTickCount        = POP_CUR_TIME(prcb);
            pState->CurrentThrottleIndex = 0;
            pState->KneeThrottleIndex    = 0;
            pState->ThrottleLimitIndex   = 0;

            //
            // Free the allocated structure, if any
            //
            if (pState->PerfStates) {

                //
                // For the sake of completeness, if there is a perf
                // state supported, then we should grab the highest
                // possible frequency and use that for the the call to
                // Set Throttle...
                //
                maxThrottle = pState->PerfStates[0].PercentFrequency;

                //
                // Free the structure...
                //
                ExFreePool(pState->PerfStates);

            } else {

                //
                // I guess it's possible to hit this case if we are
                // looking at the processor for which the allocation
                // failed. But the SetThrottleFunction should be null,
                // so this code might not matter.
                //
                maxThrottle = POP_PERF_SCALE;

            }
            pState->PerfStates = NULL;
            pState->PerfStatesCount = 0;

            //
            // Sanity check says that we should issue a call to set the
            // throttle back to 100% or whatever the highest freq that is
            // supported...
            //
            if (pState->PerfSetThrottle) {

                pState->PerfSetThrottle(maxThrottle);

            }

            //
            // We should actually reset the flags to indicate that
            // we support *nothing* throttle related. This should
            // prevent confusion in the DPC and/or Idle loop
            //
            RtlInterlockedClearBits( &(pState->Flags), PSTATE_CLEAR_MASK);
            pState->PerfSetThrottle = NULL;

            //
            // As usual, we should lower IRQL to what we started at
            //
            KeLowerIrql( oldIrql );

        } // while

        //
        // Make sure that we don't think we support throttling
        //
        PopCapabilities.ProcessorThrottle = FALSE;
        PopCapabilities.ProcessorMinThrottle = POP_PERF_SCALE;
        PopCapabilities.ProcessorMaxThrottle = POP_PERF_SCALE;

    } else {

        //
        // Otherwise, we succeeded, and thus we can use whatever we
        // figured out are the falues for Min/Max Throttle
        //
        PopCapabilities.ProcessorThrottle = (perfStates != NULL ? TRUE : FALSE);
        PopCapabilities.ProcessorMinThrottle = minThrottle;
        PopCapabilities.ProcessorMaxThrottle = maxThrottle;

    }

    //
    // Finally, return to the appropriate affinity
    //
    KeRevertToUserAffinityThread();

    //
    // Free the memory we allocated
    //
    if (perfStates) {

        ExFreePool(perfStates);

    }

    //
    // And return whatever status we calculated...
    //
    return status;

}


NTSTATUS
PopSetTimer(
    IN  PPROCESSOR_POWER_STATE  PState,
    IN  UCHAR                   Index
    )
/*++

Routine Description:

    This routine is only called within the PopPerfIdle loop. The purpose
    of the routine is to set the timer based upon the conditions expressed
    in the "index" case. This is the index into the processor perf states
    that we will be running for the next interval

Arguments:

    PState  - Processor Power State Information
    Index   - Index into the Processor Perf States Array

Return Value:

    STATUS_SUCCESS  - Timer Set
    STATUS_CANCELLED- Timer not Set/Cancelled

--*/
{
    NTSTATUS        status;
    LONGLONG        dueTime;

    //
    // Cancel the timer under the following conditions
    //
    if (Index == 0) {

        //
        // We are 100% throttle, so timer won't do much of anything...
        //
        KeCancelTimer( (PKTIMER) &(PState->PerfTimer) );
        status = STATUS_CANCELLED;
        PoPrint(
            PO_THROTTLE_DETAIL,
            ("PopSetTimer: Timer Cancelled (already 100%)\n")
            );

    } else if (PState->Flags & PSTATE_CONSTANT_THROTTLE &&
        Index == PState->KneeThrottleIndex) {

        //
        // We are at the maximum constant throttle allowed
        //
        KeCancelTimer( (PKTIMER) &(PState->PerfTimer) );
        status = STATUS_CANCELLED;
        PoPrint(
            PO_THROTTLE_DETAIL,
            ("PopSetTimer: Timer Cancelled (at constant)\n")
            );

    } else if (PState->Flags & PSTATE_DEGRADED_THROTTLE &&
        Index == PState->ThrottleLimitIndex) {

        //
        // We are at the maximum degraded throttle allowed
        //
        KeCancelTimer( (PKTIMER) &(PState->PerfTimer) );
        status = STATUS_CANCELLED;
        PoPrint(
            PO_THROTTLE_DETAIL,
            ("PopSetTimer: Timer Cancelled (at degrade)\n")
            );

    } else {

        //
        // No restrictions that we can think of, so set the timer. Note
        // that the semantics of KeSetTimer are useful here --- if
        // the timer has already been set, then this resets it (moves
        // it back to the non-signaled state) and recomputes the period.
        //
        dueTime = -1 * US2TIME * (LONGLONG) PopPerfCriticalTimeDelta;
        KeSetTimer(
            (PKTIMER) &(PState->PerfTimer),
            *(PLARGE_INTEGER) &dueTime,
            &(PState->PerfDpc)
            );
        status = STATUS_SUCCESS;
        PoPrint(
            PO_THROTTLE_DETAIL,
            ("PopSetTimer: Timer set for %ld hundred-nanoseconds\n",
             dueTime
             )
            );

    }

    return status;
}

NTSTATUS
PopSetThrottle(
    IN  PPROCESSOR_POWER_STATE  PState,
    IN  PPROCESSOR_PERF_STATE   PerfStates,
    IN  ULONG                   Index,
    IN  ULONG                   SystemTime,
    IN  ULONG                   IdleTime
    )
/*++

Routine Description:

    This routine is called when we want to set the throttle on the processor
    associated with the PState element. Since each processor gets a unique
    PState, this is guaranteed to only apply the throttle to a single
    processor.

    N.B. Since this routine is also responsible for updating the bookkeeping,
    then if a failure occurs when trying to set the throttle, there is no
    need to return a failure code --- the system state will have not been
    updated and the caller will (eventually) retry

    N.B. This routine can only be called at DISPATCH_LEVEL while running
    on the target processor

Arguments:

    PState      - Power State information about the target processor
    PerfStates  - Array of Perf States that apply to that processor
    Index       - Which perf state to transition to
    SystemTime  - Elapsed System Time (for bookkeeping)
    IdleTime    - Elapsed Idle Time (for bookkeeping)



--*/
{
    NTSTATUS    status;
    PKPRCB      prcb;
    PKTHREAD    thread;
    UCHAR       current = PState->CurrentThrottleIndex;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( KeGetCurrentPrcb() == CONTAINING_RECORD( PState, KPRCB, PowerState ) );
    ASSERT( PState != NULL && PerfStates != NULL );
    ASSERT( PState->PerfSetThrottle != NULL );

    PoPrint(
        PO_THROTTLE,
        ("PopSetThrottle: Index=%d (%d%%) at %ld (system) %ld (idle)\n",
         Index,
         PerfStates[Index].PercentFrequency,
         SystemTime,
         IdleTime
         )
        );

    //
    // If there is, then attempt to set it to the desired state
    //
    status = PState->PerfSetThrottle(PerfStates[Index].PercentFrequency);
    if (!NT_SUCCESS(status)) {

        //
        // We failed. Update the Error tracking bookkeeping
        //
        PState->ErrorCount++;
        PState->RetryCount++;

        //
        // No reason to update the other bookkeeping
        //
        PoPrint(
            PO_THROTTLE,
            ("PopSetThrottle: Index=%d FAILED!\n",
             Index
             )
            );
        return status;

    }

    //
    // Get the prcb so that that we can update the kernel and idle threads
    //
    prcb = KeGetCurrentPrcb();
    thread = prcb->IdleThread;
    SystemTime = POP_CUR_TIME(prcb);
    IdleTime = thread->KernelTime;
    PoPrint(
        PO_THROTTLE,
        ("PopSetThrottle: Index=%d (%d%%) now at %ld (system) %ld (idle)\n",
         Index,
         PerfStates[Index].PercentFrequency,
         SystemTime,
         IdleTime
         )
        );

    //
    // Update the bookkeeping information for the current state
    //
    if (!(PState->Flags & PSTATE_NOT_INITIALIZED) ) {

        ASSERT( current < PState->PerfStatesCount );
        PerfStates[current].PerformanceTime +=
            (SystemTime - PState->PerfTickCount);

    } else {

        //
        // We have successfully placed the CPU into a known state
        //
        RtlInterlockedClearBits( &(PState->Flags), PSTATE_NOT_INITIALIZED);

    }

    //
    // Update the current throttle information
    //
    PState->CurrentThrottle = PerfStates[Index].PercentFrequency;
    PState->CurrentThrottleIndex = (UCHAR) Index;

    //
    // Update our idea of what the current tick counts are
    //
    PState->PerfIdleTime = IdleTime;
    PState->PerfSystemTime = SystemTime;
    PState->PerfTickCount = SystemTime;

    //
    // Reset our retry count since we have succeeded in the state transition
    //
    PState->RetryCount = 0;

    //
    // Remember how much time we spent in C3 at this point
    //
    PState->PreviousC3StateTime = PState->TotalIdleStateTime[2];
    return status;
}

NTSTATUS
FASTCALL
PopThunkSetThrottle(
    IN UCHAR Throttle
    )
/*++

Routine Description:

    Thunks that converts from the old flavor of throttle setting (fixed-size steps)
    to the new flavor (percentage)

Arguments:

    Throttle - Supplies the percentage of throttle requested

Return Value:

    NTSTATUS

--*/

{
    //
    // Convert percentage back into level/scale. Add scale-1 so that we round up to recover
    // from the truncation when we did the original divide.
    //
    PopRealSetThrottle((Throttle*PopThunkThrottleScale + PopThunkThrottleScale - 1)/POP_PERF_SCALE);
    return STATUS_SUCCESS;
}


VOID
PopUpdateAllThrottles(
    VOID
    )
/*++

Routine Description:

    This is the heart of the throttling policy. This routine computes
    the correct speed for each CPU, based on all current information.
    If this speed is different than the current speed, then throttling
    is applied.

    This routine may be called from any component to trigger computing
    and applying a new throttle value.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KAFFINITY               processors;
    KAFFINITY               currentAffinity;
    KIRQL                   oldIrql;
    PPROCESSOR_POWER_STATE  pState;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    processors = KeActiveProcessors;
    currentAffinity = 1;
    while (processors) {

        if (processors & currentAffinity) {

            processors &= ~currentAffinity;
            KeSetSystemAffinityThread(currentAffinity);

            //
            // Ensure that all calls to PopUpdateProcessorThrottle
            // are done at DISPATCH_LEVEL (to properly synchronize.
            //
            KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

            //
            // Optimization: If we haven't marked the prcb->powerstate
            // as supporting throttling, then don't bother making the
            // call
            //
            pState = &(KeGetCurrentPrcb()->PowerState);
            if (pState->Flags & PSTATE_SUPPORTS_THROTTLE) {

                PopUpdateProcessorThrottle();

            }

            //
            // Return to the previous Irql
            //
            KeLowerIrql( oldIrql );

        }
        currentAffinity <<= 1;

    }
    KeRevertToUserAffinityThread();
}

VOID
PopUpdateProcessorThrottle(
    VOID
    )
/*++

Routine Description:

    Computes and applies the correct throttle speed for the current CPU.
    Affinity must be set to the CPU whose throttle is to be set.

    N.B. This function is always called at DPC level within the context
    of the target processor

Arguments:

    None

Return Value:

    None

--*/

{
    PKPRCB                  prcb;
    PPROCESSOR_PERF_STATE   perfStates;
    PPROCESSOR_POWER_STATE  pState;
    UCHAR                   index;
    UCHAR                   newLimit;
    UCHAR                   perfStatesCount;
    ULONG                   idleTime;
    ULONG                   time;

    //
    // Get the power state structure from the PRCB
    //
    prcb = KeGetCurrentPrcb();
    pState = &(prcb->PowerState);

    //
    // Sanity check
    //
    if (!(pState->Flags & PSTATE_SUPPORTS_THROTTLE)) {

        return;

    }

    //
    // Get the current information such as current throttle,
    // current throttle index, current system time, and current
    // idle time
    //
    newLimit = pState->CurrentThrottle;
    index    = pState->CurrentThrottleIndex;
    time     = POP_CUR_TIME(prcb);
    idleTime = prcb->IdleThread->KernelTime;

    //
    // We will need to refer to these frequently
    //
    perfStates = pState->PerfStates;
    perfStatesCount = pState->PerfStatesCount;

    //
    // Setup all the flags. Clear any that we might not need.
    //
    RtlInterlockedClearBits( &(pState->Flags), PSTATE_THROTTLE_MASK);

    //
    // If we are on AC, then we always want to run at the highest
    // possible speed. However, in case that we don't want to do that
    // in the future (its fairly restrictive), we can assume that the
    // AC policies set dynamic throttling to PO_THROTTLE_NONE. That way
    // if someone DOES want dynamic throttling on AC, they can just edit
    // the policy
    //
    if (PopProcessorPolicy->DynamicThrottle == PO_THROTTLE_NONE) {

        //
        // We precomputed what the max throttle should be
        //
        index = pState->ThermalThrottleIndex;
        newLimit = perfStates[index].PercentFrequency;

    } else {

        //
        // No matter what, we are taking an adaptive policy...
        //
        RtlInterlockedSetBits( &(pState->Flags), PSTATE_ADAPTIVE_THROTTLE );

        //
        // We are on DC, apply the appropriate heuristics based on
        // the dynamic throttling policy
        //
        switch (PopProcessorPolicy->DynamicThrottle) {
        case PO_THROTTLE_CONSTANT:

            //
            // We have pre-computed the optimal point on the graph already.
            // So, we might as well use it...
            //
            index = pState->KneeThrottleIndex;
            newLimit = perfStates[index].PercentFrequency;

            //
            // Set the constant flag
            //
            RtlInterlockedSetBits( &(pState->Flags), PSTATE_CONSTANT_THROTTLE );
            break;

        case PO_THROTTLE_DEGRADE:

            //
            // We calculate the limit of the degrade throttle on the fly
            //
            index = pState->ThrottleLimitIndex;
            newLimit = perfStates[index].PercentFrequency;

            //
            // Set the degraded flag
            //
            RtlInterlockedSetBits( &(pState->Flags), PSTATE_DEGRADED_THROTTLE );
            break;

        default:

            //
            // In case of the default (ie: unknown, simply dump a message)
            //
            PoPrint(
                PO_THROTTLE,
                ("PopUpdateProcessorThrottle - unimplemented "
                 "dynamic throttle %d\n",
                 PopProcessorPolicy->DynamicThrottle)
                );

            //
            // Fall through...
            //

        case PO_THROTTLE_ADAPTIVE:

            break;

        } // switch

        //
        // See if we are over the thermal limit...
        //
        ASSERT( pState->ThermalThrottleLimit >= pState->ProcessorMinThrottle );
        if (newLimit > pState->ThermalThrottleLimit) {

            PoPrint(
                PO_THROTTLE,
                ("PopUpdateProcessorThrottle - new throttle limit %d over "
                 " thermal throttle limit %d\n",
                 newLimit,
                 pState->ThermalThrottleLimit)
                );
            newLimit = pState->ThermalThrottleLimit;
            index = pState->ThermalThrottleIndex;

        }
    } // if () { } else { }

    //
    // Special Cases
    //
    if (pState->Flags & PSTATE_DISABLE_THROTTLE_INRUSH) {

        //
        // InRush power irp outstanding --- force the throttle to goto
        // the knee in the curve
        //
        index = pState->KneeThrottleIndex;
        newLimit = perfStates[index].PercentFrequency;

    } else if (pState->Flags & PSTATE_DISABLE_THROTTLE_NTAPI) {

        //
        // We are trying to do a power management API. Pick the closest
        // thing to 100% and "rush-to-wait"
        //
        index = 0;
        newLimit = perfStates[index].PercentFrequency;

    }

    //
    // Special Case to deal with the initialization problem. If this
    // flag is set, then we don't really know which processor state we
    // are currently in, so we set it without updating the bookkeeping
    //
    if (pState->Flags & PSTATE_NOT_INITIALIZED) {

        PoPrint(
            PO_THROTTLE,
            ("PopUpdateProcessorThrottle - setting CPU throttle to %d\n",
             newLimit)
            );
        PopSetThrottle(
            pState,
            perfStates,
            index,
            time,
            idleTime
            );
        return;

    }

    //
    // Apply the new throttle if there has been a change
    //
    if (newLimit != pState->CurrentThrottle) {

        PoPrint(
            PO_THROTTLE,
            ("PopUpdateProcessorThrottle - setting CPU throttle to %d\n",
             newLimit)
            );
        if (newLimit < pState->CurrentThrottle) {

            pState->DemotionCount++;
            perfStates[pState->CurrentThrottleIndex].DecreaseCount++;

        } else {

            pState->PromotionCount++;
            perfStates[pState->CurrentThrottleIndex].IncreaseCount++;

        }
        PopSetThrottle(
            pState,
            perfStates,
            index,
            time,
            idleTime
            );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\amd64\xsum.asm ===
include xsum.amd64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\ia64\xsum.s ===
#include "xsum.ia64"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\i386\xsum.asm ===
NO_XMMI equ 1
NO_OLD_FLUSHSLIST equ 1

.list
include xsum.x86
.xlist
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\volume.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    volume.c

Abstract:

    This module implements power management function releated to volume devices

Author:

    Ken Reneris (kenr) 04-April-1997

Revision History:

--*/


#include "pop.h"

typedef struct {
    LIST_ENTRY          List;
    LONG                Count;
    KEVENT              Wait;
} POP_FLUSH_VOLUME, *PPOP_FLUSH_VOLUME;

VOID
PoVolumeDevice (
    IN PDEVICE_OBJECT   DeviceObject
    );

VOID
PopFlushVolumeWorker (
    IN PPOP_FLUSH_VOLUME    Flush
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PoVolumeDevice)
#pragma alloc_text(PAGE,PopFlushVolumes)
#pragma alloc_text(PAGE,PopFlushVolumeWorker)
#endif


VOID
PoVolumeDevice (
    IN PDEVICE_OBJECT   DeviceObject
    )
/*++

Routine Description:

    Called for any device object which gets allocated a VPB.
    The power policy manager keeps a list of all such device objects
    in order to flush all volumes before putting the system to sleep

Arguments:

    DeviceObject    - The volume device object

Return Value:

    None

--*/
{
    PDEVICE_OBJECT_POWER_EXTENSION  Dope;

    Dope = PopGetDope(DeviceObject);
    if (Dope) {
        PopAcquireVolumeLock ();
        if (!Dope->Volume.Flink) {
            InsertTailList (&PopVolumeDevices, &Dope->Volume);
        }
        PopReleaseVolumeLock ();
    }
}


VOID
PopFlushVolumes (
    VOID
    )
/*++

Routine Description:

    Called to flush all volumes.

Arguments:

    None

Return Value:

    None

--*/
{
    PDEVICE_OBJECT_POWER_EXTENSION  Dope;
    PLIST_ENTRY                     Link;
    POP_FLUSH_VOLUME                Flush;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    NTSTATUS                        Status;
    HANDLE                          Thread;
    ULONG                           i;
    UNICODE_STRING                  RegistryName;
    HANDLE                          Key;

    Flush.Count = 1;
    InitializeListHead (&Flush.List);
    KeInitializeEvent (&Flush.Wait, NotificationEvent, FALSE);

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);

    //
    // Move volumes onto flush work queue
    //

    PopAcquireVolumeLock ();
    Link = PopVolumeDevices.Flink;
    while (Link != &PopVolumeDevices) {
        Dope = CONTAINING_RECORD (Link, DEVICE_OBJECT_POWER_EXTENSION, Volume);
        Link = Link->Flink;

        if (!(Dope->DeviceObject->Vpb->Flags & VPB_MOUNTED) ||
            (Dope->DeviceObject->Characteristics & FILE_FLOPPY_DISKETTE) ||
            (Dope->DeviceObject->Characteristics & FILE_READ_ONLY_DEVICE) ||
            (Dope->DeviceObject->Vpb->RealDevice &&
             Dope->DeviceObject->Vpb->RealDevice->Characteristics & FILE_FLOPPY_DISKETTE)) {

            //
            // Skip this device, there is no point in flushing it.
            //
        } else {
            RemoveEntryList (&Dope->Volume);
            InsertTailList (&Flush.List, &Dope->Volume);
        }
    }

    //
    // Allocate worker threads to flush volumes
    //

    i = Flush.Count;
    if (i > 8) {
        i = 8;
    }

    while (i) {
        i -= 1;
        Status = PsCreateSystemThread(&Thread,
                                      THREAD_ALL_ACCESS,
                                      &ObjectAttributes,
                                      0L,
                                      NULL,
                                      PopFlushVolumeWorker,
                                      &Flush);
        if (NT_SUCCESS(Status)) {
            Flush.Count += 1;
            NtClose (Thread);
        }
    }
    PopReleaseVolumeLock ();

    //
    // Flush the registry as well.
    //
    RtlInitUnicodeString(&RegistryName, L"\\Registry");
    InitializeObjectAttributes(&ObjectAttributes,
                               &RegistryName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);
    Status = ZwOpenKey(&Key,
                       KEY_READ,
                       &ObjectAttributes);
    if (NT_SUCCESS(Status)) {
        ZwFlushKey(Key);
        ZwClose(Key);
    }

    //
    // Verify work in complete
    //

    PopFlushVolumeWorker (&Flush);
    KeWaitForSingleObject (&Flush.Wait, Suspended, KernelMode, TRUE, NULL);
}


VOID
PopFlushVolumeWorker (
    IN PPOP_FLUSH_VOLUME    Flush
    )
/*++

Routine Description:

    Worker routine for PopFlushVolumes to flush a single volume

Arguments:

    None

Return Value:

    None

--*/
{
    PDEVICE_OBJECT_POWER_EXTENSION  Dope;
    PLIST_ENTRY                     Link;
    NTSTATUS                        Status;
    UCHAR                           Buffer[512];
    POBJECT_NAME_INFORMATION        ObName;
    ULONG                           len;
    IO_STATUS_BLOCK                 IoStatus;
    OBJECT_ATTRIBUTES               objA;
    HANDLE                          handle;

    PopAcquireVolumeLock ();

    while (!IsListEmpty (&Flush->List)) {
        Link = Flush->List.Flink;
        RemoveEntryList (Link);
        InsertTailList (&PopVolumeDevices, Link);
        PopReleaseVolumeLock ();

        Dope = CONTAINING_RECORD (Link, DEVICE_OBJECT_POWER_EXTENSION, Volume);

        //
        // Get the name of this object
        //

        ObName = (POBJECT_NAME_INFORMATION) Buffer;
        Status = ObQueryNameString (
                    Dope->DeviceObject,
                    ObName,
                    sizeof (Buffer),
                    &len
                    );

        if (NT_SUCCESS(Status) && ObName->Name.Buffer) {

            //
            // Open the volume
            //

            InitializeObjectAttributes (
                &objA,
                &ObName->Name,
                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                0,
                0
                );

            Status = ZwCreateFile (
                        &handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &objA,
                        &IoStatus,
                        NULL,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN,
                        0,
                        NULL,
                        0
                    );

            if (NT_SUCCESS(Status)) {

                //
                // Flush the volume
                //

                ZwFlushBuffersFile (handle, &IoStatus);

                //
                // Close the reference to the volume
                //

                ZwClose (handle);
            }
        }

        PopAcquireVolumeLock ();
    }

    Flush->Count -= 1;
    if (Flush->Count == 0) {
        KeSetEvent (&Flush->Wait, IO_NO_INCREMENT, FALSE);
    }

    PopReleaseVolumeLock ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\tests\bfile\bfile.c ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1988-1991		**/ 
/*****************************************************************/ 

#include <stdio.h>
#include <process.h>
#include <setjmp.h>
#include <stdlib.h>

#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define PAGE_SIZE 4096


UCHAR   Buffer[PAGE_SIZE];


VOID
BlastFile (
    IN PUCHAR   FName
    )
{
    FILE        *fp;
    ULONG       fsize, i;


    fp = fopen(FName, "r+b");
    if (!fp) {
        printf ("File %s not found\n", FName);
        return ;
    }

    fseek (fp, 0, SEEK_END);
    fsize = ftell(fp);
    printf ("Blasting file %s, size = %d\n", FName, fsize);

    fseek (fp, 0, SEEK_SET);
    for (i=0; i < fsize; i += PAGE_SIZE) {
        fwrite (Buffer, PAGE_SIZE, 1, fp);
    }
    fclose (fp);
}



VOID __cdecl
main (argc, argv)
int     argc;
char    *argv[];
{
    PULONG      pl;
    ULONG       i;


    pl = (PULONG) Buffer;
    for (i=0; i < PAGE_SIZE/sizeof(ULONG); i++) {
        pl[0] = 'RNEK';
        pl ++;
    }

    BlastFile ("hiberfil.sys");
    BlastFile ("hiberfil.dbg");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\tests\qtime\qtime.c ===
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>
//#include <winbase.h>
//
//#include <nt.h>
//#include <ntrtl.h>


LARGE_INTEGER
RtlEnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    );

ULONG
RtlEnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    );




LARGE_INTEGER
test (
    IN LARGE_INTEGER    SetTime,
    IN LARGE_INTEGER    PerfFreq
    );



typedef struct _KUSER_SHARED_DATA {

    volatile ULONG TickCountLow;
    ULONG TickCountMultiplier;

    volatile ULONG ITimeLow;
    volatile ULONG ITime1High;
    volatile ULONG ITime2High;
} KUSER_SHARED_DATA;

#define MM_SHARED_USER_DATA_VA      0x7FFE0000
#define SharedUserData ((KUSER_SHARED_DATA * const) MM_SHARED_USER_DATA_VA)

__cdecl
main ()
{
    LARGE_INTEGER   SetTime, PerfFreq, PerfCount, SystemTime;
    FILETIME        FileTime;
    LARGE_INTEGER   li;

    QueryPerformanceFrequency(&PerfFreq);
    QueryPerformanceCounter(&PerfCount);

    do {
        SystemTime.HighPart = SharedUserData->ITime1High;
        SystemTime.LowPart =  SharedUserData->ITimeLow;
    } while (SystemTime.HighPart != SharedUserData->ITime2High);

    //GetSystemTimeAsFileTime(&FileTime);
    //SystemTime.HighPart = FileTime.dwHighDateTime;
    //SystemTime.LowPart = FileTime.dwLowDateTime;

    li = test (SystemTime, PerfFreq);

    printf ("Perf freq.: %08lx:%08lx\n", PerfFreq.HighPart, PerfFreq.LowPart);
    printf ("Int time..: %08lx:%08lx\n", SystemTime.HighPart, SystemTime.LowPart);
    printf ("Perf count: %08lx:%08lx\n", PerfCount.HighPart, PerfCount.LowPart);
    printf ("New perf..: %08lx:%08lx\n", li.HighPart, li.LowPart);
    li.QuadPart = li.QuadPart - PerfCount.QuadPart;
    printf ("Diff......: %08lx:%08lx\n", li.HighPart, li.LowPart);
}


LARGE_INTEGER
test (
    IN LARGE_INTEGER    SetTime,
    IN LARGE_INTEGER    PerfFreq
    )
{
    LARGE_INTEGER   PerfCount;
    ULARGE_INTEGER  li;
    LARGE_INTEGER   NewPerf;
    ULONG           cl, divisor;


    //
    // Compute performance counter for current InterruptTime
    //

    // Multiply SetTime * PerfCount and obtain 96bit result
    // in cl, li.LowPart, li.HighPart

    li.QuadPart = RtlEnlargedUnsignedMultiply (
                        (ULONG) SetTime.LowPart,
                        (ULONG) PerfFreq.LowPart
                        ).QuadPart;

    cl = li.LowPart;
    li.QuadPart = li.HighPart +
                  RtlEnlargedUnsignedMultiply (
                        (ULONG) SetTime.LowPart,
                        (ULONG) PerfFreq.HighPart
                        ).QuadPart;

    li.QuadPart = li.QuadPart +
                  RtlEnlargedUnsignedMultiply (
                        (ULONG) SetTime.HighPart,
                        (ULONG) PerfFreq.LowPart
                        ).QuadPart;

    li.HighPart = li.HighPart + SetTime.HighPart * PerfFreq.HighPart;
    printf ("Time*PerfFreq = %08x:%08x:%08x\n",
                li.HighPart,
                li.LowPart,
                cl
                );

    // Divide 96bit result by 10,000,000

    divisor = 10000000;
    NewPerf.HighPart = RtlEnlargedUnsignedDivide(li, divisor, &li.HighPart);
    li.LowPart = cl;
    NewPerf.LowPart = RtlEnlargedUnsignedDivide(li, divisor, NULL);

    return NewPerf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\tests\usermsg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by USERMSG.RC
//
#define ID_NULL                         -1
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\tests\thrd\thrd.c ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1988-1991		**/ 
/*****************************************************************/ 

#include <stdio.h>
#include <process.h>
#include <setjmp.h>

#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


struct {
    ULONG   Flags;
    PUCHAR  String;
} EsFlags[] = {
    ES_CONTINUOUS,          "Continuous",
    ES_SYSTEM_REQUIRED,     "System",
    ES_DISPLAY_REQUIRED,    "Display",
    0, NULL
} ;


PUCHAR
EsState (
    IN EXECUTION_STATE  State
    )
{
    static UCHAR text[200];
    ULONG       i;
    PUCHAR      p;
    UCHAR       c;

    p = text;
    c = '(';
    for (i=0; EsFlags[i].Flags; i++) {
        if (State & EsFlags[i].Flags) {
            p += sprintf (p, "%c%s", c, EsFlags[i].String);
            c  = '|';
        }
    }
    p += sprintf (p, ")");
    return text;
}


VOID __cdecl
main (argc, argv)
int     argc;
char    *argv[];
{
    UCHAR               s[200];
    EXECUTION_STATE     State, PriorState;
    NTSTATUS            Status;

    for (; ;) {
        printf ("con sys disp: ");
        gets (s);

        State = 0;
        if (strstr(s, "con"))       State |= ES_CONTINUOUS;
        if (strstr(s, "disp"))      State |= ES_DISPLAY_REQUIRED;
        if (strstr(s, "sys"))       State |= ES_SYSTEM_REQUIRED;

        Status = NtSetThreadExecutionState (
                        State,
                        &PriorState
                        );

        if (NT_SUCCESS(Status)) {

            printf ("PriorState:%x, Set:%x\n", PriorState, State);

            //printf ("PriorState%s, ", EsState(PriorState));
            //printf ("Set%s\n", EsState(State));


        } else {
            printf ("Failed: %x\n", Status);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\tests\shd\shd.c ===
/*****************************************************************/
/**          Microsoft LAN Manager          **/
/**        Copyright(c) Microsoft Corp., 1988-1991      **/
/*****************************************************************/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <setjmp.h>

#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

ULONG Iterations;


struct {
    ULONG   Flags;
    PUCHAR  String;
} ActFlags[] = {
    POWER_ACTION_QUERY_ALLOWED,     "QueryApps",
    POWER_ACTION_UI_ALLOWED,        "UIAllowed",
    POWER_ACTION_OVERRIDE_APPS,     "OverrideApps",
    POWER_ACTION_DISABLE_WAKES,     "DisableWakes",
    POWER_ACTION_CRITICAL,          "Critical",
    0, NULL
    };

PUCHAR
ActionS(
    IN POWER_ACTION Act
    )
{
    static  UCHAR   line[50];
            PUCHAR  p;

    switch (Act) {
        case PowerActionNone:          p = "None";          break;
        case PowerActionSleep:         p = "Sleep";         break;
        case PowerActionShutdown:      p = "Shutdown";      break;
        case PowerActionHibernate:     p = "Hibernate";     break;
        case PowerActionShutdownReset: p = "ShutdownReset"; break;
        case PowerActionShutdownOff:   p = "ShutdownOff";   break;
        default:
            sprintf(line, "Unknown action %x", Act);
            p = line;
            break;
    }

    return p;
}

PUCHAR
SysPower(
    IN SYSTEM_POWER_STATE   State
    )
{
    static  UCHAR   line[50];
            PUCHAR  p;

    switch (State) {
        case PowerSystemUnspecified:    p = "Unspecified";      break;
        case PowerSystemWorking:        p = "Working";          break;
        case PowerSystemSleeping1:      p = "S1";               break;
        case PowerSystemSleeping2:      p = "S2";               break;
        case PowerSystemSleeping3:      p = "S3";               break;
        case PowerSystemHibernate:      p = "S4 - hibernate";   break;
        case PowerSystemShutdown:       p = "Shutdown";         break;
        default:
            sprintf(line, "Unknown power state %x", State);
            p = line;
            break;
    }

    return p;
}


PUCHAR
Action (
    IN PBOOLEAN CapFlag,
    IN PPOWER_ACTION_POLICY Act
    )
{
    static UCHAR text[200];
    PUCHAR  p;
    UCHAR   c;
    ULONG   i;

    p = text;

    if (CapFlag && !*CapFlag) {
        p += sprintf(p, "Disabled ");
    }

    p += sprintf (p, "%s", ActionS(Act->Action));
    if (Act->Action != PowerActionNone  &&  Act->Flags) {
        c = '(';
        for (i=0; ActFlags[i].Flags; i++) {
            if (Act->Flags & ActFlags[i].Flags) {
                p += sprintf (p, "%c%s", c, ActFlags[i].String);
                c  = '|';
            }
        }
        p += sprintf (p, ")");
    }

    if (Act->EventCode) {
        p += sprintf (p, "-Code=%x", Act->EventCode);
    }

    return text;
}

VOID
SetTimerTime (
    IN HANDLE   h,
    IN PUCHAR   Text,
    IN ULONG    DueTimeInMin
    )
{
    LARGE_INTEGER       SystemTime;
    LARGE_INTEGER       DueTime;
    BOOL                Status;
    SYSTEMTIME          TimeFields;
    UCHAR               s[200];

    NtQuerySystemTime (&SystemTime);
    GetSystemTime (&TimeFields);

    sprintf (s, "%d. Current time is:  %d:%d:%d, ",
        Iterations,
        TimeFields.wHour,
        TimeFields.wMinute,
        TimeFields.wSecond
        );
    printf(s);
    DbgPrint("SHD: %s", s);

    TimeFields.wMinute += (USHORT) DueTimeInMin;
    while (TimeFields.wMinute > 59) {

        TimeFields.wMinute -= 60;
        TimeFields.wHour += 1;

    }

    sprintf (s, "timer set for %d:%d:%d (%d min)  %s",
        TimeFields.wHour,
        TimeFields.wMinute,
        TimeFields.wSecond,
        DueTimeInMin,
        Text
        );
    printf(s);
    DbgPrint(s);

    //
    // Set timer as relative
    //

    DueTime.QuadPart = (ULONGLONG) -600000000L * DueTimeInMin;
    Status = SetWaitableTimer (
                h,
                &DueTime,
                0,
                NULL,
                NULL,
                TRUE
                );

    if (!Status) {

        printf ("\nSetWaitableTimer failed with %x\n", GetLastError());
        DbgPrint ("\nSetWaitableTimer failed with %x\n", GetLastError());
        exit (1);

    }
}


VOID __cdecl
main (argc, argv)
int     argc;
char    *argv[];
{
    POWER_ACTION_POLICY Act;
    SYSTEM_POWER_STATE  MinSystemState;
    NTSTATUS            Status;
    PUCHAR              p;
    BOOLEAN             Asynchronous;
    BOOLEAN             MaxLoop;
    BOOLEAN             SleepLoop;
    HANDLE              hToken, SleepTimer;
    ULONG               DelayTime;
    ULONG               MaxCount;
    ULONG               Temp;
    ULONG               WakeTime;
    TOKEN_PRIVILEGES    tkp;

    OpenProcessToken (
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hToken
        );

    LookupPrivilegeValue (
        NULL,
        SE_SHUTDOWN_NAME,
        &tkp.Privileges[0].Luid
        );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges (
        hToken,
        FALSE,
        &tkp,
        0,
        NULL,
        0
    );


    RtlZeroMemory(&Act, sizeof(Act));
    MinSystemState = PowerSystemSleeping1;      
    Asynchronous = TRUE;
    SleepLoop = FALSE;
    DelayTime = 1;
    WakeTime = 2;
    Iterations = 0;

    if (argc == 1) {
        printf ("shd shutdown|off|reset|hiber|sleep|doze [sync qapp ui oapp diswake critical] [loop] [maxloop <Int>] [waitTime <InMinutes>] [delayTime <InMinutes>]\n");
        exit (1);
    }

    while (argc) {
        argc--;
        p = *argv;
        argv += 1;

        if (_stricmp(p, "shutdown") == 0)     Act.Action = PowerActionShutdown;
        if (_stricmp(p, "off") == 0)          Act.Action = PowerActionShutdownOff;
        if (_stricmp(p, "reset") == 0)        Act.Action = PowerActionShutdownReset;
        if (_stricmp(p, "hiber") == 0)        Act.Action = PowerActionHibernate;
        if (_stricmp(p, "sleep") == 0)        Act.Action = PowerActionSleep;


        if (_stricmp(p, "qapp") == 0)         Act.Flags |= POWER_ACTION_QUERY_ALLOWED;
        if (_stricmp(p, "ui"  ) == 0)         Act.Flags |= POWER_ACTION_UI_ALLOWED;
        if (_stricmp(p, "oapp") == 0)         Act.Flags |= POWER_ACTION_OVERRIDE_APPS;
        if (_stricmp(p, "diswake") == 0)      Act.Flags |= POWER_ACTION_DISABLE_WAKES;
        if (_stricmp(p, "critical") == 0)     Act.Flags |= POWER_ACTION_CRITICAL;
        if (_stricmp(p, "sync") == 0)         Asynchronous = FALSE;

        if (_stricmp(p, "loop") == 0)         SleepLoop = TRUE;
        if (_stricmp(p, "maxloop") == 0) {

            if (!argc) {

                printf("Must specify an Maximum number with MAXLOOP\n");
                exit(1);

            }
            argc--;
            p = *argv;
            argv += 1;

            Temp = atol(p);
            if (Temp) {

                MaxCount = Temp;
                SleepLoop = TRUE;
                MaxLoop = TRUE;

            }

        }
        if (_stricmp(p, "waittime") == 0) {

            if (!argc) {

                printf("Must Specify an TimeInMinutes number with WAITTIME\n");
                exit(1);

            }
            argc--;
            p = *argv;
            argv += 1;

            Temp = atol(p);
            if (Temp) {

                WakeTime = Temp;

            }

        }
        if (_stricmp(p, "delaytime") == 0) {

            if (!argc) {

                printf("Must Specify a TimeInMinutes number with DELAYTIME\n");
                exit(1);

            }
            argc--;
            p = *argv;
            argv += 1;

            Temp = atol(p);
            if (Temp) {

                DelayTime = Temp;

            }

        }

    }

    if (!SleepLoop) {
        printf ("Calling NtInitiatePowerAction %s\n",
                Asynchronous ? "asynchronous" : "synchronous"
                );
        printf ("System Action........: %s\n",  Action(NULL, &Act));
        printf ("Min system state.....: %s\n",  SysPower(MinSystemState));

        DbgPrint ("SHD: Calling NtInitiatePowerAction %s\n",
                  Asynchronous ? "asynchronous" : "synchronous"
                  );
        DbgPrint ("SHD: System Action........: %s\n",  Action(NULL, &Act));
        DbgPrint ("SHD: Min system state.....: %s\n",  SysPower(MinSystemState));

        Status = NtInitiatePowerAction (
                    Act.Action,
                    MinSystemState,
                    Act.Flags,
                    Asynchronous
                    );
        goto exit_main;

    }


    SleepTimer = CreateWaitableTimer (
                    NULL,
                    TRUE,
                    "SleepLoopTimer"
                    );

    //
    // Remember that this is iteration #0. Do the boundary condition test
    // here since we don't want to do something that the user didn't want
    // us to do, God, forbid.
    //
    Iterations = 0;
    if (MaxLoop && Iterations >= MaxCount) {

        goto exit_main;

    }

    //
    // Use a while loop here, since we don't actually make use of the
    // check unless we have the MaxLoop set
    //
    while (1) {

        //
        // Set wake timer
        //
        SetTimerTime (SleepTimer, "Wake Time", WakeTime);

        //
        // Hibernate the system
        //
        printf (" %s\n", Action(NULL, &Act));
        DbgPrint (" %s\n", Action(NULL, &Act));
        Status = NtInitiatePowerAction (
                    Act.Action,
                    MinSystemState,
                    Act.Flags,
                    FALSE
                    );

        if (!NT_SUCCESS(Status)) {

            printf ("NtInitiatePowerAction failure: %x\n", Status);
            DbgPrint ("SHD: NtInitiazePowerAction failure: %x\n", Status);
            exit (1);

        }

        //
        // Wait for wake timer
        //
        Status = WaitForSingleObject (SleepTimer, -1);
        if (!NT_SUCCESS(Status)) {

            printf ("Wake time wait failed: %x\n", Status);
            DbgPrint ("SHD: Wake time wait failed: %x\n", Status);
            exit (1);

        }

        //
        // Number of times we've been sucessfull
        //
        Iterations += 1;

        //
        // Have we exceeded the number of iterations?
        //
        if (MaxLoop && Iterations >= MaxCount) {

            break;

        }

        //
        // Delay between each loop
        //
        SetTimerTime (SleepTimer, "Delay\n", DelayTime);
        Status = WaitForSingleObject (SleepTimer, -1);
        if (!NT_SUCCESS(Status)) {

            printf ("Delay wait failed: %x\n", Status);
            DbgPrint ("SHD: Delay wait failed: %x\n", Status);
            exit (1);

        }
    }

exit_main:
    printf ("Done. Status %x\n", Status);
    DbgPrint ("SHD: Done. Status %x\n", Status);
    exit (0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\tests\ehib\ehib.c ===
/*****************************************************************
 *
 * Copyright(c) Microsoft Corp., 1988-1999
 *
 *****************************************************************/ 
#include <stdio.h>
#include <process.h>
#include <setjmp.h>
#include <stdlib.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <powrprof.h>

/*****************************************************************
 * 
 * Globals
 *
 *****************************************************************/ 
BOOLEAN Enable      = FALSE;
BOOLEAN Verbose     = FALSE; 
BOOLEAN HiberStatus = FALSE;

/*
 * PrintHelp
 *
 * DESCRIPTION: This routine prints the help message
 *
 * RETURNS: VOID
 *
 */
VOID
PrintHelp()
{
    printf ("Enables/Disables Hibernation File\n\n");
    printf ("EHIB [/e | /d] [/v] [/s]\n\n");
    printf ("\t/e\tEnable Hibernation File\n");
    printf ("\t/d\tDisable Hibernation File\n");
    printf ("\t/s\tPrint Current Hibernate File Status\n");
    printf ("\t/v\tVerbose Mode On\n\n");
}

/*
 * ParseArgs
 *
 * Description:
 *      This routine parses the input arguments and validates the
 *      command line paramters
 *
 * Returns:
 *      TRUE  if valid command line usage/syntax
 *      FALSE if invalid command line usage/syntax
 *
 */ 
BOOLEAN
ParseArgs(argc, argv)
int     argc;
char    *argv[];
{
    int         ii;
    BOOLEAN     ValidArgs;

    //
    // Assume failure
    //
    ValidArgs = FALSE;

    if (argc < 2) {
        PrintHelp();
    
    } else {
        for (ii=1; ii<argc; ii++) {
            if (!strcmp(argv[ii], "/e") || !strcmp(argv[ii], "-e")) {
                Enable      = TRUE;
                ValidArgs   = TRUE;

            } else if (!strcmp(argv[ii], "/d") || !strcmp(argv[ii], "-d")) {
                Enable      = FALSE;
                ValidArgs   = TRUE;

            } else if (!strcmp(argv[ii], "/v") || !strcmp(argv[ii], "-v")) {
                Verbose = TRUE;

            } else if (!strcmp(argv[1], "/s") || !strcmp(argv[1], "-s")) {
                HiberStatus = TRUE;
                ValidArgs   = TRUE;

            } else {
                ValidArgs = FALSE;
                break;
            }
        }
    
        if (!ValidArgs) {
            PrintHelp();
        }
    }

    return(ValidArgs);
}

/*
 * UpgradePermissions
 *
 * Description:
 *      This routine promotes the user permissions in order to allocate
 *      & deallocate the hibernation file. 
 *
 * Returns:
 *      VOID
 */
VOID 
UpgradePermissions()
{
    HANDLE              hToken;
    TOKEN_PRIVILEGES    tkp;

    OpenProcessToken (
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hToken
        );

    LookupPrivilegeValue (
        NULL,
        SE_CREATE_PAGEFILE_NAME,
        &tkp.Privileges[0].Luid
        );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges (
        hToken,
        FALSE,
        &tkp,
        0,
        NULL,
        0
    );
}


/*
 * HiberFile
 * 
 * Description:
 *      This routine allocated/deallocates the hiberfile and prints the appropriate errors messages
 *
 * Returns: 
 *      TRUE if successful
 *      FALSE if not successful
 *
 */
BOOLEAN
HiberFile()
{
    BOOLEAN                     RetStatus;
    NTSTATUS                    Status;
    SYSTEM_POWER_CAPABILITIES   SysPwrCapabilities;

    //
    // Assume Failure
    //
    RetStatus = FALSE;

    if (GetPwrCapabilities(&SysPwrCapabilities)) {
        if (!SysPwrCapabilities.SystemS4) {
            printf("System does not support S4");

        } else if (HiberStatus) {
            if (SysPwrCapabilities.HiberFilePresent) {
                printf ("Reserved Hibernation File Enabled\n");
            } else {
                printf ("Reserved Hibernation File Disabled\n");
            }

        } else if (Verbose && Enable && SysPwrCapabilities.HiberFilePresent) {
            printf ("Reserved Hibernation File Enabled\n");
            RetStatus = TRUE;

        } else if (Verbose && !Enable && !SysPwrCapabilities.HiberFilePresent) {
            printf ("Reserved Hibernation File Disabled\n");
            RetStatus = TRUE;

        } else {
            Status = NtPowerInformation (
                        SystemReserveHiberFile,
                        &Enable,
                        sizeof (Enable),
                        NULL,
                        0
                        );

            if (NT_SUCCESS(Status)) {
                if (Verbose && Enable) {
                    printf ("Reserved Hibernation File Enabled\n");
                } else if (Verbose) {
                    printf ("Reserved Hibernation File Disabled\n");
                }
                
                RetStatus = TRUE;

            } else {
                printf ("Error allocating/deallocating Hibernation file. Status = %x\n", Status);
            }
        }
    }

    return(RetStatus);
}

/*
 * main
 *
 * Description:
 *      This program allocates and deallocates the reserved hibernation file
 *
 */
int __cdecl
main (argc, argv)
int     argc;
char    *argv[];
{
    /* Assume Failure */
    int ErrorStatus = 1;

    //
    // Parse the input arguments
    //
    if (ParseArgs(argc, argv)) {
        //
        // Upgrade permissions & Allocate/Deallocate Hibernation File
        //
        UpgradePermissions();
        if (HiberFile()) {
            ErrorStatus = 0;
        } else {
            ErrorStatus = 1;
        }
    }

    return(ErrorStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\tests\usermsg\usermsg.h ===
#define IDD_STATUSDLG                   101

#define IDC_STATUSLIST                  1000
#define IDC_HANGPWRMSG                  1001
#define IDC_PASSPWRMSG                  1002
#define IDC_FAILPWRMSG                  1003


#define ID_ICON                         200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\kulookup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kulookup.c

Abstract:

    The module implements the code necessary to lookup user mode entry points
    in the system DLL for exception dispatching and APC delivery.

Author:

    David N. Cutler (davec) 8-Oct-90

Revision History:

--*/

#include "psp.h"
#pragma alloc_text(INIT, PspLookupKernelUserEntryPoints)

NTSTATUS
PspLookupKernelUserEntryPoints (
    VOID
    )

/*++

Routine Description:

    The function locates the address of the exception dispatch and user APC
    delivery routine in the system DLL and stores the respective addresses
    in the PCR.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{

    NTSTATUS Status;
    PSZ EntryName;

    //
    // Lookup the user mode "trampoline" code for exception dispatching
    //

    EntryName = "KiUserExceptionDispatcher";
    Status = PspLookupSystemDllEntryPoint(EntryName,
                                          (PVOID *)&KeUserExceptionDispatcher);
    if (!NT_SUCCESS (Status)) {
        KdPrint(("Ps: Cannot find user exception dispatcher address\n"));
        return Status;
    }

    //
    // Lookup the user mode "trampoline" code for APC dispatching
    //

    EntryName = "KiUserApcDispatcher";
    Status = PspLookupSystemDllEntryPoint(EntryName,
                                          (PVOID *)&KeUserApcDispatcher);
    if (!NT_SUCCESS (Status)) {
        KdPrint(("Ps: Cannot find user apc dispatcher address\n"));
        return Status;
    }

    //
    // Lookup the user mode "trampoline" code for callback dispatching.
    //

    EntryName = "KiUserCallbackDispatcher";
    Status = PspLookupSystemDllEntryPoint(EntryName,
                                          (PVOID *)&KeUserCallbackDispatcher);
    if (!NT_SUCCESS (Status)) {
        KdPrint(("Ps: Cannot find user callback dispatcher address\n"));
        return Status;
    }

    //
    // Lookup the user mode "trampoline" code for raising a usermode exception
    //

    EntryName = "KiRaiseUserExceptionDispatcher";
    Status = PspLookupSystemDllEntryPoint(EntryName,
                                          (PVOID *)&KeRaiseUserExceptionDispatcher);
    if (!NT_SUCCESS (Status)) {
        KdPrint(("Ps: Cannot find raise user exception dispatcher address\n"));
        return Status;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\tests\usermsg\usermsg.c ===
#include <windows.h>
#include <commctrl.h>

#include "usermsg.h"

// #define SEND_TEST_MESSAGES  1

#define RETURN_SUCCESS  0
#define RETURN_FAILURE  1
#define RETURN_HANG     2

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

HINSTANCE   g_hInstance;        // Global instance handle of this DLL.
HWND        g_hwndParent;       // Parent of the battery meter.

LPTSTR  szDebugPBT[] =
{
    TEXT("WM_POWERBROADCAST, PBT_APMQUERYSUSPEND"),
    TEXT("WM_POWERBROADCAST, PBT_APMQUERYSTANDBY"),
    TEXT("WM_POWERBROADCAST, PBT_APMQUERYSUSPENDFAILED"),
    TEXT("WM_POWERBROADCAST, PBT_APMQUERYSTANDBYFAILED"),
    TEXT("WM_POWERBROADCAST, PBT_APMSUSPEND"),
    TEXT("WM_POWERBROADCAST, PBT_APMSTANDBY"),
    TEXT("WM_POWERBROADCAST, PBT_APMRESUMECRITICAL"),
    TEXT("WM_POWERBROADCAST, PBT_APMRESUMESUSPEND"),
    TEXT("WM_POWERBROADCAST, PBT_APMRESUMESTANDBY"),
    TEXT("WM_POWERBROADCAST, PBT_APMBATTERYLOW"),
    TEXT("WM_POWERBROADCAST, PBT_APMPOWERSTATUSCHANGE"),
    TEXT("WM_POWERBROADCAST, PBT_APMOEMEVENT"),
    TEXT("WM_POWERBROADCAST, unknown"),
    TEXT("WM_POWERBROADCAST, unknown"),
    TEXT("WM_POWERBROADCAST, unknown"),
    TEXT("WM_POWERBROADCAST, unknown"),
    TEXT("WM_POWERBROADCAST, unknown"),
    TEXT("WM_POWERBROADCAST, unknown"),
    TEXT("WM_POWERBROADCAST, PBT_APMRESUMEAUTOMATIC")
};

#ifdef SEND_TEST_MESSAGES

HANDLE      g_hNotifyMsg;

#define STACKSIZE 4096

/*******************************************************************************
*
*  NotifyMsgThread
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/


DWORD  NotifyMsgThread(DWORD dwParameter)
{
    static INT wParam;

    SetThreadPriority(g_hNotifyMsg, THREAD_PRIORITY_LOWEST);

    SendMessage(g_hwndParent, WM_POWERBROADCAST, PBT_APMPOWERSTATUSCHANGE, 0);
    for (; ;) {
        Sleep(3000);
        SendMessage(g_hwndParent, WM_POWERBROADCAST, wParam, 0);
        if (++wParam > 0xC) {
            wParam = 0;
        }
    }
    return 0;
}
#endif

/*******************************************************************************
*
*  DlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL CALLBACK DlgProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    static UINT uiReturnAction;
    UINT    uiCount;

    switch (uMsg) {
        case WM_INITDIALOG:
            g_hwndParent = hWnd;
            CheckDlgButton(hWnd, IDC_PASSPWRMSG, BST_CHECKED);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_PASSPWRMSG:
                    uiReturnAction = RETURN_SUCCESS;
                    break;

                case IDC_FAILPWRMSG:
                    uiReturnAction = RETURN_FAILURE;
                    break;

                case IDC_HANGPWRMSG:
                    uiReturnAction = RETURN_HANG;
                    break;

                case IDCANCEL:
                case IDOK:
                    EndDialog(hWnd, wParam);
                    break;

            }
            break;

        case WM_POWERBROADCAST:
            if (//(wParam >= PBT_APMQUERYSUSPEND) &&  // compiler warning
                (wParam <= PBT_APMRESUMEAUTOMATIC)) {
                SendDlgItemMessage(hWnd, IDC_STATUSLIST, LB_ADDSTRING,
                                   0, (LPARAM) szDebugPBT[wParam]);
            }
            else {
                SendDlgItemMessage(hWnd, IDC_STATUSLIST, LB_ADDSTRING,
                                   0, (LPARAM) TEXT("WM_POWERBROADCAST, unknown wParam"));
            }
            uiCount = SendDlgItemMessage(hWnd, IDC_STATUSLIST, LB_GETCOUNT, 0, 0);
            if ((uiCount != LB_ERR) && (uiCount)) {
                SendDlgItemMessage(hWnd, IDC_STATUSLIST, LB_SETCURSEL, uiCount-1, 0);
            }

            switch (uiReturnAction) {
                case RETURN_HANG:
                    while (uiReturnAction == RETURN_HANG);

                case RETURN_SUCCESS:
                    SetWindowLong(hWnd, DWL_MSGRESULT, TRUE);
                    return TRUE;

                case RETURN_FAILURE:
                    SetWindowLong(hWnd, DWL_MSGRESULT, FALSE);
                    return TRUE;
            }
            break;

        case WM_DEVICECHANGE:
            SendDlgItemMessage(hWnd, IDC_STATUSLIST, LB_ADDSTRING,
                               0, (LPARAM) TEXT("WM_DEVICECHANGE"));
            break;
    }
    return FALSE;
}


/*******************************************************************************
*
*  WinMain
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT WINAPI      WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpAnsiCmdLine,
    INT         cmdShow)
{
    DWORD  dwThreadId;

#ifdef SEND_TEST_MESSAGES
    // Spin a thread to send update messages
    g_hNotifyMsg = CreateThread(NULL, STACKSIZE,
                                (LPTHREAD_START_ROUTINE) NotifyMsgThread,
                                NULL, 0, &dwThreadId);
#endif

    DialogBox(hInstance,
              MAKEINTRESOURCE(IDD_STATUSDLG),
              NULL,
              DlgProc);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\pscid.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    pscid.c

Abstract:

    This module implements the Client ID related services.


Author:

    Mark Lucovsky (markl) 25-Apr-1989
    Jim Kelly (JimK) 2-August-1990

Revision History:

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PsLookupProcessThreadByCid)
#pragma alloc_text(PAGE, PsLookupProcessByProcessId)
#pragma alloc_text(PAGE, PsLookupThreadByThreadId)
#endif //ALLOC_PRAGMA

NTSTATUS
PsLookupProcessThreadByCid(
    IN PCLIENT_ID Cid,
    OUT PEPROCESS *Process OPTIONAL,
    OUT PETHREAD *Thread
    )

/*++

Routine Description:

    This function accepts The Client ID of a thread, and returns a
    referenced pointer to the thread, and possibly a referenced pointer
    to the process.

Arguments:

    Cid - Specifies the Client ID of the thread.

    Process - If specified, returns a referenced pointer to the process
        specified in the Cid.

    Thread - Returns a referenced pointer to the thread specified in the
        Cid.

Return Value:

    STATUS_SUCCESS - A process and thread were located based on the contents
        of the Cid.

    STATUS_INVALID_CID - The specified Cid is invalid.

--*/

{

    PHANDLE_TABLE_ENTRY CidEntry;
    PETHREAD lThread;
    PETHREAD CurrentThread;
    PEPROCESS lProcess;
    NTSTATUS Status;

    PAGED_CODE();


    lThread = NULL;

    CurrentThread = PsGetCurrentThread ();
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);

    CidEntry = ExMapHandleToPointer(PspCidTable, Cid->UniqueThread);
    if (CidEntry != NULL) {
        lThread = (PETHREAD)CidEntry->Object;
        if (!ObReferenceObjectSafe (lThread)) {
            lThread = NULL;
        }
        ExUnlockHandleTableEntry(PspCidTable, CidEntry);
    }

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    Status = STATUS_INVALID_CID;
    if (lThread != NULL) {
        //
        // This could be a thread or a process. Check its a thread.
        //
        if (lThread->Tcb.Header.Type != ThreadObject ||
            lThread->Cid.UniqueProcess != Cid->UniqueProcess ||
            lThread->GrantedAccess == 0) {
            ObDereferenceObject (lThread);
        } else {
            *Thread = lThread;
            if (ARGUMENT_PRESENT (Process)) {
                lProcess = THREAD_TO_PROCESS (lThread);
                *Process = lProcess;
                //
                // Since the thread holds a reference to the process this reference does not have to
                // be protected.
                //
                ObReferenceObject (lProcess);
            }
            Status = STATUS_SUCCESS;
        }

    }

    return Status;
}


NTSTATUS
PsLookupProcessByProcessId(
    IN HANDLE ProcessId,
    OUT PEPROCESS *Process
    )

/*++

Routine Description:

    This function accepts the process id of a process and returns a
    referenced pointer to the process.

Arguments:

    ProcessId - Specifies the Process ID of the process.

    Process - Returns a referenced pointer to the process specified by the
        process id.

Return Value:

    STATUS_SUCCESS - A process was located based on the contents of
        the process id.

    STATUS_INVALID_PARAMETER - The process was not found.

--*/

{

    PHANDLE_TABLE_ENTRY CidEntry;
    PEPROCESS lProcess;
    PETHREAD CurrentThread;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_INVALID_PARAMETER;

    CurrentThread = PsGetCurrentThread ();
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);

    CidEntry = ExMapHandleToPointer(PspCidTable, ProcessId);
    if (CidEntry != NULL) {
        lProcess = (PEPROCESS)CidEntry->Object;
        if (lProcess->Pcb.Header.Type == ProcessObject &&
            lProcess->GrantedAccess != 0) {
            if (ObReferenceObjectSafe(lProcess)) {
               *Process = lProcess;
                Status = STATUS_SUCCESS;
            }
        }

        ExUnlockHandleTableEntry(PspCidTable, CidEntry);
    }

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    return Status;
}


NTSTATUS
PsLookupThreadByThreadId(
    IN HANDLE ThreadId,
    OUT PETHREAD *Thread
    )

/*++

Routine Description:

    This function accepts the thread id of a thread and returns a
    referenced pointer to the thread.

Arguments:

    ThreadId - Specifies the Thread ID of the thread.

    Thread - Returns a referenced pointer to the thread specified by the
        thread id.

Return Value:

    STATUS_SUCCESS - A thread was located based on the contents of
        the thread id.

    STATUS_INVALID_PARAMETER - The thread was not found.

--*/

{

    PHANDLE_TABLE_ENTRY CidEntry;
    PETHREAD lThread;
    PETHREAD CurrentThread;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_INVALID_PARAMETER;

    CurrentThread = PsGetCurrentThread ();
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);

    CidEntry = ExMapHandleToPointer(PspCidTable, ThreadId);
    if (CidEntry != NULL) {
        lThread = (PETHREAD)CidEntry->Object;
        if (lThread->Tcb.Header.Type == ThreadObject && lThread->GrantedAccess) {

            if (ObReferenceObjectSafe(lThread)) {
                *Thread = lThread;
                Status = STATUS_SUCCESS;
            }
        }

        ExUnlockHandleTableEntry(PspCidTable, CidEntry);
    }

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\tests\wtime\wtime.c ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1988-1991		**/ 
/*****************************************************************/ 

#include <stdio.h>
#include <process.h>
#include <setjmp.h>
#include <stdlib.h>

#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>




VOID __cdecl
main (argc, argv)
int     argc;
char    *argv[];
{
    LARGE_INTEGER       SystemTime;
    LARGE_INTEGER       DueTime;
    ULONG               DueTimeInMin;
    ULONG               i;
    HANDLE              h;
    BOOLEAN             Status;
    SYSTEMTIME          TimeFields;
    BOOLEAN             Absolute;
    PUCHAR              p;

    h = CreateWaitableTimer (
            NULL,
            TRUE,
            "TestTimer"
            );

    printf ("usage: time [-a]\n");

    Absolute = FALSE;
    DueTimeInMin = 1;

    while (argc) {
        argc--;
        p = *argv;
        argv += 1;

        i = atol(p);
        if (i) {
            DueTimeInMin = i;
        }

        if (strcmp (p, "-a") == 0) {
            Absolute = TRUE;
        }
    }

    NtQuerySystemTime (&SystemTime);
    GetSystemTime (&TimeFields);

    printf ("Current time is:  %d:%d:%d, ",
        TimeFields.wHour,
        TimeFields.wMinute,
        TimeFields.wSecond
        );

    TimeFields.wMinute += DueTimeInMin;
    while (TimeFields.wMinute > 59) {
        TimeFields.wMinute -= 60;
        TimeFields.wHour += 1;
    }

    printf ("timer set for %d:%d:%d (%d min)  %s time\n",
        TimeFields.wHour,
        TimeFields.wMinute,
        TimeFields.wSecond,
        DueTimeInMin,
        Absolute ? "absolute" : "relative"
        );


    //
    // Set timer as relative
    //

    DueTime.QuadPart = (ULONGLONG) -600000000L * DueTimeInMin;
    if (Absolute) {
        DueTime.QuadPart = SystemTime.QuadPart - DueTime.QuadPart;
    }

    Status = SetWaitableTimer (
                h,
                &DueTime,
                0,
                NULL,
                NULL,
                TRUE
                );
    if (!Status) {
        printf ("SetWaitableTimer failed with %x\n", GetLastError());
    }

    printf ("Waiting\n");
    WaitForSingleObject (h, -1);
    printf ("Done\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\tests\vhib\vhib.c ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1988-1991		**/ 
/*****************************************************************/ 

#include <stdio.h>
#include <process.h>
#include <setjmp.h>
#include <stdlib.h>

#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


//
// Memory map information
//

// from po.h

typedef struct _PO_MEMORY_RANGE_ARRAY {
    union {
        struct {
            ULONG           PageNo;
            ULONG           StartPage;
            ULONG           EndPage;
            ULONG           CheckSum;
        } Range;
        struct {
            struct _PO_MEMORY_RANGE_ARRAY *Next;
            ULONG           NextTable;
            ULONG           CheckSum;
            ULONG           EntryCount;
        } Link;
    };
} PO_MEMORY_RANGE_ARRAY, *PPO_MEMORY_RANGE_ARRAY;

#define PO_MAX_RANGE_ARRAY  (PAGE_SIZE / sizeof(PO_MEMORY_RANGE_ARRAY))
#define PO_ENTRIES_PER_PAGE (PO_MAX_RANGE_ARRAY-1)

#define PO_IMAGE_SIGNATURE          'rbih'
#define PO_IMAGE_SIGNATURE_WAKE     'ekaw'
#define PO_IMAGE_SIGNATURE_BREAK    'pkrb'
#define PO_IMAGE_HEADER_PAGE        0
#define PO_FREE_MAP_PAGE            1
#define PO_PROCESSOR_CONTEXT_PAGE   2
#define PO_FIRST_RANGE_TABLE_PAGE   3


typedef struct {
    ULONG                   Signature;
    ULONG                   Version;
    ULONG                   CheckSum;
    ULONG                   LengthSelf;
    ULONG                   PageSelf;
    ULONG                   PageSize;

    ULONG                   ImageType;
    LARGE_INTEGER           SystemTime;
    ULONGLONG               InterruptTime;
    ULONG                   FeatureFlags;
    UCHAR                   spare[4];

    ULONG                   NoHiberPtes;
    ULONG                   HiberVa;
    PHYSICAL_ADDRESS        HiberPte;

    ULONG                   NoFreePages;
    ULONG                   FreeMapCheck;
    ULONG                   WakeCheck;

    ULONG                   TotalPages;
    ULONG                   FirstTablePage;
    ULONG                   LastFilePage;
} PO_MEMORY_IMAGE, *PPO_MEMORY_IMAGE;


PPO_MEMORY_IMAGE            MemImage;
PPO_MEMORY_RANGE_ARRAY      Table;
FILE                        *FpHiber, *FpHiberDbg, *FpDump;
FILE                        *FpSrc1, *FpSrc2;
ULONG                       PagesRead;
PVOID                       CompBuffer;
PVOID                       CompFragmentBuffer;
ULONG                       CompressedSize;

#define PAGE_SIZE   4096
#define SECTOR_SIZE 512


VOID
CheckFile (
    IN  FILE        *Src1,
    IN  FILE        *Src2,
    IN  BOOLEAN     Verify,
    IN  BOOLEAN     Compress
    );




VOID __cdecl
main (argc, argv)
int     argc;
char    *argv[];
{
    FpHiber = fopen("\\hiberfil.sys", "rb");
    if (!FpHiber) {
        printf ("Failed to open \\hiberfil.sys\n");
        exit (1);
    }

    FpDump = fopen("fdump", "wb");
    if (!FpHiber) {
        printf ("Failed to open fdump\n");
        exit (1);
    }

    FpHiberDbg = fopen("\\hiberfil.dbg", "rb");

    //
    // If only FpHiber, read it, verify it and compress it
    //

    if (!FpHiberDbg) {
        CheckFile (FpHiber, NULL, TRUE, TRUE);
        exit (0);
    }

    //
    // FpHiber & FpHiberDbg.
    //      verify FpHiber
    //      verify FpHiberDbg
    //      compare FpHiber & FpHiberDbg
    //

    printf ("Dump of hiberfil.sys:\n");
    CheckFile (FpHiber, NULL, TRUE,  FALSE);

    printf ("\n");
    printf ("Dump of hiberfil.dbg:\n");
    CheckFile (FpHiberDbg, NULL, TRUE,  FALSE);

    printf ("\n");
    printf ("Compare of hiberfil.sys & hiberfil.dbg:\n");
    CheckFile (FpHiber, FpHiberDbg, FALSE, FALSE);
}


ULONG
SimpleCheck (
    IN ULONG                PartialSum,
    IN PVOID                SourceVa,
    IN ULONG                Length
    )
{
    PUSHORT     Source;

    Source = (PUSHORT) SourceVa;
    Length = Length / 2;

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xFFFF);
    }

    return PartialSum;
}


VOID
ReadPage (
    IN ULONG PageNo,
    IN PUCHAR Buffer
    )
{
    UCHAR   BufferDbg[PAGE_SIZE];
    ULONG   i, j, Hits;

    fseek (FpSrc1, PageNo * PAGE_SIZE, SEEK_SET);
    fread (Buffer, PAGE_SIZE, 1, FpSrc1);

    if (FpSrc2) {
        fseek (FpSrc2, PageNo * PAGE_SIZE, SEEK_SET);
        fread (BufferDbg, PAGE_SIZE, 1, FpSrc2);

        Hits = 0;
        for (i=0; i < PAGE_SIZE; i++) {
            if (Buffer[i] != BufferDbg[i]) {
                for (j=i; j < PAGE_SIZE; j++) {
                    if (Buffer[j] == BufferDbg[j]) {
                        break;
                    }
                }

                if (!Hits) {
                    printf ("  Page %08x: ", PageNo);
                } else {
                    printf (", ");
                }

                if (Hits > 3) {
                    printf ("...");
                    break;
                }

                Hits += 1;
                printf ("%04x-%04x", i, j-1);
                i = j;
            }
        }
        if (Hits) {
            printf ("\n");
        }
    }

    PagesRead += 1;
}

BOOLEAN
CheckZeroPage (
    IN PULONG   Buffer
    )
{
    ULONG       i;
    UCHAR       NewBuffer[PAGE_SIZE*2];
    ULONG       NewBufferSize;
    NTSTATUS    Status;


    Status = RtlCompressBuffer (
                COMPRESSION_FORMAT_LZNT1,
                Buffer,
                PAGE_SIZE,
                NewBuffer,
                PAGE_SIZE*2,
                PAGE_SIZE,
                &NewBufferSize,
                CompBuffer
                );

    CompressedSize += NewBufferSize;

    for (i=0; i < PAGE_SIZE/sizeof(ULONG); i++) {
        if (Buffer[i]) {
            return FALSE;
        }
    }
    return TRUE;
}


VOID
CheckFile (
    IN  FILE        *Src1,
    IN  FILE        *Src2,
    IN  BOOLEAN     Verify,
    IN  BOOLEAN     Compress
    )
{
    ULONG       FilePage, DestPage, PageNo, TablePage, Index, Check;
    PUCHAR      Buffer;
    ULONG       NoRuns;
    ULONG       MaxPageCount;
    ULONG       PageCount;
    ULONG       NoZeroPages;
    ULONG       CompBufferSize;
    ULONG       CompFragmentBufferSize;
    ULONG       CompressedSectors;
    ULONG       ZeroRuns;
    BOOLEAN     ZeroRun;
    ULONG       i;

    FpSrc1 = Src1;
    FpSrc2 = Src2;

    RtlGetCompressionWorkSpaceSize (
        COMPRESSION_FORMAT_LZNT1,
        &CompBufferSize,
        &CompFragmentBufferSize
        );

    CompBuffer = malloc(CompBufferSize);
    CompFragmentBuffer = malloc(CompFragmentBufferSize);
    if (Compress) {
        printf ("Comp %d %d\n", CompBufferSize, CompFragmentBufferSize);
    }

    MemImage = malloc(PAGE_SIZE);
    Buffer = malloc(PAGE_SIZE);
    Table = malloc(PAGE_SIZE);

    ReadPage (PO_IMAGE_HEADER_PAGE, MemImage);

    Check = MemImage->CheckSum;
    MemImage->CheckSum = 0;
    if (Verify && Check != SimpleCheck(0, MemImage, MemImage->LengthSelf)) {
        printf ("Checksum on image header bad\n");
    }

    ReadPage (PO_FREE_MAP_PAGE, Buffer);
    if (Verify && MemImage->FreeMapCheck != SimpleCheck(0, Buffer, PAGE_SIZE)) {
        printf ("Checksum on free page map bad\n");
    }

    ReadPage (PO_PROCESSOR_CONTEXT_PAGE, Buffer);
    if (Verify && MemImage->WakeCheck != SimpleCheck(0, Buffer, PAGE_SIZE)) {
        printf ("Checksum on processor context page bad\n");
    }

    NoRuns = 0;
    MaxPageCount = 0;
    NoZeroPages = 0;
    CompressedSectors = 0;
    ZeroRuns = 0;

    TablePage = MemImage->FirstTablePage;
    while (TablePage) {
        ReadPage (TablePage, Table);
        Check = Table[0].Link.CheckSum;
        Table[0].Link.CheckSum = 0;
        if (Verify && Check != SimpleCheck(0, Table, PAGE_SIZE)) {
            printf ("Checksum on table page %d bad\n", TablePage);
        }

        for (Index=1; Index <= Table[0].Link.EntryCount; Index++) {
            Check = 0;
            DestPage = Table[Index].Range.StartPage;
            FilePage = Table[Index].Range.PageNo;

            ZeroRun = TRUE;
            CompressedSize = 0;
            NoRuns   += 1;
            PageCount = Table[Index].Range.EndPage - DestPage;
            if (PageCount > MaxPageCount) {
                MaxPageCount += PageCount;
            }

            while (DestPage < Table[Index].Range.EndPage) {
                ReadPage (FilePage, Buffer);

                if (Compress) {
                    if (CheckZeroPage(Buffer)) {
                        NoZeroPages += 1;
                    } else {
                        ZeroRun = FALSE;
                    }
                }

                if (Verify) {
                    Check = SimpleCheck(Check, Buffer, PAGE_SIZE);
                    if (DestPage >= 0x1a && DestPage < 0x32) {
                        fwrite (Buffer, PAGE_SIZE, 1, FpDump);
                    }
                }

                FilePage += 1;
                DestPage += 1;
            }

            i = CompressedSize / SECTOR_SIZE;
            if (CompressedSize % SECTOR_SIZE) {
                i += 1;
            }
            CompressedSectors += i;
            if (ZeroRun) {
                ZeroRuns += 1;
            }

            if (Verify && Check != Table[Index].Range.CheckSum) {
                printf ("Hit on range %08x - %08x. Tbl %08x %08x, File %08x %08x\n",
                            Table[Index].Range.StartPage,
                            Table[Index].Range.EndPage,
                            TablePage,
                            Table[Index].Range.CheckSum,
                            Table[Index].Range.PageNo,
                            Check
                            );
            }
        }

        TablePage = Table[0].Link.NextTable;
    }

    if (Verify  && Compress) {
        printf ("Image check complete.\n");
        printf ("Pages verified..: %d\n", PagesRead);
        printf ("No runs.........: %d\n", NoRuns);
        printf ("Average run.....: %d\n", PagesRead/ NoRuns);
        printf ("Max run.........: %d\n", MaxPageCount);
        printf ("No zero pages...: %d\n", NoZeroPages);
        printf ("Compressed sect.: %d\n", CompressedSectors);
        printf ("as pages........: %d\n", CompressedSectors * SECTOR_SIZE / PAGE_SIZE);
        printf ("Zero runs.......: %d\n", ZeroRuns);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\psctx.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psctx.c

Abstract:

    This procedure implements Get/Set Context Thread

Author:

    Mark Lucovsky (markl) 25-May-1989

Revision History:

--*/

#include "psp.h"

VOID
PspQueueApcSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtGetContextThread)
#pragma alloc_text(PAGE, NtSetContextThread)
#pragma alloc_text(PAGE, PsGetContextThread)
#pragma alloc_text(PAGE, PsSetContextThread)
#pragma alloc_text(PAGE, NtQueueApcThread)
#pragma alloc_text(PAGE, PspQueueApcSpecialApc)
#endif

VOID
PspQueueApcSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER (NormalRoutine);
    UNREFERENCED_PARAMETER (NormalContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    ExFreePool(Apc);
}

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    IN HANDLE ThreadHandle,
    IN PPS_APC_ROUTINE ApcRoutine,
    IN PVOID ApcArgument1,
    IN PVOID ApcArgument2,
    IN PVOID ApcArgument3
    )

/*++

Routine Description:

    This function is used to queue a user-mode APC to the specified thread. The APC
    will fire when the specified thread does an alertable wait

Arguments:

    ThreadHandle - Supplies a handle to a thread object.  The caller
        must have THREAD_SET_CONTEXT access to the thread.

    ApcRoutine - Supplies the address of the APC routine to execute when the
        APC fires.

    ApcArgument1 - Supplies the first PVOID passed to the APC

    ApcArgument2 - Supplies the second PVOID passed to the APC

    ApcArgument3 - Supplies the third PVOID passed to the APC

Return Value:

    Returns an NT Status code indicating success or failure of the API

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    KPROCESSOR_MODE Mode;
    PKAPC Apc;

    PAGED_CODE();

    Mode = KeGetPreviousMode ();

    st = ObReferenceObjectByHandle (ThreadHandle,
                                    THREAD_SET_CONTEXT,
                                    PsThreadType,
                                    Mode,
                                    &Thread,
                                    NULL);
    if (NT_SUCCESS (st)) {
        st = STATUS_SUCCESS;
        if (IS_SYSTEM_THREAD (Thread)) {
            st = STATUS_INVALID_HANDLE;
        } else {
            Apc = ExAllocatePoolWithQuotaTag (NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                              sizeof(*Apc),
                                              'pasP');

            if (Apc == NULL) {
                st = STATUS_NO_MEMORY;
            } else {
                KeInitializeApc (Apc,
                                 &Thread->Tcb,
                                 OriginalApcEnvironment,
                                 PspQueueApcSpecialApc,
                                 NULL,
                                 (PKNORMAL_ROUTINE)ApcRoutine,
                                 UserMode,
                                 ApcArgument1);

                if (!KeInsertQueueApc (Apc, ApcArgument2, ApcArgument3, 0)) {
                    ExFreePool (Apc);
                    st = STATUS_UNSUCCESSFUL;
                }
            }
        }
        ObDereferenceObject (Thread);
    }

    return st;
}


NTSTATUS
PsGetContextThread(
    IN PETHREAD Thread,
    IN OUT PCONTEXT ThreadContext,
    IN KPROCESSOR_MODE Mode
    )

/*++

Routine Description:

    This function returns the usermode context of the specified thread. This
    function will fail if the specified thread is a system thread. It will
    return the wrong answer if the thread is a non-system thread that does
    not execute in user-mode.

Arguments:

    Thread -       Supplies a pointer to the thread object from
                   which to retrieve context information.

    ThreadContext - Supplies the address of a buffer that will receive
                    the context of the specified thread.

    Mode          - Mode to use for validation checks.

Return Value:

    None.

--*/

{

    ULONG ContextFlags=0;
    GETSETCONTEXT ContextFrame = {0};
    ULONG ContextLength=0;
    NTSTATUS Status;
    PETHREAD CurrentThread;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    //
    // Get previous mode and reference specified thread.
    //

    CurrentThread = PsGetCurrentThread ();

    //
    // Attempt to get the context of the specified thread.
    //

    try {

        //
        // Set the default alignment, capture the context flags,
        // and set the default size of the context record.
        //

        if (Mode != KernelMode) {
            ProbeForReadSmallStructure (ThreadContext,
                                        FIELD_OFFSET (CONTEXT, ContextFlags) + sizeof (ThreadContext->ContextFlags),
                                        CONTEXT_ALIGN);
        }

        ContextFlags = ThreadContext->ContextFlags;

        //
        // We don't need to re-probe here so long as the structure is smaller
        // than the guard region
        //
        ContextLength = sizeof(CONTEXT);
        ASSERT (ContextLength < 0x10000);

#if defined(_X86_)
        //
        // CONTEXT_EXTENDED_REGISTERS is SET, then we want sizeof(CONTEXT) set above
        // otherwise (not set) we only want the old part of the context record.
        //
        if ((ContextFlags & CONTEXT_EXTENDED_REGISTERS) != CONTEXT_EXTENDED_REGISTERS) {
            ContextLength = FIELD_OFFSET(CONTEXT, ExtendedRegisters);
        }
#endif

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode ();
    }

    KeInitializeEvent (&ContextFrame.OperationComplete,
                       NotificationEvent,
                       FALSE);

    ContextFrame.Context.ContextFlags = ContextFlags;

    ContextFrame.Mode = Mode;
    if (Thread == CurrentThread) {
        ContextFrame.Apc.SystemArgument1 = NULL;
        ContextFrame.Apc.SystemArgument2 = Thread;
        KeEnterGuardedRegionThread (&CurrentThread->Tcb);
        PspGetSetContextSpecialApc (&ContextFrame.Apc,
                                    NULL,
                                    NULL,
                                    &ContextFrame.Apc.SystemArgument1,
                                    &ContextFrame.Apc.SystemArgument2);

        KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

        //
        // Move context to specfied context record. If an exception
        // occurs, then return the error.
        //

        try {
            RtlCopyMemory (ThreadContext,
                           &ContextFrame.Context,
                           ContextLength);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode ();
        }

    } else {
        KeInitializeApc (&ContextFrame.Apc,
                         &Thread->Tcb,
                         OriginalApcEnvironment,
                         PspGetSetContextSpecialApc,
                         NULL,
                         NULL,
                         KernelMode,
                         NULL);

        if (!KeInsertQueueApc (&ContextFrame.Apc, NULL, Thread, 2)) {
            Status = STATUS_UNSUCCESSFUL;

        } else {
            KeWaitForSingleObject (&ContextFrame.OperationComplete,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);
            //
            // Move context to specfied context record. If an
            // exception occurs, then silently handle it and
            // return success.
            //

            try {
                RtlCopyMemory (ThreadContext,
                               &ContextFrame.Context,
                               ContextLength);

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode ();
            }
        }
    }

    return Status;
}

NTSTATUS
NtGetContextThread(
    IN HANDLE ThreadHandle,
    IN OUT PCONTEXT ThreadContext
    )

/*++

Routine Description:

    This function returns the usermode context of the specified thread. This
    function will fail if the specified thread is a system thread. It will
    return the wrong answer if the thread is a non-system thread that does
    not execute in user-mode.

Arguments:

    ThreadHandle - Supplies an open handle to the thread object from
                   which to retrieve context information.  The handle
                   must allow THREAD_GET_CONTEXT access to the thread.

    ThreadContext - Supplies the address of a buffer that will receive
                    the context of the specified thread.

Return Value:

    None.

--*/

{

    KPROCESSOR_MODE Mode;
    NTSTATUS Status;
    PETHREAD Thread;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get previous mode and reference specified thread.
    //

    CurrentThread = PsGetCurrentThread ();
    Mode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    Status = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_GET_CONTEXT,
                                        PsThreadType,
                                        Mode,
                                        &Thread,
                                        NULL);

    //
    // If the reference was successful, the check if the specified thread
    // is a system thread.
    //

    if (NT_SUCCESS (Status)) {

        //
        // If the thread is not a system thread, then attempt to get the
        // context of the thread.
        //

        if (IS_SYSTEM_THREAD (Thread) == FALSE) {

            Status = PsGetContextThread (Thread, ThreadContext, Mode);

        } else {
            Status = STATUS_INVALID_HANDLE;
        }

        ObDereferenceObject (Thread);
    }

    return Status;
}


NTSTATUS
PsSetContextThread(
    IN PETHREAD Thread,
    IN PCONTEXT ThreadContext,
    IN KPROCESSOR_MODE Mode
    )

/*++

Routine Description:

    This function sets the usermode context of the specified thread. This
    function will fail if the specified thread is a system thread. It will
    return the wrong answer if the thread is a non-system thread that does
    not execute in user-mode.

Arguments:

    Thread       - Supplies the thread object from
                   which to retrieve context information.

    ThreadContext - Supplies the address of a buffer that contains new
                    context for the specified thread.

    Mode          - Mode to use for validation checks.

Return Value:

    None.

--*/

{
    ULONG ContextFlags=0;
    GETSETCONTEXT ContextFrame;
    ULONG ContextLength=0;
    NTSTATUS Status;
    PETHREAD CurrentThread;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    //
    // Get previous mode and reference specified thread.
    //

    CurrentThread = PsGetCurrentThread ();

    //
    // Attempt to get the context of the specified thread.
    //

    try {

        //
        // Capture the context flags,
        // and set the default size of the context record.
        //

        if (Mode != KernelMode) {
            ProbeForReadSmallStructure (ThreadContext,
                                        FIELD_OFFSET (CONTEXT, ContextFlags) + sizeof (ThreadContext->ContextFlags),
                                        CONTEXT_ALIGN);
        }

        //
        // We don't need to re-probe here so long as the structure is small
        // enough not to cross the guard region.
        //
        ContextFlags = ThreadContext->ContextFlags;
        ContextLength = sizeof (CONTEXT);
        ASSERT (ContextLength < 0x10000);

#if defined(_X86_)
        //
        // CONTEXT_EXTENDED_REGISTERS is SET, then we want sizeof(CONTEXT) set above
        // otherwise (not set) we only want the old part of the context record.
        //
        if ((ContextFlags & CONTEXT_EXTENDED_REGISTERS) != CONTEXT_EXTENDED_REGISTERS) {
            ContextLength = FIELD_OFFSET(CONTEXT, ExtendedRegisters);
        } 
#endif

        RtlCopyMemory (&ContextFrame.Context, ThreadContext, ContextLength);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode ();
    }

    //
    // set the context of the target thread.
    //


#if defined (_IA64_)

    //
    // On IA64 we need to fix up the PC if its a PLABEL address.
    //

    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
   
        PLABEL_DESCRIPTOR Label, *LabelAddress;
        SIZE_T BytesCopied;

        if (ContextFrame.Context.IntGp == 0) {
            LabelAddress = (PPLABEL_DESCRIPTOR)ContextFrame.Context.StIIP;
            try {
                //
                // We are in the wrong process here but it doesn't matter.
                // We just want to make sure this isn't a kernel address.
                //
                ProbeForReadSmallStructure (LabelAddress,
                                            sizeof (*LabelAddress),
                                            sizeof (ULONGLONG));
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }

            Status = MmCopyVirtualMemory (THREAD_TO_PROCESS (Thread),
                                          LabelAddress,
                                          PsGetCurrentProcessByThread (CurrentThread),
                                          &Label,
                                          sizeof (Label),
                                          KernelMode, // Needed to write to local stack
                                          &BytesCopied);
            if (NT_SUCCESS (Status)) {
                ContextFrame.Context.IntGp = Label.GlobalPointer;
                ContextFrame.Context.StIIP = Label.EntryPoint;
                ContextFrame.Context.StIPSR &= ~ISR_EI_MASK;
            } else {
                return Status;
            }
        }
    }

#endif

    KeInitializeEvent (&ContextFrame.OperationComplete,
                       NotificationEvent,
                       FALSE);

    ContextFrame.Context.ContextFlags = ContextFlags;

    ContextFrame.Mode = Mode;
    if (Thread == CurrentThread) {
        ContextFrame.Apc.SystemArgument1 = (PVOID)1;
        ContextFrame.Apc.SystemArgument2 = Thread;
        KeEnterGuardedRegionThread (&CurrentThread->Tcb);
        PspGetSetContextSpecialApc (&ContextFrame.Apc,
                                    NULL,
                                    NULL,
                                    &ContextFrame.Apc.SystemArgument1,
                                    &ContextFrame.Apc.SystemArgument2);

        KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

    } else {
        KeInitializeApc (&ContextFrame.Apc,
                         &Thread->Tcb,
                         OriginalApcEnvironment,
                         PspGetSetContextSpecialApc,
                         NULL,
                         NULL,
                         KernelMode,
                         NULL);

        if (!KeInsertQueueApc (&ContextFrame.Apc, (PVOID)1, Thread, 2)) {
            Status = STATUS_UNSUCCESSFUL;

        } else {
            KeWaitForSingleObject (&ContextFrame.OperationComplete,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);
        }
    }

    return Status;
}


NTSTATUS
NtSetContextThread(
    IN HANDLE ThreadHandle,
    IN PCONTEXT ThreadContext
    )

/*++

Routine Description:

    This function sets the usermode context of the specified thread. This
    function will fail if the specified thread is a system thread. It will
    return the wrong answer if the thread is a non-system thread that does
    not execute in user-mode.

Arguments:

    ThreadHandle - Supplies an open handle to the thread object from
                   which to retrieve context information.  The handle
                   must allow THREAD_SET_CONTEXT access to the thread.

    ThreadContext - Supplies the address of a buffer that contains new
                    context for the specified thread.

Return Value:

    None.

--*/

{
    KPROCESSOR_MODE Mode;
    NTSTATUS Status;
    PETHREAD Thread;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get previous mode and reference specified thread.
    //

    CurrentThread = PsGetCurrentThread ();
    Mode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    Status = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_CONTEXT,
                                        PsThreadType,
                                        Mode,
                                        &Thread,
                                        NULL);

    //
    // If the reference was successful, the check if the specified thread
    // is a system thread.
    //

    if (NT_SUCCESS (Status)) {

        //
        // If the thread is not a system thread, then attempt to get the
        // context of the thread.
        //

        if (IS_SYSTEM_THREAD (Thread) == FALSE) {

            Status = PsSetContextThread (Thread, ThreadContext, Mode);

        } else {
            Status = STATUS_INVALID_HANDLE;
        }

        ObDereferenceObject (Thread);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    create.c

Abstract:

    Process and Thread Creation.

Author:

    Mark Lucovsky (markl) 20-Apr-1989

    Neill Clift (NeillC) 8-Apr-2001

    Revamped process lock usage to limit time spend under the lock.
    Use rundown protection to protect parent against deletion.
    Tidy up errors paths to be small and mostly handled by process delete.
    Lock free and unload safe callouts.
                         

Revision History:

--*/

#include "psp.h"

ULONG
PspUnhandledExceptionInSystemThread(
    IN PEXCEPTION_POINTERS ExceptionPointers
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtCreateThread)
#pragma alloc_text(PAGE, PsCreateSystemThread)
#pragma alloc_text(PAGE, PspCreateThread)
#pragma alloc_text(PAGE, NtCreateProcess)
#pragma alloc_text(PAGE, NtCreateProcessEx)
#pragma alloc_text(PAGE, PsCreateSystemProcess)
#pragma alloc_text(PAGE, PspCreateProcess)
#pragma alloc_text(PAGE, PsSetCreateProcessNotifyRoutine)
#pragma alloc_text(PAGE, PsSetCreateThreadNotifyRoutine)
#pragma alloc_text(PAGE, PsRemoveCreateThreadNotifyRoutine)
#pragma alloc_text(PAGE, PspUserThreadStartup)
#pragma alloc_text(PAGE, PsSetLoadImageNotifyRoutine)
#pragma alloc_text(PAGE, PsRemoveLoadImageNotifyRoutine)
#pragma alloc_text(PAGE, PsCallImageNotifyRoutines)
#pragma alloc_text(PAGE, PspUnhandledExceptionInSystemThread)
#pragma alloc_text(PAGE, PspSystemThreadStartup)
#pragma alloc_text(PAGE, PspImageNotifyTest)
#endif


extern UNICODE_STRING CmCSDVersionString;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
LCID PsDefaultSystemLocaleId = 0;
LCID PsDefaultThreadLocaleId = 0;
LANGID PsDefaultUILanguageId = 0;
LANGID PsInstallUILanguageId = 0;

//
// The following two globals are present to make it easier to change
// working set sizes when debugging.
//

ULONG PsMinimumWorkingSet = 20;
ULONG PsMaximumWorkingSet = 45;

BOOLEAN PsImageNotifyEnabled = FALSE;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
// Define the local storage for the process lock fast mutex.
//


NTSTATUS
NtCreateThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    OUT PCLIENT_ID ClientId,
    IN PCONTEXT ThreadContext,
    IN PINITIAL_TEB InitialTeb,
    IN BOOLEAN CreateSuspended
    )

/*++

Routine Description:

    This system service API creates and initializes a thread object.

Arguments:

    ThreadHandle - Returns the handle for the new thread.

    DesiredAccess - Supplies the desired access modes to the new thread.

    ObjectAttributes - Supplies the object attributes of the new thread.

    ProcessHandle - Supplies a handle to the process that the thread is being
                    created within.

    ClientId - Returns the CLIENT_ID of the new thread.

    ThreadContext - Supplies an initial context for the new thread.

    InitialTeb - Supplies the initial contents for the thread's TEB.

    CreateSuspended - Supplies a value that controls whether or not a
                      thread is created in a suspended state.

Return Value:

    TBD

--*/

{
    NTSTATUS Status;
    INITIAL_TEB CapturedInitialTeb;

    PAGED_CODE();


    //
    // Probe all arguments
    //

    try {
        if (KeGetPreviousMode () != KernelMode) {
            ProbeForWriteHandle (ThreadHandle);

            if (ARGUMENT_PRESENT (ClientId)) {
                ProbeForWriteSmallStructure (ClientId, sizeof (CLIENT_ID), sizeof (ULONG));
            }

            if (ARGUMENT_PRESENT (ThreadContext) ) {
                ProbeForReadSmallStructure (ThreadContext, sizeof (CONTEXT), CONTEXT_ALIGN);
            } else {
                return STATUS_INVALID_PARAMETER;
            }
            ProbeForReadSmallStructure (InitialTeb, sizeof (InitialTeb->OldInitialTeb), sizeof (ULONG));
        }

        CapturedInitialTeb.OldInitialTeb = InitialTeb->OldInitialTeb;
        if (CapturedInitialTeb.OldInitialTeb.OldStackBase == NULL &&
            CapturedInitialTeb.OldInitialTeb.OldStackLimit == NULL) {
            //
            // Since the structure size here is less than 64k we don't need to reprobe
            //
            CapturedInitialTeb = *InitialTeb;
        }
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    Status = PspCreateThread (ThreadHandle,
                              DesiredAccess,
                              ObjectAttributes,
                              ProcessHandle,
                              NULL,
                              ClientId,
                              ThreadContext,
                              &CapturedInitialTeb,
                              CreateSuspended,
                              NULL,
                              NULL);

    return Status;
}

NTSTATUS
PsCreateSystemThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle OPTIONAL,
    OUT PCLIENT_ID ClientId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    )

/*++

Routine Description:

    This routine creates and starts a system thread.

Arguments:

    ThreadHandle - Returns the handle for the new thread.

    DesiredAccess - Supplies the desired access modes to the new thread.

    ObjectAttributes - Supplies the object attributes of the new thread.

    ProcessHandle - Supplies a handle to the process that the thread is being
                    created within.  If this parameter is not specified, then
                    the initial system process is used.

    ClientId - Returns the CLIENT_ID of the new thread.

    StartRoutine - Supplies the address of the system thread start routine.

    StartContext - Supplies context for a system thread start routine.

Return Value:

    TBD

--*/

{
    NTSTATUS Status;
    HANDLE SystemProcess;
    PEPROCESS ProcessPointer;

    PAGED_CODE();

    ProcessPointer = NULL;

    if (ARGUMENT_PRESENT (ProcessHandle)) {
        SystemProcess = ProcessHandle;
    } else {
        SystemProcess = NULL;
        ProcessPointer = PsInitialSystemProcess;
    }

    Status = PspCreateThread (ThreadHandle,
                              DesiredAccess,
                              ObjectAttributes,
                              SystemProcess,
                              ProcessPointer,
                              ClientId,
                              NULL,
                              NULL,
                              FALSE,
                              StartRoutine,
                              StartContext);

    return Status;
}

BOOLEAN PsUseImpersonationToken = FALSE;


NTSTATUS
PspCreateThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    IN PEPROCESS ProcessPointer,
    OUT PCLIENT_ID ClientId OPTIONAL,
    IN PCONTEXT ThreadContext OPTIONAL,
    IN PINITIAL_TEB InitialTeb OPTIONAL,
    IN BOOLEAN CreateSuspended,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext
    )

/*++

Routine Description:

    This routine creates and initializes a thread object. It implements the
    foundation for NtCreateThread and for PsCreateSystemThread.

Arguments:

    ThreadHandle - Returns the handle for the new thread.

    DesiredAccess - Supplies the desired access modes to the new thread.

    ObjectAttributes - Supplies the object attributes of the new thread.

    ProcessHandle - Supplies a handle to the process that the thread is being
                    created within.

    ClientId - Returns the CLIENT_ID of the new thread.

    ThreadContext - Supplies a pointer to a context frame that represents the
                initial user-mode context for a user-mode thread. The absence
                of this parameter indicates that a system thread is being
                created.

    InitialTeb - Supplies the contents of certain fields for the new threads
                 TEB. This parameter is only examined if both a trap and
                 exception frame were specified.

    CreateSuspended - Supplies a value that controls whether or not a user-mode
                      thread is created in a suspended state.

    StartRoutine - Supplies the address of the system thread start routine.

    StartContext - Supplies context for a system thread start routine.

Return Value:

    TBD

--*/

{

    HANDLE_TABLE_ENTRY CidEntry;
    NTSTATUS Status;
    PETHREAD Thread;
    PETHREAD CurrentThread;
    PEPROCESS Process;
    PTEB Teb;
    KPROCESSOR_MODE PreviousMode;
    HANDLE LocalThreadHandle;
    BOOLEAN AccessCheck;
    BOOLEAN MemoryAllocated;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    NTSTATUS accesst;
    LARGE_INTEGER CreateTime;
    ULONG OldActiveThreads;
    PEJOB Job;
    AUX_ACCESS_DATA AuxData;
    PACCESS_STATE AccessState;
    ACCESS_STATE LocalAccessState;

    PAGED_CODE();


    CurrentThread = PsGetCurrentThread ();

    if (StartRoutine != NULL) {
        PreviousMode = KernelMode;
    } else {
        PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);
    }

    Teb = NULL;

    Thread = NULL;
    Process = NULL;

    if (ProcessHandle != NULL) {
        //
        // Process object reference count is biased by one for each thread.
        // This accounts for the pointer given to the kernel that remains
        // in effect until the thread terminates (and becomes signaled)
        //

        Status = ObReferenceObjectByHandle (ProcessHandle,
                                            PROCESS_CREATE_THREAD,
                                            PsProcessType,
                                            PreviousMode,
                                            &Process,
                                            NULL);
    } else {
        if (StartRoutine != NULL) {
            ObReferenceObject (ProcessPointer);
            Process = ProcessPointer;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INVALID_HANDLE;
        }
    }

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // If the previous mode is user and the target process is the system
    // process, then the operation cannot be performed.
    //

    if ((PreviousMode != KernelMode) && (Process == PsInitialSystemProcess)) {
        ObDereferenceObject (Process);
        return STATUS_INVALID_HANDLE;
    }

    Status = ObCreateObject (PreviousMode,
                             PsThreadType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof(ETHREAD),
                             0,
                             0,
                             &Thread);

    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (Process);
        return Status;
    }

    RtlZeroMemory (Thread, sizeof (ETHREAD));

    //
    // Initialize rundown protection for cross thread TEB refs etc.
    //
    ExInitializeRundownProtection (&Thread->RundownProtect);

    //
    // Assign this thread to the process so that from now on
    // we don't have to dereference in error paths.
    //
    Thread->ThreadsProcess = Process;

    Thread->Cid.UniqueProcess = Process->UniqueProcessId;

    CidEntry.Object = Thread;
    CidEntry.GrantedAccess = 0;
    Thread->Cid.UniqueThread = ExCreateHandle (PspCidTable, &CidEntry);

    if (Thread->Cid.UniqueThread == NULL) {
        ObDereferenceObject (Thread);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Initialize Mm
    //

    Thread->ReadClusterSize = MmReadClusterSize;

    //
    // Initialize LPC
    //

    KeInitializeSemaphore (&Thread->LpcReplySemaphore, 0L, 1L);
    InitializeListHead (&Thread->LpcReplyChain);

    //
    // Initialize Io
    //

    InitializeListHead (&Thread->IrpList);

    //
    // Initialize Registry
    //

    InitializeListHead (&Thread->PostBlockList);

    //
    // Initialize the thread lock
    //

    PspInitializeThreadLock (Thread);

    //
    // Initialize Security. Unneeded as we zero out the entire thread block
    //

//    PspInitializeThreadSecurity (Process, Thread);

    //
    // Initialize Termination port list. Unneeded as we zero out the entire thread
    //

//    InitializeListHead (&Thread->TerminationPort);

    KeInitializeSpinLock (&Thread->ActiveTimerListLock);
    InitializeListHead (&Thread->ActiveTimerListHead);


    if (!ExAcquireRundownProtection (&Process->RundownProtect)) {
        ObDereferenceObject (Thread);
        return STATUS_PROCESS_IS_TERMINATING;
    }

    if (ARGUMENT_PRESENT (ThreadContext)) {

        //
        // User-mode thread. Create TEB etc
        //

        Status = MmCreateTeb (Process, InitialTeb, &Thread->Cid, &Teb);
        if (!NT_SUCCESS (Status)) {
            ExReleaseRundownProtection (&Process->RundownProtect);
            ObDereferenceObject (Thread);
            return Status;
        }


        try {
            //
            // Initialize kernel thread object for user mode thread.
            //

            Thread->StartAddress = (PVOID)CONTEXT_TO_PROGRAM_COUNTER(ThreadContext);

#if defined(_IA64_)

            Thread->Win32StartAddress = (PVOID)ThreadContext->IntT0;

#elif defined(_AMD64_)

            Thread->Win32StartAddress = (PVOID)ThreadContext->Rdx;

#elif defined(_X86_)

            Thread->Win32StartAddress = (PVOID)ThreadContext->Eax;

#else

#error "no target architecture"

#endif // defined(_IA64_)

        } except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();
        }

        if (NT_SUCCESS (Status)) {
            Status = KeInitThread (&Thread->Tcb,
                                   NULL,
                                   PspUserThreadStartup,
                                   (PKSTART_ROUTINE)NULL,
                                   Thread->StartAddress,
                                   ThreadContext,
                                   Teb,
                                   &Process->Pcb);

#if defined(_AMD64_)            
            //
            // Always save the legacy floating point state for wow64 threads.
            //

            if ((NT_SUCCESS (Status)) &&
                (Process->Wow64Process != NULL)) {
                Thread->Tcb.NpxState = LEGACY_STATE_SWITCH;
            }
#endif

       }


    } else {

        Teb = NULL;
        //
        // Set the system thread bit thats kept for all time
        //
        PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_SYSTEM);

        //
        // Initialize kernel thread object for kernel mode thread.
        //

        Thread->StartAddress = (PKSTART_ROUTINE) StartRoutine;
        Status = KeInitThread (&Thread->Tcb,
                               NULL,
                               PspSystemThreadStartup,
                               StartRoutine,
                               StartContext,
                               NULL,
                               NULL,
                               &Process->Pcb);
    }


    if (!NT_SUCCESS (Status)) {
        if (Teb != NULL) {
            MmDeleteTeb(Process, Teb);
        }
        ExReleaseRundownProtection (&Process->RundownProtect);
        ObDereferenceObject (Thread);
        return Status;
    }

    PspLockProcessExclusive (Process, CurrentThread);
    //
    // Process is exiting or has had delete process called
    //
    if ((Process->Flags&PS_PROCESS_FLAGS_PROCESS_DELETE) != 0) {
        PspUnlockProcessExclusive (Process, CurrentThread);

        KeUninitThread (&Thread->Tcb);

        if (Teb != NULL) {
            MmDeleteTeb(Process, Teb);
        }
        ExReleaseRundownProtection (&Process->RundownProtect);
        ObDereferenceObject(Thread);

        return STATUS_PROCESS_IS_TERMINATING;
    }


    OldActiveThreads = Process->ActiveThreads++;
    InsertTailList (&Process->ThreadListHead, &Thread->ThreadListEntry);

    KeStartThread (&Thread->Tcb);

    PspUnlockProcessExclusive (Process, CurrentThread);

    ExReleaseRundownProtection (&Process->RundownProtect);

    //
    // Failures that occur after this point cause the thread to
    // go through PspExitThread
    //


    if (OldActiveThreads == 0) {
        PERFINFO_PROCESS_CREATE (Process);

        if (PspCreateProcessNotifyRoutineCount != 0) {
            ULONG i;
            PEX_CALLBACK_ROUTINE_BLOCK CallBack;
            PCREATE_PROCESS_NOTIFY_ROUTINE Rtn;

            for (i=0; i<PSP_MAX_CREATE_PROCESS_NOTIFY; i++) {
                CallBack = ExReferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i]);
                if (CallBack != NULL) {
                    Rtn = (PCREATE_PROCESS_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack);
                    Rtn (Process->InheritedFromUniqueProcessId,
                         Process->UniqueProcessId,
                         TRUE);
                    ExDereferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i],
                                                CallBack);
                }
            }
        }
    }

    //
    // If the process has a job with a completion port,
    // AND if the process is really considered to be in the Job, AND
    // the process has not reported, report in
    //
    // This should really be done in add process to job, but can't
    // in this path because the process's ID isn't assigned until this point
    // in time
    //
    Job = Process->Job;
    if (Job != NULL && Job->CompletionPort &&
        !(Process->JobStatus & (PS_JOB_STATUS_NOT_REALLY_ACTIVE|PS_JOB_STATUS_NEW_PROCESS_REPORTED))) {

        PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NEW_PROCESS_REPORTED);

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite (&Job->JobLock, TRUE);
        if (Job->CompletionPort != NULL) {
            IoSetIoCompletion (Job->CompletionPort,
                               Job->CompletionKey,
                               (PVOID)Process->UniqueProcessId,
                               STATUS_SUCCESS,
                               JOB_OBJECT_MSG_NEW_PROCESS,
                               FALSE);
        }
        ExReleaseResourceLite (&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    }

    PERFINFO_THREAD_CREATE(Thread, InitialTeb);

    //
    // Notify registered callout routines of thread creation.
    //

    if (PspCreateThreadNotifyRoutineCount != 0) {
        ULONG i;
        PEX_CALLBACK_ROUTINE_BLOCK CallBack;
        PCREATE_THREAD_NOTIFY_ROUTINE Rtn;

        for (i = 0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i++) {
            CallBack = ExReferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i]);
            if (CallBack != NULL) {
                Rtn = (PCREATE_THREAD_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack);
                Rtn (Thread->Cid.UniqueProcess,
                     Thread->Cid.UniqueThread,
                     TRUE);
                ExDereferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i],
                                            CallBack);
            }
        }
    }


    //
    // Reference count of thread is biased once for itself and once for the handle if we create it.
    //

    ObReferenceObjectEx (Thread, 2);

    if (CreateSuspended) {
        try {
            KeSuspendThread (&Thread->Tcb);
        } except ((GetExceptionCode () == STATUS_SUSPEND_COUNT_EXCEEDED)?
                     EXCEPTION_EXECUTE_HANDLER :
                     EXCEPTION_CONTINUE_SEARCH) {
        }
        //
        // If deletion was started after we suspended then wake up the thread
        //
        if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_TERMINATED) {
            KeForceResumeThread (&Thread->Tcb);
        }
    }

    AccessState = NULL;
    if (!PsUseImpersonationToken) {
        AccessState = &LocalAccessState;
        Status = SeCreateAccessStateEx (NULL,
                                        ARGUMENT_PRESENT (ThreadContext)?PsGetCurrentProcessByThread (CurrentThread) : Process,
                                        AccessState,
                                        &AuxData,
                                        DesiredAccess,
                                        &PsThreadType->TypeInfo.GenericMapping);

        if (!NT_SUCCESS (Status)) {
            PS_SET_BITS (&Thread->CrossThreadFlags,
                         PS_CROSS_THREAD_FLAGS_DEADTHREAD);

            if (CreateSuspended) {
                (VOID) KeResumeThread (&Thread->Tcb);
            }
            KeReadyThread (&Thread->Tcb);
            ObDereferenceObject (Thread);
            return Status;
        }
    }

    Status = ObInsertObject (Thread,
                             AccessState,
                             DesiredAccess,
                             0,
                             NULL,
                             &LocalThreadHandle);

    if (AccessState != NULL) {
        SeDeleteAccessState (AccessState);
    }

    if (!NT_SUCCESS (Status)) {

        //
        // The insert failed. Terminate the thread.
        //

        //
        // This trick is used so that Dbgk doesn't report
        // events for dead threads
        //

        PS_SET_BITS (&Thread->CrossThreadFlags,
                     PS_CROSS_THREAD_FLAGS_DEADTHREAD);

        if (CreateSuspended) {
            KeResumeThread (&Thread->Tcb);
        }

    } else {

        try {

            *ThreadHandle = LocalThreadHandle;
            if (ARGUMENT_PRESENT (ClientId)) {
                *ClientId = Thread->Cid;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {

            PS_SET_BITS (&Thread->CrossThreadFlags,
                         PS_CROSS_THREAD_FLAGS_DEADTHREAD);

            if (CreateSuspended) {
                (VOID) KeResumeThread (&Thread->Tcb);
            }
            KeReadyThread (&Thread->Tcb);
            ObDereferenceObject (Thread);
            ObCloseHandle (LocalThreadHandle, PreviousMode);
            return GetExceptionCode();
        }
    }

    KeQuerySystemTime(&CreateTime);
    ASSERT ((CreateTime.HighPart & 0xf0000000) == 0);
    PS_SET_THREAD_CREATE_TIME(Thread, CreateTime);


    if ((Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD) == 0) {
        Status = ObGetObjectSecurity (Thread,
                                      &SecurityDescriptor,
                                      &MemoryAllocated);
        if (!NT_SUCCESS (Status)) {
            //
            // This trick us used so that Dbgk doesn't report
            // events for dead threads
            //
            PS_SET_BITS (&Thread->CrossThreadFlags,
                         PS_CROSS_THREAD_FLAGS_DEADTHREAD);

            if (CreateSuspended) {
                KeResumeThread(&Thread->Tcb);
            }
            KeReadyThread (&Thread->Tcb);
            ObDereferenceObject (Thread);
            ObCloseHandle (LocalThreadHandle, PreviousMode);
            return Status;
        }

        //
        // Compute the subject security context
        //

        SubjectContext.ProcessAuditId = Process;
        SubjectContext.PrimaryToken = PsReferencePrimaryToken(Process);
        SubjectContext.ClientToken = NULL;

        AccessCheck = SeAccessCheck (SecurityDescriptor,
                                     &SubjectContext,
                                     FALSE,
                                     MAXIMUM_ALLOWED,
                                     0,
                                     NULL,
                                     &PsThreadType->TypeInfo.GenericMapping,
                                     PreviousMode,
                                     &Thread->GrantedAccess,
                                     &accesst);

        PsDereferencePrimaryTokenEx (Process, SubjectContext.PrimaryToken);

        ObReleaseObjectSecurity (SecurityDescriptor,
                                 MemoryAllocated);

        if (!AccessCheck) {
            Thread->GrantedAccess = 0;
        }

        Thread->GrantedAccess |= (THREAD_TERMINATE | THREAD_SET_INFORMATION | THREAD_QUERY_INFORMATION);

    } else {
        Thread->GrantedAccess = THREAD_ALL_ACCESS;
    }

    KeReadyThread (&Thread->Tcb);
    ObDereferenceObject (Thread);

    return Status;
}

NTSTATUS
NtCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL
    )
{
    ULONG Flags = 0;

    if ((ULONG_PTR)SectionHandle & 1) {
        Flags |= PROCESS_CREATE_FLAGS_BREAKAWAY;
    }

    if ((ULONG_PTR) DebugPort & 1) {
        Flags |= PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT;
    }

    if (InheritObjectTable) {
        Flags |= PROCESS_CREATE_FLAGS_INHERIT_HANDLES;
    }

    return NtCreateProcessEx (ProcessHandle,
                              DesiredAccess,
                              ObjectAttributes OPTIONAL,
                              ParentProcess,
                              Flags,
                              SectionHandle,
                              DebugPort,
                              ExceptionPort,
                              0);
}

NTSTATUS
NtCreateProcessEx(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN ULONG Flags,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    IN ULONG JobMemberLevel
    )
/*++

Routine Description:

    This routine creates a process object.

Arguments:

    ProcessHandle - Returns the handle for the new process.

    DesiredAccess - Supplies the desired access modes to the new process.

    ObjectAttributes - Supplies the object attributes of the new process.
    .
    .
    .

Return Value:

    TBD

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    if (KeGetPreviousMode() != KernelMode) {

        //
        // Probe all arguments
        //

        try {
            ProbeForWriteHandle (ProcessHandle);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    if (ARGUMENT_PRESENT (ParentProcess)) {
        Status = PspCreateProcess (ProcessHandle,
                                   DesiredAccess,
                                   ObjectAttributes,
                                   ParentProcess,
                                   Flags,
                                   SectionHandle,
                                   DebugPort,
                                   ExceptionPort,
                                   JobMemberLevel);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}


NTSTATUS
PsCreateSystemProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    )

/*++

Routine Description:

    This routine creates a system process object. A system process
    has an address space that is initialized to an empty address space
    that maps the system.

    The process inherits its access token and other attributes from the
    initial system process. The process is created with an empty handle table.

Arguments:

    ProcessHandle - Returns the handle for the new process.

    DesiredAccess - Supplies the desired access modes to the new process.

    ObjectAttributes - Supplies the object attributes of the new process.


Return Value:

    TBD

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    Status = PspCreateProcess (ProcessHandle,
                               DesiredAccess,
                               ObjectAttributes,
                               PspInitialSystemProcessHandle,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               0);

    return Status;
}



NTSTATUS
PspCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess OPTIONAL,
    IN ULONG Flags,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    IN ULONG JobMemberLevel
    )

/*++

Routine Description:

    This routine creates and initializes a process object.  It implements the
    foundation for NtCreateProcess and for system initialization process
    creation.

Arguments:

    ProcessHandle - Returns the handle for the new process.

    DesiredAccess - Supplies the desired access modes to the new process.

    ObjectAttributes - Supplies the object attributes of the new process.

    ParentProcess - Supplies a handle to the process' parent process.  If this
                    parameter is not specified, then the process has no parent
                    and is created using the system address space.

    Flags         - Process creation flags

    SectionHandle - Supplies a handle to a section object to be used to create
                    the process' address space.  If this parameter is not
                    specified, then the address space is simply a clone of the
                    parent process' address space.

    DebugPort - Supplies a handle to a port object that will be used as the
                process' debug port.

    ExceptionPort - Supplies a handle to a port object that will be used as the
                    process' exception port.

    JobMemberLevel - Level for a create process in a jobset

Return Value:

    TBD

--*/

{
    NTSTATUS Status;
    PEPROCESS Process;
    PEPROCESS CurrentProcess;
    PEPROCESS Parent;
    PETHREAD CurrentThread;
    KAFFINITY Affinity;
    KPRIORITY BasePriority;
    PVOID SectionObject;
    PVOID ExceptionPortObject;
    PVOID DebugPortObject;
    ULONG WorkingSetMinimum, WorkingSetMaximum;
    HANDLE LocalProcessHandle;
    KPROCESSOR_MODE PreviousMode;
    INITIAL_PEB InitialPeb;
    BOOLEAN CreatePeb;
    ULONG_PTR DirectoryTableBase[2];
    BOOLEAN AccessCheck;
    BOOLEAN MemoryAllocated;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    NTSTATUS accesst;
    NTSTATUS SavedStatus;
    ULONG ImageFileNameSize;
    HANDLE_TABLE_ENTRY CidEntry;
    PEJOB Job;
    PPEB Peb;
    AUX_ACCESS_DATA AuxData;
    PACCESS_STATE AccessState;
    ACCESS_STATE LocalAccessState;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);
    CurrentProcess = PsGetCurrentProcessByThread (CurrentThread);

    CreatePeb = FALSE;
    DirectoryTableBase[0] = 0;
    DirectoryTableBase[1] = 0;
    Peb = NULL;

    //
    // Reject bogus create parameters for future expansion
    //
    if (Flags&~PROCESS_CREATE_FLAGS_LEGAL_MASK) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Parent
    //

    if (ARGUMENT_PRESENT (ParentProcess)) {
        Status = ObReferenceObjectByHandle (ParentProcess,
                                            PROCESS_CREATE_PROCESS,
                                            PsProcessType,
                                            PreviousMode,
                                            &Parent,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        if (JobMemberLevel != 0 && Parent->Job == NULL) {
            ObDereferenceObject (Parent);
            return STATUS_INVALID_PARAMETER;
        }

        BasePriority = (KPRIORITY) NORMAL_BASE_PRIORITY;

        //
        //BasePriority = Parent->Pcb.BasePriority;
        //

        Affinity = Parent->Pcb.Affinity;

        WorkingSetMinimum = PsMinimumWorkingSet;
        WorkingSetMaximum = PsMaximumWorkingSet;


    } else {

        Parent = NULL;
        Affinity = KeActiveProcessors;
        BasePriority = (KPRIORITY) NORMAL_BASE_PRIORITY;

        WorkingSetMinimum = PsMinimumWorkingSet;
        WorkingSetMaximum = PsMaximumWorkingSet;
    }

    //
    // Create the process object
    //
    Status = ObCreateObject (PreviousMode,
                             PsProcessType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof (EPROCESS),
                             0,
                             0,
                             &Process);
    if (!NT_SUCCESS (Status)) {
        goto exit_and_deref_parent;
    }
    //
    // The process object is created set to NULL. Errors
    // That occur after this step cause the process delete
    // routine to be entered.
    //
    // Teardown actions that occur in the process delete routine
    // do not need to be performed inline.
    //

    RtlZeroMemory (Process, sizeof(EPROCESS));

    ExInitializeRundownProtection (&Process->RundownProtect);
    PspInitializeProcessLock (Process);

    InitializeListHead (&Process->ThreadListHead);

#if defined(_WIN64)
    if (Flags & PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE) {
        PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_OVERRIDE_ADDRESS_SPACE);
    }
#endif

    PspInheritQuota (Process, Parent);

    ObInheritDeviceMap (Process, Parent);

    if (Parent != NULL) {
        Process->DefaultHardErrorProcessing = Parent->DefaultHardErrorProcessing;
        Process->InheritedFromUniqueProcessId = Parent->UniqueProcessId;
    } else {
        Process->DefaultHardErrorProcessing = 1;
        Process->InheritedFromUniqueProcessId = NULL;
    }

    //
    // Section
    //

    if (ARGUMENT_PRESENT (SectionHandle)) {

        Status = ObReferenceObjectByHandle (SectionHandle,
                                            SECTION_MAP_EXECUTE,
                                            MmSectionObjectType,
                                            PreviousMode,
                                            &SectionObject,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }
    } else {
        SectionObject = NULL;
        if (Parent != PsInitialSystemProcess) {
            //
            // Fetch the section pointer from the parent process
            // as we will be cloning. Since the section pointer
            // is removed at last thread exit we need to protect against
            // process exit here to be safe.
            //
            if (ExAcquireRundownProtection (&Parent->RundownProtect)) {
                SectionObject = Parent->SectionObject;
                if (SectionObject != NULL) {
                    ObReferenceObject (SectionObject);
                }
                ExReleaseRundownProtection (&Parent->RundownProtect);

            }
            if (SectionObject == NULL) {
                Status = STATUS_PROCESS_IS_TERMINATING;
                goto exit_and_deref;
            }
        }
    }

    Process->SectionObject = SectionObject;

    //
    // DebugPort
    //

    if (ARGUMENT_PRESENT (DebugPort)) {
        Status = ObReferenceObjectByHandle (DebugPort,
                                            DEBUG_PROCESS_ASSIGN,
                                            DbgkDebugObjectType,
                                            PreviousMode,
                                            &DebugPortObject,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }
        Process->DebugPort = DebugPortObject;
        if (Flags&PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT) {
            PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_NO_DEBUG_INHERIT);
        }
    } else {
        if (Parent != NULL) {
            DbgkCopyProcessDebugPort (Process, Parent);
        }
    }


    //
    // ExceptionPort
    //

    if (ARGUMENT_PRESENT (ExceptionPort)) {
        Status = ObReferenceObjectByHandle (ExceptionPort,
                                            0,
                                            LpcPortObjectType,
                                            PreviousMode,
                                            &ExceptionPortObject,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }
        Process->ExceptionPort = ExceptionPortObject;
    }


    Process->ExitStatus = STATUS_PENDING;


    //
    // Clone parent's object table.
    // If no parent (booting) then use the current object table created in
    // ObInitSystem.
    //

    if (Parent != NULL) {

        //
        // Calculate address space
        //
        //      If Parent == PspInitialSystem
        //

        if (!MmCreateProcessAddressSpace (WorkingSetMinimum,
                                          Process,
                                          &DirectoryTableBase[0])) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit_and_deref;
        }
    } else {

        Process->ObjectTable = CurrentProcess->ObjectTable;

        //
        // Initialize the Working Set Mutex and address creation mutex
        // for this "hand built" process.
        // Normally, the call to MmInitializeAddressSpace initializes the
        // working set mutex, however, in this case, we have already initialized
        // the address space and we are now creating a second process using
        // the address space of the idle thread.
        //

        Status = MmInitializeHandBuiltProcess (Process, &DirectoryTableBase[0]);
        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }
    }


    PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_HAS_ADDRESS_SPACE);


    Process->Vm.MaximumWorkingSetSize = WorkingSetMaximum;

    KeInitializeProcess (&Process->Pcb,
                         BasePriority,
                         Affinity,
                         &DirectoryTableBase[0],
                         (BOOLEAN)(Process->DefaultHardErrorProcessing & PROCESS_HARDERROR_ALIGNMENT_BIT));

    //
    //  Initialize the security fields of the process
    //  The parent may be null exactly once (during system init).
    //  Thereafter, a parent is always required so that we have a
    //  security context to duplicate for the new process.
    //

    Status = PspInitializeProcessSecurity (Parent, Process);

    if (!NT_SUCCESS (Status)) {
        goto exit_and_deref;
    }

    Process->Pcb.ThreadQuantum = PspForegroundQuantum[0];
    Process->PriorityClass = PROCESS_PRIORITY_CLASS_NORMAL;

    if (Parent != NULL) {

        if (Parent->PriorityClass == PROCESS_PRIORITY_CLASS_IDLE ||
            Parent->PriorityClass == PROCESS_PRIORITY_CLASS_BELOW_NORMAL) {

            Process->PriorityClass = Parent->PriorityClass;
        }

        //
        // if address space creation worked, then when going through
        // delete, we will attach. Of course, attaching means that the kprocess
        // must be initialized, so we delay the object stuff till here.

        //
        Status = ObInitProcess ((Flags&PROCESS_CREATE_FLAGS_INHERIT_HANDLES) ? Parent : NULL,
                                Process);

        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }
    } else {
        Status = MmInitializeHandBuiltProcess2 (Process);

        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }
    }

    Status = STATUS_SUCCESS;
    SavedStatus = STATUS_SUCCESS;

    //
    // Initialize the process address space
    // The address space has four possibilities
    //
    //      1 - Boot Process. Address space is initialized during
    //          MmInit. Parent is not specified.
    //
    //      2 - System Process. Address space is a virgin address
    //          space that only maps system space. Process is same
    //          as PspInitialSystemProcess.
    //
    //      3 - User Process (Cloned Address Space). Address space
    //          is cloned from the specified process.
    //
    //      4 - User Process (New Image Address Space). Address space
    //          is initialized so that it maps the specified section.
    //

    if (SectionHandle != NULL) {

        //
        // User Process (New Image Address Space). Don't specify Process to
        // clone, just SectionObject.
        //

        //
        // Passing in the 4th parameter as below lets the EPROCESS struct contain its image file name, provided that
        // appropriate audit settings are enabled.  Memory is allocated inside of MmInitializeProcessAddressSpace
        // and pointed to by ImageFileName, so that must be freed in the process deletion routine (PspDeleteProcess())
        //

        Status = MmInitializeProcessAddressSpace (Process,
                                                  NULL,
                                                  SectionObject,
                                                  &(Process->SeAuditProcessCreationInfo.ImageFileName));

        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }

        //
        // In order to support relocating executables, the proper status
        // (STATUS_IMAGE_NOT_AT_BASE) must be returned, so save it here.
        //

        SavedStatus = Status;

        CreatePeb = TRUE;

    } else if (Parent != NULL) {

        if (Parent != PsInitialSystemProcess) {

            Process->SectionBaseAddress = Parent->SectionBaseAddress;

            //
            // User Process ( Cloned Address Space ).  Don't specify section to
            // map, just Process to clone.
            //

            Status = MmInitializeProcessAddressSpace (Process,
                                                      Parent,
                                                      NULL,
                                                      NULL);

            CreatePeb = TRUE;

            if (!NT_SUCCESS (Status)) {
                goto exit_and_deref;
            }

            //
            // A cloned process isn't started from an image file, so we give it the name
            // of the process of which it is a clone, provided the original has a name.
            //

            if (Parent->SeAuditProcessCreationInfo.ImageFileName != NULL) {
                ImageFileNameSize = sizeof(OBJECT_NAME_INFORMATION) +
                                    Parent->SeAuditProcessCreationInfo.ImageFileName->Name.MaximumLength;

                Process->SeAuditProcessCreationInfo.ImageFileName =
                    ExAllocatePoolWithTag (PagedPool,
                                           ImageFileNameSize,
                                           'aPeS');

                if (Process->SeAuditProcessCreationInfo.ImageFileName != NULL) {

                    RtlCopyMemory (Process->SeAuditProcessCreationInfo.ImageFileName,
                                   Parent->SeAuditProcessCreationInfo.ImageFileName,
                                   ImageFileNameSize);

                    //
                    // The UNICODE_STRING in the process is self contained, so calculate the
                    // offset for the buffer.
                    //

                    Process->SeAuditProcessCreationInfo.ImageFileName->Name.Buffer =
                        (PUSHORT)(((PUCHAR) Process->SeAuditProcessCreationInfo.ImageFileName) +
                        sizeof(UNICODE_STRING));

                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit_and_deref;
                }
            }

        } else {

            //
            // System Process.  Don't specify Process to clone or section to map
            //

            Status = MmInitializeProcessAddressSpace (Process,
                                                      NULL,
                                                      NULL,
                                                      NULL);

            if (!NT_SUCCESS (Status)) {
                goto exit_and_deref;
            }

            //
            // In case the image file name of this system process is ever queried, we give
            // a zero length UNICODE_STRING.
            //

            Process->SeAuditProcessCreationInfo.ImageFileName =
                ExAllocatePoolWithTag (PagedPool,
                                       sizeof(OBJECT_NAME_INFORMATION),
                                       'aPeS');

            if (Process->SeAuditProcessCreationInfo.ImageFileName != NULL) {

                RtlZeroMemory (Process->SeAuditProcessCreationInfo.ImageFileName,
                               sizeof(OBJECT_NAME_INFORMATION));
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit_and_deref;
            }

        }
    }

    //
    // Create the process ID
    //
    CidEntry.Object = Process;
    CidEntry.GrantedAccess = 0;
    Process->UniqueProcessId = ExCreateHandle (PspCidTable, &CidEntry);
    if (Process->UniqueProcessId == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit_and_deref;
    }

    ExSetHandleTableOwner (Process->ObjectTable, Process->UniqueProcessId);


    //
    // Audit the process creation.
    //

    if (SeDetailedAuditingWithToken (NULL)) {
        SeAuditProcessCreation (Process);
    }

    //
    // See if the parent has a job. If so reference the job
    // and add the process in.
    //

    if (Parent) {
        Job = Parent->Job;
        if (Job != NULL && !(Job->LimitFlags & JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK)) {

            if (Flags&PROCESS_CREATE_FLAGS_BREAKAWAY) {
                if (!(Job->LimitFlags & JOB_OBJECT_LIMIT_BREAKAWAY_OK)) {
                    Status = STATUS_ACCESS_DENIED;
                } else {
                    Status = STATUS_SUCCESS;
                }
            } else {
                Status = PspGetJobFromSet (Job, JobMemberLevel, &Process->Job);
                if (NT_SUCCESS (Status)) {
                    PACCESS_TOKEN Token, NewToken;

                    Job = Process->Job;

                    Status = PspAddProcessToJob (Job, Process);

                    //
                    // Duplicate a new process token if one is specified for the job
                    //
                    Token = Job->Token;
                    if (Token != NULL) {
                        Status = SeSubProcessToken (Token,
                                                    &NewToken,
                                                    FALSE,
                                                    Job->SessionId);

                        if (!NT_SUCCESS (Status)) {
                            goto exit_and_deref;
                        }
                        SeAssignPrimaryToken (Process, NewToken);    
                        ObDereferenceObject (NewToken);                    
                    }

                }
            }
            if (!NT_SUCCESS (Status)) {
                goto exit_and_deref;
            }
        }
    }


    if (Parent && CreatePeb) {

        //
        // For processes created w/ a section,
        // a new "virgin" PEB is created. Otherwise,
        // for forked processes, uses inherited PEB
        // with an updated mutant.

        RtlZeroMemory (&InitialPeb, FIELD_OFFSET(INITIAL_PEB, Mutant));
        InitialPeb.Mutant = (HANDLE)(-1);
        if (SectionHandle != NULL) {

            Status = MmCreatePeb (Process, &InitialPeb, &Process->Peb);
            if (!NT_SUCCESS (Status)) {
                Process->Peb = NULL;
                goto exit_and_deref;
            }
            Peb =  Process->Peb;

        } else {
            SIZE_T BytesCopied;

            InitialPeb.InheritedAddressSpace = TRUE;

            Process->Peb = Parent->Peb;

            MmCopyVirtualMemory (CurrentProcess,
                                 &InitialPeb,
                                 Process,
                                 Process->Peb,
                                 sizeof (INITIAL_PEB),
                                 KernelMode,
                                 &BytesCopied);

        }
    }
    Peb = Process->Peb;

    //
    // Add the process to the global list of processes.
    //

    PspLockProcessList (CurrentThread);

    InsertTailList (&PsActiveProcessHead, &Process->ActiveProcessLinks);

    PspUnlockProcessList (CurrentThread);

    AccessState = NULL;
    if (!PsUseImpersonationToken) {
        AccessState = &LocalAccessState;
        Status = SeCreateAccessStateEx (NULL,
                                        (Parent == NULL || Parent != PsInitialSystemProcess)?
                                           PsGetCurrentProcessByThread (CurrentThread) :
                                           PsInitialSystemProcess,
                                        AccessState,
                                        &AuxData,
                                        DesiredAccess,
                                        &PsProcessType->TypeInfo.GenericMapping);
        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref;
        }
    }

    //
    // Insert the object. Once we do this is reachable from the outside world via
    // open by name. Open by ID is still disabled. Since its reachable
    // somebody might create a thread in the process and cause
    // rundown.
    //

    Status = ObInsertObject (Process,
                             AccessState,
                             DesiredAccess,
                             1,     // bias the refcnt by one for future process manipulations
                             NULL,
                             &LocalProcessHandle);

    if (AccessState != NULL) {
        SeDeleteAccessState (AccessState);
    }

    if (!NT_SUCCESS (Status)) {
        goto exit_and_deref_parent;
    }

    //
    // As soon as we create the handle the process is accessible to the outside world. Allow the process to
    // be deleted.
    //
    Process->GrantedAccess = PROCESS_TERMINATE;

    PsSetProcessPriorityByClass (Process, PsProcessPriorityBackground);


    if (Parent && Parent != PsInitialSystemProcess) {

        Status = ObGetObjectSecurity (Process,
                                      &SecurityDescriptor,
                                      &MemoryAllocated);
        if (!NT_SUCCESS (Status)) {
            ObCloseHandle (LocalProcessHandle, PreviousMode);

            goto exit_and_deref;
        }

        //
        // Compute the subject security context
        //

        SubjectContext.ProcessAuditId = Process;
        SubjectContext.PrimaryToken = PsReferencePrimaryToken(Process);
        SubjectContext.ClientToken = NULL;
        AccessCheck = SeAccessCheck (SecurityDescriptor,
                                     &SubjectContext,
                                     FALSE,
                                     MAXIMUM_ALLOWED,
                                     0,
                                     NULL,
                                     &PsProcessType->TypeInfo.GenericMapping,
                                     PreviousMode,
                                     &Process->GrantedAccess,
                                     &accesst);
        PsDereferencePrimaryTokenEx (Process, SubjectContext.PrimaryToken);
        ObReleaseObjectSecurity (SecurityDescriptor,
                                 MemoryAllocated);

        if (!AccessCheck) {
            Process->GrantedAccess = 0;
        }

        //
        // It does not make any sense to create a process that can not
        // do anything to itself.
        // Note: Changes to this set of bits should be reflected in psquery.c
        // code, in PspSetPrimaryToken.
        //

        Process->GrantedAccess |= (PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION | PROCESS_TERMINATE | PROCESS_CREATE_THREAD | PROCESS_DUP_HANDLE | PROCESS_CREATE_PROCESS | PROCESS_SET_INFORMATION | STANDARD_RIGHTS_ALL);

    } else {
        Process->GrantedAccess = PROCESS_ALL_ACCESS;
    }

    KeQuerySystemTime (&Process->CreateTime);

    try {
        if (Peb != NULL && CurrentThread->Tcb.Teb != NULL) {
            ((PTEB)(CurrentThread->Tcb.Teb))->NtTib.ArbitraryUserPointer = Peb;
        }

        *ProcessHandle = LocalProcessHandle;
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }

    if (SavedStatus != STATUS_SUCCESS) {
        Status = SavedStatus;
    }


exit_and_deref:

    ObDereferenceObject (Process);

exit_and_deref_parent:
    if (Parent != NULL) {
        ObDereferenceObject (Parent);
    }

    return Status;

}

NTSTATUS
PsSetCreateProcessNotifyRoutine(
    IN PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,
    IN BOOLEAN Remove
    )

/*++

Routine Description:

    This function allows an installable file system to hook into process
    creation and deletion to track those events against their own internal
    data structures.

Arguments:

    NotifyRoutine - Supplies the address of a routine which is called at
        process creation and deletion. The routine is passed the unique Id
        of the created or deleted process and the parent process if it was
        created with the inherit handles option. If it was created without
        the inherit handle options, then the parent process Id will be NULL.
        The third parameter passed to the notify routine is TRUE if the process
        is being created and FALSE if it is being deleted.

        The callout for creation happens just after the first thread in the
        process has been created. The callout for deletion happens after the
        last thread in a process has terminated and the address space is about
        to be deleted. It is possible to get a deletion call without a creation
        call if the pathological case where a process is created and deleted
        without a thread ever being created.

    Remove - FALSE specifies to install the callout and TRUE specifies to
        remove the callout that mat

Return Value:

    STATUS_SUCCESS if successful, and STATUS_INVALID_PARAMETER if not.

--*/

{

    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;

    PAGED_CODE();

    if (Remove) {
        for (i = 0; i < PSP_MAX_CREATE_PROCESS_NOTIFY; i++) {

            //
            // Reference the callback so we can check its routine address.
            //
            CallBack = ExReferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i]);

            if (CallBack != NULL) {
                //
                // See if the routine matches our target
                //
                if ((PCREATE_PROCESS_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack) == NotifyRoutine) {

                    if (ExCompareExchangeCallBack (&PspCreateProcessNotifyRoutine[i],
                                                   NULL,
                                                   CallBack)) {

                        InterlockedDecrement ((PLONG) &PspCreateProcessNotifyRoutineCount);

                        ExDereferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i],
                                                    CallBack);

                        //
                        // Wait for any active callbacks to finish and free the block.
                        //
                        ExWaitForCallBacks (CallBack);
                    
                        ExFreeCallBack (CallBack);

                        return STATUS_SUCCESS;
                    }
                }
                ExDereferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i],
                                            CallBack);
            }
        }

        return STATUS_PROCEDURE_NOT_FOUND;
    } else {
        //
        // Allocate a new callback block.
        // 
        CallBack = ExAllocateCallBack ((PEX_CALLBACK_FUNCTION) NotifyRoutine, NULL);
        if (CallBack == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        for (i = 0; i < PSP_MAX_CREATE_PROCESS_NOTIFY; i++) {
            //
            // Try and swap a null entry for the new block.
            //
            if (ExCompareExchangeCallBack (&PspCreateProcessNotifyRoutine[i],
                                           CallBack,
                                           NULL)) {
                InterlockedIncrement ((PLONG) &PspCreateProcessNotifyRoutineCount);
                return STATUS_SUCCESS;
            }
        }
        //
        // No slots left. Free the block and return.
        //
        ExFreeCallBack (CallBack);
        return STATUS_INVALID_PARAMETER;
    }

}

NTSTATUS
PsSetCreateThreadNotifyRoutine(
    IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    )

/*++

Routine Description:

    This function allows an installable file system to hook into thread
    creation and deletion to track those events against their own internal
    data structures.

Arguments:

    NotifyRoutine - Supplies the address of the routine which is called at
        thread creation and deletion. The routine is passed the unique Id
        of the created or deleted thread and the unique Id of the containing
        process. The third parameter passed to the notify routine is TRUE if
        the thread is being created and FALSE if it is being deleted.

Return Value:

    STATUS_SUCCESS if successful, and STATUS_INSUFFICIENT_RESOURCES if not.

--*/

{

    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;

    PAGED_CODE();

    //
    // Allocate a new callback block.
    // 
    CallBack = ExAllocateCallBack ((PEX_CALLBACK_FUNCTION) NotifyRoutine, NULL);
    if (CallBack == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i += 1) {
        //
        // Try and swap a null entry for the new block.
        //
        if (ExCompareExchangeCallBack (&PspCreateThreadNotifyRoutine[i],
                                       CallBack,
                                       NULL)) {
            InterlockedIncrement ((PLONG) &PspCreateThreadNotifyRoutineCount);
            return STATUS_SUCCESS;
        }
    }
    //
    // No slots left. Free the block and return.
    //
    ExFreeCallBack (CallBack);
    return STATUS_INSUFFICIENT_RESOURCES;
}

NTSTATUS
PsRemoveCreateThreadNotifyRoutine (
    IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    )
/*++

Routine Description:

    This function allows an installable file system to unhook from thread
    creation and deletion.

Arguments:

    NotifyRoutine - Supplies the address of the routine which was previously
                    registered with PsSetCreateThreadNotifyRoutine

Return Value:

    STATUS_SUCCESS if successful, and STATUS_PROCEDURE_NOT_FOUND if not.

--*/
{
    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;

    PAGED_CODE();

    for (i = 0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i += 1) {

        //
        // Reference the callback so we can check its routine address.
        //
        CallBack = ExReferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i]);

        if (CallBack != NULL) {
            //
            // See if the routine matches our target
            //
            if ((PCREATE_THREAD_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack) == NotifyRoutine) {

                if (ExCompareExchangeCallBack (&PspCreateThreadNotifyRoutine[i],
                                               NULL,
                                               CallBack)) {

                    InterlockedDecrement ((PLONG) &PspCreateThreadNotifyRoutineCount);

                    ExDereferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i],
                                                CallBack);

                    //
                    // Wait for any active callbacks to finish and free the block.
                    //
                    ExWaitForCallBacks (CallBack);
                    
                    ExFreeCallBack (CallBack);

                    return STATUS_SUCCESS;
                }
            }
            ExDereferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i],
                                        CallBack);
        }
    }

    return STATUS_PROCEDURE_NOT_FOUND;
}

VOID
PspUserThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    )

/*++

Routine Description:

    This function is called by the kernel to start a user-mode thread.

Arguments:

    StartRoutine - Ignored.

    StartContext - Supplies the initial pc value for the thread.

Return Value:

    None.

--*/

{
    PETHREAD Thread;
    PEPROCESS Process;
    PTEB Teb;
    ULONG OldFlags;
    BOOLEAN KillThread;
    KIRQL OldIrql;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(StartRoutine);

    KeLowerIrql (PASSIVE_LEVEL);

    Thread = PsGetCurrentThread ();
    Process = PsGetCurrentProcessByThread (Thread);

    //
    // All threads start with an APC at LdrInitializeThunk
    //

    //
    // See if we need to terminate early becuase of a error in the create path
    //
    KillThread = FALSE;
    if ((Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_DEADTHREAD) != 0) {
        KillThread = TRUE;
    }

    if (!KillThread) {
        Teb = NtCurrentTeb ();
        try {
            Teb->CurrentLocale = MmGetSessionLocaleId ();
            Teb->IdealProcessor = Thread->Tcb.IdealProcessor;
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    //
    // If the create worked then notify the debugger.
    //
    if ((Thread->CrossThreadFlags&
         (PS_CROSS_THREAD_FLAGS_DEADTHREAD|PS_CROSS_THREAD_FLAGS_HIDEFROMDBG)) == 0) {
        DbgkCreateThread (Thread, StartContext);
    }

    //
    // If something went wrong then terminate the thread
    //
    if (KillThread) {
        PspTerminateThreadByPointer (Thread,
                                     STATUS_THREAD_IS_TERMINATING,
                                     TRUE);
    } else {

        if (CCPF_IS_PREFETCHER_ENABLED()) {

            //
            // If this is the first thread we are starting up in this process,
            // prefetch the pages likely to be used when initializing the 
            // application into the system cache.
            //

            if ((Process->Flags & PS_PROCESS_FLAGS_LAUNCH_PREFETCHED) == 0) {

                OldFlags = PS_TEST_SET_BITS(&Process->Flags, PS_PROCESS_FLAGS_LAUNCH_PREFETCHED);

                if ((OldFlags & PS_PROCESS_FLAGS_LAUNCH_PREFETCHED) == 0) {

                    if (Process->SectionObject) {

                        //
                        // Notify cache manager of this application launch.
                        //

                        CcPfBeginAppLaunch(Process, Process->SectionObject);
                    }
                }
            }
        }

        //
        // Queue the initial APC to the thread
        //

        KeRaiseIrql (APC_LEVEL, &OldIrql);

        KiInitializeUserApc (PspGetBaseExceptionFrame (Thread),
                             PspGetBaseTrapFrame (Thread),
                             PspSystemDll.LoaderInitRoutine,
                             NULL,
                             PspSystemDll.DllBase,
                             NULL);

        KeLowerIrql (PASSIVE_LEVEL);
    }
}



ULONG
PspUnhandledExceptionInSystemThread(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )
{
    KdPrint(("PS: Unhandled Kernel Mode Exception Pointers = 0x%p\n", ExceptionPointers));
    KdPrint(("Code %x Addr %p Info0 %p Info1 %p Info2 %p Info3 %p\n",
        ExceptionPointers->ExceptionRecord->ExceptionCode,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord->ExceptionAddress,
        ExceptionPointers->ExceptionRecord->ExceptionInformation[0],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[1],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[2],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[3]
        ));

    KeBugCheckEx(
        SYSTEM_THREAD_EXCEPTION_NOT_HANDLED,
        ExceptionPointers->ExceptionRecord->ExceptionCode,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord->ExceptionAddress,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord,
        (ULONG_PTR)ExceptionPointers->ContextRecord);

//    return EXCEPTION_EXECUTE_HANDLER;
}

// PspUnhandledExceptionInSystemThread doesn't return, and the compiler
// sometimes gives 'unreachable code' warnings as a result.
#pragma warning(push)
#pragma warning(disable:4702)

VOID
PspSystemThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    )

/*++

Routine Description:

    This function is called by the kernel to start a system thread.

Arguments:

    StartRoutine - Supplies the address of the system threads entry point.

    StartContext - Supplies a context value for the system thread.

Return Value:

    None.

--*/

{
    PETHREAD Thread;

    KeLowerIrql(0);

    Thread = PsGetCurrentThread ();

    try {
        if ((Thread->CrossThreadFlags&(PS_CROSS_THREAD_FLAGS_TERMINATED|PS_CROSS_THREAD_FLAGS_DEADTHREAD)) == 0) {
            (StartRoutine)(StartContext);
        }
    } except (PspUnhandledExceptionInSystemThread(GetExceptionInformation())) {
        KeBugCheck(KMODE_EXCEPTION_NOT_HANDLED);
    }
    PspTerminateThreadByPointer (Thread, STATUS_SUCCESS, TRUE);
}

#pragma warning(pop)



HANDLE
PsGetCurrentProcessId( VOID )
{
    return PsGetCurrentThread()->Cid.UniqueProcess;
}

HANDLE
PsGetCurrentThreadId( VOID )
{
    return PsGetCurrentThread()->Cid.UniqueThread;
}

BOOLEAN
PsGetVersion(
    PULONG MajorVersion OPTIONAL,
    PULONG MinorVersion OPTIONAL,
    PULONG BuildNumber OPTIONAL,
    PUNICODE_STRING CSDVersion OPTIONAL
    )
{
    if (ARGUMENT_PRESENT(MajorVersion)) {
        *MajorVersion = NtMajorVersion;
    }

    if (ARGUMENT_PRESENT(MinorVersion)) {
        *MinorVersion = NtMinorVersion;
    }

    if (ARGUMENT_PRESENT(BuildNumber)) {
        *BuildNumber = NtBuildNumber & 0x3FFF;
    }

    if (ARGUMENT_PRESENT(CSDVersion)) {
        *CSDVersion = CmCSDVersionString;
    }
    return (BOOLEAN)((NtBuildNumber >> 28) == 0xC);
}

NTSTATUS
PsSetLoadImageNotifyRoutine(
    IN PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    )

/*++

Routine Description:

    This function allows a device driver to get notified for
    image loads. The notify is issued for both kernel and user
    mode image loads system-wide.

Arguments:

    NotifyRoutine - Supplies the address of a routine which is called at
        image load. The routine is passed information describing the
        image being loaded.

        The callout for creation happens just after the image is loaded
        into memory but before executiona of the image.

Return Value:

    STATUS_SUCCESS if successful, and STATUS_INVALID_PARAMETER if not.

--*/

{
    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;

    PAGED_CODE();

    //
    // Allocate a new callback block.
    // 
    CallBack = ExAllocateCallBack ((PEX_CALLBACK_FUNCTION) NotifyRoutine, NULL);
    if (CallBack == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i < PSP_MAX_LOAD_IMAGE_NOTIFY; i++) {
        //
        // Try and swap a null entry for the new block.
        //
        if (ExCompareExchangeCallBack (&PspLoadImageNotifyRoutine[i],
                                       CallBack,
                                       NULL)) {
            InterlockedIncrement ((PLONG) &PspLoadImageNotifyRoutineCount);
            PsImageNotifyEnabled = TRUE;
            return STATUS_SUCCESS;
        }
    }
    //
    // No slots left. Free the block and return.
    //
    ExFreeCallBack (CallBack);
    return STATUS_INSUFFICIENT_RESOURCES;
}

NTSTATUS
PsRemoveLoadImageNotifyRoutine(
    IN PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    )
/*++

Routine Description:

    This function allows an installable file system to unhook from image
    load notification.

Arguments:

    NotifyRoutine - Supplies the address of the routine which was previously
                    registered with PsSetLoadImageNotifyRoutine

Return Value:

    STATUS_SUCCESS if successful, and STATUS_PROCEDURE_NOT_FOUND if not.

--*/
{
    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;

    PAGED_CODE();

    for (i = 0; i < PSP_MAX_LOAD_IMAGE_NOTIFY; i++) {

        //
        // Reference the callback so we can check its routine address.
        //
        CallBack = ExReferenceCallBackBlock (&PspLoadImageNotifyRoutine[i]);

        if (CallBack != NULL) {
            //
            // See if the routine matches our target
            //
            if ((PLOAD_IMAGE_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack) == NotifyRoutine) {

                if (ExCompareExchangeCallBack (&PspLoadImageNotifyRoutine[i],
                                               NULL,
                                               CallBack)) {

                    InterlockedDecrement ((PLONG) &PspLoadImageNotifyRoutineCount);

                    ExDereferenceCallBackBlock (&PspLoadImageNotifyRoutine[i],
                                                CallBack);

                    //
                    // Wait for any active callbacks to finish and free the block.
                    //
                    ExWaitForCallBacks (CallBack);
                    
                    ExFreeCallBack (CallBack);

                    return STATUS_SUCCESS;
                }
            }
            ExDereferenceCallBackBlock (&PspLoadImageNotifyRoutine[i],
                                        CallBack);
        }
    }

    return STATUS_PROCEDURE_NOT_FOUND;
}

VOID
PsCallImageNotifyRoutines(
    IN PUNICODE_STRING FullImageName,
    IN HANDLE ProcessId,                // pid into which image is being mapped
    IN PIMAGE_INFO ImageInfo
    )
/*++

Routine Description:

    This function actually calls the registered image notify functions (on behalf)
    of mapview.c and sysload.c

Arguments:

    FullImageName - The name of the image being loaded

    ProcessId - The process that the image is being loaded into (0 for driver loads)

    ImageInfo - Various flags for the image

Return Value:

    None.

--*/

{
    ULONG i;
    PEX_CALLBACK_ROUTINE_BLOCK CallBack;
    PLOAD_IMAGE_NOTIFY_ROUTINE Rtn;

    PAGED_CODE();

    if (PsImageNotifyEnabled) {
        for (i=0; i < PSP_MAX_LOAD_IMAGE_NOTIFY; i++) {
            CallBack = ExReferenceCallBackBlock (&PspLoadImageNotifyRoutine[i]);
            if (CallBack != NULL) {
                Rtn = (PLOAD_IMAGE_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack);
                Rtn (FullImageName,
                     ProcessId,
                     ImageInfo);
                ExDereferenceCallBackBlock (&PspLoadImageNotifyRoutine[i], CallBack);
            }
        }
    }
}

VOID
PspImageNotifyTest(
    IN PUNICODE_STRING FullImageName,
    IN HANDLE ProcessId,
    IN PIMAGE_INFO ImageInfo
    )
/*++

Routine Description:

    This function is registered as a image notify routine on checked systems to test the interface.

Arguments:

    FullImageName - The name of the image being loaded

    ProcessId - The process that the image is being loaded into (0 for driver loads)

    ImageInfo - Various flags for the image

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER (FullImageName);
    UNREFERENCED_PARAMETER (ProcessId);
    UNREFERENCED_PARAMETER (ImageInfo);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\pshelper.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pshelper.c

Abstract:

    EPROCESS and ETHREAD field access for NTOS-external components

Author:

    Gerardo Bermudez (gerardob) 10-Aug-1999

Revision History:

    5-Jan-03 msadek - added PsGetProcessSessionIdEx()

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, PsIsProcessBeingDebugged)
#pragma alloc_text (PAGE, PsIsThreadImpersonating)
#pragma alloc_text (PAGE, PsReferenceProcessFilePointer)
#pragma alloc_text (PAGE, PsSetProcessWin32Process)
#pragma alloc_text (PAGE, PsSetProcessSecurityPort)
#pragma alloc_text (PAGE, PsSetJobUIRestrictionsClass)
#pragma alloc_text (PAGE, PsSetProcessWindowStation)
#pragma alloc_text (PAGE, PsGetProcessSecurityPort)
#pragma alloc_text (PAGE, PsSetThreadWin32Thread)
#pragma alloc_text (PAGE, PsGetProcessExitProcessCalled)
#pragma alloc_text (PAGE, PsGetThreadSessionId)
#pragma alloc_text (PAGE, PsSetProcessPriorityClass)
#endif

/*++
--*/
#undef PsGetCurrentProcess
PEPROCESS
PsGetCurrentProcess(
    VOID
    )
{
    return _PsGetCurrentProcess();
}

/*++
--*/
ULONG PsGetCurrentProcessSessionId(
    VOID
    )
{
    return MmGetSessionId (_PsGetCurrentProcess());
}

/*++
--*/
#undef PsGetCurrentThread
PETHREAD
PsGetCurrentThread(
    VOID
    )
{
    return _PsGetCurrentThread();
}

/*++
--*/
PVOID
PsGetCurrentThreadStackBase(
    VOID
    )
{
    return KeGetCurrentThread()->StackBase;
}

/*++
--*/
PVOID
PsGetCurrentThreadStackLimit(
    VOID
    )
{
    return KeGetCurrentThread()->StackLimit;
}

/*++
--*/
CCHAR
PsGetCurrentThreadPreviousMode(
    VOID
    )
{
    return KeGetPreviousMode();
}

/*++
--*/
PERESOURCE
PsGetJobLock(
    PEJOB Job
    )
{
    return &Job->JobLock;
}

/*++
--*/
ULONG
PsGetJobSessionId(
    PEJOB Job
    )
{
    return Job->SessionId;
}

/*++
--*/
ULONG
PsGetJobUIRestrictionsClass(
    PEJOB Job
    )
{
    return Job->UIRestrictionsClass;
}

/*++
--*/
LONGLONG
PsGetProcessCreateTimeQuadPart(
    PEPROCESS Process
    )
{
    return Process->CreateTime.QuadPart;
}

/*++
--*/
PVOID
PsGetProcessDebugPort(
    PEPROCESS Process
    )
{
    return Process->DebugPort;
}


BOOLEAN
PsIsProcessBeingDebugged(
    PEPROCESS Process
    )
{
    if (Process->DebugPort != NULL) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*++
--*/
BOOLEAN
PsGetProcessExitProcessCalled(
    PEPROCESS Process
    )
{
    return (BOOLEAN) ((Process->Flags&PS_PROCESS_FLAGS_PROCESS_EXITING) != 0);
}

/*++
--*/
NTSTATUS
PsGetProcessExitStatus(
    PEPROCESS Process
    )
{
    return Process->ExitStatus;
}

/*++
--*/
HANDLE
PsGetProcessId(
    PEPROCESS Process
    )
{
    return Process->UniqueProcessId;
}


/*++
--*/
UCHAR *
PsGetProcessImageFileName(
    PEPROCESS Process
    )
{
    return Process->ImageFileName;
}


/*++
--*/

HANDLE
PsGetProcessInheritedFromUniqueProcessId(
    PEPROCESS Process
    )
{
    return Process->InheritedFromUniqueProcessId;
}


/*++
--*/
PEJOB
PsGetProcessJob(
    PEPROCESS Process
    )
{
    return Process->Job;
}


/*++
--*/
ULONG
PsGetProcessSessionId(
    PEPROCESS Process
    )
{
    return MmGetSessionId (Process);
}


/*++
--*/
ULONG
PsGetProcessSessionIdEx(
    PEPROCESS Process
    )
{
    return MmGetSessionIdEx (Process);
}


/*++
--*/
PVOID
PsGetProcessSectionBaseAddress(
    PEPROCESS Process
    )
{
    return Process->SectionBaseAddress;
}


/*++
--*/
PPEB
PsGetProcessPeb(
    PEPROCESS Process
    )
{
    return Process->Peb;
}


/*++
--*/
UCHAR
PsGetProcessPriorityClass(
    PEPROCESS Process
    )
{
    return Process->PriorityClass;
}

/*++
--*/
HANDLE
PsGetProcessWin32WindowStation(
    PEPROCESS Process
    )
{
    return Process->Win32WindowStation;
}


/*++
--*/

PVOID
PsGetProcessWin32Process(
    PEPROCESS Process
    )
{
    return Process->Win32Process;
}


/*++
--*/

PVOID
PsGetProcessWow64Process(
    PEPROCESS Process
    )
{
    return PS_GET_WOW64_PROCESS (Process);
}

/*++
--*/
HANDLE
PsGetThreadId(
    PETHREAD Thread
     )
{
    return Thread->Cid.UniqueThread;
}


/*++
--*/
CCHAR
PsGetThreadFreezeCount(
    PETHREAD Thread
    )
{
    return Thread->Tcb.FreezeCount;
}


/*++
--*/
BOOLEAN
PsGetThreadHardErrorsAreDisabled(
    PETHREAD Thread)
{
    return (BOOLEAN) (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) != 0;
}


/*++
--*/
PEPROCESS
PsGetThreadProcess(
    PETHREAD Thread
     )
{
    return THREAD_TO_PROCESS(Thread);
}


/*++
--*/

HANDLE
PsGetThreadProcessId(
    PETHREAD Thread
     )
{
    return Thread->Cid.UniqueProcess;
}


/*++
--*/

ULONG
PsGetThreadSessionId(
    PETHREAD Thread
     )
{
    return MmGetSessionId (THREAD_TO_PROCESS(Thread));
}



/*++
--*/
PVOID
PsGetThreadTeb(
    PETHREAD Thread
     )
{
    return Thread->Tcb.Teb;
}


/*++
--*/
PVOID
PsGetThreadWin32Thread(
    PETHREAD Thread
     )
{
    return Thread->Tcb.Win32Thread;
}


/*++
--*/
BOOLEAN
PsIsSystemThread(
    PETHREAD Thread
     )
{
    return (BOOLEAN)(IS_SYSTEM_THREAD(Thread));
}


/*++
--*/

VOID
PsSetJobUIRestrictionsClass(
    PEJOB Job,
    ULONG UIRestrictionsClass
    )
{
    Job->UIRestrictionsClass = UIRestrictionsClass;
}

/*++
--*/

VOID
PsSetProcessPriorityClass(
    PEPROCESS Process,
    UCHAR PriorityClass
    )
{
    Process->PriorityClass = PriorityClass;
}


/*++
--*/
NTSTATUS
PsSetProcessWin32Process(
    PEPROCESS Process,
    PVOID Win32Process,
    PVOID PrevWin32Process
    )
{
    NTSTATUS Status;
    PETHREAD CurrentThread;

    Status = STATUS_SUCCESS;

    CurrentThread = PsGetCurrentThread ();

    PspLockProcessExclusive (Process, CurrentThread);

    if (Win32Process != NULL) {
        if ((Process->Flags&PS_PROCESS_FLAGS_PROCESS_DELETE) == 0 && Process->Win32Process == NULL) {
            Process->Win32Process = Win32Process;
        } else {
            Status = STATUS_PROCESS_IS_TERMINATING;
        }
    } else {
        if (Process->Win32Process == PrevWin32Process) {
            Process->Win32Process = NULL;
        } else {
            Status = STATUS_UNSUCCESSFUL;       
        }
    }

    PspUnlockProcessExclusive (Process, CurrentThread);
 
    return Status;
}



/*++
--*/
VOID
PsSetProcessWindowStation(
    PEPROCESS Process,
    HANDLE Win32WindowStation
    )
{
     Process->Win32WindowStation = Win32WindowStation;
}


/*++
--*/
VOID
PsSetThreadHardErrorsAreDisabled(
    PETHREAD Thread,
    BOOLEAN HardErrorsAreDisabled
    )
{
    if (HardErrorsAreDisabled) {
        PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED);
    } else {
        PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED);
    }
}


/*++
--*/
VOID
PsSetThreadWin32Thread(
    PETHREAD Thread,
    PVOID Win32Thread,
    PVOID PrevWin32Thread
    )
{
    if (Win32Thread != NULL) {
        InterlockedExchangePointer(&Thread->Tcb.Win32Thread, Win32Thread);
    } else {
        InterlockedCompareExchangePointer(&Thread->Tcb.Win32Thread, Win32Thread, PrevWin32Thread);
    }
}




/*++
--*/
PVOID
PsGetProcessSecurityPort(
    PEPROCESS Process
    )
{
    return Process->SecurityPort ;
}

/*++
--*/
NTSTATUS
PsSetProcessSecurityPort(
    PEPROCESS Process,
    PVOID Port
    )
{
    Process->SecurityPort = Port ;
    return STATUS_SUCCESS ;
}

BOOLEAN
PsIsThreadImpersonating (
    IN PETHREAD Thread
    )
/*++

Routine Description:

    This routine returns TRUE if the specified thread is impersonating otherwise it returns false.

Arguments:

    Thread - Thread to be queried

Return Value:

    BOOLEAN - TRUE: Thread is impersonating, FALSE: Thread is not impersonating.

--*/
{
    PAGED_CODE ();

    return (BOOLEAN) (PS_IS_THREAD_IMPERSONATING (Thread));
}


NTSTATUS
PsReferenceProcessFilePointer (
    IN PEPROCESS Process,
    OUT PVOID *OutFileObject
    )

/*++

Routine Description:

    This routine returns a referenced pointer to the FilePointer of Process.  
    This is a rundown protected wrapper around MmGetFileObjectForSection.

Arguments:

    Process - Supplies the process to query.

    OutFileObject - Returns the file object backing the requested section if
                    success is returned.

Return Value:

    NTSTATUS.
    
Environment:

    Kernel mode, PASSIVE_LEVEL.

--*/

{
    PFILE_OBJECT FileObject;

    PAGED_CODE();
    
    if (!ExAcquireRundownProtection (&Process->RundownProtect)) {
        return STATUS_UNSUCCESSFUL;
    }

    if (Process->SectionObject == NULL) {
        ExReleaseRundownProtection (&Process->RundownProtect);
        return STATUS_UNSUCCESSFUL;
    }

    FileObject = MmGetFileObjectForSection ((PVOID)Process->SectionObject);

    *OutFileObject = FileObject;

    ObReferenceObject (FileObject);

    ExReleaseRundownProtection (&Process->RundownProtect);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\psenum.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    psenum.c

Abstract:

    This module enumerates the actve processes in the system

Author:

    Neill clift (NeillC) 23-Mar-2000


Revision History:

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PsEnumProcesses)
#pragma alloc_text(PAGE, PsGetNextProcess)
#pragma alloc_text(PAGE, PsQuitNextProcess)
#pragma alloc_text(PAGE, PsEnumProcessThreads)
#pragma alloc_text(PAGE, PsGetNextProcessThread)
#pragma alloc_text(PAGE, PsQuitNextProcessThread)
#pragma alloc_text(PAGE, PsGetNextJob)
#pragma alloc_text(PAGE, PsGetNextJobProcess)
#pragma alloc_text(PAGE, PsQuitNextJob)
#pragma alloc_text(PAGE, PsQuitNextJobProcess)
#pragma alloc_text(PAGE, PspGetNextJobProcess)
#pragma alloc_text(PAGE, PspQuitNextJobProcess)
#pragma alloc_text(PAGE, NtGetNextProcess)
#pragma alloc_text(PAGE, NtGetNextThread)
#endif

NTSTATUS
PsEnumProcesses (
    IN PROCESS_ENUM_ROUTINE CallBack,
    IN PVOID Context
    )
/*++

Routine Description:

    This function calls the callback routine for each active process in the system.
    Process objects in the process of being deleted are skipped.
    Returning anything but a success code from the callback routine terminates the enumeration at that point.
    Processes may be referenced and used later safely.

Arguments:

    CallBack - Routine to be called with its first parameter the enumerated process

Return Value:

    NTSTATUS - Status of call

--*/
{
    PLIST_ENTRY ListEntry;
    PEPROCESS Process, NewProcess;
    PETHREAD CurrentThread;
    NTSTATUS Status;

    Process = NULL;

    CurrentThread = PsGetCurrentThread ();

    PspLockProcessList (CurrentThread);

    for (ListEntry = PsActiveProcessHead.Flink;
         ListEntry != &PsActiveProcessHead;
         ListEntry = ListEntry->Flink) {

        NewProcess = CONTAINING_RECORD (ListEntry, EPROCESS, ActiveProcessLinks);
        if (ObReferenceObjectSafe (NewProcess)) {

            PspUnlockProcessList (CurrentThread);

            if (Process != NULL) {
                ObDereferenceObject (Process);
            }

            Process = NewProcess;

            Status = CallBack (Process, Context);

            if (!NT_SUCCESS (Status)) {
                ObDereferenceObject (Process);
                return Status;
            }

            PspLockProcessList (CurrentThread);

        }
    }

    PspUnlockProcessList (CurrentThread);

    if (Process != NULL) {
        ObDereferenceObject (Process);
    }

    return STATUS_SUCCESS;
}

PEPROCESS
PsGetNextProcess (
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function allows code to enumerate all the active processes in the system.
    The first process (if Process is NULL) or subsequent process (if process not NULL) is returned on
    each call.
    If process is not NULL then this process must have previously been obtained by a call to PsGetNextProcess.
    Enumeration may be terminated early by calling PsQuitNextProcess on the last non-NULL process
    returned by PsGetNextProcess.

    Processes may be referenced and used later safely.

    For example, to enumerate all system processes in a loop use this code fragment:

    for (Process = PsGetNextProcess (NULL);
         Process != NULL;
         Process = PsGetNextProcess (Process)) {
         ...
         ...
         //
         // Early terminating conditions are handled like this:
         //
         if (NeedToBreakOutEarly) {
             PsQuitNextProcess (Process);
             break;
         }
    }
    

Arguments:

    Process - Process to get the next process from or NULL for the first process

Return Value:

    PEPROCESS - Next process or NULL if no more processes available

--*/
{
    PEPROCESS NewProcess = NULL;
    PETHREAD CurrentThread;
    PLIST_ENTRY ListEntry;

    CurrentThread = PsGetCurrentThread ();

    PspLockProcessList (CurrentThread);

    for (ListEntry = (Process == NULL) ? PsActiveProcessHead.Flink : Process->ActiveProcessLinks.Flink;
         ListEntry != &PsActiveProcessHead;
         ListEntry = ListEntry->Flink) {

        NewProcess = CONTAINING_RECORD (ListEntry, EPROCESS, ActiveProcessLinks);

        //
        // Processes are removed from this list during process objected deletion (object reference count goes
        // to zero). To prevent double deletion of the process we need to do a safe reference here.
        //
        if (ObReferenceObjectSafe (NewProcess)) {
            break;
        }
        NewProcess = NULL;
    }
    PspUnlockProcessList (CurrentThread);

    if (Process != NULL) {
        ObDereferenceObject (Process);
    }

    return NewProcess;
}


VOID
PsQuitNextProcess (
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function is used to terminate early a process enumeration using PsGetNextProcess

Arguments:

    Process - Non-NULL process previously obtained by a call to PsGetNextProcess.

Return Value:

    None

--*/
{
    ObDereferenceObject (Process);
}

PETHREAD
PsGetNextProcessThread (
    IN PEPROCESS Process,
    IN PETHREAD Thread
    )
/*++

Routine Description:

    This function is used to enumerate the threads in a process.


Arguments:

    Process - Process to enumerate
    Thread  - Thread to start enumeration from. This must have been obtained from previous call to
              PsGetNextProcessThread. If NULL enumeration starts at the first non-terminating thread in the process.

Return Value:

    PETHREAD - Pointer to a non-terminated process thread or a NULL if there are non. This thread must be passed
               either to another call to PsGetNextProcessThread or PsQuitNextProcessThread.

--*/
{
    PLIST_ENTRY ListEntry;
    PETHREAD NewThread, CurrentThread;

    PAGED_CODE ();
 
    CurrentThread = PsGetCurrentThread ();

    PspLockProcessShared (Process, CurrentThread);

    for (ListEntry = (Thread == NULL) ? Process->ThreadListHead.Flink : Thread->ThreadListEntry.Flink;
         ;
         ListEntry = ListEntry->Flink) {
        if (ListEntry != &Process->ThreadListHead) {
            NewThread = CONTAINING_RECORD (ListEntry, ETHREAD, ThreadListEntry);
            //
            // Don't reference a thread thats in its delete routine
            //
            if (ObReferenceObjectSafe (NewThread)) {
                break;
            }
        } else {
            NewThread = NULL;
            break;
        }
    }
    PspUnlockProcessShared (Process, CurrentThread);

    if (Thread != NULL) {
        ObDereferenceObject (Thread);
    }
    return NewThread;
}

VOID
PsQuitNextProcessThread (
    IN PETHREAD Thread
    )
/*++

Routine Description:

    This function quits thread enumeration early.

Arguments:

    Thread - Thread obtained from a call to PsGetNextProcessThread

Return Value:

    None.

--*/
{
    ObDereferenceObject (Thread);
}

NTSTATUS
PsEnumProcessThreads (
    IN PEPROCESS Process,
    IN THREAD_ENUM_ROUTINE CallBack,
    IN PVOID Context
    )
/*++

Routine Description:

    This function calls the callback routine for each active thread in the process.
    Thread objects in the process of being deleted are skipped.
    Returning anything but a success code from the callback routine terminates the enumeration at that point.
    Thread may be referenced and used later safely.

Arguments:

    CallBack - Routine to be called with its first parameter the enumerated process

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    PETHREAD Thread;

    Status = STATUS_SUCCESS;
    for (Thread = PsGetNextProcessThread (Process, NULL);
         Thread != NULL;
         Thread = PsGetNextProcessThread (Process, Thread)) {
        Status = CallBack (Process, Thread, Context);
        if (!NT_SUCCESS (Status)) {
            PsQuitNextProcessThread (Thread);
            break;
        }
    }
    return Status;
}

PEJOB
PsGetNextJob (
    IN PEJOB Job
    )
/*++

Routine Description:

    This function allows code to enumerate all the active jobs in the system.
    The first job (if Job is NULL) or subsequent jobs (if Job not NULL) is returned on
    each call.
    If Job is not NULL then this job must have previously been obtained by a call to PsGetNextJob.
    Enumeration may be terminated early by calling PsQuitNextJob on the last non-NULL job
    returned by PsGetNextJob.

    Jobs may be referenced and used later safely.

    For example, to enumerate all system jobs in a loop use this code fragment:

    for (Job = PsGetNextJob (NULL);
         Job != NULL;
         Job = PsGetNextJob (Job)) {
         ...
         ...
         //
         // Early terminating conditions are handled like this:
         //
         if (NeedToBreakOutEarly) {
             PsQuitNextJob (Job);
             break;
         }
    }
    

Arguments:

    Job - Job from a previous call to PsGetNextJob or NULL for the first job in the system

Return Value:

    PEJOB - Next job in the system or NULL if none available.

--*/
{
    PEJOB NewJob = NULL;
    PLIST_ENTRY ListEntry;
    PETHREAD CurrentThread;

    CurrentThread = PsGetCurrentThread ();

    PspLockJobListShared (CurrentThread);

    for (ListEntry = (Job == NULL) ? PspJobList.Flink : Job->JobLinks.Flink;
         ListEntry != &PspJobList;
         ListEntry = ListEntry->Flink) {

        NewJob = CONTAINING_RECORD (ListEntry, EJOB, JobLinks);

        //
        // Jobs are removed from this list during job objected deletion (object reference count goes
        // to zero). To prevent double deletion of the job we need to do a safe reference here.
        //
        if (ObReferenceObjectSafe (NewJob)) {
            break;
        }
        NewJob = NULL;
    }

    PspUnlockJobListShared (CurrentThread);

    if (Job != NULL) {
        ObDereferenceObject (Job);
    }

    return NewJob;
}


VOID
PsQuitNextJob (
    IN PEJOB Job
    )
/*++

Routine Description:

    This function is used to terminate early a job enumeration using PsGetNextJob

Arguments:

    Job - Non-NULL job previously obtained by a call to PsGetNextJob.

Return Value:

    None

--*/
{
    ObDereferenceObject (Job);
}

PEPROCESS
PsGetNextJobProcess (
    IN PEJOB Job,
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function is used to enumerate the processes in a job.


Arguments:

    Job     - Job to Enumerate
    Process - Process to start enumeration from. This must have been obtained from previous call to
              PsGetNextJobProcess. If NULL enumeration starts at the first non-terminating process in the Job.

Return Value:

    PEPROCESS - Pointer to a non-terminated process or a NULL if there are non. This process must be passed
                either to another call to PsGetNextJobProcess or PsQuitNextJobProcess.

--*/
{
    PLIST_ENTRY ListEntry;
    PEPROCESS NewProcess;
    PETHREAD CurrentThread;

    PAGED_CODE ();
 
    CurrentThread = PsGetCurrentThread ();

    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

    for (ListEntry = (Process == NULL) ? Job->ProcessListHead.Flink : Process->JobLinks.Flink;
         ;
         ListEntry = ListEntry->Flink) {
        if (ListEntry != &Job->ProcessListHead) {
            NewProcess = CONTAINING_RECORD (ListEntry, EPROCESS, JobLinks);
            //
            // Don't reference a process thats in its delete routine
            //
            if (ObReferenceObjectSafe (NewProcess)) {
                break;
            }
        } else {
            NewProcess = NULL;
            break;
        }
    }

    ExReleaseResourceLite (&Job->JobLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);


    if (Process != NULL) {
        ObDereferenceObject (Process);
    }
    return NewProcess;
}

VOID
PsQuitNextJobProcess (
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function quits job process enumeration early.

Arguments:

    Process - Process obtained from a call to PsGetNextJobProcess

Return Value:

    None.

--*/
{
    ObDereferenceObject (Process);
}

PEPROCESS
PspGetNextJobProcess (
    IN PEJOB Job,
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function is used to enumerate the processes in a job with the job lock held.


Arguments:

    Job     - Job to Enumerate
    Process - Process to start enumeration from. This must have been obtained from previous call to
              PsGetNextJobProcess. If NULL enumeration starts at the first non-terminating process in the Job.

Return Value:

    PEPROCESS - Pointer to a non-terminated process or a NULL if there are non. This process must be passed
                either to another call to PsGetNextJobProcess or PsQuitNextJobProcess.

--*/
{
    PLIST_ENTRY ListEntry;
    PEPROCESS NewProcess;

    PAGED_CODE ();
 
    for (ListEntry = (Process == NULL) ? Job->ProcessListHead.Flink : Process->JobLinks.Flink;
         ;
         ListEntry = ListEntry->Flink) {
        if (ListEntry != &Job->ProcessListHead) {
            NewProcess = CONTAINING_RECORD (ListEntry, EPROCESS, JobLinks);
            //
            // Don't reference a process thats in its delete routine
            //
            if (ObReferenceObjectSafe (NewProcess)) {
                break;
            }
        } else {
            NewProcess = NULL;
            break;
        }
    }

    if (Process != NULL) {
        ObDereferenceObjectDeferDelete (Process);
    }
    return NewProcess;
}

VOID
PspQuitNextJobProcess (
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function quits job process enumeration early.

Arguments:

    Process - Process obtained from a call to PsGetNextJobProcess

Return Value:

    None.

--*/
{
    ObDereferenceObjectDeferDelete (Process);
}

NTSTATUS
NtGetNextProcess (
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewProcessHandle
    )
/*++

Routine Description:

    This function gets the next for first process in the list of all processes in the system

Arguments:

    ProcessHandle - Process obtained from a previous call to NtGetNextProcess or NULL for the first process
    DesiredAccess - Access requested for process handle
    HandleAttributes - Handle attributes requested.
    Flags - Flags for the operation
    NewProcessHandle - Pointer to a handle value that is returned on sucess

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    KPROCESSOR_MODE PreviousMode;
    PEPROCESS Process, NewProcess;
    NTSTATUS Status;
    ACCESS_STATE AccessState;
    AUX_ACCESS_DATA AuxData;
    HANDLE Handle;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode ();

    //
    // Sanitize handle attributes
    //
    HandleAttributes = ObSanitizeHandleAttributes (HandleAttributes, PreviousMode);

    //
    // Validate pointer arguments
    //

    try {
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle (NewProcessHandle);
        }
        *NewProcessHandle = NULL;
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    //
    // Check for inclusion of reserved flags and reject the call if present
    //

    if (Flags != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    if (ProcessHandle == NULL) {
        Process = NULL;
    } else {
        Status = ObReferenceObjectByHandle (ProcessHandle,
                                            0,
                                            PsProcessType,
                                            PreviousMode,
                                            &Process,
                                            NULL);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    }

    NewProcess = PsGetNextProcess (Process);

    if (NewProcess == NULL) {
        return STATUS_NO_MORE_ENTRIES;
    }

    Status = SeCreateAccessState (&AccessState,
                                  &AuxData,
                                  DesiredAccess,
                                  &PsProcessType->TypeInfo.GenericMapping);

    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (NewProcess);
        return Status;
    }

    if (SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)) {
        if (AccessState.RemainingDesiredAccess & MAXIMUM_ALLOWED) {
            AccessState.PreviouslyGrantedAccess |= PROCESS_ALL_ACCESS;
        } else {
            AccessState.PreviouslyGrantedAccess |= AccessState.RemainingDesiredAccess;
        }
        AccessState.RemainingDesiredAccess = 0;
    }


    while (1) {
        if (NewProcess->GrantedAccess != 0) {

            Status = ObOpenObjectByPointer (NewProcess,
                                            HandleAttributes,
                                            &AccessState,
                                            0,
                                            PsProcessType,
                                            PreviousMode,
                                            &Handle);
            if (NT_SUCCESS (Status)) {
                try {
                    *NewProcessHandle = Handle;
                } except (ExSystemExceptionFilter ()) {
                    Status = GetExceptionCode ();
                }
                break;
            }

            if (Status != STATUS_ACCESS_DENIED) {
                break;
            }
        }

        NewProcess = PsGetNextProcess (NewProcess);

        if (NewProcess == NULL) {
            Status = STATUS_NO_MORE_ENTRIES;
            break;
        }
    }

    SeDeleteAccessState (&AccessState);

    if (NewProcess != NULL) {
        ObDereferenceObject (NewProcess);
    }

    return Status;
}

NTSTATUS
NtGetNextThread (
    IN HANDLE ProcessHandle,
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewThreadHandle
    )
/*++

Routine Description:

    This function gets the next for first thread in a process

Arguments:

    ProcessHandle - Process that is being enumerated
    ThreadHandle - Last thread returned by the enumeration routine or NULL if the first is required
    DesiredAccess - Access requested for thread handle
    HandleAttributes - Handle attributes requested.
    Flags - Flags for the operation
    NewThreadHandle - Pointer to a handle value that is returned on sucess

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    KPROCESSOR_MODE PreviousMode;
    PEPROCESS Process;
    PETHREAD Thread, NewThread;
    NTSTATUS Status;
    ACCESS_STATE AccessState;
    AUX_ACCESS_DATA AuxData;
    HANDLE Handle;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode ();

    //
    // Sanitize handle attributes
    //

    HandleAttributes = ObSanitizeHandleAttributes (HandleAttributes, PreviousMode);

    //
    // Validate pointer arguments
    //

    try {
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle (NewThreadHandle);
        }
        *NewThreadHandle = NULL;
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    //
    // Check for inclusion of reserved flags and reject the call if present
    //

    if (Flags != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    if (ThreadHandle == NULL) {
        Thread = NULL;
    } else {
        Status = ObReferenceObjectByHandle (ThreadHandle,
                                            0,
                                            PsProcessType,
                                            PreviousMode,
                                            &Thread,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            ObDereferenceObject (Process);
            return Status;
        }

        //
        // Make sure 
        //

        if (THREAD_TO_PROCESS (Thread) != Process) {
            ObDereferenceObject (Thread);
            ObDereferenceObject (Process);
            return STATUS_INVALID_PARAMETER;
        }
    }

    NewThread = PsGetNextProcessThread (Process, Thread);


    if (NewThread == NULL) {
        ObDereferenceObject (Process);
        return STATUS_NO_MORE_ENTRIES;
    }

    Status = SeCreateAccessState (&AccessState,
                                  &AuxData,
                                  DesiredAccess,
                                  &PsProcessType->TypeInfo.GenericMapping);

    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (Process);
        ObDereferenceObject (NewThread);
        return Status;
    }

    if (SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)) {
        if (AccessState.RemainingDesiredAccess & MAXIMUM_ALLOWED) {
            AccessState.PreviouslyGrantedAccess |= PROCESS_ALL_ACCESS;
        } else {
            AccessState.PreviouslyGrantedAccess |= AccessState.RemainingDesiredAccess;
        }
        AccessState.RemainingDesiredAccess = 0;
    }


    while (1) {

        if (NewThread->GrantedAccess != 0) {
            Status = ObOpenObjectByPointer (NewThread,
                                            HandleAttributes,
                                            &AccessState,
                                            0,
                                            PsThreadType,
                                            PreviousMode,
                                            &Handle);
            if (NT_SUCCESS (Status)) {
                try {
                    *NewThreadHandle = Handle;
                } except (ExSystemExceptionFilter ()) {
                    Status = GetExceptionCode ();
                }
                break;
            }

            if (Status != STATUS_ACCESS_DENIED) {
                break;
            }
        }

        NewThread = PsGetNextProcessThread (Process, NewThread);

        if (NewThread == NULL) {
            Status = STATUS_NO_MORE_ENTRIES;
            break;
        }
    }

    SeDeleteAccessState (&AccessState);

    ObDereferenceObject (Process);
    if (NewThread != NULL) {
        ObDereferenceObject (NewThread);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\psimpers.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psimpers.c

Abstract:

    This module implements the NtImpersonateThread() service.


Author:

    Jim Kelly (JimK) 20-Apr-1991

Revision History:

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtImpersonateThread)
#endif //ALLOC_PRAGMA


NTSTATUS
NtImpersonateThread(
    IN HANDLE ServerThreadHandle,
    IN HANDLE ClientThreadHandle,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos
    )

/*++

Routine Description:

    This routine is used to cause the server thread to impersonate the client
    thread.  The impersonation is done according to the specified quality
    of service parameters.



Arguments:

    ServerThreadHandle - Is a handle to the server thread (the impersonator, or
        doing the impersonation).  This handle must be open for
        THREAD_IMPERSONATE access.

    ClientThreadHandle - Is a handle to the Client thread (the impersonatee, or
        one being impersonated).   This handle must be open for
        THREAD_DIRECT_IMPERSONATION access.


    SecurityQos - A pointer to security quality of service information
        indicating what form of impersonation is to be performed.



Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.


--*/

{


    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PETHREAD ClientThread, ServerThread;
    SECURITY_QUALITY_OF_SERVICE CapturedQos;
    SECURITY_CLIENT_CONTEXT ClientSecurityContext;

    //
    // Get previous processor mode and probe and capture arguments if necessary
    //

    PreviousMode = KeGetPreviousMode();

    try {

        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure (SecurityQos,
                                        sizeof (SECURITY_QUALITY_OF_SERVICE),
                                        sizeof (ULONG));
        }
        CapturedQos = *SecurityQos;

    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }



    //
    // Reference the client thread, checking for appropriate access.
    //

    Status = ObReferenceObjectByHandle (ClientThreadHandle,           // Handle
                                        THREAD_DIRECT_IMPERSONATION,  // DesiredAccess
                                        PsThreadType,                 // ObjectType
                                        PreviousMode,                 // AccessMode
                                        &ClientThread,                // Object
                                        NULL);                        // GrantedAccess

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Reference the client thread, checking for appropriate access.
    //

    Status = ObReferenceObjectByHandle (ServerThreadHandle,           // Handle
                                        THREAD_IMPERSONATE,           // DesiredAccess
                                        PsThreadType,                 // ObjectType
                                        PreviousMode,                 // AccessMode
                                        &ServerThread,                // Object
                                        NULL);                        // GrantedAccess

    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (ClientThread);
        return Status;
    }


    //
    // Get the client's security context
    //

    Status = SeCreateClientSecurity (ClientThread,             // ClientThread
                                     &CapturedQos,             // SecurityQos
                                     FALSE,                    // ServerIsRemote
                                     &ClientSecurityContext);  // ClientContext

    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (ServerThread);
        ObDereferenceObject (ClientThread);
        return Status;
    }


    //
    // Impersonate the client
    //

    Status = SeImpersonateClientEx (&ClientSecurityContext, ServerThread);

    SeDeleteClientSecurity (&ClientSecurityContext);

    //
    // Done.
    //


    ObDereferenceObject (ServerThread);
    ObDereferenceObject (ClientThread);

    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\psjob.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    psjob.c

Abstract:

    This module implements bulk of the job object support

Author:

    Mark Lucovsky (markl) 22-May-1997

Revision History:

--*/

#include "psp.h"
#include "winerror.h"

#pragma alloc_text(INIT, PspInitializeJobStructures)
#pragma alloc_text(INIT, PspInitializeJobStructuresPhase1)

#pragma alloc_text(PAGE, NtCreateJobObject)
#pragma alloc_text(PAGE, NtOpenJobObject)
#pragma alloc_text(PAGE, NtAssignProcessToJobObject)
#pragma alloc_text(PAGE, NtQueryInformationJobObject)
#pragma alloc_text(PAGE, NtSetInformationJobObject)
#pragma alloc_text(PAGE, NtTerminateJobObject)
#pragma alloc_text(PAGE, NtIsProcessInJob)
#pragma alloc_text(PAGE, NtCreateJobSet)
#pragma alloc_text(PAGE, PspJobDelete)
#pragma alloc_text(PAGE, PspJobClose)
#pragma alloc_text(PAGE, PspAddProcessToJob)
#pragma alloc_text(PAGE, PspRemoveProcessFromJob)
#pragma alloc_text(PAGE, PspExitProcessFromJob)
#pragma alloc_text(PAGE, PspApplyJobLimitsToProcessSet)
#pragma alloc_text(PAGE, PspApplyJobLimitsToProcess)
#pragma alloc_text(PAGE, PspTerminateAllProcessesInJob)
#pragma alloc_text(PAGE, PspFoldProcessAccountingIntoJob)
#pragma alloc_text(PAGE, PspCaptureTokenFilter)
#pragma alloc_text(PAGE, PsReportProcessMemoryLimitViolation)
#pragma alloc_text(PAGE, PspJobTimeLimitsWork)
#pragma alloc_text(PAGE, PsEnforceExecutionTimeLimits)
#pragma alloc_text(PAGE, PspShutdownJobLimits)
#pragma alloc_text(PAGE, PspGetJobFromSet)
#pragma alloc_text(PAGE, PsChangeJobMemoryUsage)
#pragma alloc_text(PAGE, PspWin32SessionCallout)

//
// move to io.h
extern POBJECT_TYPE IoCompletionObjectType;

KDPC PspJobTimeLimitsDpc;
KTIMER PspJobTimeLimitsTimer;
WORK_QUEUE_ITEM PspJobTimeLimitsWorkItem;
KGUARDED_MUTEX PspJobTimeLimitsLock;
BOOLEAN PspJobTimeLimitsShuttingDown;

#define PSP_ONE_SECOND      (10 * (1000*1000))
#define PSP_JOB_TIME_LIMITS_TIME    -7

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
LARGE_INTEGER PspJobTimeLimitsInterval = {0};
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif


NTSTATUS
NTAPI
NtCreateJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    )
{

    PEJOB Job;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create a job object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);
    try {

        //
        // Probe output handle address if
        // necessary.
        //

        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle (JobHandle);
        }
        *JobHandle = NULL;

    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode();
    }

    //
    // Allocate job object.
    //

    Status = ObCreateObject (PreviousMode,
                             PsJobType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof (EJOB),
                             0,
                             0,
                             &Job);

    //
    // If the job object was successfully allocated, then initialize it
    // and attempt to insert the job object in the current
    // process' handle table.
    //

    if (NT_SUCCESS(Status)) {

        RtlZeroMemory (Job, sizeof (EJOB));
        InitializeListHead (&Job->ProcessListHead);
        InitializeListHead (&Job->JobSetLinks);
        KeInitializeEvent (&Job->Event, NotificationEvent, FALSE);
        PspInitializeJobLimitsLock (Job);

        //
        // Job Object gets the SessionId of the Process creating the Job
        // We will use this sessionid to restrict the processes that can
        // be added to a job.
        //
        Job->SessionId = MmGetSessionId (PsGetCurrentProcessByThread (CurrentThread));

        //
        // Initialize the scheduling class for the Job
        //
        Job->SchedulingClass = PSP_DEFAULT_SCHEDULING_CLASSES;

        ExInitializeResourceLite (&Job->JobLock);

        PspLockJobListExclusive (CurrentThread);

        InsertTailList (&PspJobList, &Job->JobLinks);

        PspUnlockJobListExclusive (CurrentThread);


        Status = ObInsertObject (Job,
                                 NULL,
                                 DesiredAccess,
                                 0,
                                 NULL,
                                 &Handle);

        //
        // If the job object was successfully inserted in the current
        // process' handle table, then attempt to write the job object
        // handle value.
        //
        if (NT_SUCCESS (Status)) {
            try {
                *JobHandle = Handle;
            } except (ExSystemExceptionFilter ()) {
                 Status = GetExceptionCode ();
            }
        }
    }
    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NTAPI
NtOpenJobObject(
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open the job object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object open routine.
    //

    PreviousMode = KeGetPreviousMode ();

    if (PreviousMode != KernelMode) {
        try {

            //
            // Probe output handle address
            // if necessary.
            //

            ProbeForWriteHandle (JobHandle);

        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // If an exception occurs during the probe of the output job handle,
            // then always handle the exception and return the exception code as the
            // status value.
            //

            return GetExceptionCode ();
        }
    }


    //
    // Open handle to the event object with the specified desired access.
    //

    Status = ObOpenObjectByName (ObjectAttributes,
                                 PsJobType,
                                 PreviousMode,
                                 NULL,
                                 DesiredAccess,
                                 NULL,
                                 &Handle);

    //
    // If the open was successful, then attempt to write the job object
    // handle value. If the write attempt fails then just report an error.
    // When the caller attempts to access the handle value, an
    // access violation will occur.
    //

    if (NT_SUCCESS (Status)) {
        try {
            *JobHandle = Handle;
        } except(ExSystemExceptionFilter ()) {
            return GetExceptionCode ();
        }
    }

    return Status;
}

NTSTATUS
NTAPI
NtAssignProcessToJobObject(
    IN HANDLE JobHandle,
    IN HANDLE ProcessHandle
    )
{
    PEJOB Job;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    NTSTATUS Status, Status1;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN IsAdmin;
    PACCESS_TOKEN JobToken, NewToken = NULL;
    ULONG SessionId;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    //
    // Now reference the job object. Then we need to lock the process and check again
    //

    Status = ObReferenceObjectByHandle (JobHandle,
                                        JOB_OBJECT_ASSIGN_PROCESS,
                                        PsJobType,
                                        PreviousMode,
                                        &Job,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    JobToken = Job->Token;
       
    //
    // Reference the process object, lock the process, test for already been assigned
    //

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_QUOTA | PROCESS_TERMINATE |
                                            ((JobToken != NULL)?PROCESS_SET_INFORMATION:0),
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        ObDereferenceObject (Job);
        return Status;
    }

    //
    // Quick Check for prior assignment
    //

    if (Process->Job) {
        Status = STATUS_ACCESS_DENIED;
        goto deref_and_return_status;
    }

    //
    // We only allow a process that is running in the Job creator's hydra session
    // to be assigned to the job.
    //

    SessionId = MmGetSessionId (Process);
    if (SessionId != Job->SessionId) {
        Status = STATUS_ACCESS_DENIED;
        goto deref_and_return_status;
    }

    //
    // Security Rules:  If the job has no-admin set, and it is running
    // as admin, that's not allowed
    //

    if (Job->SecurityLimitFlags & JOB_OBJECT_SECURITY_NO_ADMIN) {
        PACCESS_TOKEN Token;

        Token = PsReferencePrimaryToken (Process);

        IsAdmin = SeTokenIsAdmin (Token);

        PsDereferencePrimaryTokenEx (Process, Token);

        if (IsAdmin) {
            Status = STATUS_ACCESS_DENIED;
            goto deref_and_return_status;
        }
    }

    //
    // Duplicate the primary token so we can assign it to the process.
    //
    if (JobToken != NULL) {
        Status = SeSubProcessToken (JobToken,
                                    &NewToken,
                                    FALSE,
                                    SessionId);

        if (!NT_SUCCESS (Status)) {
            goto deref_and_return_status;
        }
    }

    if (!ExAcquireRundownProtection (&Process->RundownProtect)) {
        Status = STATUS_PROCESS_IS_TERMINATING;
        if (JobToken != NULL) {
            ObDereferenceObject (NewToken);
        }
        goto deref_and_return_status;
    }


    //
    // ref the job for the process
    //

    ObReferenceObject (Job);

    if (InterlockedCompareExchangePointer (&Process->Job, Job, NULL) != NULL) {
        ExReleaseRundownProtection (&Process->RundownProtect);
        ObDereferenceObject (Process);
        ObDereferenceObjectEx (Job, 2);
        if (JobToken != NULL) {
            ObDereferenceObject (NewToken);
        }
        return STATUS_ACCESS_DENIED;
    }
    //
    // If the job has a token filter established,
    // use it to filter the
    //
    ExReleaseRundownProtection (&Process->RundownProtect);

    Status = PspAddProcessToJob (Job, Process);
    if (!NT_SUCCESS (Status)) {

        Status1 = PspTerminateProcess (Process, ERROR_NOT_ENOUGH_QUOTA);
        if (NT_SUCCESS (Status1)) {

            KeEnterCriticalRegionThread (&CurrentThread->Tcb);
            ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

            Job->TotalTerminatedProcesses++;

            ExReleaseResourceLite (&Job->JobLock);
            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        }
    }

    //
    // If the job has UI restrictions and this is a GUI process, call ntuser
    //
    if ((Job->UIRestrictionsClass != JOB_OBJECT_UILIMIT_NONE) &&
         (Process->Win32Process != NULL)) {
        WIN32_JOBCALLOUT_PARAMETERS Parms;

        Parms.Job = Job;
        Parms.CalloutType = PsW32JobCalloutAddProcess;
        Parms.Data = Process->Win32Process;

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceExclusiveLite(&Job->JobLock, TRUE);

        PspWin32SessionCallout(PspW32JobCallout, &Parms, Job->SessionId);

        ExReleaseResourceLite (&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    }

    if (JobToken != NULL) {
        Status1 = PspSetPrimaryToken (NULL, Process, NULL, NewToken, TRUE);
        ObDereferenceObject (NewToken);
        //
        // Only bad callers should fail here.
        //
        ASSERT (NT_SUCCESS (Status1));
    }

deref_and_return_status:

    ObDereferenceObject (Process);
    ObDereferenceObject (Job);

    return Status;
}

NTSTATUS
PspAddProcessToJob(
    PEJOB Job,
    PEPROCESS Process
    )
{

    NTSTATUS Status;
    PETHREAD CurrentThread;
    SIZE_T MinWs,MaxWs;
    KAPC_STATE ApcState;
    ULONG SetLimit;

    PAGED_CODE();


    CurrentThread = PsGetCurrentThread ();

    Status = STATUS_SUCCESS;


    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

    InsertTailList (&Job->ProcessListHead, &Process->JobLinks);

    //
    // Update relevant ADD accounting info.
    //

    Job->TotalProcesses++;
    Job->ActiveProcesses++;

    //
    // Test for active process count exceeding limit
    //

    if ((Job->LimitFlags & JOB_OBJECT_LIMIT_ACTIVE_PROCESS) &&
        Job->ActiveProcesses > Job->ActiveProcessLimit) {

        PS_SET_CLEAR_BITS (&Process->JobStatus,
                           PS_JOB_STATUS_NOT_REALLY_ACTIVE | PS_JOB_STATUS_ACCOUNTING_FOLDED,
                           PS_JOB_STATUS_LAST_REPORT_MEMORY);

        if (Job->CompletionPort != NULL) {
            IoSetIoCompletion (Job->CompletionPort,
                               Job->CompletionKey,
                               NULL,
                               STATUS_SUCCESS,
                               JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT,
                               TRUE);
        }

        Status = STATUS_QUOTA_EXCEEDED;
    }

    if ((Job->LimitFlags & JOB_OBJECT_LIMIT_JOB_TIME) && KeReadStateEvent (&Job->Event)) {
        PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NOT_REALLY_ACTIVE | PS_JOB_STATUS_ACCOUNTING_FOLDED);

        Status = STATUS_QUOTA_EXCEEDED;
    }

    //
    // If the last handle to the job has been closed and the kill on close option is set
    // we don't let new processes enter the job. This is to make cleanup solid.
    //

    if (PS_TEST_ALL_BITS_SET (Job->JobFlags, PS_JOB_FLAGS_CLOSE_DONE|JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE)) {
        PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NOT_REALLY_ACTIVE | PS_JOB_STATUS_ACCOUNTING_FOLDED);
        Status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS (Status)) {

        PspApplyJobLimitsToProcess (Job, Process);

        if (Job->CompletionPort != NULL &&
            Process->UniqueProcessId &&
            !(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE) &&
            !(Process->JobStatus & PS_JOB_STATUS_NEW_PROCESS_REPORTED)) {

            PS_SET_CLEAR_BITS (&Process->JobStatus,
                               PS_JOB_STATUS_NEW_PROCESS_REPORTED,
                               PS_JOB_STATUS_LAST_REPORT_MEMORY);

            IoSetIoCompletion (Job->CompletionPort,
                               Job->CompletionKey,
                               (PVOID)Process->UniqueProcessId,
                               STATUS_SUCCESS,
                               JOB_OBJECT_MSG_NEW_PROCESS,
                               FALSE);
        }

    } else {
        Job->ActiveProcesses--;
    }

    ExReleaseResourceLite (&Job->JobLock);

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    if (NT_SUCCESS (Status)) {

        //
        // We can't attach with APCs diabled so we have to unlock attach and then check
        // working set limits.
        //

        KeStackAttachProcess (&Process->Pcb, &ApcState);

        KeEnterGuardedRegionThread (&CurrentThread->Tcb);

        ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

        MinWs = Job->MinimumWorkingSetSize;
        MaxWs = Job->MaximumWorkingSetSize;
        if (Job->LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {
            SetLimit = MM_WORKING_SET_MAX_HARD_ENABLE;
        } else {
            SetLimit = MM_WORKING_SET_MAX_HARD_DISABLE;
        }

        PspLockWorkingSetChangeExclusiveUnsafe ();

        ExReleaseResourceLite (&Job->JobLock);

        //
        // See if we need to apply WS limits
        //

        if (SetLimit != MM_WORKING_SET_MAX_HARD_DISABLE) {

            MmAdjustWorkingSetSize (MinWs,
                                    MaxWs,
                                    FALSE,
                                    TRUE);

        }
        MmEnforceWorkingSetLimit (Process, SetLimit);

        PspUnlockWorkingSetChangeExclusiveUnsafe ();

        KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

        KeUnstackDetachProcess (&ApcState);


        if (!MmAssignProcessToJob (Process)) {
            Status = STATUS_QUOTA_EXCEEDED;
        }

    }

    return Status;
}

//
// Only callable from process delete routine !
// This means that if the above fails, failure is termination of the process !
//
VOID
PspRemoveProcessFromJob(
    PEJOB Job,
    PEPROCESS Process
    )
{
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

    RemoveEntryList (&Process->JobLinks);

    //
    // Update REMOVE accounting info
    //


    if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
        Job->ActiveProcesses--;
        PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NOT_REALLY_ACTIVE);
    }

    PspFoldProcessAccountingIntoJob (Job, Process);

    ExReleaseResourceLite (&Job->JobLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}

VOID
PspExitProcessFromJob(
    PEJOB Job,
    PEPROCESS Process
    )
{
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite(&Job->JobLock, TRUE);

    //
    // Update REMOVE accounting info
    //


    if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
        Job->ActiveProcesses--;
        PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NOT_REALLY_ACTIVE);
    }

    PspFoldProcessAccountingIntoJob(Job,Process);

    ExReleaseResourceLite(&Job->JobLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}

VOID
PspJobDelete(
    IN PVOID Object
    )
{
    PEJOB Job, tJob;
    WIN32_JOBCALLOUT_PARAMETERS Parms;
    PPS_JOB_TOKEN_FILTER Filter;
    PETHREAD CurrentThread;

    PAGED_CODE();

    Job = (PEJOB) Object;

    //
    // call ntuser to delete its job structure
    //

    Parms.Job = Job;
    Parms.CalloutType = PsW32JobCalloutTerminate;
    Parms.Data = NULL;

    CurrentThread = PsGetCurrentThread ();

    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite(&Job->JobLock, TRUE);

    PspWin32SessionCallout(PspW32JobCallout, &Parms, Job->SessionId);

    ExReleaseResourceLite(&Job->JobLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    Job->LimitFlags = 0;

    if (Job->CompletionPort != NULL) {
        ObDereferenceObject (Job->CompletionPort);
        Job->CompletionPort = NULL;
    }


    //
    // Remove Job on Job List and job set
    //

    tJob = NULL;

    PspLockJobListExclusive (CurrentThread);

    RemoveEntryList (&Job->JobLinks);

    //
    // If we are part of a jobset then we must be the pinning job. We must pass on the pin to the next
    // job in the chain.
    //
    if (!IsListEmpty (&Job->JobSetLinks)) {
        tJob = CONTAINING_RECORD (Job->JobSetLinks.Flink, EJOB, JobSetLinks);
        RemoveEntryList (&Job->JobSetLinks);
    }

    PspUnlockJobListExclusive (CurrentThread);

    //
    // Removing the pin from the job set can cause a cascade of deletes that would cause a stack overflow
    // as we recursed at this point. We break recursion by forcing the defered delete path here.
    //
    if (tJob != NULL) {
        ObDereferenceObjectDeferDelete (tJob);
    }

    //
    // Free Security clutter:
    //

    if (Job->Token != NULL) {
        ObDereferenceObject (Job->Token);
        Job->Token = NULL;
    }

    Filter = Job->Filter;
    if (Filter != NULL) {
        if (Filter->CapturedSids != NULL) {
            ExFreePool (Filter->CapturedSids);
        }

        if (Filter->CapturedPrivileges != NULL) {
            ExFreePool (Filter->CapturedPrivileges);
        }

        if (Filter->CapturedGroups != NULL) {
            ExFreePool (Filter->CapturedGroups);
        }

        ExFreePool (Filter);

    }

    ExDeleteResourceLite (&Job->JobLock);
}

VOID
PspJobClose (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    )
/*++

Routine Description:

    Called by the object manager when a handle is closed to the object.

Arguments:

    Process - Process doing the close
    Object - Job object being closed
    GrantedAccess - Access ranted for this handle
    ProcessHandleCount - Unused and unmaintained by OB
    SystemHandleCount - Current handle count for this object

Return Value:

    None.

--*/
{
    PEJOB Job = Object;
    PVOID Port;
    PETHREAD CurrentThread;

    PAGED_CODE ();

    UNREFERENCED_PARAMETER (Process);
    UNREFERENCED_PARAMETER (GrantedAccess);
    UNREFERENCED_PARAMETER (ProcessHandleCount);
    //
    // If this isn't the last handle then do nothing.
    //
    if (SystemHandleCount > 1) {
        return;
    }

    CurrentThread = PsGetCurrentThread ();



    //
    // Mark the job has having its last handle closed.
    // This is used to prevent new processes entering a job
    // marked as terminate on close and also prevents a completion
    // port being set on a torn down job. Completion ports
    // are removed on last handle close.
    //

    PS_SET_BITS (&Job->JobFlags, PS_JOB_FLAGS_CLOSE_DONE);

    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

    if (Job->LimitFlags&JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE) {

        ExReleaseResourceLite (&Job->JobLock);
        KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

        PspTerminateAllProcessesInJob (Job, STATUS_SUCCESS, FALSE);

        KeEnterGuardedRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);
    }

    PspLockJobLimitsExclusiveUnsafe (Job);

    //
    // Release the completion port
    //

    Port = Job->CompletionPort;
    Job->CompletionPort = NULL;


    PspUnlockJobLimitsExclusiveUnsafe (Job);

    ExReleaseResourceLite (&Job->JobLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

    if (Port != NULL) {
        ObDereferenceObject (Port);
    }
}


#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
const ULONG PspJobInfoLengths[] = {
    sizeof(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),         // JobObjectBasicAccountingInformation
    sizeof(JOBOBJECT_BASIC_LIMIT_INFORMATION),              // JobObjectBasicLimitInformation
    sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST),                // JobObjectBasicProcessIdList
    sizeof(JOBOBJECT_BASIC_UI_RESTRICTIONS),                // JobObjectBasicUIRestrictions
    sizeof(JOBOBJECT_SECURITY_LIMIT_INFORMATION),           // JobObjectSecurityLimitInformation
    sizeof(JOBOBJECT_END_OF_JOB_TIME_INFORMATION),          // JobObjectEndOfJobTimeInformation
    sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT),            // JobObjectAssociateCompletionPortInformation
    sizeof(JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION),  // JobObjectBasicAndIoAccountingInformation
    sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),           // JobObjectExtendedLimitInformation
    sizeof(JOBOBJECT_JOBSET_INFORMATION),                   // JobObjectJobSetInformation
    0
    };

const ULONG PspJobInfoAlign[] = {
    sizeof(ULONG),                                  // JobObjectBasicAccountingInformation
    sizeof(ULONG),                                  // JobObjectBasicLimitInformation
    sizeof(ULONG),                                  // JobObjectBasicProcessIdList
    sizeof(ULONG),                                  // JobObjectBasicUIRestrictions
    sizeof(ULONG),                                  // JobObjectSecurityLimitInformation
    sizeof(ULONG),                                  // JobObjectEndOfJobTimeInformation
    sizeof(PVOID),                                  // JobObjectAssociateCompletionPortInformation
    sizeof(ULONG),                                  // JobObjectBasicAndIoAccountingInformation
    sizeof(ULONG),                                  // JobObjectExtendedLimitInformation
    TYPE_ALIGNMENT (JOBOBJECT_JOBSET_INFORMATION),  // JobObjectJobSetInformation
    0
    };

NTSTATUS
NtQueryInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    OUT PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    PEJOB Job;
    KPROCESSOR_MODE PreviousMode;
    JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION AccountingInfo;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ExtendedLimitInfo;
    JOBOBJECT_BASIC_UI_RESTRICTIONS BasicUIRestrictions;
    JOBOBJECT_SECURITY_LIMIT_INFORMATION SecurityLimitInfo;
    JOBOBJECT_JOBSET_INFORMATION JobSetInformation;
    JOBOBJECT_END_OF_JOB_TIME_INFORMATION EndOfJobInfo;
    NTSTATUS st=STATUS_SUCCESS;
    ULONG RequiredLength, RequiredAlign, ActualReturnLength;
    PVOID ReturnData=NULL;
    PEPROCESS Process;
    PLIST_ENTRY Next;
    LARGE_INTEGER UserTime, KernelTime;
    PULONG_PTR NextProcessIdSlot;
    ULONG WorkingLength;
    PJOBOBJECT_BASIC_PROCESS_ID_LIST IdList;
    PUCHAR CurrentOffset;
    PTOKEN_GROUPS WorkingGroup;
    PTOKEN_PRIVILEGES WorkingPrivs;
    ULONG RemainingSidBuffer;
    PSID TargetSidBuffer;
    PSID RemainingSid;
    BOOLEAN AlreadyCopied;
    PPS_JOB_TOKEN_FILTER Filter;
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    //
    // Get previous processor mode and probe output argument if necessary.
    //

    if (JobObjectInformationClass >= MaxJobObjectInfoClass || JobObjectInformationClass <= 0) {
        return STATUS_INVALID_INFO_CLASS;
    }

    RequiredLength = PspJobInfoLengths[JobObjectInformationClass-1];
    RequiredAlign = PspJobInfoAlign[JobObjectInformationClass-1];
    ActualReturnLength = RequiredLength;

    if (JobObjectInformationLength != RequiredLength) {

        //
        // BasicProcessIdList is variable length, so make sure header is
        // ok. Can not enforce an exact match !  Security Limits can be
        // as well, due to the token groups and privs
        //
        if ((JobObjectInformationClass == JobObjectBasicProcessIdList) ||
            (JobObjectInformationClass == JobObjectSecurityLimitInformation)) {
            if (JobObjectInformationLength < RequiredLength) {
                return STATUS_INFO_LENGTH_MISMATCH;
            } else {
                RequiredLength = JobObjectInformationLength;
            }
        } else {
            return STATUS_INFO_LENGTH_MISMATCH;
        }
    }


    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (PreviousMode != KernelMode) {
        try {
            //
            // Since these functions don't change any state thats not reversible
            // in the error paths we only probe the output buffer for write access.
            // This improves performance by not touching the buffer multiple times
            // And only writing the portions of the buffer that change.
            //

            ProbeForRead (JobObjectInformation,
                          JobObjectInformationLength,
                          RequiredAlign);

            if (ARGUMENT_PRESENT (ReturnLength)) {
                ProbeForWriteUlong (ReturnLength);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    //
    // reference the job
    //

    if (ARGUMENT_PRESENT (JobHandle)) {
        st = ObReferenceObjectByHandle (JobHandle,
                                        JOB_OBJECT_QUERY,
                                        PsJobType,
                                        PreviousMode,
                                        &Job,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }
    } else {

        //
        // if the current process has a job, NULL means the job of the
        // current process. Query is always allowed for this case
        //

        Process = PsGetCurrentProcessByThread (CurrentThread);

        if (Process->Job != NULL) {
            Job = Process->Job;
            ObReferenceObject (Job);
        } else {
            return STATUS_ACCESS_DENIED;
        }
    }

    AlreadyCopied = FALSE;


    //
    // Check argument validity.
    //

    switch (JobObjectInformationClass) {

    case JobObjectBasicAccountingInformation:
    case JobObjectBasicAndIoAccountingInformation:

        //
        // These two cases are identical, EXCEPT that with AndIo, IO information
        // is returned as well, but the first part of the local is identical to
        // basic, and the shorter return'd data length chops what we return.
        //

        RtlZeroMemory (&AccountingInfo.IoInfo,sizeof(AccountingInfo.IoInfo));

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

        AccountingInfo.BasicInfo.TotalUserTime = Job->TotalUserTime;
        AccountingInfo.BasicInfo.TotalKernelTime = Job->TotalKernelTime;
        AccountingInfo.BasicInfo.ThisPeriodTotalUserTime = Job->ThisPeriodTotalUserTime;
        AccountingInfo.BasicInfo.ThisPeriodTotalKernelTime = Job->ThisPeriodTotalKernelTime;
        AccountingInfo.BasicInfo.TotalPageFaultCount = Job->TotalPageFaultCount;

        AccountingInfo.BasicInfo.TotalProcesses = Job->TotalProcesses;
        AccountingInfo.BasicInfo.ActiveProcesses = Job->ActiveProcesses;
        AccountingInfo.BasicInfo.TotalTerminatedProcesses = Job->TotalTerminatedProcesses;

        AccountingInfo.IoInfo.ReadOperationCount = Job->ReadOperationCount;
        AccountingInfo.IoInfo.WriteOperationCount = Job->WriteOperationCount;
        AccountingInfo.IoInfo.OtherOperationCount = Job->OtherOperationCount;
        AccountingInfo.IoInfo.ReadTransferCount = Job->ReadTransferCount;
        AccountingInfo.IoInfo.WriteTransferCount = Job->WriteTransferCount;
        AccountingInfo.IoInfo.OtherTransferCount = Job->OtherTransferCount;

        //
        // Add in the time and page faults for each process
        //

        Next = Job->ProcessListHead.Flink;

        while (Next != &Job->ProcessListHead) {

            Process = (PEPROCESS)(CONTAINING_RECORD(Next, EPROCESS, JobLinks));
            if (!(Process->JobStatus & PS_JOB_STATUS_ACCOUNTING_FOLDED)) {

                UserTime.QuadPart = UInt32x32To64(Process->Pcb.UserTime, KeMaximumIncrement);
                KernelTime.QuadPart = UInt32x32To64(Process->Pcb.KernelTime, KeMaximumIncrement);

                AccountingInfo.BasicInfo.TotalUserTime.QuadPart += UserTime.QuadPart;
                AccountingInfo.BasicInfo.TotalKernelTime.QuadPart += KernelTime.QuadPart;
                AccountingInfo.BasicInfo.ThisPeriodTotalUserTime.QuadPart += UserTime.QuadPart;
                AccountingInfo.BasicInfo.ThisPeriodTotalKernelTime.QuadPart += KernelTime.QuadPart;
                AccountingInfo.BasicInfo.TotalPageFaultCount += Process->Vm.PageFaultCount;

                AccountingInfo.IoInfo.ReadOperationCount += Process->ReadOperationCount.QuadPart;
                AccountingInfo.IoInfo.WriteOperationCount += Process->WriteOperationCount.QuadPart;
                AccountingInfo.IoInfo.OtherOperationCount += Process->OtherOperationCount.QuadPart;
                AccountingInfo.IoInfo.ReadTransferCount += Process->ReadTransferCount.QuadPart;
                AccountingInfo.IoInfo.WriteTransferCount += Process->WriteTransferCount.QuadPart;
                AccountingInfo.IoInfo.OtherTransferCount += Process->OtherTransferCount.QuadPart;
            }
            Next = Next->Flink;
        }
        ExReleaseResourceLite (&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        ReturnData = &AccountingInfo;
        st = STATUS_SUCCESS;

        break;

    case JobObjectExtendedLimitInformation:
    case JobObjectBasicLimitInformation:

        //
        // Get the Basic Information
        //
        KeEnterGuardedRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

        ExtendedLimitInfo.BasicLimitInformation.LimitFlags = Job->LimitFlags;
        ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize = Job->MinimumWorkingSetSize;
        ExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize = Job->MaximumWorkingSetSize;
        ExtendedLimitInfo.BasicLimitInformation.ActiveProcessLimit = Job->ActiveProcessLimit;
        ExtendedLimitInfo.BasicLimitInformation.PriorityClass = (ULONG)Job->PriorityClass;
        ExtendedLimitInfo.BasicLimitInformation.SchedulingClass = Job->SchedulingClass;
        ExtendedLimitInfo.BasicLimitInformation.Affinity = (ULONG_PTR)Job->Affinity;
        ExtendedLimitInfo.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart = Job->PerProcessUserTimeLimit.QuadPart;
        ExtendedLimitInfo.BasicLimitInformation.PerJobUserTimeLimit.QuadPart = Job->PerJobUserTimeLimit.QuadPart;


        if (JobObjectInformationClass == JobObjectExtendedLimitInformation) {

            //
            // Get Extended Information
            //

            PspLockJobLimitsSharedUnsafe (Job);

            ExtendedLimitInfo.ProcessMemoryLimit = Job->ProcessMemoryLimit << PAGE_SHIFT;
            ExtendedLimitInfo.JobMemoryLimit = Job->JobMemoryLimit << PAGE_SHIFT;
            ExtendedLimitInfo.PeakJobMemoryUsed = Job->PeakJobMemoryUsed << PAGE_SHIFT;

            ExtendedLimitInfo.PeakProcessMemoryUsed = Job->PeakProcessMemoryUsed << PAGE_SHIFT;

            PspUnlockJobLimitsSharedUnsafe (Job);

            ExReleaseResourceLite(&Job->JobLock);
            KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
            //
            // Zero un-used I/O counters
            //
            RtlZeroMemory (&ExtendedLimitInfo.IoInfo, sizeof (ExtendedLimitInfo.IoInfo));

            ReturnData = &ExtendedLimitInfo;

        } else {

            ExReleaseResourceLite (&Job->JobLock);
            KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

            ReturnData = &ExtendedLimitInfo.BasicLimitInformation;

        }

        st = STATUS_SUCCESS;

        break;

    case JobObjectBasicUIRestrictions:

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite(&Job->JobLock, TRUE);

        BasicUIRestrictions.UIRestrictionsClass = Job->UIRestrictionsClass;

        ExReleaseResourceLite(&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        ReturnData = &BasicUIRestrictions;
        st = STATUS_SUCCESS;

        break;

    case JobObjectBasicProcessIdList:

        IdList = (PJOBOBJECT_BASIC_PROCESS_ID_LIST)JobObjectInformation;
        NextProcessIdSlot = &IdList->ProcessIdList[0];
        WorkingLength = FIELD_OFFSET(JOBOBJECT_BASIC_PROCESS_ID_LIST, ProcessIdList);

        AlreadyCopied = TRUE;

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

        try {

            //
            // Acounted for in the workinglength = 2*sizeof(ULONG)
            //

            IdList->NumberOfAssignedProcesses = Job->ActiveProcesses;
            IdList->NumberOfProcessIdsInList = 0;

            Next = Job->ProcessListHead.Flink;

            while (Next != &Job->ProcessListHead) {

                Process = (PEPROCESS)(CONTAINING_RECORD (Next, EPROCESS, JobLinks));
                if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
                    if (!Process->UniqueProcessId) {
                        IdList->NumberOfAssignedProcesses--;
                    } else {
                        if ((RequiredLength - WorkingLength) >= sizeof (ULONG_PTR)) {
                            *NextProcessIdSlot++ = (ULONG_PTR)Process->UniqueProcessId;
                            WorkingLength += sizeof(ULONG_PTR);
                            IdList->NumberOfProcessIdsInList++;
                        } else {
                            st = STATUS_BUFFER_OVERFLOW;
                            ActualReturnLength = WorkingLength;
                            break;
                        }
                    }
                }
                Next = Next->Flink;
            }
            ActualReturnLength = WorkingLength;

        } except (ExSystemExceptionFilter ()) {
            st = GetExceptionCode ();
            ActualReturnLength = 0;
        }
        ExReleaseResourceLite(&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        break;

    case JobObjectSecurityLimitInformation:

        RtlZeroMemory (&SecurityLimitInfo, sizeof (SecurityLimitInfo));

        ReturnData = &SecurityLimitInfo;

        st = STATUS_SUCCESS;

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        ExAcquireResourceSharedLite(&Job->JobLock, TRUE);

        SecurityLimitInfo.SecurityLimitFlags = Job->SecurityLimitFlags;

        //
        // If a filter is present, then we have an ugly marshalling to do.
        //

        Filter = Job->Filter;
        if (Filter != NULL) {

            WorkingLength = 0;

            //
            // For each field, if it is present, include the extra stuff
            //

            if (Filter->CapturedSidsLength > 0) {
                WorkingLength += Filter->CapturedSidsLength + sizeof (ULONG);
            }

            if (Filter->CapturedGroupsLength > 0) {
                WorkingLength += Filter->CapturedGroupsLength + sizeof (ULONG);
            }

            if (Filter->CapturedPrivilegesLength > 0) {
                WorkingLength += Filter->CapturedPrivilegesLength + sizeof (ULONG);
            }

            RequiredLength -= sizeof (SecurityLimitInfo);

            if (WorkingLength > RequiredLength) {
                st = STATUS_BUFFER_OVERFLOW ;
                ActualReturnLength = WorkingLength + sizeof (SecurityLimitInfo);
                goto unlock;
            }

            CurrentOffset = (PUCHAR) (JobObjectInformation) + sizeof (SecurityLimitInfo);

            try {

                if (Filter->CapturedSidsLength > 0) {
                    WorkingGroup = (PTOKEN_GROUPS) CurrentOffset;

                    CurrentOffset += sizeof (ULONG);

                    SecurityLimitInfo.RestrictedSids = WorkingGroup;

                    WorkingGroup->GroupCount = Filter->CapturedSidCount;

                    TargetSidBuffer = (PSID) (CurrentOffset +
                                              sizeof (SID_AND_ATTRIBUTES) *
                                              Filter->CapturedSidCount);

                    st = RtlCopySidAndAttributesArray (Filter->CapturedSidCount,
                                                       Filter->CapturedSids,
                                                       WorkingLength,
                                                       WorkingGroup->Groups,
                                                       TargetSidBuffer,
                                                       &RemainingSid,
                                                       &RemainingSidBuffer);

                    CurrentOffset += Filter->CapturedSidsLength;

                }

                if (!NT_SUCCESS (st)) {
                    leave;
                }

                if (Filter->CapturedGroupsLength > 0) {
                    WorkingGroup = (PTOKEN_GROUPS) CurrentOffset;

                    CurrentOffset += sizeof (ULONG);

                    SecurityLimitInfo.SidsToDisable = WorkingGroup;

                    WorkingGroup->GroupCount = Filter->CapturedGroupCount;

                    TargetSidBuffer = (PSID) (CurrentOffset +
                                              sizeof (SID_AND_ATTRIBUTES) *
                                              Filter->CapturedGroupCount);

                    st = RtlCopySidAndAttributesArray (Filter->CapturedGroupCount,
                                                       Filter->CapturedGroups,
                                                       WorkingLength,
                                                       WorkingGroup->Groups,
                                                       TargetSidBuffer,
                                                       &RemainingSid,
                                                       &RemainingSidBuffer);

                    CurrentOffset += Filter->CapturedGroupsLength;

                }

                if (!NT_SUCCESS (st)) {
                    leave;
                }

                if (Filter->CapturedPrivilegesLength > 0) {
                    WorkingPrivs = (PTOKEN_PRIVILEGES) CurrentOffset;

                    CurrentOffset += sizeof (ULONG);

                    SecurityLimitInfo.PrivilegesToDelete = WorkingPrivs;

                    WorkingPrivs->PrivilegeCount = Filter->CapturedPrivilegeCount;

                    RtlCopyMemory (WorkingPrivs->Privileges,
                                   Filter->CapturedPrivileges,
                                   Filter->CapturedPrivilegesLength);

                }



            } except (EXCEPTION_EXECUTE_HANDLER) {
                st = GetExceptionCode ();
                ActualReturnLength = 0 ;
            }

        }
unlock:
        ExReleaseResourceLite (&Job->JobLock);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        AlreadyCopied = TRUE;

        if (NT_SUCCESS (st)) {
            try {
                RtlCopyMemory (JobObjectInformation,
                               &SecurityLimitInfo,
                               sizeof (SecurityLimitInfo));
            }  except (EXCEPTION_EXECUTE_HANDLER) {
                st = GetExceptionCode ();
                ActualReturnLength = 0 ;
                break;
            }
        }

        break;

    case JobObjectJobSetInformation:

        PspLockJobListShared (CurrentThread);

        JobSetInformation.MemberLevel = Job->MemberLevel;

        PspUnlockJobListShared (CurrentThread);

        ReturnData = &JobSetInformation;
        st = STATUS_SUCCESS;

        break;

    case JobObjectEndOfJobTimeInformation:

        EndOfJobInfo.EndOfJobTimeAction = Job->EndOfJobTimeAction;

        ReturnData = &EndOfJobInfo;
        st = STATUS_SUCCESS;
        break;

    default:

        st = STATUS_INVALID_INFO_CLASS;
    }


    //
    // Finish Up
    //

    ObDereferenceObject (Job);


    if (NT_SUCCESS (st)) {

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            if (!AlreadyCopied) {
                RtlCopyMemory (JobObjectInformation, ReturnData, RequiredLength);
            }

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = ActualReturnLength;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    return st;

}

NTSTATUS
NtSetInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    IN PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength
    )
{
    PEJOB Job;
    EJOB LocalJob={0};
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS st;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ExtendedLimitInfo={0};
    JOBOBJECT_BASIC_UI_RESTRICTIONS BasicUIRestrictions={0};
    JOBOBJECT_SECURITY_LIMIT_INFORMATION SecurityLimitInfo={0};
    JOBOBJECT_END_OF_JOB_TIME_INFORMATION EndOfJobInfo={0};
    JOBOBJECT_ASSOCIATE_COMPLETION_PORT AssociateInfo={0};
    ULONG RequiredAccess;
    ULONG RequiredLength, RequiredAlign;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    BOOLEAN HasPrivilege;
    BOOLEAN IsChild=FALSE;
    PLIST_ENTRY Next;
    PPS_JOB_TOKEN_FILTER Filter;
    PVOID IoCompletion;
    PACCESS_TOKEN LocalToken;
    ULONG ValidFlags;
    ULONG LimitFlags;
    BOOLEAN ProcessWorkingSetHead = FALSE;
    PJOB_WORKING_SET_CHANGE_RECORD WsChangeRecord;

    PAGED_CODE();

    //
    // Get previous processor mode and probe output argument if necessary.
    //

    if (JobObjectInformationClass >= MaxJobObjectInfoClass || JobObjectInformationClass <= 0) {
        return STATUS_INVALID_INFO_CLASS;
    }

    RequiredLength = PspJobInfoLengths[JobObjectInformationClass-1];
    RequiredAlign = PspJobInfoAlign[JobObjectInformationClass-1];

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (PreviousMode != KernelMode) {
        try {

            ProbeForRead (JobObjectInformation,
                          JobObjectInformationLength,
                          RequiredAlign);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    if (JobObjectInformationLength != RequiredLength) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // reference the job
    //

    if (JobObjectInformationClass == JobObjectSecurityLimitInformation) {
        RequiredAccess = JOB_OBJECT_SET_SECURITY_ATTRIBUTES;
    } else {
        RequiredAccess = JOB_OBJECT_SET_ATTRIBUTES;
    }

    st = ObReferenceObjectByHandle (JobHandle,
                                    RequiredAccess,
                                    PsJobType,
                                    PreviousMode,
                                    &Job,
                                    NULL);
    if (!NT_SUCCESS (st)) {
        return st;
    }

    KeEnterGuardedRegionThread (&CurrentThread->Tcb);

    //
    // Check argument validity.
    //

    switch (JobObjectInformationClass) {

    case JobObjectExtendedLimitInformation:
    case JobObjectBasicLimitInformation:
        try {
            RtlCopyMemory (&ExtendedLimitInfo, JobObjectInformation, RequiredLength);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }

        if (NT_SUCCESS (st)) {
            //
            // sanity check LimitFlags
            //
            if (JobObjectInformationClass == JobObjectBasicLimitInformation) {
                ValidFlags = JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS;
            } else {
                ValidFlags = JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS;
            }

            if (ExtendedLimitInfo.BasicLimitInformation.LimitFlags & ~ValidFlags) {
                st = STATUS_INVALID_PARAMETER;
            } else {

                LimitFlags = ExtendedLimitInfo.BasicLimitInformation.LimitFlags;

                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

                //
                // Deal with each of the various limit flags
                //

                LocalJob.LimitFlags = Job->LimitFlags;


                //
                // ACTIVE PROCESS LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_ACTIVE_PROCESS) {

                    //
                    // Active Process Limit is NOT retroactive. New processes are denied,
                    // but existing ones are not killed just because the limit is
                    // reduced.
                    //

                    LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
                    LocalJob.ActiveProcessLimit = ExtendedLimitInfo.BasicLimitInformation.ActiveProcessLimit;
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
                    LocalJob.ActiveProcessLimit = 0;
                }

                //
                // PRIORITY CLASS LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_PRIORITY_CLASS) {

                    if (ExtendedLimitInfo.BasicLimitInformation.PriorityClass > PROCESS_PRIORITY_CLASS_ABOVE_NORMAL) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        if (ExtendedLimitInfo.BasicLimitInformation.PriorityClass == PROCESS_PRIORITY_CLASS_HIGH ||
                            ExtendedLimitInfo.BasicLimitInformation.PriorityClass == PROCESS_PRIORITY_CLASS_REALTIME) {

                            //
                            // Increasing the base priority of a process is a
                            // privileged operation.  Check for the privilege
                            // here.
                            //

                            HasPrivilege = SeCheckPrivilegedObject (SeIncreaseBasePriorityPrivilege,
                                                                    JobHandle,
                                                                    JOB_OBJECT_SET_ATTRIBUTES,
                                                                    PreviousMode);

                            if (!HasPrivilege) {
                                st = STATUS_PRIVILEGE_NOT_HELD;
                            }
                        }

                        if (NT_SUCCESS (st)) {
                            LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_PRIORITY_CLASS;
                            LocalJob.PriorityClass = (UCHAR)ExtendedLimitInfo.BasicLimitInformation.PriorityClass;
                        }
                    }
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_PRIORITY_CLASS;
                    LocalJob.PriorityClass = 0;
                }

                //
                // SCHEDULING CLASS LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_SCHEDULING_CLASS) {

                    if (ExtendedLimitInfo.BasicLimitInformation.SchedulingClass >= PSP_NUMBER_OF_SCHEDULING_CLASSES) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        if (ExtendedLimitInfo.BasicLimitInformation.SchedulingClass > PSP_DEFAULT_SCHEDULING_CLASSES) {

                            //
                            // Increasing above the default scheduling class
                            // is a
                            // privileged operation.  Check for the privilege
                            // here.
                            //

                            HasPrivilege = SeCheckPrivilegedObject (SeIncreaseBasePriorityPrivilege,
                                                                    JobHandle,
                                                                    JOB_OBJECT_SET_ATTRIBUTES,
                                                                    PreviousMode);

                            if (!HasPrivilege) {
                                st = STATUS_PRIVILEGE_NOT_HELD;
                            }
                        }

                        if (NT_SUCCESS (st)) {
                            LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_SCHEDULING_CLASS;
                            LocalJob.SchedulingClass = ExtendedLimitInfo.BasicLimitInformation.SchedulingClass;
                        }
                    }
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_SCHEDULING_CLASS;
                    LocalJob.SchedulingClass = PSP_DEFAULT_SCHEDULING_CLASSES ;
                }

                //
                // AFFINITY LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_AFFINITY) {

                    if (!ExtendedLimitInfo.BasicLimitInformation.Affinity ||
                        (ExtendedLimitInfo.BasicLimitInformation.Affinity != (ExtendedLimitInfo.BasicLimitInformation.Affinity & KeActiveProcessors))) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_AFFINITY;
                        LocalJob.Affinity = (KAFFINITY)ExtendedLimitInfo.BasicLimitInformation.Affinity;
                    }
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_AFFINITY;
                    LocalJob.Affinity = 0;
                }

                //
                // PROCESS TIME LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_PROCESS_TIME) {

                    if (!ExtendedLimitInfo.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_TIME;
                        LocalJob.PerProcessUserTimeLimit.QuadPart = ExtendedLimitInfo.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart;
                    }
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_PROCESS_TIME;
                    LocalJob.PerProcessUserTimeLimit.QuadPart = 0;
                }

                //
                // JOB TIME LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_JOB_TIME) {

                    if (!ExtendedLimitInfo.BasicLimitInformation.PerJobUserTimeLimit.QuadPart) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_JOB_TIME;
                        LocalJob.PerJobUserTimeLimit.QuadPart = ExtendedLimitInfo.BasicLimitInformation.PerJobUserTimeLimit.QuadPart;
                    }
                } else {
                    if (LimitFlags & JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME) {

                        //
                        // If we are supposed to preserve existing job time limits, then
                        // preserve them !
                        //

                        LocalJob.LimitFlags |= (Job->LimitFlags & JOB_OBJECT_LIMIT_JOB_TIME);
                        LocalJob.PerJobUserTimeLimit.QuadPart = Job->PerJobUserTimeLimit.QuadPart;
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_JOB_TIME;
                        LocalJob.PerJobUserTimeLimit.QuadPart = 0;
                    }
                }

                //
                // WORKING SET LIMIT
                //
                if (LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {


                    //
                    // the only issue with this check is that when we enforce through the
                    // processes, we may find a process that can not handle the new working set
                    // limit because it will make the process's working set not fluid
                    //

                    if ((ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize == 0 &&
                         ExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize == 0)                 ||

                         (ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize == (SIZE_T)-1 &&
                         ExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize == (SIZE_T)-1)        ||

                         (ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize >
                            ExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize)                   ) {


                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        if (ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize <= PsMinimumWorkingSet ||
                            SeSinglePrivilegeCheck (SeIncreaseBasePriorityPrivilege,
                                                    PreviousMode)) {
                            LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_WORKINGSET;
                            LocalJob.MinimumWorkingSetSize = ExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize;
                            LocalJob.MaximumWorkingSetSize = ExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize;

                        } else {
                            st = STATUS_PRIVILEGE_NOT_HELD;
                        }
                    }
                } else {
                    LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_WORKINGSET;
                    LocalJob.MinimumWorkingSetSize = 0;
                    LocalJob.MaximumWorkingSetSize = 0;
                }

                if (JobObjectInformationClass == JobObjectExtendedLimitInformation) {
                    //
                    // PROCESS MEMORY LIMIT
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_PROCESS_MEMORY) {
                        if (ExtendedLimitInfo.ProcessMemoryLimit < PAGE_SIZE) {
                            st = STATUS_INVALID_PARAMETER;
                        } else {
                            LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;
                            LocalJob.ProcessMemoryLimit = ExtendedLimitInfo.ProcessMemoryLimit >> PAGE_SHIFT;
                        }
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_PROCESS_MEMORY;
                        LocalJob.ProcessMemoryLimit = 0;
                    }

                    //
                    // JOB WIDE MEMORY LIMIT
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_JOB_MEMORY) {
                        if (ExtendedLimitInfo.JobMemoryLimit < PAGE_SIZE) {
                            st = STATUS_INVALID_PARAMETER;
                        } else {
                            LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_JOB_MEMORY;
                            LocalJob.JobMemoryLimit = ExtendedLimitInfo.JobMemoryLimit >> PAGE_SHIFT;
                        }
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_JOB_MEMORY;
                        LocalJob.JobMemoryLimit = 0;
                    }

                    //
                    // JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION) {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION;
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION;
                    }

                    //
                    // JOB_OBJECT_LIMIT_BREAKAWAY_OK
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_BREAKAWAY_OK) {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_BREAKAWAY_OK;
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_BREAKAWAY_OK;
                    }

                    //
                    // JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK) {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK;
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK;
                    }
                    //
                    // JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE
                    //
                    if (LimitFlags & JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE) {
                        LocalJob.LimitFlags |= JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
                    } else {
                        LocalJob.LimitFlags &= ~JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
                    }
                }

                if (NT_SUCCESS (st)) {


                    //
                    // Copy LocalJob to Job
                    //

                    Job->LimitFlags = LocalJob.LimitFlags;
                    Job->MinimumWorkingSetSize = LocalJob.MinimumWorkingSetSize;
                    Job->MaximumWorkingSetSize = LocalJob.MaximumWorkingSetSize;
                    Job->ActiveProcessLimit = LocalJob.ActiveProcessLimit;
                    Job->Affinity = LocalJob.Affinity;
                    Job->PriorityClass = LocalJob.PriorityClass;
                    Job->SchedulingClass = LocalJob.SchedulingClass;
                    Job->PerProcessUserTimeLimit.QuadPart = LocalJob.PerProcessUserTimeLimit.QuadPart;
                    Job->PerJobUserTimeLimit.QuadPart = LocalJob.PerJobUserTimeLimit.QuadPart;

                    if (JobObjectInformationClass == JobObjectExtendedLimitInformation) {
                        PspLockJobLimitsExclusiveUnsafe (Job);
                        Job->ProcessMemoryLimit = LocalJob.ProcessMemoryLimit;
                        Job->JobMemoryLimit = LocalJob.JobMemoryLimit;
                        PspUnlockJobLimitsExclusiveUnsafe (Job);
                    }

                    if (LimitFlags & JOB_OBJECT_LIMIT_JOB_TIME) {

                        //
                        // Take any signalled processes and fold their accounting
                        // intothe job. This way a process that exited clean but still
                        // is open won't impact the next period
                        //

                        Next = Job->ProcessListHead.Flink;

                        while (Next != &Job->ProcessListHead) {

                            Process = (PEPROCESS)(CONTAINING_RECORD(Next, EPROCESS, JobLinks));

                            //
                            // see if process has been signalled.
                            // This indicates that the process has exited. We can't do
                            // this in the exit path becuase of the lock order problem
                            // between the process lock and the job lock since in exit
                            // we hold the process lock for a long time and can't drop
                            // it until thread termination
                            //

                            if (KeReadStateProcess (&Process->Pcb)) {
                                PspFoldProcessAccountingIntoJob (Job, Process);
                            } else {

                                LARGE_INTEGER ProcessTime;

                                //
                                // running processes have their current runtime
                                // added to the programmed limit. This way, you
                                // can set a limit on a job with processes in the
                                // job and not have previous runtimes count against
                                // the limit
                                //

                                if (!(Process->JobStatus & PS_JOB_STATUS_ACCOUNTING_FOLDED)) {
                                    ProcessTime.QuadPart = UInt32x32To64 (Process->Pcb.UserTime, KeMaximumIncrement);
                                    Job->PerJobUserTimeLimit.QuadPart += ProcessTime.QuadPart;
                                }
                            }

                            Next = Next->Flink;
                        }


                        //
                        // clear period times and reset the job
                        //

                        Job->ThisPeriodTotalUserTime.QuadPart = 0;
                        Job->ThisPeriodTotalKernelTime.QuadPart = 0;

                        KeClearEvent (&Job->Event);

                    }

                    if (Job->LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {
                        PspLockWorkingSetChangeExclusiveUnsafe ();
                        PspWorkingSetChangeHead.MinimumWorkingSetSize = Job->MinimumWorkingSetSize;
                        PspWorkingSetChangeHead.MaximumWorkingSetSize = Job->MaximumWorkingSetSize;
                        ProcessWorkingSetHead = TRUE;
                    }

                    PspApplyJobLimitsToProcessSet (Job);

                }
                ExReleaseResourceLite (&Job->JobLock);
            }

        }
        break;

    case JobObjectBasicUIRestrictions:

        try {
            RtlCopyMemory (&BasicUIRestrictions, JobObjectInformation, RequiredLength);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }

        if (NT_SUCCESS (st)) {
            //
            // sanity check UIRestrictionsClass
            //
            if (BasicUIRestrictions.UIRestrictionsClass & ~JOB_OBJECT_UI_VALID_FLAGS) {
                st = STATUS_INVALID_PARAMETER;
            } else {

                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

                //
                // Check for switching between UI restrictions
                //

                if (Job->UIRestrictionsClass ^ BasicUIRestrictions.UIRestrictionsClass) {

                    //
                    // notify ntuser that the UI restrictions have changed
                    //
                    WIN32_JOBCALLOUT_PARAMETERS Parms;

                    Parms.Job = Job;
                    Parms.CalloutType = PsW32JobCalloutSetInformation;
                    Parms.Data = ULongToPtr (BasicUIRestrictions.UIRestrictionsClass);

                    PspWin32SessionCallout (PspW32JobCallout, &Parms, Job->SessionId);
                }


                //
                // save the UI restrictions into the job object
                //

                Job->UIRestrictionsClass = BasicUIRestrictions.UIRestrictionsClass;

                ExReleaseResourceLite (&Job->JobLock);
            }
        }
        break;

        //
        // SECURITY LIMITS
        //

    case JobObjectSecurityLimitInformation:

        try {
            RtlCopyMemory (&SecurityLimitInfo,
                           JobObjectInformation,
                           RequiredLength);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }


        if (NT_SUCCESS (st)) {

            if (SecurityLimitInfo.SecurityLimitFlags & (~JOB_OBJECT_SECURITY_VALID_FLAGS)) {
                st = STATUS_INVALID_PARAMETER;
            } else {
                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);
                //
                // Deal with specific options.  Basic rules:  Once a
                // flag is on, it is always on (so even with a handle to
                // the job, a process could not lift the security
                // restrictions).
                //

                if (SecurityLimitInfo.SecurityLimitFlags & JOB_OBJECT_SECURITY_NO_ADMIN) {
                    Job->SecurityLimitFlags |= JOB_OBJECT_SECURITY_NO_ADMIN ;

                    if (Job->Token) {
                        if (SeTokenIsAdmin (Job->Token)) {
                            Job->SecurityLimitFlags &= (~JOB_OBJECT_SECURITY_NO_ADMIN);

                            st = STATUS_INVALID_PARAMETER;
                        }
                    }
                }

                if (SecurityLimitInfo.SecurityLimitFlags & JOB_OBJECT_SECURITY_RESTRICTED_TOKEN ) {
                    if (Job->SecurityLimitFlags & (JOB_OBJECT_SECURITY_ONLY_TOKEN | JOB_OBJECT_SECURITY_FILTER_TOKENS)) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        Job->SecurityLimitFlags |= JOB_OBJECT_SECURITY_RESTRICTED_TOKEN;
                    }
                }

                //
                // The forcible token is a little more interesting.  It
                // cannot be reset, so if there is a pointer there already,
                // fail the call.  If a filter is already in place, this is
                // not allowed, either.  If no-admin is set, it is checked
                // at the end, once the token has been ref'd.
                //

                if (SecurityLimitInfo.SecurityLimitFlags & JOB_OBJECT_SECURITY_ONLY_TOKEN) {
                    if (Job->Token ||
                         (Job->SecurityLimitFlags & JOB_OBJECT_SECURITY_FILTER_TOKENS)) {
                        st = STATUS_INVALID_PARAMETER ;
                    } else {
                        st = ObReferenceObjectByHandle(SecurityLimitInfo.JobToken,
                                                       TOKEN_ASSIGN_PRIMARY |
                                                           TOKEN_IMPERSONATE |
                                                           TOKEN_DUPLICATE,
                                                       SeTokenObjectType,
                                                       PreviousMode,
                                                       &LocalToken,
                                                       NULL);

                        if (NT_SUCCESS (st)) {
                            if (SeTokenType (LocalToken) != TokenPrimary) {
                                st = STATUS_BAD_TOKEN_TYPE;
                            } else {
                                st = SeIsChildTokenByPointer (LocalToken,
                                                              &IsChild);
                            }

                            if (!NT_SUCCESS (st)) {
                                ObDereferenceObject (LocalToken);
                            }
                        }


                        if (NT_SUCCESS (st)) {
                            //
                            // If the token supplied is not a restricted token
                            // based on the caller's ID, then they must have
                            // assign primary privilege in order to associate
                            // the token with the job.
                            //

                            if (!IsChild) {
                                HasPrivilege = SeCheckPrivilegedObject (SeAssignPrimaryTokenPrivilege,
                                                                        JobHandle,
                                                                        JOB_OBJECT_SET_SECURITY_ATTRIBUTES,
                                                                        PreviousMode);

                                if (!HasPrivilege) {
                                    st = STATUS_PRIVILEGE_NOT_HELD;
                                }
                            }

                            if (NT_SUCCESS (st)) {

                                //
                                // Not surprisingly, specifying no-admin and
                                // supplying an admin token is a no-no.
                                //

                                if ((Job->SecurityLimitFlags & JOB_OBJECT_SECURITY_NO_ADMIN) &&
                                     SeTokenIsAdmin (LocalToken)) {
                                    st = STATUS_INVALID_PARAMETER;

                                    ObDereferenceObject (LocalToken);

                                } else {
                                    //
                                    // Grab a reference to the token into the job
                                    // object
                                    //
                                    KeMemoryBarrier ();
                                    Job->Token = LocalToken;
                                    Job->SecurityLimitFlags |= JOB_OBJECT_SECURITY_ONLY_TOKEN;
                                }

                            } else {
                                //
                                // This is the token was a child or otherwise ok,
                                // but assign primary was not held, so the
                                // request was rejected.
                                //

                                ObDereferenceObject (LocalToken);
                            }

                        }

                    }
                }

                if (SecurityLimitInfo.SecurityLimitFlags & JOB_OBJECT_SECURITY_FILTER_TOKENS ) {
                    if (Job->SecurityLimitFlags & (JOB_OBJECT_SECURITY_ONLY_TOKEN | JOB_OBJECT_SECURITY_FILTER_TOKENS)) {
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        //
                        // capture the token restrictions
                        //

                        st = PspCaptureTokenFilter (PreviousMode,
                                                    &SecurityLimitInfo,
                                                    &Filter);

                        if (NT_SUCCESS (st)) {
                            KeMemoryBarrier ();
                            Job->SecurityLimitFlags |= JOB_OBJECT_SECURITY_FILTER_TOKENS;
                            Job->Filter = Filter;
                        }

                    }
                }

                ExReleaseResourceLite (&Job->JobLock);
            }
        }
        break;

    case JobObjectEndOfJobTimeInformation:

        try {
            RtlCopyMemory (&EndOfJobInfo, JobObjectInformation, RequiredLength);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }

        if (NT_SUCCESS (st)) {
            //
            // sanity check LimitFlags
            //
            if (EndOfJobInfo.EndOfJobTimeAction > JOB_OBJECT_POST_AT_END_OF_JOB) {
                st = STATUS_INVALID_PARAMETER;
            } else {
                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);
                Job->EndOfJobTimeAction = EndOfJobInfo.EndOfJobTimeAction;
                ExReleaseResourceLite (&Job->JobLock);
            }
        }
        break;

    case JobObjectAssociateCompletionPortInformation:

        try {
            RtlCopyMemory (&AssociateInfo, JobObjectInformation, RequiredLength);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }

        if ( NT_SUCCESS(st) ) {
            if (Job->CompletionPort || AssociateInfo.CompletionPort == NULL) {
                st = STATUS_INVALID_PARAMETER;
            } else {
                st = ObReferenceObjectByHandle (AssociateInfo.CompletionPort,
                                                IO_COMPLETION_MODIFY_STATE,
                                                IoCompletionObjectType,
                                                PreviousMode,
                                                &IoCompletion,
                                                NULL);

                if (NT_SUCCESS(st)) {
                    ExAcquireResourceExclusiveLite(&Job->JobLock, TRUE);

                    //
                    // If the job already has a completion port or if the job has been rundown
                    // then reject the request.
                    //
                    if (Job->CompletionPort != NULL || (Job->JobFlags&PS_JOB_FLAGS_CLOSE_DONE) != 0) {
                        ExReleaseResourceLite(&Job->JobLock);

                        ObDereferenceObject (IoCompletion);
                        st = STATUS_INVALID_PARAMETER;
                    } else {
                        Job->CompletionKey = AssociateInfo.CompletionKey;

                        KeMemoryBarrier ();
                        Job->CompletionPort = IoCompletion;
                        //
                        // Now whip through ALL existing processes in the job
                        // and send notification messages
                        //

                        Next = Job->ProcessListHead.Flink;

                        while (Next != &Job->ProcessListHead) {

                            Process = (PEPROCESS)(CONTAINING_RECORD(Next,EPROCESS,JobLinks));

                            //
                            // If the process is really considered part of the job, has
                            // been assigned its id, and has not yet checked in, do it now
                            //

                            if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)
                                 && Process->UniqueProcessId
                                 && !(Process->JobStatus & PS_JOB_STATUS_NEW_PROCESS_REPORTED)) {

                                PS_SET_CLEAR_BITS (&Process->JobStatus,
                                                   PS_JOB_STATUS_NEW_PROCESS_REPORTED,
                                                   PS_JOB_STATUS_LAST_REPORT_MEMORY);

                                IoSetIoCompletion(
                                    Job->CompletionPort,
                                    Job->CompletionKey,
                                    (PVOID)Process->UniqueProcessId,
                                    STATUS_SUCCESS,
                                    JOB_OBJECT_MSG_NEW_PROCESS,
                                    FALSE
                                    );

                            }
                            Next = Next->Flink;
                        }
                        ExReleaseResourceLite(&Job->JobLock);
                    }
                }
            }
        }
        break;


    default:

        st = STATUS_INVALID_INFO_CLASS;
    }


    //
    // Working Set Changes are processed outside of the job lock.
    //
    // calling MmAdjust CAN NOT cause MM to call PsChangeJobMemoryUsage !
    //

    if (ProcessWorkingSetHead) {
        LIST_ENTRY FreeList;
        KAPC_STATE ApcState;

        InitializeListHead (&FreeList);
        while (!IsListEmpty (&PspWorkingSetChangeHead.Links)) {
            Next = RemoveHeadList(&PspWorkingSetChangeHead.Links);
            InsertTailList (&FreeList, Next);
            WsChangeRecord = CONTAINING_RECORD(Next,JOB_WORKING_SET_CHANGE_RECORD,Links);

            KeStackAttachProcess(&WsChangeRecord->Process->Pcb, &ApcState);

            MmAdjustWorkingSetSize (PspWorkingSetChangeHead.MinimumWorkingSetSize,
                                    PspWorkingSetChangeHead.MaximumWorkingSetSize,
                                    FALSE,
                                    TRUE);

            //
            // call MM to Enable hard workingset
            //

            MmEnforceWorkingSetLimit(WsChangeRecord->Process,
                                     MM_WORKING_SET_MAX_HARD_ENABLE);
            KeUnstackDetachProcess(&ApcState);
        }
        PspUnlockWorkingSetChangeExclusiveUnsafe ();

        while (!IsListEmpty (&FreeList)) {
            Next = RemoveHeadList(&FreeList);
            WsChangeRecord = CONTAINING_RECORD(Next,JOB_WORKING_SET_CHANGE_RECORD,Links);

            ObDereferenceObject (WsChangeRecord->Process);
            ExFreePool (WsChangeRecord);
        }
    }

    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);


    //
    // Finish Up
    //

    ObDereferenceObject(Job);

    return st;
}

VOID
PspApplyJobLimitsToProcessSet(
    PEJOB Job
    )
{
    PEPROCESS Process;
    PJOB_WORKING_SET_CHANGE_RECORD WsChangeRecord;

    PAGED_CODE();

    //
    // The job object is held exclusive by the caller
    //

    for (Process = PspGetNextJobProcess (Job, NULL);
         Process != NULL;
         Process = PspGetNextJobProcess (Job, Process)) {

        if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
            if (Job->LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {
                WsChangeRecord = ExAllocatePoolWithTag (PagedPool,
                                                        sizeof(*WsChangeRecord),
                                                        'rCsP');
                if (WsChangeRecord != NULL) {
                    WsChangeRecord->Process = Process;
                    ObReferenceObject (Process);
                    InsertTailList(&PspWorkingSetChangeHead.Links,&WsChangeRecord->Links);
                }
            }
            PspApplyJobLimitsToProcess(Job,Process);
        }
    }
}

VOID
PspApplyJobLimitsToProcess(
    PEJOB Job,
    PEPROCESS Process
    )
{
    PETHREAD CurrentThread;
    PAGED_CODE();

    //
    // The job object is held exclusive by the caller
    //

    if (Job->LimitFlags & JOB_OBJECT_LIMIT_PRIORITY_CLASS) {
        Process->PriorityClass = Job->PriorityClass;

        PsSetProcessPriorityByClass (Process,
                                     Process->Vm.Flags.MemoryPriority == MEMORY_PRIORITY_FOREGROUND ?
                                         PsProcessPriorityForeground : PsProcessPriorityBackground);
    }

    CurrentThread = PsGetCurrentThread ();

    if ( Job->LimitFlags & JOB_OBJECT_LIMIT_AFFINITY ) {


        PspLockProcessExclusive (Process, CurrentThread);

        KeSetAffinityProcess (&Process->Pcb, Job->Affinity);

        PspUnlockProcessExclusive (Process, CurrentThread);
    }

    if ( !(Job->LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) ) {
        //
        // call MM to disable hard workingset
        //

        MmEnforceWorkingSetLimit(Process, MM_WORKING_SET_MAX_HARD_DISABLE);
    }

    PspLockJobLimitsShared (Job, CurrentThread);

    if ( Job->LimitFlags & JOB_OBJECT_LIMIT_PROCESS_MEMORY  ) {
        Process->CommitChargeLimit = Job->ProcessMemoryLimit;
    } else {
        Process->CommitChargeLimit = 0;
    }

    PspUnlockJobLimitsShared (Job, CurrentThread);


    //
    // If the process is NOT IDLE Priority Class, and long fixed quantums
    // are in use, use the scheduling class stored in the job object for this process
    //
    if (Process->PriorityClass != PROCESS_PRIORITY_CLASS_IDLE) {

        if (PspUseJobSchedulingClasses ) {
            Process->Pcb.ThreadQuantum = PspJobSchedulingClasses[Job->SchedulingClass];
        }
        //
        // if the scheduling class is PSP_NUMBER_OF_SCHEDULING_CLASSES-1, then
        // give this process non-preemptive scheduling
        //
        if (Job->SchedulingClass == PSP_NUMBER_OF_SCHEDULING_CLASSES-1) {
            KeSetDisableQuantumProcess (&Process->Pcb,TRUE);
        } else {
            KeSetDisableQuantumProcess (&Process->Pcb,FALSE);
        }

    }


}

NTSTATUS
NtTerminateJobObject(
    IN HANDLE JobHandle,
    IN NTSTATUS ExitStatus
    )
{
    PEJOB Job;
    NTSTATUS st;
    KPROCESSOR_MODE PreviousMode;
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    st = ObReferenceObjectByHandle (JobHandle,
                                    JOB_OBJECT_TERMINATE,
                                    PsJobType,
                                    PreviousMode,
                                    &Job,
                                    NULL);
    if (!NT_SUCCESS (st)) {
        return st;
    }

    PspTerminateAllProcessesInJob (Job, ExitStatus, FALSE);

    ObDereferenceObject (Job);

    return st;
}

VOID
PsEnforceExecutionTimeLimits(
    VOID
    )
{
    LARGE_INTEGER RunningJobTime;
    LARGE_INTEGER ProcessTime;
    PEJOB Job;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    NTSTATUS Status;
    BOOLEAN KilledSome;

    PAGED_CODE();


    CurrentThread = PsGetCurrentThread ();

    //
    // Look at each job. If time limits are set for the job, then enforce them
    //

    for (Job = PsGetNextJob (NULL);
         Job != NULL;
         Job = PsGetNextJob (Job)) {

        if (Job->LimitFlags & (JOB_OBJECT_LIMIT_PROCESS_TIME | JOB_OBJECT_LIMIT_JOB_TIME)) {

            for (Process = PsGetNextJobProcess (Job, NULL);
                 Process != NULL;
                 Process = PsGetNextJobProcess (Job, Process)) {

                //
                // Job looks like a candidate for time enforcing. Need to get the
                // job lock to be sure, but we don't want to hang waiting for the
                // job lock, so skip the job until next time around if we need to
                //
                //

                KeEnterCriticalRegionThread (&CurrentThread->Tcb);
                if (ExAcquireResourceExclusiveLite (&Job->JobLock, FALSE)) {


                    //
                    // Job is setup for time limits
                    //

                    RunningJobTime.QuadPart = Job->ThisPeriodTotalUserTime.QuadPart;

                    if (Job->LimitFlags & (JOB_OBJECT_LIMIT_PROCESS_TIME | JOB_OBJECT_LIMIT_JOB_TIME)) {



                        ProcessTime.QuadPart = UInt32x32To64 (Process->Pcb.UserTime,KeMaximumIncrement);

                        if (!(Process->JobStatus & PS_JOB_STATUS_ACCOUNTING_FOLDED)) {
                            RunningJobTime.QuadPart += ProcessTime.QuadPart;
                        }

                        if (Job->LimitFlags & JOB_OBJECT_LIMIT_PROCESS_TIME ) {
                            if (ProcessTime.QuadPart > Job->PerProcessUserTimeLimit.QuadPart) {

                                //
                                // Process Time Limit has been exceeded.
                                //
                                // Reference the process. Assert that it is not in its
                                // delete routine. If all is OK, then nuke and dereferece
                                // the process
                                //


                                if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
                                    PS_SET_CLEAR_BITS (&Process->JobStatus,
                                                       PS_JOB_STATUS_NOT_REALLY_ACTIVE,
                                                       PS_JOB_STATUS_LAST_REPORT_MEMORY);

                                    ExReleaseResourceLite (&Job->JobLock);
                                    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

                                    Status = PspTerminateProcess (Process, ERROR_NOT_ENOUGH_QUOTA);

                                    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
                                    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);


                                    if (NT_SUCCESS (Status)) {

                                        Job->TotalTerminatedProcesses++;
                                        Job->ActiveProcesses--;

                                        if (Job->CompletionPort != NULL) {
                                            IoSetIoCompletion (Job->CompletionPort,
                                                               Job->CompletionKey,
                                                               (PVOID)Process->UniqueProcessId,
                                                               STATUS_SUCCESS,
                                                               JOB_OBJECT_MSG_END_OF_PROCESS_TIME,
                                                               FALSE);
                                        }
                                        PspFoldProcessAccountingIntoJob(Job,Process);

                                    }
                                }
                            }
                        }
                    }
                    if (Job->LimitFlags & JOB_OBJECT_LIMIT_JOB_TIME) {
                        if (RunningJobTime.QuadPart > Job->PerJobUserTimeLimit.QuadPart ) {

                            //
                            // Job Time Limit has been exceeded.
                            //
                            // Perform the appropriate action
                            //

                            switch (Job->EndOfJobTimeAction) {

                            case JOB_OBJECT_TERMINATE_AT_END_OF_JOB:

                                ExReleaseResourceLite (&Job->JobLock);
                                KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

                                KilledSome = PspTerminateAllProcessesInJob (Job, ERROR_NOT_ENOUGH_QUOTA, TRUE);

                                if (!KilledSome) {
                                    continue;
                                }

                                KeEnterCriticalRegionThread (&CurrentThread->Tcb);
                                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

                                if (Job->ActiveProcesses == 0 && Job->CompletionPort) {
                                    IoSetIoCompletion (Job->CompletionPort,
                                                       Job->CompletionKey,
                                                       NULL,
                                                       STATUS_SUCCESS,
                                                       JOB_OBJECT_MSG_END_OF_JOB_TIME,
                                                       FALSE);
                                }
                                break;

                            case JOB_OBJECT_POST_AT_END_OF_JOB:

                                if (Job->CompletionPort) {
                                    Status = IoSetIoCompletion (Job->CompletionPort,
                                                                Job->CompletionKey,
                                                                NULL,
                                                                STATUS_SUCCESS,
                                                                JOB_OBJECT_MSG_END_OF_JOB_TIME,
                                                                FALSE);
                                    if (NT_SUCCESS (Status)) {

                                        //
                                        // Clear job level time limit
                                        //

                                        Job->LimitFlags &= ~JOB_OBJECT_LIMIT_JOB_TIME;
                                        Job->PerJobUserTimeLimit.QuadPart = 0;
                                    }
                                } else {

                                    ExReleaseResourceLite (&Job->JobLock);
                                    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

                                    PspTerminateAllProcessesInJob (Job, ERROR_NOT_ENOUGH_QUOTA, TRUE);

                                    continue;
                                }
                                break;
                            }
                        }

                    }

                    ExReleaseResourceLite (&Job->JobLock);
                }
                KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
            }
        }
    }
}

BOOLEAN
PspTerminateAllProcessesInJob(
    PEJOB Job,
    NTSTATUS Status,
    BOOLEAN IncCounter
    )
{
    PEPROCESS Process;
    BOOLEAN TerminatedAProcess;
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();
    TerminatedAProcess = FALSE;

    for (Process = PsGetNextJobProcess (Job, NULL);
         Process != NULL;
         Process = PsGetNextJobProcess (Job, Process)) {

        if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {

            if (NT_SUCCESS (PspTerminateProcess (Process, Status))) {

                KeEnterCriticalRegionThread (&CurrentThread->Tcb);
                ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

                if (!(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE)) {
                    PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_NOT_REALLY_ACTIVE);

                    if (IncCounter) {
                        Job->TotalTerminatedProcesses++;
                    }

                    Job->ActiveProcesses--;

                    if (Job->ActiveProcesses == 0) {
                        KeSetEvent (&Job->Event,0,FALSE);
                    }

                    PspFoldProcessAccountingIntoJob (Job, Process);


                    TerminatedAProcess = TRUE;
                }

                ExReleaseResourceLite (&Job->JobLock);
                KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
            }
        }
    }
    return TerminatedAProcess;
}


VOID
PspFoldProcessAccountingIntoJob(
    PEJOB Job,
    PEPROCESS Process
    )
{
    LARGE_INTEGER UserTime, KernelTime;

    if (!(Process->JobStatus & PS_JOB_STATUS_ACCOUNTING_FOLDED)) {
        UserTime.QuadPart = UInt32x32To64(Process->Pcb.UserTime,KeMaximumIncrement);
        KernelTime.QuadPart = UInt32x32To64(Process->Pcb.KernelTime,KeMaximumIncrement);

        Job->TotalUserTime.QuadPart += UserTime.QuadPart;
        Job->TotalKernelTime.QuadPart += KernelTime.QuadPart;
        Job->ThisPeriodTotalUserTime.QuadPart += UserTime.QuadPart;
        Job->ThisPeriodTotalKernelTime.QuadPart += KernelTime.QuadPart;

        Job->ReadOperationCount += Process->ReadOperationCount.QuadPart;
        Job->WriteOperationCount += Process->WriteOperationCount.QuadPart;
        Job->OtherOperationCount += Process->OtherOperationCount.QuadPart;
        Job->ReadTransferCount += Process->ReadTransferCount.QuadPart;
        Job->WriteTransferCount += Process->WriteTransferCount.QuadPart;
        Job->OtherTransferCount += Process->OtherTransferCount.QuadPart;

        Job->TotalPageFaultCount += Process->Vm.PageFaultCount;


        if ( Process->CommitChargePeak > Job->PeakProcessMemoryUsed ) {
            Job->PeakProcessMemoryUsed = Process->CommitChargePeak;
        }

        PS_SET_CLEAR_BITS (&Process->JobStatus,
                           PS_JOB_STATUS_ACCOUNTING_FOLDED,
                           PS_JOB_STATUS_LAST_REPORT_MEMORY);

        if (Job->CompletionPort && Job->ActiveProcesses == 0) {
            IoSetIoCompletion(
                Job->CompletionPort,
                Job->CompletionKey,
                NULL,
                STATUS_SUCCESS,
                JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO,
                FALSE
                );
            }
        }
}

NTSTATUS
PspCaptureTokenFilter(
    KPROCESSOR_MODE PreviousMode,
    PJOBOBJECT_SECURITY_LIMIT_INFORMATION SecurityLimitInfo,
    PPS_JOB_TOKEN_FILTER * TokenFilter
    )
{
    NTSTATUS Status ;
    PPS_JOB_TOKEN_FILTER Filter ;

    Filter = ExAllocatePoolWithTag (NonPagedPool,
                                    sizeof (PS_JOB_TOKEN_FILTER),
                                    'fTsP');

    if (!Filter)
    {
        *TokenFilter = NULL;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (Filter, sizeof (PS_JOB_TOKEN_FILTER));

    try {

        Status = STATUS_SUCCESS;

        //
        //  Capture Sids to remove
        //

        if (ARGUMENT_PRESENT (SecurityLimitInfo->SidsToDisable)) {

            ProbeForReadSmallStructure (SecurityLimitInfo->SidsToDisable,
                                        sizeof (TOKEN_GROUPS),
                                        sizeof (ULONG));

            Filter->CapturedGroupCount = SecurityLimitInfo->SidsToDisable->GroupCount;

            Status = SeCaptureSidAndAttributesArray(
                        SecurityLimitInfo->SidsToDisable->Groups,
                        Filter->CapturedGroupCount,
                        PreviousMode,
                        NULL, 0,
                        NonPagedPool,
                        TRUE,
                        &Filter->CapturedGroups,
                        &Filter->CapturedGroupsLength);
        }

        //
        //  Capture PrivilegesToDelete
        //

        if (NT_SUCCESS (Status) &&
            ARGUMENT_PRESENT (SecurityLimitInfo->PrivilegesToDelete)) {

            ProbeForReadSmallStructure (SecurityLimitInfo->PrivilegesToDelete,
                                        sizeof (TOKEN_PRIVILEGES),
                                        sizeof (ULONG));

            Filter->CapturedPrivilegeCount = SecurityLimitInfo->PrivilegesToDelete->PrivilegeCount;

            Status = SeCaptureLuidAndAttributesArray(
                         SecurityLimitInfo->PrivilegesToDelete->Privileges,
                         Filter->CapturedPrivilegeCount,
                         PreviousMode,
                         NULL, 0,
                         NonPagedPool,
                         TRUE,
                         &Filter->CapturedPrivileges,
                         &Filter->CapturedPrivilegesLength);

        }

        //
        //  Capture Restricted Sids
        //

        if (NT_SUCCESS(Status) &&
            ARGUMENT_PRESENT(SecurityLimitInfo->RestrictedSids)) {

            ProbeForReadSmallStructure (SecurityLimitInfo->RestrictedSids,
                                        sizeof (TOKEN_GROUPS),
                                        sizeof (ULONG));

            Filter->CapturedSidCount = SecurityLimitInfo->RestrictedSids->GroupCount;

            Status = SeCaptureSidAndAttributesArray(
                        SecurityLimitInfo->RestrictedSids->Groups,
                        Filter->CapturedSidCount,
                        PreviousMode,
                        NULL, 0,
                        NonPagedPool,
                        TRUE,
                        &Filter->CapturedSids,
                        &Filter->CapturedSidsLength);

        }



    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode ();
    }  // end_try

    if (!NT_SUCCESS (Status)) {
        if (Filter->CapturedSids) {
            ExFreePool (Filter->CapturedSids);
        }

        if (Filter->CapturedPrivileges) {
            ExFreePool (Filter->CapturedPrivileges);
        }

        if (Filter->CapturedGroups) {
            ExFreePool (Filter->CapturedGroups);
        }

        ExFreePool (Filter);

        Filter = NULL;

    }

    *TokenFilter = Filter;

    return Status;
}



BOOLEAN
PsChangeJobMemoryUsage(
    IN ULONG Flags,
    IN SSIZE_T Amount
    )
{
    PEPROCESS Process;
    PETHREAD CurrentThread;
    PEJOB Job;
    SIZE_T CurrentJobMemoryUsed;
    BOOLEAN ReturnValue;

    UNREFERENCED_PARAMETER (Flags);     // BUGBUG

    ReturnValue = TRUE;
    CurrentThread = PsGetCurrentThread ();
    Process = PsGetCurrentProcessByThread (CurrentThread);
    Job = Process->Job;
    if ( Job ) {
        //
        // This routine can be called while holding the process lock (during
        // teb deletion... So instead of using the job lock, we must use the
        // memory limits lock. The lock order is always (job lock followed by
        // process lock. The memory limits lock never nests or calls other
        // code while held. It can be grapped while holding the job lock, or
        // the process lock.
        //
        PspLockJobLimitsShared (Job, CurrentThread);


        CurrentJobMemoryUsed = Job->CurrentJobMemoryUsed + Amount;

        if ( Job->LimitFlags & JOB_OBJECT_LIMIT_JOB_MEMORY &&
             CurrentJobMemoryUsed > Job->JobMemoryLimit ) {
            CurrentJobMemoryUsed = Job->CurrentJobMemoryUsed;
            ReturnValue = FALSE;



            //
            // Tell the job port that commit has been exceeded, and process id x
            // was the one that hit it.
            //

            if ( Job->CompletionPort
                 && Process->UniqueProcessId
                 && (Process->JobStatus & PS_JOB_STATUS_NEW_PROCESS_REPORTED)
                 && (Process->JobStatus & PS_JOB_STATUS_LAST_REPORT_MEMORY) == 0) {

                PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_LAST_REPORT_MEMORY);
                IoSetIoCompletion(
                    Job->CompletionPort,
                    Job->CompletionKey,
                    (PVOID)Process->UniqueProcessId,
                    STATUS_SUCCESS,
                    JOB_OBJECT_MSG_JOB_MEMORY_LIMIT,
                    TRUE
                    );

            }
        }

        if (ReturnValue) {
            Job->CurrentJobMemoryUsed = CurrentJobMemoryUsed;

            //
            // Update current and peak counters if this is an addition.
            //

            if (Amount > 0) {
                if (CurrentJobMemoryUsed > Job->PeakJobMemoryUsed) {
                    Job->PeakJobMemoryUsed = CurrentJobMemoryUsed;
                }

                if (Process->CommitCharge + Amount > Job->PeakProcessMemoryUsed) {
                    Job->PeakProcessMemoryUsed = Process->CommitCharge + Amount;
                }
            }
        }

        PspUnlockJobLimitsShared (Job, CurrentThread);
    }

    return ReturnValue;
}


VOID
PsReportProcessMemoryLimitViolation(
    VOID
    )
{
    PEPROCESS Process;
    PETHREAD CurrentThread;
    PEJOB Job;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();
    Process = PsGetCurrentProcessByThread (CurrentThread);
    Job = Process->Job;
    if (Job != NULL && (Job->LimitFlags & JOB_OBJECT_LIMIT_PROCESS_MEMORY)) {

        PspLockJobLimitsShared (Job, CurrentThread);

        //
        // Tell the job port that commit has been exceeded, and process id x
        // was the one that hit it.
        //

        if (Job->CompletionPort &&
            Process->UniqueProcessId &&
            (Process->JobStatus & PS_JOB_STATUS_NEW_PROCESS_REPORTED) &&
            (Process->JobStatus & PS_JOB_STATUS_LAST_REPORT_MEMORY) == 0) {

            PS_SET_BITS (&Process->JobStatus, PS_JOB_STATUS_LAST_REPORT_MEMORY);
            IoSetIoCompletion(
                Job->CompletionPort,
                Job->CompletionKey,
                (PVOID)Process->UniqueProcessId,
                STATUS_SUCCESS,
                JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT,
                TRUE
                );

        }

        PspUnlockJobLimitsShared (Job, CurrentThread);

    }
}

VOID
PspJobTimeLimitsWork(
    IN PVOID Context
    )
{
    PETHREAD CurrentThread;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Context);

    PsEnforceExecutionTimeLimits();

    CurrentThread = PsGetCurrentThread ();

    //
    // Reset timer
    //

    PspLockJobTimeLimitsShared (CurrentThread);

    if (!PspJobTimeLimitsShuttingDown) {
        KeSetTimer (&PspJobTimeLimitsTimer,
                    PspJobTimeLimitsInterval,
                    &PspJobTimeLimitsDpc);
    }

    PspUnlockJobTimeLimitsShared (CurrentThread);
}


VOID
PspJobTimeLimitsDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);
    ExQueueWorkItem(&PspJobTimeLimitsWorkItem, DelayedWorkQueue);
}

VOID
PspInitializeJobStructures(
    )
{

    //
    // Initialize job list head and mutex
    //

    InitializeListHead (&PspJobList); 

    PspInitializeJobListLock ();

    //
    // Initialize job time limits timer, etc
    //

    PspInitializeJobTimeLimitsLock ();

    PspJobTimeLimitsShuttingDown = FALSE;

    KeInitializeDpc (&PspJobTimeLimitsDpc,
                     PspJobTimeLimitsDpcRoutine,
                     NULL);

    ExInitializeWorkItem (&PspJobTimeLimitsWorkItem, PspJobTimeLimitsWork, NULL);
    KeInitializeTimer (&PspJobTimeLimitsTimer);

    PspJobTimeLimitsInterval.QuadPart = Int32x32To64(PSP_ONE_SECOND,
                                                     PSP_JOB_TIME_LIMITS_TIME);
}

VOID
PspInitializeJobStructuresPhase1(
    )
{
    //
    // Wait until Phase1 executive initialization completes (ie: the worker
    // queues must be initialized) before setting off our DPC timer (which
    // queues work items!).
    //

    KeSetTimer (&PspJobTimeLimitsTimer,
                PspJobTimeLimitsInterval,
                &PspJobTimeLimitsDpc);
}

VOID
PspShutdownJobLimits(
    VOID
    )
{
    PETHREAD CurrentThread;


    CurrentThread = PsGetCurrentThread ();

    // Cancel the job time limits enforcement worker

    PspLockJobTimeLimitsExclusive (CurrentThread);

    PspJobTimeLimitsShuttingDown = TRUE;

    KeCancelTimer (&PspJobTimeLimitsTimer);

    PspUnlockJobTimeLimitsExclusive (CurrentThread);
}

NTSTATUS
NtIsProcessInJob (
    IN HANDLE ProcessHandle,
    IN HANDLE JobHandle
    )
/*++

Routine Description:

    This finds out if a process is in a specific or any job

Arguments:

    ProcessHandle - Handle to process to be checked
    JobHandle - Handle of job to check process against, May be NULL to do general query.

Return Value:

    NTSTATUS - Status of call

--*/
{
    KPROCESSOR_MODE PreviousMode;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    PEJOB Job;
    NTSTATUS Status;

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (ProcessHandle != NtCurrentProcess ()) {
        Status = ObReferenceObjectByHandle (ProcessHandle,
                                            PROCESS_QUERY_INFORMATION,
                                            PsProcessType,
                                            PreviousMode,
                                            &Process,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    } else {
        Process = PsGetCurrentProcessByThread (CurrentThread);
    }

    if (JobHandle == NULL) {
        Job = Process->Job;
    } else {
        Status = ObReferenceObjectByHandle (JobHandle,
                                            JOB_OBJECT_QUERY,
                                            PsJobType,
                                            PreviousMode,
                                            &Job,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
             goto exit_and_clean;
        }
    }

    if (Process->Job == NULL || Process->Job != Job) {
        Status = STATUS_PROCESS_NOT_IN_JOB;
    } else {
        Status = STATUS_PROCESS_IN_JOB;
    }

    if (JobHandle != NULL) {
        ObDereferenceObject (Job);
    }

exit_and_clean:

    if (ProcessHandle != NtCurrentProcess ()) {
        ObDereferenceObject (Process);
    }
    return Status;
}

NTSTATUS
PspGetJobFromSet (
    IN PEJOB ParentJob,
    IN ULONG JobMemberLevel,
    OUT PEJOB *pJob)
/*++

Routine Description:

    The function selects the job a process will run in. Either the same job as the parent or a job in the same
    job set as the parent but with a JobMemberLevel >= to the parents level/

Arguments:

    ParentJob - Job the parent is in.
    JobMemberLevel - Member level requested for this process. Zero for use parents job.
    Pjob - Returned job to place process in.

Return Value:

    NTSTATUS - Status of call

--*/
{
    PLIST_ENTRY Entry;
    PEJOB Job;
    NTSTATUS Status;
    PETHREAD CurrentThread;

    //
    // This is the normal case. We are not asking to be moved jobs or we are asking for our current level
    //

    if (JobMemberLevel == 0) {
        ObReferenceObject (ParentJob);
        *pJob = ParentJob;
        return STATUS_SUCCESS;
    }

    Status = STATUS_ACCESS_DENIED;

    CurrentThread = PsGetCurrentThread ();

    PspLockJobListShared (CurrentThread);

    if (ParentJob->MemberLevel != 0 && ParentJob->MemberLevel <= JobMemberLevel) {

        for (Entry = ParentJob->JobSetLinks.Flink;
             Entry != &ParentJob->JobSetLinks;
             Entry = Entry->Flink) {

             Job = CONTAINING_RECORD (Entry, EJOB, JobSetLinks);
             if (Job->MemberLevel == JobMemberLevel &&
                 ObReferenceObjectSafe (Job)) {
                 *pJob = Job;
                 Status = STATUS_SUCCESS;
                 break;
             }
        }
    }
    PspUnlockJobListShared (CurrentThread);

    return Status;
}

NTSTATUS
NtCreateJobSet (
    IN ULONG NumJob,
    IN PJOB_SET_ARRAY UserJobSet,
    IN ULONG Flags)
/*++

Routine Description:

    This function creates a job set from multiple job objects.

Arguments:

    NumJob     - Number of jobs in JobSet
    UserJobSet - Pointer to array of jobs to combine
    Flags      - Flags mask for future expansion

Return Value:

    NTSTATUS - Status of call

--*/
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    ULONG_PTR BufLen;
    PJOB_SET_ARRAY JobSet;
    ULONG JobsProcessed;
    PEJOB Job;
    ULONG MinMemberLevel;
    PEJOB HeadJob;
    PLIST_ENTRY ListEntry;
    PETHREAD CurrentThread;

    //
    // Flags must be zero and number of jobs >= 2 and not overflow when the length is caculated
    //
    if (Flags != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    if (NumJob <= 1 || NumJob > MAXULONG_PTR / sizeof (JobSet[0])) {
        return STATUS_INVALID_PARAMETER;
    }

    BufLen = NumJob * sizeof (JobSet[0]);

    JobSet = ExAllocatePoolWithQuotaTag (PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, BufLen, 'bjsP');
    if (JobSet == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    try {
        if (PreviousMode == UserMode) {
            ProbeForRead (UserJobSet, BufLen, TYPE_ALIGNMENT (JOB_SET_ARRAY));
        }
        RtlCopyMemory (JobSet, UserJobSet, BufLen);
    } except (ExSystemExceptionFilter ()) {
        ExFreePool (JobSet);
        return GetExceptionCode ();
    }

    MinMemberLevel = 0;
    Status = STATUS_SUCCESS;
    for (JobsProcessed = 0; JobsProcessed < NumJob; JobsProcessed++) {
        if (JobSet[JobsProcessed].MemberLevel <= MinMemberLevel || JobSet[JobsProcessed].Flags != 0) {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
        MinMemberLevel = JobSet[JobsProcessed].MemberLevel;

        Status = ObReferenceObjectByHandle (JobSet[JobsProcessed].JobHandle,
                                            JOB_OBJECT_QUERY,
                                            PsJobType,
                                            PreviousMode,
                                            &Job,
                                            NULL);
        if (!NT_SUCCESS (Status)) {
            break;
        }
        JobSet[JobsProcessed].JobHandle = Job;
    }

    if (!NT_SUCCESS (Status)) {
        while (JobsProcessed-- > 0) {
            Job = JobSet[JobsProcessed].JobHandle;
            ObDereferenceObject (Job);
        }
        ExFreePool (JobSet);
        return Status;
    }

    HeadJob = NULL;

    PspLockJobListExclusive (CurrentThread);

    for (JobsProcessed = 0; JobsProcessed < NumJob; JobsProcessed++) {
        Job = JobSet[JobsProcessed].JobHandle;

        //
        // If we are already in a job set then reject this call.
        //
        if (Job->MemberLevel != 0) {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (HeadJob != NULL) {
            if (HeadJob == Job) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            InsertTailList (&HeadJob->JobSetLinks, &Job->JobSetLinks);
        } else {
            HeadJob = Job;
        }
        Job->MemberLevel = JobSet[JobsProcessed].MemberLevel;
    }

    if (!NT_SUCCESS (Status)) {
        if (HeadJob) {
            while (!IsListEmpty (&HeadJob->JobSetLinks)) {
                ListEntry = RemoveHeadList (&HeadJob->JobSetLinks);
                Job = CONTAINING_RECORD (ListEntry, EJOB, JobSetLinks);
                Job->MemberLevel = 0;
                InitializeListHead (&Job->JobSetLinks);
            }
            HeadJob->MemberLevel = 0;
        }
    }

    PspUnlockJobListExclusive (CurrentThread);

    //
    // Dereference all the objects in the error path. If we suceeded then pin all but the first object by
    // leaving the reference there.
    //
    if (!NT_SUCCESS (Status)) {
        for (JobsProcessed = 0; JobsProcessed < NumJob; JobsProcessed++) {
            Job = JobSet[JobsProcessed].JobHandle;
            ObDereferenceObject (Job);
        }
    } else {
        Job = JobSet[0].JobHandle;
        ObDereferenceObject (Job);
    }

    ExFreePool (JobSet);

    return Status;
}

NTSTATUS
PspWin32SessionCallout(
    IN  PKWIN32_JOB_CALLOUT CalloutRoutine,
    IN  PKWIN32_JOBCALLOUT_PARAMETERS Parameters,
    IN  ULONG SessionId
    )
/*++

Routine Description:

    This routine calls the specified callout routine in session space, for the
    specified session.

Parameters:

    CalloutRoutine - Callout routine in session space.

    Parameters     - Parameters to pass the callout routine.

    SessionId      - Specifies the ID of the session in which the specified
                     callout routine is to be called.

Return Value:

    Status code that indicates whether or not the function was successful.

Notes:

    Returns STATUS_NOT_FOUND if the specified session was not found.

--*/
{
    NTSTATUS Status;
    PVOID OpaqueSession;
    KAPC_STATE ApcState;
    PEPROCESS Process;

    PAGED_CODE();

    //
    // Make sure we have all the information we need to deliver notification.
    //
    if (CalloutRoutine == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the callout routine in session space.
    //
    ASSERT(MmIsSessionAddress((PVOID)CalloutRoutine));

    Process = PsGetCurrentProcess();
    if ((Process->Flags & PS_PROCESS_FLAGS_IN_SESSION) &&
        (SessionId == MmGetSessionId (Process))) {
        //
        // If the call is from a user mode process, and we are asked to call the
        // current session, call directly.
        //
        (CalloutRoutine)(Parameters);

        Status = STATUS_SUCCESS;

    } else {
        //
        // Reference the session object for the specified session.
        //
        OpaqueSession = MmGetSessionById (SessionId);
        if (OpaqueSession == NULL) {
            return STATUS_NOT_FOUND;
        }

        //
        // Attach to the specified session.
        //
        Status = MmAttachSession(OpaqueSession, &ApcState);
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_WARNING_LEVEL,
                       "PspWin32SessionCallout: "
                       "could not attach to 0x%p, session %d for registered notification callout @ 0x%p\n",
                       OpaqueSession,
                       SessionId,
                       CalloutRoutine));
            MmQuitNextSession(OpaqueSession);
            return Status;
        }

        //
        // Dispatch notification to the callout routine.
        //
        (CalloutRoutine)(Parameters);

        //
        // Detach from the session.
        //
        Status = MmDetachSession (OpaqueSession, &ApcState);
        ASSERT(NT_SUCCESS(Status));

        //
        // Dereference the session object.
        //
        Status = MmQuitNextSession (OpaqueSession);
        ASSERT(NT_SUCCESS(Status));
    }

    return Status;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\psopen.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psopen.c

Abstract:

    This module implements Process and Thread open.
    This module also contains NtRegisterThreadTerminationPort.

Author:

    Mark Lucovsky (markl) 20-Sep-1989

Revision History:

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtOpenProcess)
#pragma alloc_text(PAGE, NtOpenThread)
#endif

NTSTATUS
NtOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    )

/*++

Routine Description:

    This function opens a handle to a process object with the specified
    desired access.

    The object is located either by name, or by locating a thread whose
    Client ID matches the specified Client ID and then opening that thread's
    process.

Arguments:

    ProcessHandle - Supplies a pointer to a variable that will receive
        the process object handle.

    DesiredAccess - Supplies the desired types of access for the process
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.
        If the ObjectName field is specified, then ClientId must not be
        specified.

    ClientId - Supplies a pointer to a ClientId that if supplied
        specifies the thread whose process is to be opened. If this
        argument is specified, then ObjectName field of the ObjectAttributes
        structure must not be specified.

Return Value:

    NTSTATUS - Status of call

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROCESS Process;
    PETHREAD Thread;
    CLIENT_ID CapturedCid={0};
    BOOLEAN ObjectNamePresent;
    BOOLEAN ClientIdPresent;
    ACCESS_STATE AccessState;
    AUX_ACCESS_DATA AuxData;
    ULONG Attributes;

    PAGED_CODE();

    //
    // Make sure that only one of either ClientId or ObjectName is
    // present.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

        //
        // Since we need to look at the ObjectName field, probe
        // ObjectAttributes and capture object name present indicator.
        //

        try {

            ProbeForWriteHandle (ProcessHandle);

            ProbeForReadSmallStructure (ObjectAttributes,
                                        sizeof(OBJECT_ATTRIBUTES),
                                        sizeof(ULONG));
            ObjectNamePresent = (BOOLEAN)ARGUMENT_PRESENT (ObjectAttributes->ObjectName);
            Attributes = ObSanitizeHandleAttributes (ObjectAttributes->Attributes, UserMode);

            if (ARGUMENT_PRESENT (ClientId)) {
                ProbeForReadSmallStructure (ClientId, sizeof (CLIENT_ID), sizeof (ULONG));
                CapturedCid = *ClientId;
                ClientIdPresent = TRUE;
            } else {
                ClientIdPresent = FALSE;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    } else {
        ObjectNamePresent = (BOOLEAN)ARGUMENT_PRESENT (ObjectAttributes->ObjectName);
        Attributes = ObSanitizeHandleAttributes (ObjectAttributes->Attributes, KernelMode);
        if (ARGUMENT_PRESENT (ClientId)) {
            CapturedCid = *ClientId;
            ClientIdPresent = TRUE;
        } else {
            ClientIdPresent = FALSE;
        }
    }

    if (ObjectNamePresent && ClientIdPresent) {
        return STATUS_INVALID_PARAMETER_MIX;
    }

    //
    // Create an AccessState here, because the caller may have
    // DebugPrivilege, which requires us to make special adjustments
    // to his desired access mask.  We do this by modifying the
    // internal fields in the AccessState to achieve the effect
    // we desire.
    //

    Status = SeCreateAccessState(
                 &AccessState,
                 &AuxData,
                 DesiredAccess,
                 &PsProcessType->TypeInfo.GenericMapping
                 );

    if ( !NT_SUCCESS(Status) ) {

        return Status;
    }

    //
    // Check here to see if the caller has SeDebugPrivilege.  If
    // he does, we will allow him any access he wants to the process.
    // We do this by clearing the DesiredAccess in the AccessState
    // and recording what we want him to have in the PreviouslyGrantedAccess
    // field.
    //
    // Note that this routine performs auditing as appropriate.
    //

    if (SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode )) {

        if ( AccessState.RemainingDesiredAccess & MAXIMUM_ALLOWED ) {
            AccessState.PreviouslyGrantedAccess |= PROCESS_ALL_ACCESS;

        } else {

            AccessState.PreviouslyGrantedAccess |= ( AccessState.RemainingDesiredAccess );
        }

        AccessState.RemainingDesiredAccess = 0;

    }

    if (ObjectNamePresent) {

        //
        // Open handle to the process object with the specified desired access,
        // set process handle value, and return service completion status.
        //

        Status = ObOpenObjectByName(
                    ObjectAttributes,
                    PsProcessType,
                    PreviousMode,
                    &AccessState,
                    0,
                    NULL,
                    &Handle
                    );

        SeDeleteAccessState( &AccessState );

        if ( NT_SUCCESS(Status) ) {
            try {
                *ProcessHandle = Handle;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
        }

        return Status;
    }

    if ( ClientIdPresent ) {

        Thread = NULL;
        if (CapturedCid.UniqueThread) {
            Status = PsLookupProcessThreadByCid(
                        &CapturedCid,
                        &Process,
                        &Thread
                        );

            if (!NT_SUCCESS(Status)) {
                SeDeleteAccessState( &AccessState );
                return Status;
            }
        } else {
            Status = PsLookupProcessByProcessId(
                        CapturedCid.UniqueProcess,
                        &Process
                        );

            if ( !NT_SUCCESS(Status) ) {
                SeDeleteAccessState( &AccessState );
                return Status;
            }
        }

        //
        // OpenObjectByAddress
        //

        Status = ObOpenObjectByPointer(
                    Process,
                    Attributes,
                    &AccessState,
                    0,
                    PsProcessType,
                    PreviousMode,
                    &Handle
                    );

        SeDeleteAccessState( &AccessState );

        if (Thread) {
            ObDereferenceObject(Thread);
        }

        ObDereferenceObject(Process);

        if (NT_SUCCESS (Status)) {

            try {
                *ProcessHandle = Handle;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
        }

        return Status;

    }

    return STATUS_INVALID_PARAMETER_MIX;
}

NTSTATUS
NtOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    )

/*++

Routine Description:

    This function opens a handle to a thread object with the specified
    desired access.

    The object is located either by name, or by locating a thread whose
    Client ID matches the specified Client ID.

Arguments:

    ThreadHandle - Supplies a pointer to a variable that will receive
        the thread object handle.

    DesiredAccess - Supplies the desired types of access for the Thread
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.
        If the ObjectName field is specified, then ClientId must not be
        specified.

    ClientId - Supplies a pointer to a ClientId that if supplied
        specifies the thread whose thread is to be opened. If this
        argument is specified, then ObjectName field of the ObjectAttributes
        structure must not be specified.

Return Value:

    TBS

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PETHREAD Thread;
    CLIENT_ID CapturedCid={0};
    BOOLEAN ObjectNamePresent;
    BOOLEAN ClientIdPresent;
    ACCESS_STATE AccessState;
    AUX_ACCESS_DATA AuxData;
    ULONG HandleAttributes;

    PAGED_CODE();

    //
    // Make sure that only one of either ClientId or ObjectName is
    // present.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

        //
        // Since we need to look at the ObjectName field, probe
        // ObjectAttributes and capture object name present indicator.
        //

        try {

            ProbeForWriteHandle(ThreadHandle);

            ProbeForReadSmallStructure (ObjectAttributes,
                                        sizeof(OBJECT_ATTRIBUTES),
                                        sizeof(ULONG));
            ObjectNamePresent = (BOOLEAN)ARGUMENT_PRESENT(ObjectAttributes->ObjectName);
            HandleAttributes = ObSanitizeHandleAttributes (ObjectAttributes->Attributes, UserMode);

            if (ARGUMENT_PRESENT(ClientId)) {
                ProbeForReadSmallStructure (ClientId, sizeof(CLIENT_ID), sizeof(ULONG));
                CapturedCid = *ClientId;
                ClientIdPresent = TRUE;
            } else {
                ClientIdPresent = FALSE;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    } else {
        ObjectNamePresent = (BOOLEAN) ARGUMENT_PRESENT(ObjectAttributes->ObjectName);
        HandleAttributes = ObSanitizeHandleAttributes (ObjectAttributes->Attributes, KernelMode);
        if (ARGUMENT_PRESENT(ClientId)) {
            CapturedCid = *ClientId;
            ClientIdPresent = TRUE;
        } else {
            ClientIdPresent = FALSE;
        }
    }

    if (ObjectNamePresent && ClientIdPresent) {
        return STATUS_INVALID_PARAMETER_MIX;
    }

    Status = SeCreateAccessState(
                 &AccessState,
                 &AuxData,
                 DesiredAccess,
                 &PsProcessType->TypeInfo.GenericMapping
                 );

    if (!NT_SUCCESS (Status)) {

        return Status;
    }

    //
    // Check here to see if the caller has SeDebugPrivilege.  If
    // he does, we will allow him any access he wants to the process.
    // We do this by clearing the DesiredAccess in the AccessState
    // and recording what we want him to have in the PreviouslyGrantedAccess
    // field.

    if (SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode )) {

        if ( AccessState.RemainingDesiredAccess & MAXIMUM_ALLOWED ) {
            AccessState.PreviouslyGrantedAccess |= THREAD_ALL_ACCESS;

        } else {
 
            AccessState.PreviouslyGrantedAccess |= ( AccessState.RemainingDesiredAccess );
        }

        AccessState.RemainingDesiredAccess = 0;

    }

    if ( ObjectNamePresent ) {

        //
        // Open handle to the Thread object with the specified desired access,
        // set Thread handle value, and return service completion status.
        //

        Status = ObOpenObjectByName(
                    ObjectAttributes,
                    PsThreadType,
                    PreviousMode,
                    &AccessState,
                    0,
                    NULL,
                    &Handle
                    );

        SeDeleteAccessState( &AccessState );

        if ( NT_SUCCESS(Status) ) {
            try {
                *ThreadHandle = Handle;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
        }
        return Status;
    }

    if ( ClientIdPresent ) {

        if ( CapturedCid.UniqueProcess ) {
            Status = PsLookupProcessThreadByCid(
                        &CapturedCid,
                        NULL,
                        &Thread
                        );

            if ( !NT_SUCCESS(Status) ) {
                SeDeleteAccessState( &AccessState );
                return Status;
            }
        } else {
            Status = PsLookupThreadByThreadId(
                        CapturedCid.UniqueThread,
                        &Thread
                        );

            if ( !NT_SUCCESS(Status) ) {
                SeDeleteAccessState( &AccessState );
                return Status;
            }

        }

        Status = ObOpenObjectByPointer(
                    Thread,
                    HandleAttributes,
                    &AccessState,
                    0,
                    PsThreadType,
                    PreviousMode,
                    &Handle
                    );

        SeDeleteAccessState( &AccessState );
        ObDereferenceObject(Thread);

        if ( NT_SUCCESS(Status) ) {

            try {
                *ThreadHandle = Handle;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
        }

        return Status;

    }

    return STATUS_INVALID_PARAMETER_MIX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\psdelete.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psdelete.c

Abstract:

    This module implements process and thread object termination and
    deletion.

Author:

    Mark Lucovsky (markl) 01-May-1989

Revision History:

--*/

#include "psp.h"

extern PEPROCESS ExpDefaultErrorPortProcess;

#ifdef ALLOC_PRAGMA

NTSTATUS
PspFreezeProcessWorker (
    PEPROCESS Process,
    PVOID Context
    );

VOID
PspCatchCriticalBreak(
    IN PCHAR Msg,
    IN PVOID  Object,
    IN PUCHAR ImageFileName
    );

#pragma alloc_text(PAGE, PsSetLegoNotifyRoutine)
#pragma alloc_text(PAGE, PspTerminateThreadByPointer)
#pragma alloc_text(PAGE, NtTerminateProcess)
#pragma alloc_text(PAGE, PsTerminateProcess)
#pragma alloc_text(PAGE, PspWaitForUsermodeExit)
#pragma alloc_text(PAGE, NtTerminateThread)
#pragma alloc_text(PAGE, PsTerminateSystemThread)
#pragma alloc_text(PAGE, PspNullSpecialApc)
#pragma alloc_text(PAGE, PsExitSpecialApc)
#pragma alloc_text(PAGE, PspExitApcRundown)
#pragma alloc_text(PAGE, PspExitNormalApc)
#pragma alloc_text(PAGE, PspCatchCriticalBreak)
#pragma alloc_text(PAGE, PspExitThread)
#pragma alloc_text(PAGE, PspExitProcess)
#pragma alloc_text(PAGE, PspProcessDelete)
#pragma alloc_text(PAGE, PspThreadDelete)
#pragma alloc_text(PAGE, NtRegisterThreadTerminatePort)
#pragma alloc_text(PAGE, PsGetProcessExitTime)
#pragma alloc_text(PAGE, PsShutdownSystem)
#pragma alloc_text(PAGE, PsWaitForAllProcesses)
#pragma alloc_text(PAGE, PspFreezeProcessWorker)
#pragma alloc_text(PAGE, PspTerminateProcess)
#endif


LARGE_INTEGER ShortTime = {(ULONG)(-10 * 1000 * 100), -1}; // 100 milliseconds


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
PLEGO_NOTIFY_ROUTINE PspLegoNotifyRoutine = NULL;

ULONG
PsSetLegoNotifyRoutine(
    PLEGO_NOTIFY_ROUTINE LegoNotifyRoutine
    )
{
    PAGED_CODE();

    PspLegoNotifyRoutine = LegoNotifyRoutine;

    return FIELD_OFFSET(KTHREAD,LegoData);
}

VOID
PspReaper(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine implements the thread reaper. The reaper is responsible
    for processing terminated threads. This includes:

        - deallocating their kernel stacks

        - releasing their process' CreateDelete lock

        - dereferencing their process

        - dereferencing themselves

Arguments:

    Context - NOT USED

Return Value:

    None.

--*/

{
    PSINGLE_LIST_ENTRY NextEntry;
    PETHREAD Thread;

    UNREFERENCED_PARAMETER (Context);

    //
    // Remove the current list of threads from the reaper list and place a
    // marker in the reaper list head. This marker will prevent another
    // worker thread from being queued until all threads in the reaper list
    // have been processed.
    //

    do {

        NextEntry = InterlockedExchangePointer (&PsReaperListHead.Next,
                                                (PVOID)1);

        ASSERT ((NextEntry != NULL) && (NextEntry != (PVOID)1));
    
        //
        // Delete the respective kernel stack and dereference each thread
        // in the reaper list.
        //
    
        do {
    
            //
            // Wait until context is swapped for this thread.
            //
    
            Thread = CONTAINING_RECORD (NextEntry, ETHREAD, ReaperLink);
            KeWaitForContextSwap (&Thread->Tcb);
            MmDeleteKernelStack (Thread->Tcb.StackBase,
                                 (BOOLEAN)Thread->Tcb.LargeStack);
    
            Thread->Tcb.InitialStack = NULL;
            NextEntry = NextEntry->Next;
            ObDereferenceObject (Thread);
    
        } while ((NextEntry != NULL) && (NextEntry != (PVOID)1));

    } while (InterlockedCompareExchangePointer (&PsReaperListHead.Next,
                                                NULL,
                                                (PVOID)1) != (PVOID)1);

    return;
}

NTSTATUS
PspTerminateThreadByPointer(
    IN PETHREAD Thread,
    IN NTSTATUS ExitStatus,
    IN BOOLEAN DirectTerminate
    )

/*++

Routine Description:

    This function causes the specified thread to terminate.

Arguments:

    ThreadHandle - Supplies a referenced pointer to the thread to terminate.

    ExitStatus - Supplies the exit status associated with the thread.

    DirectTerminate - TRUE is its ok to exit without queing an APC, FALSE otherwise

Return Value:

    TBD

--*/

{
    NTSTATUS Status;
    PKAPC    ExitApc=NULL;
    ULONG    OldMask;

    PAGED_CODE();

    if (Thread->CrossThreadFlags
    & PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION) {
      PspCatchCriticalBreak("Terminating critical thread 0x%p (in %s)\n",
                Thread,
                THREAD_TO_PROCESS(Thread)->ImageFileName);
    }

    if (DirectTerminate && Thread == PsGetCurrentThread()) {

        ASSERT (KeGetCurrentIrql() < APC_LEVEL);

        PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_TERMINATED);

        PspExitThread (ExitStatus);

        //
        // Never Returns
        //

    } else {
        //
        // Cross thread deletion of system threads won't work.
        //
        if (IS_SYSTEM_THREAD (Thread)) {
            return STATUS_ACCESS_DENIED;
        }

        Status = STATUS_SUCCESS;

        while (1) {
            ExitApc = (PKAPC) ExAllocatePoolWithTag (NonPagedPool,
                                                     sizeof(KAPC),
                                                     'xEsP');
            if (ExitApc != NULL) {
                break;
            }
            KeDelayExecutionThread(KernelMode, FALSE, &ShortTime);
        }

        //
        // Mark the thread as terminating and call the exit function.
        //
        OldMask = PS_TEST_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_TERMINATED);

        //
        // If we are the first to set the terminating flag then queue the APC
        //

        if ((OldMask & PS_CROSS_THREAD_FLAGS_TERMINATED) == 0) {

            KeInitializeApc (ExitApc,
                             PsGetKernelThread (Thread),
                             OriginalApcEnvironment,
                             PsExitSpecialApc,
                             PspExitApcRundown,
                             PspExitNormalApc,
                             KernelMode,
                             ULongToPtr (ExitStatus));

            if (!KeInsertQueueApc (ExitApc, ExitApc, NULL, 2)) {
                //
                // If APC queuing is disabled then the thread is exiting anyway
                //
                ExFreePool (ExitApc);
                Status = STATUS_UNSUCCESSFUL;
            } else {
                //
                // We queued the APC to the thread. Wake up the thread if it was suspened.
                //
                KeForceResumeThread (&Thread->Tcb);

            }
        } else {
            ExFreePool (ExitApc);
        }
    }

    return Status;
}

NTSTATUS
NtTerminateProcess(
    IN HANDLE ProcessHandle OPTIONAL,
    IN NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the specified process and all of
    its threads to terminate.

Arguments:

    ProcessHandle - Supplies a handle to the process to terminate.

    ExitStatus - Supplies the exit status associated with the process.

Return Value:

    NTSTATUS - Status of operation

--*/

{

    PETHREAD Thread, Self;
    PEPROCESS Process;
    PEPROCESS CurrentProcess;
    NTSTATUS st;
    BOOLEAN ProcessHandleSpecified;
    PAGED_CODE();

    Self = PsGetCurrentThread();
    CurrentProcess = PsGetCurrentProcessByThread (Self);

    if (ARGUMENT_PRESENT (ProcessHandle)) {
        ProcessHandleSpecified = TRUE;
    } else {
        ProcessHandleSpecified = FALSE;
        ProcessHandle = NtCurrentProcess();
    }

    st = ObReferenceObjectByHandle (ProcessHandle,
                                    PROCESS_TERMINATE,
                                    PsProcessType,
                                    KeGetPreviousModeByThread(&Self->Tcb),
                                    &Process,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return(st);
    }

    if (Process->Flags & PS_PROCESS_FLAGS_BREAK_ON_TERMINATION) {
        PspCatchCriticalBreak ("Terminating critical process 0x%p (%s)\n",
                               Process,
                               Process->ImageFileName);
    }

    //
    // Acquire rundown protection just so we can give the right errors
    //

    if (!ExAcquireRundownProtection (&Process->RundownProtect)) {
        ObDereferenceObject (Process);
        return STATUS_PROCESS_IS_TERMINATING;
    }

    //
    // Mark process as deleting except for the obscure delete self case.
    //
    if (ProcessHandleSpecified) {
        PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_PROCESS_DELETE);
    }

    st = STATUS_NOTHING_TO_TERMINATE;

    for (Thread = PsGetNextProcessThread (Process, NULL);
         Thread != NULL;
         Thread = PsGetNextProcessThread (Process, Thread)) {

        st = STATUS_SUCCESS;
        if (Thread != Self) {
            PspTerminateThreadByPointer (Thread, ExitStatus, FALSE);
        }
    }

    ExReleaseRundownProtection (&Process->RundownProtect);


    if (Process == CurrentProcess) {
        if (ProcessHandleSpecified) {

            ObDereferenceObject (Process);

            //
            // Never Returns
            //

            PspTerminateThreadByPointer (Self, ExitStatus, TRUE);
        }
    } else if (ExitStatus == DBG_TERMINATE_PROCESS) {
        DbgkClearProcessDebugObject (Process, NULL);
    }

    //
    // If there are no threads in this process then clear out its handle table.
    // Do the same for processes being debugged. This is so a process can never lock itself into the system
    // by debugging itself or have a handle open to itself.
    //
    if (st == STATUS_NOTHING_TO_TERMINATE || (Process->DebugPort != NULL && ProcessHandleSpecified)) {
        ObClearProcessHandleTable (Process);
        st = STATUS_SUCCESS;
    }

    ObDereferenceObject(Process);

    return st;
}

NTSTATUS
PsTerminateProcess(
    PEPROCESS Process,
    NTSTATUS Status
    )
{
    return PspTerminateProcess (Process, Status);
}

NTSTATUS
PspTerminateProcess(
    PEPROCESS Process,
    NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the specified process and all of
    its threads to terminate.

Arguments:

    ProcessHandle - Supplies a handle to the process to terminate.

    ExitStatus - Supplies the exit status associated with the process.

Return Value:

    TBD

--*/

{

    PETHREAD Thread;
    NTSTATUS st;

    PAGED_CODE();


    if (Process->Flags
    & PS_PROCESS_FLAGS_BREAK_ON_TERMINATION) {
      PspCatchCriticalBreak("Terminating critical process 0x%p (%s)\n",
                Process,
                Process->ImageFileName);
    }

    //
    // Mark process as deleting
    //
    PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_PROCESS_DELETE);

    st = STATUS_NOTHING_TO_TERMINATE;

    for (Thread = PsGetNextProcessThread (Process, NULL);
         Thread != NULL;
         Thread = PsGetNextProcessThread (Process, Thread)) {

        st = STATUS_SUCCESS;

        PspTerminateThreadByPointer (Thread, ExitStatus, FALSE);

    }

    //
    // If there are no threads in this process then clear out its handle table.
    // Do the same for processes being debugged. This is so a process can never lock itself into the system
    // by debugging itself or have a handle open to itself.
    //
    if (st == STATUS_NOTHING_TO_TERMINATE || Process->DebugPort != NULL) {
        ObClearProcessHandleTable (Process);
        st = STATUS_SUCCESS;
    }
    return st;
}


NTSTATUS
PspWaitForUsermodeExit(
    IN PEPROCESS         Process
    )

/*++

Routine Description:

    This function waits for a process's usermode threads to terminate.

Arguments:

    Process - Supplies a pointer to the process to wait for

    WaitMode - Supplies the mode to wait in

    LockMode - Supplies the way to wait for the process lock

Return Value:

    NTSTATUS - Status of call

--*/
{
    BOOLEAN     GotAThread;
    PETHREAD    Thread;

    do {
        GotAThread = FALSE;

        for (Thread = PsGetNextProcessThread (Process, NULL);
             Thread != NULL;
             Thread = PsGetNextProcessThread (Process, Thread)) {

            if (!IS_SYSTEM_THREAD (Thread) && !KeReadStateThread (&Thread->Tcb)) {
                ObReferenceObject (Thread);
                PsQuitNextProcessThread (Thread);
                GotAThread = TRUE;
                break;
            }
        }


        if (GotAThread) {
            KeWaitForSingleObject (Thread,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);
            ObDereferenceObject (Thread);
        }
    } while (GotAThread);

    return STATUS_SUCCESS;
}


NTSTATUS
NtTerminateThread(
    IN HANDLE ThreadHandle OPTIONAL,
    IN NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the specified thread to terminate.

Arguments:

    ThreadHandle - Supplies a handle to the thread to terminate.

    ExitStatus - Supplies the exit status associated with the thread.

Return Value:

    TBD

--*/

{

    PETHREAD Thread=NULL, ThisThread;
    PEPROCESS ThisProcess;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN Self = TRUE;

    PAGED_CODE();

    ThisThread = PsGetCurrentThread ();

    if (!ARGUMENT_PRESENT (ThreadHandle)) {
        //
        // This is part of the strange linkage between base\win32 and the kernel.
        // This routine gets called this way first and if it returns the base
        // code does an exit process call.
        //
        ThisProcess = PsGetCurrentProcessByThread (ThisThread);

        if (ThisProcess->ActiveThreads == 1) {
            return STATUS_CANT_TERMINATE_SELF;
        }
        Self = TRUE;
    } else {
        if (ThreadHandle != NtCurrentThread ()) {
            Status = ObReferenceObjectByHandle (ThreadHandle,
                                                THREAD_TERMINATE,
                                                PsThreadType,
                                                KeGetPreviousModeByThread (&ThisThread->Tcb),
                                                &Thread,
                                                NULL);
            if (!NT_SUCCESS (Status)) {
                return Status;
            }

            if (Thread == ThisThread) {
                ObDereferenceObject (Thread);
            } else {
                Self = FALSE;
            }
        }

    }

    if (Self) {
        PspTerminateThreadByPointer (ThisThread, ExitStatus, TRUE);
    } else {
        Status = PspTerminateThreadByPointer (Thread, ExitStatus, FALSE);
        ObDereferenceObject (Thread);
    }

    return Status;
}

NTSTATUS
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the current thread, which must be a system
    thread, to terminate.

Arguments:

    ExitStatus - Supplies the exit status associated with the thread.

Return Value:

    NTSTATUS - Status of call

--*/

{
    PETHREAD Thread = PsGetCurrentThread();

    if (!IS_SYSTEM_THREAD (Thread)) {
        return STATUS_INVALID_PARAMETER;
    }

    return PspTerminateThreadByPointer (Thread, ExitStatus, TRUE);
}


VOID
PspNullSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

{

    PAGED_CODE();

    UNREFERENCED_PARAMETER(NormalRoutine);
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    ExFreePool (Apc);
}

VOID
PsExitSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

{
    NTSTATUS ExitStatus;
    PETHREAD Thread;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(NormalRoutine);
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    Thread = PsGetCurrentThread();

    if (((ULONG_PTR)Apc->SystemArgument2) & 1) {
        ExitStatus = (NTSTATUS)((LONG_PTR)Apc->NormalContext);
        PspExitApcRundown (Apc);
        PspExitThread (ExitStatus);
    }

}

VOID
PspExitApcRundown(
    IN PKAPC Apc
    )
{
    PAGED_CODE();

    ExFreePool(Apc);
}

VOID
PspExitNormalApc(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

{
    PETHREAD Thread;
    PKAPC ExitApc;

    PAGED_CODE();

    ASSERT (!(((ULONG_PTR)SystemArgument2) & 1));

    Thread = PsGetCurrentThread();

    ExitApc = (PKAPC) SystemArgument1;

    KeInitializeApc (ExitApc,
                     PsGetKernelThread(Thread),
                     OriginalApcEnvironment,
                     PsExitSpecialApc,
                     PspExitApcRundown,
                     PspExitNormalApc,
                     UserMode,
                     NormalContext);

    if (!KeInsertQueueApc (ExitApc, ExitApc,
                           (PVOID)((ULONG_PTR)SystemArgument2 | 1),
                           2)) {
        // Note that we'll get here if APC queueing has been
        // disabled -- on the other hand, in that case, the thread
        // is exiting anyway.
        PspExitApcRundown (ExitApc);
    }
    //
    // We just queued a user APC to this thread. User APC won't fire until we do an
    // alertable wait so we need to set this flag here.
    //
    Thread->Tcb.ApcState.UserApcPending = TRUE;
}

VOID
PspCatchCriticalBreak(
    IN PCHAR Msg,
    IN PVOID Object,
    IN PUCHAR ImageFileName
    )
{
    // The object is critical to the OS -- ask to break in, or bugcheck.
    char    Response[2];
    BOOLEAN Handled;

    PAGED_CODE();

    Handled = FALSE;

    if (KdDebuggerEnabled) {
        DbgPrint(Msg,
                 Object,
                 ImageFileName);

        while (! Handled
               && ! KdDebuggerNotPresent) {
            DbgPrompt("Break, or Ignore (bi)? ",
                      Response,
                      sizeof(Response));

            switch (Response[0]) {
            case 'b':
            case 'B':
                DbgBreakPoint();
                // Fall through
            case 'i':
            case 'I':
                Handled = TRUE;
                break;

            default:
                break;
            }
        }
    }

    if (!Handled) {
        //
        // No debugger -- bugcheck immediately
        //
        KeBugCheckEx(CRITICAL_OBJECT_TERMINATION,
                     (ULONG_PTR) ((DISPATCHER_HEADER *)Object)->Type,
                     (ULONG_PTR) Object,
                     (ULONG_PTR) ImageFileName,
                     (ULONG_PTR) Msg);
    }
}

DECLSPEC_NORETURN
VOID
PspExitThread(
    IN NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the currently executing thread to terminate.  This
    function is only called from within the process structure.  It is called
    either from mainline exit code to exit the current thread, or from
    PsExitSpecialApc (as a piggyback to user-mode PspExitNormalApc).

Arguments:

    ExitStatus - Supplies the exit status associated with the current thread.

Return Value:

    None.

--*/


{

    PETHREAD Thread;
    PETHREAD WaitThread;
    PETHREAD DerefThread;
    PEPROCESS Process;
    PKAPC Apc;
    PLIST_ENTRY Entry, FirstEntry;
    PTERMINATION_PORT TerminationPort, NextPort;
    LPC_CLIENT_DIED_MSG CdMsg;
    BOOLEAN LastThread;
    PTEB Teb;
    PPEB Peb;
    PACCESS_TOKEN ProcessToken;
    NTSTATUS Status;

    PAGED_CODE();

    Thread = PsGetCurrentThread();
    Process = THREAD_TO_PROCESS(Thread);

    if (Process != PsGetCurrentProcessByThread (Thread)) {
        KeBugCheckEx (INVALID_PROCESS_ATTACH_ATTEMPT,
                      (ULONG_PTR)Process,
                      (ULONG_PTR)Thread->Tcb.ApcState.Process,
                      (ULONG)Thread->Tcb.ApcStateIndex,
                      (ULONG_PTR)Thread);
    }

    KeLowerIrql(PASSIVE_LEVEL);

    if (Thread->ActiveExWorker) {
        KeBugCheckEx (ACTIVE_EX_WORKER_THREAD_TERMINATION,
                      (ULONG_PTR)Thread,
                      0,
                      0,
                      0);
    }

    if (Thread->Tcb.CombinedApcDisable != 0) {
        KeBugCheckEx (KERNEL_APC_PENDING_DURING_EXIT,
                      (ULONG_PTR)0,
                      (ULONG_PTR)Thread->Tcb.CombinedApcDisable,
                      (ULONG_PTR)0,
                      1);
    }


    //
    // Its time to start turning off various cross thread references.
    // Mark the thread as rundown and wait for accessors to exit.
    //
    ExWaitForRundownProtectionRelease (&Thread->RundownProtect);

    //
    // Clear any execution state associated with the thread
    //

    PoRundownThread(Thread);

    //
    // Notify registered callout routines of thread deletion.
    //

    PERFINFO_THREAD_DELETE(Thread);

    if (PspCreateThreadNotifyRoutineCount != 0) {
        ULONG i;
        PEX_CALLBACK_ROUTINE_BLOCK CallBack;
        PCREATE_THREAD_NOTIFY_ROUTINE Rtn;

        for (i=0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i++) {
            CallBack = ExReferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i]);
            if (CallBack != NULL) {
                Rtn = (PCREATE_THREAD_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack);
                Rtn (Process->UniqueProcessId,
                     Thread->Cid.UniqueThread,
                     FALSE);
                ExDereferenceCallBackBlock (&PspCreateThreadNotifyRoutine[i],
                                            CallBack);
            }
        }
    }

    LastThread = FALSE;
    DerefThread = NULL;

    PspLockProcessExclusive (Process, Thread);

    //
    // Say one less active thread. If we are the last then block creates and wait for the other threads to exit.
    //
    Process->ActiveThreads--;
    if (Process->ActiveThreads == 0) {
        PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_PROCESS_DELETE);

        LastThread = TRUE;
        if (ExitStatus == STATUS_THREAD_IS_TERMINATING) {
            if (Process->ExitStatus == STATUS_PENDING) {
                Process->ExitStatus = Process->LastThreadExitStatus;
            }
        } else {
            Process->ExitStatus = ExitStatus;
        }

        //
        // We are the last thread to leave the process. We have to wait till all the other threads have exited before we do.
        //
        for (Entry = Process->ThreadListHead.Flink;
             Entry != &Process->ThreadListHead;
             Entry = Entry->Flink) {

            WaitThread = CONTAINING_RECORD (Entry, ETHREAD, ThreadListEntry);
            if (WaitThread != Thread &&
                !KeReadStateThread (&WaitThread->Tcb) &&
                ObReferenceObjectSafe (WaitThread)) {

                PspUnlockProcessExclusive (Process, Thread);

                KeWaitForSingleObject (WaitThread,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);

                if (DerefThread != NULL) {
                    ObDereferenceObject (DerefThread);
                }
                DerefThread = WaitThread;
                PspLockProcessExclusive (Process, Thread);
            }
        }
    } else {
        if (ExitStatus != STATUS_THREAD_IS_TERMINATING) {
            Process->LastThreadExitStatus = ExitStatus;
        }
    }

    PspUnlockProcessExclusive (Process, Thread);

    if (DerefThread != NULL) {
        ObDereferenceObject (DerefThread);
    }


    //
    // If we need to send debug messages then do so.
    //

    if (Process->DebugPort != NULL) {
        //
        // Don't report system thread exit to the debugger as we don't report them.
        //
        if (!IS_SYSTEM_THREAD (Thread)) {
            if (LastThread) {
                DbgkExitProcess (ExitStatus);
            } else {
                DbgkExitThread (ExitStatus);
            }
        }
    }

    if (KD_DEBUGGER_ENABLED) {

        if (Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION) {
            PspCatchCriticalBreak ("Critical thread 0x%p (in %s) exited\n",
                                   Thread,
                                   Process->ImageFileName);
        }
    } // End of critical thread/process exit detect

    if (LastThread &&
        (Process->Flags & PS_PROCESS_FLAGS_BREAK_ON_TERMINATION)) {
        if (KD_DEBUGGER_ENABLED) {
            PspCatchCriticalBreak ("Critical process 0x%p (%s) exited\n",
                                   Process,
                                   Process->ImageFileName);
        } else {
            KeBugCheckEx (CRITICAL_PROCESS_DIED,
                          (ULONG_PTR)Process,
                          0,
                          0,
                          0);
        }
    }


    ASSERT(Thread->Tcb.CombinedApcDisable == 0);

    //
    // Process the TerminationPort. This is only accessed from this thread
    //
    TerminationPort = Thread->TerminationPort;
    if (TerminationPort != NULL) {

        CdMsg.PortMsg.u1.s1.DataLength = sizeof(LARGE_INTEGER);
        CdMsg.PortMsg.u1.s1.TotalLength = sizeof(LPC_CLIENT_DIED_MSG);
        CdMsg.PortMsg.u2.s2.Type = LPC_CLIENT_DIED;
        CdMsg.PortMsg.u2.s2.DataInfoOffset = 0;

        do {

            CdMsg.CreateTime.QuadPart = PS_GET_THREAD_CREATE_TIME (Thread);
            while (1) {
                Status = LpcRequestPort (TerminationPort->Port, (PPORT_MESSAGE)&CdMsg);
                if (Status == STATUS_NO_MEMORY || Status == STATUS_INSUFFICIENT_RESOURCES) {
                    KeDelayExecutionThread (KernelMode, FALSE, &ShortTime);
                    continue;
                }
                break;
            }
            ObDereferenceObject (TerminationPort->Port);

            NextPort = TerminationPort->Next;

            ExFreePoolWithTag (TerminationPort, 'pTsP'|PROTECTED_POOL);

            TerminationPort = NextPort;

        } while (TerminationPort != NULL);
    } else {

        //
        // If there are no ports to send notifications to,
        // but there is an exception port, then we have to
        // send a client died message through the exception
        // port. This will allow a server a chance to get notification
        // if an app/thread dies before it even starts
        //
        //
        // We only send the exception if the thread creation really worked.
        // DeadThread is set when an NtCreateThread returns an error, but
        // the thread will actually execute this path. If DeadThread is not
        // set than the thread creation succeeded. The other place DeadThread
        // is set is when we were terminated without having any chance to move.
        // in this case, DeadThread is set and the exit status is set to
        // STATUS_THREAD_IS_TERMINATING
        //

        if ((ExitStatus == STATUS_THREAD_IS_TERMINATING &&
            (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD)) ||
            !(Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD)) {

            CdMsg.PortMsg.u1.s1.DataLength = sizeof (LARGE_INTEGER);
            CdMsg.PortMsg.u1.s1.TotalLength = sizeof (LPC_CLIENT_DIED_MSG);
            CdMsg.PortMsg.u2.s2.Type = LPC_CLIENT_DIED;
            CdMsg.PortMsg.u2.s2.DataInfoOffset = 0;
            if (Process->ExceptionPort != NULL) {
                CdMsg.CreateTime.QuadPart = PS_GET_THREAD_CREATE_TIME (Thread);
                while (1) {
                    Status = LpcRequestPort (Process->ExceptionPort, (PPORT_MESSAGE)&CdMsg);
                    if (Status == STATUS_NO_MEMORY || Status == STATUS_INSUFFICIENT_RESOURCES) {
                        KeDelayExecutionThread (KernelMode, FALSE, &ShortTime);
                        continue;
                    }
                    break;
                }
            }
        }
    }

    //
    // rundown the Win32 structures
    //

    if (Thread->Tcb.Win32Thread) {
        (PspW32ThreadCallout) (Thread, PsW32ThreadCalloutExit);
    }

    if (LastThread && Process->Win32Process) {
        (PspW32ProcessCallout) (Process, FALSE);
    }

    //
    // User/Gdi has been given a chance to clean up. Now make sure they didn't
    // leave the kernel stack locked which would happen if data was still live on
    // this stack, but was being used by another thread
    //

    if (!Thread->Tcb.EnableStackSwap) {
        KeBugCheckEx (KERNEL_STACK_LOCKED_AT_EXIT, 0, 0, 0, 0);
    }

    //
    // Rundown The Lists:
    //
    //      - Cancel Io By Thread
    //      - Cancel Timers
    //      - Cancel Registry Notify Requests pending against this thread
    //      - Perform kernel thread rundown
    //

    IoCancelThreadIo (Thread);
    ExTimerRundown ();
    CmNotifyRunDown (Thread);
    KeRundownThread ();

#if DBG

    //
    // See if we are exiting while holding a resource
    //

    ExCheckIfResourceOwned ();

#endif

    //
    // Delete the thread's TEB.  If the address of the TEB is in user
    // space, then this is a real user mode TEB.  If the address is in
    // system space, then this is a special system thread TEB allocated
    // from paged or nonpaged pool.
    //


    Teb = Thread->Tcb.Teb;
    if (Teb != NULL) {
        PRTL_CRITICAL_SECTION Cs;
        int DecrementCount;

        Peb = Process->Peb;

        try {

            //
            // The thread is a user-mode thread. Look to see if the thread
            // owns the loader lock (and any other key peb-based critical
            // sections. If so, do our best to release the locks.
            //
            // Since the LoaderLock used to be a mutant, releasing the lock
            // like this is very similar to mutant abandonment and the loader
            // never did anything with abandoned status anyway
            //

            Cs = Peb->LoaderLock;
            if (Cs != NULL) {
                ProbeForRead(Cs,sizeof(*Cs),4);
                if (Cs->OwningThread == Thread->Cid.UniqueThread) {

                    //
                    // x86 uses a 1 based recursion count
                    //

#if defined(_X86_)
                    DecrementCount = Cs->RecursionCount;
#else
                    DecrementCount = Cs->RecursionCount + 1;
#endif
                    Cs->RecursionCount = 0;
                    Cs->OwningThread = 0;

                    //
                    // undo lock count increments for recursion cases
                    //

                    while(DecrementCount > 1) {
                        InterlockedDecrement (&Cs->LockCount);
                        DecrementCount--;
                    }

                    //
                    // undo final lock count
                    //

                    if (InterlockedDecrement (&Cs->LockCount) >= 0) {
                        NtSetEvent (Cs->LockSemaphore, NULL);
                    }
                } else if (Teb->WaitingOnLoaderLock) {

                    //
                    // if the thread exited while waiting on the loader
                    // lock clean it up. There is still a potential race
                    // here since we can not safely know what happens to
                    // a thread after it interlocked increments the lock count
                    // but before it sets the waiting on loader lock flag. On the
                    // release side, it it safe since we mark ownership of the lock
                    // before clearing the flag. This triggers the first part of this
                    // test. The only thing out of whack is the recursion count, but this
                    // is also safe since in this state, recursion count is 0.
                    //


                    //
                    // This code isn't right. We need to bump down our lock count
                    // increment.
                    //
                    // A few cases to consider:
                    //
                    // Another thread releases the lock signals the event.
                    // We take the wait and then die before setting our ID.
                    // I doubt very much that this can happen because right
                    // after we come out of the wait, we set the owner Id
                    // (meaning that we would go through the other part of the if).
                    // Bottom line is that we should just decrement our lock count
                    // and get out of the way. There is no need to set the event.
                    // In the RAS stress failure, I saw us setting the event
                    // just because the lock count was >= 0. The lock was already held
                    // by another thread so setting the event let yet another thread
                    // also own the lock. Last one to release would get a
                    // not owner critical section failure
                    //
                    //
                    // if ( InterlockedDecrement(&Cs->LockCount) >= 0 ){
                    //     NtSetEvent(Cs->LockSemaphore,NULL);
                    // }
                    //

                    InterlockedDecrement (&Cs->LockCount);
                }
            }
#if defined(_WIN64)
            if (Process->Wow64Process) {
                // Do the same thing for the 32-bit PEB->Ldr
                PRTL_CRITICAL_SECTION32 Cs32;
                PPEB32 Peb32;

                Peb32 = Process->Wow64Process->Wow64;
                Cs32 = (PRTL_CRITICAL_SECTION32)ULongToPtr (Peb32->LoaderLock);
                if (Cs32 != NULL) {
                    ProbeForRead (Cs32, sizeof(*Cs32), 4);
                    if (Cs32->OwningThread == PtrToUlong(Thread->Cid.UniqueThread)) {
                        //
                        // x86 uses a 1 based recursion count, so the
                        // IA64 kernel needs to do the same, since
                        // the critsect is really implemented by IA32
                        // usermode.
                        //
                        DecrementCount = Cs32->RecursionCount;
                        Cs32->RecursionCount = 0;
                        Cs32->OwningThread = 0;

                        //
                        // undo lock count increments for recursion cases
                        //
                        while(DecrementCount > 1) {
                            InterlockedDecrement(&Cs32->LockCount);
                            DecrementCount--;
                        }

                        //
                        // undo final lock count
                        //
                        if (InterlockedDecrement (&Cs32->LockCount) >= 0){
                            NtSetEvent (LongToHandle (Cs32->LockSemaphore),NULL);
                        }
                    } else {
                        PTEB32 Teb32 = WOW64_GET_TEB32(Teb);

                        ProbeForRead (Teb32,sizeof (*Teb32), 4);
                        if (Teb32->WaitingOnLoaderLock) {
                            InterlockedDecrement(&Cs32->LockCount);
                        }
                    }
                }
            }
#endif


            //
            // Free the user mode stack on termination if we need to.
            //

            if (Teb->FreeStackOnTermination &&
                (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD) == 0) {
                SIZE_T Zero = 0;
                PVOID BaseAddress = Teb->DeallocationStack;
                ZwFreeVirtualMemory (NtCurrentProcess (),
                                     &BaseAddress,
                                     &Zero,
                                     MEM_RELEASE);
            }

            //
            // Close the debugger object associated with this thread if there is one.
            //
            if (Teb->DbgSsReserved[1] != NULL) {
                ObCloseHandle (Teb->DbgSsReserved[1], UserMode);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }

        MmDeleteTeb (Process, Teb);
        Thread->Tcb.Teb = NULL;
    }


    //
    // Let LPC component deal with message stack in Thread->LpcReplyMessage
    // but do it after the client ID becomes invalid.
    //

    LpcExitThread (Thread);

    Thread->ExitStatus = ExitStatus;
    KeQuerySystemTime (&Thread->ExitTime);


    ASSERT (Thread->Tcb.CombinedApcDisable == 0);

    if (LastThread) {

        Process->ExitTime = Thread->ExitTime;
        PspExitProcess (TRUE, Process);
            
        ProcessToken = PsReferencePrimaryToken (Process);
        if (SeDetailedAuditingWithToken (ProcessToken)) {
            SeAuditProcessExit (Process);
        }
        PsDereferencePrimaryTokenEx (Process, ProcessToken);

#if defined(_X86_)
        //
        // Rundown VDM DPCs
        //
        if (Process->VdmObjects != NULL) {
            VdmRundownDpcs (Process);
        }
#endif

        //
        // Rundown the handle table
        //
        ObKillProcess (Process);

        //
        // Release the image section
        //
        if (Process->SectionObject != NULL) {
            ObDereferenceObject (Process->SectionObject);
            Process->SectionObject = NULL;
        }

        if (Process->Job != NULL) {

            //
            // Now we can fold the process accounting into the job. Don't need to wait for
            // the delete routine.
            //

            PspExitProcessFromJob (Process->Job, Process);

        }

    }


    //
    // Rundown pending APCs. Protect against being frozen after we raise IRQL but before dispatcher lock is taken.
    //
    KeEnterCriticalRegionThread (&Thread->Tcb);

    //
    // Disable APC queueing for the current thread.
    //

    Thread->Tcb.ApcQueueable = FALSE;

    //
    // At this point we may have been frozen and the APC is pending. First we remove the suspend/freeze bias that
    // may exist and then drop IRQL. The suspend APC if present will fire and drop through. No futher suspends are
    // allowed as the thread is marked to prevent APC's
    //
    KeForceResumeThread (&Thread->Tcb);
    KeLeaveCriticalRegionThread (&Thread->Tcb);

    //
    // flush user-mode APC queue
    //

    FirstEntry = KeFlushQueueApc (&Thread->Tcb, UserMode);

    if (FirstEntry != NULL) {

        Entry = FirstEntry;
        do {
            Apc = CONTAINING_RECORD (Entry, KAPC, ApcListEntry);
            Entry = Entry->Flink;

            //
            // If the APC has a rundown routine then call it. Otherwise
            // deallocate the APC
            //

            if (Apc->RundownRoutine) {
                (Apc->RundownRoutine) (Apc);
            } else {
                ExFreePool (Apc);
            }

        } while (Entry != FirstEntry);
    }

    if (LastThread) {
        MmCleanProcessAddressSpace (Process);
    }

    if (Thread->Tcb.LegoData && PspLegoNotifyRoutine) {
        (PspLegoNotifyRoutine) (&Thread->Tcb);
    }

    //
    // flush kernel-mode APC queue
    // There should never be any kernel mode APCs found this far
    // into thread termination. Since we go to PASSIVE_LEVEL upon
    // entering exit.
    //

    FirstEntry = KeFlushQueueApc (&Thread->Tcb, KernelMode);

    if (FirstEntry != NULL || Thread->Tcb.CombinedApcDisable != 0) {
        KeBugCheckEx (KERNEL_APC_PENDING_DURING_EXIT,
                      (ULONG_PTR)FirstEntry,
                      (ULONG_PTR)Thread->Tcb.CombinedApcDisable,
                      (ULONG_PTR)KeGetCurrentIrql(),
                      0);
    }


    //
    // Signal the process
    //

    if (LastThread) {
        KeSetProcess (&Process->Pcb, 0, FALSE);
    }

    //
    // Terminate the thread.
    //
    // N.B. There is no return from this call.
    //
    // N.B. The kernel inserts the current thread in the reaper list and
    //      activates a thread, if necessary, to reap the terminating thread.
    //

    KeTerminateThread (0L);
}

VOID
PspExitProcess(
    IN BOOLEAN LastThreadExit,
    IN PEPROCESS Process
    )
{
    ULONG ActualTime;
    PEJOB Job;
    PETHREAD CurrentThread;

    PAGED_CODE();

    PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_PROCESS_EXITING);

    if (LastThreadExit) {

        PERFINFO_PROCESS_DELETE(Process);

        if (PspCreateProcessNotifyRoutineCount != 0) {
            ULONG i;
            PEX_CALLBACK_ROUTINE_BLOCK CallBack;
            PCREATE_PROCESS_NOTIFY_ROUTINE Rtn;

            for (i = 0; i < PSP_MAX_CREATE_PROCESS_NOTIFY; i++) {
                CallBack = ExReferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i]);
                if (CallBack != NULL) {
                    Rtn = (PCREATE_PROCESS_NOTIFY_ROUTINE) ExGetCallBackBlockRoutine (CallBack);
                    Rtn (Process->InheritedFromUniqueProcessId,
                         Process->UniqueProcessId,
                         FALSE);
                    ExDereferenceCallBackBlock (&PspCreateProcessNotifyRoutine[i],
                                                CallBack);
                }
            }
        }

    }


    PoRundownProcess (Process);

    //
    // Dereference (close) the security port.  This will stop any authentication
    // or EFS requests from this process to the LSA process.  The "well known"
    // value of 1 will prevent the security system from try to re-establish the
    // connection during the process shutdown (e.g. when the rdr deletes a handle)
    //

    if (Process->SecurityPort) {

        if (Process->SecurityPort != ((PVOID) 1)) {
            ObDereferenceObject (Process->SecurityPort);

            Process->SecurityPort = (PVOID) 1 ;
        }
    }
    else {
        
        //
        // Even if there have never been any requests to the LSA process, i.e. the pointer
        // is NULL, set it to 1 anyway.  Filter drivers can apparently cause a network 
        // hop at this point.  This will prevent any such from deadlocking.
        //

        Process->SecurityPort = (PVOID) 1 ;
    }


    if (LastThreadExit) {


        //
        // If the current process has previously set the timer resolution,
        // then reset it.
        //

        if ((Process->Flags&PS_PROCESS_FLAGS_SET_TIMER_RESOLUTION) != 0) {
            ZwSetTimerResolution (KeMaximumIncrement, FALSE, &ActualTime);
        }

        Job = Process->Job;
        if (Job != NULL && Job->CompletionPort != NULL &&
            !(Process->JobStatus & PS_JOB_STATUS_NOT_REALLY_ACTIVE) &&
            !(Process->JobStatus & PS_JOB_STATUS_EXIT_PROCESS_REPORTED)) {

            ULONG_PTR ExitMessageId;

            switch (Process->ExitStatus) {
                case STATUS_GUARD_PAGE_VIOLATION      :
                case STATUS_DATATYPE_MISALIGNMENT     :
                case STATUS_BREAKPOINT                :
                case STATUS_SINGLE_STEP               :
                case STATUS_ACCESS_VIOLATION          :
                case STATUS_IN_PAGE_ERROR             :
                case STATUS_ILLEGAL_INSTRUCTION       :
                case STATUS_NONCONTINUABLE_EXCEPTION  :
                case STATUS_INVALID_DISPOSITION       :
                case STATUS_ARRAY_BOUNDS_EXCEEDED     :
                case STATUS_FLOAT_DENORMAL_OPERAND    :
                case STATUS_FLOAT_DIVIDE_BY_ZERO      :
                case STATUS_FLOAT_INEXACT_RESULT      :
                case STATUS_FLOAT_INVALID_OPERATION   :
                case STATUS_FLOAT_OVERFLOW            :
                case STATUS_FLOAT_STACK_CHECK         :
                case STATUS_FLOAT_UNDERFLOW           :
                case STATUS_INTEGER_DIVIDE_BY_ZERO    :
                case STATUS_INTEGER_OVERFLOW          :
                case STATUS_PRIVILEGED_INSTRUCTION    :
                case STATUS_STACK_OVERFLOW            :
                case STATUS_CONTROL_C_EXIT            :
                case STATUS_FLOAT_MULTIPLE_FAULTS     :
                case STATUS_FLOAT_MULTIPLE_TRAPS      :
                case STATUS_REG_NAT_CONSUMPTION       :
                    ExitMessageId = JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS;
                    break;
                default:
                    ExitMessageId = JOB_OBJECT_MSG_EXIT_PROCESS;
                    break;
            }

            PS_SET_CLEAR_BITS (&Process->JobStatus,
                               PS_JOB_STATUS_EXIT_PROCESS_REPORTED,
                               PS_JOB_STATUS_LAST_REPORT_MEMORY);

            CurrentThread = PsGetCurrentThread ();

            KeEnterCriticalRegionThread (&CurrentThread->Tcb);
            ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

            if (Job->CompletionPort != NULL) {
                IoSetIoCompletion (Job->CompletionPort,
                                   Job->CompletionKey,
                                   (PVOID)Process->UniqueProcessId,
                                   STATUS_SUCCESS,
                                   ExitMessageId,
                                   FALSE);
            }

            ExReleaseResourceLite (&Job->JobLock);
            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        }

        if (CCPF_IS_PREFETCHER_ACTIVE ()) {

            //
            // Let prefetcher know that this process is exiting.
            //

            CcPfProcessExitNotification (Process);
        }

    } else {
        MmCleanProcessAddressSpace (Process);
    }

}

VOID
PspProcessDelete(
    IN PVOID Object
    )
{
    PEPROCESS Process;
    PETHREAD CurrentThread;
    KAPC_STATE ApcState;

    PAGED_CODE();

    Process = (PEPROCESS)Object;

    //
    // Remove the process from the global list
    //
    if (Process->ActiveProcessLinks.Flink != NULL) {
        CurrentThread = PsGetCurrentThread ();

        PspLockProcessList (CurrentThread);
        RemoveEntryList (&Process->ActiveProcessLinks);
        PspUnlockProcessList (CurrentThread);
    }

    if (Process->SeAuditProcessCreationInfo.ImageFileName != NULL) {
        ExFreePool (Process->SeAuditProcessCreationInfo.ImageFileName);
        Process->SeAuditProcessCreationInfo.ImageFileName = NULL;
    }

    if (Process->Job != NULL) {
        PspRemoveProcessFromJob (Process->Job, Process);
        ObDereferenceObjectDeferDelete (Process->Job);
        Process->Job = NULL;
    }

    KeTerminateProcess (&Process->Pcb);


    if (Process->DebugPort != NULL) {
        ObDereferenceObject (Process->DebugPort);
        Process->DebugPort = NULL;
    }
    if (Process->ExceptionPort != NULL) {
        ObDereferenceObject (Process->ExceptionPort);
        Process->ExceptionPort = NULL;
    }

    if (Process->SectionObject != NULL) {
        ObDereferenceObject (Process->SectionObject);
        Process->SectionObject = NULL;
    }

    PspDeleteLdt (Process );
    PspDeleteVdmObjects (Process);

    if (Process->ObjectTable != NULL) {
        KeStackAttachProcess (&Process->Pcb, &ApcState);
        ObKillProcess (Process);
        KeUnstackDetachProcess (&ApcState);
    }


    if (Process->Flags&PS_PROCESS_FLAGS_HAS_ADDRESS_SPACE) {

        //
        // Clean address space of the process
        //

        KeStackAttachProcess (&Process->Pcb, &ApcState);

        PspExitProcess (FALSE, Process);

        KeUnstackDetachProcess (&ApcState);

        MmDeleteProcessAddressSpace (Process);
    }

    if (Process->UniqueProcessId) {
        if (!(ExDestroyHandle (PspCidTable, Process->UniqueProcessId, NULL))) {
            KeBugCheck (CID_HANDLE_DELETION);
        }
    }

    PspDeleteProcessSecurity (Process);


    if (Process->WorkingSetWatch != NULL) {
        ExFreePool (Process->WorkingSetWatch);
        PsReturnProcessNonPagedPoolQuota (Process, WS_CATCH_SIZE);
    }

    ObDereferenceDeviceMap (Process);
    PspDereferenceQuota (Process);

#if !defined(_X86_)
    {
        //
        // Free any alignment exception tracking structures that might
        // have been around to support a user-mode debugger.
        //

        PALIGNMENT_EXCEPTION_TABLE ExceptionTable;
        PALIGNMENT_EXCEPTION_TABLE NextExceptionTable;

        ExceptionTable = Process->Pcb.AlignmentExceptionTable;
        while (ExceptionTable != NULL) {

            NextExceptionTable = ExceptionTable->Next;
            ExFreePool( ExceptionTable );
            ExceptionTable = NextExceptionTable;
        }
    }
#endif

}

VOID
PspThreadDelete(
    IN PVOID Object
    )
{
    PETHREAD Thread;
    PETHREAD CurrentThread;
    PEPROCESS Process;

    PAGED_CODE();

    Thread = (PETHREAD) Object;

    ASSERT(Thread->Tcb.Win32Thread == NULL);

    if (Thread->Tcb.InitialStack) {
        MmDeleteKernelStack(Thread->Tcb.StackBase,
                            (BOOLEAN)Thread->Tcb.LargeStack);
    }

    if (Thread->Cid.UniqueThread != NULL) {
        if (!ExDestroyHandle (PspCidTable, Thread->Cid.UniqueThread, NULL)) {
            KeBugCheck(CID_HANDLE_DELETION);
        }
    }

    PspDeleteThreadSecurity (Thread);

    Process = THREAD_TO_PROCESS(Thread);
    if (Process) {
        //
        // Remove the thread from the process if it was ever inserted.
        //
        if (Thread->ThreadListEntry.Flink != NULL) {

            CurrentThread = PsGetCurrentThread ();

            PspLockProcessExclusive (Process, CurrentThread);

            RemoveEntryList (&Thread->ThreadListEntry);

            PspUnlockProcessExclusive (Process, CurrentThread);
        }

        ObDereferenceObject(Process);
    }
}

NTSTATUS
NtRegisterThreadTerminatePort(
    IN HANDLE PortHandle
    )

/*++

Routine Description:

    This API allows a thread to register a port to be notified upon
    thread termination.

Arguments:

    PortHandle - Supplies an open handle to a port object that will be
        sent a termination message when the thread terminates.

Return Value:

    TBD

--*/

{

    PVOID Port;
    PTERMINATION_PORT TerminationPort;
    NTSTATUS st;
    PETHREAD Thread;

    PAGED_CODE();

    Thread = PsGetCurrentThread ();

    st = ObReferenceObjectByHandle (PortHandle,
                                    0,
                                    LpcPortObjectType,
                                    KeGetPreviousModeByThread(&Thread->Tcb),
                                    &Port,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    TerminationPort = ExAllocatePoolWithQuotaTag (PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                                  sizeof(TERMINATION_PORT),
                                                  'pTsP'|PROTECTED_POOL);
    if (TerminationPort == NULL) {
        ObDereferenceObject (Port);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    TerminationPort->Port = Port;
    TerminationPort->Next = Thread->TerminationPort;

    Thread->TerminationPort = TerminationPort;

    return STATUS_SUCCESS;
}

LARGE_INTEGER
PsGetProcessExitTime(
    VOID
    )

/*++

Routine Description:

    This routine returns the exit time for the current process.

Arguments:

    None.

Return Value:

    The function value is the exit time for the current process.

Note:

    This routine assumes that the caller wants an error log entry within the
    bounds of the maximum size.

--*/

{
    PAGED_CODE();

    //
    // Simply return the exit time for this process.
    //

    return PsGetCurrentProcess()->ExitTime;
}


#undef PsIsThreadTerminating

BOOLEAN
PsIsThreadTerminating(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine returns TRUE if the specified thread is in the process of
    terminating.

Arguments:

    Thread - Supplies a pointer to the thread to be checked for termination.

Return Value:

    TRUE is returned if the thread is terminating, else FALSE is returned.

--*/

{
    //
    // Simply return whether or not the thread is in the process of terminating.
    //

    if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_TERMINATED) {
        return TRUE;
    } else {
        return FALSE;
    }
}



NTSTATUS
PspFreezeProcessWorker (
    PEPROCESS Process,
    PVOID Context
    )
/*++

Routine Description:

    This function is the enumeration worker to suspend all processes.

Arguments:

    Process - Current process being enumerated
    Context - Unused context value

Return Value:

    NTSTATUS - Always returns true to continue enumeration

--*/
{

    UNREFERENCED_PARAMETER (Context);

    if (Process != PsInitialSystemProcess &&
        Process != PsIdleProcess &&
        Process != ExpDefaultErrorPortProcess) {

        if (Process->ExceptionPort != NULL) {
            LpcDisconnectPort (Process->ExceptionPort);
        }
        if ((Process->Flags&PS_PROCESS_FLAGS_PROCESS_EXITING) == 0) {
            PsSuspendProcess (Process);
        }
    }

    return STATUS_SUCCESS;
}

BOOLEAN PsContinueWaiting = FALSE;


LOGICAL
PsShutdownSystem (
    VOID
  )
/*++

Routine Description:

    This function shuts down ps, killing all non-system threads.

Arguments:

    None.

Return Value:

    Returns TRUE if all processes were terminated, FALSE if not.

--*/

{
    PEPROCESS     Process;
    PETHREAD      Thread;
    ULONG         NumProcs;
    ULONG         i;
    ULONG         MaxPasses;
    NTSTATUS      Status;
    LARGE_INTEGER Timeout = {(ULONG)(-10 * 1000 * 1000 * 100), -1};
    LOGICAL       Retval;

#define WAIT_BATCH THREAD_WAIT_OBJECTS
    PKPROCESS     WaitProcs[WAIT_BATCH];
    BOOLEAN       First;

    PAGED_CODE();

    Retval = TRUE;
    //
    // Some processes wait for other processes to die and then initiate actions.
    // Killing all processes without letting any execute any usermode code
    // prevents any unwanted initiated actions.
    //

    Thread = PsGetCurrentThread();

    if (InterlockedCompareExchangePointer(&PspShutdownThread,
                                          Thread,
                                          0) != 0) {
        // Some other thread is already in shutdown -- bail
        return FALSE;
    }

    PsEnumProcesses (PspFreezeProcessWorker, NULL);


    //
    // This loop kills all the processes and then waits for one of a subset
    // of them to die.  They must all be killed first (before any can be waited
    // on) so that any process like a debuggee that is waiting for a debugger
    // won't stall us.
    //
    // Driver unload won't occur until the last handle goes away for a device.
    //

    MaxPasses = 0;
    First = TRUE;
    do {
        NumProcs = 0;

        Status = STATUS_SUCCESS;
        for (Process = PsGetNextProcess (NULL);
             Process != NULL;
             Process = PsGetNextProcess (Process)) {

            if (Process != PsInitialSystemProcess &&
                Process != PsIdleProcess &&
                Process != ExpDefaultErrorPortProcess) {

                ASSERT (MmGetSessionId (Process) == 0);

                Status = PsTerminateProcess (Process,
                                             STATUS_SYSTEM_SHUTDOWN);

                //
                // If there is space save the referenced process away so
                // we can wait on it.  Don't wait on processes with no
                // threads as they will only exit when the last handle goes.
                //

                if ((Process->Flags&PS_PROCESS_FLAGS_PROCESS_EXITING) == 0 &&
                    Status != STATUS_NOTHING_TO_TERMINATE &&
                    NumProcs < WAIT_BATCH) {

                    ObReferenceObject (Process);
                    WaitProcs[NumProcs++] = &Process->Pcb;
                }
            }
        }
        First = FALSE;

        //
        // Wait for one of a small set of the processes to exit.
        //

        if (NumProcs != 0) {
            Status = KeWaitForMultipleObjects (NumProcs,
                                               WaitProcs,
                                               WaitAny,
                                               Executive,
                                               KernelMode,
                                               FALSE,
                                               &Timeout,
                                               NULL);

           for (i = 0; i < NumProcs; i++) {
               Process = CONTAINING_RECORD(WaitProcs[i],
                                           EPROCESS,
                                           Pcb);

               ObDereferenceObject (Process);
           }
        }

        //
        // Don't let an unkillable process stop shutdown from finishing.
        // ASSERT on checked builds so the faulty component causing this
        // can be debugged and fixed.
        //
        if (NumProcs > 0 && Status == STATUS_TIMEOUT) {
            MaxPasses += 1;
            if (MaxPasses > 10) {
                ASSERT (FALSE);
                if (!PsContinueWaiting) {
                    Retval = FALSE;
                    break;
                }
            }
        } else {
            MaxPasses = 0;
        }

    } while (NumProcs > 0);

    if (PoCleanShutdownEnabled()  && ExpDefaultErrorPortProcess) {
        // Explicitly kill csrss -- we don't want to do this in the loop,
        // because we don't want to wait on it, because it has system
        // threads which will exit later.  But we can terminate the user
        // threads, now that everything else has died (we can't terminate
        // them earlier, because DestroyWindowStation()/TerminateConsole()
        // depends on them being around).

        PsTerminateProcess(ExpDefaultErrorPortProcess,
                           STATUS_SYSTEM_SHUTDOWN);

        // Now, make sure that csrss's usermode threads have gotten a
        // chance to terminate.
        PspWaitForUsermodeExit(ExpDefaultErrorPortProcess);
    }

    // And we're done.

    PspShutdownJobLimits();
    MmUnmapViewOfSection(PsInitialSystemProcess, PspSystemDll.DllBase);
    ObDereferenceObject(PspSystemDll.Section);
    ZwClose(PspInitialSystemProcessHandle);
    PspInitialSystemProcessHandle = NULL;

    // Disconnect the system process's LSA security port
    if (PsInitialSystemProcess->SecurityPort) {
        if (PsInitialSystemProcess->SecurityPort != ((PVOID) 1 ))
        {
            ObDereferenceObject(PsInitialSystemProcess->SecurityPort);

            PsInitialSystemProcess->SecurityPort = (PVOID) 1 ;
        }

    }

    return Retval;
}

BOOLEAN
PsWaitForAllProcesses (
    VOID)
/*++

Routine Description:

    This function waits for all the processes to terminate.

Arguments:

    None.

Return Value:

    Returns TRUE if all processes were terminated, FALSE if not.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Timeout = {(ULONG)-(100 * 1000), -1};
    ULONG MaxPasses;
    BOOLEAN Wait;
    PEPROCESS Process;
    PEPROCESS WaitProcess=NULL;

    MaxPasses = 0;
    while (1) {
        Wait = FALSE;
        for (Process = PsGetNextProcess (NULL);
             Process != NULL;
             Process = PsGetNextProcess (Process)) {

            if (Process != PsInitialSystemProcess &&
                Process != PsIdleProcess &&
                (Process->Flags&PS_PROCESS_FLAGS_PROCESS_EXITING) != 0) {
                if (Process->ObjectTable != NULL) {
                    Wait = TRUE;
                    WaitProcess = Process;
                    ObReferenceObject (WaitProcess);
                    PsQuitNextProcess (WaitProcess);
                    break;
                }
            }
        }

        if (Wait) {
            Status = KeWaitForSingleObject (WaitProcess,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            &Timeout);

            ObDereferenceObject (WaitProcess);

            if (Status == STATUS_TIMEOUT) {
                MaxPasses += 1;
                Timeout.QuadPart *= 2;
                if (MaxPasses > 13) {
                    KdPrint (("PS: %d process left in the system after termination\n",
                             PsProcessType->TotalNumberOfObjects));
//                    ASSERT (PsProcessType->TotalNumberOfObjects == 0);
                    return FALSE;
                }
            }
        } else {
            return TRUE;
        }
    }

    return TRUE;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\psinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psinit.c

Abstract:

    Process Structure Initialization.

Author:

    Mark Lucovsky (markl) 20-Apr-1989

Revision History:

--*/

#include "psp.h"

extern ULONG PsMinimumWorkingSet;
extern ULONG PsMaximumWorkingSet;
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#pragma data_seg("PAGEDATA")
#endif
#define NTDLL_PATH_NAME L"\\SystemRoot\\System32\\ntdll.dll"
const UNICODE_STRING PsNtDllPathName = {
	sizeof(NTDLL_PATH_NAME) - sizeof(UNICODE_NULL),
	sizeof(NTDLL_PATH_NAME),
	NTDLL_PATH_NAME
};

ULONG PsPrioritySeperation; // nonpaged
BOOLEAN PspUseJobSchedulingClasses = FALSE;
PACCESS_TOKEN PspBootAccessToken = NULL;
HANDLE PspInitialSystemProcessHandle = NULL;
PHANDLE_TABLE PspCidTable; // nonpaged
SYSTEM_DLL PspSystemDll = {NULL};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#pragma data_seg("INITDATA")
#endif
ULONG PsRawPrioritySeparation = 0;
ULONG PsEmbeddedNTMask = 0;



NTSTATUS
MmCheckSystemImage(
    IN HANDLE ImageFileHandle,
    IN LOGICAL PurgeSection
    );

NTSTATUS
LookupEntryPoint (
    IN PVOID DllBase,
    IN PSZ NameOfEntryPoint,
    OUT PVOID *AddressOfEntryPoint
    );

const GENERIC_MAPPING PspProcessMapping = {
    STANDARD_RIGHTS_READ |
        PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
    STANDARD_RIGHTS_WRITE |
        PROCESS_CREATE_PROCESS | PROCESS_CREATE_THREAD |
        PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_DUP_HANDLE |
        PROCESS_TERMINATE | PROCESS_SET_QUOTA |
        PROCESS_SET_INFORMATION | PROCESS_SET_PORT,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    PROCESS_ALL_ACCESS
};

const GENERIC_MAPPING PspThreadMapping = {
    STANDARD_RIGHTS_READ |
        THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION,
    STANDARD_RIGHTS_WRITE |
        THREAD_TERMINATE | THREAD_SUSPEND_RESUME | THREAD_ALERT |
        THREAD_SET_INFORMATION | THREAD_SET_CONTEXT,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    THREAD_ALL_ACCESS
};

const GENERIC_MAPPING PspJobMapping = {
    STANDARD_RIGHTS_READ |
        JOB_OBJECT_QUERY,
    STANDARD_RIGHTS_WRITE |
        JOB_OBJECT_ASSIGN_PROCESS | JOB_OBJECT_SET_ATTRIBUTES | JOB_OBJECT_TERMINATE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    THREAD_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg("PAGECONST")
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,PsInitSystem)
#pragma alloc_text(INIT,PspInitPhase0)
#pragma alloc_text(INIT,PspInitPhase1)
#pragma alloc_text(INIT,PspInitializeSystemDll)
#pragma alloc_text(INIT,PspLookupSystemDllEntryPoint)
#pragma alloc_text(INIT,PspNameToOrdinal)
#pragma alloc_text(PAGE,PsLocateSystemDll)
#pragma alloc_text(PAGE,PsMapSystemDll)
#pragma alloc_text(PAGE,PsChangeQuantumTable)

#endif

//
// Process Structure Global Data
//

POBJECT_TYPE PsThreadType;
POBJECT_TYPE PsProcessType;
PEPROCESS PsInitialSystemProcess;
PVOID PsSystemDllDllBase;
ULONG PspDefaultPagedLimit;
ULONG PspDefaultNonPagedLimit;
ULONG PspDefaultPagefileLimit;
SCHAR PspForegroundQuantum[3];

EPROCESS_QUOTA_BLOCK PspDefaultQuotaBlock;
BOOLEAN PspDoingGiveBacks;
POBJECT_TYPE PsJobType;
KGUARDED_MUTEX PspJobListLock;
KSPIN_LOCK PspQuotaLock;
LIST_ENTRY PspJobList;

SINGLE_LIST_ENTRY PsReaperListHead;
WORK_QUEUE_ITEM PsReaperWorkItem;
PVOID PsSystemDllBase;
#define PSP_1MB (1024*1024)

//
// List head and mutex that links all processes that have been initialized
//

KGUARDED_MUTEX PspActiveProcessMutex;
LIST_ENTRY PsActiveProcessHead;
//extern PIMAGE_FILE_HEADER _header;
PEPROCESS PsIdleProcess;
PETHREAD PspShutdownThread;

BOOLEAN
PsInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function performs process structure initialization.
    It is called during phase 0 and phase 1 initialization. Its
    function is to dispatch to the appropriate phase initialization
    routine.

Arguments:

    Phase - Supplies the initialization phase number.

    LoaderBlock - Supplies a pointer to a loader parameter block.

Return Value:

    TRUE - Initialization succeeded.

    FALSE - Initialization failed.

--*/

{
    UNREFERENCED_PARAMETER (Phase);

    switch (InitializationPhase) {

    case 0 :
        return PspInitPhase0(LoaderBlock);
    case 1 :
        return PspInitPhase1(LoaderBlock);
    default:
        KeBugCheckEx(UNEXPECTED_INITIALIZATION_CALL, 1, InitializationPhase, 0, 0);
    }
//    return 0; // Not reachable, quiet compiler
}

BOOLEAN
PspInitPhase0 (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine performs phase 0 process structure initialization.
    During this phase, the initial system process, phase 1 initialization
    thread, and reaper threads are created. All object types and other
    process structures are created and initialized.

Arguments:

    None.

Return Value:

    TRUE - Initialization was successful.

    FALSE - Initialization Failed.

--*/

{

    UNICODE_STRING NameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    HANDLE ThreadHandle;
    PETHREAD Thread;
    MM_SYSTEMSIZE SystemSize;
    ULONG i;
#if DBG
    NTSTATUS Status;
#endif

    SystemSize = MmQuerySystemSize ();
    PspDefaultPagefileLimit = (ULONG)-1;

#ifdef _WIN64
    if (sizeof (TEB) > 8192 || sizeof (PEB) > 4096) {
#else
    if (sizeof (TEB) > 4096 || sizeof (PEB) > 4096) {
#endif
        KeBugCheckEx (PROCESS_INITIALIZATION_FAILED, 99, sizeof (TEB), sizeof (PEB), 99);
    }

    switch (SystemSize) {

        case MmMediumSystem :
            PsMinimumWorkingSet += 10;
            PsMaximumWorkingSet += 100;
            break;

        case MmLargeSystem :
            PsMinimumWorkingSet += 30;
            PsMaximumWorkingSet += 300;
            break;

        case MmSmallSystem :
        default:
            break;
    }

    //
    // Initialize all the callback structures
    //

    for (i = 0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i++) {
        ExInitializeCallBack (&PspCreateThreadNotifyRoutine[i]);
    }

    for (i = 0; i < PSP_MAX_CREATE_PROCESS_NOTIFY; i++) {
        ExInitializeCallBack (&PspCreateProcessNotifyRoutine[i]);
    }

    for (i = 0; i < PSP_MAX_LOAD_IMAGE_NOTIFY; i++) {
        ExInitializeCallBack (&PspLoadImageNotifyRoutine[i]);
    }


    PsChangeQuantumTable (FALSE, PsRawPrioritySeparation);

    //
    // Quotas grow as needed automatically
    //

    if (PspDefaultNonPagedLimit == 0 && PspDefaultPagedLimit == 0) {
        PspDoingGiveBacks = TRUE;
    } else {
        PspDoingGiveBacks = FALSE;
    }


    PspDefaultPagedLimit *= PSP_1MB;
    PspDefaultNonPagedLimit *= PSP_1MB;

    if (PspDefaultPagefileLimit != -1) {
        PspDefaultPagefileLimit *= PSP_1MB;
    }


    //
    // Initialize active process list head and mutex
    //

    InitializeListHead (&PsActiveProcessHead);

    PspInitializeProcessListLock ();

    //
    // Initialize the process security fields lock
    //


    PsIdleProcess = PsGetCurrentProcess();

    PspInitializeProcessLock (PsIdleProcess);
    ExInitializeRundownProtection (&PsIdleProcess->RundownProtect);
    InitializeListHead (&PsIdleProcess->ThreadListHead);


    PsIdleProcess->Pcb.KernelTime = 0;
    PsIdleProcess->Pcb.KernelTime = 0;

    //
    // Initialize the shutdown thread pointer
    //
    PspShutdownThread = NULL;

    //
    // Initialize the common fields of the Object Type Prototype record
    //

    RtlZeroMemory (&ObjectTypeInitializer, sizeof (ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof (ObjectTypeInitializer);
    ObjectTypeInitializer.SecurityRequired = TRUE;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.InvalidAttributes = OBJ_PERMANENT |
                                              OBJ_EXCLUSIVE |
                                              OBJ_OPENIF;


    //
    // Create Object types for Thread and Process Objects.
    //

    RtlInitUnicodeString (&NameString, L"Process");
    ObjectTypeInitializer.DefaultPagedPoolCharge = PSP_PROCESS_PAGED_CHARGE;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = PSP_PROCESS_NONPAGED_CHARGE;
    ObjectTypeInitializer.DeleteProcedure = PspProcessDelete;
    ObjectTypeInitializer.ValidAccessMask = PROCESS_ALL_ACCESS;
    ObjectTypeInitializer.GenericMapping = PspProcessMapping;

    if (!NT_SUCCESS (ObCreateObjectType (&NameString,
                                         &ObjectTypeInitializer,
                                         (PSECURITY_DESCRIPTOR) NULL,
                                         &PsProcessType))) {
        return FALSE;
    }

    RtlInitUnicodeString (&NameString, L"Thread");
    ObjectTypeInitializer.DefaultPagedPoolCharge = PSP_THREAD_PAGED_CHARGE;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = PSP_THREAD_NONPAGED_CHARGE;
    ObjectTypeInitializer.DeleteProcedure = PspThreadDelete;
    ObjectTypeInitializer.ValidAccessMask = THREAD_ALL_ACCESS;
    ObjectTypeInitializer.GenericMapping = PspThreadMapping;

    if (!NT_SUCCESS (ObCreateObjectType (&NameString,
                                         &ObjectTypeInitializer,
                                         (PSECURITY_DESCRIPTOR) NULL,
                                         &PsThreadType))) {
        return FALSE;
    }


    RtlInitUnicodeString (&NameString, L"Job");
    ObjectTypeInitializer.DefaultPagedPoolCharge = 0;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof (EJOB);
    ObjectTypeInitializer.DeleteProcedure = PspJobDelete;
    ObjectTypeInitializer.CloseProcedure = PspJobClose;
    ObjectTypeInitializer.ValidAccessMask = JOB_OBJECT_ALL_ACCESS;
    ObjectTypeInitializer.GenericMapping = PspJobMapping;
    ObjectTypeInitializer.InvalidAttributes = 0;

    if (!NT_SUCCESS (ObCreateObjectType (&NameString,
                                         &ObjectTypeInitializer,
                                         (PSECURITY_DESCRIPTOR) NULL,
                                         &PsJobType))) {
        return FALSE;
    }


    //
    // Initialize job list head and mutex
    //

    PspInitializeJobStructures ();
    
    InitializeListHead (&PspWorkingSetChangeHead.Links);

    PspInitializeWorkingSetChangeLock ();

    //
    // Initialize CID handle table.
    //
    // N.B. The CID handle table is removed from the handle table list so
    //      it will not be enumerated for object handle queries.
    //

    PspCidTable = ExCreateHandleTable (NULL);
    if (PspCidTable == NULL) {
        return FALSE;
    }

    //
    // Set PID and TID reuse to strict FIFO. This isn't absolutely needed but
    // it makes tracking audits easier.
    //
    ExSetHandleTableStrictFIFO (PspCidTable);

    ExRemoveHandleTable (PspCidTable);

#if defined(i386)

    //
    // Ldt Initialization
    //

    if ( !NT_SUCCESS (PspLdtInitialize ()) ) {
        return FALSE;
    }

    //
    // Vdm support Initialization
    //

    if (!NT_SUCCESS (PspVdmInitialize ())) {
        return FALSE;
    }

#endif

    //
    // Initialize Reaper Data Structures
    //

    PsReaperListHead.Next = NULL;

    ExInitializeWorkItem (&PsReaperWorkItem, PspReaper, NULL);

    //
    // Get a pointer to the system access token.
    // This token is used by the boot process, so we can take the pointer
    // from there.
    //

    PspBootAccessToken = ExFastRefGetObject (PsIdleProcess->Token);

    InitializeObjectAttributes (&ObjectAttributes,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!NT_SUCCESS (PspCreateProcess (&PspInitialSystemProcessHandle,
                                       PROCESS_ALL_ACCESS,
                                       &ObjectAttributes,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0))) {
        return FALSE;
    }

    if (!NT_SUCCESS (ObReferenceObjectByHandle (PspInitialSystemProcessHandle,
                                                0L,
                                                PsProcessType,
                                                KernelMode,
                                                &PsInitialSystemProcess,
                                                NULL))) {

        return FALSE;
    }

    strcpy((char *) &PsIdleProcess->ImageFileName[0], "Idle");
    strcpy((char *) &PsInitialSystemProcess->ImageFileName[0], "System");

    //
    // The system process can allocate resources, and its name may be queried by 
    // NtQueryInfomationProcess and various audits.  We must explicitly allocate memory 
    // for this field of the System EPROCESS, and initialize it appropriately.  In this 
    // case, appropriate initialization means zeroing the memory.
    //

    PsInitialSystemProcess->SeAuditProcessCreationInfo.ImageFileName =
        ExAllocatePoolWithTag (PagedPool, 
                               sizeof(OBJECT_NAME_INFORMATION), 
                               'aPeS');

    if (PsInitialSystemProcess->SeAuditProcessCreationInfo.ImageFileName != NULL) {
        RtlZeroMemory (PsInitialSystemProcess->SeAuditProcessCreationInfo.ImageFileName, 
                       sizeof (OBJECT_NAME_INFORMATION));
    } else {
        return FALSE;
    }

    //
    // Phase 1 System initialization
    //

    if (!NT_SUCCESS (PsCreateSystemThread (&ThreadHandle,
                                           THREAD_ALL_ACCESS,
                                           &ObjectAttributes,
                                           0L,
                                           NULL,
                                           Phase1Initialization,
                                           (PVOID)LoaderBlock))) {
        return FALSE;
    }


    if (!NT_SUCCESS (ObReferenceObjectByHandle (ThreadHandle,
                                                0L,
                                                PsThreadType,
                                                KernelMode,
                                                &Thread,
                                                NULL))) {
        return FALSE;
    }

    ZwClose (ThreadHandle);

//
// On checked systems install an image callout routine
//
#if DBG

    Status = PsSetLoadImageNotifyRoutine (PspImageNotifyTest);
    if (!NT_SUCCESS (Status)) {
        return FALSE;
    }

#endif

    return TRUE;
}

BOOLEAN
PspInitPhase1 (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine performs phase 1 process structure initialization.
    During this phase, the system DLL is located and relevant entry
    points are extracted.

Arguments:

    None.

Return Value:

    TRUE - Initialization was successful.

    FALSE - Initialization Failed.

--*/

{

    NTSTATUS st;

    UNREFERENCED_PARAMETER (LoaderBlock);

    PspInitializeJobStructuresPhase1 ();

    st = PspInitializeSystemDll ();

    if (!NT_SUCCESS (st)) {
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
PsLocateSystemDll (
    BOOLEAN ReplaceExisting
    )

/*++

Routine Description:

    This function locates the system dll and creates a section for the
    DLL and maps it into the system process.

Arguments:

    None.

Return Value:

    TRUE - Initialization was successful.

    FALSE - Initialization Failed.

--*/

{

    HANDLE File;
    HANDLE Section;
    NTSTATUS st;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    PVOID NtDllSection;

    //
    // First see if we need to load this DLL at all.
    //
    if (ExVerifySuite (EmbeddedNT) && (PsEmbeddedNTMask&PS_EMBEDDED_NO_USERMODE)) {
        return STATUS_SUCCESS;
    }

    if (!ReplaceExisting) {

        ExInitializePushLock(&PspSystemDll.DllLock);
    }

    //
    // Initialize the system DLL
    //

    InitializeObjectAttributes (&ObjectAttributes,
                                (PUNICODE_STRING) &PsNtDllPathName,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);

    st = ZwOpenFile (&File,
                     SYNCHRONIZE | FILE_EXECUTE,
                     &ObjectAttributes,
                     &IoStatus,
                     FILE_SHARE_READ,
                     0);

    if (!NT_SUCCESS (st)) {

#if DBG
        DbgPrint("PS: PsLocateSystemDll - NtOpenFile( NTDLL.DLL ) failed.  Status == %lx\n",
                 st);
#endif
        if (ReplaceExisting) {
            return st;
        }

        KeBugCheckEx (PROCESS1_INITIALIZATION_FAILED, st, 2, 0, 0);
    }

    st = MmCheckSystemImage (File, TRUE);

    if (st == STATUS_IMAGE_CHECKSUM_MISMATCH ||
        st == STATUS_INVALID_IMAGE_PROTECT) {

        ULONG_PTR ErrorParameters;
        ULONG ErrorResponse;

        //
        // Hard error time. A driver is corrupt.
        //

        ErrorParameters = (ULONG_PTR)&PsNtDllPathName;

        NtRaiseHardError (st,
                          1,
                          1,
                          &ErrorParameters,
                          OptionOk,
                          &ErrorResponse);
        return st;
    }

    st = ZwCreateSection (&Section,
                          SECTION_ALL_ACCESS,
                          NULL,
                          0,
                          PAGE_EXECUTE,
                          SEC_IMAGE,
                          File);
    ZwClose (File);

    if (!NT_SUCCESS (st)) {
#if DBG
        DbgPrint("PS: PsLocateSystemDll: NtCreateSection Status == %lx\n",st);
#endif
        if (ReplaceExisting) {
            return st;
        }
        KeBugCheckEx (PROCESS1_INITIALIZATION_FAILED, st, 3, 0, 0);
//        return st;
    }

    //
    // Now that we have the section, reference it, store its address in the
    // PspSystemDll and then close handle to the section.
    //

    st = ObReferenceObjectByHandle (Section,
                                    SECTION_ALL_ACCESS,
                                    MmSectionObjectType,
                                    KernelMode,
                                    &NtDllSection,
                                    NULL);

    ZwClose (Section);

    if (!NT_SUCCESS (st)) {
        
        if (ReplaceExisting) {
            return st;
        }
        KeBugCheckEx(PROCESS1_INITIALIZATION_FAILED,st,4,0,0);
//        return st;
    }

    if (ReplaceExisting) {

        PVOID ExistingSection;

        KeEnterCriticalRegion();
        ExAcquirePushLockExclusive(&PspSystemDll.DllLock);

        ExistingSection = PspSystemDll.Section;

        PspSystemDll.Section = NtDllSection;

        ExReleasePushLockExclusive(&PspSystemDll.DllLock);
        KeLeaveCriticalRegion();

        if (ExistingSection) {
            
            ObDereferenceObject(ExistingSection);
        }

    } else {
        
        PspSystemDll.Section = NtDllSection;

        //
        // Map the system dll into the user part of the address space
        //

        st = PsMapSystemDll (PsGetCurrentProcess (), &PspSystemDll.DllBase);
        PsSystemDllDllBase = PspSystemDll.DllBase;

        if (!NT_SUCCESS (st)) {
            KeBugCheckEx (PROCESS1_INITIALIZATION_FAILED, st, 5, 0, 0);
    //        return st;
        }
        PsSystemDllBase = PspSystemDll.DllBase;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PsMapSystemDll (
    IN PEPROCESS Process,
    OUT PVOID *DllBase OPTIONAL
    )

/*++

Routine Description:

    This function maps the system DLL into the specified process.

Arguments:

    Process - Supplies the address of the process to map the DLL into.

Return Value:

    TBD

--*/

{
    NTSTATUS st;
    PVOID ViewBase;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    PVOID CapturedSection;

    PAGED_CODE();

    ViewBase = NULL;
    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    
    KeEnterCriticalRegion();
    ExAcquirePushLockShared(&PspSystemDll.DllLock);

    CapturedSection = PspSystemDll.Section;
    ObReferenceObject(CapturedSection);
    
    ExReleasePushLockShared(&PspSystemDll.DllLock);
    KeLeaveCriticalRegion();

    //
    // Map the system dll into the user part of the address space
    //

    st = MmMapViewOfSection(
            CapturedSection,
            Process,
            &ViewBase,
            0L,
            0L,
            &SectionOffset,
            &ViewSize,
            ViewShare,
            0L,
            PAGE_READWRITE
            );
    
    ObDereferenceObject(CapturedSection);

    if (st != STATUS_SUCCESS) {
#if DBG
        DbgPrint("PS: Unable to map system dll at based address.\n");
#endif
        st = STATUS_CONFLICTING_ADDRESSES;
    }

    if (ARGUMENT_PRESENT (DllBase)) {
        *DllBase = ViewBase;
    }

    return st;
}

NTSTATUS
PspInitializeSystemDll (
    VOID
    )

/*++

Routine Description:

    This function initializes the system DLL and locates
    various entrypoints within the DLL.

Arguments:

    None.

Return Value:

    TBD

--*/

{
    NTSTATUS st;
    PSZ dll_entrypoint;

    //
    // If we skipped dll load becuase we are kernel only then exit now.
    //
    if (PsSystemDllDllBase == NULL) {
        return STATUS_SUCCESS;
    }
    //
    // Locate the important system dll entrypoints
    //

    dll_entrypoint = "LdrInitializeThunk";

    st = PspLookupSystemDllEntryPoint (dll_entrypoint,
                                       (PVOID) &PspSystemDll.LoaderInitRoutine);

    if (!NT_SUCCESS (st)) {
#if DBG
        DbgPrint("PS: Unable to locate LdrInitializeThunk in system dll\n");
#endif
        KeBugCheckEx (PROCESS1_INITIALIZATION_FAILED, st, 6, 0, 0);
    }


    st = PspLookupKernelUserEntryPoints ();

    if ( !NT_SUCCESS (st)) {
        KeBugCheckEx(PROCESS1_INITIALIZATION_FAILED,st,8,0,0);
     }

    KdUpdateDataBlock ();

    return st;
}

NTSTATUS
PspLookupSystemDllEntryPoint (
    IN PSZ NameOfEntryPoint,
    OUT PVOID *AddressOfEntryPoint
    )

{
    return LookupEntryPoint (PspSystemDll.DllBase,
                             NameOfEntryPoint,
                             AddressOfEntryPoint);
}

const SCHAR PspFixedQuantums[6] = {3*THREAD_QUANTUM,
                                   3*THREAD_QUANTUM,
                                   3*THREAD_QUANTUM,
                                   6*THREAD_QUANTUM,
                                   6*THREAD_QUANTUM,
                                   6*THREAD_QUANTUM};

const SCHAR PspVariableQuantums[6] = {1*THREAD_QUANTUM,
                                      2*THREAD_QUANTUM,
                                      3*THREAD_QUANTUM,
                                      2*THREAD_QUANTUM,
                                      4*THREAD_QUANTUM,
                                      6*THREAD_QUANTUM};

//
// The table is ONLY used when fixed quantums are selected.
//

const SCHAR PspJobSchedulingClasses[PSP_NUMBER_OF_SCHEDULING_CLASSES] = {1*THREAD_QUANTUM,   // long fixed 0
                                                                         2*THREAD_QUANTUM,   // long fixed 1...
                                                                         3*THREAD_QUANTUM,
                                                                         4*THREAD_QUANTUM,
                                                                         5*THREAD_QUANTUM,
                                                                         6*THREAD_QUANTUM,   // DEFAULT
                                                                         7*THREAD_QUANTUM,
                                                                         8*THREAD_QUANTUM,
                                                                         9*THREAD_QUANTUM,
                                                                         10*THREAD_QUANTUM};   // long fixed 9

VOID
PsChangeQuantumTable (
    BOOLEAN ModifyActiveProcesses,
    ULONG PrioritySeparation
    )
{

    PEPROCESS Process;
    PETHREAD CurrentThread;
    PLIST_ENTRY NextProcess;
    ULONG QuantumIndex;
    SCHAR const* QuantumTableBase;
    PEJOB Job;

    //
    // extract priority seperation value
    //
    switch (PrioritySeparation & PROCESS_PRIORITY_SEPARATION_MASK) {
        case 3:
            PsPrioritySeperation = PROCESS_PRIORITY_SEPARATION_MAX;
            break;
        default:
            PsPrioritySeperation = PrioritySeparation & PROCESS_PRIORITY_SEPARATION_MASK;
            break;
        }

    //
    // determine if we are using fixed or variable quantums
    //
    switch (PrioritySeparation & PROCESS_QUANTUM_VARIABLE_MASK) {
        case PROCESS_QUANTUM_VARIABLE_VALUE:
            QuantumTableBase = PspVariableQuantums;
            break;

        case PROCESS_QUANTUM_FIXED_VALUE:
            QuantumTableBase = PspFixedQuantums;
            break;

        case PROCESS_QUANTUM_VARIABLE_DEF:
        default:
            if (MmIsThisAnNtAsSystem ()) {
                QuantumTableBase = PspFixedQuantums;
            } else {
                QuantumTableBase = PspVariableQuantums;
            }
            break;
    }

    //
    // determine if we are using long or short
    //
    switch (PrioritySeparation & PROCESS_QUANTUM_LONG_MASK) {
        case PROCESS_QUANTUM_LONG_VALUE:
            QuantumTableBase = QuantumTableBase + 3;
            break;

        case PROCESS_QUANTUM_SHORT_VALUE:
            break;

        case PROCESS_QUANTUM_LONG_DEF:
        default:
            if (MmIsThisAnNtAsSystem ()) {
                QuantumTableBase = QuantumTableBase + 3;
            }
            break;
    }

    //
    // Job Scheduling classes are ONLY meaningful if long fixed quantums
    // are selected. In practice, this means stock NTS configurations
    //
    if (QuantumTableBase == &PspFixedQuantums[3]) {
        PspUseJobSchedulingClasses = TRUE;
    } else {
        PspUseJobSchedulingClasses = FALSE;
    }

    RtlCopyMemory (PspForegroundQuantum, QuantumTableBase, sizeof(PspForegroundQuantum));

    if (ModifyActiveProcesses) {

        CurrentThread = PsGetCurrentThread ();

        PspLockProcessList (CurrentThread);

        NextProcess = PsActiveProcessHead.Flink;

        while (NextProcess != &PsActiveProcessHead) {
            Process = CONTAINING_RECORD(NextProcess,
                                        EPROCESS,
                                        ActiveProcessLinks);

            if (Process->Vm.Flags.MemoryPriority == MEMORY_PRIORITY_BACKGROUND) {
                QuantumIndex = 0;
            } else {
                QuantumIndex = PsPrioritySeperation;
            }

            if (Process->PriorityClass != PROCESS_PRIORITY_CLASS_IDLE) {

                //
                // If the process is contained within a JOB, AND we are
                // running Fixed, Long Quantums, use the quantum associated
                // with the Job's scheduling class
                //
                Job = Process->Job;
                if (Job != NULL && PspUseJobSchedulingClasses) {
                    Process->Pcb.ThreadQuantum = PspJobSchedulingClasses[Job->SchedulingClass];
                } else {
                    Process->Pcb.ThreadQuantum = PspForegroundQuantum[QuantumIndex];
                }
            } else {
                Process->Pcb.ThreadQuantum = THREAD_QUANTUM;
            }
            NextProcess = NextProcess->Flink;
        }
        PspUnlockProcessList (CurrentThread);
    }
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=ps

TARGETNAME=ps
TARGETTYPE=LIBRARY
TARGETPATH=obj

BUILD_PRODUCES=ntosps$(NT_UP)

MSC_WARNING_LEVEL=/W4 /WX

INCLUDES=..;..\..\inc;..\..\ke;$(SDKTOOLS_INC_PATH)

SOURCES=..\psspnd.c   \
        ..\pscid.c    \
        ..\psimpers.c \
        ..\psinit.c   \
        ..\psdelete.c \
        ..\psquery.c  \
        ..\create.c   \
        ..\kulookup.c \
        ..\psquota.c  \
        ..\psctx.c    \
        ..\psopen.c   \
        ..\psjob.c    \
        ..\security.c \
        ..\pshelper.c \
        ..\psenum.c

PRECOMPILED_INCLUDE=..\psp.h
PRECOMPILED_PCH=psp.pch
PRECOMPILED_OBJ=psp.obj

UMTYPE=nt

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\psquota.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psquota.c

Abstract:

    This module implements the quota mechanism for NT

Author:

    Mark Lucovsky (markl) 18-Sep-1989

Revision History:

    Neill Clift (NeillC) 4-Nov-2000

    Changed to be mostly lock free. Preserved the basic design in terms of how quota is managed.

--*/

#include "psp.h"

LIST_ENTRY PspQuotaBlockList; // List of all quota blocks except the default

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, PsInitializeQuotaSystem)
#pragma alloc_text (PAGE, PspInheritQuota)
#pragma alloc_text (PAGE, PspDereferenceQuota)
#pragma alloc_text (PAGE, PsChargeSharedPoolQuota)
#pragma alloc_text (PAGE, PsReturnSharedPoolQuota)
#endif


VOID
PsInitializeQuotaSystem (
    VOID
    )
/*++

Routine Description:

    This function initializes the quota system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KeInitializeSpinLock(&PspQuotaLock);

    PspDefaultQuotaBlock.ReferenceCount = 1;
    PspDefaultQuotaBlock.ProcessCount = 1;
    PspDefaultQuotaBlock.QuotaEntry[PsPagedPool].Limit    = (SIZE_T)-1;
    PspDefaultQuotaBlock.QuotaEntry[PsNonPagedPool].Limit = (SIZE_T)-1;
    PspDefaultQuotaBlock.QuotaEntry[PsPageFile].Limit     = (SIZE_T)-1;

    PsGetCurrentProcess()->QuotaBlock = &PspDefaultQuotaBlock;

    InitializeListHead (&PspQuotaBlockList);
}

VOID
PspInsertQuotaBlock (
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock
    )
/*++

Routine Description:

    This routines as a new quota block to the global list of system quota blocks.

Arguments:

    QuotaBlock - Quota block to be inserted into the list.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    ExAcquireSpinLock (&PspQuotaLock, &OldIrql);
    InsertTailList (&PspQuotaBlockList, &QuotaBlock->QuotaList);
    ExReleaseSpinLock (&PspQuotaLock, OldIrql);
}

VOID
PspDereferenceQuotaBlock (
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock
    )
/*++

Routine Description:

    This removes a single reference from a quota block and deletes the block if it was the last.

Arguments:

    QuotaBlock - Quota block to dereference

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    SIZE_T ReturnQuota;
    PS_QUOTA_TYPE QuotaType;

    if (InterlockedDecrement ((PLONG) &QuotaBlock->ReferenceCount) == 0) {

        ExAcquireSpinLock (&PspQuotaLock, &OldIrql);

        RemoveEntryList (&QuotaBlock->QuotaList);

        //
        // Free any unreturned quota;
        //
        for (QuotaType = PsNonPagedPool;
             QuotaType <= PsPagedPool;
             QuotaType++) {
            ReturnQuota = QuotaBlock->QuotaEntry[QuotaType].Return + QuotaBlock->QuotaEntry[QuotaType].Limit;
            if (ReturnQuota > 0) {
                MmReturnPoolQuota (QuotaType, ReturnQuota);
            }
        }

        ExReleaseSpinLock (&PspQuotaLock, OldIrql);

        ExFreePool (QuotaBlock);
    }
}

SIZE_T
FORCEINLINE
PspInterlockedExchangeQuota (
    IN PSIZE_T pQuota,
    IN SIZE_T NewQuota)
/*++

Routine Description:

    This function does an interlocked exchange on a quota variable.

Arguments:

    pQuota   - Pointer to a quota entry to exchange into

    NewQuota - The new value to exchange into the quota location.

Return Value:

    SIZE_T - Old value that was contained in the quota variable

--*/
{
#if !defined(_WIN64)
    return InterlockedExchange ((PLONG) pQuota, NewQuota);
#else
    return InterlockedExchange64 ((PLONGLONG) pQuota, NewQuota);
#endif    
}

SIZE_T
FORCEINLINE
PspInterlockedCompareExchangeQuota (
    IN PSIZE_T pQuota,
    IN SIZE_T NewQuota,
    IN SIZE_T OldQuota
   )
/*++

Routine Description:

    This function performs a compare exchange operation on a quota variable

Arguments:

    pQuota - Pointer to the quota variable being changed
    NewQuota - New value to place in the quota variable
    OldQuota - The current contents of the quota variable

Return Value:

    SIZE_T - The old contents of the variable

--*/
{
#if !defined(_WIN64)
    return InterlockedCompareExchange ((PLONG) pQuota, NewQuota, OldQuota);
#else
    return InterlockedCompareExchange64 ((PLONGLONG)pQuota, NewQuota, OldQuota);
#endif
}

SIZE_T
PspReleaseReturnedQuota (
    IN PS_QUOTA_TYPE QuotaType
    )
/*++

Routine Description:

    This function walks the list of system quota blocks and returns any non-returned quota.
    This function is called when we are about to fail a quota charge and we want to try and
    free some resources up.

Arguments:

    QuotaType - Type of quota to scan for.

Return Value:

    SIZE_T - Amount of that quota returned to the system.

--*/
{
    SIZE_T ReturnQuota, Usage, Limit;
    PLIST_ENTRY ListEntry;
    PEPROCESS_QUOTA_BLOCK QuotaBlock;

    ReturnQuota = 0;
    ListEntry = PspQuotaBlockList.Flink;
    while (1) {
        if (ListEntry == &PspQuotaBlockList) {
            break;
        }
        QuotaBlock = CONTAINING_RECORD (ListEntry, EPROCESS_QUOTA_BLOCK, QuotaList);
        //
        // Gather up any unreturned quota;
        //
        ReturnQuota += PspInterlockedExchangeQuota (&QuotaBlock->QuotaEntry[QuotaType].Return, 0);
        //
        // If no more processes are assocociated with this block then trim its limit back. This
        // block can only have quota returned at this point.
        //
        if (QuotaBlock->ProcessCount == 0) {
            Usage = QuotaBlock->QuotaEntry[QuotaType].Usage;
            Limit = QuotaBlock->QuotaEntry[QuotaType].Limit;
            if (Limit > Usage) {
                if (PspInterlockedCompareExchangeQuota (&QuotaBlock->QuotaEntry[QuotaType].Limit,
                                                        Usage,
                                                        Limit) == Limit) {
                    ReturnQuota += Limit - Usage;
                }
            }
        }

        ListEntry = ListEntry->Flink;
        
    }
    if (ReturnQuota > 0) {
        MmReturnPoolQuota (QuotaType, ReturnQuota);
    }

    return ReturnQuota;
}



//
// Interfaces return different status values for differen quotas. These are the values.
//
const static NTSTATUS PspQuotaStatus[PsQuotaTypes] = {STATUS_QUOTA_EXCEEDED,
                                                      STATUS_QUOTA_EXCEEDED,
                                                      STATUS_PAGEFILE_QUOTA_EXCEEDED};

VOID
FORCEINLINE
PspInterlockedMaxQuota (
    IN PSIZE_T pQuota,
    IN SIZE_T NewQuota
    )
/*++

Routine Description:

    This function makes sure that the target contains a value that >= to the new quota value.
    This is used to maintain peak values.

Arguments:

    pQuota - Pointer to a quota variable
    NewQuota - New value to be used in the maximum comparison.

Return Value:

    None.

--*/
{
    SIZE_T Quota;

    Quota = *pQuota;
    while (1) {
        if (NewQuota <= Quota) {
            break;
        }
        //
        // This looks strange because we don't care if the exchanged suceeded. We only
        // care that the quota is greater than our new quota.
        //
        Quota = PspInterlockedCompareExchangeQuota (pQuota,
                                                    NewQuota,
                                                    Quota);
    }
}

SIZE_T
FORCEINLINE
PspInterlockedAddQuota (
    IN PSIZE_T pQuota,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function adds the specified amount on to the target quota

Arguments:

    pQuota - Pointer to a quota variable to be modified
    Amount - Amount to be added to the quota

Return Value:

    SIZE_T - New value of quota variable after the addition was performed

--*/
{
#if !defined(_WIN64)
    return InterlockedExchangeAdd ((PLONG) pQuota, Amount) + Amount;
#else
    return InterlockedExchangeAdd64 ((PLONGLONG) pQuota, Amount) + Amount;
#endif
}

SIZE_T
FORCEINLINE
PspInterlockedSubtractQuota (
    IN PSIZE_T pUsage,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function subtracts the specified amount on to the target quota

Arguments:

    pQuota - Pointer to a quota variable to be modified
    Amount - Amount to be subtracted from the quota

Return Value:

    SIZE_T - New value of quota variable after the subtraction was performed

--*/
{
#if !defined(_WIN64)
    return InterlockedExchangeAdd ((PLONG) pUsage, -(LONG)Amount) - Amount;
#else
    return InterlockedExchangeAdd64 ((PLONGLONG) pUsage, -(LONGLONG)Amount) - Amount;
#endif
}


BOOLEAN
PspExpandQuota (
    IN PS_QUOTA_TYPE QuotaType,
    IN PEPROCESS_QUOTA_ENTRY QE,
    IN SIZE_T Usage,
    IN SIZE_T Amount,
    OUT SIZE_T *pLimit
    )
/*++

Routine Description:

    This function charges the specified quota to a process quota block

Arguments:

    QuotaType  - The quota being charged. One of PsNonPagedPool, PsPagedPool or PsPageFile.
    QE         - Quota entry being modified
    Usage      - The current quota usage
    Amount     - The amount of quota being charged.
    pLimit     - The new limit

Return Value:

    BOOLEAN - TRUE if quota expansion suceeded.

--*/
{
    SIZE_T Limit, NewLimit;
    KIRQL OldIrql;

    //
    // We need to attempt quota expansion for this request.
    // Acquire the global lock and see if somebody else changed the limit.
    // We don't want to do too many expansions. If somebody else did it
    // then we want to use theirs if possible.
    //
    ExAcquireSpinLock (&PspQuotaLock, &OldIrql);

    //
    // Refetch limit information. Another thread may have done limit expansion/contraction.
    // By refetching limit we preserve the order we established above.
    //
    Limit = QE->Limit;

    //
    // If the request could be satisfied now then repeat.
    //
    if (Usage + Amount <= Limit) {
        ExReleaseSpinLock (&PspQuotaLock, OldIrql);
        *pLimit = Limit;
        return TRUE;
    }
    //
    // If expansion is currently enabled then attempt it.
    // If this fails then scavenge any returns from all the
    // quota blocks in the system and try again.
    //
    if (((QuotaType == PsNonPagedPool)?PspDefaultNonPagedLimit:PspDefaultPagedLimit) == 0) {
       if (MmRaisePoolQuota (QuotaType, Limit, &NewLimit) ||
            (PspReleaseReturnedQuota (QuotaType) > 0 &&
             MmRaisePoolQuota (QuotaType, Limit, &NewLimit))) {
            //
            // We refetch limit here but that doesn't violate the ordering
            //
            Limit = PspInterlockedAddQuota (&QE->Limit, NewLimit - Limit);
            ExReleaseSpinLock (&PspQuotaLock, OldIrql);
            *pLimit = Limit;
            return TRUE;
        }
    }

    ExReleaseSpinLock (&PspQuotaLock, OldIrql);

    *pLimit = Limit;

    return FALSE;
}

NTSTATUS
FORCEINLINE
PspChargeQuota (
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock,
    IN PEPROCESS Process,
    IN PS_QUOTA_TYPE QuotaType,
    IN SIZE_T Amount)
/*++

Routine Description:

    This function charges the specified quota to a process quota block

Arguments:

    QuotaBlock - Quota block to make charges to.
    Process    - Process that is being charged.
    QuotaType  - The quota being charged. One of PsNonPagedPool, PsPagedPool or PsPageFile.
    Amount     - The amount of quota being charged.

Return Value:

    NTSTATUS - Status of the operation

--*/
{
    PEPROCESS_QUOTA_ENTRY QE;
    SIZE_T Usage, Limit, NewUsage, tUsage, Extra;

    QE = &QuotaBlock->QuotaEntry[QuotaType];

    //
    // This memory barrier is important. In order not to have to recheck the limit after
    // we charge the quota we only ever reduce the limit by the same amount we are about
    // to reduce the usage by. Using an out of data limit will only allow us to over charge
    // by an amount another thread is just about to release.
    //
    Usage = QE->Usage;

    KeMemoryBarrier ();

    Limit = QE->Limit;
    while (1) {
        NewUsage = Usage + Amount;
        //
        // Wrapping cases are always rejected
        //
        if (NewUsage < Usage) {
            return PspQuotaStatus [QuotaType];
        }
        //
        // If its within the limits then try and grab the quota
        //
        if (NewUsage <= Limit) {
            tUsage = PspInterlockedCompareExchangeQuota (&QE->Usage,
                                                         NewUsage,
                                                         Usage);
            if (tUsage == Usage) {
                //
                // Update the Peak value
                //
                PspInterlockedMaxQuota (&QE->Peak, NewUsage);
                //
                // Update the process counts if needed
                //
                if (Process != NULL) {
                    NewUsage = PspInterlockedAddQuota (&Process->QuotaUsage[QuotaType], Amount);
                    //
                    // Update the peak value
                    //
                    PspInterlockedMaxQuota (&Process->QuotaPeak[QuotaType], NewUsage);
                }
                return STATUS_SUCCESS;
            }
            //
            // The usage has changed under us. We have a new usage from the exchange
            // but must refetch the limit to preserve the ordering we established
            // above this loop. We don't need a memory barrier as we obtained
            // the new value via an interlocked operation and they contain barriers.
            //
            Usage = tUsage;

            KeMemoryBarrier ();

            Limit = QE->Limit;
            continue;
        }

        //
        // Page file quota is not increased
        //
        if (QuotaType == PsPageFile) {
            return PspQuotaStatus [QuotaType];
        } else {
            //
            // First try and grab any returns that this process has made.
            //
            Extra = PspInterlockedExchangeQuota (&QE->Return, 0);
            if (Extra > 0) {
                //
                // We had some returns so add this to the limit. We can retry the
                // acquire with the new limit. We refetch the limit here but that
                // doesn't violate the state we set up at the top of the loop.
                // The state is that we read the Usage before we read the limit.
                //
                Limit = PspInterlockedAddQuota (&QE->Limit, Extra);
                continue;
            }
            //
            // Try to expand quota if we can
            //
            if (PspExpandQuota (QuotaType, QE, Usage, Amount, &Limit)) {
                //
                // We refetched limit here but that doesn't violate the ordering
                //
                continue;
            }

            return PspQuotaStatus [QuotaType];
        }
    }
}

VOID
PspGivebackQuota (
    IN PS_QUOTA_TYPE QuotaType,
    IN PEPROCESS_QUOTA_ENTRY QE
    )
/*++

Routine Description:

    This function returns excess freed quota to MM

Arguments:

    QuotaType  - The quota being returned. One of PsNonPagedPool, PsPagedPool or PsPageFile.
    QE -  Quote entry to return to

Return Value:

    None.

--*/
{
    SIZE_T GiveBack;
    KIRQL OldIrql;

    //
    // Acquire a global spinlock so we only have one thread giving back to the system
    //
    ExAcquireSpinLock (&PspQuotaLock, &OldIrql);
    GiveBack = PspInterlockedExchangeQuota (&QE->Return, 0);
    if (GiveBack > 0) {
        MmReturnPoolQuota (QuotaType, GiveBack);
    }
    ExReleaseSpinLock (&PspQuotaLock, OldIrql);
}

VOID
FORCEINLINE
PspReturnQuota (
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock,
    IN PEPROCESS Process,
    IN PS_QUOTA_TYPE QuotaType,
    IN SIZE_T Amount)
/*++

Routine Description:

    This function returns previously charged quota to the quota block

Arguments:

    QuotaBlock - Quota block to return charges to.
    Process    - Process that was originaly charged.
    QuotaType  - The quota being returned. One of PsNonPagedPool, PsPagedPool or PsPageFile.
    Amount     - The amount of quota being returned.

Return Value:

    None.

--*/
{
    PEPROCESS_QUOTA_ENTRY QE;
    SIZE_T Usage, NewUsage, tUsage, tAmount, rAmount, Limit, NewLimit, tLimit;
    SIZE_T GiveBackLimit, GiveBack;

    QE = &QuotaBlock->QuotaEntry[QuotaType];

    Usage = QE->Usage;
    Limit = QE->Limit;
    //
    // We need to give back quota here if we have lots to return.
    //
#define PSMINGIVEBACK ((MMPAGED_QUOTA_INCREASE > MMNONPAGED_QUOTA_INCREASE)?MMNONPAGED_QUOTA_INCREASE:MMPAGED_QUOTA_INCREASE)
    if (Limit - Usage >  PSMINGIVEBACK && Limit > Usage) {
        if (QuotaType != PsPageFile  && QuotaBlock != &PspDefaultQuotaBlock && PspDoingGiveBacks) {
            if (QuotaType == PsPagedPool) {
                GiveBackLimit = MMPAGED_QUOTA_INCREASE;
            } else {
                GiveBackLimit = MMNONPAGED_QUOTA_INCREASE;
            }
            if (GiveBackLimit > Amount) {
                GiveBack = Amount;
            } else {
                GiveBack = GiveBackLimit;
            }
            NewLimit = Limit - GiveBack;
            tLimit = PspInterlockedCompareExchangeQuota (&QE->Limit,
                                                         NewLimit,
                                                         Limit);
            
            if (tLimit == Limit) {
                //
                // We suceeded in shrinking the limit. Add this reduction to the return field.
                // If returns exceed a threshhold then give the lot bacxk to MM.
                //
                GiveBack = PspInterlockedAddQuota (&QE->Return, GiveBack);
                if (GiveBack > GiveBackLimit) {
                    PspGivebackQuota (QuotaType, QE);
                }
            }
        }
    }

    //
    // Now return the quota to the usage field.
    // The charge might have been split across the default quota block and
    // a new quota block. We have to handle this case here by first returning
    // quota to the specified quota block then skipping to the default.
    //
    rAmount = Amount;
    while (1) {
        if (rAmount > Usage) {
            tAmount = Usage;
            NewUsage = 0;
        } else {
            tAmount = rAmount;
            NewUsage = Usage - rAmount;
        }

        tUsage = PspInterlockedCompareExchangeQuota (&QE->Usage,
                                                     NewUsage,
                                                     Usage);
        if (tUsage == Usage) {
            //
            // Update the process counts if needed
            //
            if (Process != NULL) {
                ASSERT (tAmount <= Process->QuotaUsage[QuotaType]);
                NewUsage = PspInterlockedSubtractQuota (&Process->QuotaUsage[QuotaType], tAmount);
            }
            rAmount = rAmount - tAmount;
            if (rAmount == 0) {
                return;
            }
            ASSERT (QuotaBlock != &PspDefaultQuotaBlock);
            if (QuotaBlock == &PspDefaultQuotaBlock) {
                return;
            }
            QuotaBlock = &PspDefaultQuotaBlock;
            QE = &QuotaBlock->QuotaEntry[QuotaType];
            Usage = QE->Usage;
        } else {
            Usage = tUsage;
        }

    }
}

PEPROCESS_QUOTA_BLOCK
PsChargeSharedPoolQuota(
    IN PEPROCESS Process,
    IN SIZE_T PagedAmount,
    IN SIZE_T NonPagedAmount
    )

/*++

Routine Description:

    This function charges shared pool quota of the specified pool type
    to the specified process's pooled quota block.  If the quota charge
    would exceed the limits allowed to the process, then an exception is
    raised and quota is not charged.

Arguments:

    Process - Supplies the process to charge quota to.

    PagedAmount - Supplies the amount of paged pool quota to charge.

    PagedAmount - Supplies the amount of non paged pool quota to charge.

Return Value:

    NULL - Quota was exceeded

    NON-NULL - A referenced pointer to the quota block that was charged

--*/

{
    PEPROCESS_QUOTA_BLOCK QuotaBlock;
    NTSTATUS Status;

    ASSERT((Process->Pcb.Header.Type == ProcessObject) || (Process->Pcb.Header.Type == 0));

    if (Process == PsInitialSystemProcess) {
        return (PEPROCESS_QUOTA_BLOCK) 1;
    }

    QuotaBlock = Process->QuotaBlock;

    if (PagedAmount > 0) {
        Status = PspChargeQuota (QuotaBlock, NULL, PsPagedPool, PagedAmount);
        if (!NT_SUCCESS (Status)) {
            return NULL;
        }
    }
    if (NonPagedAmount > 0) {
        Status = PspChargeQuota (QuotaBlock, NULL, PsNonPagedPool, NonPagedAmount);
        if (!NT_SUCCESS (Status)) {
            if (PagedAmount > 0) {
                PspReturnQuota (QuotaBlock, NULL, PsPagedPool, PagedAmount);
            }
            return NULL;
        }
    }

    InterlockedIncrement ((PLONG) &QuotaBlock->ReferenceCount);
    return QuotaBlock;
}


VOID
PsReturnSharedPoolQuota(
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock,
    IN SIZE_T PagedAmount,
    IN SIZE_T NonPagedAmount
    )

/*++

Routine Description:

    This function returns pool quota of the specified pool type to the
    specified process.

Arguments:

    QuotaBlock - Supplies the quota block to return quota to.

    PagedAmount - Supplies the amount of paged pool quota to return.

    PagedAmount - Supplies the amount of non paged pool quota to return.

Return Value:

    None.

--*/

{
    //
    // if we bypassed the quota charge, don't do anything here either
    //

    if (QuotaBlock == (PEPROCESS_QUOTA_BLOCK) 1) {
        return;
    }

    if (PagedAmount > 0) {
        PspReturnQuota (QuotaBlock, NULL, PsPagedPool, PagedAmount);
    }

    if (NonPagedAmount > 0) {
        PspReturnQuota (QuotaBlock, NULL, PsNonPagedPool, NonPagedAmount);
    }

    PspDereferenceQuotaBlock (QuotaBlock);
}

VOID
PsChargePoolQuota(
    IN PEPROCESS Process,
    IN POOL_TYPE PoolType,
    IN SIZE_T Amount
    )

/*++

Routine Description:

    This function charges pool quota of the specified pool type to
    the specified process. If the quota charge would exceed the limits
    allowed to the process, then an exception is raised and quota is
    not charged.

Arguments:

    Process - Supplies the process to charge quota to.

    PoolType - Supplies the type of pool quota to charge.

    Amount - Supplies the amount of pool quota to charge.

Return Value:

    Raises STATUS_QUOTA_EXCEEDED if the quota charge would exceed the
        limits allowed to the process.

--*/
{
    NTSTATUS Status;

    Status = PsChargeProcessPoolQuota (Process,
                                       PoolType,
                                       Amount);
    if (!NT_SUCCESS (Status)) {
        ExRaiseStatus (Status);
    }
}

NTSTATUS
PsChargeProcessPoolQuota(
    IN PEPROCESS Process,
    IN POOL_TYPE PoolType,
    IN SIZE_T Amount
    )

/*++

Routine Description:

    This function charges pool quota of the specified pool type to
    the specified process. If the quota charge would exceed the limits
    allowed to the process, then an exception is raised and quota is
    not charged.

Arguments:

    Process - Supplies the process to charge quota to.

    PoolType - Supplies the type of pool quota to charge.

    Amount - Supplies the amount of pool quota to charge.

Return Value:

    NTSTATUS - Status of operation

--*/

{
    ASSERT ((Process->Pcb.Header.Type == ProcessObject) || (Process->Pcb.Header.Type == 0));

    ASSERT (PoolType == PagedPool || PoolType == NonPagedPool);

    __assume (PoolType == PagedPool || PoolType == NonPagedPool);


    if (Process == PsInitialSystemProcess) {
        return STATUS_SUCCESS;
    }

    return PspChargeQuota (Process->QuotaBlock, Process, PoolType, Amount);
}

VOID
PsReturnPoolQuota(
    IN PEPROCESS Process,
    IN POOL_TYPE PoolType,
    IN SIZE_T Amount
    )

/*++

Routine Description:

    This function returns pool quota of the specified pool type to the
    specified process.

Arguments:

    Process - Supplies the process to return quota to.

    PoolType - Supplies the type of pool quota to return.

    Amount - Supplies the amount of pool quota to return

Return Value:

    Raises STATUS_QUOTA_EXCEEDED if the quota charge would exceed the
        limits allowed to the process.

--*/

{
    ASSERT((Process->Pcb.Header.Type == ProcessObject) || (Process->Pcb.Header.Type == 0));

    ASSERT (PoolType == PagedPool || PoolType == NonPagedPool);

    __assume (PoolType == PagedPool || PoolType == NonPagedPool);

    if (Process == PsInitialSystemProcess) {
        return;
    }

    PspReturnQuota (Process->QuotaBlock, Process, PoolType, Amount);
    return;
}

VOID
PspInheritQuota(
    IN PEPROCESS NewProcess,
    IN PEPROCESS ParentProcess
    )
{
    PEPROCESS_QUOTA_BLOCK QuotaBlock;

    if (ParentProcess) {
        QuotaBlock = ParentProcess->QuotaBlock;
    } else {
        QuotaBlock = &PspDefaultQuotaBlock;
    }

    InterlockedIncrement ((PLONG) &QuotaBlock->ReferenceCount);
    InterlockedIncrement ((PLONG) &QuotaBlock->ProcessCount);
    NewProcess->QuotaBlock = QuotaBlock;
}

VOID
PspDereferenceQuota (
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This function is called at process object deletion to remove the quota block.

Arguments:

    Process - Supplies the process to return quota to.


Return Value:

    None.

--*/
{
    PEPROCESS_QUOTA_BLOCK QuotaBlock;

    ASSERT (Process->QuotaUsage[PsNonPagedPool] == 0);

    ASSERT (Process->QuotaUsage[PsPagedPool]    == 0);

    ASSERT (Process->QuotaUsage[PsPageFile]     == 0);

    QuotaBlock = Process->QuotaBlock;

    InterlockedDecrement ((PLONG) &QuotaBlock->ProcessCount);
    PspDereferenceQuotaBlock (QuotaBlock);
}

NTSTATUS
PsChargeProcessQuota (
    IN PEPROCESS Process,
    IN PS_QUOTA_TYPE QuotaType,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to charge against the specified quota.

Arguments:

    Process   - Supplies the process to charge against.
    QuotaType - Type of quota being charged
    Amount    - Amount of quota being charged


Return Value:

    NTSTATUS - Status of operation

--*/
{
    ASSERT ((Process->Pcb.Header.Type == ProcessObject) || (Process->Pcb.Header.Type == 0));

    if (Process == PsInitialSystemProcess) {
        return STATUS_SUCCESS;
    }

    return PspChargeQuota (Process->QuotaBlock, Process, QuotaType, Amount);
}

VOID
PsReturnProcessQuota (
    IN PEPROCESS Process,
    IN PS_QUOTA_TYPE QuotaType,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to return previously charged quota to the specified process

Arguments:

    Process   - Supplies the process that was previously charged.
    QuotaType - Type of quota being returned
    Amount    - Amount of quota being returned


Return Value:

    NTSTATUS - Status of operation

--*/
{
    ASSERT ((Process->Pcb.Header.Type == ProcessObject) || (Process->Pcb.Header.Type == 0));

    if (Process == PsInitialSystemProcess) {
        return;
    }

    PspReturnQuota (Process->QuotaBlock, Process, QuotaType, Amount);
}

NTSTATUS
PsChargeProcessNonPagedPoolQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to charge non-paged pool quota against the specified process.

Arguments:

    Process   - Supplies the process to charge against.
    Amount    - Amount of quota being charged


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return STATUS_SUCCESS;
    }
    return PspChargeQuota (Process->QuotaBlock, Process, PsNonPagedPool, Amount);
}

VOID
PsReturnProcessNonPagedPoolQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to return previously charged non-paged pool quota to the specified process

Arguments:

    Process   - Supplies the process that was previously charged.
    Amount    - Amount of quota being returned


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return;
    }
    PspReturnQuota (Process->QuotaBlock, Process, PsNonPagedPool, Amount);
}

NTSTATUS
PsChargeProcessPagedPoolQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to charge paged pool quota against the specified process.

Arguments:

    Process   - Supplies the process to charge against.
    Amount    - Amount of quota being charged


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return STATUS_SUCCESS;
    }
    return PspChargeQuota (Process->QuotaBlock, Process, PsPagedPool, Amount);
}

VOID
PsReturnProcessPagedPoolQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to return previously charged paged pool quota to the specified process

Arguments:

    Process   - Supplies the process that was previously charged.
    Amount    - Amount of quota being returned


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return;
    }
    PspReturnQuota (Process->QuotaBlock, Process, PsPagedPool, Amount);
}

NTSTATUS
PsChargeProcessPageFileQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to charge page file quota against the specified process.

Arguments:

    Process   - Supplies the process to charge against.
    Amount    - Amount of quota being charged


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return STATUS_SUCCESS;
    }
    return PspChargeQuota (Process->QuotaBlock, Process, PsPageFile, Amount);
}

VOID
PsReturnProcessPageFileQuota(
    IN PEPROCESS Process,
    IN SIZE_T Amount
    )
/*++

Routine Description:

    This function is called to return previously charged page file quota to the specified process

Arguments:

    Process   - Supplies the process that was previously charged.
    Amount    - Amount of quota being returned


Return Value:

    NTSTATUS - Status of operation

--*/
{
    if (Process == PsInitialSystemProcess) {
        return;
    }
    PspReturnQuota (Process->QuotaBlock, Process, PsPageFile, Amount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\psp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psp.h

Abstract:

    Private Interfaces for process structure.

Author:

    Mark Lucovsky (markl) 20-Apr-1989

Revision History:

--*/

#ifndef _PSP_
#define _PSP_

#pragma warning(disable:4054)   // Cast of function pointer to PVOID
#pragma warning(disable:4055)   // Cast of function pointer
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4152)   // Casting function pointers
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4327)   // alignment on assignment
#pragma warning(disable:4328)   // alignment on assignment

#include "ntos.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "zwapi.h"
#include "ki.h"
#if defined(_X86_)
#include <vdmntos.h>
#endif
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include <string.h>
#if defined(_WIN64)
#include <wow64t.h>
#endif

//
// Working Set Watcher is 8kb. This lets us watch about 4mb of working
// set.
//

#define WS_CATCH_SIZE 8192
#define WS_OVERHEAD 16
#define MAX_WS_CATCH_INDEX (((WS_CATCH_SIZE-WS_OVERHEAD)/sizeof(PROCESS_WS_WATCH_INFORMATION)) - 2)

//
// Process Quota Charges:
//
//  PagedPool
//      Directory Base Page - PAGE_SIZE
//
//  NonPaged
//      Object Body         - sizeof(EPROCESS)
//

#define PSP_PROCESS_PAGED_CHARGE    (PAGE_SIZE)
#define PSP_PROCESS_NONPAGED_CHARGE (sizeof(EPROCESS))

//
// Thread Quota Charges:
//
//  PagedPool
//      Kernel Stack        - 0
//
//  NonPaged
//      Object Body         - sizeof(ETHREAD)
//

#define PSP_THREAD_PAGED_CHARGE     (0)
#define PSP_THREAD_NONPAGED_CHARGE  (sizeof(ETHREAD))

//
// Define routines to get trap and exception frame addresses
//

#define PSPALIGN_DOWN(address,amt) ((ULONG)(address) & ~(( amt ) - 1))

#define PSPALIGN_UP(address,amt) (PSPALIGN_DOWN( (address + (amt) - 1), (amt) ))


#if defined(_IA64_)

#define PspGetBaseTrapFrame(Thread) (PKTRAP_FRAME)((ULONG_PTR)Thread->Tcb.InitialStack - \
                                                   KTHREAD_STATE_SAVEAREA_LENGTH - KTRAP_FRAME_LENGTH)


#define PspGetBaseExceptionFrame(Thread) ((PKEXCEPTION_FRAME)(((ULONG_PTR)PspGetBaseTrapFrame(Thread) + STACK_SCRATCH_AREA - \
                                                               sizeof(KEXCEPTION_FRAME)) & ~((ULONG_PTR)15)))


#elif defined(_AMD64_)

#define PspGetBaseTrapFrame(Thread) (PKTRAP_FRAME)((ULONG_PTR)Thread->Tcb.InitialStack - KTRAP_FRAME_LENGTH)

#define PspGetBaseExceptionFrame(Thread) ((PKEXCEPTION_FRAME)((ULONG_PTR)PspGetBaseTrapFrame(Thread) - \
                                                              KEXCEPTION_FRAME_LENGTH))

#elif defined(_X86_)

#define PspGetBaseTrapFrame(Thread) (PKTRAP_FRAME)((ULONG_PTR)Thread->Tcb.InitialStack - \
                                                   PSPALIGN_UP(sizeof(KTRAP_FRAME),KTRAP_FRAME_ALIGN) - \
                                                   sizeof(FX_SAVE_AREA))

#define PspGetBaseExceptionFrame(Thread) (NULL)

#else

#error "no target architecture"

#endif // defined(_IA64_)



typedef struct _GETSETCONTEXT {
    KAPC Apc;
    KPROCESSOR_MODE Mode;
    KEVENT OperationComplete;
    CONTEXT Context;
    KNONVOLATILE_CONTEXT_POINTERS NonVolatileContext;
} GETSETCONTEXT, *PGETSETCONTEXT;

typedef struct _SYSTEM_DLL {
    PVOID Section;
    PVOID DllBase;
    PKNORMAL_ROUTINE LoaderInitRoutine;
    EX_PUSH_LOCK DllLock;
} SYSTEM_DLL, PSYSTEM_DLL;

typedef struct _JOB_WORKING_SET_CHANGE_HEAD {
    LIST_ENTRY Links;
    KGUARDED_MUTEX Lock;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
} JOB_WORKING_SET_CHANGE_HEAD, *PJOB_WORKING_SET_CHANGE_HEAD;

typedef struct _JOB_WORKING_SET_CHANGE_RECORD {
    LIST_ENTRY Links;
    PEPROCESS Process;
} JOB_WORKING_SET_CHANGE_RECORD, *PJOB_WORKING_SET_CHANGE_RECORD;

JOB_WORKING_SET_CHANGE_HEAD PspWorkingSetChangeHead;

//
// Private Entry Points
//

VOID
PspProcessDump(
    IN PVOID Object,
    IN POB_DUMP_CONTROL Control OPTIONAL
    );

VOID
PspProcessDelete(
    IN PVOID Object
    );


VOID
PspThreadDump(
    IN PVOID Object,
    IN POB_DUMP_CONTROL Control OPTIONAL
    );

VOID
PspInheritQuota(
    IN PEPROCESS NewProcess,
    IN PEPROCESS ParentProcess
    );

VOID
PspDereferenceQuota(
    IN PEPROCESS Process
    );

VOID
PspThreadDelete(
    IN PVOID Object
    );

NTSTATUS
PspWriteTebImpersonationInfo (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    );

//
// Initialization and loader entrypoints
//

BOOLEAN
PspInitPhase0 (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

BOOLEAN
PspInitPhase1 (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
PspInitializeSystemDll( VOID );

NTSTATUS
PspLookupSystemDllEntryPoint(
    IN PSZ EntryPointName,
    OUT PVOID *EntryPointAddress
    );

NTSTATUS
PspLookupKernelUserEntryPoints(
    VOID
    );

USHORT
PspNameToOrdinal(
    IN PSZ EntryPointName,
    IN ULONG DllBase,
    IN ULONG NumberOfNames,
    IN PULONG NameTableBase,
    IN PUSHORT OrdinalTableBase
    );

//
// Internal Creation Functions
//


NTSTATUS
PspCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess OPTIONAL,
    IN ULONG Flags,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    IN ULONG JobMemberLevel
    );

#define PSP_MAX_CREATE_PROCESS_NOTIFY 8

//
// Define process callouts. These are of type PCREATE_PROCESS_NOTIFY_ROUTINE 
// Called on process create and delete.
//
ULONG PspCreateProcessNotifyRoutineCount;
EX_CALLBACK PspCreateProcessNotifyRoutine[PSP_MAX_CREATE_PROCESS_NOTIFY];



#define PSP_MAX_CREATE_THREAD_NOTIFY 8

//
// Define thread callouts. These are of type PCREATE_THREAD_NOTIFY_ROUTINE
// Called on thread create and delete.
//
ULONG PspCreateThreadNotifyRoutineCount;
EX_CALLBACK PspCreateThreadNotifyRoutine[PSP_MAX_CREATE_THREAD_NOTIFY];


#define PSP_MAX_LOAD_IMAGE_NOTIFY 8

//
// Define image load callbacks. These are of type PLOAD_IMAGE_NOTIFY_ROUTINE 
// Called on image load.
//
ULONG PspLoadImageNotifyRoutineCount;
EX_CALLBACK PspLoadImageNotifyRoutine[PSP_MAX_LOAD_IMAGE_NOTIFY];


NTSTATUS
PspCreateThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    IN PEPROCESS ProcessPointer,
    OUT PCLIENT_ID ClientId OPTIONAL,
    IN PCONTEXT ThreadContext OPTIONAL,
    IN PINITIAL_TEB InitialTeb OPTIONAL,
    IN BOOLEAN CreateSuspended,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext
    );

//
// Startup Routines
//

VOID
PspUserThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    );

VOID
PspSystemThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    );

VOID
PspReaper(
    IN PVOID StartContext
    );

VOID
PspNullSpecialApc(
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

//
// Thread Exit Support
//

VOID
PspExitApcRundown(
    IN PKAPC Apc
    );

DECLSPEC_NORETURN
VOID
PspExitThread(
    IN NTSTATUS ExitStatus
    );

NTSTATUS
PspTerminateThreadByPointer(
    IN PETHREAD Thread,
    IN NTSTATUS ExitStatus,
    IN BOOLEAN DirectTerminate
    );


VOID
PspExitSpecialApc(
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

VOID
PspExitProcess(
    IN BOOLEAN TrimAddressSpace,
    IN PEPROCESS Process
    );

NTSTATUS
PspWaitForUsermodeExit(
    IN PEPROCESS         Process
    );

//
// Context Management
//

VOID
PspSetContext(
    OUT PKTRAP_FRAME TrapFrame,
    OUT PKNONVOLATILE_CONTEXT_POINTERS NonVolatileContext,
    IN PCONTEXT Context,
    KPROCESSOR_MODE Mode
    );

VOID
PspGetContext(
    IN PKTRAP_FRAME TrapFrame,
    IN PKNONVOLATILE_CONTEXT_POINTERS NonVolatileContext,
    IN OUT PCONTEXT Context
    );

VOID
PspGetSetContextSpecialApc(
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

VOID
PspExitNormalApc(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// private security routines
//

NTSTATUS
PspInitializeProcessSecurity(
    IN PEPROCESS Parent OPTIONAL,
    IN PEPROCESS Child
    );

VOID
PspDeleteProcessSecurity(
  IN PEPROCESS Process
  );

VOID
PspInitializeThreadSecurity(
    IN PEPROCESS Process,
    IN PETHREAD Thread
    );

VOID
PspDeleteThreadSecurity(
    IN PETHREAD Thread
    );

NTSTATUS
PspAssignPrimaryToken(
    IN PEPROCESS Process,
    IN HANDLE Token OPTIONAL,
    IN PACCESS_TOKEN TokenPointer OPTIONAL
    );

NTSTATUS
PspSetPrimaryToken(
    IN HANDLE ProcessHandle,
    IN PEPROCESS ProcessPointer OPTIONAL, 
    IN HANDLE TokenHandle OPTIONAL,
    IN PACCESS_TOKEN TokenPointer OPTIONAL,
    IN BOOLEAN PrivilegeChecked
    );

//
// Ldt support routines
//

#if defined(i386)
NTSTATUS
PspLdtInitialize(
    );
#endif

//
// Vdm support Routines

#if defined(i386)
NTSTATUS
PspVdmInitialize(
    );
#endif

NTSTATUS
PspQueryLdtInformation(
    IN PEPROCESS Process,
    OUT PVOID LdtInformation,
    IN ULONG LdtInformationLength,
    OUT PULONG ReturnLength
    );

NTSTATUS
PspSetLdtInformation(
    IN PEPROCESS Process,
    IN PVOID LdtInformation,
    IN ULONG LdtInformationLength
    );

NTSTATUS
PspSetLdtSize(
    IN PEPROCESS Process,
    IN PVOID LdtSize,
    IN ULONG LdtSizeLength
    );

VOID
PspDeleteLdt(
    IN PEPROCESS Process
    );

//
// Io handling support routines
//


NTSTATUS
PspSetProcessIoHandlers(
    IN PEPROCESS Process,
    IN PVOID IoHandlerInformation,
    IN ULONG IoHandlerLength
    );

VOID
PspDeleteVdmObjects(
    IN PEPROCESS Process
    );

NTSTATUS
PspQueryDescriptorThread (
    PETHREAD Thread,
    PVOID ThreadInformation,
    ULONG ThreadInformationLength,
    PULONG ReturnLength
    );

//
// Job Object Support Routines
//

VOID
PspInitializeJobStructures(
    VOID
    );

VOID
PspInitializeJobStructuresPhase1(
    VOID
    );

VOID
PspJobTimeLimitsWork(
    IN PVOID Context
    );

VOID
PspJobTimeLimitsDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
PspJobDelete(
    IN PVOID Object
    );

VOID
PspJobClose (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    );

NTSTATUS
PspAddProcessToJob(
    PEJOB Job,
    PEPROCESS Process
    );

VOID
PspRemoveProcessFromJob(
    PEJOB Job,
    PEPROCESS Process
    );

VOID
PspExitProcessFromJob(
    PEJOB Job,
    PEPROCESS Process
    );

VOID
PspApplyJobLimitsToProcessSet(
    PEJOB Job
    );

VOID
PspApplyJobLimitsToProcess(
    PEJOB Job,
    PEPROCESS Process
    );

BOOLEAN
PspTerminateAllProcessesInJob(
    PEJOB Job,
    NTSTATUS Status,
    BOOLEAN IncCounter
    );

VOID
PspFoldProcessAccountingIntoJob(
    PEJOB Job,
    PEPROCESS Process
    );

NTSTATUS
PspCaptureTokenFilter(
    KPROCESSOR_MODE PreviousMode,
    PJOBOBJECT_SECURITY_LIMIT_INFORMATION SecurityLimitInfo,
    PPS_JOB_TOKEN_FILTER * TokenFilter
    );

VOID
PspShutdownJobLimits(
    VOID
    );

NTSTATUS
PspTerminateProcess(
    PEPROCESS Process,
    NTSTATUS Status
    );


NTSTATUS
PspGetJobFromSet (
    IN PEJOB ParentJob,
    IN ULONG JobMemberLevel,
    OUT PEJOB *pJob);

NTSTATUS
PspWin32SessionCallout(
    IN  PKWIN32_JOB_CALLOUT CalloutRoutine,
    IN  PKWIN32_JOBCALLOUT_PARAMETERS Parameters,
    IN  ULONG SessionId
    );


//
// This test routine is called on checked systems to test this path
//
VOID
PspImageNotifyTest(
    IN PUNICODE_STRING FullImageName,
    IN HANDLE ProcessId,
    IN PIMAGE_INFO ImageInfo
    );

PEPROCESS
PspGetNextJobProcess (
    IN PEJOB Job,
    IN PEPROCESS Process
    );

VOID
PspQuitNextJobProcess (
    IN PEPROCESS Process
    );

VOID
PspInsertQuotaBlock (
    IN PEPROCESS_QUOTA_BLOCK QuotaBlock
    );



VOID
FORCEINLINE
PspInitializeProcessLock (
    IN PEPROCESS Process
    )
{
    ExInitializePushLock (&Process->ProcessLock);
}

VOID
FORCEINLINE
PspLockProcessExclusive (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquirePushLockExclusive (&Process->ProcessLock);
}

VOID
FORCEINLINE
PspLockProcessShared (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquirePushLockShared (&Process->ProcessLock);
}

VOID
FORCEINLINE
PspUnlockProcessShared (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    ExReleasePushLockShared (&Process->ProcessLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspUnlockProcessExclusive (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    ExReleasePushLockExclusive (&Process->ProcessLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}


//
// Define macros to lock the security fields of the process and thread
//

VOID
FORCEINLINE
PspLockProcessSecurityExclusive (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    PspLockProcessExclusive (Process, CurrentThread);
}

VOID
FORCEINLINE
PspLockProcessSecurityShared (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    PspLockProcessShared (Process, CurrentThread);
}

VOID
FORCEINLINE
PspUnlockProcessSecurityShared (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    PspUnlockProcessShared (Process, CurrentThread);
}

VOID
FORCEINLINE
PspUnlockProcessSecurityExclusive (
    IN PEPROCESS Process,
    IN PETHREAD CurrentThread
    )
{
    PspUnlockProcessExclusive (Process, CurrentThread);
}


VOID
FORCEINLINE
PspInitializeThreadLock (
    IN PETHREAD Thread
    )
{
    ExInitializePushLock (&Thread->ThreadLock);
}

VOID
FORCEINLINE
PspLockThreadSecurityExclusive (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    )
{
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquirePushLockExclusive (&Thread->ThreadLock);
}

VOID
FORCEINLINE
PspLockThreadSecurityShared (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    )
{
    KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    ExAcquirePushLockShared (&Thread->ThreadLock);
}


VOID
FORCEINLINE
PspUnlockThreadSecurityShared (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    )
{
    ExReleasePushLockShared (&Thread->ThreadLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspUnlockThreadSecurityExclusive (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    )
{
    ExReleasePushLockExclusive (&Thread->ThreadLock);
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
}

//
// Define macros to lock the global process list
//

extern KGUARDED_MUTEX PspActiveProcessMutex;

VOID
FORCEINLINE
PspInitializeProcessListLock (
    VOID
    )
{
    KeInitializeGuardedMutex (&PspActiveProcessMutex);
};

VOID
FORCEINLINE
PspLockProcessList (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspActiveProcessMutex);
}

VOID
FORCEINLINE
PspUnlockProcessList (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspActiveProcessMutex);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

//
// Routines to lock and unlock the job list mutex
//

extern KGUARDED_MUTEX PspJobListLock;

VOID
FORCEINLINE
PspInitializeJobListLock (
    VOID
    )
{
    KeInitializeGuardedMutex (&PspJobListLock);
}


VOID
FORCEINLINE
PspLockJobListExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspJobListLock);
}

VOID
FORCEINLINE
PspLockJobListShared (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspJobListLock);
}

VOID
FORCEINLINE
PspUnlockJobListExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspJobListLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspUnlockJobListShared (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspJobListLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

//
// Routines to lock the job memory list lock
//

VOID
FORCEINLINE
PspInitializeJobLimitsLock (
    IN PEJOB Job
    )
{
    KeInitializeGuardedMutex (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspLockJobLimitsExclusive (
    IN PEJOB    Job,
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspLockJobLimitsExclusiveUnsafe (
    IN PEJOB    Job
    )
{
    ASSERT (KeAreAllApcsDisabled());
    KeAcquireGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspLockJobLimitsShared (
    IN PEJOB    Job,
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspLockJobLimitsSharedUnsafe (
    IN PEJOB Job
    )
{
    ASSERT (KeAreAllApcsDisabled());
    KeAcquireGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspUnlockJobLimitsExclusive (
    IN PEJOB    Job,
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&Job->MemoryLimitsLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspUnlockJobLimitsExclusiveUnsafe (
    IN PEJOB Job
    )
{
    ASSERT (KeAreAllApcsDisabled());
    KeReleaseGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

VOID
FORCEINLINE
PspUnlockJobLimitsShared (
    IN PEJOB    Job,
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&Job->MemoryLimitsLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspUnlockJobLimitsSharedUnsafe (
    IN PEJOB Job
    )
{
    ASSERT (KeAreAllApcsDisabled());
    KeReleaseGuardedMutexUnsafe (&Job->MemoryLimitsLock);
}

//
// Routines to lock job time limits structures
//
extern KGUARDED_MUTEX PspJobTimeLimitsLock;

VOID
FORCEINLINE
PspInitializeJobTimeLimitsLock (
    VOID
    )
{
    KeInitializeGuardedMutex (&PspJobTimeLimitsLock);
}

VOID
FORCEINLINE
PspLockJobTimeLimitsExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspJobTimeLimitsLock);
}

VOID
FORCEINLINE
PspUnlockJobTimeLimitsExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspJobTimeLimitsLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspLockJobTimeLimitsShared (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspJobTimeLimitsLock);
}

VOID
FORCEINLINE
PspUnlockJobTimeLimitsShared (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspJobTimeLimitsLock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

//
// Routines for locking working set change lock
//
VOID
FORCEINLINE
PspInitializeWorkingSetChangeLock (
    VOID
    )
{
    KeInitializeGuardedMutex (&PspWorkingSetChangeHead.Lock);
}

VOID
FORCEINLINE
PspLockWorkingSetChangeExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeEnterGuardedRegionThread (&CurrentThread->Tcb);
    KeAcquireGuardedMutexUnsafe (&PspWorkingSetChangeHead.Lock);
}

VOID
FORCEINLINE
PspUnlockWorkingSetChangeExclusive (
    IN PETHREAD CurrentThread
    )
{
    KeReleaseGuardedMutexUnsafe (&PspWorkingSetChangeHead.Lock);
    KeLeaveGuardedRegionThread (&CurrentThread->Tcb);
}

VOID
FORCEINLINE
PspLockWorkingSetChangeExclusiveUnsafe (
    VOID
    )
{
    ASSERT (KeAreAllApcsDisabled());
    KeAcquireGuardedMutexUnsafe (&PspWorkingSetChangeHead.Lock);
}

VOID
FORCEINLINE
PspUnlockWorkingSetChangeExclusiveUnsafe (
    VOID
    )
{
    KeReleaseGuardedMutexUnsafe (&PspWorkingSetChangeHead.Lock);
    ASSERT (KeAreAllApcsDisabled());
}

//
//
// Global Data
//

extern PHANDLE_TABLE PspCidTable;
extern HANDLE PspInitialSystemProcessHandle;
extern PACCESS_TOKEN PspBootAccessToken;
extern KSPIN_LOCK PspEventPairLock;
extern SYSTEM_DLL PspSystemDll;
extern PETHREAD PspShutdownThread;

extern ULONG PspDefaultPagedLimit;
extern ULONG PspDefaultNonPagedLimit;
extern ULONG PspDefaultPagefileLimit;
extern ULONG PsMinimumWorkingSet;

extern EPROCESS_QUOTA_BLOCK PspDefaultQuotaBlock;
extern BOOLEAN PspDoingGiveBacks;

extern PKWIN32_PROCESS_CALLOUT PspW32ProcessCallout;
extern PKWIN32_THREAD_CALLOUT PspW32ThreadCallout;
extern PKWIN32_JOB_CALLOUT PspW32JobCallout;
extern ULONG PspW32ProcessSize;
extern ULONG PspW32ThreadSize;
extern SCHAR PspForegroundQuantum[3];


#define PSP_NUMBER_OF_SCHEDULING_CLASSES    10
#define PSP_DEFAULT_SCHEDULING_CLASSES      5

extern const SCHAR PspJobSchedulingClasses[PSP_NUMBER_OF_SCHEDULING_CLASSES];
extern BOOLEAN PspUseJobSchedulingClasses;

extern LIST_ENTRY PspJobList;
extern KDPC PspJobLimeLimitsDpc;
extern KTIMER PspJobTimeLimitsTimer;
extern WORK_QUEUE_ITEM PspJobTimeLimitsWorkItem;
extern KSPIN_LOCK PspQuotaLock;

#endif // _PSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\security.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This module implements the security related portions of the process
    structure.


Author:

    Mark Lucovsky (markl) 25-Apr-1989
    Jim Kelly (JimK) 2-August-1990

    Neill Clift (NeillC) 14-Aug-2000
        Revamped for fast referencing the primary token and holding the security lock
        only over critical portions.


Revision History:

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
PsOpenTokenOfJobObject(
    IN HANDLE JobObject,
    OUT PACCESS_TOKEN * Token
    );

#pragma alloc_text(PAGE, PsReferencePrimaryToken)
#pragma alloc_text(PAGE, PsReferenceImpersonationToken)
#pragma alloc_text(PAGE, PsReferenceEffectiveToken)
#pragma alloc_text(PAGE, PsOpenTokenOfThread)
#pragma alloc_text(PAGE, PsOpenTokenOfProcess)
#pragma alloc_text(PAGE, PsOpenTokenOfJobObject)
#pragma alloc_text(PAGE, PsImpersonateClient)
#pragma alloc_text(PAGE, PsDisableImpersonation)
#pragma alloc_text(PAGE, PsRestoreImpersonation)
#pragma alloc_text(PAGE, PsRevertToSelf)
#pragma alloc_text(PAGE, PsRevertThreadToSelf)
#pragma alloc_text(PAGE, PspInitializeProcessSecurity)
#pragma alloc_text(PAGE, PspDeleteProcessSecurity)
#pragma alloc_text(PAGE, PspAssignPrimaryToken)
#pragma alloc_text(PAGE, PspInitializeThreadSecurity)
#pragma alloc_text(PAGE, PspDeleteThreadSecurity)
#pragma alloc_text(PAGE, PsAssignImpersonationToken)
#pragma alloc_text(PAGE, PspWriteTebImpersonationInfo)

#endif //ALLOC_PRAGMA


PACCESS_TOKEN
PsReferencePrimaryToken(
    IN PEPROCESS Process
    )

/*++

Routine Description:

    This function returns a pointer to the primary token of a process.
    The reference count of that primary token is incremented to protect
    the pointer returned.

    When the pointer is no longer needed, it should be freed using
    PsDereferencePrimaryToken().


Arguments:

    Process - Supplies the address of the process whose primary token
        is to be referenced.

Return Value:

    A pointer to the specified process's primary token.

--*/

{
    PACCESS_TOKEN Token;
    PETHREAD CurrentThread;

    PAGED_CODE();

    ASSERT( Process->Pcb.Header.Type == ProcessObject );

    Token = ObFastReferenceObject (&Process->Token);
    if (Token == NULL) {
        CurrentThread = PsGetCurrentThread ();
        PspLockProcessSecurityShared (Process, CurrentThread);
        Token = ObFastReferenceObjectLocked (&Process->Token);
        PspUnlockProcessSecurityShared (Process, CurrentThread);
    }

    return Token;

}


PACCESS_TOKEN
PsReferenceImpersonationToken(
    IN PETHREAD Thread,
    OUT PBOOLEAN CopyOnOpen,
    OUT PBOOLEAN EffectiveOnly,
    OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This function returns a pointer to the impersonation token of a thread.
    The reference count of that impersonation token is incremented to protect
    the pointer returned.

    If the thread is not currently impersonating a client, then a null pointer
    is returned.

    If the thread is impersonating a client, then information about the
    means of impersonation are also returned (ImpersonationLevel).

    If a non-null value is returned, then PsDereferenceImpersonationToken()
    must be called to decrement the token's reference count when the pointer
    is no longer needed.


Arguments:

    Thread - Supplies the address of the thread whose impersonation token
        is to be referenced.

    CopyOnOpen - The current value of the Thread->ImpersonationInfo->CopyOnOpen field.

    EffectiveOnly - The current value of the Thread->ImpersonationInfo->EffectiveOnly field.

    ImpersonationLevel - The current value of the Thread->ImpersonationInfo->ImpersonationLevel
        field.

Return Value:

    A pointer to the specified thread's impersonation token.

    If the thread is not currently impersonating a client, then NULL is
    returned.

--*/

{
    PACCESS_TOKEN Token;
    PETHREAD CurrentThread;
    PPS_IMPERSONATION_INFORMATION ImpersonationInfo;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);

    //
    // before going through the lock overhead just look to see if it is
    // null. There is no race.  Grabbing the lock is not needed until
    // we decide to use the token at which point we re check to see it
    // it is null.
    // This check saves about 300 instructions.
    //

    if (!PS_IS_THREAD_IMPERSONATING (Thread)) {
        return NULL;
    }

    //
    //  Lock the process security fields.
    //
    CurrentThread = PsGetCurrentThread ();

    PspLockThreadSecurityShared (Thread, CurrentThread);

    //
    // Grab impersonation info block.
    //
    ImpersonationInfo = Thread->ImpersonationInfo;


    if (PS_IS_THREAD_IMPERSONATING (Thread)) {

        //
        //  Return the thread's impersonation level, etc.
        //

        Token = ImpersonationInfo->Token;
        //
        //  Increment the reference count of the token to protect our
        //  pointer.
        //

        ObReferenceObject (Token);

        (*ImpersonationLevel) = ImpersonationInfo->ImpersonationLevel;
        (*CopyOnOpen) = ImpersonationInfo->CopyOnOpen;
        (*EffectiveOnly) = ImpersonationInfo->EffectiveOnly;



    } else {
        Token = NULL;
    }


    //
    //  Release the security fields.
    //

    PspUnlockThreadSecurityShared (Thread, CurrentThread);

    return Token;

}

PACCESS_TOKEN
PsReferenceEffectiveToken(
    IN PETHREAD Thread,
    OUT PTOKEN_TYPE TokenType,
    OUT PBOOLEAN EffectiveOnly,
    OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This function returns a pointer to the effective token of a thread.  The
    effective token of a thread is the thread's impersonation token if it has
    one.  Otherwise, it is the primary token of the thread's process.

    The reference count of the effective token is incremented to protect
    the pointer returned.

    If the thread is impersonating a client, then the impersonation level
    is also returned.

    Either PsDereferenceImpersonationToken() (for an impersonation token) or
    PsDereferencePrimaryToken() (for a primary token) must be called to
    decrement the token's reference count when the pointer is no longer
    needed.


Arguments:

    Thread - Supplies the address of the thread whose effective token
        is to be referenced.

    TokenType - Receives the type of the effective token.  If the thread
        is currently impersonating a client, then this will be
        TokenImpersonation.  Othwerwise, it will be TokenPrimary.

    EffectiveOnly - If the token type is TokenImpersonation, then this
        receives the value of the client thread's Thread->Client->EffectiveOnly field.
        Otherwise, it is set to FALSE.

    ImpersonationLevel - The current value of the Thread->Client->ImpersonationLevel
        field for an impersonation token and is not set for a primary token.

Return Value:

    A pointer to the specified thread's effective token.

--*/

{
    PACCESS_TOKEN Token;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    PPS_IMPERSONATION_INFORMATION ImpersonationInfo;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);

    Process = THREAD_TO_PROCESS(Thread);

    //
    //  Grab the current impersonation token pointer value
    //

    Token = NULL;

    if (PS_IS_THREAD_IMPERSONATING (Thread)) {


        //
        //  Lock the process security fields.
        //
        CurrentThread = PsGetCurrentThread ();

        PspLockThreadSecurityShared (Thread, CurrentThread);


        if (PS_IS_THREAD_IMPERSONATING (Thread)) {
            //
            // Grab impersonation info block.
            //
            ImpersonationInfo = Thread->ImpersonationInfo;

            Token = ImpersonationInfo->Token;

            //
            //  Return the thread's impersonation level, etc.
            //

            (*TokenType) = TokenImpersonation;
            (*EffectiveOnly) = ImpersonationInfo->EffectiveOnly;
            (*ImpersonationLevel) = ImpersonationInfo->ImpersonationLevel;

            //
            //  Increment the reference count of the token to protect our
            //  pointer.
            //
            ObReferenceObject (Token);

            //
            //  Release the security fields.
            //

            PspUnlockThreadSecurityShared (Thread, CurrentThread);

            return Token;
        }

        //
        //  Release the security fields.
        //

        PspUnlockThreadSecurityShared (Thread, CurrentThread);

    }

    //
    // Get the thread's primary token if it wasn't impersonating a client.
    //

    Token = ObFastReferenceObject (&Process->Token);

    if (Token == NULL) {
        //
        // Fast ref failed. We go the slow way with a lock
        //
        CurrentThread = PsGetCurrentThread ();

        PspLockProcessSecurityShared (Process,CurrentThread);
        Token = ObFastReferenceObjectLocked (&Process->Token);
        PspUnlockProcessSecurityShared (Process,CurrentThread);
    }
    //
    //  Only the TokenType and CopyOnOpen OUT parameters are
    //  returned for a primary token.
    //

    (*TokenType) = TokenPrimary;
    (*EffectiveOnly) = FALSE;

    return Token;

}

NTSTATUS
PsOpenTokenOfThread(
    IN HANDLE ThreadHandle,
    IN BOOLEAN OpenAsSelf,
    OUT PACCESS_TOKEN *Token,
    OUT PBOOLEAN CopyOnOpen,
    OUT PBOOLEAN EffectiveOnly,
    OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This function does the thread specific processing of
    an NtOpenThreadToken() service.

    The service validates that the handle has appropriate access
    to reference the thread.  If so, it goes on to increment
    the reference count of the token object to prevent it from
    going away while the rest of the NtOpenThreadToken() request
    is processed.

    NOTE: If this call completes successfully, the caller is responsible
          for decrementing the reference count of the target token.
          This must be done using PsDereferenceImpersonationToken().

Arguments:

    ThreadHandle - Supplies a handle to a thread object.

    OpenAsSelf - Is a boolean value indicating whether the access should
        be made using the calling thread's current security context, which
        may be that of a client (if impersonating), or using the caller's
        process-level security context.  A value of FALSE indicates the
        caller's current context should be used un-modified.  A value of
        TRUE indicates the request should be fulfilled using the process
        level security context.

    Token - If successful, receives a pointer to the thread's token
        object.

    CopyOnOpen - The current value of the Thread->Client->CopyOnOpen field.

    EffectiveOnly - The current value of the Thread->Client->EffectiveOnly field.

    ImpersonationLevel - The current value of the Thread->Client->ImpersonationLevel
        field.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_NO_TOKEN - Indicates the referenced thread is not currently
        impersonating a client.

    STATUS_CANT_OPEN_ANONYMOUS - Indicates the client requested anonymous
        impersonation level.  An anonymous token can not be openned.

    status may also be any value returned by an attemp the reference
    the thread object for THREAD_QUERY_INFORMATION access.

--*/

{

    NTSTATUS
        Status;

    PETHREAD
        Thread;

    KPROCESSOR_MODE
        PreviousMode;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();


    UNREFERENCED_PARAMETER (OpenAsSelf);

    //
    //  Make sure the handle grants the appropriate access to the specified
    //  thread.
    //

    Status = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);



    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    //  Reference the impersonation token, if there is one
    //

    (*Token) = PsReferenceImpersonationToken (Thread,
                                              CopyOnOpen,
                                              EffectiveOnly,
                                              ImpersonationLevel);


    //
    //  dereference the target thread.
    //

    ObDereferenceObject (Thread);

    //
    // Make sure there is a token
    //

    if (*Token == NULL) {
        return STATUS_NO_TOKEN;
    }

    //
    //  Make sure the ImpersonationLevel is high enough to allow
    //  the token to be openned.
    //

    if ((*ImpersonationLevel) <= SecurityAnonymous) {
        PsDereferenceImpersonationToken (*Token);
        (*Token) = NULL;
        return STATUS_CANT_OPEN_ANONYMOUS;
    }


    return STATUS_SUCCESS;

}


NTSTATUS
PsOpenTokenOfProcess(
    IN HANDLE ProcessHandle,
    OUT PACCESS_TOKEN *Token
    )

/*++

Routine Description:

    This function does the process specific processing of
    an NtOpenProcessToken() service.

    The service validates that the handle has appropriate access
    to referenced process.  If so, it goes on to reference the
    primary token object to prevent it from going away while the
    rest of the NtOpenProcessToken() request is processed.

    NOTE: If this call completes successfully, the caller is responsible
          for decrementing the reference count of the target token.
          This must be done using the PsDereferencePrimaryToken() API.

Arguments:

    ProcessHandle - Supplies a handle to a process object whose primary
        token is to be opened.

    Token - If successful, receives a pointer to the process's token
        object.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    status may also be any value returned by an attemp the reference
    the process object for PROCESS_QUERY_INFORMATION access.

--*/

{

    NTSTATUS
        Status;

    PEPROCESS
        Process;

    KPROCESSOR_MODE
        PreviousMode;


    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    //
    //  Make sure the handle grants the appropriate access to the specified
    //  process.
    //

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

    if (!NT_SUCCESS (Status)) {

        return Status;
    }

    //
    //  Reference the primary token
    //  (This takes care of gaining exlusive access to the process
    //   security fields for us)
    //

    (*Token) = PsReferencePrimaryToken (Process);



    //
    // Done with the process object
    //
    ObDereferenceObject (Process);

    return STATUS_SUCCESS;


}

NTSTATUS
PsOpenTokenOfJobObject(
    IN HANDLE JobObject,
    OUT PACCESS_TOKEN * Token
    )

/*++

Routine Description:

    This function does the ps/job specific work for NtOpenJobObjectToken.


Arguments:

    JobObject - Supplies a handle to a job object whose limit token
        token is to be opened.

    Token - If successful, receives a pointer to the process's token
        object.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_NO_TOKEN - indicates the job object does  not have a token


--*/
{
    NTSTATUS Status;
    PEJOB Job;
    KPROCESSOR_MODE PreviousMode;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle (JobObject,
                                        JOB_OBJECT_QUERY,
                                        PsJobType,
                                        PreviousMode,
                                        &Job,
                                        NULL);

    if (NT_SUCCESS (Status)) {
        if (Job->Token != NULL) {
            ObReferenceObject (Job->Token);

            *Token = Job->Token;

        } else {
            Status = STATUS_NO_TOKEN;
        }
    }

    return Status;
}



NTSTATUS
PsImpersonateClient(
    IN PETHREAD Thread,
    IN PACCESS_TOKEN Token,
    IN BOOLEAN CopyOnOpen,
    IN BOOLEAN EffectiveOnly,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This routine sets up the specified thread so that it is impersonating
    the specified client.  This will result in the reference count of the
    token representing the client being incremented to reflect the new
    reference.

    If the thread is currently impersonating a client, that token will be
    dereferenced.



Arguments:

    Thread - points to the thread which is going to impersonate a client.

    Token - Points to the token to be assigned as the impersonation token.
        This does NOT have to be a TokenImpersonation type token.  This
        allows direct reference of client process's primary tokens.

    CopyOnOpen - If TRUE, indicates the token is considered to be private
        by the assigner and should be copied if opened.  For example, a
        session layer may be using a token to represent a client's context.
        If the session is trying to synchronize the context of the client,
        then user mode code should not be given direct access to the session
        layer's token.

        Basically, session layers should always specify TRUE for this, while
        tokens assigned by the server itself (handle based) should specify
        FALSE.


    EffectiveOnly - Is a boolean value to be assigned as the
        Thread->ImpersonationInfo->EffectiveOnly field value for the
        impersonation.  A value of FALSE indicates the server is allowed
        to enable currently disabled groups and privileges.

    ImpersonationLevel - Is the impersonation level that the server is allowed
        to access the token with.


Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.


--*/

{

    PPS_IMPERSONATION_INFORMATION NewClient, FreeClient;
    PACCESS_TOKEN OldToken;
    PACCESS_TOKEN NewerToken=NULL;
    PACCESS_TOKEN ProcessToken ;
    NTSTATUS Status;
    PPS_JOB_TOKEN_FILTER Filter;
    PEPROCESS Process;
    PETHREAD CurrentThread;
    PEJOB Job;
    PPS_IMPERSONATION_INFORMATION ImpersonationInfo;
    BOOLEAN DontReference = FALSE ;
    BOOLEAN NewTokenCreated = FALSE ;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);

    Process = THREAD_TO_PROCESS (Thread);

    if (!ARGUMENT_PRESENT(Token)) {


        OldToken = NULL;
        if (PS_IS_THREAD_IMPERSONATING (Thread)) {

            //
            //  Lock the process security fields
            //
            CurrentThread = PsGetCurrentThread ();

            PspLockThreadSecurityExclusive (Thread, CurrentThread);

            if (PS_IS_THREAD_IMPERSONATING (Thread)) {
                //
                // Grab impersonation info block.
                //
                ImpersonationInfo = Thread->ImpersonationInfo;

                //
                // This is a request to revert to self.
                // Clean up any client information.
                //
                OldToken = ImpersonationInfo->Token;
                PS_CLEAR_BITS (&Thread->CrossThreadFlags,
                               PS_CROSS_THREAD_FLAGS_IMPERSONATING);
            }
            //
            //  Release the security fields
            //
            PspUnlockThreadSecurityExclusive (Thread, CurrentThread);

            PspWriteTebImpersonationInfo (Thread, CurrentThread);
        }

    } else {

        //
        // Allocate and set up the Client block. We do this without holding the Process
        // security lock so we reduce contention. Only one thread will manage to assign this.
        // The client block once created never goes away until the last dereference of
        // the process. We can touch this without locks
        //
        NewClient = Thread->ImpersonationInfo;
        if (NewClient == NULL) {
            NewClient = ExAllocatePoolWithTag (PagedPool,
                                               sizeof (PS_IMPERSONATION_INFORMATION),
                                               'mIsP'|PROTECTED_POOL);

            if (NewClient == NULL) {
                return STATUS_NO_MEMORY;
            }
            FreeClient = InterlockedCompareExchangePointer (&Thread->ImpersonationInfo,
                                                            NewClient,
                                                            NULL);
            //
            // We got beaten by another thread. Free our context and use the new one
            //
            if (FreeClient != NULL) {
                ExFreePoolWithTag (NewClient, 'mIsP'|PROTECTED_POOL);
                NewClient = FreeClient;
            }

        }

        //
        // Check process token for rules on impersonation
        //

        ProcessToken = PsReferencePrimaryToken( Process );

        if ( ProcessToken ) {

            Status = SeTokenCanImpersonate( 
                        ProcessToken, 
                        Token,
                        ImpersonationLevel );

            PsDereferencePrimaryTokenEx( Process, ProcessToken );

            if ( !NT_SUCCESS( Status ) ) {

                Status = SeCopyClientToken(
                                Token,
                                SecurityIdentification,
                                KernelMode,
                                &NewerToken );

                if ( !NT_SUCCESS(Status)) {

                    return Status ;
                    
                }

                //
                // We have a substitute token.  Change Token to be this new
                // one, but do not add a reference later.  Right now, there 
                // is exactly one reference, so it will go away when the 
                // thread stops impersonating.  Note that we still need to 
                // do the job filters below, hence the switch.
                //

                Token = NewerToken ;
                NewerToken = NULL ;
                DontReference = TRUE ;
                NewTokenCreated = TRUE ;
                ImpersonationLevel = SecurityIdentification ;
                
            }
            
        }

        //
        // Check if we're allowed to impersonate based on the job
        // restrictions:
        //


        Job = Process->Job;
        if (Job != NULL) {

            if ((Job->SecurityLimitFlags & JOB_OBJECT_SECURITY_NO_ADMIN) &&
                 (SeTokenIsAdmin (Token))) {

                if ( NewTokenCreated ) {

                    ObDereferenceObject( Token );
                    
                }

                return STATUS_ACCESS_DENIED;

            } else if ((Job->SecurityLimitFlags & JOB_OBJECT_SECURITY_RESTRICTED_TOKEN) &&
                       (!SeTokenIsRestricted (Token))) {

                if ( NewTokenCreated ) {

                    ObDereferenceObject( Token );
                    
                }
                return STATUS_ACCESS_DENIED;

            } else {
                Filter = Job->Filter;
                if (Filter != NULL) {
                    //
                    // Filter installed.  Need to create a restricted token
                    // dynamically.
                    //

                    Status = SeFastFilterToken (Token,
                                                KernelMode,
                                                0,
                                                Filter->CapturedGroupCount,
                                                Filter->CapturedGroups,
                                                Filter->CapturedPrivilegeCount,
                                                Filter->CapturedPrivileges,
                                                Filter->CapturedSidCount,
                                                Filter->CapturedSids,
                                                Filter->CapturedSidsLength,
                                                &NewerToken);

                    if (NT_SUCCESS (Status)) {
                        //
                        // If we created a filtered token then we don't need to add an extra token reference
                        // as this is a new token with a single reference we just created.
                        //

                        if ( NewTokenCreated ) {

                            ObDereferenceObject( Token );

                        }
                        Token = NewerToken;

                    } else {

                        if ( NewTokenCreated ) {

                            ObDereferenceObject( Token );

                        }
                        return Status;
                    }

                } else {

                    if ( !DontReference) {

                        ObReferenceObject (Token);
                    }
                }
            }
        } else {

            if ( !DontReference) {
                
                ObReferenceObject (Token);
            }
        }

        //
        //  Lock the process security fields
        //

        CurrentThread = PsGetCurrentThread ();

        PspLockThreadSecurityExclusive (Thread, CurrentThread);
        //
        // If we are already impersonating someone,
        // use the already allocated block.  This avoids
        // an alloc and a free.
        //

        if (PS_IS_THREAD_IMPERSONATING (Thread)) {

            //
            // capture the old token pointer.
            // We'll dereference it after unlocking the security fields.
            //

            OldToken = NewClient->Token;

        } else {

            OldToken = NULL;

            PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
        }

        NewClient->ImpersonationLevel = ImpersonationLevel;
        NewClient->EffectiveOnly = EffectiveOnly;
        NewClient->CopyOnOpen = CopyOnOpen;
        NewClient->Token = Token;
        //
        //  Release the security fields
        //
        PspUnlockThreadSecurityExclusive (Thread, CurrentThread);

        PspWriteTebImpersonationInfo (Thread, CurrentThread);
    }

    //
    // Free the old client token, if necessary.
    //

    if (OldToken != NULL) {
        PsDereferenceImpersonationToken (OldToken);
    }


    return STATUS_SUCCESS;

}


BOOLEAN
PsDisableImpersonation(
    IN PETHREAD Thread,
    IN PSE_IMPERSONATION_STATE ImpersonationState
    )

/*++

Routine Description:

    This routine temporarily disables the impersonation of a thread.
    The impersonation state is saved for quick replacement later.  The
    impersonation token is left referenced and a pointer to it is held
    in the IMPERSONATION_STATE data structure.

    PsRestoreImpersonation() must be used after this routine is called.



Arguments:

    Thread - points to the thread whose impersonation (if any) is to
        be temporarily disabled.

    ImpersonationState - receives the current impersonation information,
        including a pointer to the impersonation token.


Return Value:

    TRUE - Indicates the impersonation state has been saved and the
        impersonation has been temporarily disabled.

    FALSE - Indicates the specified thread was not impersonating a client.
       No action has been taken.

--*/

{


    PPS_IMPERSONATION_INFORMATION OldClient;
    PETHREAD CurrentThread;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);


    //
    // Capture the impersonation information (if there is any).
    // The vast majority of cases this function is called we are not impersonating. Skip acquiring
    // the lock in this case.
    //
    OldClient = NULL;
    if (PS_IS_THREAD_IMPERSONATING (Thread)) {
        //
        //  Lock the process security fields
        //
        CurrentThread = PsGetCurrentThread ();

        PspLockThreadSecurityExclusive (Thread, CurrentThread);

        //
        // Test and clear the impersonation bit. If we are still impersonating then capture the info.
        //
        if (PS_TEST_CLEAR_BITS (&Thread->CrossThreadFlags,
                                PS_CROSS_THREAD_FLAGS_IMPERSONATING)&
                PS_CROSS_THREAD_FLAGS_IMPERSONATING) {
            OldClient = Thread->ImpersonationInfo;
            ImpersonationState->Level         = OldClient->ImpersonationLevel;
            ImpersonationState->EffectiveOnly = OldClient->EffectiveOnly;
            ImpersonationState->CopyOnOpen    = OldClient->CopyOnOpen;
            ImpersonationState->Token         = OldClient->Token;
        }
        //
        //  Release the security fields
        //
        PspUnlockThreadSecurityExclusive (Thread, CurrentThread);
    }

    if (OldClient != NULL) {
        return TRUE;
    } else {
        //
        // Not impersonating.  Just make up some values.
        // The NULL for the token indicates we aren't impersonating.
        //
        ImpersonationState->Level         = SecurityAnonymous;
        ImpersonationState->EffectiveOnly = FALSE;
        ImpersonationState->CopyOnOpen    = FALSE;
        ImpersonationState->Token         = NULL;
        return FALSE;
    }
}



VOID
PsRestoreImpersonation(
    IN PETHREAD Thread,
    IN PSE_IMPERSONATION_STATE ImpersonationState
    )

/*++

Routine Description:

    This routine restores an impersonation that has been temporarily disabled
    using PsDisableImpersonation().

    Notice that if this routine finds the thread is already impersonating
    (again), then restoring the temporarily disabled impersonation will cause
    the current impersonation to be abandoned.



Arguments:

    Thread - points to the thread whose impersonation is to be restored.

    ImpersontionState - receives the current impersontion information,
        including a pointer ot the impersonation token.


Return Value:

    TRUE - Indicates the impersonation state has been saved and the
        impersonation has been temporarily disabled.

    FALSE - Indicates the specified thread was not impersonating a client.
       No action has been taken.

--*/

{

    PETHREAD CurrentThread;
    PACCESS_TOKEN OldToken;
    PPS_IMPERSONATION_INFORMATION ImpInfo;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);

    OldToken = NULL;

    //
    //  Lock the process security fields
    //

    CurrentThread = PsGetCurrentThread ();

    PspLockThreadSecurityExclusive (Thread, CurrentThread);

    ImpInfo = Thread->ImpersonationInfo;

    //
    // If the thread is currently impersonating then we must revert this
    //

    if (PS_IS_THREAD_IMPERSONATING (Thread)) {
        OldToken = ImpInfo->Token;
    }


    //
    // Restore the previous impersonation token if there was one
    //

    if (ImpersonationState->Token) {
        ImpInfo->ImpersonationLevel = ImpersonationState->Level;
        ImpInfo->EffectiveOnly      = ImpersonationState->EffectiveOnly;
        ImpInfo->CopyOnOpen         = ImpersonationState->CopyOnOpen;
        ImpInfo->Token              = ImpersonationState->Token;
        PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
    } else {
        PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
    }

    //
    //  Release the security fields
    //

    PspUnlockThreadSecurityExclusive (Thread, CurrentThread);

    if (OldToken != NULL) {
        ObDereferenceObject (OldToken);
    }

    return;

}


VOID
PsRevertToSelf( )

/*++

Routine Description:

    This routine causes the calling thread to discontinue
    impersonating a client.  If the thread is not currently
    impersonating a client, no action is taken.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PETHREAD Thread;
    PEPROCESS Process;
    PACCESS_TOKEN OldToken;

    PAGED_CODE();

    Thread = PsGetCurrentThread ();
    Process = THREAD_TO_PROCESS (Thread);

    //
    //  Lock the process security fields
    //
    PspLockThreadSecurityExclusive (Thread, Thread);

    //
    //  See if the thread is impersonating a client
    //  and dereference that token if so.
    //

    if (PS_IS_THREAD_IMPERSONATING (Thread)) {
        PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
        OldToken = Thread->ImpersonationInfo->Token;
    } else {
        OldToken = NULL;
    }

    //
    //  Release the security fields
    //
    PspUnlockThreadSecurityExclusive (Thread, Thread);


    //
    // Free the old client info...
    //
    if (OldToken != NULL) {
        ObDereferenceObject (OldToken);

        PspWriteTebImpersonationInfo (Thread, Thread);
    }

    return;
}


VOID
PsRevertThreadToSelf (
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine causes the specified thread to discontinue
    impersonating a client. If the thread is not currently
    impersonating a client, no action is taken.

Arguments:

    Thread - Thread to remove impersonation from

Return Value:

    None.

--*/

{
    PETHREAD CurrentThread;
    PACCESS_TOKEN OldToken;
    PPS_IMPERSONATION_INFORMATION ImpersonationInfo;

    PAGED_CODE();

    ASSERT (Thread->Tcb.Header.Type == ThreadObject);

    if (PS_IS_THREAD_IMPERSONATING (Thread)) {

        CurrentThread = PsGetCurrentThread ();

        //
        //  Lock the process security fields
        //
        PspLockThreadSecurityExclusive (Thread, CurrentThread);

        //
        //  See if the thread is impersonating a client
        //  and dereference that token if so.
        //
        if (PS_IS_THREAD_IMPERSONATING (Thread)) {
            //
            // Grab impersonation info block.
            //
            ImpersonationInfo = Thread->ImpersonationInfo;

            PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
            OldToken = ImpersonationInfo->Token;
        } else {
            OldToken = NULL;
        }

        //
        //  Release the security fields
        //
        PspUnlockThreadSecurityExclusive (Thread, CurrentThread);

        //
        // Free the old client info...
        //
        if (OldToken != NULL) {
            ObDereferenceObject (OldToken);
            PspWriteTebImpersonationInfo (Thread, CurrentThread);
        }
    }

    return;
}


NTSTATUS
PspInitializeProcessSecurity(
    IN PEPROCESS Parent OPTIONAL,
    IN PEPROCESS Child
    )

/*++

Routine Description:

    This function initializes a new process's security fields, including
    the assignment of a new primary token.

    The child process is assumed to not yet have been inserted into
    an object table.

    NOTE: IT IS EXPECTED THAT THIS SERVICE WILL BE CALLED WITH A NULL
          PARENT PROCESS POINTER EXACTLY ONCE - FOR THE INITIAL SYSTEM
          PROCESS.


Arguments:

    Parent - An optional pointer to the process being used as the parent
        of the new process.  If this value is NULL, then the process is
        assumed to be the initial system process, and the boot token is
        assigned rather than a duplicate of the parent process's primary
        token.

    Child - Supplies the address of the process being initialized.  This
        process does not yet require security field contention protection.
        In particular, the security fields may be accessed without first
        acquiring the process security fields lock.



Return Value:


--*/

{
    NTSTATUS Status;
    PACCESS_TOKEN ParentToken, NewToken;

    PAGED_CODE();

    //
    // Assign the primary token
    //

    if (ARGUMENT_PRESENT (Parent)) {

        //
        // create the primary token
        // This is a duplicate of the parent's token.
        //
        ParentToken = PsReferencePrimaryToken (Parent);

        Status = SeSubProcessToken (ParentToken,
                                    &NewToken,
                                    TRUE,
                                    MmGetSessionId (Child));

        PsDereferencePrimaryTokenEx (Parent, ParentToken);

        if (NT_SUCCESS(Status)) {
            ObInitializeFastReference (&Child->Token,
                                       NewToken);
        }

    } else {

        //
        //  Reference and assign the boot token
        //
        //  The use of a single boot access token assumes there is
        //  exactly one parentless process in the system - the initial
        //  process.  If this ever changes, this code will need to change
        //  to match the new condition (so that a token doesn't end up
        //  being shared by multiple processes.
        //

        ObInitializeFastReference (&Child->Token, NULL);
        SeAssignPrimaryToken (Child, PspBootAccessToken);
        Status = STATUS_SUCCESS;


    }

    return Status;

}

VOID
PspDeleteProcessSecurity(
    IN PEPROCESS Process
    )

/*++

Routine Description:

    This function cleans up a process's security fields as part of process
    deletion.  It is assumed no other references to the process can occur
    during or after a call to this routine.  This enables us to reference
    the process security fields without acquiring the lock protecting those
    fields.

    NOTE: It may be desirable to add auditing capability to this routine
          at some point.


Arguments:

    Process - A pointer to the process being deleted.


Return Value:

    None.

--*/

{

    PAGED_CODE();


    //
    // If we are deleting a process that didn't successfully complete
    // process initialization, then there may be no token associated
    // with it yet.
    //

    if (!ExFastRefObjectNull (Process->Token)) {
        SeDeassignPrimaryToken (Process);
    }

    return;
}


NTSTATUS
PspAssignPrimaryToken(
    IN PEPROCESS Process,
    IN HANDLE Token OPTIONAL,
    IN PACCESS_TOKEN TokenPointer OPTIONAL
    )

/*++

Routine Description:

    This function performs the security portions of primary token assignment.
    It is expected that the proper access to the process and thread objects,
    as well as necessary privilege, has already been established.

    A primary token can only be replaced if the process has no threads, or
    has one thread.  This is because the thread objects point to the primary
    token and must have those pointers updated when the primary token is
    changed.  This is only expected to be necessary at logon time, when
    the process is in its infancy and either has zero threads or maybe one
    inactive thread.

    If the assignment is successful, the old token is dereferenced and the
    new one is referenced.



Arguments:

    Process - A pointer to the process whose primary token is being
        replaced.

    Token - The handle value of the token to be assigned as the primary
        token.


Return Value:

    STATUS_SUCCESS - Indicates the primary token has been successfully
        replaced.

    STATUS_BAD_TOKEN_TYPE - Indicates the token is not of type TokenPrimary.

    STATUS_TOKEN_IN_USE - Indicates the token is already in use by
        another process.

    Other status may be returned when attempting to reference the token
    object.

--*/

{
    NTSTATUS Status;
    PACCESS_TOKEN NewToken, OldToken;
    KPROCESSOR_MODE PreviousMode;
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    if (TokenPointer == NULL) {
        PreviousMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

        //
        // Reference the specified token, and make sure it can be assigned
        // as a primary token.
        //

        Status = ObReferenceObjectByHandle (Token,
                                            TOKEN_ASSIGN_PRIMARY,
                                            SeTokenObjectType,
                                            PreviousMode,
                                            &NewToken,
                                            NULL);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    } else {
        NewToken = TokenPointer;
    }


    //
    // This routine makes sure the NewToken is suitable for assignment
    // as a primary token.
    //

    Status = SeExchangePrimaryToken (Process, NewToken, &OldToken);


    //
    // Acquire and release the process security lock to force any slow
    // referencers out of the slow path.
    //

    PspLockProcessSecurityExclusive (Process, CurrentThread);
    PspUnlockProcessSecurityExclusive (Process, CurrentThread);

    //
    // Free the old token (we don't need it).
    // This can't be done while the security fields are locked.
    //

    if (NT_SUCCESS (Status)) {
        ObDereferenceObject (OldToken);
    }

    //
    // Undo the handle reference
    //

    if (TokenPointer == NULL) {
        ObDereferenceObject (NewToken);
    }


    return Status;
}


VOID
PspInitializeThreadSecurity(
    IN PEPROCESS Process,
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This function initializes a new thread's security fields.


Arguments:

    Process - Points to the process the thread belongs to.

    Thread - Points to the thread object being initialized.


Return Value:

    None.

--*/

{

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Process);
    //
    // Initially not impersonating anyone. This is not currently called as we zero out the entire thread at create time anyway
    //

    Thread->ImpersonationInfo = NULL;
    PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);

    return;

}


VOID
PspDeleteThreadSecurity(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This function cleans up a thread's security fields as part of thread
    deletion.  It is assumed no other references to the thread can occur
    during or after a call to this routine, so no locking is necessary
    to access the thread security fields.


Arguments:

    Thread - A pointer to the thread being deleted.


Return Value:

    None.

--*/

{
    PPS_IMPERSONATION_INFORMATION ImpersonationInfo;

    PAGED_CODE();

    ImpersonationInfo = Thread->ImpersonationInfo;
    //
    // clean-up client information, if there is any.
    //
    if (PS_IS_THREAD_IMPERSONATING (Thread)) {
        ObDereferenceObject (ImpersonationInfo->Token);
    }

    if (ImpersonationInfo != NULL) {
        ExFreePoolWithTag (ImpersonationInfo, 'mIsP'|PROTECTED_POOL);
        PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
        Thread->ImpersonationInfo = NULL;
    }

    return;

}

NTSTATUS
PspWriteTebImpersonationInfo (
    IN PETHREAD Thread,
    IN PETHREAD CurrentThread
    )
/*++

Routine Description:

    This function updates the thread TEB fields to reflect the impersonation status
    of the thread.


Arguments:

    Thread - A pointer to the thread whose impersonation token has been changed

    CurrentThread - The current thread

Return Value:

    NTSTATUS - Status of operation

--*/
{
    PTEB Teb;
    BOOLEAN  AttachedToProcess = FALSE;
    PEPROCESS ThreadProcess;
    BOOLEAN Impersonating;
    KAPC_STATE ApcState;

    PAGED_CODE();

    ASSERT (CurrentThread == PsGetCurrentThread ());

    ThreadProcess = THREAD_TO_PROCESS (Thread);

    Teb = Thread->Tcb.Teb;

    if (Teb != NULL) {
        if (PsGetCurrentProcessByThread (CurrentThread) != ThreadProcess) {
            KeStackAttachProcess (&ThreadProcess->Pcb, &ApcState);
            AttachedToProcess = TRUE;
        }

        //
        // We are doing a cross thread TEB reference here. Protect against the TEB being freed and used by
        // somebody else.
        //
        if (Thread == CurrentThread || ExAcquireRundownProtection (&Thread->RundownProtect)) {

            while (1) {

                Impersonating = (BOOLEAN) PS_IS_THREAD_IMPERSONATING (Thread);

                //
                // The TEB may still raise an exception in low memory conditions so we need try/except here
                //

                try {
                    if (Impersonating) {
                        Teb->ImpersonationLocale = (LCID)-1;
                        Teb->IsImpersonating = 1;
                    } else {
                        Teb->ImpersonationLocale = (LCID) 0;
                        Teb->IsImpersonating = 0;
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                }

                KeMemoryBarrier ();

                if (Impersonating == (BOOLEAN) PS_IS_THREAD_IMPERSONATING (Thread)) {
                    break;
                }

            }

            if (Thread != CurrentThread) {
                ExReleaseRundownProtection (&Thread->RundownProtect);
            }
        }

        if (AttachedToProcess) {
            KeUnstackDetachProcess (&ApcState);
        }
    }
    return STATUS_SUCCESS;
}



NTSTATUS
PsAssignImpersonationToken(
    IN PETHREAD Thread,
    IN HANDLE Token
    )

/*++

Routine Description:

    This function performs the security portions of establishing an
    impersonation token.  This routine is expected to be used only in
    the case where the subject has asked for impersonation explicitly
    providing an impersonation token.  Other services are provided for
    use by communication session layers that need to establish an
    impersonation on a server's behalf.

    It is expected that the proper access to the thread object has already
    been established.

    The following rules apply:

         1) The caller must have TOKEN_IMPERSONATE access to the token
            for any action to be taken.

         2) If the token may NOT be used for impersonation (e.g., not an
            impersonation token) no action is taken.

         3) Otherwise, any existing impersonation token is dereferenced and
            the new token is established as the impersonation token.



Arguments:

    Thread - A pointer to the thread whose impersonation token is being
        set.

    Token - The handle value of the token to be assigned as the impersonation
        token.  If this value is NULL, then current impersonation (if any)
        is terminated and no new impersonation is established.


Return Value:

    STATUS_SUCCESS - Indicates the primary token has been successfully
        replaced.

    STATUS_BAD_TOKEN_TYPE - Indicates the token is not of type
        TokenImpersonation.

    Other status may be returned when attempting to reference the token
    object.

--*/

{
    NTSTATUS Status;
    PACCESS_TOKEN NewToken;
    KPROCESSOR_MODE PreviousMode;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PETHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    if (!ARGUMENT_PRESENT (Token)) {

        PsRevertThreadToSelf (Thread);

        Status = STATUS_SUCCESS;
    } else {

        PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

        //
        // Reference the specified token for TOKEN_IMPERSONATE access
        //

        Status = ObReferenceObjectByHandle (Token,
                                            TOKEN_IMPERSONATE,
                                            SeTokenObjectType,
                                            PreviousMode,
                                            &NewToken,
                                            NULL);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        //
        // Make sure the token is an impersonation token.
        //

        if (SeTokenType (NewToken) != TokenImpersonation) {
            ObDereferenceObject (NewToken);
            return STATUS_BAD_TOKEN_TYPE;
        }

        ImpersonationLevel = SeTokenImpersonationLevel (NewToken);

        //
        // The rest can be done by PsImpersonateClient.
        //
        // PsImpersonateClient will reference the passed token
        // on success.
        //

        Status = PsImpersonateClient (Thread,
                                      NewToken,
                                      FALSE,          // CopyOnOpen
                                      FALSE,          // EffectiveOnly
                                      ImpersonationLevel);


        //
        // Dereference the passed token.
        //
        //

        ObDereferenceObject (NewToken);
    }

    return Status;
}

#undef PsDereferencePrimaryToken

#pragma alloc_text(PAGE, PsDereferencePrimaryToken)

VOID
PsDereferencePrimaryToken(
    IN PACCESS_TOKEN PrimaryToken
    )
/*++

Routine Description:

    Returns the reference obtained via PsReferencePrimaryToken

Arguments:

    Returns the reference

Return Value:

    None.

--*/
{
    PAGED_CODE();

    ObDereferenceObject (PrimaryToken);
}

#undef PsDereferenceImpersonationToken

#pragma alloc_text(PAGE, PsDereferenceImpersonationToken)

VOID
PsDereferenceImpersonationToken(
    IN PACCESS_TOKEN ImpersonationToken
    )
/*++

Routine Description:

    Returns the reference obtained via PsReferenceImpersonationToken

Arguments:

    Returns the reference

Return Value:

    None.


--*/
{
    PAGED_CODE();

    if (ImpersonationToken != NULL) {
        ObDereferenceObject (ImpersonationToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\psspnd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psspnd.c

Abstract:

    This module implements NtSuspendThread and NtResumeThread

Author:

    Mark Lucovsky (markl) 25-May-1989

Revision History:

--*/

#include "psp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtSuspendThread)
#pragma alloc_text(PAGE, NtResumeThread)
#pragma alloc_text(PAGE, NtAlertThread)
#pragma alloc_text(PAGE, NtAlertResumeThread)
#pragma alloc_text(PAGE, NtTestAlert)
#pragma alloc_text(PAGE, NtSuspendProcess)
#pragma alloc_text(PAGE, NtResumeProcess)

#pragma alloc_text(PAGE, PsSuspendThread)
#pragma alloc_text(PAGE, PsSuspendProcess)
#pragma alloc_text(PAGE, PsResumeProcess)
#pragma alloc_text(PAGE, PsResumeThread)
#endif

NTSTATUS
PsSuspendThread (
    IN PETHREAD Thread,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )
/*++

Routine Description:

    This function suspends the target thread, and optionally
    returns the previous suspend count.

Arguments:

    ThreadHandle - Supplies a handle to the thread object to suspend.

    PreviousSuspendCount - An optional parameter, that if specified
        points to a variable that receives the thread's previous suspend
        count.

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    ULONG LocalPreviousSuspendCount = 0;

    PAGED_CODE();

    if (Thread == PsGetCurrentThread ()) {
        try {
            LocalPreviousSuspendCount = (ULONG) KeSuspendThread (&Thread->Tcb);
            Status = STATUS_SUCCESS;
        } except ((GetExceptionCode () == STATUS_SUSPEND_COUNT_EXCEEDED)?
                     EXCEPTION_EXECUTE_HANDLER :
                     EXCEPTION_CONTINUE_SEARCH) {
            Status = GetExceptionCode();
        }
    } else {
        //
        // Protect the remote thread from being rundown.
        //
        if (ExAcquireRundownProtection (&Thread->RundownProtect)) {

            //
            // Don't allow suspend if we are being deleted
            //
            if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_TERMINATED) {
                Status = STATUS_THREAD_IS_TERMINATING;
            } else {
                try {
                    LocalPreviousSuspendCount = (ULONG) KeSuspendThread (&Thread->Tcb);
                    Status = STATUS_SUCCESS;
                } except ((GetExceptionCode () == STATUS_SUSPEND_COUNT_EXCEEDED)?
                              EXCEPTION_EXECUTE_HANDLER :
                              EXCEPTION_CONTINUE_SEARCH) {
                    Status = GetExceptionCode();
                }
                //
                // If deletion was started after we suspended then wake up the thread
                //
                if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_TERMINATED) {
                    KeForceResumeThread (&Thread->Tcb);
                    LocalPreviousSuspendCount = 0;
                    Status = STATUS_THREAD_IS_TERMINATING;
                }
            }
            ExReleaseRundownProtection (&Thread->RundownProtect);
        } else {
            Status = STATUS_THREAD_IS_TERMINATING;
        }
    }

    if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
        *PreviousSuspendCount = LocalPreviousSuspendCount;
    }
    return Status;
}

NTSTATUS
PsSuspendProcess (
    PEPROCESS Process
    )
/*++

Routine Description:

    This function suspends all the PS threads in a process.

Arguments:

    Process - Process whose threads are to be suspended

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    NTSTATUS Status;
    PETHREAD Thread;

    PAGED_CODE ();


    if (ExAcquireRundownProtection (&Process->RundownProtect)) {

        for (Thread = PsGetNextProcessThread (Process, NULL);
             Thread != NULL;
             Thread = PsGetNextProcessThread (Process, Thread)) {

            PsSuspendThread (Thread, NULL);
        }

        ExReleaseRundownProtection (&Process->RundownProtect);

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_PROCESS_IS_TERMINATING;
    }

    return Status;
}

NTSTATUS
PsResumeProcess (
    PEPROCESS Process
    )
/*++

Routine Description:

    This function resumes all the PS threads in a process.

Arguments:

    Process - Process whose threads are to be suspended

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    NTSTATUS Status;
    PETHREAD Thread;

    PAGED_CODE ();

    if (ExAcquireRundownProtection (&Process->RundownProtect)) {

        for (Thread = PsGetNextProcessThread (Process, NULL);
             Thread != NULL;
             Thread = PsGetNextProcessThread (Process, Thread)) {

            KeResumeThread (&Thread->Tcb);
        }

        ExReleaseRundownProtection (&Process->RundownProtect);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_PROCESS_IS_TERMINATING;
    }

    return Status;
}

NTSTATUS
NtSuspendThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )

/*++

Routine Description:

    This function suspends the target thread, and optionally
    returns the previous suspend count.

Arguments:

    ThreadHandle - Supplies a handle to the thread object to suspend.

    PreviousSuspendCount - An optional parameter, that if specified
        points to a variable that receives the thread's previous suspend
        count.

Return Value:

    NTSTATUS - Status of operation.

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    ULONG LocalPreviousSuspendCount;
    KPROCESSOR_MODE Mode;

    PAGED_CODE();

    Mode = KeGetPreviousMode ();

    try {

        if (Mode != KernelMode) {
            if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
                ProbeForWriteUlong (PreviousSuspendCount);
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    st = ObReferenceObjectByHandle (ThreadHandle,
                                    THREAD_SUSPEND_RESUME,
                                    PsThreadType,
                                    Mode,
                                    &Thread,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    st = PsSuspendThread (Thread, &LocalPreviousSuspendCount);

    ObDereferenceObject (Thread);

    try {

        if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
            *PreviousSuspendCount = LocalPreviousSuspendCount;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        st = GetExceptionCode ();

    }

    return st;

}

NTSTATUS
PsResumeThread (
    IN PETHREAD Thread,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )
/*++

Routine Description:

    This function resumes a thread that was previously suspened

Arguments:

    Thread - Thread to resume
    
    PreviousSuspendCount - Optional address of a ULONG to place the previous suspend count in

Return Value:

    NTSTATUS - Status of call

--*/
{
    ULONG LocalPreviousSuspendCount;

    PAGED_CODE();

    LocalPreviousSuspendCount = (ULONG) KeResumeThread (&Thread->Tcb);

    if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
        *PreviousSuspendCount = LocalPreviousSuspendCount;
    }
    
    return STATUS_SUCCESS;
}


NTSTATUS
NtResumeThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )

/*++

Routine Description:

    This function resumes a thread that was previously suspened

Arguments:

    ThreadHandle - Handle to thread to resume
    
    PreviousSuspendCount - Optional address of a ULONG to place the previous suspend count in

Return Value:

    NTSTATUS - Status of call

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    KPROCESSOR_MODE Mode;
    ULONG LocalPreviousSuspendCount;

    PAGED_CODE();

    Mode = KeGetPreviousMode ();

    try {

        if (Mode != KernelMode) {
            if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
                ProbeForWriteUlong (PreviousSuspendCount);
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode ();
    }

    st = ObReferenceObjectByHandle (ThreadHandle,
                                    THREAD_SUSPEND_RESUME,
                                    PsThreadType,
                                    Mode,
                                    &Thread,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    PsResumeThread (Thread, &LocalPreviousSuspendCount);

    ObDereferenceObject (Thread);

    try {
        if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
            *PreviousSuspendCount = LocalPreviousSuspendCount;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode ();
    }

    return STATUS_SUCCESS;

}

NTSTATUS
NtSuspendProcess (
    IN HANDLE ProcessHandle
    )
/*++

Routine Description:

    This function suspends all none-exiting threads in the target process

Arguments:

    ProcessHandle - Supplies an open handle to the process to be suspened

Return Value:

    NTSTATUS - Status of operation

--*/
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROCESS Process;

    PAGED_CODE();


    PreviousMode = KeGetPreviousMode ();

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (NT_SUCCESS (Status)) {
        Status = PsSuspendProcess (Process);
        ObDereferenceObject (Process);
    }

    return Status;
}

NTSTATUS
NtResumeProcess (
    IN HANDLE ProcessHandle
    )
/*++

Routine Description:

    This function suspends all none-exiting threads in the target process

Arguments:

    ProcessHandle - Supplies an open handle to the process to be suspened

Return Value:

    NTSTATUS - Status of operation

--*/
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROCESS Process;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode ();

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (NT_SUCCESS (Status)) {
        Status = PsResumeProcess (Process);
        ObDereferenceObject (Process);
    }

    return Status;
}

NTSTATUS
NtAlertThread(
    IN HANDLE ThreadHandle
    )

/*++

Routine Description:

    This function alerts the target thread using the previous mode
    as the mode of the alert.

Arguments:

    ThreadHandle - Supplies an open handle to the thread to be alerted

Return Value:

    NTSTATUS - Status of operation

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    KPROCESSOR_MODE Mode;

    PAGED_CODE();

    Mode = KeGetPreviousMode ();

    st = ObReferenceObjectByHandle (ThreadHandle,
                                    THREAD_ALERT,
                                    PsThreadType,
                                    Mode,
                                    &Thread,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    KeAlertThread (&Thread->Tcb,Mode);

    ObDereferenceObject (Thread);

    return STATUS_SUCCESS;

}


NTSTATUS
NtAlertResumeThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    NTSTATUS - Status of operation

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    ULONG LocalPreviousSuspendCount;
    KPROCESSOR_MODE Mode;

    PAGED_CODE();

    Mode = KeGetPreviousMode ();

    try {


        if (Mode != KernelMode ) {
            if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
                ProbeForWriteUlong (PreviousSuspendCount);
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    st = ObReferenceObjectByHandle (ThreadHandle,
                                    THREAD_SUSPEND_RESUME,
                                    PsThreadType,
                                    Mode,
                                    &Thread,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    LocalPreviousSuspendCount = (ULONG) KeAlertResumeThread (&Thread->Tcb);

    ObDereferenceObject (Thread);

    try {

        if (ARGUMENT_PRESENT (PreviousSuspendCount)) {
            *PreviousSuspendCount = LocalPreviousSuspendCount;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode ();
    }

    return STATUS_SUCCESS;
}


NTSTATUS
NtTestAlert(
    VOID
    )

/*++

Routine Description:

    This function tests the alert flag inside the current thread. If
    an alert is pending for the previous mode, then the alerted status
    is returned, pending APC's may also be delivered at this time.

Arguments:

    None

Return Value:

    STATUS_ALERTED - An alert was pending for the current thread at the
        time this function was called.

    STATUS_SUCCESS - No alert was pending for this thread.

--*/

{

    PAGED_CODE();

    if (KeTestAlertThread(KeGetPreviousMode ())) {
        return STATUS_ALERTED;
    } else {
        return STATUS_SUCCESS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\amd64\psctxamd64.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    psctx.c

Abstract:

    This procedure implements Get/Set Context Thread

Author:

    David N. Cutler (davec) 20-Oct-2000

Revision History:

--*/

#include "psp.h"

#pragma alloc_text(PAGE, PspGetContext)
#pragma alloc_text(PAGE, PspGetSetContextSpecialApc)
#pragma alloc_text(PAGE, PspSetContext)

VOID
PspGetContext (
    IN PKTRAP_FRAME TrapFrame,
    IN PKNONVOLATILE_CONTEXT_POINTERS ContextPointers,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function selectively moves the contents of the specified trap frame
    and nonvolatile context to the specified context record.

Arguments:

    TrapFrame - Supplies the contents of a trap frame.

    ContextPointers - Supplies the address of context pointers record.

    ContextRecord - Supplies the address of a context record.

Return Value:

    None.

--*/

{

    ULONG ContextFlags;
    PLEGACY_SAVE_AREA NpxFrame;

    PAGED_CODE();

    //
    // Get control information if specified.
    //

    ContextFlags = ContextRecord->ContextFlags;
    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers RIP, CS, RSP, SS, and EFlags.
        //

        ContextRecord->Rip = TrapFrame->Rip;
        ContextRecord->SegCs = TrapFrame->SegCs;
        ContextRecord->SegSs = TrapFrame->SegSs;
        ContextRecord->Rsp = TrapFrame->Rsp;
        ContextRecord->EFlags = TrapFrame->EFlags;
    }

    //
    // Get segment register contents if specified.
    //

    if ((ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {

        //
        // Set segment registers GS, FS, ES, DS.
        //

        ContextRecord->SegDs = KGDT64_R3_DATA | RPL_MASK;
        ContextRecord->SegEs = KGDT64_R3_DATA | RPL_MASK;
        ContextRecord->SegFs = KGDT64_R3_CMTEB | RPL_MASK;
        ContextRecord->SegGs = KGDT64_R3_DATA | RPL_MASK;
    }

    //
    //  Get integer register contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers RAX, RCX, RDX, RSI, RDI, R8, R9, R10, RBX,
        // RBP, R11, R12, R13, R14, and R15.
        //

        ContextRecord->Rax = TrapFrame->Rax;
        ContextRecord->Rcx = TrapFrame->Rcx;
        ContextRecord->Rdx = TrapFrame->Rdx;
        ContextRecord->R8 = TrapFrame->R8;
        ContextRecord->R9 = TrapFrame->R9;
        ContextRecord->R10 = TrapFrame->R10;
        ContextRecord->R11 = TrapFrame->R11;

        ContextRecord->Rbx = *ContextPointers->Rbx;
        ContextRecord->Rbp = *ContextPointers->Rbp;
        ContextRecord->Rsi = *ContextPointers->Rsi;
        ContextRecord->Rdi = *ContextPointers->Rdi;
        ContextRecord->R12 = *ContextPointers->R12;
        ContextRecord->R13 = *ContextPointers->R13;
        ContextRecord->R14 = *ContextPointers->R14;
        ContextRecord->R15 = *ContextPointers->R15;
    }

    //
    // Get floating point context if specified.
    //


    if ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

        //
        // Set XMM registers Xmm0-Xmm15 and the XMM CSR contents.
        //

        RtlCopyMemory(&ContextRecord->Xmm0,
                      &TrapFrame->Xmm0,
                      sizeof(M128) * 6);

        ContextRecord->Xmm6 = *ContextPointers->Xmm6;
        ContextRecord->Xmm7 = *ContextPointers->Xmm7;
        ContextRecord->Xmm8 = *ContextPointers->Xmm8;
        ContextRecord->Xmm9 = *ContextPointers->Xmm9;
        ContextRecord->Xmm10 = *ContextPointers->Xmm10;
        ContextRecord->Xmm11 = *ContextPointers->Xmm11;
        ContextRecord->Xmm12 = *ContextPointers->Xmm12;
        ContextRecord->Xmm13 = *ContextPointers->Xmm13;
        ContextRecord->Xmm14 = *ContextPointers->Xmm14;
        ContextRecord->Xmm15 = *ContextPointers->Xmm15;

        ContextRecord->MxCsr = TrapFrame->MxCsr;

        //
        // If the specified mode is user, then also set the legacy floating
        // point state.
        //

        if ((TrapFrame->SegCs & MODE_MASK) == UserMode) {
            NpxFrame = (PLEGACY_SAVE_AREA)(TrapFrame + 1);
            RtlCopyMemory(&ContextRecord->FltSave,
                          NpxFrame,
                          sizeof(LEGACY_SAVE_AREA));
        }
    }

    //
    //
    // Get debug register contents if requested.
    //

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {

        //
        // Set the debug registers DR0, DR1, DR2, DR3, DR6, and DR7.
        //

        if ((TrapFrame->Dr7 & DR7_ACTIVE) != 0) {
            ContextRecord->Dr0 = TrapFrame->Dr0;
            ContextRecord->Dr1 = TrapFrame->Dr1;
            ContextRecord->Dr2 = TrapFrame->Dr2;
            ContextRecord->Dr3 = TrapFrame->Dr3;
            ContextRecord->Dr6 = TrapFrame->Dr6;
            ContextRecord->Dr7 = TrapFrame->Dr7;

        } else {
            ContextRecord->Dr0 = 0;
            ContextRecord->Dr1 = 0;
            ContextRecord->Dr2 = 0;
            ContextRecord->Dr3 = 0;
            ContextRecord->Dr6 = 0;
            ContextRecord->Dr7 = 0;
        }
    }

    return;
}

VOID
PspSetContext (
    OUT PKTRAP_FRAME TrapFrame,
    OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers,
    IN PCONTEXT ContextRecord,
    KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This function selectively moves the contents of the specified context
    record to the specified trap frame and nonvolatile context.

Arguments:

    TrapFrame - Supplies the address of a trap frame.

    ContextPointers - Supplies the address of a context pointers record.

    ContextRecord - Supplies the address of a context record.

    ProcessorMode - Supplies the processor mode to use when sanitizing
        the PSR and FSR.

Return Value:

    None.

--*/

{

    ULONG ContextFlags;
    PLEGACY_SAVE_AREA NpxFrame;

    PAGED_CODE();

    //
    // Set control information if specified.
    //

    ContextFlags = ContextRecord->ContextFlags;
    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers RIP, RSP, and EFlags.
        //

        TrapFrame->EFlags = SANITIZE_EFLAGS(ContextRecord->EFlags, PreviousMode);
        TrapFrame->Rip = ContextRecord->Rip;
        TrapFrame->Rsp = ContextRecord->Rsp;

        //
        // The segment registers DS, ES, FS, and GS are never restored from saved
        // data. However, SS and CS are restored from the trap frame. Make sure
        // that these segment registers have the proper values.
        //

        if (PreviousMode == UserMode) {
            TrapFrame->SegSs = KGDT64_R3_DATA | RPL_MASK;
            if (ContextRecord->SegCs != (KGDT64_R3_CODE | RPL_MASK)) {
                TrapFrame->SegCs = KGDT64_R3_CMCODE | RPL_MASK;

            } else {
                TrapFrame->SegCs = KGDT64_R3_CODE | RPL_MASK;
            }

        } else {
            TrapFrame->SegCs = KGDT64_R0_CODE;
            TrapFrame->SegSs = KGDT64_NULL;
        }
    }


    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers RAX, RCX, RDX, RSI, RDI, R8, R9, R10, RBX,
        // RBP, R11, R12, R13, R14, and R15.
        //

        TrapFrame->Rax = ContextRecord->Rax;
        TrapFrame->Rcx = ContextRecord->Rcx;
        TrapFrame->Rdx = ContextRecord->Rdx;
        TrapFrame->R8 = ContextRecord->R8;
        TrapFrame->R9 = ContextRecord->R9;
        TrapFrame->R10 = ContextRecord->R10;
        TrapFrame->R11 = ContextRecord->R11;

        *ContextPointers->Rbx = ContextRecord->Rbx;
        *ContextPointers->Rbp = ContextRecord->Rbp;
        *ContextPointers->Rsi = ContextRecord->Rsi;
        *ContextPointers->Rdi = ContextRecord->Rdi;
        *ContextPointers->R12 = ContextRecord->R12;
        *ContextPointers->R13 = ContextRecord->R13;
        *ContextPointers->R14 = ContextRecord->R14;
        *ContextPointers->R15 = ContextRecord->R15;
    }

    //
    // Set floating register contents if requested.
    //

    if ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

        //
        // Set XMM registers Xmm0-Xmm15 and the XMM CSR contents.
        //

        RtlCopyMemory(&TrapFrame->Xmm0,
                      &ContextRecord->Xmm0,
                      sizeof(M128) * 6);

        *ContextPointers->Xmm6 = ContextRecord->Xmm6;
        *ContextPointers->Xmm7 = ContextRecord->Xmm7;
        *ContextPointers->Xmm8 = ContextRecord->Xmm8;
        *ContextPointers->Xmm9 = ContextRecord->Xmm9;
        *ContextPointers->Xmm10 = ContextRecord->Xmm10;
        *ContextPointers->Xmm11 = ContextRecord->Xmm11;
        *ContextPointers->Xmm12 = ContextRecord->Xmm12;
        *ContextPointers->Xmm13 = ContextRecord->Xmm13;
        *ContextPointers->Xmm14 = ContextRecord->Xmm14;
        *ContextPointers->Xmm15 = ContextRecord->Xmm15;

        //
        // Clear all reserved bits in MXCSR.
        //

        TrapFrame->MxCsr = SANITIZE_MXCSR(ContextRecord->MxCsr);

        //
        // If the specified mode is user, then also set the legacy floating
        // point state.
        //

        if (PreviousMode == UserMode) {

            //
            // Set the floating state MM0/ST0 - MM7/ST7 and the control state.
            //

            NpxFrame = (PLEGACY_SAVE_AREA)(TrapFrame + 1);
            RtlCopyMemory(NpxFrame,
                          &ContextRecord->FltSave,
                          sizeof(LEGACY_SAVE_AREA));
        }
    }

    //
    // Set debug register state if specified.
    //

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {

        //
        // Set the debug registers DR0, DR1, DR2, DR3, DR6, and DR7.
        //

        TrapFrame->Dr0 = SANITIZE_DRADDR(ContextRecord->Dr0, PreviousMode);
        TrapFrame->Dr1 = SANITIZE_DRADDR(ContextRecord->Dr1, PreviousMode);
        TrapFrame->Dr2 = SANITIZE_DRADDR(ContextRecord->Dr2, PreviousMode);
        TrapFrame->Dr3 = SANITIZE_DRADDR(ContextRecord->Dr3, PreviousMode);
        TrapFrame->Dr6 = 0;
        TrapFrame->Dr7 = SANITIZE_DR7(ContextRecord->Dr7, PreviousMode);
        if (PreviousMode != KernelMode) {
            KeGetCurrentThread()->Header.DebugActive =
                                (BOOLEAN)((TrapFrame->Dr7 & DR7_ACTIVE) != 0);
        }
    }

    return;
}

VOID
PspGetSetContextSpecialApc (
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function either captures the user mode state of the current thread,
    or sets the user mode state of the current thread. The operation type is
    determined by the value of SystemArgument1. A NULL value is used for get
    context, and a non-NULL value is used for set context.

Arguments:

    Apc - Supplies a pointer to the APC control object that caused entry
          into this routine.

    NormalRoutine - Supplies a pointer to a pointer to the normal routine
        function that was specifed when the APC was initialized.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointer to two
        arguments that contain untyped data.

Return Value:

    None.

--*/

{

    PGETSETCONTEXT ContextBlock;
    PKNONVOLATILE_CONTEXT_POINTERS ContextPointers;
    CONTEXT ContextRecord;
    ULONG64 ControlPc;
    ULONG64 EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 ImageBase;
    PLEGACY_SAVE_AREA NpxFrame;
    ULONG64 TrapFrame;
    PETHREAD Thread;

    UNREFERENCED_PARAMETER(NormalRoutine);
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument2);

    PAGED_CODE();

    //
    // Get the address of the context block and compute the address of the
    // system entry trap frame.
    //

    ContextBlock = CONTAINING_RECORD(Apc, GETSETCONTEXT, Apc);
    ContextPointers = &ContextBlock->NonVolatileContext;

    Thread = Apc->SystemArgument2;

    EstablisherFrame = 0;

    TrapFrame = 0;

    if (ContextBlock->Mode == KernelMode) {
        TrapFrame = (ULONG64)Thread->Tcb.TrapFrame;
    }

    if (TrapFrame == 0) {
        TrapFrame = (ULONG64)PspGetBaseTrapFrame(Thread);
    }

    //
    // Capture the current thread context and set the initial control PC
    // value.
    //

    RtlCaptureContext(&ContextRecord);

    //
    // Initialize context pointers for the nonvolatile integer and floating
    // registers.
    //

#if DBG

    RtlZeroMemory(ContextPointers, sizeof(KNONVOLATILE_CONTEXT_POINTERS));

#endif

    ContextPointers->Rbx = &ContextRecord.Rbx;
    ContextPointers->Rsp = &ContextRecord.Rsp;
    ContextPointers->Rbp = &ContextRecord.Rbp;
    ContextPointers->Rsi = &ContextRecord.Rsi;
    ContextPointers->Rdi = &ContextRecord.Rdi;
    ContextPointers->R12 = &ContextRecord.R12;
    ContextPointers->R13 = &ContextRecord.R13;
    ContextPointers->R14 = &ContextRecord.R14;
    ContextPointers->R15 = &ContextRecord.R15;

    ContextPointers->Xmm6 = &ContextRecord.Xmm6;
    ContextPointers->Xmm7 = &ContextRecord.Xmm7;
    ContextPointers->Xmm8 = &ContextRecord.Xmm8;
    ContextPointers->Xmm9 = &ContextRecord.Xmm9;
    ContextPointers->Xmm10 = &ContextRecord.Xmm10;
    ContextPointers->Xmm11 = &ContextRecord.Xmm11;
    ContextPointers->Xmm12 = &ContextRecord.Xmm12;
    ContextPointers->Xmm13 = &ContextRecord.Xmm13;
    ContextPointers->Xmm14 = &ContextRecord.Xmm14;
    ContextPointers->Xmm15 = &ContextRecord.Xmm15;

    //
    // Start with the frame specified by the context record and virtually
    // unwind call frames until the system entry trap frame is encountered.
    //

    do {

        //
        // Lookup the function table entry using the point at which control
        // left the function.
        //

        ControlPc = ContextRecord.Rip;
        FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, NULL);

        //
        // If there is a function table entry for the routine, then virtually
        // unwind to the caller of the current routine to obtain the address
        // where control left the caller. Otherwise, the function is a leaf
        // function and the return address register contains the address of
        // where control left the caller.
        //

        if (FunctionEntry != NULL) {
            RtlVirtualUnwind(UNW_FLAG_EHANDLER,
                             ImageBase,
                             ControlPc,
                             FunctionEntry,
                             &ContextRecord,
                             &HandlerData,
                             &EstablisherFrame,
                             ContextPointers);

        } else {
            ContextRecord.Rip = *(PULONG64)(ContextRecord.Rsp);
            ContextRecord.Rsp += 8;
        }

    } while (EstablisherFrame != TrapFrame);

    //
    // If system argument one is nonzero, then set the context of the current
    // thread. Otherwise, get the context of the current thread.
    //

    if (*SystemArgument1 != NULL) {

        //
        // Set context.
        //
        // If the legacy state is switch, then save the the legacy floating
        // state, set the context, and restore the legacy floating state.
        // Otherwise, set the context.
        //

        if (Thread->Tcb.NpxState == LEGACY_STATE_SWITCH) {
            NpxFrame = (PLEGACY_SAVE_AREA)((PKTRAP_FRAME)TrapFrame + 1);
            KeSaveLegacyFloatingPointState(NpxFrame);
            PspSetContext((PKTRAP_FRAME)TrapFrame,
                          ContextPointers,
                          &ContextBlock->Context,
                          ContextBlock->Mode);

            KeRestoreLegacyFloatingPointState(NpxFrame);

        } else {
            PspSetContext((PKTRAP_FRAME)TrapFrame,
                          ContextPointers,
                          &ContextBlock->Context,
                          ContextBlock->Mode);
        }

    } else {

        //
        // Get context.
        //
        // If the legacy state is switch, then save the legacy floating state
        // and get the context.
        //
        // N.B. The legacy floating state is saved and restored. The reason
        //      this is necessary is that saving the legacy floating state
        //      alters some of the state.
        //
    
        if (Thread->Tcb.NpxState == LEGACY_STATE_SWITCH) {
            NpxFrame = (PLEGACY_SAVE_AREA)((PKTRAP_FRAME)TrapFrame + 1);
            KeSaveLegacyFloatingPointState(NpxFrame);
            KeRestoreLegacyFloatingPointState(NpxFrame);
        }
    
        PspGetContext((PKTRAP_FRAME)TrapFrame,
                       ContextPointers,
                       &ContextBlock->Context);
    }

    KeSetEvent(&ContextBlock->OperationComplete, 0, FALSE);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\psquery.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psquery.c

Abstract:

    This module implements the set and query functions for
    process and thread objects.

Author:

    Mark Lucovsky (markl) 17-Aug-1989


Revision History:

--*/

#include "psp.h"
#include "winerror.h"

#if defined(_WIN64)
#include <wow64t.h>
#endif

//
// Process Pooled Quota Usage and Limits
//  NtQueryInformationProcess using ProcessPooledUsageAndLimits
//

//
// this is the csrss process !
//
extern PEPROCESS ExpDefaultErrorPortProcess;
BOOLEAN PsWatchEnabled = FALSE;



#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
const KPRIORITY PspPriorityTable[PROCESS_PRIORITY_CLASS_ABOVE_NORMAL+1] = {8,4,8,13,24,6,10};


NTSTATUS
PsConvertToGuiThread(
    VOID
    );

NTSTATUS
PspQueryWorkingSetWatch(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    );

NTSTATUS
PspQueryQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    );

NTSTATUS
PspQueryPooledQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    );

NTSTATUS
PspSetQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    IN KPROCESSOR_MODE PreviousMode
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PsEstablishWin32Callouts)
#pragma alloc_text(PAGE, PsConvertToGuiThread)
#pragma alloc_text(PAGE, NtQueryInformationProcess)
#pragma alloc_text(PAGE, NtSetInformationProcess)
#pragma alloc_text(PAGE, NtQueryPortInformationProcess)
#pragma alloc_text(PAGE, NtQueryInformationThread)
#pragma alloc_text(PAGE, NtSetInformationThread)
#pragma alloc_text(PAGE, PsSetProcessPriorityByClass)
#pragma alloc_text(PAGE, PspSetPrimaryToken)
#pragma alloc_text(PAGE, PspSetQuotaLimits)
#pragma alloc_text(PAGE, PspQueryQuotaLimits)
#pragma alloc_text(PAGE, PspQueryPooledQuotaLimits)
#pragma alloc_text(PAGE, NtGetCurrentProcessorNumber)
#pragma alloc_text(PAGELK, PspQueryWorkingSetWatch)
#endif

NTSTATUS
PspQueryWorkingSetWatch(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    )
{
    PPAGEFAULT_HISTORY WorkingSetCatcher;
    ULONG SpaceNeeded;
    PEPROCESS Process;
    KIRQL OldIrql;
    NTSTATUS st;

    UNREFERENCED_PARAMETER (ProcessInformationClass);

    st = ObReferenceObjectByHandle (ProcessHandle,
                                    PROCESS_QUERY_INFORMATION,
                                    PsProcessType,
                                    PreviousMode,
                                    (PVOID *)&Process,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    WorkingSetCatcher = Process->WorkingSetWatch;
    if (WorkingSetCatcher == NULL) {
        ObDereferenceObject (Process);
        return STATUS_UNSUCCESSFUL;
    }

    MmLockPagableSectionByHandle (ExPageLockHandle);
    ExAcquireSpinLock (&WorkingSetCatcher->SpinLock,&OldIrql);

    if (WorkingSetCatcher->CurrentIndex) {

        //
        // Null Terminate the first empty entry in the buffer
        //

        WorkingSetCatcher->WatchInfo[WorkingSetCatcher->CurrentIndex].FaultingPc = NULL;

        //Store a special Va value if the buffer was full and
        //page faults could have been lost

        if (WorkingSetCatcher->CurrentIndex != WorkingSetCatcher->MaxIndex) {
            WorkingSetCatcher->WatchInfo[WorkingSetCatcher->CurrentIndex].FaultingVa = NULL;
        } else {
            WorkingSetCatcher->WatchInfo[WorkingSetCatcher->CurrentIndex].FaultingVa = (PVOID) 1;
        }

        SpaceNeeded = (WorkingSetCatcher->CurrentIndex+1) * sizeof(PROCESS_WS_WATCH_INFORMATION);
    } else {
        ExReleaseSpinLock (&WorkingSetCatcher->SpinLock, OldIrql);
        MmUnlockPagableImageSection (ExPageLockHandle);
        ObDereferenceObject (Process);
        return STATUS_NO_MORE_ENTRIES;
    }

    if (ProcessInformationLength < SpaceNeeded) {
        ExReleaseSpinLock (&WorkingSetCatcher->SpinLock, OldIrql);
        MmUnlockPagableImageSection (ExPageLockHandle);
        ObDereferenceObject (Process);
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Mark the Working Set buffer as full and then drop the lock
    // and copy the bytes
    //

    WorkingSetCatcher->CurrentIndex = MAX_WS_CATCH_INDEX;

    ExReleaseSpinLock (&WorkingSetCatcher->SpinLock,OldIrql);

    try {
        RtlCopyMemory (ProcessInformation, &WorkingSetCatcher->WatchInfo[0], SpaceNeeded);
        if (ARGUMENT_PRESENT (ReturnLength) ) {
            *ReturnLength = SpaceNeeded;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        st = GetExceptionCode ();
    }

    ExAcquireSpinLock (&WorkingSetCatcher->SpinLock, &OldIrql);
    WorkingSetCatcher->CurrentIndex = 0;
    ExReleaseSpinLock (&WorkingSetCatcher->SpinLock, OldIrql);

    MmUnlockPagableImageSection (ExPageLockHandle);
    ObDereferenceObject (Process);

    return st;
}

NTSTATUS
PspQueryQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    )
{
    QUOTA_LIMITS_EX QuotaLimits={0};
    PEPROCESS Process;
    NTSTATUS Status;
    PEPROCESS_QUOTA_BLOCK QuotaBlock;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    ULONG HardEnforcement;
    KAPC_STATE ApcState;

    UNREFERENCED_PARAMETER (ProcessInformationClass);

    if (ProcessInformationLength != sizeof (QUOTA_LIMITS) &&
        ProcessInformationLength != sizeof (QUOTA_LIMITS_EX)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    QuotaBlock = Process->QuotaBlock;

    if (QuotaBlock != &PspDefaultQuotaBlock) {
        QuotaLimits.PagedPoolLimit = QuotaBlock->QuotaEntry[PsPagedPool].Limit;
        QuotaLimits.NonPagedPoolLimit = QuotaBlock->QuotaEntry[PsNonPagedPool].Limit;
        QuotaLimits.PagefileLimit = QuotaBlock->QuotaEntry[PsPageFile].Limit;
    } else {
        QuotaLimits.PagedPoolLimit = (SIZE_T)-1;
        QuotaLimits.NonPagedPoolLimit = (SIZE_T)-1;
        QuotaLimits.PagefileLimit = (SIZE_T)-1;
    }

    QuotaLimits.TimeLimit.LowPart = 0xffffffff;
    QuotaLimits.TimeLimit.HighPart = 0xffffffff;

    KeStackAttachProcess (&Process->Pcb, &ApcState);

    Status = MmQueryWorkingSetInformation (&PeakWorkingSetSize,
                                           &WorkingSetSize,
                                           &QuotaLimits.MinimumWorkingSetSize,
                                           &QuotaLimits.MaximumWorkingSetSize,
                                           &HardEnforcement);
    KeUnstackDetachProcess (&ApcState);

    if (HardEnforcement & MM_WORKING_SET_MIN_HARD_ENABLE) {
        QuotaLimits.Flags = QUOTA_LIMITS_HARDWS_MIN_ENABLE;
    } else {
        QuotaLimits.Flags = QUOTA_LIMITS_HARDWS_MIN_DISABLE;
    }

    if (HardEnforcement & MM_WORKING_SET_MAX_HARD_ENABLE) {
        QuotaLimits.Flags |= QUOTA_LIMITS_HARDWS_MAX_ENABLE;
    } else {
        QuotaLimits.Flags |= QUOTA_LIMITS_HARDWS_MAX_DISABLE;
    }

    ObDereferenceObject (Process);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    //
    // Either of these may cause an access violation. The
    // exception handler will return access violation as
    // status code.
    //

    try {
        ASSERT (ProcessInformationLength <= sizeof (QuotaLimits));

        RtlCopyMemory (ProcessInformation, &QuotaLimits, ProcessInformationLength);

        if (ARGUMENT_PRESENT (ReturnLength)) {
            *ReturnLength = ProcessInformationLength;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode ();
    }

    return Status;
}

NTSTATUS
PspQueryPooledQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL,
    IN KPROCESSOR_MODE PreviousMode
    )
{
    PEPROCESS Process;
    NTSTATUS st;
    PEPROCESS_QUOTA_BLOCK QuotaBlock;
    POOLED_USAGE_AND_LIMITS UsageAndLimits;

    UNREFERENCED_PARAMETER (ProcessInformationClass);

    if (ProcessInformationLength != (ULONG) sizeof (POOLED_USAGE_AND_LIMITS)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    st = ObReferenceObjectByHandle (ProcessHandle,
                                    PROCESS_QUERY_INFORMATION,
                                    PsProcessType,
                                    PreviousMode,
                                    &Process,
                                    NULL);
    if (!NT_SUCCESS (st)) {
        return st;
    }


    QuotaBlock = Process->QuotaBlock;

    UsageAndLimits.PagedPoolLimit        = QuotaBlock->QuotaEntry[PsPagedPool].Limit;
    UsageAndLimits.NonPagedPoolLimit     = QuotaBlock->QuotaEntry[PsNonPagedPool].Limit;
    UsageAndLimits.PagefileLimit         = QuotaBlock->QuotaEntry[PsPageFile].Limit;


    UsageAndLimits.PagedPoolUsage        = QuotaBlock->QuotaEntry[PsPagedPool].Usage;
    UsageAndLimits.NonPagedPoolUsage     = QuotaBlock->QuotaEntry[PsNonPagedPool].Usage;
    UsageAndLimits.PagefileUsage         = QuotaBlock->QuotaEntry[PsPageFile].Usage;

    UsageAndLimits.PeakPagedPoolUsage    = QuotaBlock->QuotaEntry[PsPagedPool].Peak;
    UsageAndLimits.PeakNonPagedPoolUsage = QuotaBlock->QuotaEntry[PsNonPagedPool].Peak;
    UsageAndLimits.PeakPagefileUsage     = QuotaBlock->QuotaEntry[PsPageFile].Peak;

    //
    // Since the quota charge and return are lock free we may see Peak and Limit out of step.
    // Usage <= Limit and Usage <= Peak
    // Since Limit is adjusted up and down it does not hold that Peak <= Limit.
    //
#define PSMAX(a,b) (((a) > (b))?(a):(b))

    UsageAndLimits.PagedPoolLimit        = PSMAX (UsageAndLimits.PagedPoolLimit,    UsageAndLimits.PagedPoolUsage);
    UsageAndLimits.NonPagedPoolLimit     = PSMAX (UsageAndLimits.NonPagedPoolLimit, UsageAndLimits.NonPagedPoolUsage);
    UsageAndLimits.PagefileLimit         = PSMAX (UsageAndLimits.PagefileLimit,     UsageAndLimits.PagefileUsage);

    UsageAndLimits.PeakPagedPoolUsage    = PSMAX (UsageAndLimits.PeakPagedPoolUsage,    UsageAndLimits.PagedPoolUsage);
    UsageAndLimits.PeakNonPagedPoolUsage = PSMAX (UsageAndLimits.PeakNonPagedPoolUsage, UsageAndLimits.NonPagedPoolUsage);
    UsageAndLimits.PeakPagefileUsage     = PSMAX (UsageAndLimits.PeakPagefileUsage,     UsageAndLimits.PagefileUsage);

    ObDereferenceObject(Process);

    //
    // Either of these may cause an access violation. The
    // exception handler will return access violation as
    // status code. No further cleanup needs to be done.
    //

    try {
        *(PPOOLED_USAGE_AND_LIMITS) ProcessInformation = UsageAndLimits;

        if (ARGUMENT_PRESENT(ReturnLength) ) {
            *ReturnLength = sizeof(POOLED_USAGE_AND_LIMITS);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode ();
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PspSetPrimaryToken(
    IN HANDLE ProcessHandle OPTIONAL,
    IN PEPROCESS ProcessPointer OPTIONAL,
    IN HANDLE TokenHandle OPTIONAL,
    IN PACCESS_TOKEN TokenPointer OPTIONAL,
    IN BOOLEAN PrivilegeChecked
    )
/*++

    Sets the primary token for a process.
    The token and process supplied can be either by
    handle or by pointer.

--*/
{
    NTSTATUS Status;
    BOOLEAN HasPrivilege;
    BOOLEAN IsChildToken;
    PEPROCESS Process;
    KPROCESSOR_MODE PreviousMode;
    ACCESS_MASK GrantedAccess;
    PACCESS_TOKEN Token;

    //
    // Check to see if the supplied token is a child of the caller's
    // token. If so, we don't need to do the privilege check.
    //

    PreviousMode = KeGetPreviousMode ();

    if (TokenPointer == NULL) {
        //
        // Reference the specified token, and make sure it can be assigned
        // as a primary token.
        //

        Status = ObReferenceObjectByHandle (TokenHandle,
                                            TOKEN_ASSIGN_PRIMARY,
                                            SeTokenObjectType,
                                            PreviousMode,
                                            &Token,
                                            NULL);

        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    } else {
        Token = TokenPointer;
    }

    //
    // If the privilege check has already been done (when the token was
    // assign to a job for example). We don't want to do it here.
    //
    if (!PrivilegeChecked) {
        Status = SeIsChildTokenByPointer (Token,
                                          &IsChildToken);

        if (!NT_SUCCESS (Status)) {
            goto exit_and_deref_token;
        }

        if (!IsChildToken) {


            //
            // SeCheckPrivilegedObject will perform auditing as appropriate
            //

            HasPrivilege = SeCheckPrivilegedObject (SeAssignPrimaryTokenPrivilege,
                                                    ProcessHandle,
                                                    PROCESS_SET_INFORMATION,
                                                    PreviousMode);

            if (!HasPrivilege) {

                Status = STATUS_PRIVILEGE_NOT_HELD;

                goto exit_and_deref_token;
            }
        }

    }

    if (ProcessPointer == NULL) {
        Status = ObReferenceObjectByHandle (ProcessHandle,
                                            PROCESS_SET_INFORMATION,
                                            PsProcessType,
                                            PreviousMode,
                                            &Process,
                                            NULL);

        if (!NT_SUCCESS (Status)) {

            goto exit_and_deref_token;
        }
    } else {
        Process = ProcessPointer;
    }


    //
    // Check for proper access to the token, and assign the primary
    // token for the process.
    //

    Status = PspAssignPrimaryToken (Process, NULL, Token);

    //
    // Recompute the process's access to itself for use
    // with the CurrentProcess() pseudo handle.
    //

    if (NT_SUCCESS (Status)) {

        NTSTATUS accesst;
        BOOLEAN AccessCheck;
        BOOLEAN MemoryAllocated;
        PSECURITY_DESCRIPTOR SecurityDescriptor;
        SECURITY_SUBJECT_CONTEXT SubjectContext;

        Status = ObGetObjectSecurity (Process,
                                      &SecurityDescriptor,
                                      &MemoryAllocated);

        if (NT_SUCCESS (Status)) {
            SubjectContext.ProcessAuditId = Process;
            SubjectContext.PrimaryToken = PsReferencePrimaryToken (Process);
            SubjectContext.ClientToken = NULL;
            AccessCheck = SeAccessCheck (SecurityDescriptor,
                                         &SubjectContext,
                                         FALSE,
                                         MAXIMUM_ALLOWED,
                                         0,
                                         NULL,
                                         &PsProcessType->TypeInfo.GenericMapping,
                                         PreviousMode,
                                         &GrantedAccess,
                                         &accesst);

            PsDereferencePrimaryTokenEx(Process, SubjectContext.PrimaryToken);
            ObReleaseObjectSecurity (SecurityDescriptor,
                                     MemoryAllocated);

            if (!AccessCheck) {
                GrantedAccess = 0;
            }

            //
            // To keep consistency with process creation, grant these
            // bits otherwise CreateProcessAsUser messes up really badly for
            // restricted tokens and we end up with a process that has no
            // access to itself when new token is set on the suspended
            // process.
            //
            GrantedAccess |= (PROCESS_VM_OPERATION | PROCESS_VM_READ |
                              PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION |
                              PROCESS_TERMINATE | PROCESS_CREATE_THREAD |
                              PROCESS_DUP_HANDLE | PROCESS_CREATE_PROCESS |
                              PROCESS_SET_INFORMATION | STANDARD_RIGHTS_ALL);

            Process->GrantedAccess = GrantedAccess;
        }
        //
        // Since the process token is being set,
        // Set the device map for process to NULL.
        // During the next reference to the process' device map,
        // the object manager will set the device map for the process
        //
        if (ObIsLUIDDeviceMapsEnabled() != 0) {
            ObDereferenceDeviceMap( Process );
        }
    }

    if (ProcessPointer == NULL) {
        ObDereferenceObject (Process);
    }

exit_and_deref_token:

    if (TokenPointer == NULL) {
        ObDereferenceObject (Token);
    }

    return Status;
}


NTSTATUS
NtQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

{
    PEPROCESS Process;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS st;
    PROCESS_BASIC_INFORMATION BasicInfo;
    VM_COUNTERS_EX VmCounters;
    IO_COUNTERS IoCounters;
    KERNEL_USER_TIMES SysUserTime;
    HANDLE DebugPort;
    ULONG HandleCount;
    ULONG DefaultHardErrorMode;
    ULONG DisableBoost;
    ULONG BreakOnTerminationEnabled;
    PPROCESS_DEVICEMAP_INFORMATION DeviceMapInfo;
    PROCESS_SESSION_INFORMATION SessionInfo;
    PROCESS_PRIORITY_CLASS PriorityClass;
    ULONG_PTR Wow64Info;
    ULONG Flags;
    PUNICODE_STRING pTempNameInfo;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    ULONG HardEnforcement;
    KAPC_STATE ApcState;

    PAGED_CODE();

    //
    // Get previous processor mode and probe output argument if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            //
            // Since these functions don't change any state thats not reversible
            // in the error paths we only probe the output buffer for write access.
            // This improves performance by not touching the buffer multiple times
            // And only writing the portions of the buffer that change.
            //
            ProbeForRead (ProcessInformation,
                          ProcessInformationLength,
                          sizeof (ULONG));

            if (ARGUMENT_PRESENT (ReturnLength)) {
                ProbeForWriteUlong (ReturnLength);
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    switch ( ProcessInformationClass ) {

    case ProcessImageFileName:
        {
            ULONG LengthNeeded = 0;

            st = ObReferenceObjectByHandle (ProcessHandle,
                                            PROCESS_QUERY_INFORMATION,
                                            PsProcessType,
                                            PreviousMode,
                                            &Process,
                                            NULL);

            if (!NT_SUCCESS (st)) {
                return st;
            }

            //
            // SeLocateProcessImageName will allocate space for a UNICODE_STRING and point pTempNameInfo
            // at that string.  This memory will be freed later in the routine.
            //

            st = SeLocateProcessImageName (Process, &pTempNameInfo);

            if (!NT_SUCCESS(st)) {
                ObDereferenceObject(Process);
                return st;
            }

            LengthNeeded = sizeof(UNICODE_STRING) + pTempNameInfo->MaximumLength;

            //
            // Either of these may cause an access violation. The
            // exception handler will return access violation as
            // status code. No further cleanup needs to be done.
            //

            try {

                if (ARGUMENT_PRESENT(ReturnLength) ) {
                    *ReturnLength = LengthNeeded;
                }

                if (ProcessInformationLength >= LengthNeeded) {
                    RtlCopyMemory(
                        ProcessInformation,
                        pTempNameInfo,
                        sizeof(UNICODE_STRING) + pTempNameInfo->MaximumLength
                        );
                    ((PUNICODE_STRING) ProcessInformation)->Buffer = (PWSTR)((PUCHAR) ProcessInformation + sizeof(UNICODE_STRING));

                } else {
                    st = STATUS_INFO_LENGTH_MISMATCH;
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                st = GetExceptionCode ();
            }

            ObDereferenceObject(Process);
            ExFreePool( pTempNameInfo );

            return st;

        }

    case ProcessWorkingSetWatch:

        return PspQueryWorkingSetWatch (ProcessHandle,
                                        ProcessInformationClass,
                                        ProcessInformation,
                                        ProcessInformationLength,
                                        ReturnLength,
                                        PreviousMode);

    case ProcessBasicInformation:

        if (ProcessInformationLength != (ULONG) sizeof(PROCESS_BASIC_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        BasicInfo.ExitStatus = Process->ExitStatus;
        BasicInfo.PebBaseAddress = Process->Peb;
        BasicInfo.AffinityMask = Process->Pcb.Affinity;
        BasicInfo.BasePriority = Process->Pcb.BasePriority;
        BasicInfo.UniqueProcessId = (ULONG_PTR)Process->UniqueProcessId;
        BasicInfo.InheritedFromUniqueProcessId = (ULONG_PTR)Process->InheritedFromUniqueProcessId;

        ObDereferenceObject(Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PPROCESS_BASIC_INFORMATION) ProcessInformation = BasicInfo;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof(PROCESS_BASIC_INFORMATION);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessDefaultHardErrorMode:

        if (ProcessInformationLength != sizeof(ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        DefaultHardErrorMode = Process->DefaultHardErrorProcessing;

        ObDereferenceObject(Process);

        try {
            *(PULONG) ProcessInformation = DefaultHardErrorMode;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessQuotaLimits:

        return PspQueryQuotaLimits (ProcessHandle,
                                    ProcessInformationClass,
                                    ProcessInformation,
                                    ProcessInformationLength,
                                    ReturnLength,
                                    PreviousMode);

    case ProcessPooledUsageAndLimits:

        return PspQueryPooledQuotaLimits (ProcessHandle,
                                          ProcessInformationClass,
                                          ProcessInformation,
                                          ProcessInformationLength,
                                          ReturnLength,
                                          PreviousMode);

    case ProcessIoCounters:

        if (ProcessInformationLength != (ULONG) sizeof (IO_COUNTERS)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        IoCounters.ReadOperationCount = Process->ReadOperationCount.QuadPart;
        IoCounters.WriteOperationCount = Process->WriteOperationCount.QuadPart;
        IoCounters.OtherOperationCount = Process->OtherOperationCount.QuadPart;
        IoCounters.ReadTransferCount = Process->ReadTransferCount.QuadPart;
        IoCounters.WriteTransferCount = Process->WriteTransferCount.QuadPart;
        IoCounters.OtherTransferCount = Process->OtherTransferCount.QuadPart;

        ObDereferenceObject (Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PIO_COUNTERS) ProcessInformation = IoCounters;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof(IO_COUNTERS);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessVmCounters:

        if (ProcessInformationLength != (ULONG) sizeof (VM_COUNTERS)
            && ProcessInformationLength != (ULONG) sizeof (VM_COUNTERS_EX)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }


        //
        // Note: At some point, we might have to grab the statistics
        // lock to reliably read this stuff
        //

        VmCounters.PeakVirtualSize = Process->PeakVirtualSize;
        VmCounters.VirtualSize = Process->VirtualSize;
        VmCounters.PageFaultCount = Process->Vm.PageFaultCount;

        KeStackAttachProcess (&Process->Pcb, &ApcState);

        st = MmQueryWorkingSetInformation (&VmCounters.PeakWorkingSetSize,
                                           &VmCounters.WorkingSetSize,
                                           &MinimumWorkingSetSize,
                                           &MaximumWorkingSetSize,
                                           &HardEnforcement);


        KeUnstackDetachProcess (&ApcState);

        VmCounters.QuotaPeakPagedPoolUsage = Process->QuotaPeak[PsPagedPool];
        VmCounters.QuotaPagedPoolUsage = Process->QuotaUsage[PsPagedPool];
        VmCounters.QuotaPeakNonPagedPoolUsage = Process->QuotaPeak[PsNonPagedPool];
        VmCounters.QuotaNonPagedPoolUsage = Process->QuotaUsage[PsNonPagedPool];
        VmCounters.PagefileUsage = ((SIZE_T) Process->QuotaUsage[PsPageFile]) << PAGE_SHIFT;
        VmCounters.PeakPagefileUsage = ((SIZE_T) Process->QuotaPeak[PsPageFile]) << PAGE_SHIFT;
        VmCounters.PrivateUsage = ((SIZE_T) Process->CommitCharge) << PAGE_SHIFT;

        ObDereferenceObject (Process);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            RtlCopyMemory(ProcessInformation,
                          &VmCounters,
                          ProcessInformationLength);
            
            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = ProcessInformationLength;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessTimes:

        if ( ProcessInformationLength != (ULONG) sizeof(KERNEL_USER_TIMES) ) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Need some type of interlock on KiTimeLock
        //

        SysUserTime.KernelTime.QuadPart = UInt32x32To64(Process->Pcb.KernelTime,
                                                        KeMaximumIncrement);

        SysUserTime.UserTime.QuadPart = UInt32x32To64(Process->Pcb.UserTime,
                                                      KeMaximumIncrement);

        SysUserTime.CreateTime = Process->CreateTime;
        SysUserTime.ExitTime = Process->ExitTime;

        ObDereferenceObject (Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PKERNEL_USER_TIMES) ProcessInformation = SysUserTime;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (KERNEL_USER_TIMES);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessDebugPort :

        //
        if (ProcessInformationLength != (ULONG) sizeof (HANDLE)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (Process->DebugPort == NULL) {

            DebugPort = NULL;

        } else {

            DebugPort = (HANDLE)-1;

        }

        ObDereferenceObject (Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PHANDLE) ProcessInformation = DebugPort;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof(HANDLE);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessDebugObjectHandle :
        //
        if (ProcessInformationLength != sizeof (HANDLE)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = DbgkOpenProcessDebugPort (Process,
                                       PreviousMode,
                                       &DebugPort);

        if (!NT_SUCCESS (st)) {
            DebugPort = NULL;
        }

        ObDereferenceObject (Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PHANDLE) ProcessInformation = DebugPort;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (HANDLE);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            if (DebugPort != NULL) {
                ObCloseHandle (DebugPort, PreviousMode);
            }
            return GetExceptionCode ();
        }

        return st;

    case ProcessDebugFlags :

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }


        try {
            *(PULONG) ProcessInformation = (Process->Flags&PS_PROCESS_FLAGS_NO_DEBUG_INHERIT)?0:PROCESS_DEBUG_INHERIT;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof(HANDLE);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            st = GetExceptionCode ();
        }

        ObDereferenceObject (Process);

        return st;


    case ProcessHandleCount :

        if (ProcessInformationLength != (ULONG) sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        HandleCount = ObGetProcessHandleCount (Process);

        ObDereferenceObject (Process);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PULONG) ProcessInformation = HandleCount;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessLdtInformation :

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PspQueryLdtInformation (Process,
                                     ProcessInformation,
                                     ProcessInformationLength,
                                     ReturnLength);

        ObDereferenceObject(Process);
        return st;


    case ProcessWx86Information :

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Flags = Process->Flags & PS_PROCESS_FLAGS_VDM_ALLOWED ? 1 : 0;

        ObDereferenceObject (Process);

        //
        // The returned flags is used as a BOOLEAN to indicate whether the
        // ProcessHandle specifies a NtVdm Process.  In another words, the caller
        // can simply do a
        //      if (ReturnedValue == TRUE) {
        //          a ntvdm process;
        //      } else {
        //          NOT a ntvdm process;
        //      }
        //

        try {
            *(PULONG)ProcessInformation = Flags;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof(ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return st;

    case ProcessPriorityBoost:
        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        DisableBoost = Process->Pcb.DisableBoost ? 1 : 0;

        ObDereferenceObject (Process);

        try {
            *(PULONG)ProcessInformation = DisableBoost;

            if (ARGUMENT_PRESENT( ReturnLength) ) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return st;

    case ProcessDeviceMap:
        DeviceMapInfo = (PPROCESS_DEVICEMAP_INFORMATION)ProcessInformation;
        if (ProcessInformationLength < sizeof (DeviceMapInfo->Query)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        if (ProcessInformationLength == sizeof (PROCESS_DEVICEMAP_INFORMATION_EX)) {
            try {
                Flags = ((PPROCESS_DEVICEMAP_INFORMATION_EX)DeviceMapInfo)->Flags;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
            if ( (Flags & ~(PROCESS_LUID_DOSDEVICES_ONLY)) ||
                 (ObIsLUIDDeviceMapsEnabled () == 0) ) {
                return STATUS_INVALID_PARAMETER;
            }
        }
        else {
            if (ProcessInformationLength == sizeof (DeviceMapInfo->Query)) {
                Flags = 0;
            }
            else {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = ObQueryDeviceMapInformation (Process, DeviceMapInfo, Flags);
        ObDereferenceObject(Process);
        return st;

    case ProcessSessionInformation :

        if (ProcessInformationLength != (ULONG) sizeof (PROCESS_SESSION_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        SessionInfo.SessionId = MmGetSessionId (Process);

        ObDereferenceObject (Process);

        try {
            *(PPROCESS_SESSION_INFORMATION) ProcessInformation = SessionInfo;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof(PROCESS_SESSION_INFORMATION);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;



    case ProcessPriorityClass:

        if (ProcessInformationLength != sizeof (PROCESS_PRIORITY_CLASS)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        PriorityClass.Foreground = FALSE;
        PriorityClass.PriorityClass = Process->PriorityClass;

        ObDereferenceObject (Process);

        try {
            *(PPROCESS_PRIORITY_CLASS) ProcessInformation = PriorityClass;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof(PROCESS_PRIORITY_CLASS);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;


    case ProcessWow64Information:

        if (ProcessInformationLength != sizeof (ULONG_PTR)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        Wow64Info = 0;

        //
        // Acquire process rundown protection as we are about to look at process structures torn down at
        // process exit.
        //
        if (ExAcquireRundownProtection (&Process->RundownProtect)) {
            PWOW64_PROCESS Wow64Process;

            if ((Wow64Process = PS_GET_WOW64_PROCESS (Process)) != NULL) {
                Wow64Info = (ULONG_PTR)(Wow64Process->Wow64);
            }

            ExReleaseRundownProtection (&Process->RundownProtect);
        }


        ObDereferenceObject (Process);

        try {
            *(PULONG_PTR)ProcessInformation = Wow64Info;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (ULONG_PTR);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;


    case ProcessLUIDDeviceMapsEnabled:

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            *(PULONG)ProcessInformation = ObIsLUIDDeviceMapsEnabled ();

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessBreakOnTermination:

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (Process->Flags & PS_PROCESS_FLAGS_BREAK_ON_TERMINATION) {

            BreakOnTerminationEnabled = 1;

        } else {

            BreakOnTerminationEnabled = 0;

        }

        ObDereferenceObject (Process);

        try {

            *(PULONG)ProcessInformation = BreakOnTerminationEnabled;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (ULONG);
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ProcessHandleTracing: {
        PPROCESS_HANDLE_TRACING_QUERY Pht;
        PHANDLE_TABLE HandleTable;
        PHANDLE_TRACE_DEBUG_INFO DebugInfo;
        HANDLE_TRACE_DB_ENTRY Trace;
        PPROCESS_HANDLE_TRACING_ENTRY NextTrace;
        ULONG StacksLeft;
        ULONG i, j;

        if (ProcessInformationLength < FIELD_OFFSET (PROCESS_HANDLE_TRACING_QUERY,
                                                     HandleTrace)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        Pht = (PPROCESS_HANDLE_TRACING_QUERY) ProcessInformation;
        StacksLeft = (ProcessInformationLength - FIELD_OFFSET (PROCESS_HANDLE_TRACING_QUERY,
                                                              HandleTrace)) /
                     sizeof (Pht->HandleTrace[0]);
        NextTrace = &Pht->HandleTrace[0];

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_QUERY_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }
        HandleTable = ObReferenceProcessHandleTable (Process);

        if (HandleTable != NULL) {
            DebugInfo = ExReferenceHandleDebugInfo (HandleTable);
            if (DebugInfo != NULL) {
                try {
                    Pht->TotalTraces = 0;
                    j = DebugInfo->CurrentStackIndex % DebugInfo->TableSize;
                    for (i = 0; i < DebugInfo->TableSize; i++) {
                        RtlCopyMemory (&Trace, &DebugInfo->TraceDb[j], sizeof (Trace));
                        if ((Pht->Handle == Trace.Handle || Pht->Handle == 0) && Trace.Type != 0) {
                            Pht->TotalTraces++;
                            if (StacksLeft > 0) {
                                StacksLeft--;
                                NextTrace->Handle = Trace.Handle;
                                NextTrace->ClientId = Trace.ClientId;
                                NextTrace->Type = Trace.Type;
                                RtlCopyMemory (NextTrace->Stacks,
                                               Trace.StackTrace,
                                               min (sizeof (NextTrace->Stacks),
                                                    sizeof (Trace.StackTrace)));
                                NextTrace++;

                            } else {
                                st = STATUS_INFO_LENGTH_MISMATCH;
                            }
                        }
                        if (j == 0) {
                            j = DebugInfo->TableSize - 1;
                        } else {
                            j--;
                        }
                    }
                    if (ARGUMENT_PRESENT (ReturnLength)) {
                        *ReturnLength = (ULONG) ((PUCHAR) NextTrace - (PUCHAR) Pht);
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    st = GetExceptionCode ();
                }

                ExDereferenceHandleDebugInfo (HandleTable, DebugInfo);

            } else {
                st = STATUS_INVALID_PARAMETER;
            }
            ObDereferenceProcessHandleTable (Process);
        } else {
            st = STATUS_PROCESS_IS_TERMINATING;
        }

        ObDereferenceObject(Process);
        return st;
    }
    default:

        return STATUS_INVALID_INFO_CLASS;
    }

}

NTSTATUS
NtQueryPortInformationProcess(
    VOID
    )

/*++

Routine Description:

    This function tests whether a debug port or an exception port is attached
    to the current process and returns a corresponding value. This function is
    used to bypass raising an exception through the system when no associated
    ports are present.

    N.B. This improves performance considerably with respect to raising
         software exceptions in user mode on AMD64 and IA64 systems.

Arguments:

    None.

Return Value:

    A success value of TRUE is returned if either a debug or exception port
    is associated with the current process. Otherwise, a success value of
    FALSE is returned.

--*/

{

    PEPROCESS Process;
    PETHREAD Thread;

    //
    // If the process has a debug port and it is not being hidden from the
    // debugger, then return a success status of TRUE. Otherwise, is the
    // process has an exception port, then return a success status of TRUE.
    // Otherwise, return a success status of FALSE.
    //

    Thread = PsGetCurrentThread();
    Process = PsGetCurrentProcessByThread (Thread);
    if ((Process->DebugPort != NULL) &&
        ((Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) == 0)) {

        return TRUE;

    } else if (Process->ExceptionPort != NULL) {
        return TRUE;

    } else {
        return FALSE;
    }
}

NTSTATUS
PspSetQuotaLimits(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    IN KPROCESSOR_MODE PreviousMode
    )
{
    PEPROCESS Process;
    PETHREAD CurrentThread;
    QUOTA_LIMITS_EX RequestedLimits;
    PEPROCESS_QUOTA_BLOCK NewQuotaBlock;
    NTSTATUS st, ReturnStatus;
    BOOLEAN OkToIncrease, IgnoreError;
    PEJOB Job;
    KAPC_STATE ApcState;
    ULONG EnableHardLimits;
    BOOLEAN PurgeRequest;

    UNREFERENCED_PARAMETER (ProcessInformationClass);

    try {

        if (ProcessInformationLength == sizeof (QUOTA_LIMITS)) {
            RtlCopyMemory (&RequestedLimits,
                           ProcessInformation,
                           sizeof (QUOTA_LIMITS));
            RequestedLimits.Reserved1 = 0;
            RequestedLimits.Reserved2 = 0;
            RequestedLimits.Reserved3 = 0;
            RequestedLimits.Reserved4 = 0;
            RequestedLimits.Reserved5 = 0;
            RequestedLimits.Flags = 0;
        } else if (ProcessInformationLength == sizeof (QUOTA_LIMITS_EX)) {
            RequestedLimits = *(PQUOTA_LIMITS_EX) ProcessInformation;
        } else {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode ();
    }

    //
    // All unused flags must be zero
    //
    if (RequestedLimits.Flags & ~(QUOTA_LIMITS_HARDWS_MAX_ENABLE|QUOTA_LIMITS_HARDWS_MAX_DISABLE|
                                  QUOTA_LIMITS_HARDWS_MIN_ENABLE|QUOTA_LIMITS_HARDWS_MIN_DISABLE)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disallow both enable and disable bits set at the same time.
    //
    if (PS_TEST_ALL_BITS_SET (RequestedLimits.Flags, QUOTA_LIMITS_HARDWS_MIN_ENABLE|QUOTA_LIMITS_HARDWS_MIN_DISABLE) ||
        PS_TEST_ALL_BITS_SET (RequestedLimits.Flags, QUOTA_LIMITS_HARDWS_MAX_ENABLE|QUOTA_LIMITS_HARDWS_MAX_DISABLE)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // See if we are changing the hard limits or not
    //

    EnableHardLimits = 0;

    if (RequestedLimits.Flags&QUOTA_LIMITS_HARDWS_MIN_ENABLE) {
        EnableHardLimits = MM_WORKING_SET_MIN_HARD_ENABLE;
    } else if (RequestedLimits.Flags&QUOTA_LIMITS_HARDWS_MIN_DISABLE) {
        EnableHardLimits = MM_WORKING_SET_MIN_HARD_DISABLE;
    }

    if (RequestedLimits.Flags&QUOTA_LIMITS_HARDWS_MAX_ENABLE) {
        EnableHardLimits |= MM_WORKING_SET_MAX_HARD_ENABLE;
    } else if (RequestedLimits.Flags&QUOTA_LIMITS_HARDWS_MAX_DISABLE) {
        EnableHardLimits |= MM_WORKING_SET_MAX_HARD_DISABLE;
    }


    //
    // All reserved fields must be zero
    //
    if (RequestedLimits.Reserved1 != 0 || RequestedLimits.Reserved2 != 0 ||
        RequestedLimits.Reserved3 != 0 || RequestedLimits.Reserved4 != 0 ||
        RequestedLimits.Reserved5 != 0) {
        return STATUS_INVALID_PARAMETER;
    }


    st = ObReferenceObjectByHandle (ProcessHandle,
                                    PROCESS_SET_QUOTA,
                                    PsProcessType,
                                    PreviousMode,
                                    &Process,
                                    NULL);

    if (!NT_SUCCESS (st)) {
        return st;
    }

    CurrentThread = PsGetCurrentThread ();

    //
    // Now we are ready to set the quota limits for the process
    //
    // If the process already has a quota block, then all we allow
    // is working set changes.
    //
    // If the process has no quota block, all that can be done is a
    // quota set operation.
    //
    // If a quota field is zero, we pick the value.
    //
    // Setting quotas requires the SeIncreaseQuotaPrivilege (except for
    // working set size since this is only advisory).
    //


    ReturnStatus = STATUS_SUCCESS;

    if ((Process->QuotaBlock == &PspDefaultQuotaBlock) &&
         (RequestedLimits.MinimumWorkingSetSize == 0 || RequestedLimits.MaximumWorkingSetSize == 0)) {

        //
        // You must have a privilege to assign quotas
        //

        if (!SeSinglePrivilegeCheck (SeIncreaseQuotaPrivilege, PreviousMode)) {
            ObDereferenceObject (Process);
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        NewQuotaBlock = ExAllocatePoolWithTag (NonPagedPool, sizeof(*NewQuotaBlock), 'bQsP');
        if (NewQuotaBlock == NULL) {
            ObDereferenceObject (Process);
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory (NewQuotaBlock, sizeof (*NewQuotaBlock));

        //
        // Initialize the quota block
        //
        NewQuotaBlock->ReferenceCount = 1;
        NewQuotaBlock->ProcessCount   = 1;

        NewQuotaBlock->QuotaEntry[PsNonPagedPool].Peak  = Process->QuotaPeak[PsNonPagedPool];
        NewQuotaBlock->QuotaEntry[PsPagedPool].Peak     = Process->QuotaPeak[PsPagedPool];
        NewQuotaBlock->QuotaEntry[PsPageFile].Peak      = Process->QuotaPeak[PsPageFile];

        //
        // Now compute limits
        //

        //
        // Get the defaults that the system would pick.
        //

        NewQuotaBlock->QuotaEntry[PsPagedPool].Limit    = PspDefaultPagedLimit;
        NewQuotaBlock->QuotaEntry[PsNonPagedPool].Limit = PspDefaultNonPagedLimit;
        NewQuotaBlock->QuotaEntry[PsPageFile].Limit     = PspDefaultPagefileLimit;

        // Everything is set. Now double check to quota block field
        // If we still have no quota block then assign and succeed.
        // Otherwise punt.
        //

        if (InterlockedCompareExchangePointer (&Process->QuotaBlock,
                                               NewQuotaBlock,
                                               &PspDefaultQuotaBlock) != &PspDefaultQuotaBlock) {
            ExFreePool (NewQuotaBlock);
        } else {
            PspInsertQuotaBlock (NewQuotaBlock);
        }


    } else {

        //
        // Only allow a working set size change
        //

        if (RequestedLimits.MinimumWorkingSetSize &&
            RequestedLimits.MaximumWorkingSetSize) {

            //
            // See if the caller just wants to purge the working set.
            // This is an unprivileged operation.
            //
            if (RequestedLimits.MinimumWorkingSetSize == (SIZE_T)-1 &&
                RequestedLimits.MaximumWorkingSetSize == (SIZE_T)-1) {
                PurgeRequest = TRUE;
                OkToIncrease = FALSE;
            } else {
                PurgeRequest = FALSE;

                if (SeSinglePrivilegeCheck (SeIncreaseBasePriorityPrivilege,
                                            PreviousMode)) {
                    OkToIncrease = TRUE;
                } else {
                    OkToIncrease = FALSE;
                }
            }

            do {
                IgnoreError = FALSE;

                KeStackAttachProcess (&Process->Pcb, &ApcState);

                KeEnterGuardedRegionThread (&CurrentThread->Tcb);

                Job = Process->Job;
                if (Job != NULL) {
                    ExAcquireResourceExclusiveLite (&Job->JobLock, TRUE);

                    if (Job->LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {
                        //
                        // Don't let a process in a job change if job limits are applied
                        // except purge requests which can always be done.
                        //

                        EnableHardLimits = MM_WORKING_SET_MAX_HARD_ENABLE;
                        OkToIncrease = TRUE;
                        IgnoreError = TRUE; // we must always set enforcement value

                        if (!PurgeRequest) {
                            RequestedLimits.MinimumWorkingSetSize = Job->MinimumWorkingSetSize;
                            RequestedLimits.MaximumWorkingSetSize = Job->MaximumWorkingSetSize;
                        }
                    }

                    PspLockWorkingSetChangeExclusiveUnsafe ();

                    ExReleaseResourceLite (&Job->JobLock);
                }

                ReturnStatus = MmAdjustWorkingSetSizeEx (RequestedLimits.MinimumWorkingSetSize,
                                                         RequestedLimits.MaximumWorkingSetSize,
                                                         FALSE,
                                                         OkToIncrease,
                                                         EnableHardLimits);

                if (!NT_SUCCESS (ReturnStatus) && IgnoreError) {
                    MmEnforceWorkingSetLimit (Process,
                                              EnableHardLimits);
                }

                if (Job != NULL) {
                    PspUnlockWorkingSetChangeExclusiveUnsafe ();
                }

                KeLeaveGuardedRegionThread (&CurrentThread->Tcb);

                KeUnstackDetachProcess (&ApcState);

                //
                // We loop here in case this process was added to a job
                // after we checked but before we set the limits
                //

            } while (Process->Job != Job);

        }
    }

    ObDereferenceObject(Process);

    return ReturnStatus;
}

NTSTATUS
NtSetInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    )

/*++

Routine Description:

    This function sets the state of a process object.

Arguments:

    ProcessHandle - Supplies a handle to a process object.

    ProcessInformationClass - Supplies the class of information being
        set.

    ProcessInformation - Supplies a pointer to a record that contains the
        information to set.

    ProcessInformationLength - Supplies the length of the record that contains
        the information to set.

Return Value:

    TBS

--*/

{

    PEPROCESS Process;
    PETHREAD Thread;
    PETHREAD CurrentThread;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS st;
    KPRIORITY BasePriority;
    ULONG BoostValue;
    ULONG DefaultHardErrorMode;
    PVOID ExceptionPort;
    BOOLEAN EnableAlignmentFaultFixup;
    HANDLE ExceptionPortHandle;
    ULONG ProbeAlignment;
    HANDLE PrimaryTokenHandle;
    BOOLEAN HasPrivilege = FALSE;
    UCHAR MemoryPriority;
    PROCESS_PRIORITY_CLASS LocalPriorityClass;
    PROCESS_FOREGROUND_BACKGROUND LocalForeground;
    KAFFINITY Affinity, AffinityWithMasks;
    ULONG DisableBoost;
    BOOLEAN bDisableBoost;
    PPROCESS_DEVICEMAP_INFORMATION DeviceMapInfo;
    HANDLE DirectoryHandle;
    PROCESS_SESSION_INFORMATION SessionInfo;
    ULONG EnableBreakOnTermination;
    PEJOB Job;

    PAGED_CODE();

    //
    // Get previous processor mode and probe input argument if necessary.
    //

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (PreviousMode != KernelMode) {

        if (ProcessInformationClass == ProcessBasePriority) {
            ProbeAlignment = sizeof (KPRIORITY);
        } else if (ProcessInformationClass == ProcessEnableAlignmentFaultFixup) {
            ProbeAlignment = sizeof (BOOLEAN);
        } else if (ProcessInformationClass == ProcessForegroundInformation) {
            ProbeAlignment = sizeof (PROCESS_FOREGROUND_BACKGROUND);
        } else if (ProcessInformationClass == ProcessPriorityClass) {
            ProbeAlignment = sizeof (BOOLEAN);
        } else if (ProcessInformationClass == ProcessAffinityMask) {
            ProbeAlignment = sizeof (ULONG_PTR);
        } else {
            ProbeAlignment = sizeof (ULONG);
        }

        try {

            ProbeForRead (ProcessInformation,
                          ProcessInformationLength,
                          ProbeAlignment);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    //
    // Check argument validity.
    //

    switch (ProcessInformationClass) {

    case ProcessWorkingSetWatch: {
        PPAGEFAULT_HISTORY WorkingSetCatcher;

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PsChargeProcessNonPagedPoolQuota (Process, WS_CATCH_SIZE);
        if (NT_SUCCESS (st)) {

            WorkingSetCatcher = ExAllocatePoolWithTag (NonPagedPool, WS_CATCH_SIZE, 'sWsP');
            if (!WorkingSetCatcher) {
                st = STATUS_NO_MEMORY;
            } else {

                PsWatchEnabled = TRUE;
                WorkingSetCatcher->CurrentIndex = 0;
                WorkingSetCatcher->MaxIndex = MAX_WS_CATCH_INDEX;
                KeInitializeSpinLock (&WorkingSetCatcher->SpinLock);

                //
                // This only ever goes on the process and isn't removed till process object deletion.
                // We just need to protect against multiple callers here.
                //
                if (InterlockedCompareExchangePointer (&Process->WorkingSetWatch,
                                                       WorkingSetCatcher, NULL) == NULL) {
                    st = STATUS_SUCCESS;
                } else {
                    ExFreePool (WorkingSetCatcher);
                    st = STATUS_PORT_ALREADY_SET;
                }
            }
            if (!NT_SUCCESS (st)) {
                PsReturnProcessNonPagedPoolQuota (Process, WS_CATCH_SIZE);
            }
        }

        ObDereferenceObject (Process);

        return st;
    }

    case ProcessBasePriority: {


        //
        // THIS ITEM CODE IS OBSOLETE !
        //

        if (ProcessInformationLength != sizeof (KPRIORITY)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            BasePriority = *(KPRIORITY *)ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

        if (BasePriority & 0x80000000) {
            MemoryPriority = MEMORY_PRIORITY_FOREGROUND;
            BasePriority &= ~0x80000000;
        } else {
            MemoryPriority = MEMORY_PRIORITY_BACKGROUND;
        }

        if (BasePriority > HIGH_PRIORITY ||
            BasePriority <= LOW_PRIORITY) {

            return STATUS_INVALID_PARAMETER;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }


        if (BasePriority > Process->Pcb.BasePriority) {

            //
            // Increasing the base priority of a process is a
            // privileged operation.  Check for the privilege
            // here.
            //

            HasPrivilege = SeCheckPrivilegedObject (SeIncreaseBasePriorityPrivilege,
                                                    ProcessHandle,
                                                    PROCESS_SET_INFORMATION,
                                                    PreviousMode);

            if (!HasPrivilege) {

                ObDereferenceObject (Process);
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        KeSetPriorityProcess (&Process->Pcb, BasePriority);
        MmSetMemoryPriorityProcess (Process, MemoryPriority);
        ObDereferenceObject (Process);

        return STATUS_SUCCESS;
    }

    case ProcessPriorityClass: {
        if (ProcessInformationLength != sizeof (PROCESS_PRIORITY_CLASS)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            LocalPriorityClass = *(PPROCESS_PRIORITY_CLASS)ProcessInformation;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (LocalPriorityClass.PriorityClass > PROCESS_PRIORITY_CLASS_ABOVE_NORMAL) {
            return STATUS_INVALID_PARAMETER;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }


        if (LocalPriorityClass.PriorityClass != Process->PriorityClass &&
            LocalPriorityClass.PriorityClass == PROCESS_PRIORITY_CLASS_REALTIME) {

            //
            // Increasing the base priority of a process is a
            // privileged operation.  Check for the privilege
            // here.
            //

            HasPrivilege = SeCheckPrivilegedObject (SeIncreaseBasePriorityPrivilege,
                                                    ProcessHandle,
                                                    PROCESS_SET_INFORMATION,
                                                    PreviousMode);

            if (!HasPrivilege) {

                ObDereferenceObject (Process);
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        //
        // If the process has a job object, override whatever the process
        // is calling with with the value from the job object
        //
        Job = Process->Job;
        if (Job != NULL) {
            KeEnterCriticalRegionThread (&CurrentThread->Tcb);
            ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

            if (Job->LimitFlags & JOB_OBJECT_LIMIT_PRIORITY_CLASS) {
                LocalPriorityClass.PriorityClass = Job->PriorityClass;
            }

            ExReleaseResourceLite (&Job->JobLock);
            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        }

        Process->PriorityClass = LocalPriorityClass.PriorityClass;

        PsSetProcessPriorityByClass (Process,
                                     LocalPriorityClass.Foreground ?
                                         PsProcessPriorityForeground : PsProcessPriorityBackground);

        ObDereferenceObject (Process);

        return STATUS_SUCCESS;
    }

    case ProcessForegroundInformation: {

        if (ProcessInformationLength != sizeof (PROCESS_FOREGROUND_BACKGROUND)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            LocalForeground = *(PPROCESS_FOREGROUND_BACKGROUND)ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }


        PsSetProcessPriorityByClass (Process,
                                     LocalForeground.Foreground ?
                                         PsProcessPriorityForeground : PsProcessPriorityBackground);

        ObDereferenceObject (Process);

        return STATUS_SUCCESS;
    }

    case ProcessRaisePriority: {
        //
        // This code is used to boost the priority of all threads
        // within a process. It cannot be used to change a thread into
        // a realtime class, or to lower the priority of a thread. The
        // argument is a boost value that is added to the base priority
        // of the specified process.
        //


        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            BoostValue = *(PULONG)ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Get the process create/delete lock and walk through the
        // thread list boosting each thread.
        //


        if (ExAcquireRundownProtection (&Process->RundownProtect)) {
            for (Thread = PsGetNextProcessThread (Process, NULL);
                 Thread != NULL;
                 Thread = PsGetNextProcessThread (Process, Thread)) {

                 KeBoostPriorityThread (&Thread->Tcb, (KPRIORITY)BoostValue);
            }
            ExReleaseRundownProtection (&Process->RundownProtect);
        } else {
            st = STATUS_PROCESS_IS_TERMINATING;
        }

        ObDereferenceObject (Process);

        return st;
    }

    case ProcessDefaultHardErrorMode: {
        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            DefaultHardErrorMode = *(PULONG)ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Process->DefaultHardErrorProcessing = DefaultHardErrorMode;
        if (DefaultHardErrorMode & PROCESS_HARDERROR_ALIGNMENT_BIT) {
            KeSetAutoAlignmentProcess (&Process->Pcb,TRUE);
        } else {
            KeSetAutoAlignmentProcess (&Process->Pcb,FALSE);
        }

        ObDereferenceObject (Process);

        return STATUS_SUCCESS;
    }

    case ProcessQuotaLimits: {
        return PspSetQuotaLimits (ProcessHandle,
                                  ProcessInformationClass,
                                  ProcessInformation,
                                  ProcessInformationLength,
                                  PreviousMode);
    }

    case ProcessExceptionPort : {
        if (ProcessInformationLength != sizeof (HANDLE)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            ExceptionPortHandle = *(PHANDLE) ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (!SeSinglePrivilegeCheck (SeTcbPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }



        st = ObReferenceObjectByHandle (ExceptionPortHandle,
                                        0,
                                        LpcPortObjectType,
                                        PreviousMode,
                                        &ExceptionPort,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            ObDereferenceObject (ExceptionPort);
            return st;
        }

        //
        // We are only allowed to put the exception port on. It doesn't get removed till process delete.
        //
        if (InterlockedCompareExchangePointer (&Process->ExceptionPort, ExceptionPort, NULL) == NULL) {
            st = STATUS_SUCCESS;
        } else {
            ObDereferenceObject (ExceptionPort);
            st = STATUS_PORT_ALREADY_SET;
        }
        ObDereferenceObject (Process);

        return st;
    }

    case ProcessAccessToken : {

        if (ProcessInformationLength != sizeof (PROCESS_ACCESS_TOKEN)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            PrimaryTokenHandle  = ((PROCESS_ACCESS_TOKEN *)ProcessInformation)->Token;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }


        st = PspSetPrimaryToken (ProcessHandle,
                                 NULL,
                                 PrimaryTokenHandle,
                                 NULL,
                                 FALSE);

        return st;
    }


    case ProcessLdtInformation:

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION | PROCESS_VM_WRITE,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PspSetLdtInformation (Process,
                                   ProcessInformation,
                                   ProcessInformationLength);

        ObDereferenceObject (Process);
        return st;

    case ProcessLdtSize:

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION | PROCESS_VM_WRITE,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PspSetLdtSize (Process,
                            ProcessInformation,
                            ProcessInformationLength);

        ObDereferenceObject(Process);
        return st;

    case ProcessIoPortHandlers:

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PspSetProcessIoHandlers (Process,
                                      ProcessInformation,
                                      ProcessInformationLength);

        ObDereferenceObject (Process);

        return st;

    case ProcessUserModeIOPL:

        //
        // Must make sure the caller is a trusted subsystem with the
        // appropriate privilege level before executing this call.
        // If the calls returns FALSE we must return an error code.
        //

        if (!SeSinglePrivilegeCheck (SeTcbPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (NT_SUCCESS (st)) {

#if defined (_X86_)

            Ke386SetIOPL ();

#endif

            ObDereferenceObject (Process);
        }

        return st;

        //
        // Enable/disable auto-alignment fixup for a process and all its threads.
        //

    case ProcessEnableAlignmentFaultFixup: {

        if (ProcessInformationLength != sizeof (BOOLEAN)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            EnableAlignmentFaultFixup = *(PBOOLEAN)ProcessInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (EnableAlignmentFaultFixup) {
            Process->DefaultHardErrorProcessing |= PROCESS_HARDERROR_ALIGNMENT_BIT;
        } else {
            Process->DefaultHardErrorProcessing &= ~PROCESS_HARDERROR_ALIGNMENT_BIT;
        }

        KeSetAutoAlignmentProcess (&(Process->Pcb), EnableAlignmentFaultFixup);

        ObDereferenceObject (Process);

        return STATUS_SUCCESS;
    }

    case ProcessWx86Information : {

        ULONG  VdmAllowedFlags;

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {

            VdmAllowedFlags = *(PULONG)ProcessInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        //
        // Must make sure the caller is a trusted subsystem with the
        // appropriate privilege level before executing this call.
        // If the calls returns FALSE we must return an error code.
        //
        if (!SeSinglePrivilegeCheck (SeTcbPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        //
        // Make sure the ProcessHandle is indeed a process handle.
        //

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (NT_SUCCESS (st)) {

            //
            // For now, non zero Flags will allowed VDM.
            //

            if (VdmAllowedFlags) {
                PS_SET_BITS(&Process->Flags, PS_PROCESS_FLAGS_VDM_ALLOWED);
            } else {
                PS_CLEAR_BITS(&Process->Flags, PS_PROCESS_FLAGS_VDM_ALLOWED);
            }
            ObDereferenceObject(Process);
        }

        return st;
    }

    case ProcessAffinityMask:

        if (ProcessInformationLength != sizeof (KAFFINITY)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            Affinity = *(PKAFFINITY)ProcessInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        AffinityWithMasks = Affinity & KeActiveProcessors;

        if (!Affinity || (AffinityWithMasks != Affinity)) {
            return STATUS_INVALID_PARAMETER;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // If the process has a job object, override whatever the process
        // is calling with with the value from the job object
        //
        Job = Process->Job;
        if (Job != NULL) {
            KeEnterCriticalRegionThread (&CurrentThread->Tcb);
            ExAcquireResourceSharedLite (&Job->JobLock, TRUE);

            if (Job->LimitFlags & JOB_OBJECT_LIMIT_AFFINITY) {
                AffinityWithMasks = Job->Affinity;
            }

            ExReleaseResourceLite (&Job->JobLock);
            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        }

        if (ExAcquireRundownProtection (&Process->RundownProtect)) {

            PspLockProcessExclusive (Process, CurrentThread);

            KeSetAffinityProcess (&Process->Pcb, AffinityWithMasks);

            PspUnlockProcessExclusive (Process, CurrentThread);

            ExReleaseRundownProtection (&Process->RundownProtect);

            st = STATUS_SUCCESS;
        } else {
            st = STATUS_PROCESS_IS_TERMINATING;
        }
        ObDereferenceObject (Process);
        return st;

    case ProcessPriorityBoost:
        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            DisableBoost = *(PULONG)ProcessInformation;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        bDisableBoost = (DisableBoost ? TRUE : FALSE);

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Acquire rundown protection to give back the correct error
        // if the process has or is being terminated.
        //


        if (!ExAcquireRundownProtection (&Process->RundownProtect)) {
            st = STATUS_PROCESS_IS_TERMINATING;
        } else {
            PLIST_ENTRY Next;

            PspLockProcessExclusive (Process, CurrentThread);

            Process->Pcb.DisableBoost = bDisableBoost;

            for (Next = Process->ThreadListHead.Flink;
                 Next != &Process->ThreadListHead;
                 Next = Next->Flink) {
                Thread = (PETHREAD)(CONTAINING_RECORD(Next, ETHREAD, ThreadListEntry));
                KeSetDisableBoostThread (&Thread->Tcb, bDisableBoost);
            }

            PspUnlockProcessExclusive (Process, CurrentThread);

            ExReleaseRundownProtection (&Process->RundownProtect);
        }

        ObDereferenceObject (Process);
        return st;

    case ProcessDebugFlags : {
        ULONG Flags;

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        try {
            Flags = *(PULONG) ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Flags = 0;
            st = GetExceptionCode ();
        }
        if (NT_SUCCESS (st)) {
            if (Flags & ~PROCESS_DEBUG_INHERIT) {
                st = STATUS_INVALID_PARAMETER;
            } else {
                if (Flags&PROCESS_DEBUG_INHERIT) {
                    PS_CLEAR_BITS (&Process->Flags, PS_PROCESS_FLAGS_NO_DEBUG_INHERIT);
                } else {
                    PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_NO_DEBUG_INHERIT);
                }
            }
        }

        ObDereferenceObject (Process);

        return st;
    }

    case ProcessDeviceMap:
        DeviceMapInfo = (PPROCESS_DEVICEMAP_INFORMATION)ProcessInformation;
        if (ProcessInformationLength != sizeof (DeviceMapInfo->Set)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            DirectoryHandle = DeviceMapInfo->Set.DirectoryHandle;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }


        //
        // The devmap fields here are synchronized using a private ob spinlock. We don't need to protect with a
        // lock at this level.
        //
        st = ObSetDeviceMap (Process, DirectoryHandle);

        ObDereferenceObject (Process);
        return st;

    case ProcessSessionInformation :

        //
        // Update Multi-User session specific process information
        //
        if (ProcessInformationLength != (ULONG) sizeof (PROCESS_SESSION_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            SessionInfo = *(PPROCESS_SESSION_INFORMATION) ProcessInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        //
        // We only allow TCB to set SessionId's
        //
        if (!SeSinglePrivilegeCheck (SeTcbPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        //
        // Reference process object
        //
        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION | PROCESS_SET_SESSIONID,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Update SessionId in the Token
        //
        if (SessionInfo.SessionId != MmGetSessionId (Process)) {
            st = STATUS_ACCESS_DENIED;
        } else {
            st = STATUS_SUCCESS;
        }

        ObDereferenceObject (Process);

        return( st );

    case ProcessBreakOnTermination:

        if (ProcessInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {

            EnableBreakOnTermination = *(PULONG)ProcessInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (!SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if ( EnableBreakOnTermination ) {

            PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_BREAK_ON_TERMINATION);

        } else {

            PS_CLEAR_BITS (&Process->Flags, PS_PROCESS_FLAGS_BREAK_ON_TERMINATION);

        }

        ObDereferenceObject (Process);

        return STATUS_SUCCESS;

    case ProcessHandleTracing: {

        PPROCESS_HANDLE_TRACING_ENABLE_EX Pht;
        PHANDLE_TABLE HandleTable;
        ULONG Slots;

        Slots = 0;

        //
        // Zero length disables otherwise we enable
        //
        if (ProcessInformationLength != 0) {
            if (ProcessInformationLength != sizeof (PROCESS_HANDLE_TRACING_ENABLE) &&
                ProcessInformationLength != sizeof (PROCESS_HANDLE_TRACING_ENABLE_EX)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Pht = (PPROCESS_HANDLE_TRACING_ENABLE_EX) ProcessInformation;


            try {
                if (Pht->Flags != 0) {
                    return STATUS_INVALID_PARAMETER;
                }
                if (ProcessInformationLength == sizeof (PROCESS_HANDLE_TRACING_ENABLE_EX)) {
                    Slots = Pht->TotalSlots;
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }
        }

        st = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_INFORMATION,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }
        HandleTable = ObReferenceProcessHandleTable (Process);

        if (HandleTable != NULL) {
            if (ProcessInformationLength != 0) {
                st = ExEnableHandleTracing (HandleTable, Slots);
            } else {
                st = ExDisableHandleTracing (HandleTable);
            }
            ObDereferenceProcessHandleTable (Process);
        } else {
            st = STATUS_PROCESS_IS_TERMINATING;
        }

        ObDereferenceObject(Process);
        return st;
    }


    default:
        return STATUS_INVALID_INFO_CLASS;
    }

}


NTSTATUS
NtQueryInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function queries the state of a thread object and returns the
    requested information in the specified record structure.

Arguments:

    ThreadHandle - Supplies a handle to a thread object.

    ThreadInformationClass - Supplies the class of information being
        requested.

    ThreadInformation - Supplies a pointer to a record that is to
        receive the requested information.

    ThreadInformationLength - Supplies the length of the record that is
        to receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that is to
        receive the actual length of information that is returned.

Return Value:

    TBS

--*/

{

    LARGE_INTEGER PerformanceCount;
    PETHREAD Thread;
    PEPROCESS Process;
    ULONG LastThread;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS st;
    THREAD_BASIC_INFORMATION BasicInfo;
    KERNEL_USER_TIMES SysUserTime;
    PVOID Win32StartAddressValue;
    ULONG DisableBoost;
    ULONG IoPending ;
    ULONG BreakOnTerminationEnabled;
    PETHREAD CurrentThread;

    //
    // Get previous processor mode and probe output argument if necessary.
    //

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (PreviousMode != KernelMode) {
        try {
            //
            // Since these functions don't change any state thats not reversible
            // in the error paths we only probe the output buffer for write access.
            // This improves performance by not touching the buffer multiple times
            // And only writing the portions of the buffer that change.
            //

            ProbeForRead (ThreadInformation,
                          ThreadInformationLength,
                          sizeof(ULONG));

            if (ARGUMENT_PRESENT( ReturnLength)) {
                ProbeForWriteUlong (ReturnLength);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    //
    // Check argument validity.
    //

    switch (ThreadInformationClass) {

    case ThreadBasicInformation:

        if (ThreadInformationLength != (ULONG) sizeof (THREAD_BASIC_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (KeReadStateThread (&Thread->Tcb)) {
            BasicInfo.ExitStatus = Thread->ExitStatus;
        } else {
            BasicInfo.ExitStatus = STATUS_PENDING;
        }

        BasicInfo.TebBaseAddress = (PTEB) Thread->Tcb.Teb;
        BasicInfo.ClientId = Thread->Cid;
        BasicInfo.AffinityMask = Thread->Tcb.Affinity;
        BasicInfo.Priority = Thread->Tcb.Priority;
        BasicInfo.BasePriority = KeQueryBasePriorityThread (&Thread->Tcb);

        ObDereferenceObject (Thread);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PTHREAD_BASIC_INFORMATION) ThreadInformation = BasicInfo;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (THREAD_BASIC_INFORMATION);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ThreadTimes:

        if (ThreadInformationLength != (ULONG) sizeof (KERNEL_USER_TIMES)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        SysUserTime.KernelTime.QuadPart = UInt32x32To64(Thread->Tcb.KernelTime,
                                                        KeMaximumIncrement);

        SysUserTime.UserTime.QuadPart = UInt32x32To64(Thread->Tcb.UserTime,
                                                      KeMaximumIncrement);

        SysUserTime.CreateTime.QuadPart = PS_GET_THREAD_CREATE_TIME(Thread);
        if (KeReadStateThread(&Thread->Tcb)) {
            SysUserTime.ExitTime = Thread->ExitTime;
        } else {
            SysUserTime.ExitTime.QuadPart = 0;
        }

        ObDereferenceObject (Thread);

        //
        // Either of these may cause an access violation. The
        // exception handler will return access violation as
        // status code. No further cleanup needs to be done.
        //

        try {
            *(PKERNEL_USER_TIMES) ThreadInformation = SysUserTime;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (KERNEL_USER_TIMES);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ThreadDescriptorTableEntry :

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        st = PspQueryDescriptorThread (Thread,
                                       ThreadInformation,
                                       ThreadInformationLength,
                                       ReturnLength);

        ObDereferenceObject (Thread);

        return st;

    case ThreadQuerySetWin32StartAddress:
        if (ThreadInformationLength != sizeof (ULONG_PTR)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Win32StartAddressValue = Thread->Win32StartAddress;
        ObDereferenceObject (Thread);

        try {
            *(PVOID *) ThreadInformation = Win32StartAddressValue;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (ULONG_PTR);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return st;

        //
        // Query thread cycle counter.
        //

    case ThreadPerformanceCount:
        if (ThreadInformationLength != sizeof (LARGE_INTEGER)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

#if defined (PERF_DATA)
        PerformanceCount.LowPart = Thread->PerformanceCountLow;
        PerformanceCount.HighPart = Thread->PerformanceCountHigh;
#else
        PerformanceCount.QuadPart = 0;
#endif
        ObDereferenceObject(Thread);

        try {
            *(PLARGE_INTEGER)ThreadInformation = PerformanceCount;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (LARGE_INTEGER);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return st;

    case ThreadAmILastThread:
        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        Process = THREAD_TO_PROCESS (CurrentThread);

        if (Process->ActiveThreads == 1) {
            LastThread = 1;
        } else {
            LastThread = 0;
        }

        try {
            *(PULONG)ThreadInformation = LastThread;

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    case ThreadPriorityBoost:
        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        DisableBoost = Thread->Tcb.DisableBoost ? 1 : 0;

        ObDereferenceObject (Thread);

        try {
            *(PULONG)ThreadInformation = DisableBoost;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return st;

    case ThreadIsIoPending:

        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Its impossible to synchronize this cross thread.
        // Since the result is worthless the second its fetched
        // this isn't a problem.
        //
        IoPending = !IsListEmpty (&Thread->IrpList);


        ObDereferenceObject (Thread);

        try {
            *(PULONG)ThreadInformation = IoPending ;

            if (ARGUMENT_PRESENT (ReturnLength) ) {
                *ReturnLength = sizeof (ULONG);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

        return STATUS_SUCCESS ;

    case ThreadBreakOnTermination:

        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION) {

            BreakOnTerminationEnabled = 1;

        } else {

            BreakOnTerminationEnabled = 0;

        }

        ObDereferenceObject(Thread);

        try {

            *(PULONG) ThreadInformation = BreakOnTerminationEnabled;

            if (ARGUMENT_PRESENT(ReturnLength) ) {
                *ReturnLength = sizeof(ULONG);
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        return STATUS_SUCCESS;

    default:
        return STATUS_INVALID_INFO_CLASS;
    }

}

NTSTATUS
NtSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    )

/*++

Routine Description:

    This function sets the state of a thread object.

Arguments:

    ThreadHandle - Supplies a handle to a thread object.

    ThreadInformationClass - Supplies the class of information being
        set.

    ThreadInformation - Supplies a pointer to a record that contains the
        information to set.

    ThreadInformationLength - Supplies the length of the record that contains
        the information to set.

Return Value:

    TBS

--*/

{
    PETHREAD Thread;
    PETHREAD CurrentThread;
    PEPROCESS Process;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS st;
    KAFFINITY Affinity, AffinityWithMasks;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG TlsIndex;
    PVOID TlsArrayAddress;
    PVOID Win32StartAddressValue;
    ULONG ProbeAlignment;
    BOOLEAN EnableAlignmentFaultFixup;
    ULONG EnableBreakOnTermination;
    ULONG IdealProcessor;
    ULONG DisableBoost;
    PVOID *ExpansionSlots;
    HANDLE ImpersonationTokenHandle;
    BOOLEAN HasPrivilege;
    PEJOB Job;
    PTEB Teb;

    PAGED_CODE();

    //
    // Get previous processor mode and probe input argument if necessary.
    //

    CurrentThread = PsGetCurrentThread ();

    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (PreviousMode != KernelMode) {
        try {

            switch (ThreadInformationClass) {

            case ThreadPriority :
                ProbeAlignment = sizeof(KPRIORITY);
                break;
            case ThreadAffinityMask :
            case ThreadQuerySetWin32StartAddress :
                ProbeAlignment = sizeof (ULONG_PTR);
                break;
            case ThreadEnableAlignmentFaultFixup :
                ProbeAlignment = sizeof (BOOLEAN);
                break;
            default :
                ProbeAlignment = sizeof(ULONG);
            }

            ProbeForRead(
                ThreadInformation,
                ThreadInformationLength,
                ProbeAlignment);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }

    //
    // Check argument validity.
    //

    switch (ThreadInformationClass) {

    case ThreadPriority:

        if (ThreadInformationLength != sizeof (KPRIORITY)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            Priority = *(KPRIORITY *)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (Priority > HIGH_PRIORITY ||
            Priority <= LOW_PRIORITY) {

            return STATUS_INVALID_PARAMETER;
        }

        if (Priority >= LOW_REALTIME_PRIORITY) {

            //
            // Increasing the priority of a thread beyond
            // LOW_REALTIME_PRIORITY is a privileged operation.
            //

            HasPrivilege = SeCheckPrivilegedObject (SeIncreaseBasePriorityPrivilege,
                                                    ThreadHandle,
                                                    THREAD_SET_INFORMATION,
                                                    PreviousMode);

            if (!HasPrivilege) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        KeSetPriorityThread (&Thread->Tcb, Priority);

        ObDereferenceObject (Thread);

        return STATUS_SUCCESS;

    case ThreadBasePriority:

        if (ThreadInformationLength != sizeof (LONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            BasePriority = *(PLONG)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }
        Process = THREAD_TO_PROCESS (Thread);


        if (BasePriority > THREAD_BASE_PRIORITY_MAX ||
            BasePriority < THREAD_BASE_PRIORITY_MIN) {
            if (BasePriority == THREAD_BASE_PRIORITY_LOWRT+1 ||
                BasePriority == THREAD_BASE_PRIORITY_IDLE-1) {
                ;
            } else {

                //
                // Allow csrss, or realtime processes to select any
                // priority
                //

                if (PsGetCurrentProcessByThread (CurrentThread) == ExpDefaultErrorPortProcess ||
                    Process->PriorityClass == PROCESS_PRIORITY_CLASS_REALTIME) {
                    ;
                } else {
                    ObDereferenceObject (Thread);
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }

        //
        // If the thread is running within a job object, and the job
        // object has a priority class limit, do not allow
        // priority adjustments that raise the thread's priority, unless
        // the priority class is realtime
        //

        Job = Process->Job;
        if (Job != NULL && (Job->LimitFlags & JOB_OBJECT_LIMIT_PRIORITY_CLASS)) {
            if (Process->PriorityClass != PROCESS_PRIORITY_CLASS_REALTIME){
                if (BasePriority > 0) {
                    ObDereferenceObject (Thread);
                    return STATUS_SUCCESS;
                }
            }
        }

        KeSetBasePriorityThread (&Thread->Tcb, BasePriority);

        ObDereferenceObject (Thread);

        return STATUS_SUCCESS;

    case ThreadEnableAlignmentFaultFixup:

        if (ThreadInformationLength != sizeof (BOOLEAN) ) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            EnableAlignmentFaultFixup = *(PBOOLEAN)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        KeSetAutoAlignmentThread (&Thread->Tcb, EnableAlignmentFaultFixup);

        ObDereferenceObject (Thread);

        return STATUS_SUCCESS;

    case ThreadAffinityMask:

        if (ThreadInformationLength != sizeof (KAFFINITY)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            Affinity = *(PKAFFINITY)ThreadInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (!Affinity) {
            return STATUS_INVALID_PARAMETER;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Process = THREAD_TO_PROCESS (Thread);

        if (ExAcquireRundownProtection (&Process->RundownProtect)) {

            PspLockProcessShared (Process, CurrentThread);

            AffinityWithMasks = Affinity & Process->Pcb.Affinity;
            if (AffinityWithMasks != Affinity) {
                st = STATUS_INVALID_PARAMETER;
            } else {
                KeSetAffinityThread (&Thread->Tcb,
                                     AffinityWithMasks);
                st = STATUS_SUCCESS;
            }

            PspUnlockProcessShared (Process, CurrentThread);

            ExReleaseRundownProtection (&Process->RundownProtect);
        } else {
            st = STATUS_PROCESS_IS_TERMINATING;
        }

        ObDereferenceObject (Thread);

        return st;

    case ThreadImpersonationToken:


        if (ThreadInformationLength != sizeof (HANDLE)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }


        try {
            ImpersonationTokenHandle = *(PHANDLE) ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }


        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_THREAD_TOKEN,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // Check for proper access to (and type of) the token, and assign
        // it as the thread's impersonation token.
        //

        st = PsAssignImpersonationToken (Thread, ImpersonationTokenHandle);


        ObDereferenceObject (Thread);

        return st;

    case ThreadQuerySetWin32StartAddress:
        if (ThreadInformationLength != sizeof (ULONG_PTR)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }


        try {
            Win32StartAddressValue = *(PVOID *) ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }


        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Thread->Win32StartAddress = (PVOID)Win32StartAddressValue;

        ObDereferenceObject (Thread);

        return st;


    case ThreadIdealProcessor:

        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }


        try {
            IdealProcessor = *(PULONG)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        if (IdealProcessor > MAXIMUM_PROCESSORS) {
            return STATUS_INVALID_PARAMETER;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);
        if (!NT_SUCCESS (st)) {
            return st;
        }

        //
        // this is sort of a slimey way of returning info from this set only
        // api
        //

        st = (NTSTATUS)KeSetIdealProcessorThread (&Thread->Tcb, (CCHAR)IdealProcessor);

        //
        // We could be making cross process and/or cross thread references here.
        // Acquire rundown protection to make sure the teb can't go away.
        //
        Teb = Thread->Tcb.Teb;
        if (Teb != NULL && ExAcquireRundownProtection (&Thread->RundownProtect)) {
            PEPROCESS TargetProcess;
            BOOLEAN Attached;
            KAPC_STATE ApcState;

            Attached = FALSE;
            //
            // See if we are crossing process boundaries and if so attach to the target
            //
            TargetProcess = THREAD_TO_PROCESS (Thread);
            if (TargetProcess != PsGetCurrentProcessByThread (CurrentThread)) {
                KeStackAttachProcess (&TargetProcess->Pcb, &ApcState);
                Attached = TRUE;
            }

            try {

                Teb->IdealProcessor = Thread->Tcb.IdealProcessor;
            } except (EXCEPTION_EXECUTE_HANDLER) {
            }

            if (Attached) {
                KeUnstackDetachProcess (&ApcState);
            }

            ExReleaseRundownProtection (&Thread->RundownProtect);


        }


        ObDereferenceObject (Thread);

        return st;


    case ThreadPriorityBoost:
        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            DisableBoost = *(PULONG)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        KeSetDisableBoostThread (&Thread->Tcb,DisableBoost ? TRUE : FALSE);

        ObDereferenceObject (Thread);

        return st;

    case ThreadZeroTlsCell:
        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {
            TlsIndex = *(PULONG) ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        ObDereferenceObject (Thread);

        if (Thread != CurrentThread) {
            return STATUS_INVALID_PARAMETER;
        }

        Process = THREAD_TO_PROCESS (Thread);


        // The 32bit TEB needs to be set if this is a WOW64 process on a 64BIT system.
        // This code isn't 100% correct since threads have a conversion state where they
        // are chaning from 64 to 32 and they don't have a TEB32 yet.  Fortunatly, the slots
        // will be zero when the thread is created so no damage is done by not clearing it here.

        // Note that the test for the process type is inside the inner loop. This
        // is bad programming, but this function is hardly time constrained and
        // fixing this with complex macros would not be worth it due to the loss of clairity.

        for (Thread = PsGetNextProcessThread (Process, NULL);
             Thread != NULL;
             Thread = PsGetNextProcessThread (Process, Thread)) {

            //
            // We are doing cross thread TEB references and need to prevent TEB deletion.
            //
            if (ExAcquireRundownProtection (&Thread->RundownProtect)) {
                Teb = Thread->Tcb.Teb;
                if (Teb != NULL) {
                    try {
#if defined(_WIN64)
                        PTEB32 Teb32 = NULL;
                        PLONG ExpansionSlots32;

                        if (Process->Wow64Process) { //wow64 process
                            Teb32 = WOW64_GET_TEB32(Teb);  //No probing needed on regular TEB.
                        }
#endif
                        if (TlsIndex > TLS_MINIMUM_AVAILABLE-1) {
                            if ( TlsIndex < (TLS_MINIMUM_AVAILABLE+TLS_EXPANSION_SLOTS) - 1 ) {
                                //
                                // This is an expansion slot, so see if the thread
                                // has an expansion cell
                                //
#if defined(_WIN64)
                                if (Process->Wow64Process) { //Wow64 process.
                                    if (Teb32) {
                                        ExpansionSlots32 = ULongToPtr(ProbeAndReadUlong(&(Teb32->TlsExpansionSlots)));
                                        if (ExpansionSlots32) {
                                            ProbeAndWriteLong(ExpansionSlots32 + TlsIndex - TLS_MINIMUM_AVAILABLE, 0);
                                        }
                                    }
                                } else {
#endif
                                    ExpansionSlots = Teb->TlsExpansionSlots;
                                    ProbeForReadSmallStructure (ExpansionSlots, TLS_EXPANSION_SLOTS*4, 8);
                                    if ( ExpansionSlots ) {
                                        ExpansionSlots[TlsIndex-TLS_MINIMUM_AVAILABLE] = 0;
                                    }

#if defined(_WIN64)
                                }
#endif
                            }
                        } else {
#if defined(_WIN64)
                            if (Process->Wow64Process) { //wow64 process
                               if(Teb32) {
                                  ProbeAndWriteUlong(Teb32->TlsSlots + TlsIndex, 0);
                               }
                            } else {
#endif
                               Teb->TlsSlots[TlsIndex] = NULL;
#if defined(_WIN64)
                            }
#endif
                        }
                    } except (EXCEPTION_EXECUTE_HANDLER) {
                        st = GetExceptionCode ();
                    }

                }
                ExReleaseRundownProtection (&Thread->RundownProtect);
            }
        }

        return st;
        break;

    case ThreadSetTlsArrayAddress:
        if (ThreadInformationLength != sizeof (PVOID)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }


        try {
            TlsArrayAddress = *(PVOID *)ThreadInformation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        Thread->Tcb.TlsArray = TlsArrayAddress;

        ObDereferenceObject (Thread);

        return st;
        break;

    case ThreadHideFromDebugger:
        if (ThreadInformationLength != 0) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HIDEFROMDBG);

        ObDereferenceObject (Thread);

        return st;
        break;

    case ThreadBreakOnTermination:

        if (ThreadInformationLength != sizeof (ULONG)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        try {

            EnableBreakOnTermination = *(PULONG)ThreadInformation;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

        if (!SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        st = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        PreviousMode,
                                        &Thread,
                                        NULL);

        if (!NT_SUCCESS (st)) {
            return st;
        }

        if (EnableBreakOnTermination) {

            PS_SET_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION);

        } else {

            PS_CLEAR_BITS (&Thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION);

        }

        ObDereferenceObject (Thread);

        return STATUS_SUCCESS;

    default:
        return STATUS_INVALID_INFO_CLASS;
    }
}

ULONG
NtGetCurrentProcessorNumber(
    VOID
    )
{
    return KeGetCurrentProcessorNumber();
}

VOID
PsWatchWorkingSet(
    IN NTSTATUS Status,
    IN PVOID PcValue,
    IN PVOID Va
    )

/*++

Routine Description:

    This function collects data about page faults and stores information
    about the page fault in the current process's data structure.

Arguments:

    Status - Supplies the success completion status.

    PcValue - Supplies the instruction address that caused the page fault.

    Va - Supplies the virtual address that caused the page fault.

--*/

{

    PEPROCESS Process;
    PPAGEFAULT_HISTORY WorkingSetCatcher;
    KIRQL OldIrql;
    BOOLEAN TransitionFault = FALSE;

    //
    // Both transition and demand zero faults count as soft faults. Only disk
    // reads count as hard faults.
    //

    if ( Status <= STATUS_PAGE_FAULT_DEMAND_ZERO ) {
        TransitionFault = TRUE;
    }

    Process = PsGetCurrentProcess();
    WorkingSetCatcher = Process->WorkingSetWatch;
    if (WorkingSetCatcher == NULL) {
        return;
    }

    ExAcquireSpinLock(&WorkingSetCatcher->SpinLock,&OldIrql);
    if (WorkingSetCatcher->CurrentIndex >= WorkingSetCatcher->MaxIndex) {
        ExReleaseSpinLock(&WorkingSetCatcher->SpinLock,OldIrql);
        return;
    }

    //
    // Store the Pc and Va values in the buffer. Use the least sig. bit
    // of the Va to store whether it was a soft or hard fault
    //

    WorkingSetCatcher->WatchInfo[WorkingSetCatcher->CurrentIndex].FaultingPc = PcValue;
    WorkingSetCatcher->WatchInfo[WorkingSetCatcher->CurrentIndex].FaultingVa = TransitionFault ? (PVOID)((ULONG_PTR)Va | 1) : (PVOID)((ULONG_PTR)Va & 0xfffffffe) ;
    WorkingSetCatcher->CurrentIndex++;
    ExReleaseSpinLock(&WorkingSetCatcher->SpinLock,OldIrql);
    return;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

PKWIN32_PROCESS_CALLOUT PspW32ProcessCallout = NULL;
PKWIN32_THREAD_CALLOUT PspW32ThreadCallout = NULL;
PKWIN32_JOB_CALLOUT PspW32JobCallout = NULL;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
extern PKWIN32_POWEREVENT_CALLOUT PopEventCallout;
extern PKWIN32_POWERSTATE_CALLOUT PopStateCallout;



NTKERNELAPI
VOID
PsEstablishWin32Callouts(
   IN PKWIN32_CALLOUTS_FPNS pWin32Callouts )

/*++

Routine Description:

    This function is used by the Win32 kernel mode component to
    register callout functions for process/thread init/deinit functions
    and to report the sizes of the structures.

Arguments:

    ProcessCallout - Supplies the address of the function to be called when
        a process is either created or deleted.

    ThreadCallout - Supplies the address of the function to be called when
        a thread is either created or deleted.

    GlobalAtomTableCallout - Supplies the address of the function to be called
        to get the correct global atom table for the current process

    PowerEventCallout - Supplies the address of a function to be called when
        a power event occurs.

    PowerStateCallout - Supplies the address of a function to be called when
        the power state changes.

    JobCallout - Supplies the address of a function to be called when
        the job state changes or a process is assigned to a job.

    BatchFlushRoutine - Supplies the address of the function to be called

Return Value:

    None.

--*/

{
    PAGED_CODE();

    PspW32ProcessCallout = pWin32Callouts->ProcessCallout;
    PspW32ThreadCallout = pWin32Callouts->ThreadCallout;
    ExGlobalAtomTableCallout = pWin32Callouts->GlobalAtomTableCallout;
    KeGdiFlushUserBatch = (PGDI_BATCHFLUSH_ROUTINE)pWin32Callouts->BatchFlushRoutine;
    PopEventCallout = pWin32Callouts->PowerEventCallout;
    PopStateCallout = pWin32Callouts->PowerStateCallout;
    PspW32JobCallout = pWin32Callouts->JobCallout;
//    PoSetSystemState(ES_SYSTEM_REQUIRED);


    ExDesktopOpenProcedureCallout = pWin32Callouts->DesktopOpenProcedure;
    ExDesktopOkToCloseProcedureCallout = pWin32Callouts->DesktopOkToCloseProcedure;
    ExDesktopCloseProcedureCallout = pWin32Callouts->DesktopCloseProcedure;
    ExDesktopDeleteProcedureCallout = pWin32Callouts->DesktopDeleteProcedure;
    ExWindowStationOkToCloseProcedureCallout = pWin32Callouts->WindowStationOkToCloseProcedure;
    ExWindowStationCloseProcedureCallout = pWin32Callouts->WindowStationCloseProcedure;
    ExWindowStationDeleteProcedureCallout = pWin32Callouts->WindowStationDeleteProcedure;
    ExWindowStationParseProcedureCallout = pWin32Callouts->WindowStationParseProcedure;
    ExWindowStationOpenProcedureCallout = pWin32Callouts->WindowStationOpenProcedure;

}


VOID
PsSetProcessPriorityByClass(
    IN PEPROCESS Process,
    IN PSPROCESSPRIORITYMODE PriorityMode
    )
{
    KPRIORITY BasePriority;
    UCHAR MemoryPriority;
    ULONG QuantumIndex;
    PEJOB Job;

    PAGED_CODE();


    BasePriority = PspPriorityTable[Process->PriorityClass];


    if (PriorityMode == PsProcessPriorityForeground ) {
        QuantumIndex = PsPrioritySeperation;
        MemoryPriority = MEMORY_PRIORITY_FOREGROUND;
    } else {
        QuantumIndex = 0;
        MemoryPriority = MEMORY_PRIORITY_BACKGROUND;
    }

    if (Process->PriorityClass != PROCESS_PRIORITY_CLASS_IDLE) {
        Job = Process->Job;
        if (Job != NULL && PspUseJobSchedulingClasses ) {
            Process->Pcb.ThreadQuantum = PspJobSchedulingClasses[Job->SchedulingClass];
        } else {
            Process->Pcb.ThreadQuantum = PspForegroundQuantum[QuantumIndex];
        }
    } else {
        Process->Pcb.ThreadQuantum = THREAD_QUANTUM;
    }

    KeSetPriorityProcess (&Process->Pcb,BasePriority);
    if (PriorityMode != PsProcessPrioritySpinning ) {
        MmSetMemoryPriorityProcess(Process, MemoryPriority);
    }
}



#if defined(_X86_)
#pragma optimize ("y",off)
#endif

NTSTATUS
PsConvertToGuiThread(
    VOID
    )

/*++

Routine Description:

    This function converts a thread to a GUI thread. This involves giving the
    thread a larger variable sized stack, and allocating appropriate w32
    thread and process objects.

Arguments:

    None.

Environment:

    On x86 this function needs to build an EBP frame.  The function
    KeSwitchKernelStack depends on this fact.   The '#pragma optimize
    ("y",off)' below disables frame pointer omission for all builds.

Return Value:

    TBD

--*/

{
    PVOID NewStack;
    PVOID OldStack;
    PETHREAD Thread;
    PEPROCESS Process;
    NTSTATUS Status;
    PKNODE Node;

    PAGED_CODE();

    Thread = PsGetCurrentThread();

    if (KeGetPreviousModeByThread(&Thread->Tcb) == KernelMode) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!PspW32ProcessCallout) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // If the thread is using the shadow service table, then an attempt is
    // being made to convert a thread that has already been converted, or
    // a limit violation has occured on the Win32k system service table.
    //

    if (Thread->Tcb.ServiceTable != (PVOID)&KeServiceDescriptorTable[0]) {
        return STATUS_ALREADY_WIN32;
    }

    Process = PsGetCurrentProcessByThread (Thread);

    //
    // Get a larger kernel stack if we haven't already.
    //

    if (!Thread->Tcb.LargeStack) {

        Node = KiProcessorBlock[Thread->Tcb.IdealProcessor]->ParentNode;
        NewStack = MmCreateKernelStack(TRUE,
                                       Node->NodeNumber);

        if ( !NewStack ) {

            try {
                NtCurrentTeb()->LastErrorValue = (LONG)ERROR_NOT_ENOUGH_MEMORY;
            } except (EXCEPTION_EXECUTE_HANDLER) {
            }

            return STATUS_NO_MEMORY;
        }

        //
        // Switching kernel stacks will copy the base trap frame. This needs
        // to be protected from context changes by disabline kernel APC's.
        //

        KeEnterGuardedRegionThread (&Thread->Tcb);

#if defined(_IA64_)
        OldStack = KeSwitchKernelStack(NewStack,
                                   (UCHAR *)NewStack - KERNEL_LARGE_STACK_COMMIT,
                                   (UCHAR *)NewStack + KERNEL_LARGE_BSTORE_COMMIT);
#else
        OldStack = KeSwitchKernelStack(NewStack,
                                   (UCHAR *)NewStack - KERNEL_LARGE_STACK_COMMIT);
#endif // defined(_IA64_)

        KeLeaveGuardedRegionThread (&Thread->Tcb);

        MmDeleteKernelStack(OldStack, FALSE);

    }

    PERFINFO_CONVERT_TO_GUI_THREAD(Thread);

    //
    // We are all clean on the stack, now call out and then link the Win32 structures
    // to the base exec structures
    //

    Status = (PspW32ProcessCallout) (Process, TRUE);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Switch the thread to use the shadow system serive table which will
    // enable it to execute Win32k services.
    //

    Thread->Tcb.ServiceTable = (PVOID)&KeServiceDescriptorTableShadow[0];

    ASSERT (Thread->Tcb.Win32Thread == 0);


    //
    // Make the thread callout.
    //

    Status = (PspW32ThreadCallout)(Thread,PsW32ThreadCalloutInitialize);
    if (!NT_SUCCESS (Status)) {
        Thread->Tcb.ServiceTable = (PVOID)&KeServiceDescriptorTable[0];
    }

    return Status;

}

#if defined(_X86_)
#pragma optimize ("y",on)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\amd64\psldt.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    psldt.c

Abstract:

    This module contains AMD64 stubs for the process and thread ldt support.

Author:

    David N. Cutler (davec) 13-Oct-2000

--*/

#include "psp.h"

NTSTATUS
PspQueryLdtInformation (
    IN PEPROCESS Process,
    OUT PVOID LdtInformation,
    IN ULONG LdtInformationLength,
    OUT PULONG ReturnLength
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Process - Supplies a pointer to a executive process object.

    LdtInformation - Supplies a pointer to the information buffer.

    LdtInformationLength - Supplies the length of the information buffer.

    ReturnLength - Supplies a pointer to a variable that receives the number
        of bytes returned in the information buffer.

Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{

    UNREFERENCED_PARAMETER(Process);
    UNREFERENCED_PARAMETER(LdtInformation);
    UNREFERENCED_PARAMETER(LdtInformationLength);
    UNREFERENCED_PARAMETER(ReturnLength);

    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
PspSetLdtSize(
    IN PEPROCESS Process,
    IN PVOID LdtSize,
    IN ULONG LdtSizeLength
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Process -- Supplies a pointer to an executive process object.

    LdtSize -- Supplies a pointer to the LDT size infomration.

    LdtSizeLength - Supplies the length of the LDT size information.


Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{
    UNREFERENCED_PARAMETER(Process);
    UNREFERENCED_PARAMETER(LdtSize);
    UNREFERENCED_PARAMETER(LdtSizeLength);

    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
PspSetLdtInformation(
    IN PEPROCESS Process,
    IN PVOID LdtInformation,
    IN ULONG LdtInformationLength
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Process -- Supplies a pointer to an executive process object.

    LdtInformation -- Supplies a pointer to the information buffer.

    LdtInformationLength -- Supplies the length of the information buffer.

Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{

    UNREFERENCED_PARAMETER(Process);
    UNREFERENCED_PARAMETER(LdtInformation);
    UNREFERENCED_PARAMETER(LdtInformationLength);

    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
PspQueryDescriptorThread (
    PETHREAD Thread,
    PVOID ThreadInformation,
    ULONG ThreadInformationLength,
    PULONG ReturnLength
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Thread - Supplies a pointer to an executive thread object.

    ThreadInformation - Supplies a pointer to the thread descriptor
        information.

    ThreadInformationLength - Supplies the length of the thread descriptor
        information.

    ReturnLength - Supplies a pointer to a variable that receives the number
        of bytes returned in the descriptor information buffer.

Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{

    UNREFERENCED_PARAMETER(Thread);
    UNREFERENCED_PARAMETER(ThreadInformation);
    UNREFERENCED_PARAMETER(ThreadInformationLength);
    UNREFERENCED_PARAMETER(ReturnLength);

    return STATUS_NOT_IMPLEMENTED;
}

VOID
PspDeleteLdt(
    IN PEPROCESS Process
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Process -- Supplies a pointer to an executive process object.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER(Process);

    return;
}

NTSTATUS
NtSetLdtEntries(
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1High
    )

/*++

Routine Description:

    This function is not implemented on AMD64.

Arguments:

    Selector0 - Supplies the number of the first descriptor to set.

    Entry0Low - Supplies the low 32 bits of the descriptor.

    Entry0Hi - Supplies the high 32 bits of the descriptor.

    Selector1 - Supplies the number of the last descriptor to set.

    Entry1Low - Supplies the low 32 bits of the descriptor.

    Entry1Hi - Supplies the high 32 bits of the descriptor.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(Selector0);
    UNREFERENCED_PARAMETER(Entry0Low);
    UNREFERENCED_PARAMETER(Entry0Hi);
    UNREFERENCED_PARAMETER(Selector1);
    UNREFERENCED_PARAMETER(Entry1Low);
    UNREFERENCED_PARAMETER(Entry1High);

    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\i386\psctx386.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psctx.c

Abstract:

    This procedure implements Get/Set Context Thread

Author:

    Mark Lucovsky (markl) 25-May-1989

Notes:

    There IS NO NonVolatileContext stored outside of the trap
    frame on a 386, with the exception of floating point.  Hence,
    the NonVolatileContextPointers argument to Get/SetContext is
    always NULL on the 386.

Revision History:

     8-Jan-90   bryanwi

        Port to 386

--*/

#include "psp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PspGetContext )
#pragma alloc_text(PAGE,PspGetSetContextSpecialApc )
#pragma alloc_text(PAGE,PspSetContext)
#endif


VOID
PspGetContext(
    IN PKTRAP_FRAME TrapFrame,
    IN PKNONVOLATILE_CONTEXT_POINTERS NonVolatileContext,
    IN OUT PCONTEXT Context
    )

/*++

Routine Description:

    This function moves the contents of the specified trap and NonVolatile
    context into the specified context record. It's primary user will
    be NtGetContextThread.

    N.B. - NonVolatileContext is IGNORED on the 386.

Arguments:

    TrapFrame - Supplies the contents of a trap frame that should be
                restored copied into the proper location in the context
                record.

    Context - Returns the threads current context.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( NonVolatileContext );

    PAGED_CODE();

    KeContextFromKframes(TrapFrame, NULL, Context);
}

VOID
PspSetContext(
    OUT PKTRAP_FRAME TrapFrame,
    OUT PKNONVOLATILE_CONTEXT_POINTERS NonVolatileContext,
    IN PCONTEXT Context,
    KPROCESSOR_MODE Mode
    )

/*++

Routine Description:

    This function moves the contents of the specified context record
    into the specified trap frame, and modifies the thread's non volatile
    context by storing through the thread's nonvolatile context pointers.

    N.B. - NonVolatileContext is IGNORED on the 386.

Arguments:

    TrapFrame - Returns selected pieces of the context record.

    Context - Supplies a context record to be copied in the trap and
              nonvolatile context.

    Mode - Supplies the mode to be used when sanitizing the psr, epsr and fsr

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( NonVolatileContext );

    PAGED_CODE();

    KeContextToKframes(TrapFrame, NULL, Context, Context->ContextFlags, Mode);
}

VOID
PspGetSetContextSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function either captures the usermode state of the current
    thread, or sets the usermode state of the current thread. The
    operation type is determined by the value of SystemArgument1. A
    NULL value is used for get context, and a non-NULL value is used
    for set context.

Arguments:

    Apc - Supplies a pointer to the APC control object that caused entry
          into this routine.

    NormalRoutine - Supplies a pointer to a pointer to the normal routine
        function that was specifed when the APC was initialized.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointer to two
        arguments that contain untyped data.

Return Value:

    None.

--*/

{
    PGETSETCONTEXT Ctx;
    PKTRAP_FRAME TrapFrame;
    PETHREAD Thread;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( NormalRoutine );
    UNREFERENCED_PARAMETER( NormalContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    Ctx = CONTAINING_RECORD(Apc,GETSETCONTEXT,Apc);

    Thread = Apc->SystemArgument2;

    TrapFrame = NULL;

    if (Ctx->Mode == KernelMode) {
        TrapFrame = Thread->Tcb.TrapFrame;
    }

    if (TrapFrame == NULL) {
        TrapFrame = PspGetBaseTrapFrame (Thread);
    }

    if ( Apc->SystemArgument1 ) {

        //
        // Set Context
        //

        PspSetContext(TrapFrame,NULL,&Ctx->Context,Ctx->Mode);

    } else {

        //
        // Get Context
        //

        PspGetContext(TrapFrame,NULL,&Ctx->Context);
    }

    KeSetEvent(&Ctx->OperationComplete,0,FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\ia64\psldt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    psldt.c

Abstract:

    This module contains mips stubs for the process and thread ldt support

Author:

    Dave Hastings (daveh) 20 May 1991

Revision History:

--*/

#include "psp.h"


NTSTATUS
PspQueryLdtInformation( 
    IN PEPROCESS Process,
    OUT PVOID LdtInformation,
    IN ULONG LdtInformationLength,
    OUT PULONG ReturnLength
    )
/*++

Routine Description:

    This routine returns STATUS_NOT_IMPLEMENTED

Arguments:

    Process -- Supplies a pointer to the process to return LDT info for
    LdtInformation -- Supplies a pointer to the buffer 
    ReturnLength -- Returns the number of bytes put into the buffer
    
Return Value:

    STATUS_NOT_IMPLEMENTED
--*/
{
    UNREFERENCED_PARAMETER (Process);
    UNREFERENCED_PARAMETER (LdtInformation);
    UNREFERENCED_PARAMETER (LdtInformationLength);
    UNREFERENCED_PARAMETER (ReturnLength);
    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
PspSetLdtSize(
    IN PEPROCESS Process,
    IN PVOID LdtSize,
    IN ULONG LdtSizeLength
    )

/*++

Routine Description:

    This function returns STATUS_NOT_IMPLEMENTED

Arguments:

    Process -- Supplies a pointer to the process whose Ldt is to be sized
    LdtSize -- Supplies a pointer to the size information

    
Return Value:

    STATUS_NOT_IMPLEMENTED
--*/
{
    UNREFERENCED_PARAMETER (Process);
    UNREFERENCED_PARAMETER (LdtSize);
    UNREFERENCED_PARAMETER (LdtSizeLength);
    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
PspSetLdtInformation(
    IN PEPROCESS Process,
    IN PVOID LdtInformation,
    IN ULONG LdtInformationLength
    )

/*++

Routine Description:

    This function returns STATUS_NOT_IMPLEMENTED

Arguments:

    Process -- Supplies a pointer to the process whose Ldt is to be modified
    LdtInformation -- Supplies a pointer to the information about the Ldt
        modifications
    LdtInformationLength -- Supplies the length of the LdtInformation 
        structure.
Return Value:

    
Return Value:

    STATUS_NOT_IMPLEMENTED
--*/
{
    UNREFERENCED_PARAMETER (Process);
    UNREFERENCED_PARAMETER (LdtInformation);
    UNREFERENCED_PARAMETER (LdtInformationLength);
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
PspQueryDescriptorThread (
    PETHREAD Thread,
    PVOID ThreadInformation,
    ULONG ThreadInformationLength,
    PULONG ReturnLength
    )
/*++

Routine Description:

    This function returns STATUS_NOT_IMPLEMENTED

Arguments:

    Thread -- Supplies a pointer to the thread.
    ThreadInformation -- Supplies information on the descriptor.
    ThreadInformationLength -- Supplies the length of the information.
    ReturnLength -- Returns the number of bytes returned.

Return Value:
    
    STATUS_NOT_IMPLEMENTED
--*/
{
    UNREFERENCED_PARAMETER (Thread);
    UNREFERENCED_PARAMETER (ThreadInformation);
    UNREFERENCED_PARAMETER (ThreadInformationLength);
    UNREFERENCED_PARAMETER (ReturnLength);
    return STATUS_NOT_IMPLEMENTED;
}

VOID
PspDeleteLdt(
    IN PEPROCESS Process
    )
/*++

Routine Description:
    
    This is a stub for the Ldt delete routine

Arguments:

    Process -- Supplies a pointer to the process

Return Value:

    None
--*/
{
    UNREFERENCED_PARAMETER (Process);
}

NTSTATUS
NtSetLdtEntries(
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1High
    )
{
    UNREFERENCED_PARAMETER (Selector0);
    UNREFERENCED_PARAMETER (Entry0Low);
    UNREFERENCED_PARAMETER (Entry0Hi);
    UNREFERENCED_PARAMETER (Selector1);
    UNREFERENCED_PARAMETER (Entry1Low);
    UNREFERENCED_PARAMETER (Entry1High);
    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\ia64\psctxi64.c ===
/*++

Copyright (c) 1998  Intel Corporation
Copyright (c) 1990  Microsoft Corporation

Module Name:

    psctxi64.c

Abstract:

    This module implements function to get and set the context of a thread.

Author:

    David N. Cutler (davec) 1-Oct-1990

Revision History:

--*/
#include "psp.h"
#include <ia64.h>

#define ALIGN_NATS(Result, Source, Start, AddressOffset, Mask)    \
    if (AddressOffset == Start) {                                       \
        Result = (ULONGLONG)Source;                                     \
    } else if (AddressOffset < Start) {                                 \
        Result = (ULONGLONG)(Source << (Start - AddressOffset));        \
    } else {                                                            \
        Result = (ULONGLONG)((Source >> (AddressOffset - Start)) |      \
                             (Source << (64 + Start - AddressOffset))); \
    }                                                                   \
    Result = Result & (ULONGLONG)Mask

#define EXTRACT_NATS(Result, Source, Start, AddressOffset, Mask)        \
    Result = (ULONGLONG)(Source & (ULONGLONG)Mask);                     \
    if (AddressOffset < Start) {                                        \
        Result = Result >> (Start - AddressOffset);                     \
    } else if (AddressOffset > Start) {                                 \
        Result = ((Result << (AddressOffset - Start)) |                 \
                  (Result >> (64 + Start - AddressOffset)));            \
    }


VOID
KiGetDebugContext (
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextFrame
    );

VOID
KiSetDebugContext (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextFrame,
    IN KPROCESSOR_MODE ProcessorMode
    );


VOID
PspGetContext (
    IN PKTRAP_FRAME                   TrapFrame,
    IN PKNONVOLATILE_CONTEXT_POINTERS ContextPointers,
    IN OUT PCONTEXT                   ContextEM
    )

/*++

Routine Description:

    This function selectively moves the contents of the specified trap frame
    and nonvolatile context to the specified context record.

Arguments:

    TrapFrame -         Supplies a pointer to a trap frame.

    ContextPointers -   Supplies the address of context pointers record.

    ContextEM -         Supplies the address of a context record.

Return Value:

    None.

    N.B. The side effect of this routine is that the dirty user stacked
         registers that were flushed into the kernel backing store are
         copied backed into the user backing store and the trap frame
         will be modified as a result of that.

--*/

{

    ULONGLONG IntNats1, IntNats2 = 0;
    USHORT R1Offset;

    if (ContextEM->ContextFlags & CONTEXT_EXCEPTION_REQUEST) {

        ContextEM->ContextFlags |= CONTEXT_EXCEPTION_REPORTING;
        ContextEM->ContextFlags &= ~(CONTEXT_EXCEPTION_ACTIVE | CONTEXT_SERVICE_ACTIVE);

        if (TRAP_FRAME_TYPE(TrapFrame) == SYSCALL_FRAME) {

            ContextEM->ContextFlags |= CONTEXT_SERVICE_ACTIVE;

        } else if (TRAP_FRAME_TYPE(TrapFrame) != INTERRUPT_FRAME) {

            ContextEM->ContextFlags |= CONTEXT_EXCEPTION_ACTIVE;
        }
    }

    if ((ContextEM->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        ContextEM->IntGp = TrapFrame->IntGp;
        ContextEM->IntSp = TrapFrame->IntSp;
        ContextEM->ApUNAT = TrapFrame->ApUNAT;
        ContextEM->BrRp = TrapFrame->BrRp;

        ContextEM->StFPSR = TrapFrame->StFPSR;
        ContextEM->StIPSR = TrapFrame->StIPSR;
        ContextEM->StIIP = TrapFrame->StIIP;
        ContextEM->StIFS = TrapFrame->StIFS;

        if (TRAP_FRAME_TYPE(TrapFrame) != SYSCALL_FRAME) {

            ContextEM->ApCCV = TrapFrame->ApCCV;
            ContextEM->SegCSD = TrapFrame->SegCSD;

        }

        //
        // Get RSE control states from the trap frame.
        //

        ContextEM->RsPFS = TrapFrame->RsPFS;
        ContextEM->RsRSC = TrapFrame->RsRSC;
        ContextEM->RsRNAT = TrapFrame->RsRNAT;

        ContextEM->RsBSP = RtlpRseShrinkBySOF (TrapFrame->RsBSP, TrapFrame->StIFS);
        ContextEM->RsBSPSTORE = ContextEM->RsBSP;

        //
        // Get preserved applicaton registers
        //

        ContextEM->ApLC = *ContextPointers->ApLC;
        ContextEM->ApEC = (*ContextPointers->ApEC >> PFS_EC_SHIFT) & PFS_EC_MASK;

        //
        // Get iA status
        //

        ContextEM->StFCR = __getReg(CV_IA64_AR21);
        ContextEM->Eflag = __getReg(CV_IA64_AR24);
        ContextEM->SegSSD = __getReg(CV_IA64_AR26);
        ContextEM->Cflag = __getReg(CV_IA64_AR27);
        ContextEM->StFSR = __getReg(CV_IA64_AR28);
        ContextEM->StFIR = __getReg(CV_IA64_AR29);
        ContextEM->StFDR = __getReg(CV_IA64_AR30);
        ContextEM->ApDCR = __getReg(CV_IA64_ApDCR);

    }

    if ((ContextEM->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        ContextEM->Preds = TrapFrame->Preds;
        ContextEM->IntTeb = TrapFrame->IntTeb;
        ContextEM->IntV0 = TrapFrame->IntV0;

        ASSERT((TrapFrame->EOFMarker & ~0xffI64) == KTRAP_FRAME_EOF);

        if (TRAP_FRAME_TYPE(TrapFrame) != SYSCALL_FRAME) {

            ContextEM->IntT0 = TrapFrame->IntT0;
            ContextEM->IntT1 = TrapFrame->IntT1;
            ContextEM->IntT2 = TrapFrame->IntT2;
            ContextEM->IntT3 = TrapFrame->IntT3;
            ContextEM->IntT4 = TrapFrame->IntT4;

            //
            // t5 - t22
            //

            memcpy(&ContextEM->IntT5, &TrapFrame->IntT5, 18*sizeof(ULONGLONG));


            //
            // Get branch registers
            //

            ContextEM->BrT0 = TrapFrame->BrT0;
            ContextEM->BrT1 = TrapFrame->BrT1;
        }

        ContextEM->BrS0 = *ContextPointers->BrS0;
        ContextEM->BrS1 = *ContextPointers->BrS1;
        ContextEM->BrS2 = *ContextPointers->BrS2;
        ContextEM->BrS3 = *ContextPointers->BrS3;
        ContextEM->BrS4 = *ContextPointers->BrS4;

        //
        // Get integer registers s0 - s3 from exception frame.
        //

        ContextEM->IntS0 = *ContextPointers->IntS0;
        ContextEM->IntS1 = *ContextPointers->IntS1;
        ContextEM->IntS2 = *ContextPointers->IntS2;
        ContextEM->IntS3 = *ContextPointers->IntS3;
        IntNats2 |= (((*ContextPointers->IntS0Nat >> (((ULONG_PTR)ContextPointers->IntS0 & 0x1F8) >> 3)) & 0x1) << 4);
        IntNats2 |= (((*ContextPointers->IntS1Nat >> (((ULONG_PTR)ContextPointers->IntS1 & 0x1F8) >> 3)) & 0x1) << 5);
        IntNats2 |= (((*ContextPointers->IntS2Nat >> (((ULONG_PTR)ContextPointers->IntS2 & 0x1F8) >> 3)) & 0x1) << 6);
        IntNats2 |= (((*ContextPointers->IntS3Nat >> (((ULONG_PTR)ContextPointers->IntS3 & 0x1F8) >> 3)) & 0x1) << 7);

        //
        // Get the integer nats field in the context
        // *ContextPointers->IntNats has Nats for preserved regs
        //

        R1Offset = (USHORT)((ULONG_PTR)(&TrapFrame->IntGp) >> 3) & 0x3f;
        ALIGN_NATS(IntNats1, TrapFrame->IntNats, 1, R1Offset, 0xFFFFFF0E);

        ContextEM->IntNats = IntNats1 | IntNats2;

#ifdef DEBUG
        DbgPrint("PspGetContext INTEGER: R1Offset = 0x%x, TF->IntNats = 0x%I64x, IntNats1 = 0x%I64x\n",
               R1Offset, TrapFrame->IntNats, IntNats1);
#endif

    }

    if ((ContextEM->ContextFlags & CONTEXT_LOWER_FLOATING_POINT) == CONTEXT_LOWER_FLOATING_POINT) {

        ContextEM->StFPSR = TrapFrame->StFPSR;

        //
        // Get floating registers fs0 - fs19
        //

        ContextEM->FltS0 = *ContextPointers->FltS0;
        ContextEM->FltS1 = *ContextPointers->FltS1;
        ContextEM->FltS2 = *ContextPointers->FltS2;
        ContextEM->FltS3 = *ContextPointers->FltS3;

        ContextEM->FltS4 = *ContextPointers->FltS4;
        ContextEM->FltS5 = *ContextPointers->FltS5;
        ContextEM->FltS6 = *ContextPointers->FltS6;
        ContextEM->FltS7 = *ContextPointers->FltS7;

        ContextEM->FltS8 = *ContextPointers->FltS8;
        ContextEM->FltS9 = *ContextPointers->FltS9;
        ContextEM->FltS10 = *ContextPointers->FltS10;
        ContextEM->FltS11 = *ContextPointers->FltS11;

        ContextEM->FltS12 = *ContextPointers->FltS12;
        ContextEM->FltS13 = *ContextPointers->FltS13;
        ContextEM->FltS14 = *ContextPointers->FltS14;
        ContextEM->FltS15 = *ContextPointers->FltS15;

        ContextEM->FltS16 = *ContextPointers->FltS16;
        ContextEM->FltS17 = *ContextPointers->FltS17;
        ContextEM->FltS18 = *ContextPointers->FltS18;
        ContextEM->FltS19 = *ContextPointers->FltS19;

        
        if (TRAP_FRAME_TYPE(TrapFrame) != SYSCALL_FRAME) {

            //
            // Get floating registers ft0 - ft9 from trap frame.
            //

            RtlCopyIa64FloatRegisterContext(&ContextEM->FltT0,
                                            &TrapFrame->FltT0,
                                            sizeof(FLOAT128) * (10));

        }
    }

    if ((ContextEM->ContextFlags & CONTEXT_HIGHER_FLOATING_POINT) == CONTEXT_HIGHER_FLOATING_POINT) {

        ContextEM->StFPSR = TrapFrame->StFPSR;

        //
        // Get floating regs f32 - f127 from higher floating point save area
        //

        if (TrapFrame->PreviousMode == UserMode) {
            RtlCopyIa64FloatRegisterContext(
                &ContextEM->FltF32,
                (PFLOAT128)GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(KeGetCurrentThread()->StackBase),
                96*sizeof(FLOAT128)
                );
        }
    }

    //
    // Get h/w debug register context
    //

    if ((ContextEM->ContextFlags & CONTEXT_DEBUG) == CONTEXT_DEBUG) {
        KiGetDebugContext(TrapFrame, ContextEM);
    }

    return;
}

VOID
PspSetContext (
    IN OUT PKTRAP_FRAME               TrapFrame,
    IN PKNONVOLATILE_CONTEXT_POINTERS ContextPointers,
    IN PCONTEXT                       ContextEM,
    IN KPROCESSOR_MODE                ProcessorMode
    )

/*++

Routine Description:

    This function selectively moves the contents of the specified context
    record to the specified trap frame and nonvolatile context.

    We're expecting a plabel to have been passed in the IIP (we won't have a valid
    Global pointer) and if we have a plabel we fill in the correct Global pointer and
    IIP. Technically, the GP is part of the CONTEXT_CONTROL with the EM architecture
    so we only need to check to see if CONTEXT_CONTROL has been specified.

Arguments:

    TrapFrame -           Supplies the address of the trap frame.

    ContextPointers -   Supplies the address of context pointers record.

    ContextEM -         Supplies the address of a context record.

    ProcessorMode -     Supplies the processor mode to use when sanitizing
                        the PSR and FSR.

Return Value:

    None.

--*/

{
    USHORT R1Offset;
    ULONGLONG NewBsp;

    //
    // Indicate the trap frame has been modified by a set context.
    // This is used by the emulation code to detect that the trap frame
    // has been changed after trap has occured.
    //

    TrapFrame->EOFMarker |= MODIFIED_FRAME;

    if ((ContextEM->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        TrapFrame->IntGp = ContextEM->IntGp;
        TrapFrame->IntSp = ContextEM->IntSp;
        TrapFrame->ApUNAT = ContextEM->ApUNAT;
        TrapFrame->BrRp = ContextEM->BrRp;
        TrapFrame->ApCCV = ContextEM->ApCCV;
        TrapFrame->SegCSD = ContextEM->SegCSD;

        //
        // Set preserved applicaton registers.
        //

        *ContextPointers->ApLC = ContextEM->ApLC;
        *ContextPointers->ApEC &= ~((ULONGLONG)PFS_EC_MASK << PFS_EC_SHIFT);
        *ContextPointers->ApEC |= ((ContextEM->ApEC & PFS_EC_MASK) << PFS_EC_SHIFT);

        TrapFrame->StFPSR = SANITIZE_FSR(ContextEM->StFPSR, ProcessorMode);
        TrapFrame->StIIP = ContextEM->StIIP;
        TrapFrame->StIFS = SANITIZE_IFS(ContextEM->StIFS, ProcessorMode);
        TrapFrame->StIPSR = SANITIZE_PSR(ContextEM->StIPSR, ProcessorMode);
        TrapFrame->RsPFS = SANITIZE_PFS(ContextEM->RsPFS, ProcessorMode);

        //
        // If the BSP value is not being changed then preserve the 
        // preload count.  This is only necessary if KeFlushUserRseState
        // failed for some reason.
        //

        NewBsp = RtlpRseGrowBySOF (ContextEM->RsBSP, ContextEM->StIFS);

        if (TrapFrame->RsBSP == NewBsp) {
            
            RSC  Rsc;

            Rsc.ull = ZERO_PRELOAD_SIZE(SANITIZE_RSC(ContextEM->RsRSC, ProcessorMode));
            Rsc.sb.rsc_preload = ((struct _RSC *) &(TrapFrame->RsRSC))->rsc_preload;
            TrapFrame->RsRSC = Rsc.ull;

        } else {
            TrapFrame->RsRSC = ZERO_PRELOAD_SIZE(SANITIZE_RSC(ContextEM->RsRSC, ProcessorMode));
            TrapFrame->RsBSP = NewBsp;
        }

        TrapFrame->RsBSPSTORE = TrapFrame->RsBSP;
        TrapFrame->RsRNAT = ContextEM->RsRNAT;

#ifdef DEBUG
        DbgPrint ("PspSetContext CONTROL: TrapFrame->RsRNAT = 0x%I64x\n",
                TrapFrame->RsRNAT);
#endif

        //
        // Set and sanitize iA status
        //

        __setReg(CV_IA64_AR21, SANITIZE_AR21_FCR (ContextEM->StFCR, ProcessorMode));
        __setReg(CV_IA64_AR24, SANITIZE_AR24_EFLAGS (ContextEM->Eflag, ProcessorMode));
        __setReg(CV_IA64_AR26, ContextEM->SegSSD);
        __setReg(CV_IA64_AR27, SANITIZE_AR27_CFLG (ContextEM->Cflag, ProcessorMode));

        __setReg(CV_IA64_AR28, SANITIZE_AR28_FSR (ContextEM->StFSR, ProcessorMode));
        __setReg(CV_IA64_AR29, SANITIZE_AR29_FIR (ContextEM->StFIR, ProcessorMode));
        __setReg(CV_IA64_AR30, SANITIZE_AR30_FDR (ContextEM->StFDR, ProcessorMode));

    }

    if ((ContextEM->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        TrapFrame->IntT0 = ContextEM->IntT0;
        TrapFrame->IntT1 = ContextEM->IntT1;
        TrapFrame->IntT2 = ContextEM->IntT2;
        TrapFrame->IntT3 = ContextEM->IntT3;
        TrapFrame->IntT4 = ContextEM->IntT4;
        TrapFrame->IntV0 = ContextEM->IntV0;
        TrapFrame->IntTeb = ContextEM->IntTeb;
        TrapFrame->Preds = ContextEM->Preds;

        //
        //  t5 - t2
        //

        RtlCopyMemory(&TrapFrame->IntT5, &ContextEM->IntT5, 18*sizeof(ULONGLONG));

        //
        // Set the integer nats fields
        //

        R1Offset = (USHORT)((ULONG_PTR)(&TrapFrame->IntGp) >> 3) & 0x3f;

        EXTRACT_NATS(TrapFrame->IntNats, ContextEM->IntNats,
                     1, R1Offset, 0xFFFFFF0E);

        //
        // Set the preserved integer NAT fields
        //

        *ContextPointers->IntS0 = ContextEM->IntS0;
        *ContextPointers->IntS1 = ContextEM->IntS1;
        *ContextPointers->IntS2 = ContextEM->IntS2;
        *ContextPointers->IntS3 = ContextEM->IntS3;

        *ContextPointers->IntS0Nat &= ~(0x1 << (((ULONG_PTR)ContextPointers->IntS0 & 0x1F8) >> 3));
        *ContextPointers->IntS1Nat &= ~(0x1 << (((ULONG_PTR)ContextPointers->IntS1 & 0x1F8) >> 3));
        *ContextPointers->IntS2Nat &= ~(0x1 << (((ULONG_PTR)ContextPointers->IntS2 & 0x1F8) >> 3));
        *ContextPointers->IntS3Nat &= ~(0x1 << (((ULONG_PTR)ContextPointers->IntS3 & 0x1F8) >> 3));

        *ContextPointers->IntS0Nat |= (((ContextEM->IntNats >> 4) & 0x1) << (((ULONG_PTR)ContextPointers->IntS0 & 0x1F8) >> 3));
        *ContextPointers->IntS1Nat |= (((ContextEM->IntNats >> 4) & 0x1) << (((ULONG_PTR)ContextPointers->IntS1 & 0x1F8) >> 3));
        *ContextPointers->IntS2Nat |= (((ContextEM->IntNats >> 4) & 0x1) << (((ULONG_PTR)ContextPointers->IntS2 & 0x1F8) >> 3));
        *ContextPointers->IntS3Nat |= (((ContextEM->IntNats >> 4) & 0x1) << (((ULONG_PTR)ContextPointers->IntS3 & 0x1F8) >> 3));

#ifdef DEBUG
        DbgPrint("PspSetContext INTEGER: R1Offset = 0x%x, TF->IntNats = 0x%I64x, Context->IntNats = 0x%I64x\n",
               R1Offset, TrapFrame->IntNats, ContextEM->IntNats);
#endif

        *ContextPointers->BrS0 = ContextEM->BrS0;
        *ContextPointers->BrS1 = ContextEM->BrS1;
        *ContextPointers->BrS2 = ContextEM->BrS2;
        *ContextPointers->BrS3 = ContextEM->BrS3;
        *ContextPointers->BrS4 = ContextEM->BrS4;
        TrapFrame->BrT0 = ContextEM->BrT0;
        TrapFrame->BrT1 = ContextEM->BrT1;
    }

    if ((ContextEM->ContextFlags & CONTEXT_LOWER_FLOATING_POINT) == CONTEXT_LOWER_FLOATING_POINT) {

        TrapFrame->StFPSR = SANITIZE_FSR(ContextEM->StFPSR, ProcessorMode);

        //
        // Set floating registers fs0 - fs19.
        //

        *ContextPointers->FltS0 = ContextEM->FltS0;
        *ContextPointers->FltS1 = ContextEM->FltS1;
        *ContextPointers->FltS2 = ContextEM->FltS2;
        *ContextPointers->FltS3 = ContextEM->FltS3;

        *ContextPointers->FltS4 = ContextEM->FltS4;
        *ContextPointers->FltS5 = ContextEM->FltS5;
        *ContextPointers->FltS6 = ContextEM->FltS6;
        *ContextPointers->FltS7 = ContextEM->FltS7;

        *ContextPointers->FltS8 = ContextEM->FltS8;
        *ContextPointers->FltS9 = ContextEM->FltS9;
        *ContextPointers->FltS10 = ContextEM->FltS10;
        *ContextPointers->FltS11 = ContextEM->FltS11;

        *ContextPointers->FltS12 = ContextEM->FltS12;
        *ContextPointers->FltS13 = ContextEM->FltS13;
        *ContextPointers->FltS14 = ContextEM->FltS14;
        *ContextPointers->FltS15 = ContextEM->FltS15;

        *ContextPointers->FltS16 = ContextEM->FltS16;
        *ContextPointers->FltS17 = ContextEM->FltS17;
        *ContextPointers->FltS18 = ContextEM->FltS18;
        *ContextPointers->FltS19 = ContextEM->FltS19;

        //
        // Set floating registers ft0 - ft9.
        //

        RtlCopyIa64FloatRegisterContext(&TrapFrame->FltT0,
                                        &ContextEM->FltT0,
                                        sizeof(FLOAT128) * (10));
    }

    if ((ContextEM->ContextFlags & CONTEXT_HIGHER_FLOATING_POINT) == CONTEXT_HIGHER_FLOATING_POINT) {


        TrapFrame->StFPSR = SANITIZE_FSR(ContextEM->StFPSR, ProcessorMode);

        if (ProcessorMode == UserMode) {

            //
            // Update the higher floating point save area (f32-f127) and
            // set the corresponding modified bit in the PSR to 1.
            //

            RtlCopyIa64FloatRegisterContext(
                (PFLOAT128)GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(KeGetCurrentThread()->StackBase),
                &ContextEM->FltF32,
                96*sizeof(FLOAT128));

            //
            // set the dfh bit to force a reload of the high fp register
            // set on the next user access, and clear mfh to make sure
            // the changes are not over written.
            //

            TrapFrame->StIPSR |= (1i64 << PSR_DFH);
            TrapFrame->StIPSR &= ~(1i64 << PSR_MFH);
        }

    }

    //
    // Set debug register contents if specified.
    //

    if ((ContextEM->ContextFlags & CONTEXT_DEBUG) == CONTEXT_DEBUG) {
        KiSetDebugContext (TrapFrame, ContextEM, ProcessorMode);
    }

    return;
}

VOID
PspGetSetContextSpecialApcMain (
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function either captures the user mode state of the current
    thread, or sets the user mode state of the current thread. The
    operation type is determined by the value of SystemArgument1. A
    zero value is used for get context, and a nonzero value is used
    for set context.

Arguments:

    Apc - Supplies a pointer to the APC control object that caused entry
          into this routine.

    NormalRoutine - Supplies a pointer to the normal routine function that
        was specified when the APC was initialized. This parameter is not
        used.

    NormalContext - Supplies a pointer to an arbitrary data structure that
        was specified when the APC was initialized. This parameter is not
        used.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to two
        arguments that contain untyped data.
        The first arguement is used to distinguish between get and set requests.
            A value of zero  signifies that GetThreadContext was requested.
            A non-zero value signifies that SetThreadContext was requested.
        The Second arguement has the thread handle. The second arguement is
        not used.

Return Value:

    None.

--*/

{
    PGETSETCONTEXT                ContextInfo;
    KNONVOLATILE_CONTEXT_POINTERS ContextPointers;  // Not currently used, needed later.
    CONTEXT                       ContextRecord;
    ULONGLONG                     ControlPc;
    FRAME_POINTERS                EstablisherFrame;
    PRUNTIME_FUNCTION             FunctionEntry;
    BOOLEAN                       InFunction;
    PKTRAP_FRAME                  TrFrame1;
    ULONGLONG                     ImageBase;
    ULONGLONG                     TargetGp;
    PETHREAD                      Thread;

    UNREFERENCED_PARAMETER (NormalRoutine);
    UNREFERENCED_PARAMETER (NormalContext);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // Get the address of the context frame and compute the address of the
    // system entry trap frame.
    //

    ContextInfo = CONTAINING_RECORD (Apc, GETSETCONTEXT, Apc);

    Thread = Apc->SystemArgument2;

    TrFrame1 = NULL;

    if (ContextInfo->Mode == KernelMode) {
        TrFrame1 = Thread->Tcb.TrapFrame;
    }

    if (TrFrame1 == NULL) {
        TrFrame1 = PspGetBaseTrapFrame (Thread);
    }


    //
    // Capture the current thread context and set the initial control PC
    // value.
    //

    RtlCaptureContext(&ContextRecord);
    ControlPc = ContextRecord.BrRp;

    //
    // Initialize context pointers for the nonvolatile integer and floating
    // registers.
    //

    ContextPointers.FltS0 = &ContextRecord.FltS0;
    ContextPointers.FltS1 = &ContextRecord.FltS1;
    ContextPointers.FltS2 = &ContextRecord.FltS2;
    ContextPointers.FltS3 = &ContextRecord.FltS3;
    ContextPointers.FltS4 = &ContextRecord.FltS4;
    ContextPointers.FltS5 = &ContextRecord.FltS5;
    ContextPointers.FltS6 = &ContextRecord.FltS6;
    ContextPointers.FltS7 = &ContextRecord.FltS7;
    ContextPointers.FltS8 = &ContextRecord.FltS8;
    ContextPointers.FltS9 = &ContextRecord.FltS9;
    ContextPointers.FltS10 = &ContextRecord.FltS10;
    ContextPointers.FltS11 = &ContextRecord.FltS11;
    ContextPointers.FltS12 = &ContextRecord.FltS12;
    ContextPointers.FltS13 = &ContextRecord.FltS13;
    ContextPointers.FltS14 = &ContextRecord.FltS14;
    ContextPointers.FltS15 = &ContextRecord.FltS15;
    ContextPointers.FltS16 = &ContextRecord.FltS16;
    ContextPointers.FltS17 = &ContextRecord.FltS17;
    ContextPointers.FltS18 = &ContextRecord.FltS18;
    ContextPointers.FltS19 = &ContextRecord.FltS19;

    ContextPointers.IntS0 = &ContextRecord.IntS0;
    ContextPointers.IntS1 = &ContextRecord.IntS1;
    ContextPointers.IntS2 = &ContextRecord.IntS2;
    ContextPointers.IntS3 = &ContextRecord.IntS3;
    ContextPointers.IntSp = &ContextRecord.IntSp;

    ContextPointers.BrS0 = &ContextRecord.BrS0;
    ContextPointers.BrS1 = &ContextRecord.BrS1;
    ContextPointers.BrS2 = &ContextRecord.BrS2;
    ContextPointers.BrS3 = &ContextRecord.BrS3;
    ContextPointers.BrS4 = &ContextRecord.BrS4;

    ContextPointers.ApLC = &ContextRecord.ApLC;
    ContextPointers.ApEC = &ContextRecord.ApEC;

    //
    // Start with the frame specified by the context record and virtually
    // unwind call frames until the system entry trap frame is encountered.
    //

    do {

        //
        // Lookup the function table entry using the point at which control
        // left the procedure.
        //

        FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, &TargetGp);

        //
        // If there is a function table entry for the routine, then virtually
        // unwind to the caller of the current routine to obtain the address
        // where control left the caller.
        //

        if (FunctionEntry != NULL) {
            ControlPc = RtlVirtualUnwind(ImageBase,
                                         ControlPc,
                                         FunctionEntry,
                                         &ContextRecord,
                                         &InFunction,
                                         &EstablisherFrame,
                                         &ContextPointers);

        } else {

            ControlPc = ContextRecord.BrRp;
            ContextRecord.StIFS = ContextRecord.RsPFS;
            ContextRecord.RsBSP = RtlpRseShrinkBySOL (ContextRecord.RsBSP, ContextRecord.StIFS);
        }

    } while ((PVOID)ContextRecord.IntSp != TrFrame1);

    //
    // Process GetThreadContext or SetThreadContext as specified.
    //

    if (*SystemArgument1 != 0) {

        //
        // Set Context from proper Context mode
        //

        PspSetContext(TrFrame1, &ContextPointers, &ContextInfo->Context,
                      ContextInfo->Mode);

    } else {

        //
        // Get Context from proper Context mode
        //

        KeFlushUserRseState(TrFrame1);
        PspGetContext(TrFrame1, &ContextPointers, &ContextInfo->Context);

    }

    KeSetEvent(&ContextInfo->OperationComplete, 0, FALSE);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\i386\psvdm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    psldt.c

Abstract:

    This module contains code for the io port handler support

Author:

    Dave Hastings (daveh) 26 Jan 1991

Revision History:

--*/

#include "psp.h"


#if DBG
#define ASSERTEQUAL(value1, value2, string)     \
        if ((ULONG)value1 != (ULONG)value2) {   \
            DbgPrint string ;                   \
        }

#define ASSERTEQUALBREAK(value1, value2, string)\
        if ((ULONG)value1 != (ULONG)value2) {   \
            DbgPrint string ;                   \
            DbgBreakPoint();                    \
        }
#else

#define ASSERTEQUAL(value1, value2, string)
#define ASSERTEQUALBREAK(value1, value2, string)

#endif


//
// Internal functions
//

NTSTATUS
Psp386InstallIoHandler(
    IN PEPROCESS Process,
    IN PEMULATOR_ACCESS_ENTRY EmulatorAccessEntry,
    IN ULONG PortNumber,
    IN ULONG Context
    );

NTSTATUS
Psp386RemoveIoHandler(
    IN PEPROCESS Process,
    IN PEMULATOR_ACCESS_ENTRY EmulatorAccessEntry,
    IN ULONG PortNumber
    );

NTSTATUS
Psp386InsertVdmIoHandlerBlock(
    IN PEPROCESS Process,
    IN PVDM_IO_HANDLER VdmIoHandler
    );

PVDM_IO_HANDLER
Psp386GetVdmIoHandler(
    IN PEPROCESS Process,
    IN ULONG PortNumber
    );

NTSTATUS
Psp386CreateVdmIoListHead(
    IN PEPROCESS Process
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,PspVdmInitialize)
#pragma alloc_text(PAGE,PspSetProcessIoHandlers)
#pragma alloc_text(PAGE,Ps386GetVdmIoHandler)
#pragma alloc_text(PAGE,Psp386RemoveIoHandler)
#pragma alloc_text(PAGE,Psp386InstallIoHandler)
#pragma alloc_text(PAGE,Psp386CreateVdmIoListHead)
#pragma alloc_text(PAGE,Psp386InsertVdmIoHandlerBlock)
#pragma alloc_text(PAGE,Psp386GetVdmIoHandler)
#pragma alloc_text(PAGE,PspDeleteVdmObjects)
#endif


//
//  Resource to synchronize access to IoHandler list
//
ERESOURCE VdmIoListCreationResource;




NTSTATUS
PspSetProcessIoHandlers(
    IN PEPROCESS Process,
    IN PVOID IoHandlerInformation,
    IN ULONG IoHandlerLength
    )
/*++

Routine Description:

    This routine installs a device driver IO handling routine for the
    specified process.  If an io operation is detected in a vdm on a port
    that has a device driver IO handling routine, that routine will be called.

Arguments:

    Process -- Supplies a pointer to the process for which Io port handlers
        are to be installed
    IoHandlerInformation -- Supplies a pointer to the information about the
        io port handlers
    IoHandlerLength -- Supplies the length of the IoHandlerInformation
        structure.

Return Value:



--*/
{
    PPROCESS_IO_PORT_HANDLER_INFORMATION IoHandlerInfo;
    NTSTATUS Status;
    PEMULATOR_ACCESS_ENTRY EmulatorAccess;
    ULONG EmulatorEntryNumber, NumberPorts;
    ULONG PortSize;
    PAGED_CODE();

    //
    // Insure that this call was made from KernelMode
    //
    if (KeGetPreviousMode () != KernelMode) {
        return STATUS_INVALID_PARAMETER;    // this info type invalid in usermode
    }
    //
    // Insure that the data passed is long enough
    //
    if (IoHandlerLength < (ULONG)sizeof (PROCESS_IO_PORT_HANDLER_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }
    IoHandlerInfo = IoHandlerInformation;

    //
    // For each of the entries in the array that describes the handlers,
    // determine what size of port the specified handler is being installed
    // for, and then iterate over each individual port.
    //
    for (EmulatorEntryNumber = 0, EmulatorAccess =
            IoHandlerInfo->EmulatorAccessEntries;
        EmulatorEntryNumber < IoHandlerInfo->NumEntries;
        EmulatorEntryNumber++, EmulatorAccess++) {

            switch (EmulatorAccess->AccessType) {
            case Uchar:
                PortSize = 1;
                break;
            case Ushort:
                PortSize = 2;
                break;
            case Ulong:
            default:
                PortSize = 4;
            }

            for (NumberPorts = 0;
                NumberPorts < EmulatorAccess->NumConsecutivePorts;
                NumberPorts++) {
                    if (IoHandlerInfo->Install) {
                        Status = Psp386InstallIoHandler(
                            Process,
                            EmulatorAccess,
                            EmulatorAccess->BasePort + NumberPorts * PortSize,
                            IoHandlerInfo->Context
                            );
                        if (NT_SUCCESS(Status)) {
                        }
                    } else {
                        Status = Psp386RemoveIoHandler(
                            Process,
                            EmulatorAccess,
                            EmulatorAccess->BasePort + NumberPorts * PortSize
                            );
                    }
                    if (!NT_SUCCESS(Status)) {
                        goto exitloop;
                    }
            }
    }
    Status = STATUS_SUCCESS;
exitloop:
    return Status;

}


VOID
PspDeleteVdmObjects(
    IN PEPROCESS Process
    )
/*++

Routine Description:

    Frees the VdmObjects structure and the Frees the IoHandler list

Arguments:

    Process -- Supplies a pointer to the process

Return Value:

    None
--*/
{
    SIZE_T PoolQuota;
    PVDM_PROCESS_OBJECTS pVdmObjects;
    PVDM_IO_HANDLER p1, p2;
    PVDM_IO_LISTHEAD p3;
    PLIST_ENTRY  Next;
    PDELAYINTIRQ pDelayIntIrq;

    pVdmObjects = Process->VdmObjects;

    if (pVdmObjects == NULL)  {
        return;
    }

    //
    // First Free any port handler entries for this process,
    //
    p1 = NULL;
    p3 = pVdmObjects->VdmIoListHead;

    if (p3) {
        p2 = p3->VdmIoHandlerList;

        while (p2) {
            p1 = p2;
            p2 = p1->Next;
            ExFreePool( p1 );
        }

        ExDeleteResourceLite(&p3->VdmIoResource);

        ExFreePool( p3 );
        pVdmObjects->VdmIoListHead = NULL;
    }

    if (pVdmObjects->pIcaUserData) {
        PsReturnProcessPagedPoolQuota (Process,
                                       sizeof(VDMICAUSERDATA));

        ExFreePool(pVdmObjects->pIcaUserData);
    }

    //
    // Free up the DelayedIntList, spinlock protection is not needed because
    // object referencing on the process is being used instead.  Meaning there
    // can be no outstanding timers because the process object reference
    // count would have to be nonzero.
    //

    PoolQuota = 0;

    Next = pVdmObjects->DelayIntListHead.Flink;

    while (Next != &pVdmObjects->DelayIntListHead) {
        pDelayIntIrq = CONTAINING_RECORD(Next, DELAYINTIRQ, DelayIntListEntry);
        Next = Next->Flink;
        RemoveEntryList (&pDelayIntIrq->DelayIntListEntry);
        ExFreePool (pDelayIntIrq);
        PoolQuota += sizeof(DELAYINTIRQ);
    }

    if (PoolQuota != 0) {
        PsReturnProcessNonPagedPoolQuota(Process, PoolQuota);
    }

    PsReturnProcessNonPagedPoolQuota (Process, sizeof(VDM_PROCESS_OBJECTS));

    ExFreePool (pVdmObjects);

    Process->VdmObjects = NULL;
}



NTSTATUS
Psp386RemoveIoHandler(
    IN PEPROCESS Process,
    IN PEMULATOR_ACCESS_ENTRY EmulatorAccessEntry,
    IN ULONG PortNumber
    )
/*++

Routine Description:

    This routine remove a handler for a port.  On debug version, it will
    print a message if there is no handler.

Arguments:

    Process -- Supplies a pointer to the process
    EmulatorAccess -- Supplies a pointer to the information about the
        io port handler
    PortNumber -- Supplies the port number to remove the handler from.

Return Value:

--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    PVDM_IO_HANDLER VdmIoHandler;
    KIRQL OldIrql;
    PAGED_CODE();

    //
    // Ensure we have a vdm process which is initialized
    // correctly for VdmIoHandlers
    //
    if (!pVdmObjects) {
#if DBG
        DbgPrint("Psp386RemoveIoHandler: uninitialized VdmObjects\n");
#endif
        return STATUS_UNSUCCESSFUL;
    }


    //
    // If the list does not have a head, then there are no handlers to
    // remove.
    //
    if (!pVdmObjects->VdmIoListHead) {
#if DBG
        DbgPrint("Psp386RemoveIoHandler : attempt to remove non-existent hdlr\n");
#endif
        return STATUS_SUCCESS;
    }

    //
    // Lock the list, so we can insure a correct update.
    //
    KeRaiseIrql(APC_LEVEL, &OldIrql);
    ExAcquireResourceExclusiveLite(&pVdmObjects->VdmIoListHead->VdmIoResource,TRUE);

    VdmIoHandler = Psp386GetVdmIoHandler(
        Process,
        PortNumber & ~0x3
        );

    if (!VdmIoHandler) {
#if DBG
        DbgPrint("Psp386RemoveIoHandler : attempt to remove non-existent hdlr\n");
#endif
        ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
        KeLowerIrql(OldIrql);
        return STATUS_SUCCESS;
    }

    ASSERTEQUALBREAK(
        VdmIoHandler->PortNumber,
        (PortNumber & ~0x3),
        ("Psp386RemoveIoHandler : Bad pointer returned from GetVdmIoHandler\n")
        );

    if (EmulatorAccessEntry->AccessMode & EMULATOR_READ_ACCESS) {
        switch (EmulatorAccessEntry->AccessType) {
        case Uchar:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UcharStringIo[PortNumber % 4],
                    ("Psp386RemoveIoHandler : UcharString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UcharStringIo[PortNumber % 4] = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UcharIo[PortNumber % 4],
                    ("Psp386RemoveIoHandler : Uchar fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UcharIo[PortNumber % 4] = NULL;
            }
            break;
        case Ushort:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UshortStringIo[(PortNumber & 2) >> 1],
                    ("Psp386RemoveIoHandler : UshortString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UshortStringIo[(PortNumber & 2) >> 1] = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UshortIo[(PortNumber & 2) >> 1],
                    ("Psp386RemoveIoHandler : Ushort fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UshortIo[(PortNumber & 2) >> 1] = NULL;
            }
            break;
        case Ulong:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UlongStringIo,
                    ("Psp386RemoveIoHandler : UlongString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UlongStringIo = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[0].UlongIo,
                    ("Psp386RemoveIoHandler : Ulong fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UlongIo = NULL;
            }
            break;
        }
    }

    if (EmulatorAccessEntry->AccessMode & EMULATOR_WRITE_ACCESS) {
        switch (EmulatorAccessEntry->AccessType) {
        case Uchar:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UcharStringIo[PortNumber % 4],
                    ("Psp386RemoveIoHandler : UcharString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UcharStringIo[PortNumber % 4] = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UcharIo[PortNumber % 4],
                    ("Psp386RemoveIoHandler : Uchar fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UcharIo[PortNumber % 4] = NULL;
            }
            break;
        case Ushort:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UshortStringIo[(PortNumber & 2) >> 1],
                    ("Psp386RemoveIoHandler : UshortString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UshortStringIo[(PortNumber & 2) >> 1] = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UshortIo[(PortNumber & 2) >> 1],
                    ("Psp386RemoveIoHandler : Ushort fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UshortIo[(PortNumber & 2) >> 1] = NULL;
            }
            break;
        case Ulong:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UlongStringIo,
                    ("Psp386RemoveIoHandler : UlongString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UlongStringIo = NULL;
            } else {
                ASSERTEQUAL(
                    EmulatorAccessEntry->Routine,
                    VdmIoHandler->IoFunctions[1].UlongIo,
                    ("Psp386RemoveIoHandler : Ulong fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UlongIo = NULL;
            }
            break;
        }
    }

    ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
    KeLowerIrql(OldIrql);

    return STATUS_SUCCESS;

}

NTSTATUS
Psp386InstallIoHandler(
    IN PEPROCESS Process,
    IN PEMULATOR_ACCESS_ENTRY EmulatorAccessEntry,
    IN ULONG PortNumber,
    IN ULONG Context
    )
/*++

Routine Description:

    This routine install a handler for a port.  On debug version, it will
    print a message if there is already a handler.

Arguments:

    Process -- Supplies a pointer to the process
    EmulatorAccess -- Supplies a pointer to the information about the
        io port handler
    PortNumber -- Supplies the port number to install the handler for.

Return Value:

--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    PVDM_IO_HANDLER VdmIoHandler;
    NTSTATUS Status;
    KIRQL    OldIrql;
    PAGED_CODE();


    //
    // Ensure we have a vdm process which is initialized
    // correctly for VdmIoHandlers
    //
    if (!pVdmObjects) {
#if DBG
        DbgPrint("Psp386InstallIoHandler: uninitialized VdmObjects\n");
#endif
        return STATUS_UNSUCCESSFUL;
    }


    Status = STATUS_SUCCESS;

    //
    // If this is the first handler to be installed, create the list head,
    // and initialize the resource lock.
    //
    if (!pVdmObjects->VdmIoListHead) {
        Status = Psp386CreateVdmIoListHead(
            Process
            );

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Lock the list to insure correct update.
    //
    KeRaiseIrql(APC_LEVEL, &OldIrql);
    ExAcquireResourceExclusiveLite(&pVdmObjects->VdmIoListHead->VdmIoResource,TRUE);

    //
    // Update Context
    //

    pVdmObjects->VdmIoListHead->Context = Context;

    VdmIoHandler = Psp386GetVdmIoHandler(
        Process,
        PortNumber & ~0x3
        );

    // If there isn't already a node for this block of ports,
    // attempt to allocate a new one.
    //
    if (!VdmIoHandler) {
        try {

            VdmIoHandler = ExAllocatePoolWithQuotaTag (PagedPool,
                                                       sizeof(VDM_IO_HANDLER),
                                                       'HVsP');

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            if (VdmIoHandler) {
                ExFreePool(VdmIoHandler);
            }
        }

        if (!NT_SUCCESS(Status)) {
            ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
            KeLowerIrql(OldIrql);
            return Status;
        }

        RtlZeroMemory(VdmIoHandler, sizeof(VDM_IO_HANDLER));
        VdmIoHandler->PortNumber = PortNumber & ~0x3;

        Status = Psp386InsertVdmIoHandlerBlock(
            Process,
            VdmIoHandler
            );

        if (!NT_SUCCESS(Status)) {
            ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
            KeLowerIrql(OldIrql);
            return Status;
        }
    }

    ASSERTEQUALBREAK(
        VdmIoHandler->PortNumber,
        (PortNumber & ~0x3),
        ("Psp386InstallIoHandler : Bad pointer returned from GetVdmIoHandler\n")
        );

    if (EmulatorAccessEntry->AccessMode & EMULATOR_READ_ACCESS) {
        switch (EmulatorAccessEntry->AccessType) {
        case Uchar:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UcharStringIo[PortNumber % 4],
                    ("Psp386InstallIoHandler : UcharString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UcharStringIo[PortNumber % 4] =
                    (PDRIVER_IO_PORT_UCHAR_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UcharIo[PortNumber % 4],
                    ("Psp386InstallIoHandler : Uchar fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UcharIo[PortNumber % 4] =
                    (PDRIVER_IO_PORT_UCHAR)EmulatorAccessEntry->Routine;
            }
            break;
        case Ushort:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UshortStringIo[(PortNumber & 2) >> 1],
                    ("Psp386InstallIoHandler : UshortString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UshortStringIo[(PortNumber & 2) >> 1] =
                    (PDRIVER_IO_PORT_USHORT_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UshortIo[(PortNumber & 2) >> 1],
                    ("Psp386InstallIoHandler : Ushort fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UshortIo[(PortNumber & 2) >> 1] =
                    (PDRIVER_IO_PORT_USHORT)EmulatorAccessEntry->Routine;
            }
            break;
        case Ulong:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UlongStringIo,
                    ("Psp386InstallIoHandler : UlongString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UlongStringIo =
                    (PDRIVER_IO_PORT_ULONG_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[0].UlongIo,
                    ("Psp386InstallIoHandler : Ulong fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[0].UlongIo =
                    (PDRIVER_IO_PORT_ULONG)EmulatorAccessEntry->Routine;
            }
            break;
        }
    }

    if (EmulatorAccessEntry->AccessMode & EMULATOR_WRITE_ACCESS) {
        switch (EmulatorAccessEntry->AccessType) {
        case Uchar:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UcharStringIo[PortNumber % 4],
                    ("Psp386InstallIoHandler : UcharString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UcharStringIo[PortNumber % 4] =
                    (PDRIVER_IO_PORT_UCHAR_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UcharIo[PortNumber % 4],
                    ("Psp386InstallIoHandler : Uchar fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UcharIo[PortNumber % 4] =
                    (PDRIVER_IO_PORT_UCHAR)EmulatorAccessEntry->Routine;
            }
            break;
        case Ushort:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UshortStringIo[(PortNumber & 2) >> 1],
                    ("Psp386InstallIoHandler : UshortString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UshortStringIo[(PortNumber & 2) >> 1] =
                    (PDRIVER_IO_PORT_USHORT_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UshortIo[(PortNumber & 2) >> 1],
                    ("Psp386InstallIoHandler : Ushort fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UshortIo[(PortNumber & 2) >> 1] =
                    (PDRIVER_IO_PORT_USHORT)EmulatorAccessEntry->Routine;
            }
            break;
        case Ulong:
            if (EmulatorAccessEntry->StringSupport) {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UlongStringIo,
                    ("Psp386InstallIoHandler : UlongString fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UlongStringIo =
                    (PDRIVER_IO_PORT_ULONG_STRING)EmulatorAccessEntry->Routine;
            } else {
                ASSERTEQUALBREAK(
                    NULL,
                    VdmIoHandler->IoFunctions[1].UlongIo,
                    ("Psp386InstallIoHandler : Ulong fns don't match\n")
                    );
                VdmIoHandler->IoFunctions[1].UlongIo =
                    (PDRIVER_IO_PORT_ULONG)EmulatorAccessEntry->Routine;
            }
        }
    }

    ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
    KeLowerIrql(OldIrql);
    return STATUS_SUCCESS;

}



NTSTATUS
Psp386CreateVdmIoListHead(
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This routine creates the head node of the Io handler list.  This node
    contains the spin lock that protects the list.  This routine also
    initializes the spin lock.

Arguments:

    Process -- Supplies a pointer to the process

Return Value:

Notes:

--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    NTSTATUS Status;
    PVDM_IO_LISTHEAD HandlerListHead=NULL;
    KIRQL    OldIrql;
    PAGED_CODE();

    Status = STATUS_SUCCESS;

    // if there isn't yet a head, grab the resource lock and create one
    if (pVdmObjects->VdmIoListHead == NULL) {
        KeRaiseIrql(APC_LEVEL, &OldIrql);
        ExAcquireResourceExclusiveLite(&VdmIoListCreationResource, TRUE);

        // if no head was created while we grabbed the spin lock
        if (pVdmObjects->VdmIoListHead == NULL) {

            try {
                // allocate space for the list head
                // and charge the quota for it

                HandlerListHead = ExAllocatePoolWithQuotaTag (NonPagedPool,
                                                              sizeof(VDM_IO_LISTHEAD),
                                                              'LVsP');

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
                if (HandlerListHead) {
                    ExFreePool(HandlerListHead);
                }
            }

            if ((!NT_SUCCESS(Status) || !HandlerListHead)) {
                ExReleaseResourceLite(&VdmIoListCreationResource);
                KeLowerIrql(OldIrql);

                return (Status == STATUS_SUCCESS ?
                    STATUS_INSUFFICIENT_RESOURCES :
                    Status);

            }

            ExInitializeResourceLite(&HandlerListHead->VdmIoResource);

            HandlerListHead->VdmIoHandlerList = NULL;

            //
            // Attach the list head to the process
            // and attach the handler to the list.
            // Since this was a new list

            pVdmObjects->VdmIoListHead = HandlerListHead;

            ExReleaseResourceLite(&VdmIoListCreationResource);
            KeLowerIrql(OldIrql);


        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS
Psp386InsertVdmIoHandlerBlock(
    IN PEPROCESS Process,
    IN PVDM_IO_HANDLER VdmIoHandler
    )
/*++

Routine Description:

    This routine inserts a new VdmIoHandler block into the process's io
    handler list.

Arguments:

    Process -- Supplies a pointer to the process
    VdmIoHandler -- Supplies a pointer to the block to insert.

Return Value:

--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    PVDM_IO_HANDLER HandlerList, p;
    PVDM_IO_LISTHEAD HandlerListHead;
    PAGED_CODE();


    HandlerListHead = pVdmObjects->VdmIoListHead;
    HandlerList = HandlerListHead->VdmIoHandlerList;
    p = NULL;
    while ((HandlerList != NULL) &&
        (HandlerList->PortNumber < VdmIoHandler->PortNumber)) {
#if DBG
            if (HandlerList->PortNumber == VdmIoHandler->PortNumber) {
                DbgPrint("Ps386InsertVdmIoHandlerBlock : handler list corrupt\n");
            }
#endif
            p = HandlerList;
            HandlerList = HandlerList->Next;
    }

    if (p == NULL) { // Beginning of list
        VdmIoHandler->Next = HandlerListHead->VdmIoHandlerList;
        HandlerListHead->VdmIoHandlerList = VdmIoHandler;
    } else if (HandlerList == NULL) { // End of list
        p->Next = VdmIoHandler;
        VdmIoHandler->Next = NULL;
    } else { // Middle of list
        VdmIoHandler->Next = HandlerList;
        p->Next = VdmIoHandler;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
Ps386GetVdmIoHandler(
    IN PEPROCESS Process,
    IN ULONG PortNumber,
    OUT PVDM_IO_HANDLER VdmIoHandler,
    OUT PULONG Context
    )
/*++

Routine Description:

    This routine finds the VdmIoHandler block for the specified port.

Arguments:

    Process -- Supplies a pointer to the process
    PortNumber -- Supplies the port number
    VdmIoHandler -- Supplies a pointer to the destination for the lookup

Returns:

    True -- A handler structure was found and copied
    False -- A handler structure was not found


--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    PVDM_IO_HANDLER p;
    BOOLEAN Success;
    KIRQL   OldIrql;
    PAGED_CODE();

    if (pVdmObjects == NULL) {
        return FALSE;
    }

    if (PortNumber % 4) {
#if DBG
        DbgPrint(
            "Ps386GetVdmIoHandler : Invalid Port Number %lx\n",
            PortNumber
            );
#endif
        return FALSE;
    }

    if (!pVdmObjects->VdmIoListHead) {
        return FALSE;
    }


    KeRaiseIrql(APC_LEVEL, &OldIrql);
    ExAcquireResourceExclusiveLite(&pVdmObjects->VdmIoListHead->VdmIoResource,TRUE);

    p = Psp386GetVdmIoHandler(
        Process,
        PortNumber
        );

    if (p) {
        *VdmIoHandler = *p;
        *Context = pVdmObjects->VdmIoListHead->Context;
        Success = TRUE;
    } else {
        Success = FALSE;
    }
    ExReleaseResourceLite(&pVdmObjects->VdmIoListHead->VdmIoResource);
    KeLowerIrql(OldIrql);

    return Success;
}


PVDM_IO_HANDLER
Psp386GetVdmIoHandler(
    IN PEPROCESS Process,
    IN ULONG PortNumber
    )
/*++

Routine Description:

    This routine finds the VdmIoHandler block for the specified port.

Arguments:

    Process -- Supplies a pointer to the process
    PortNumber -- Supplies the port number

Returns:

    NULL  if no handler found
    non-NULL if handler found

--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects = Process->VdmObjects;
    PVDM_IO_HANDLER p;
    PAGED_CODE();

    if (PortNumber % 4) {
#if DBG
        DbgPrint(
            "Ps386GetVdmIoHandler : Invalid Port Number %lx\n",
            PortNumber
            );
#endif
        return NULL;
    }

    p = pVdmObjects->VdmIoListHead->VdmIoHandlerList;
    while ((p) && (p->PortNumber != PortNumber)) {
        p = p->Next;
    }

    return p;

}

NTSTATUS
PspVdmInitialize(
    )

/*++

Routine Description:

    This routine initializes the process based Vdm support for x86.

Arguments:

    None

Return Value:

    TBS
--*/
{
    return ExInitializeResourceLite (&VdmIoListCreationResource);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\i386\psldt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    psldt.c

Abstract:

    This module contains code for the process and thread ldt support.

Author:

    Dave Hastings (daveh) 20 May 1991

Notes:

    The nonpaged pool consumed by the LDT is returned to the system at process
    deletion time.  The process deletion handler calls PspDeleteLdt.  We
    do not keep a reference to the process once the ldt is created.

    Note that the LDT must be kept in nonpaged memory because the EXIT_ALL
    macros that return from traps and interrupts pop ds (which may be an LDT
    selector) and then other registers.  With interrupts disabled.

Revision History:

--*/

#include "psp.h"

//
// Internal constants
//

#define DESCRIPTOR_GRAN     0x00800000
#define DESCRIPTOR_NP       0x00008000
#define DESCRIPTOR_SYSTEM   0x00001000
#define DESCRIPTOR_CONFORM  0x00001C00
#define DESCRIPTOR_DPL      0x00006000
#define DESCRIPTOR_TYPEDPL  0x00007F00


KMUTEX LdtMutex;

//
// Internal subroutines
//

PLDT_ENTRY
PspCreateLdt (
    IN PLDT_ENTRY Ldt,
    IN ULONG Offset,
    IN ULONG Size,
    IN ULONG AllocationSize
    );

LOGICAL
PspIsDescriptorValid (
    IN PLDT_ENTRY Descriptor
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PspLdtInitialize)
#pragma alloc_text(PAGE, PsSetLdtEntries)
#pragma alloc_text(PAGE, NtSetLdtEntries)
#pragma alloc_text(PAGE, PspDeleteLdt)
#pragma alloc_text(PAGE, PspQueryLdtInformation)
#pragma alloc_text(PAGE, PspSetLdtSize)
#pragma alloc_text(PAGE, PspSetLdtInformation)
#pragma alloc_text(PAGE, PspCreateLdt)
#pragma alloc_text(PAGE, PspIsDescriptorValid)
#pragma alloc_text(PAGE, PspQueryDescriptorThread)
#pragma alloc_text(PAGE, PsSetProcessLdtInfo)
#endif

NTSTATUS
PspLdtInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the LDT support for the x86

Arguments:

    None

Return Value:

    NTSTATUS.

--*/
{
    KeInitializeMutex  (&LdtMutex, 0);
    return STATUS_SUCCESS;
}


NTSTATUS
PspQueryLdtInformation (
    IN PEPROCESS Process,
    OUT PPROCESS_LDT_INFORMATION LdtInformation,
    IN ULONG LdtInformationLength,
    OUT PULONG ReturnLength
    )
/*++

Routine Description:

    This function performs the work for the LDT portion of the query
    process information function.  It copies the contents of the LDT
    for the specified process into the user's buffer, up to the length
    of the buffer.

Arguments:

    Process -- Supplies a pointer to the process to return LDT info for
    LdtInformation -- Supplies a pointer to the buffer
    ReturnLength -- Returns the number of bytes put into the buffer

Return Value:

    NTSTATUS.

--*/
{
    ULONG CopyLength, CopyEnd;
    NTSTATUS Status;
    ULONG HeaderLength;
    ULONG Length=0, Start=0;
    LONG MutexStatus;
    PLDTINFORMATION ProcessLdtInfo;

    PAGED_CODE();

    //
    // Verify the parameters
    //

    if (LdtInformationLength < sizeof (PROCESS_LDT_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // This portion of the parameters may be in user space
    //
    try {
        //
        // Capture parameters
        //
        Length = LdtInformation->Length;
        Start = LdtInformation->Start;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode ();
    }

    //
    // The buffer containing the LDT entries must be in the information
    // structure.  We subtract one LDT entry, because the structure is
    // declared to contain one.
    //
    if (LdtInformationLength - sizeof(PROCESS_LDT_INFORMATION) + sizeof(LDT_ENTRY) < Length) {

        return STATUS_INFO_LENGTH_MISMATCH;
    }

    // An LDT entry is a processor structure, and must be 8 bytes long
    ASSERT((sizeof(LDT_ENTRY) == 8));

    //
    // The length of the structure must be an even number of LDT entries
    //
    if (Length % sizeof (LDT_ENTRY)) {
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // The information to get from the LDT must start on an LDT entry
    // boundary.
    //
    if (Start % sizeof (LDT_ENTRY)) {
        return STATUS_INVALID_LDT_OFFSET;
    }

    //
    // Acquire the LDT mutex
    //

    Status = KeWaitForSingleObject (&LdtMutex,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ProcessLdtInfo = Process->LdtInformation;

    //
    // If the process has an LDT
    //

    if ((ProcessLdtInfo) && (ProcessLdtInfo->Size)) {

        ASSERT ((ProcessLdtInfo->Ldt));

        //
        // Set the end of the copy to be the smaller of:
        //  the end of the information the user requested or
        //  the end of the information that is actually there
        //

        if (ProcessLdtInfo->Size < Start) {
           CopyEnd = Start;
        } else if (ProcessLdtInfo->Size - Start  > Length) {
            CopyEnd = Length + Start;
        } else {
            CopyEnd = ProcessLdtInfo->Size;
        }

        CopyLength = CopyEnd - Start;

        try {

            //
            // Set the length field to the actual length of the LDT
            //

            LdtInformation->Length = ProcessLdtInfo->Size;

            //
            // Copy the contents of the LDT into the user's buffer
            //

            if (CopyLength) {

                RtlCopyMemory (&(LdtInformation->LdtEntries),
                               (PCHAR)ProcessLdtInfo->Ldt + Start,
                               CopyLength);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            MutexStatus = KeReleaseMutex (&LdtMutex, FALSE);
            ASSERT ((MutexStatus == 0));
            return GetExceptionCode ();
        }

    } else {

        //
        // There is no LDT
        //

        CopyLength = 0;
        try {
            LdtInformation->Length = 0;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            MutexStatus = KeReleaseMutex (&LdtMutex, FALSE);
            ASSERT ((MutexStatus == 0));
            return GetExceptionCode ();
        }
    }

    //
    // Set the length of the information returned
    //

    if (ARGUMENT_PRESENT (ReturnLength)) {

        try {
            HeaderLength = (PCHAR)(&(LdtInformation->LdtEntries)) -
                (PCHAR)(&(LdtInformation->Start));
            *ReturnLength = CopyLength + HeaderLength;
        } except (EXCEPTION_EXECUTE_HANDLER){
            MutexStatus = KeReleaseMutex (&LdtMutex, FALSE);
            ASSERT ((MutexStatus == 0));
            return GetExceptionCode ();
        }
    }

    MutexStatus = KeReleaseMutex (&LdtMutex, FALSE);
    ASSERT ((MutexStatus == 0));
    return STATUS_SUCCESS;
}


NTSTATUS
PspSetLdtSize (
    IN PEPROCESS Process,
    IN PPROCESS_LDT_SIZE LdtSize,
    IN ULONG LdtSizeLength
    )

/*++

Routine Description:

    This routine changes the LDT size.  It will shrink the LDT, but not
    grow it.  If the LDT shrinks by 1 or more pages from its current allocation,
    the LDT will be reallocated for the new smaller size.  If the allocated
    size of the LDT changes, the quota charge for the LDT will be reduced.

Arguments:

    Process -- Supplies a pointer to the process whose LDT is to be sized
    LdtSize -- Supplies a pointer to the size information

Return Value:

    NTSTATUS.

--*/
{
    ULONG OldSize = 0, NewSize;
    LONG MutexState;
    ULONG Length=0;
    PLDT_ENTRY OldLdt = NULL;
    NTSTATUS Status;
    PLDTINFORMATION ProcessLdtInfo;
    PLDT_ENTRY Ldt;

    PAGED_CODE();

    //
    // Verify the parameters
    //
    if (LdtSizeLength != sizeof (PROCESS_LDT_SIZE)){
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // The following parameters may be in user space
    //
    try {
        //
        // Capture the new LDT length
        //
        Length = LdtSize->Length;

    } except(EXCEPTION_EXECUTE_HANDLER){
        return GetExceptionCode ();
    }


    ASSERT((sizeof(LDT_ENTRY) == 8));

    //
    // The LDT must always be an integral number of LDT_ENTRIES
    //
    if (Length % sizeof(LDT_ENTRY)) {
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // Acquire the LDT Mutex
    //

    Status = KeWaitForSingleObject (&LdtMutex,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // If there isn't an LDT we can't set the size of the LDT
    //
    ProcessLdtInfo = Process->LdtInformation;
    if ((ProcessLdtInfo == NULL) || (ProcessLdtInfo->Size == 0)) {
        MutexState = KeReleaseMutex( &LdtMutex, FALSE );
        ASSERT((MutexState == 0));
        return STATUS_NO_LDT;
    }

    //
    // This function cannot be used to grow the LDT
    //
    if (Length > ProcessLdtInfo->Size) {
        MutexState = KeReleaseMutex( &LdtMutex, FALSE );
        ASSERT((MutexState == 0));
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // Later, we will set ProcessLdtInfo->LDT = LDT.  We may set the value
    // of LDT in the if statement below, but there is one case where we
    // don't
    //
    Ldt = ProcessLdtInfo->Ldt;

    //
    // Adjust the size of the LDT
    //

    ProcessLdtInfo->Size = Length;

    //
    // Free some of the LDT memory if conditions allow
    //

    if ( Length == 0 ) {

        OldSize = ProcessLdtInfo->AllocatedSize;
        OldLdt = ProcessLdtInfo->Ldt;

        ProcessLdtInfo->AllocatedSize = 0;
        Ldt = NULL;

    } else if ((ProcessLdtInfo->AllocatedSize - ProcessLdtInfo->Size) >= PAGE_SIZE) {

        OldSize = ProcessLdtInfo->AllocatedSize;
        OldLdt = ProcessLdtInfo->Ldt;

        //
        // Calculate new LDT size (lowest integer number of pages
        // large enough)
        //

        ProcessLdtInfo->AllocatedSize = ROUND_TO_PAGES (ProcessLdtInfo->Size);

        //
        // Reallocate and copy the LDT
        //

        Ldt = PspCreateLdt (ProcessLdtInfo->Ldt,
                            0,
                            ProcessLdtInfo->Size,
                            ProcessLdtInfo->AllocatedSize);

        if ( Ldt == NULL ) {

            //
            // We cannot reduce the allocation, but we can reduce the
            // LDT selector limit (done using Ke386SetLdtProcess)
            //

            Ldt = OldLdt;
            ProcessLdtInfo->AllocatedSize = OldSize;
            OldLdt = NULL;
        }
    }

    ProcessLdtInfo->Ldt = Ldt;

    //
    // Change the limit on the Process LDT
    //

    Ke386SetLdtProcess (&(Process->Pcb),
                        ProcessLdtInfo->Ldt,
                        ProcessLdtInfo->Size);

    NewSize = ProcessLdtInfo->AllocatedSize;

    MutexState = KeReleaseMutex (&LdtMutex, FALSE);

    ASSERT((MutexState == 0));

    //
    // If we resized the LDT, free the old one and reduce the quota charge
    //

    if (OldLdt) {
        ExFreePool (OldLdt);

        PsReturnProcessNonPagedPoolQuota (Process,
                                          OldSize - NewSize);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PspSetLdtInformation(
    IN PEPROCESS Process,
    IN PPROCESS_LDT_INFORMATION LdtInformation,
    IN ULONG LdtInformationLength
    )

/*++

Routine Description:

    This function alters the ldt for a specified process.  It can alter
    portions of the LDT, or the whole LDT.  If an LDT is created or
    grown, the specified process will be charged the quota for the LDT.
    Each descriptor that is set will be verified.

Arguments:

    Process -- Supplies a pointer to the process whose LDT is to be modified
    LdtInformation -- Supplies a pointer to the information about the LDT
        modifications
    LdtInformationLength -- Supplies the length of the LdtInformation
        structure.
Return Value:

    TBS
--*/
{
    NTSTATUS Status;
    PLDT_ENTRY OldLdt = NULL;
    ULONG OldSize = 0;
    ULONG AllocatedSize;
    ULONG Size;
    ULONG MutexState;
    ULONG LdtOffset;
    PLDT_ENTRY CurrentDescriptor;
    PPROCESS_LDT_INFORMATION LdtInfo=NULL;
    PLDTINFORMATION ProcessLdtInfo;
    PLDT_ENTRY Ldt;

    PAGED_CODE();

    if (LdtInformationLength < sizeof (PROCESS_LDT_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    Status = STATUS_SUCCESS;
    LdtInfo = ExAllocatePoolWithQuotaTag (NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                          LdtInformationLength,
                                          'dLsP');

    if (LdtInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // alocate a local buffer to capture the ldt information to
    //
    try {
        //
        // Copy the information the user is supplying
        //
        RtlCopyMemory (LdtInfo,
                       LdtInformation,
                       LdtInformationLength);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ExFreePool (LdtInfo);
        Status = GetExceptionCode ();
        return Status;
    }

    //
    // Verify that the Start and Length are plausible
    //
    if (LdtInfo->Start & 0xFFFF0000) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_OFFSET;
    }

    if (LdtInfo->Length & 0xFFFF0000) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // Insure that the buffer it large enough to contain the specified number
    // of selectors.
    //
    if (LdtInformationLength - sizeof (PROCESS_LDT_INFORMATION) + sizeof (LDT_ENTRY) < LdtInfo->Length) {
        ExFreePool (LdtInfo);
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // The info to set must be an integral number of selectors
    //
    if (LdtInfo->Length % sizeof (LDT_ENTRY)) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // The beginning of the info must be on a selector boundary
    //
    if (LdtInfo->Start % sizeof (LDT_ENTRY)) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_OFFSET;
    }

    //
    // Verify all of the descriptors.
    //

    for (CurrentDescriptor = LdtInfo->LdtEntries;
         (PCHAR)CurrentDescriptor < (PCHAR)LdtInfo->LdtEntries + LdtInfo->Length;
          CurrentDescriptor++) {
        if (!PspIsDescriptorValid (CurrentDescriptor)) {
            ExFreePool (LdtInfo);
            return STATUS_INVALID_LDT_DESCRIPTOR;
        }
    }

    //
    // Acquire the LDT Mutex
    //

    Status = KeWaitForSingleObject (&LdtMutex,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);
    if (!NT_SUCCESS (Status)) {
        ExFreePool (LdtInfo);
        return Status;
    }

    ProcessLdtInfo = Process->LdtInformation;

    //
    // If the process doen't have an LDT information structure, allocate
    //  one and attach it to the process
    //
    if (ProcessLdtInfo == NULL) {
        ProcessLdtInfo = ExAllocatePoolWithTag (NonPagedPool,
                                                sizeof(LDTINFORMATION),
                                                'dLsP');
        if (ProcessLdtInfo == NULL) {
            goto SetInfoCleanup;
        }
        Process->LdtInformation = ProcessLdtInfo;
        RtlZeroMemory (ProcessLdtInfo, sizeof (LDTINFORMATION));
    }

    //
    // If we are supposed to remove the LDT
    //
    if (LdtInfo->Length == 0)  {

        //
        // Remove the process' LDT
        //

        if (ProcessLdtInfo->Ldt) {
            OldSize = ProcessLdtInfo->AllocatedSize;
            OldLdt = ProcessLdtInfo->Ldt;

            ProcessLdtInfo->AllocatedSize = 0;
            ProcessLdtInfo->Size = 0;
            ProcessLdtInfo->Ldt = NULL;

            Ke386SetLdtProcess (&Process->Pcb,
                                NULL,
                                0);

            PsReturnProcessNonPagedPoolQuota (Process, OldSize);
        }


    } else if (ProcessLdtInfo->Ldt == NULL) {

        //
        // Create a new LDT for the process
        //

        //
        // Allocate an integral number of pages for the LDT.
        //

        ASSERT(((PAGE_SIZE % 2) == 0));

        AllocatedSize = ROUND_TO_PAGES (LdtInfo->Start + LdtInfo->Length);

        Size = LdtInfo->Start + LdtInfo->Length;

        Ldt = PspCreateLdt (LdtInfo->LdtEntries,
                            LdtInfo->Start,
                            Size,
                            AllocatedSize);

        if (Ldt == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SetInfoCleanup;
        }

        Status = PsChargeProcessNonPagedPoolQuota (Process,
                                                   AllocatedSize);

        if (!NT_SUCCESS (Status)) {
            ExFreePool (Ldt);
            Ldt = NULL;
            goto SetInfoCleanup;
        }

        ProcessLdtInfo->Ldt = Ldt;
        ProcessLdtInfo->Size = Size;
        ProcessLdtInfo->AllocatedSize = AllocatedSize;
        Ke386SetLdtProcess (&Process->Pcb,
                            ProcessLdtInfo->Ldt,
                            ProcessLdtInfo->Size);


    } else if (LdtInfo->Length + LdtInfo->Start > ProcessLdtInfo->Size) {

        //
        // Grow the process' LDT
        //

        if (LdtInfo->Length + LdtInfo->Start > ProcessLdtInfo->AllocatedSize) {

            //
            // Current LDT allocation is not large enough, so create a
            // new larger LDT
            //

            OldSize = ProcessLdtInfo->AllocatedSize;

            Size = LdtInfo->Start + LdtInfo->Length;
            AllocatedSize = ROUND_TO_PAGES (Size);

            Ldt = PspCreateLdt (ProcessLdtInfo->Ldt,
                                0,
                                OldSize,
                                AllocatedSize);

            if (Ldt == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SetInfoCleanup;
            }


            Status = PsChargeProcessNonPagedPoolQuota (Process,
                                                       AllocatedSize);

            if (!NT_SUCCESS (Status)) {
                ExFreePool (Ldt);
                Ldt = NULL;
                goto SetInfoCleanup;
            }
            PsReturnProcessNonPagedPoolQuota (Process,
                                              OldSize);

            //
            // Swap LDT information
            //
            OldLdt = ProcessLdtInfo->Ldt;
            ProcessLdtInfo->Ldt = Ldt;
            ProcessLdtInfo->Size = Size;
            ProcessLdtInfo->AllocatedSize = AllocatedSize;

            //
            // Put new selectors into the new ldt
            //
            RtlCopyMemory ((PCHAR)(ProcessLdtInfo->Ldt) + LdtInfo->Start,
                           LdtInfo->LdtEntries,
                           LdtInfo->Length);

            Ke386SetLdtProcess (&Process->Pcb,
                                ProcessLdtInfo->Ldt,
                                ProcessLdtInfo->Size);


        } else {

            //
            // Current LDT allocation is large enough
            //

            ProcessLdtInfo->Size = LdtInfo->Length + LdtInfo->Start;

            Ke386SetLdtProcess (&Process->Pcb,
                                ProcessLdtInfo->Ldt,
                                ProcessLdtInfo->Size);

            //
            // Change the selectors in the table
            //
            for (LdtOffset = LdtInfo->Start, CurrentDescriptor = LdtInfo->LdtEntries;
                 LdtOffset < LdtInfo->Start + LdtInfo->Length;
                 LdtOffset += sizeof(LDT_ENTRY), CurrentDescriptor++) {

                Ke386SetDescriptorProcess (&Process->Pcb,
                                           LdtOffset,
                                           *CurrentDescriptor);
            }
        }
    } else {

        //
        // Simply changing some selectors
        //

        for (LdtOffset = LdtInfo->Start, CurrentDescriptor = LdtInfo->LdtEntries;
             LdtOffset < LdtInfo->Start +  LdtInfo->Length;
             LdtOffset += sizeof(LDT_ENTRY), CurrentDescriptor++) {

            Ke386SetDescriptorProcess (&Process->Pcb,
                                       LdtOffset,
                                       *CurrentDescriptor);
        }
        Status = STATUS_SUCCESS;
    }


SetInfoCleanup:

    MutexState = KeReleaseMutex (&LdtMutex, FALSE);
    ASSERT ((MutexState == 0));

    if (OldLdt != NULL) {
        ExFreePool (OldLdt);
    }

    if (LdtInfo != NULL) {
        ExFreePool (LdtInfo);
    }

    return Status;
}

PLDT_ENTRY
PspCreateLdt (
    IN PLDT_ENTRY Ldt,
    IN ULONG Offset,
    IN ULONG Size,
    IN ULONG AllocationSize
    )

/*++

Routine Description:

    This routine allocates space in nonpaged pool for an LDT, and copies the
    specified selectors into it.  IT DOES NOT VALIDATE THE SELECTORS.
    Selector validation must be done before calling this routine.  IT
    DOES NOT CHARGE THE QUOTA FOR THE LDT.

Arguments:

    Ldt -- Supplies a pointer to the descriptors to be put into the LDT.
    Offset -- Supplies the offset in the LDT to copy the descriptors to.
    Size -- Supplies the actualsize of the new LDT
    AllocationSize -- Supplies the size to allocate

Return Value:

    Pointer to the new LDT
--*/
{
    PLDT_ENTRY NewLdt;

    PAGED_CODE();

    ASSERT ((AllocationSize >= Size));
    ASSERT (((Size % sizeof(LDT_ENTRY)) == 0));

    NewLdt = ExAllocatePoolWithTag (NonPagedPool, AllocationSize, 'dLsP');

    if (NewLdt != NULL) {
        RtlZeroMemory (NewLdt, AllocationSize);
        RtlCopyMemory ((PCHAR)NewLdt + Offset, Ldt, Size - Offset);
    }

    return NewLdt;
}



LOGICAL
PspIsDescriptorValid (
    IN PLDT_ENTRY Descriptor
    )

/*++

Routine Description:

    This function determines if the supplied descriptor is valid to put
    into a process LDT.  For the descriptor to be valid it must have the
    following characteristics:

    Base < MM_HIGHEST_USER_ADDRESS
    Base + Limit < MM_HIGHEST_USER_ADDRESS
    Type must be
        ReadWrite, ReadOnly, ExecuteRead, ExecuteOnly, or Invalid
        big or small
        normal or grow down
        Not a system descriptor (system bit is 1 == application)
            This rules out all gates, etc
        Not conforming
    DPL must be 3

Arguments:

    Descriptor -- Supplies a pointer to the descriptor to check

Return Value:

    True if the descriptor is valid (note: valid to put into an LDT.  This
        includes Invalid descriptors)
    False if not
--*/

{
    ULONG Base;
    ULONG Limit;

    PAGED_CODE();

    //
    // if descriptor is an invalid descriptor
    //

    if ((Descriptor->HighWord.Bits.Type == 0) &&
        (Descriptor->HighWord.Bits.Dpl == 0)) {

        return TRUE;
    }

    Base = Descriptor->BaseLow | (Descriptor->HighWord.Bytes.BaseMid << 16) |
           (Descriptor->HighWord.Bytes.BaseHi << 24);

    Limit = Descriptor->LimitLow | (Descriptor->HighWord.Bits.LimitHi << 16);

    //
    // Only have to check for present selectors
    //
    if (Descriptor->HighWord.Bits.Pres) {
        ULONG ActualLimit;

        if ((Descriptor->HighWord.Bits.Type&0x14) == 0x14) {
            if (Descriptor->HighWord.Bits.Default_Big == 1) {
                ActualLimit = 0xFFFFFFFF;
            } else {
                ActualLimit = 0xFFFF;
            }
        } else if (Descriptor->HighWord.Bits.Granularity == 0) {
            ActualLimit = Limit;
        } else {
            ActualLimit = (Limit<<12) + 0xFFF;
        }

        //
        // See if the segment extends into the kernel address space.
        //
        if (Base > Base + ActualLimit ||
            ((PVOID)(Base + ActualLimit) > MM_HIGHEST_USER_ADDRESS)) {
            return FALSE;
        }

        //
        // Don't let the reserved field be set.
        //
        if (Descriptor->HighWord.Bits.Reserved_0 != 0) {
            return FALSE;
        }
    }


    //
    // if Dpl is not 3
    //

    if (Descriptor->HighWord.Bits.Dpl != 3) {
        return FALSE;
    }

    //
    // if descriptor is a system descriptor (which includes gates)
    // if bit 4 of the Type field is 0, then it's a system descriptor,
    // and we don't like it.
    //

    if (!(Descriptor->HighWord.Bits.Type & 0x10)) {
        return FALSE;
    }

    //
    // if descriptor is conforming code
    //

    if (((Descriptor->HighWord.Bits.Type & 0x18) == 0x18) &&
        (Descriptor->HighWord.Bits.Type & 0x4)) {

        return FALSE;
    }

    return TRUE;
}

NTSTATUS
PspQueryDescriptorThread (
    PETHREAD Thread,
    PVOID ThreadInformation,
    ULONG ThreadInformationLength,
    PULONG ReturnLength
    )
/*++

Routine Description:

    This function retrieves a descriptor table entry for the specified thread.
    This entry may be in either the Gdt or the LDT, as specfied by the
    supplied selector

Arguments:

    Thread -- Supplies a pointer to the thread.
    ThreadInformation -- Supplies information on the descriptor.
    ThreadInformationLength -- Supplies the length of the information.
    ReturnLength -- Returns the number of bytes returned.

Return Value:

    TBS
--*/
{
    DESCRIPTOR_TABLE_ENTRY DescriptorEntry={0};
    PEPROCESS Process;
    LONG MutexState;
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT( sizeof(KGDTENTRY) == sizeof(LDT_ENTRY) );

    //
    // Verify parameters
    //

    if ( ThreadInformationLength != sizeof(DESCRIPTOR_TABLE_ENTRY) ) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    try {
        DescriptorEntry = *(PDESCRIPTOR_TABLE_ENTRY)ThreadInformation;
    } except(EXCEPTION_EXECUTE_HANDLER){
        return GetExceptionCode ();
    }


    Status = STATUS_SUCCESS;

    //
    // If its a Gdt entry, let the kernel find it for us
    //

    if ( !(DescriptorEntry.Selector & SELECTOR_TABLE_INDEX) ) {

        if ( (DescriptorEntry.Selector & 0xFFFFFFF8) >= KGDT_NUMBER * sizeof(KGDTENTRY) ) {

            return STATUS_ACCESS_VIOLATION;
        }

        try {
            Ke386GetGdtEntryThread (&Thread->Tcb,
                                    DescriptorEntry.Selector & 0xFFFFFFF8,
                                    (PKGDTENTRY) &(((PDESCRIPTOR_TABLE_ENTRY)ThreadInformation)->Descriptor));
            if (ARGUMENT_PRESENT(ReturnLength) ) {
                *ReturnLength = sizeof(LDT_ENTRY);
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    } else {

        //
        // it's an LDT entry, so copy it from the LDT
        //

        Process = THREAD_TO_PROCESS (Thread);

        //
        // Acquire the LDT Mutex
        //

        Status = KeWaitForSingleObject (&LdtMutex,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        if ( Process->LdtInformation == NULL ) {

            // If there is no LDT
            Status = STATUS_NO_LDT;

        } else if ( (DescriptorEntry.Selector & 0xFFFFFFF8) >=
            ((PLDTINFORMATION)(Process->LdtInformation))->Size ) {

            // Else If the selector is outside the table
            Status = STATUS_ACCESS_VIOLATION;

        } else try {

            // Else return the contents of the descriptor
            RtlCopyMemory (&(((PDESCRIPTOR_TABLE_ENTRY)ThreadInformation)->Descriptor),
                           (PCHAR)(((PLDTINFORMATION)(Process->LdtInformation))->Ldt) +
                               (DescriptorEntry.Selector & 0xFFFFFFF8),
                           sizeof(LDT_ENTRY));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(LDT_ENTRY);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode ();
        }

        MutexState = KeReleaseMutex (&LdtMutex, FALSE);
        ASSERT ((MutexState == 0));
    }

    return Status;
}

VOID
PspDeleteLdt(
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This routine frees the nonpaged pool associated with a process' LDT, if
    it has one.

Arguments:

    Process -- Supplies a pointer to the process

Return Value:

    None
--*/
{
    PLDTINFORMATION LdtInformation;

    PAGED_CODE();

    LdtInformation = Process->LdtInformation;
    if (LdtInformation != NULL) {
        if (LdtInformation->Ldt != NULL) {
            PsReturnProcessNonPagedPoolQuota (Process, LdtInformation->AllocatedSize);
            ExFreePool (LdtInformation->Ldt);
        }
        ExFreePool( LdtInformation );
    }
}

NTSTATUS
PsSetLdtEntries (
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1Hi
    )
/*++

Routine Description:

    This routine sets up to two selectors in the current process's LDT.
    The LDT will be grown as necessary.  A selector value of 0 indicates
    that the specified selector was not passed (allowing the setting of
    a single selector).

Arguments:

    Selector0 -- Supplies the number of the first descriptor to set
    Entry0Low -- Supplies the low 32 bits of the descriptor
    Entry0Hi -- Supplies the high 32 bits of the descriptor
    Selector1 -- Supplies the number of the first descriptor to set
    Entry1Low -- Supplies the low 32 bits of the descriptor
    Entry1Hi -- Supplies the high 32 bits of the descriptor

Return Value:

    NTSTATUS.

--*/

{
    ULONG LdtSize, AllocatedSize;
    NTSTATUS Status;
    PEPROCESS Process;
    LDT_ENTRY Descriptor[2];
    PLDT_ENTRY Ldt, OldLdt;
    PLDTINFORMATION ProcessLdtInformation;
    LONG MutexState;
    ULONG Selector1Index;

    PAGED_CODE();

    //
    // Verify the selectors.  We do not allow selectors that point into
    // Kernel space, system selectors, or conforming code selectors
    //

    //
    // Verify the selectors
    //
    if ((Selector0 & 0xFFFF0000) || (Selector1 & 0xFFFF0000)) {
        return STATUS_INVALID_LDT_DESCRIPTOR;
    }

    // Change the selector values to indexes into the LDT

    Selector0 = Selector0 & ~(RPL_MASK | SELECTOR_TABLE_INDEX);
    Selector1 = Selector1 & ~(RPL_MASK | SELECTOR_TABLE_INDEX);


    //
    // Verify descriptor 0
    //

    Selector1Index = 0;
    if (Selector0) {

        Selector1Index = 1;

        *((PULONG)(&Descriptor[0]))       = Entry0Low;
        *(((PULONG)(&Descriptor[0])) + 1) = Entry0Hi;

        //
        // Validate the descriptor
        //
        if (!PspIsDescriptorValid (&Descriptor[0])) {
            return STATUS_INVALID_LDT_DESCRIPTOR;
        }
    }

    //
    // Verify descriptor 1
    //

    if (Selector1) {
        *((PULONG)(&Descriptor[Selector1Index]))       = Entry1Low;
        *(((PULONG)(&Descriptor[Selector1Index])) + 1) = Entry1Hi;

        //
        // Validate the descriptor
        //
        if (!PspIsDescriptorValid (&Descriptor[Selector1Index])) {
            return STATUS_INVALID_LDT_DESCRIPTOR;
        }
    }

    //
    // Figure out how large the LDT needs to be
    //

    if (Selector0 > Selector1) {
        LdtSize = Selector0 + sizeof(LDT_ENTRY);
    } else {
        LdtSize = Selector1 + sizeof(LDT_ENTRY);
    }

    Process = PsGetCurrentProcess();

    //
    // Acquire the LDT mutex.
    //

    Status = KeWaitForSingleObject (&LdtMutex,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ProcessLdtInformation = Process->LdtInformation;

    //
    // Most of the time, the process will already have an LDT, and it
    // will be large enough.  for this, we just set the descriptors and
    // return
    //

    if (ProcessLdtInformation) {

        //
        // If the LDT descriptor does not have to be modified.
        //

        if (ProcessLdtInformation->Size >= LdtSize) {

            if (Selector0) {

                Ke386SetDescriptorProcess (&(Process->Pcb),
                                           Selector0,
                                           Descriptor[0]);
            }

            if (Selector1) {

                Ke386SetDescriptorProcess (&(Process->Pcb),
                                           Selector1,
                                           Descriptor[Selector1Index]);
            }

            MutexState = KeReleaseMutex (&LdtMutex, FALSE);
            ASSERT (MutexState == 0);
            return STATUS_SUCCESS;
        }

        //
        // Else if the LDT will fit in the memory currently allocated.
        //

        if (ProcessLdtInformation->AllocatedSize >= LdtSize) {

            //
            // First remove the LDT.  This will allow us to edit the memory.
            // We will then put the LDT back.  Since we have to change the
            // limit anyway, it would take two calls to the kernel ldt
            // management minimum to set the descriptors.  Each of those calls
            // would stall all of the processors in an MP system.  If we
            // didn't remove the ldt first, and we were setting two descriptors,
            // we would have to call the LDT management 3 times (once per
            // descriptor, and once to change the limit of the LDT).
            //

            Ke386SetLdtProcess (&(Process->Pcb), NULL, 0L);

            //
            // Set the Descriptors in the LDT.
            //

            if (Selector0) {
                *((PLDT_ENTRY) &ProcessLdtInformation->Ldt[Selector0/sizeof(LDT_ENTRY)]) = Descriptor[0];
            }

            if (Selector1) {
                *((PLDT_ENTRY) &ProcessLdtInformation->Ldt[Selector1/sizeof(LDT_ENTRY)]) = Descriptor[Selector1Index];
            }

            //
            // Set the LDT for the process
            //

            ProcessLdtInformation->Size = LdtSize;

            Ke386SetLdtProcess (&(Process->Pcb),
                                ProcessLdtInformation->Ldt,
                                ProcessLdtInformation->Size);

            MutexState = KeReleaseMutex (&LdtMutex, FALSE);
            ASSERT (MutexState == 0);
            return STATUS_SUCCESS;
        }

        //
        // Otherwise we have to grow the LDT allocation.
        //
    }

    //
    // If the process does not yet have an LDT information structure,
    // allocate and attach one.
    //

    OldLdt = NULL;

    if (!Process->LdtInformation) {
        ProcessLdtInformation = ExAllocatePoolWithTag (NonPagedPool,
                                                       sizeof(LDTINFORMATION),
                                                       'dLsP');
        if (ProcessLdtInformation == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SetLdtEntriesCleanup;
        }
        Process->LdtInformation = ProcessLdtInformation;
        ProcessLdtInformation->Size = 0L;
        ProcessLdtInformation->AllocatedSize = 0L;
        ProcessLdtInformation->Ldt = NULL;
    }

    //
    // Now, we either need to create or grow an LDT, so allocate some
    // memory, and copy as necessary
    //

    AllocatedSize = ROUND_TO_PAGES (LdtSize);

    Ldt = ExAllocatePoolWithTag (NonPagedPool, AllocatedSize, 'dLsP');

    if (Ldt == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SetLdtEntriesCleanup;
    }

    Status = PsChargeProcessNonPagedPoolQuota (Process, AllocatedSize);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Ldt);
        Ldt = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SetLdtEntriesCleanup;
    }

    RtlZeroMemory (Ldt, AllocatedSize);

    OldLdt = ProcessLdtInformation->Ldt;

    if (OldLdt != NULL) {

        //
        // copy the contents of the old LDT
        //

        RtlCopyMemory (Ldt, OldLdt, ProcessLdtInformation->Size);

        PsReturnProcessNonPagedPoolQuota (Process,
                                          ProcessLdtInformation->AllocatedSize);
    }

    ProcessLdtInformation->Size = LdtSize;
    ProcessLdtInformation->AllocatedSize = AllocatedSize;
    ProcessLdtInformation->Ldt = Ldt;

    //
    // Set the descriptors in the LDT
    //

    if (Selector0) {
        *((PLDT_ENTRY) &ProcessLdtInformation->Ldt[Selector0/sizeof(LDT_ENTRY)]) = Descriptor[0];
    }

    if (Selector1) {
        *((PLDT_ENTRY) &ProcessLdtInformation->Ldt[Selector1/sizeof(LDT_ENTRY)]) = Descriptor[Selector1Index];
    }

    //
    // Set the LDT for the process
    //

    Ke386SetLdtProcess (&Process->Pcb,
                        ProcessLdtInformation->Ldt,
                        ProcessLdtInformation->Size);

    //
    // Cleanup and exit
    //

    Status = STATUS_SUCCESS;

SetLdtEntriesCleanup:

    MutexState = KeReleaseMutex (&LdtMutex, FALSE);
    ASSERT (MutexState == 0);

    if (OldLdt != NULL) {
        ExFreePool (OldLdt);
    }

    return Status;
}
NTSTATUS
NtSetLdtEntries(
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1Hi
    )
/*++

Routine Description:

    This routine sets up to two selectors in the current process's LDT.
    The LDT will be grown as necessary.  A selector value of 0 indicates
    that the specified selector was not passed (allowing the setting of
    a single selector).

Arguments:

    Selector0 -- Supplies the number of the first descriptor to set
    Entry0Low -- Supplies the low 32 bits of the descriptor
    Entry0Hi -- Supplies the high 32 bits of the descriptor
    Selector1 -- Supplies the number of the first descriptor to set
    Entry1Low -- Supplies the low 32 bits of the descriptor
    Entry1Hi -- Supplies the high 32 bits of the descriptor

Return Value:

    NTSTATUS.

--*/

{
    return PsSetLdtEntries (Selector0,
                            Entry0Low,
                            Entry0Hi,
                            Selector1,
                            Entry1Low,
                            Entry1Hi
                            );
}

NTSTATUS
PsSetProcessLdtInfo (
    IN PPROCESS_LDT_INFORMATION LdtInformation,
    IN ULONG LdtInformationLength
    )

/*++

Routine Description:

    This function alters the ldt for a specified process.  It can alter
    portions of the LDT, or the whole LDT.  If an Ldt is created or
    grown, the specified process will be charged the quota for the LDT.
    Each descriptor that is set will be verified.

Arguments:

    LdtInformation - Supplies a pointer to a record that contains the
        information to set.  This pointer has already been probed, but since
        it is a usermode pointer, accesses must be guarded by try-except.

    LdtInformationLength - Supplies the length of the record that contains
        the information to set.

Return Value:

    NTSTATUS.

--*/

{
    PEPROCESS Process = PsGetCurrentProcess();
    NTSTATUS Status;
    PLDT_ENTRY OldLdt = NULL;
    ULONG OldSize = 0;
    ULONG AllocatedSize;
    ULONG Size;
    ULONG MutexState;
    ULONG LdtOffset;
    PLDT_ENTRY CurrentDescriptor;
    PPROCESS_LDT_INFORMATION LdtInfo;
    PLDTINFORMATION ProcessLdtInfo;
    PLDT_ENTRY Ldt;

    PAGED_CODE();

    if (LdtInformationLength < (ULONG)sizeof( PROCESS_LDT_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Allocate a local buffer to capture the ldt information to
    //

    LdtInfo = ExAllocatePoolWithQuotaTag (NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                          LdtInformationLength,
                                          'ldmV');
    if (LdtInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = STATUS_SUCCESS;

    try {

        //
        // Copy the information the user is supplying
        //

        RtlCopyMemory (LdtInfo,
                       LdtInformation,
                       LdtInformationLength);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode ();
        ExFreePool (LdtInfo);
    }

    //
    // If the capture didn't succeed
    //

    if (!NT_SUCCESS (Status)) {

        if (Status == STATUS_ACCESS_VIOLATION) {
            return STATUS_SUCCESS;
        }

        return Status;
    }

    //
    // Verify that the Start and Length are plausible
    //
    if (LdtInfo->Start & 0xFFFF0000) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_OFFSET;
    }

    if (LdtInfo->Length & 0xFFFF0000) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // Insure that the buffer is large enough to contain the specified number
    // of selectors.
    //
    if (LdtInformationLength - sizeof (PROCESS_LDT_INFORMATION) + sizeof (LDT_ENTRY) < LdtInfo->Length) {
        ExFreePool (LdtInfo);
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // The info to set must be an integral number of selectors
    //
    if (LdtInfo->Length % sizeof (LDT_ENTRY)) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_SIZE;
    }

    //
    // The beginning of the info must be on a selector boundary
    //
    if (LdtInfo->Start % sizeof (LDT_ENTRY)) {
        ExFreePool (LdtInfo);
        return STATUS_INVALID_LDT_OFFSET;
    }

    //
    // Verify all of the descriptors.
    //

    for (CurrentDescriptor = LdtInfo->LdtEntries;
         (PCHAR)CurrentDescriptor < (PCHAR)LdtInfo->LdtEntries + LdtInfo->Length;
          CurrentDescriptor += 1) {

        if (!PspIsDescriptorValid (CurrentDescriptor)) {
            ExFreePool (LdtInfo);
            return STATUS_INVALID_LDT_DESCRIPTOR;
        }
    }

    //
    // Acquire the Ldt Mutex
    //

    Status = KeWaitForSingleObject (&LdtMutex,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);
    if (!NT_SUCCESS (Status)) {
        ExFreePool (LdtInfo);
        return Status;
    }

    ProcessLdtInfo = Process->LdtInformation;

    //
    // If the process doesn't have an Ldt information structure, allocate
    // one and attach it to the process
    //

    if (ProcessLdtInfo == NULL) {
        ProcessLdtInfo = ExAllocatePoolWithTag (NonPagedPool,
                                                sizeof(LDTINFORMATION),
                                                'dLsP');
        if (ProcessLdtInfo == NULL) {
            goto SetInfoCleanup;
        }
        RtlZeroMemory (ProcessLdtInfo, sizeof (LDTINFORMATION));
        Process->LdtInformation = ProcessLdtInfo;
    }

    //
    // If we are supposed to remove the LDT
    //
    if (LdtInfo->Length == 0)  {

        //
        // Remove the process' Ldt
        //

        if (ProcessLdtInfo->Ldt) {
            OldSize = ProcessLdtInfo->AllocatedSize;
            OldLdt = ProcessLdtInfo->Ldt;

            ProcessLdtInfo->AllocatedSize = 0;
            ProcessLdtInfo->Size = 0;
            ProcessLdtInfo->Ldt = NULL;

            Ke386SetLdtProcess (&Process->Pcb,
                                NULL,
                                0);

            PsReturnProcessNonPagedPoolQuota (Process, OldSize);
        }

    } else if (ProcessLdtInfo->Ldt == NULL) {

        //
        // Create a new Ldt for the process
        //
        // Allocate an integral number of pages for the LDT.
        //

        ASSERT(((PAGE_SIZE % 2) == 0));

        AllocatedSize = ROUND_TO_PAGES (LdtInfo->Start + LdtInfo->Length);

        Size = LdtInfo->Start + LdtInfo->Length;

        Ldt = PspCreateLdt (LdtInfo->LdtEntries,
                            LdtInfo->Start,
                            Size,
                            AllocatedSize);

        if (Ldt == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SetInfoCleanup;
        }

        Status = PsChargeProcessNonPagedPoolQuota (Process,
                                                   AllocatedSize);

        if (!NT_SUCCESS (Status)) {
            ExFreePool (Ldt);
            Ldt = NULL;
            goto SetInfoCleanup;
        }

        ProcessLdtInfo->Ldt = Ldt;
        ProcessLdtInfo->Size = Size;
        ProcessLdtInfo->AllocatedSize = AllocatedSize;
        Ke386SetLdtProcess (&Process->Pcb,
                            ProcessLdtInfo->Ldt,
                            ProcessLdtInfo->Size);


    } else if (LdtInfo->Length + LdtInfo->Start > ProcessLdtInfo->Size) {

        //
        // Grow the process' Ldt
        //

        if (LdtInfo->Length + LdtInfo->Start > ProcessLdtInfo->AllocatedSize) {

            //
            // Current Ldt allocation is not large enough, so create a
            // new larger Ldt
            //

            OldSize = ProcessLdtInfo->AllocatedSize;

            Size = LdtInfo->Start + LdtInfo->Length;
            AllocatedSize = ROUND_TO_PAGES (Size);

            Ldt = PspCreateLdt (ProcessLdtInfo->Ldt,
                                0,
                                OldSize,
                                AllocatedSize);

            if (Ldt == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SetInfoCleanup;
            }

            Status = PsChargeProcessNonPagedPoolQuota (Process,
                                                       AllocatedSize);

            if (!NT_SUCCESS (Status)) {
                ExFreePool (Ldt);
                Ldt = NULL;
                goto SetInfoCleanup;
            }
            PsReturnProcessNonPagedPoolQuota (Process,
                                              OldSize);

            //
            // Swap Ldt information
            //
            OldLdt = ProcessLdtInfo->Ldt;
            ProcessLdtInfo->Ldt = Ldt;
            ProcessLdtInfo->Size = Size;
            ProcessLdtInfo->AllocatedSize = AllocatedSize;

            //
            // Put new selectors into the new ldt
            //
            RtlCopyMemory ((PCHAR)(ProcessLdtInfo->Ldt) + LdtInfo->Start,
                           LdtInfo->LdtEntries,
                           LdtInfo->Length);

            Ke386SetLdtProcess (&Process->Pcb,
                                ProcessLdtInfo->Ldt,
                                ProcessLdtInfo->Size);


        } else {

            //
            // Current Ldt allocation is large enough
            //

            ProcessLdtInfo->Size = LdtInfo->Length + LdtInfo->Start;

            Ke386SetLdtProcess (&Process->Pcb,
                                ProcessLdtInfo->Ldt,
                                ProcessLdtInfo->Size);

            //
            // Change the selectors in the table
            //
            for (LdtOffset = LdtInfo->Start, CurrentDescriptor = LdtInfo->LdtEntries;
                 LdtOffset < LdtInfo->Start + LdtInfo->Length;
                 LdtOffset += sizeof(LDT_ENTRY), CurrentDescriptor++) {

                Ke386SetDescriptorProcess (&Process->Pcb,
                                           LdtOffset,
                                           *CurrentDescriptor);
            }
        }
    } else {

        //
        // Simply changing some selectors
        //

        for (LdtOffset = LdtInfo->Start, CurrentDescriptor = LdtInfo->LdtEntries;
             LdtOffset < LdtInfo->Start +  LdtInfo->Length;
             LdtOffset += sizeof(LDT_ENTRY), CurrentDescriptor++) {

            Ke386SetDescriptorProcess (&Process->Pcb,
                                       LdtOffset,
                                       *CurrentDescriptor);
        }
        Status = STATUS_SUCCESS;
    }


SetInfoCleanup:

    MutexState = KeReleaseMutex (&LdtMutex, FALSE);
    ASSERT ((MutexState == 0));

    if (OldLdt != NULL) {
        ExFreePool (OldLdt);
    }

    if (LdtInfo != NULL) {
        ExFreePool (LdtInfo);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\amd64\psvdm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    psldt.c

Abstract:

    This module contains mips stubs for the Io port handler support

Author:

    Dave Hastings (daveh) 26 Jan 1991

Revision History:

--*/

#include "psp.h"


NTSTATUS
PspSetProcessIoHandlers(
    IN PEPROCESS Process,
    IN PVOID IoHandlerInformation,
    IN ULONG IoHandlerLength
    )
/*++

Routine Description:

    This routine returns STATUS_NOT_IMPLEMENTED

Arguments:

    Process -- Supplies a pointer to the process for which Io port handlers
        are to be installed
    IoHandlerInformation -- Supplies a pointer to the information about the
        io port handlers
    IoHandlerLength -- Supplies the length of the IoHandlerInformation
        structure.

Return Value:

    Returns STATUS_NOT_IMPLEMENTED

--*/
{
    UNREFERENCED_PARAMETER(Process);
    UNREFERENCED_PARAMETER(IoHandlerInformation);
    UNREFERENCED_PARAMETER(IoHandlerLength);
    return STATUS_NOT_IMPLEMENTED;
}

VOID
PspDeleteVdmObjects(
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This is a stub for the Vdm Objects delete routine

Arguments:

    Process -- Supplies a pointer to the process

Return Value:

    None
--*/
{
    UNREFERENCED_PARAMETER(Process);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\ia64\psvdm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    psldt.c

Abstract:

    This module contains mips stubs for the Io port handler support

Author:

    Dave Hastings (daveh) 26 Jan 1991

Revision History:

--*/

#include "psp.h"


NTSTATUS
PspSetProcessIoHandlers(
    IN PEPROCESS Process,
    IN PVOID IoHandlerInformation,
    IN ULONG IoHandlerLength
    )
/*++

Routine Description:

    This routine returns STATUS_NOT_IMPLEMENTED

Arguments:

    Process -- Supplies a pointer to the process for which Io port handlers
        are to be installed
    IoHandlerInformation -- Supplies a pointer to the information about the
        io port handlers
    IoHandlerLength -- Supplies the length of the IoHandlerInformation
        structure.

Return Value:

    Returns STATUS_NOT_IMPLEMENTED

--*/
{
    UNREFERENCED_PARAMETER(Process);
    UNREFERENCED_PARAMETER(IoHandlerInformation);
    UNREFERENCED_PARAMETER(IoHandlerLength);
    return STATUS_NOT_IMPLEMENTED;
}

VOID
PspDeleteVdmObjects(
    IN PEPROCESS Process
    )
/*++

Routine Description:

    This is a stub for the Vdm Objects delete routine

Arguments:

    Process -- Supplies a pointer to the process

Return Value:

    None
--*/
{
    UNREFERENCED_PARAMETER(Process);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ps\ia64\pswrap.s ===
#include "ksia64.h"

        .file     "pswrap.s"
        .text

        PublicFunction(PspGetSetContextSpecialApcMain)
        PublicFunction(KiRestoreExceptionFrame)

        NESTED_ENTRY(PspGetSetContextSpecialApc)
        PROLOGUE_BEGIN

        .regstk   0, 0, 5, 0
        alloc     t16 = ar.pfs, 0, 0, 5, 0
        mov       t17 = brp
        .fframe   ExceptionFrameLength+0x10
        add       sp = -ExceptionFrameLength-0x10, sp
        ;;

        mov       t18 = ar.unat
        add       t3 = STACK_SCRATCH_AREA, sp
        ;;

        .savepsp  ar.unat, 0x10+ExceptionFrameLength-STACK_SCRATCH_AREA
        st8       [t3] = t18
        add       t0 = ExFltS19+0x10+STACK_SCRATCH_AREA, sp
        add       t1 = ExFltS18+0x10+STACK_SCRATCH_AREA, sp
        ;;

        .save.gf  0x0, 0xC0000
        stf.spill [t0] = fs19, ExFltS17-ExFltS19
        stf.spill [t1] = fs18, ExFltS16-ExFltS18
        ;;

        .save.gf  0x0, 0x30000
        stf.spill [t0] = fs17, ExFltS15-ExFltS17
        stf.spill [t1] = fs16, ExFltS14-ExFltS16
        mov       t10 = bs4
        ;;

        .save.gf  0x0, 0xC000
        stf.spill [t0] = fs15, ExFltS13-ExFltS15
        stf.spill [t1] = fs14, ExFltS12-ExFltS14
        mov       t11 = bs3
        ;;

        .save.gf  0x0, 0x3000
        stf.spill [t0] = fs13, ExFltS11-ExFltS13
        stf.spill [t1] = fs12, ExFltS10-ExFltS12
        mov       t12 = bs2
        ;;

        .save.gf  0x0, 0xC00
        stf.spill [t0] = fs11, ExFltS9-ExFltS11
        stf.spill [t1] = fs10, ExFltS8-ExFltS10
        mov       t13 = bs1
        ;;

        .save.gf  0x0, 0x300
        stf.spill [t0] = fs9, ExFltS7-ExFltS9
        stf.spill [t1] = fs8, ExFltS6-ExFltS8
        mov       t14 = bs0
        ;;

        .save.gf  0x0, 0xC0
        stf.spill [t0] = fs7, ExFltS5-ExFltS7
        stf.spill [t1] = fs6, ExFltS4-ExFltS6
        mov       t15 = ar.lc
        ;;

        .save.gf  0x0, 0x30
        stf.spill [t0] = fs5, ExFltS3-ExFltS5
        stf.spill [t1] = fs4, ExFltS2-ExFltS4
        ;;

        .save.f   0xC
        stf.spill [t0] = fs3, ExFltS1-ExFltS3         // save fs3
        stf.spill [t1] = fs2, ExFltS0-ExFltS2         // save fs2
        ;;

        .save.f   0x3
        stf.spill [t0] = fs1, ExBrS4-ExFltS1          // save fs1
        stf.spill [t1] = fs0, ExBrS3-ExFltS0          // save fs0
        ;;

        .save.b   0x18
        st8       [t0] = t10, ExBrS2-ExBrS4           // save bs4
        st8       [t1] = t11, ExBrS1-ExBrS3           // save bs3
        ;;

        .save.b   0x6
        st8       [t0] = t12, ExBrS0-ExBrS2           // save bs2
        st8       [t1] = t13, ExIntS2-ExBrS1          // save bs1
        ;;

        .save.b   0x1
        st8       [t0] = t14, ExIntS3-ExBrS0          // save bs0
        ;;

        .save.gf  0xC, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s3, ExIntS1-ExIntS3          // save s3
        .mem.offset 8,0
        st8.spill [t1] = s2, ExIntS0-ExIntS2          // save s2
        ;;

        .save.gf  0x3, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s1, ExApLC-ExIntS1           // save s1
        .mem.offset 8,0
        st8.spill [t1] = s0, ExApEC-ExIntS0           // save s0
        add       t2 = STACK_SCRATCH_AREA+8, sp
        ;;

        .savepsp  ar.pfs, ExceptionFrameLength-ExApEC-STACK_SCRATCH_AREA
        st8       [t1] = t16, ExIntNats-ExApEC
        mov       t4 = ar.unat                        // captured Nats of s0-s3
        ;;

        .savepsp  ar.lc, ExceptionFrameLength-ExApLC-STACK_SCRATCH_AREA
        st8       [t0] = t15
        .savepsp  @priunat, ExceptionFrameLength-ExIntNats-STACK_SCRATCH_AREA
        st8       [t1] = t4                           // save Nats of s0-s3
        ;;

        .savepsp  brp, 8+ExceptionFrameLength-STACK_SCRATCH_AREA
        st8       [t2] = t17

        PROLOGUE_END

        br.call.sptk brp = PspGetSetContextSpecialApcMain
        ;;

        add       out0 = 0x10+STACK_SCRATCH_AREA, sp
        br.call.sptk brp = KiRestoreExceptionFrame
        ;;

        add       t2 = STACK_SCRATCH_AREA+8, sp
        add       t3 = STACK_SCRATCH_AREA, sp
		add       t4 = ExApEC+STACK_SCRATCH_AREA+0x10, sp
        ;;

        ld8       t2 = [t2]
        ld8       t3 = [t3]
        ;;

        ld8       t4 = [t4]
        mov       ar.unat = t3
        mov       brp = t2
        ;;

        .restore
        add       sp = ExceptionFrameLength+0x10, sp
        mov       ar.pfs = t4
        br.ret.sptk brp

        NESTED_EXIT(PspGetSetContextSpecialApc)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\fileinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the File Information routines for Raw called by
    the dispatch driver.

Author:

    David Goebel     [DavidGoe]    13-May-1991

Revision History:

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawQueryInformation)
#pragma alloc_text(PAGE, RawSetInformation)
#endif

NTSTATUS
RawQueryInformation (
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine for querying file information, though only
    query current file position is supported.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the query


Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PFILE_POSITION_INFORMATION Buffer;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = &IrpSp->Parameters.QueryFile.Length;
    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  The only request that is valid for raw is to query file position.
    //

    if ( FileInformationClass == FilePositionInformation ) {

        //
        //  Make sure the buffer is large enough
        //

        if (*Length < sizeof(FILE_POSITION_INFORMATION)) {

            Irp->IoStatus.Information = 0;

            Status = STATUS_BUFFER_OVERFLOW;

        } else {

            //
            //  Get the current position found in the file object.
            //

            Buffer->CurrentByteOffset = IrpSp->FileObject->CurrentByteOffset;

            //
            //  Update the length, irp info, and status output variables
            //

            *Length -= sizeof( FILE_POSITION_INFORMATION );

            Irp->IoStatus.Information = sizeof( FILE_POSITION_INFORMATION );

            Status = STATUS_SUCCESS;
        }

    } else {

        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    RawCompleteRequest( Irp, Status );

    UNREFERENCED_PARAMETER( Vcb );

    return Status;
}

NTSTATUS
RawSetInformation (
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine for setting file information, though only
    setting current file position is supported.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the set


Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    FILE_INFORMATION_CLASS FileInformationClass;
    PFILE_POSITION_INFORMATION Buffer;
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;
    Buffer = (PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer;
    FileObject= IrpSp->FileObject;

    //
    //  The only request that is valid for raw is to set file position.
    //

    if ( FileInformationClass == FilePositionInformation ) {

        //
        //  Check that the new position we're supplied is aligned properly
        //  for the device.
        //

        PDEVICE_OBJECT DeviceObject;

        DeviceObject = IoGetRelatedDeviceObject( IrpSp->FileObject );

        if ((Buffer->CurrentByteOffset.LowPart & DeviceObject->AlignmentRequirement) != 0) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            //
            //  The input parameter is fine so set the current byte offset.
            //

            FileObject->CurrentByteOffset = Buffer->CurrentByteOffset;

            Status = STATUS_SUCCESS;
        }

    } else {

        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    RawCompleteRequest( Irp, Status );

    UNREFERENCED_PARAMETER( Vcb );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Raw called by the
    dispatch driver.

Author:

    David Goebel     [DavidGoe]    18-Mar-91

Revision History:

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawCreate)
#endif


NTSTATUS
RawCreate (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Open the volume.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the read

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    BOOLEAN DeleteVolume = FALSE;

    PAGED_CODE();

    //
    //  This is an open/create request.  The only valid operation that
    //  is supported by the RAW file system is if the caller:
    //
    //    o  Specifies the device itself (file name == ""),
    //    o  specifies that this is an OPEN operation,
    //    o  and does not ask to create a directory.
    //

    Status = KeWaitForSingleObject( &Vcb->Mutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
    ASSERT( NT_SUCCESS( Status ) );

    //
    // Don't allow any relative opens as well as opens with a filename. These opens have
    // only been checked for traverse access by the I/O manager.
    //
    if (((IrpSp->FileObject == NULL) || ((IrpSp->FileObject->FileName.Length == 0) &&
                                          IrpSp->FileObject->RelatedFileObject == NULL)) &&
        ((IrpSp->Parameters.Create.Options >> 24) == FILE_OPEN) &&
        ((IrpSp->Parameters.Create.Options & FILE_DIRECTORY_FILE) == 0)) {

        //
        //  If the volume is locked or dismounted we cannot open it again.
        //

        if ( FlagOn(Vcb->VcbState,  VCB_STATE_FLAG_LOCKED) ) {

            Status = STATUS_ACCESS_DENIED;
            Irp->IoStatus.Information = 0;

        } if ( FlagOn(Vcb->VcbState,  VCB_STATE_FLAG_DISMOUNTED) ) {

            Status = STATUS_VOLUME_DISMOUNTED;
            Irp->IoStatus.Information = 0;

        } else {

            //
            //  If the volume is already opened by someone then we need to check
            //  the share access
            //

            USHORT ShareAccess;
            ACCESS_MASK DesiredAccess;

            ShareAccess = IrpSp->Parameters.Create.ShareAccess;
            DesiredAccess = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;

            if ((Vcb->OpenCount > 0) &&
                !NT_SUCCESS(Status = IoCheckShareAccess( DesiredAccess,
                                                         ShareAccess,
                                                         IrpSp->FileObject,
                                                         &Vcb->ShareAccess,
                                                         TRUE ))) {

                Irp->IoStatus.Information = 0;

            } else {

                //
                //  This is a valid create.  Increment the "OpenCount" and
                //  stuff the Vpb into the file object.
                //

                if (Vcb->OpenCount == 0) {

                    IoSetShareAccess( DesiredAccess,
                                      ShareAccess,
                                      IrpSp->FileObject,
                                      &Vcb->ShareAccess );
                }

                Vcb->OpenCount += 1;

                IrpSp->FileObject->Vpb = Vcb->Vpb;

                Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = FILE_OPENED;

                IrpSp->FileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;
            }
        }

    } else {

        //
        //  Fail this I/O request since one of the above conditions was
        //  not met.
        //
//        KdPrint (("Failing raw open\n"));
//        ASSERT (FALSE);
        Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;
    }

    //
    //  If this was not successfull and this was the first open on the
    //  volume, we must implicitly dis-mount the volume.
    //

    if (!NT_SUCCESS(Status) && (Vcb->OpenCount == 0)) {

        DeleteVolume = RawCheckForDismount( Vcb, TRUE );
    }

    if (!DeleteVolume) {
        (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );
    }

    RawCompleteRequest( Irp, Status );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\cleanup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Raw called by the
    dispatch driver.

Author:

    David Goebel     [DavidGoe]    18-Mar-91

Revision History:

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawCleanup)
#endif


NTSTATUS
RawCleanup (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine for cleaning up a handle.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the read

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  This is a Cleanup operation.  All we have to do is deal with
    //  share access.
    //

    Status = KeWaitForSingleObject( &Vcb->Mutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
    ASSERT( NT_SUCCESS( Status ) );

    IoRemoveShareAccess( IrpSp->FileObject, &Vcb->ShareAccess );

    //
    //  If the volume has been dismounted then the close count should be one.
    //  we will let the volume dismount complete at this point if so.
    //

    if (FlagOn( Vcb->VcbState,  VCB_STATE_FLAG_DISMOUNTED )) {

        ASSERT( Vcb->OpenCount == 1 );

        //
        //  Float this Vcb and Vpb while we wait for the close.  
        //  We know the Vcb won't go away in this call because our
        //  reference keeps the OpenCount above zero.
        //

        RawCheckForDismount( Vcb, FALSE );
    }

    (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );

    RawCompleteRequest( Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\nodetype.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

--*/

#ifndef _NODETYPE_
#define _NODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)

#define RAW_NTC_VCB                      ((NODE_TYPE_CODE)0x0600)

typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\fsctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Raw called
    by the dispatch driver.

Author:

    David Goebel     [DavidGoe]    18-Mar-91

Revision History:

--*/

#include "RawProcs.h"

//
//  Local procedure prototypes
//

NTSTATUS
RawMountVolume (
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawVerifyVolume (
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb
    );

NTSTATUS
RawUserFsCtrl (
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawMountVolume)
#pragma alloc_text(PAGE, RawUserFsCtrl)
#pragma alloc_text(PAGE, RawFileSystemControl)
#endif


NTSTATUS
RawFileSystemControl (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine implements the FileSystem control operations

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the FileSystem control operation.

Return Value:

    NTSTATUS - The status for the IRP

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call an internal worker routine.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_USER_FS_REQUEST:

        Status = RawUserFsCtrl( IrpSp, Vcb );
        break;

    case IRP_MN_MOUNT_VOLUME:

        Status = RawMountVolume( IrpSp );
        break;

    case IRP_MN_VERIFY_VOLUME:

        Status = RawVerifyVolume( IrpSp, Vcb );
        break;

    default:

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    RawCompleteRequest( Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
RawMountVolume (
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine performs the mount volume operation.

Arguments:

    IrpSp - Supplies the IrpSp parameters to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PDEVICE_OBJECT DeviceObjectWeTalkTo;

    PVOLUME_DEVICE_OBJECT VolumeDeviceObject;

    PAGED_CODE();

    //
    //  Save some references to make our life a little easier
    //

    DeviceObjectWeTalkTo = IrpSp->Parameters.MountVolume.DeviceObject;

    //
    // A mount operation has been requested.  Create a
    // new device object to represent this volume.
    //

    Status = IoCreateDevice( IrpSp->DeviceObject->DriverObject,
                             sizeof(VOLUME_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT),
                             NULL,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             (PDEVICE_OBJECT *)&VolumeDeviceObject );

    if ( !NT_SUCCESS( Status ) ) {

        return Status;
    }

    //
    //  Our alignment requirement is the larger of the processor alignment requirement
    //  already in the volume device object and that in the DeviceObjectWeTalkTo
    //

    if (DeviceObjectWeTalkTo->AlignmentRequirement > VolumeDeviceObject->DeviceObject.AlignmentRequirement) {

        VolumeDeviceObject->DeviceObject.AlignmentRequirement = DeviceObjectWeTalkTo->AlignmentRequirement;
    }

    //
    // Set sector size to the same value as the DeviceObjectWeTalkTo.
    //

    VolumeDeviceObject->DeviceObject.SectorSize = DeviceObjectWeTalkTo->SectorSize;

    VolumeDeviceObject->DeviceObject.Flags |= DO_DIRECT_IO;

    //
    //  Initialize the Vcb for this volume
    //

    Status = RawInitializeVcb( &VolumeDeviceObject->Vcb,
                               IrpSp->Parameters.MountVolume.DeviceObject,
                               IrpSp->Parameters.MountVolume.Vpb );


    if ( !NT_SUCCESS( Status ) ) {

        //
        //  Unlike the other points of teardown we do not need to deref the target device
        //  a iosubsys will automatically do that for a failed mount
        //  

        IoDeleteDevice( (PDEVICE_OBJECT)VolumeDeviceObject );
        return Status;
    }

    //
    //  Finally, make it look as if the volume has been
    //  mounted.  This includes storing the
    //  address of this file system's device object (the one
    //  that was created to handle this volume) in the VPB so
    //  all requests are directed to this file system from
    //  now until the volume is initialized with a real file
    //  structure.
    //

    VolumeDeviceObject->Vcb.Vpb->DeviceObject = (PDEVICE_OBJECT)VolumeDeviceObject;
    VolumeDeviceObject->Vcb.Vpb->SerialNumber = 0xFFFFFFFF;
    VolumeDeviceObject->Vcb.Vpb->VolumeLabelLength = 0;

    VolumeDeviceObject->DeviceObject.Flags &= ~DO_DEVICE_INITIALIZING;
    VolumeDeviceObject->DeviceObject.StackSize = (UCHAR) (DeviceObjectWeTalkTo->StackSize + 1);

    {
        PFILE_OBJECT VolumeFileObject = NULL;

        //
        //  We need a file object to do the notification.
        //
        
        try {
            VolumeFileObject = IoCreateStreamFileObjectLite( NULL, &VolumeDeviceObject->DeviceObject );
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }

        if (!NT_SUCCESS(Status)) {
            IoDeleteDevice( (PDEVICE_OBJECT)VolumeDeviceObject );
            return Status;
        }

        //
        //  We need to bump the count up 2 now so that the close we do in a few lines
        //  doesn't make the Vcb go away now.
        //
        
        VolumeDeviceObject->Vcb.OpenCount += 2;
        FsRtlNotifyVolumeEvent( VolumeFileObject, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( VolumeFileObject );

        //
        //  Okay, the close is over, now we can safely decrement the open count again
       //  (back to 0) so the Vcb can go away when we're really done with it.
        //
        
        VolumeDeviceObject->Vcb.OpenCount -= 2;
    }
    
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
RawVerifyVolume (
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine verifies a volume.

Arguments:

    IrpSp - Supplies the IrpSp parameters to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    BOOLEAN DeleteVolume = FALSE;
    KIRQL   Irql;
    PVPB    vpb;
    BOOLEAN Mounted;

    //
    //  If the volume is somehow stale, dismount.  We must synchronize
    //  our inspection of the close count so we don't rip the volume up
    //  while racing with a close, for instance.  The VPB refcount drops
    //  *before* the close comes into the filesystem.
    //

    //
    // By this time its possible that the volume has been dismounted by
    // RawClose. So check if its mounted. If so, take a reference on the VPB
    // The reference on the VPB will prevent close from deleting the device.
    //

    IoAcquireVpbSpinLock(&Irql);

    Mounted = FALSE;
    vpb = IrpSp->Parameters.VerifyVolume.Vpb;
    if (vpb->Flags & VPB_MOUNTED) {
        vpb->ReferenceCount++;
        Mounted = TRUE;
    }

    IoReleaseVpbSpinLock(Irql);

    if (!Mounted) {
        return STATUS_WRONG_VOLUME;
    }

    Status = KeWaitForSingleObject( &Vcb->Mutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
    ASSERT( NT_SUCCESS( Status ) );

    //
    //  Since we ignore all verify errors from the disk driver itself,
    //  this request must have originated from a file system, thus
    //  since we weren't the originators, we're going to say this isn't
    //  our volume, and if the open count is zero, dismount the volume.
    //

    IoAcquireVpbSpinLock(&Irql);
    vpb->ReferenceCount--;
    IoReleaseVpbSpinLock(Irql);

    Vcb->Vpb->RealDevice->Flags &= ~DO_VERIFY_VOLUME;

    if (Vcb->OpenCount == 0) {

        DeleteVolume = RawCheckForDismount( Vcb, FALSE );
    }

    if (!DeleteVolume) {
        (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );
    }

    return STATUS_WRONG_VOLUME;
}



//
//  Local Support Routine
//

NTSTATUS
RawUserFsCtrl (
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    IrpSp - Supplies the IrpSp parameters to process

    Vcb - Supplies the volume we are working on.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    ULONG FsControlCode;
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;
    FileObject = IrpSp->FileObject;

    //
    //  Do pre-notification before entering the volume mutex so that we
    //  can be reentered by good threads cleaning up their resources.
    //

    switch (FsControlCode) {
        case FSCTL_LOCK_VOLUME:
            
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK );
            break;

        case FSCTL_DISMOUNT_VOLUME:

            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_DISMOUNT );
            break;

        default:
            break;
    }
    
    Status = KeWaitForSingleObject( &Vcb->Mutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
    ASSERT( NT_SUCCESS( Status ) );

    switch ( FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPLOCK_BREAK_NOTIFY:

        Status = STATUS_NOT_IMPLEMENTED;
        break;

    case FSCTL_LOCK_VOLUME:

        if ( !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_LOCKED) &&
             (Vcb->OpenCount == 1) ) {

            Vcb->VcbState |= VCB_STATE_FLAG_LOCKED;

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_ACCESS_DENIED;
        }

        break;

    case FSCTL_UNLOCK_VOLUME:

        if ( !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_LOCKED) ) {

            Status = STATUS_NOT_LOCKED;

        } else {

            Vcb->VcbState &= ~VCB_STATE_FLAG_LOCKED;

            Status = STATUS_SUCCESS;
        }

        break;

    case FSCTL_DISMOUNT_VOLUME:

        //
        //  Right now the logic in cleanup.c assumes that there can
        //  only be one handle on the volume if locked.  The code
        //  there needs to be fixed if forced dismounts are allowed.
        //

        if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_LOCKED)) {

            Vcb->VcbState |=  VCB_STATE_FLAG_DISMOUNTED;
            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_ACCESS_DENIED;
        }

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );

    //
    //  Now perform post-notification as required.
    //

    if (NT_SUCCESS( Status )) {
    
        switch ( FsControlCode ) {
            case FSCTL_UNLOCK_VOLUME:

                FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
                break;
            
            default:
                break;
        }
    
    } else {
        
        switch ( FsControlCode ) {
            case FSCTL_LOCK_VOLUME:
                
                FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK_FAILED );
                break;

            case FSCTL_DISMOUNT_VOLUME:

                FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_DISMOUNT_FAILED );
                break;

            default:
                break;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\close.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Raw called by the
    dispatch driver.

Author:

    David Goebel     [DavidGoe]    18-Mar-91

Revision History:

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawClose)
#endif

NTSTATUS
RawClose (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine for closing a volume.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the read

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    BOOLEAN DeleteVolume = FALSE;

    PAGED_CODE();

    //
    //  This is a close operation.  If it is the last one, dismount.
    //

    //
    // Skip stream files as they are unopened fileobjects.
    // This might be a close from IopInvalidateVolumesForDevice
    // 
    if (IrpSp->FileObject->Flags & FO_STREAM_FILE) {
        RawCompleteRequest( Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    Status = KeWaitForSingleObject( &Vcb->Mutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
    ASSERT( NT_SUCCESS( Status ) );

    Vcb->OpenCount -= 1;

    if (Vcb->OpenCount == 0) {

        DeleteVolume = RawCheckForDismount( Vcb, FALSE );
    }

    if (!DeleteVolume) {
        (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );
    }

    RawCompleteRequest( Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=raw

TARGETNAME=raw
TARGETTYPE=LIBRARY
TARGETPATH=obj

BUILD_PRODUCES=ntosraw$(NT_UP)

INCLUDES=..;..\..\inc

MSC_WARNING_LEVEL=/W4 /WX

SOURCES=..\Cleanup.c  \
        ..\Close.c    \
        ..\Create.c   \
        ..\FileInfo.c \
        ..\FsCtrl.c   \
        ..\StrucSup.c \
        ..\RawDisp.c  \
        ..\RawInit.c  \
        ..\ReadWrit.c \
        ..\VolInfo.c

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\rawprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RawProcs.h

Abstract:

    This module defines all of the globally used procedures in the Raw
    file system.

Author:

    David Goebel     [DavidGoe]    18-Mar-91

Revision History:

--*/

#ifndef _RAWPROCS_
#define _RAWPROCS_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses

#include <string.h>
#include <ntos.h>
#include <zwapi.h>
#include <FsRtl.h>
#include <ntdddisk.h>

#include "nodetype.h"
#include "RawStruc.h"


//
//  This is the main entry point to the Raw File system.
//

NTSTATUS
RawDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );


//
//  MAJOR FUNCTIONS
//
//  These routines are called by RawDispatch via the I/O system via the
//  dispatch table in the Driver Object.  If the status returned is not
//  STATUS_PENDING, the Irp will be complete with this status.
//

NTSTATUS
RawCleanup (                         //  implemented in Cleanup.c
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawClose (                           //  implemented in Close.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawCreate (                          //  implemented in Create.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawFileSystemControl (               //  implemented in FsCtrl.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawReadWriteDeviceControl (          //  implemented in ReadWrit.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawQueryInformation (                //  implemented in FileInfo.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawSetInformation (                  //  implemented in FileInfo.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RawQueryVolumeInformation (          //  implemented in VolInfo.c
    IN PVCB Vcb,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );


//
//  Miscellaneous support routines
//

//
//  Completion routine for read, write, and device control to deal with
//  verify issues.  Implemented in RawDisp.c
//

NTSTATUS
RawCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
//  In-memory structure support routines, implemented in StrucSup.c
//

NTSTATUS
RawInitializeVcb (
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb
    );

BOOLEAN
RawCheckForDismount (
    PVCB Vcb,
    BOOLEAN CalledFromCreate
    );

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define BooleanFlagOn(Flags,SingleFlag) (                          \
    ((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE) 
    
//
//  This macro just returns the particular flag if its set
//  

#define FlagOn(F,SF) ( \
    (((F) & (SF)))     \
)

    
//
//  This macro completes a request
//

#define RawCompleteRequest(IRP,STATUS) {           \
                                                   \
    (IRP)->IoStatus.Status = (STATUS);             \
                                                   \
    IoCompleteRequest( (IRP), IO_DISK_INCREMENT ); \
}

#endif // _RAWPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\strucsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StrucSup.c

Abstract:

    This module implements the Raw in-memory data structure manipulation
    routines

Author:

    David Goebel     [DavidGoe]    18-Mar-91

Revision History:

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawInitializeVcb)
#endif


NTSTATUS
RawInitializeVcb (
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb
    )

/*++

Routine Description:

    This routine initializes and inserts a new Vcb record into the in-memory
    data structure.  The Vcb record "hangs" off the end of the Volume device
    object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

    TargetDeviceObject - Supplies the address of the target device object to
        associate with the Vcb record.

    Vpb - Supplies the address of the Vpb to associate with the Vcb record.

Return Value:

    NTSTATUS for any errors

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  We start by first zeroing out all of the VCB, this will guarantee
    //  that any stale data is wiped clean
    //

    RtlZeroMemory( Vcb, sizeof(VCB) );

    //
    //  Set the proper node type code and node byte size
    //

    Vcb->NodeTypeCode = RAW_NTC_VCB;
    Vcb->NodeByteSize = sizeof(VCB);

    //
    //  Set the Target Device Object, Vpb, and Vcb State fields
    //

    //
    //  No need to take a extra reference on the Target Device object as
    //  IopMountVolume already has taken a reference.
    //

    Vcb->TargetDeviceObject = TargetDeviceObject;
    Vcb->Vpb = Vpb;

    //
    //  Initialize the Mutex.
    //

    KeInitializeMutex( &Vcb->Mutex, MUTEX_LEVEL_FILESYSTEM_RAW_VCB );

    //
    //  allocate the spare vpb for forced dismount
    //

    Vcb->SpareVpb = ExAllocatePoolWithTag( NonPagedPool, sizeof( VPB ), 'Raw ');
    if (Vcb->SpareVpb == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  and return to our caller
    //

    return Status;
}

BOOLEAN
RawCheckForDismount (
    PVCB Vcb,
    BOOLEAN CalledFromCreate
    )

/*++

Routine Description:

    This routine determines if a volume is ready for deletion.  It
    correctly synchronizes with creates en-route to the file system.
    On exit if the vcb is deleted the mutex is released
    
Arguments:

    Vcb - Supplies the volue to examine

    CalledFromCreate - Tells us if we should allow 0 or 1 in VpbRefCount

Return Value:

    BOOLEAN - TRUE if the volume was deleted, FALSE otherwise.

--*/

{

    KIRQL SavedIrql;
    ULONG ReferenceCount = 0;
    BOOLEAN DeleteVolume = FALSE;

    //
    //  We must enter with the vcb mutex acquired
    //  

    ASSERT( KeReadStateMutant( &Vcb->Mutex ) == 0 );

    IoAcquireVpbSpinLock( &SavedIrql );

    ReferenceCount = Vcb->Vpb->ReferenceCount;

    {
        PVPB Vpb;

        Vpb = Vcb->Vpb;

        //
        //  If a create is in progress on this volume, don't
        //  delete it.
        //

        if ( ReferenceCount != (ULONG)(CalledFromCreate ? 1 : 0) ) {

            //
            //  Cleanup the vpb on a forced dismount even if we can't delete the vcb if
            //  we haven't already done so
            //   

            if ((Vcb->SpareVpb != NULL) && 
                FlagOn( Vcb->VcbState,  VCB_STATE_FLAG_DISMOUNTED )) {

                //
                //  Setup the spare vpb and put it on the real device
                //  

                RtlZeroMemory( Vcb->SpareVpb, sizeof( VPB ) );

                Vcb->SpareVpb->Type = IO_TYPE_VPB;
                Vcb->SpareVpb->Size = sizeof( VPB );
                Vcb->SpareVpb->RealDevice = Vcb->Vpb->RealDevice;
                Vcb->SpareVpb->DeviceObject = NULL;
                Vcb->SpareVpb->Flags = FlagOn( Vcb->Vpb->Flags, VPB_REMOVE_PENDING );

                Vcb->Vpb->RealDevice->Vpb = Vcb->SpareVpb;

                //
                //  The spare vpb now belongs to the iosubsys and we own the original one
                //  

                Vcb->SpareVpb = NULL;
                Vcb->Vpb->Flags |=  VPB_PERSISTENT;

            }

            DeleteVolume = FALSE;

        } else {

            DeleteVolume = TRUE;

            if ( Vpb->RealDevice->Vpb == Vpb ) {

                Vpb->DeviceObject = NULL;

                Vpb->Flags &= ~VPB_MOUNTED;
            }
        }
    }
    IoReleaseVpbSpinLock( SavedIrql );

    if (DeleteVolume) {

        (VOID)KeReleaseMutex( &Vcb->Mutex, FALSE );

        //
        //  Free the spare vpb if we didn't use it or the original one if 
        //  we did use it and there are no more reference counts. Otherwise i/o
        //  subsystem still has a ref and will free the vpb itself
        // 

        if (Vcb->SpareVpb) {
            ExFreePool( Vcb->SpareVpb );
        } else if (ReferenceCount == 0) {
            ExFreePool( Vcb->Vpb );
        }
        
        ObDereferenceObject( Vcb->TargetDeviceObject );
        IoDeleteDevice( (PDEVICE_OBJECT)CONTAINING_RECORD( Vcb,
                                                           VOLUME_DEVICE_OBJECT,
                                                           Vcb));
    }
    
    return DeleteVolume;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\volinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the volume information routines for Raw called by
    the dispatch driver.

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

--*/

#include "RawProcs.h"

NTSTATUS
RawQueryFsVolumeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
RawQueryFsSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
RawQueryFsDeviceInfo (
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
RawQueryFsAttributeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawQueryVolumeInformation)
#pragma alloc_text(PAGE, RawQueryFsVolumeInfo)
#pragma alloc_text(PAGE, RawQueryFsSizeInfo)
#pragma alloc_text(PAGE, RawQueryFsDeviceInfo)
#pragma alloc_text(PAGE, RawQueryFsAttributeInfo)
#endif


NTSTATUS
RawQueryVolumeInformation (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine implements the NtQueryVolumeInformation API call.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp being processed.

    IrpSp - Supplies parameters describing the read

Return Value:

    NTSTATUS - The status for the Irp.

--*/

{
    NTSTATUS Status;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;
    FsInformationClass = IrpSp->Parameters.QueryVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Based on the information class we'll do different actions.  Each
    //  of the procedures that we're calling fills up the output buffer
    //  if possible and returns true if it successfully filled the buffer
    //  and false if it couldn't wait for any I/O to complete.
    //

    switch (FsInformationClass) {

    case FileFsVolumeInformation:

        Status = RawQueryFsVolumeInfo( Vcb, Buffer, &Length );
        break;

    case FileFsSizeInformation:

        Status = RawQueryFsSizeInfo( Vcb, Buffer, &Length );
        break;

    case FileFsDeviceInformation:

        Status = RawQueryFsDeviceInfo( Vcb, Buffer, &Length );
        break;

    case FileFsAttributeInformation:

        Status = RawQueryFsAttributeInfo( Vcb, Buffer, &Length );
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    //
    //  Set the information field to the number of bytes actually filled in,
    //  and complete the request.
    //

    Irp->IoStatus.Information = IrpSp->Parameters.QueryVolume.Length - Length;

    RawCompleteRequest( Irp, Status );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
RawQueryFsVolumeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Zero out the buffer, then extract and fill up the non zero fields.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_FS_VOLUME_INFORMATION) );

    Buffer->VolumeSerialNumber = Vcb->Vpb->SerialNumber;

    Buffer->SupportsObjects = FALSE;

    Buffer->VolumeLabelLength = 0;

    *Length -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel[0]);

    //
    //  Set our status and return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
RawQueryFsSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume size call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    PIRP Irp;
    KEVENT Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    PDEVICE_OBJECT RealDevice;

    DISK_GEOMETRY DiskGeometry;
    PARTITION_INFORMATION PartitionInformation;
    GET_LENGTH_INFORMATION GetLengthInformation;

    BOOLEAN DriveIsPartitioned;

    PAGED_CODE();

    //
    //  Make sure the buffer is large enough
    //

    if (*Length < sizeof(FILE_FS_SIZE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_SIZE_INFORMATION) );

    //
    //  Prepare for our device control below.  The device drivers only
    //  have to copy geometry and partition info from in-memory strucures,
    //  so it is OK to make these calls even when we can't wait.
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    RealDevice = Vcb->Vpb->RealDevice;

    //
    //  Query the disk geometry
    //

    Irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                         RealDevice,
                                         NULL,
                                         0,
                                         &DiskGeometry,
                                         sizeof(DISK_GEOMETRY),
                                         FALSE,
                                         &Event,
                                         &Iosb );

    if ( Irp == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( (Status = IoCallDriver( RealDevice, Irp )) == STATUS_PENDING ) {

        (VOID) KeWaitForSingleObject( &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER)NULL );

        Status = Iosb.Status;
    }

    //
    //  If this call didn't succeed, the drive hasn't even been low-level
    //  formatted, and thus geometry information is undefined.
    //

    if (!NT_SUCCESS( Status )) {

        *Length = 0;
        return Status;
    }

    //
    //  See if we have to check the partition information (floppy disks are
    //  the only type that can't have partitions )
    //

    if ( FlagOn( RealDevice->Characteristics, FILE_FLOPPY_DISKETTE )) {

        DriveIsPartitioned = FALSE;
        PartitionInformation.PartitionLength.QuadPart = 0;

    } else {

        //
        //  Query the length info.
        //

        KeResetEvent( &Event );

        Irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_LENGTH_INFO,
                                             RealDevice,
                                             NULL,
                                             0,
                                             &GetLengthInformation,
                                             sizeof(GET_LENGTH_INFORMATION),
                                             FALSE,
                                             &Event,
                                             &Iosb );

        if ( Irp == NULL ) {
           return STATUS_INSUFFICIENT_RESOURCES;
        }

        if ( (Status = IoCallDriver( RealDevice, Irp )) == STATUS_PENDING ) {

            (VOID) KeWaitForSingleObject( &Event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER)NULL );

            Status = Iosb.Status;
        }

        PartitionInformation.PartitionLength = GetLengthInformation.Length;

        if ( !NT_SUCCESS (Status) ) {

            //
            //  Query the partition table
            //

            KeResetEvent( &Event );

            Irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_PARTITION_INFO,
                                                 RealDevice,
                                                 NULL,
                                                 0,
                                                 &PartitionInformation,
                                                 sizeof(PARTITION_INFORMATION),
                                                 FALSE,
                                                 &Event,
                                                 &Iosb );

            if ( Irp == NULL ) {
               return STATUS_INSUFFICIENT_RESOURCES;
            }

            if ( (Status = IoCallDriver( RealDevice, Irp )) == STATUS_PENDING ) {

                (VOID) KeWaitForSingleObject( &Event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER)NULL );

                Status = Iosb.Status;
            }

            //
            //  If we get back invalid device request, the disk is not partitioned
            //

            if ( !NT_SUCCESS (Status) ) {

                DriveIsPartitioned = FALSE;

            } else {

                DriveIsPartitioned = TRUE;
            }

        } else {

            DriveIsPartitioned = TRUE;
        }
    }

    //
    //  Set the output buffer
    //

    Buffer->BytesPerSector = DiskGeometry.BytesPerSector;

    Buffer->SectorsPerAllocationUnit = 1;

    //
    //  Now, based on whether the disk is partitioned, compute the
    //  total number of sectors on this disk.
    //

    Buffer->TotalAllocationUnits =
    Buffer->AvailableAllocationUnits = ( DriveIsPartitioned == TRUE ) ?

        RtlExtendedLargeIntegerDivide( PartitionInformation.PartitionLength,
                                       DiskGeometry.BytesPerSector,
                                       NULL )

                                        :

        RtlExtendedIntegerMultiply( DiskGeometry.Cylinders,
                                    DiskGeometry.TracksPerCylinder *
                                    DiskGeometry.SectorsPerTrack );

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_SIZE_INFORMATION);

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
RawQueryFsDeviceInfo (
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume device call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Make sure the buffer is large enough
    //

    if (*Length < sizeof(FILE_FS_DEVICE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_DEVICE_INFORMATION) );

    //
    //  Set the output buffer
    //

    Buffer->DeviceType = FILE_DEVICE_DISK;

    Buffer->Characteristics = Vcb->TargetDeviceObject->Characteristics;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_DEVICE_INFORMATION);

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
RawQueryFsAttributeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume attribute call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    ULONG LengthUsed;

    UNREFERENCED_PARAMETER( Vcb );

    PAGED_CODE();

    //
    //  Check if the buffer we're given is long enough to contain "Raw"
    //

    LengthUsed = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0]) + 6;

    if (*Length < LengthUsed) {

        return STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Set the output buffer
    //

    Buffer->FileSystemAttributes       = 0;
    Buffer->MaximumComponentNameLength = 0;
    Buffer->FileSystemNameLength       = 6;
    RtlCopyMemory( &Buffer->FileSystemName[0], L"RAW", 6 );

    //
    //  Adjust the length variable
    //

    *Length -= LengthUsed;

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\rawstruc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RawStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Raw file system.

Author:

    David Goebel     [DavidGoe]    18-Mar-91

Revision History:

--*/

#ifndef _RAWSTRUC_
#define _RAWSTRUC_


//
//  The Vcb (Volume control Block) record corresponds to every volume mounted
//  by the file system.  This structure must be allocated from non-paged pool.
//

typedef struct _VCB {

    //
    //  The type and size of this record (must be RAW_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A pointer the device object passed in by the I/O system on a mount
    //  This is the target device object that the file system talks to when it
    //  needs to do any I/O (e.g., the disk stripper device object).
    //
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  A pointer to the VPB for the volume passed in by the I/O system on
    //  a mount.
    //

    PVPB Vpb;

    //
    //  A pointer to a spare Vpb used for explicit dismount
    // 

    PVPB SpareVpb;


    //
    //  The internal state of the device.
    //

    USHORT VcbState;

    //
    //  A mutex to control access to VcbState, OpenCount and ShareAccess
    //

    KMUTEX Mutex;

    //
    //  A count of the number of file objects that have opened the volume
    //  and their share access state.
    //

    CLONG OpenCount;

    SHARE_ACCESS ShareAccess;

    //
    //  Information about the disk geometry
    //

    ULONG BytesPerSector;

    LARGE_INTEGER SectorsOnDisk;

} VCB;
typedef VCB *PVCB;

#define VCB_STATE_FLAG_LOCKED            (0x0001)
#define VCB_STATE_FLAG_DISMOUNTED        (0x0002)

//
//  The Volume Device Object is an I/O system device object with a
//  VCB record appended to the end.  There are multiple of these
//  records, one for every mounted volume, and are created during
//  a volume mount operation.
//

typedef struct _VOLUME_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} VOLUME_DEVICE_OBJECT;
typedef VOLUME_DEVICE_OBJECT *PVOLUME_DEVICE_OBJECT;

#endif // _RAWSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\readwrit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ReadWrit.c

Abstract:

    This module implements the File Read and Write routines called by the
    dispatch driver.

Author:

    David Goebel      [DavidGoe]      28-Feb-1991

Revision History:

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawReadWriteDeviceControl)
#endif

NTSTATUS
RawReadWriteDeviceControl (
    IN PVCB Vcb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the a common routine for both reading and writing a volume.

Arguments:

    Vcb - Supplies the volume being queried.

    Irp - Supplies the Irp to process

    IrpSp - Supplies parameters describing the read or write

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION NextIrpSp;
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  If this was for a zero byte read or write transfer, just complete
    //  it with success.
    //

    if (((IrpSp->MajorFunction == IRP_MJ_READ) ||
         (IrpSp->MajorFunction == IRP_MJ_WRITE)) &&
        (IrpSp->Parameters.Read.Length == 0)) {

        RawCompleteRequest( Irp, STATUS_SUCCESS );

        return STATUS_SUCCESS;
    }

    //
    //  This is a very simple operation.  Simply forward the
    //  request to the device driver since exact blocks are
    //  being read and return whatever status was given.
    //
    //  Get the next stack location, and copy over the stack location
    //

    NextIrpSp = IoGetNextIrpStackLocation( Irp );

    *NextIrpSp = *IrpSp;

    //
    //  Prohibit verifies all together.
    //

    NextIrpSp->Flags |= SL_OVERRIDE_VERIFY_VOLUME;

    //
    //  Set up the completion routine
    //

    IoSetCompletionRoutine( Irp,
                            RawCompletionRoutine,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\rawinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RawInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for Raw

Author:

    David Goebel     [DavidGoe]    18-Mar-91

Environment:

    Kernel mode

Revision History:

--*/

#include "RawProcs.h"
#include <zwapi.h>

NTSTATUS
RawInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
RawUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
RawShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, RawInitialize)
#pragma alloc_text(PAGE, RawUnload)
#pragma alloc_text(PAGE, RawShutdown)
#endif
PDEVICE_OBJECT RawDeviceCdRomObject;
PDEVICE_OBJECT RawDeviceTapeObject;
PDEVICE_OBJECT RawDeviceDiskObject;


NTSTATUS
RawInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Raw file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING NameString;

    UNREFERENCED_PARAMETER (RegistryPath);

    //
    //  First create a device object for the Disk file system queue
    //

    RtlInitUnicodeString( &NameString, L"\\Device\\RawDisk" );
    Status = IoCreateDevice( DriverObject,
                             0L,
                             &NameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &RawDeviceDiskObject );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    DriverObject->DriverUnload = RawUnload;
    //
    //  Now create one for the CD ROM file system queue
    //

    RtlInitUnicodeString( &NameString, L"\\Device\\RawCdRom" );
    Status = IoCreateDevice( DriverObject,
                             0L,
                             &NameString,
                             FILE_DEVICE_CD_ROM_FILE_SYSTEM,
                             0,
                             FALSE,
                             &RawDeviceCdRomObject );
    if (!NT_SUCCESS( Status )) {
        IoDeleteDevice (RawDeviceDiskObject);
        return Status;
    }

    //
    //  And now create one for the Tape file system queue
    //

    RtlInitUnicodeString( &NameString, L"\\Device\\RawTape" );
    Status = IoCreateDevice( DriverObject,
                             0L,
                             &NameString,
                             FILE_DEVICE_TAPE_FILE_SYSTEM,
                             0,
                             FALSE,
                             &RawDeviceTapeObject );
    if (!NT_SUCCESS( Status )) {
        IoDeleteDevice (RawDeviceCdRomObject);
        IoDeleteDevice (RawDeviceDiskObject);
        return Status;
    }

    //
    // Register a shutdown handler to enable us to unregister the file system objects
    //
    Status = IoRegisterShutdownNotification (RawDeviceTapeObject);
    if (!NT_SUCCESS( Status )) {
        IoDeleteDevice (RawDeviceTapeObject);
        IoDeleteDevice (RawDeviceCdRomObject);
        IoDeleteDevice (RawDeviceDiskObject);
        return Status;
    }
    //
    //  Raw does direct IO
    //

    RawDeviceDiskObject->Flags |= DO_DIRECT_IO;
    RawDeviceCdRomObject->Flags |= DO_DIRECT_IO;
    RawDeviceTapeObject->Flags |= DO_DIRECT_IO;

    //
    //  Initialize the driver object with this driver's entry points.  Note
    //  that only a limited capability is supported by the raw file system.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                   =
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                  =
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                    =
    DriverObject->MajorFunction[IRP_MJ_READ]                     =
    DriverObject->MajorFunction[IRP_MJ_WRITE]                    =
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]        =
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]          =
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] =
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                  =
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]      =
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]           =
    DriverObject->MajorFunction[IRP_MJ_PNP]                      =

                                                (PDRIVER_DISPATCH)RawDispatch;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN]                 = RawShutdown;


    //
    // Finally, register this file system in the system.
    //

    IoRegisterFileSystem( RawDeviceDiskObject );
    IoRegisterFileSystem( RawDeviceCdRomObject );
    IoRegisterFileSystem( RawDeviceTapeObject );
    ObReferenceObject (RawDeviceDiskObject);
    ObReferenceObject (RawDeviceCdRomObject);
    ObReferenceObject (RawDeviceTapeObject);

    //
    //  And return to our caller
    //

    return( STATUS_SUCCESS );
}

NTSTATUS
RawShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Unregister the file system objects so we can unload
    //
    IoUnregisterFileSystem (RawDeviceDiskObject);
    IoUnregisterFileSystem (RawDeviceCdRomObject);
    IoUnregisterFileSystem (RawDeviceTapeObject);

    IoDeleteDevice (RawDeviceTapeObject);
    IoDeleteDevice (RawDeviceCdRomObject);
    IoDeleteDevice (RawDeviceDiskObject);

    RawCompleteRequest( Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


VOID
RawUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This is the unload routine for the Raw file system

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER (DriverObject);

    ObDereferenceObject (RawDeviceTapeObject);
    ObDereferenceObject (RawDeviceCdRomObject);
    ObDereferenceObject (RawDeviceDiskObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\raw\rawdisp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RawDisp.c

Abstract:

    This module is the main entry point for all major function codes.
    It is responsible for dispatching the request to the appropriate
    routine.

Author:

    David Goebel      [DavidGoe]      28-Feb-1991

Revision History:

--*/

#include "RawProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RawDispatch)
#endif


NTSTATUS
RawDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Dispatch the request to the appropriate function.  It is the worker
    function's responsibility to appropriately complete the IRP.

Arguments:

    VolumeDeviceObject - Supplies the volume device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the IRP

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PVCB Vcb;

    PAGED_CODE();

    //
    //  Get a pointer to the current stack location.  This location contains
    //  the function codes and parameters for this particular request.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Check for operations associated with our FileSystemDeviceObjects
    //  as opposed to our VolumeDeviceObjects.  Only mount is allowed to
    //  continue through the normal dispatch in this case.
    //

    if ((((PDEVICE_OBJECT)VolumeDeviceObject)->Size == sizeof(DEVICE_OBJECT)) &&
        !((IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
          (IrpSp->MinorFunction == IRP_MN_MOUNT_VOLUME))) {

        if ((IrpSp->MajorFunction == IRP_MJ_CREATE) ||
            (IrpSp->MajorFunction == IRP_MJ_CLEANUP) ||
            (IrpSp->MajorFunction == IRP_MJ_CLOSE)) {

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_INVALID_DEVICE_REQUEST;
        }

        RawCompleteRequest( Irp, Status );

        return Status;
    }

    FsRtlEnterFileSystem();

    //
    //  Get a pointer to the Vcb.  Note that is we are mount a volume this
    //  pointer will not have meaning, but that is OK since we will not
    //  use it in that case.
    //

    Vcb = &VolumeDeviceObject->Vcb;

    //
    //  Case on the function that is being performed by the requestor.  We
    //  should only see expected requests since we filled the dispatch table
    //  by hand.
    //

    try {

        switch ( IrpSp->MajorFunction ) {

            case IRP_MJ_CLEANUP:

                Status = RawCleanup( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_CLOSE:

                Status = RawClose( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_CREATE:

                Status = RawCreate( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_FILE_SYSTEM_CONTROL:

                Status = RawFileSystemControl( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_PNP: 

                if(IrpSp->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE) {
                    Status = STATUS_DEVICE_BUSY;
                    RawCompleteRequest(Irp, Status);
                    break;
                } 

            case IRP_MJ_READ:
            case IRP_MJ_WRITE:
            case IRP_MJ_DEVICE_CONTROL:

                Status = RawReadWriteDeviceControl( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_QUERY_INFORMATION:

                Status = RawQueryInformation( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_SET_INFORMATION:

                Status = RawSetInformation( Vcb, Irp, IrpSp );
                break;

            case IRP_MJ_QUERY_VOLUME_INFORMATION:

                Status = RawQueryVolumeInformation( Vcb, Irp, IrpSp );
                break;

            default:

                //
                //  We should never get a request we don't expect.
                //

                KdPrint(("Raw: Illegal Irp major function code 0x%x.\n", IrpSp->MajorFunction));
                KeBugCheckEx( FILE_SYSTEM, 0, 0, 0, 0 );
        }

    } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

        //
        //  No routine we call should ever generate an exception
        //

        Status = GetExceptionCode();

        KdPrint(("Raw: Unexpected excpetion %X.\n", Status));
    }

    //
    //  And return to our caller
    //

    FsRtlExitFileSystem();

    return Status;
}

//
//  Completion routine for read, write, and device control to deal with
//  verify issues.  Implemented in RawDisp.c
//

NTSTATUS
RawCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Simply update the file pointer context in the file object if we
    //  were successful and this was a synrhonous read or write.
    //

    if (((IrpSp->MajorFunction == IRP_MJ_READ) ||
         (IrpSp->MajorFunction == IRP_MJ_WRITE)) &&
        (IrpSp->FileObject != NULL) &&
        FlagOn(IrpSp->FileObject->Flags, FO_SYNCHRONOUS_IO) &&
        NT_SUCCESS(Irp->IoStatus.Status)) {

        IrpSp->FileObject->CurrentByteOffset.QuadPart =
            IrpSp->FileObject->CurrentByteOffset.QuadPart +
            Irp->IoStatus.Information;
    }

    //
    //  If IoCallDriver returned PENDING, mark our stack location
    //  with pending.
    //

    if ( Irp->PendingReturned ) {

        IoMarkIrpPending( Irp );
    }

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Context );

    return STATUS_SUCCESS;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\add2stra.c ===
#undef UNICODE
#undef _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <stdio.h>
#include <tchar.h>

#define RtlIpv6AddressToStringT RtlIpv6AddressToStringA
#define RtlIpv4AddressToStringT RtlIpv4AddressToStringA
#define RtlIpv6AddressToStringExT RtlIpv6AddressToStringExA
#define RtlIpv4AddressToStringExT RtlIpv4AddressToStringExA

#include "add2strt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\add2strw.c ===
#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <stdio.h>
#include <tchar.h>

#define RtlIpv4AddressToStringT RtlIpv4AddressToStringW
#define RtlIpv6AddressToStringT RtlIpv6AddressToStringW
#define RtlIpv4AddressToStringExT RtlIpv4AddressToStringExW
#define RtlIpv6AddressToStringExT RtlIpv6AddressToStringExW

#include "add2strt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\add2strt.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    add2strt.h

Abstract:

    Code for IP address-to-string translation routines.

Author:

    Dave Thaler (dthaler)   3-28-2001

Revision History:

    IPv6 conversion code originally by Rich Draves (richdr)

--*/

struct in6_addr {
    union {
        UCHAR Byte[16];
        USHORT Word[8];
    } u;
};
#define s6_bytes   u.Byte
#define s6_words   u.Word

struct in_addr {
        union {
                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { USHORT s_w1,s_w2; } S_un_w;
                ULONG S_addr;
        } S_un;
};
#define s_addr  S_un.S_addr
#define AF_INET 2
#define AF_INET6 23
#define INET_ADDRSTRLEN  22
#define INET6_ADDRSTRLEN 65

LPTSTR
RtlIpv6AddressToStringT(
    IN const struct in6_addr *Addr,
    OUT LPTSTR S
    )

/*++

Routine Description:

    Generates an IPv6 string literal corresponding to the address Addr.
    The shortened canonical forms are used (RFC 1884 etc).
    The basic string representation consists of 8 hex numbers
    separated by colons, with a couple embellishments:
    - a string of zero numbers (at most one) is replaced
    with a double-colon.
    - the last 32 bits are represented in IPv4-style dotted-octet notation
    if the address is a v4-compatible or ISATAP address.

    For example,
        ::
        ::1
        ::157.56.138.30
        ::ffff:156.56.136.75
        ff01::
        ff02::2
        0:1:2:3:4:5:6:7

Arguments:

    S - Receives a pointer to the buffer in which to place the
        string literal.

    Addr - Receives the IPv6 address.

Return Value:

    Pointer to the null byte at the end of the string inserted.
    This can be used by the caller to easily append more information.

--*/

{
    int maxFirst, maxLast;
    int curFirst, curLast;
    int i;
    int endHex = 8;

    // Check for IPv6-compatible, IPv4-mapped, and IPv4-translated
    // addresses
    if ((Addr->s6_words[0] == 0) && (Addr->s6_words[1] == 0) &&
        (Addr->s6_words[2] == 0) && (Addr->s6_words[3] == 0) &&
        (Addr->s6_words[6] != 0)) {
        if ((Addr->s6_words[4] == 0) &&
             ((Addr->s6_words[5] == 0) || (Addr->s6_words[5] == 0xffff)))
        {
            // compatible or mapped
            S += _stprintf(S, _T("::%hs%u.%u.%u.%u"),
                           Addr->s6_words[5] == 0 ? "" : "ffff:",
                           Addr->s6_bytes[12], Addr->s6_bytes[13],
                           Addr->s6_bytes[14], Addr->s6_bytes[15]);
            return S;
        }
        else if ((Addr->s6_words[4] == 0xffff) && (Addr->s6_words[5] == 0)) {
            // translated
            S += _stprintf(S, _T("::ffff:0:%u.%u.%u.%u"),
                           Addr->s6_bytes[12], Addr->s6_bytes[13],
                           Addr->s6_bytes[14], Addr->s6_bytes[15]);
            return S;
        }
    }


    // Find largest contiguous substring of zeroes
    // A substring is [First, Last), so it's empty if First == Last.

    maxFirst = maxLast = 0;
    curFirst = curLast = 0;

    // ISATAP EUI64 starts with 00005EFE (or 02005EFE)...
    if (((Addr->s6_words[4] & 0xfffd) == 0) && (Addr->s6_words[5] == 0xfe5e)) {
        endHex = 6;
    }

    for (i = 0; i < endHex; i++) {

        if (Addr->s6_words[i] == 0) {
            // Extend current substring
            curLast = i+1;

            // Check if current is now largest
            if (curLast - curFirst > maxLast - maxFirst) {

                maxFirst = curFirst;
                maxLast = curLast;
            }
        }
        else {
            // Start a new substring
            curFirst = curLast = i+1;
        }
    }

    // Ignore a substring of length 1.
    if (maxLast - maxFirst <= 1)
        maxFirst = maxLast = 0;

        // Write colon-separated words.
        // A double-colon takes the place of the longest string of zeroes.
        // All zeroes is just "::".

    for (i = 0; i < endHex; i++) {

        // Skip over string of zeroes
        if ((maxFirst <= i) && (i < maxLast)) {

            S += _stprintf(S, _T("::"));
            i = maxLast-1;
            continue;
        }

        // Need colon separator if not at beginning
        if ((i != 0) && (i != maxLast))
            S += _stprintf(S, _T(":"));

        S += _stprintf(S, _T("%x"), RtlUshortByteSwap(Addr->s6_words[i]));
    }

    if (endHex < 8) {
        S += _stprintf(S, _T(":%u.%u.%u.%u"),
                       Addr->s6_bytes[12], Addr->s6_bytes[13],
                       Addr->s6_bytes[14], Addr->s6_bytes[15]);
    }

    return S;
}

NTSTATUS
RtlIpv6AddressToStringExT(
    IN const struct in6_addr *Address,
    IN ULONG ScopeId,
    IN USHORT Port,
    OUT LPTSTR AddressString,
    IN OUT PULONG AddressStringLength
    )

/*++

Routine Description:

    This is the extension routine which handles a full address conversion
    including address, scopeid and port (scopeid and port are optional).

Arguments:

    Address - The address part to be translated.

    ScopeId - The Scope ID of the address (optional).

    Port - The port number of the address (optional). 
           Port is in network byte order.

    AddressString - Pointer to output buffer where we will fill in address string.

    AddressStringLength - For input, it is the length of the input buffer; for 
                          output it is the length we actual returned.
Return Value:

    STATUS_SUCCESS if the operation is successful, error code otherwise.

--*/
{
    TCHAR String[INET6_ADDRSTRLEN];
    LPTSTR S;
    ULONG Length;
    
    if ((Address == NULL) ||
        (AddressString == NULL) ||
        (AddressStringLength == NULL)) {

        return STATUS_INVALID_PARAMETER;
    }
    S = String;
    if (Port) {
        S += _stprintf(S, _T("["));
    }

    //
    // Now translate this address.
    //
    S = RtlIpv6AddressToStringT(Address, S);
    if (ScopeId != 0) {
        S += _stprintf(S, _T("%%%u"), ScopeId);
    }
    if (Port != 0) {
        S += _stprintf(S, _T("]:%u"), RtlUshortByteSwap(Port));
    }
    Length = (ULONG)(S - String + 1);
    if (*AddressStringLength < Length) {
        //
        // Before return, tell the caller how big 
        // the buffer we need.
        //
        *AddressStringLength = Length;
        return STATUS_INVALID_PARAMETER;
    }
    *AddressStringLength = Length;
    RtlCopyMemory(AddressString, String, Length * sizeof(TCHAR));
    return STATUS_SUCCESS;

}
    

LPTSTR
RtlIpv4AddressToStringT(
    IN const struct in_addr *Addr,
    OUT LPTSTR S
    )

/*++

Routine Description:

    Generates an IPv4 string literal corresponding to the address Addr.

Arguments:

    S - Receives a pointer to the buffer in which to place the
        string literal.

    Addr - Receives the IPv4 address.

Return Value:

    Pointer to the null byte at the end of the string inserted.
    This can be used by the caller to easily append more information.

--*/

{
    S += _stprintf(S, _T("%u.%u.%u.%u"),
                  ( Addr->s_addr >>  0 ) & 0xFF,
                  ( Addr->s_addr >>  8 ) & 0xFF,
                  ( Addr->s_addr >> 16 ) & 0xFF,
                  ( Addr->s_addr >> 24 ) & 0xFF );

    return S;
}


NTSTATUS
RtlIpv4AddressToStringExT(
    IN const struct in_addr *Address,
    IN USHORT Port,
    OUT LPTSTR AddressString,
    IN OUT PULONG AddressStringLength
    )

/*++

Routine Description:

    This is the extension routine which handles a full address conversion
    including address and port (port is optional).
    
Arguments:

    Address - The address part to translate.

    Port - Port number if there is any, otherwise 0. Port is in network 
           byte order. 

    AddressString - Receives the formatted address string.
    
    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    STATUS_SUCCESS if the operation is successful, error code otherwise.

--*/

{

    TCHAR String[INET_ADDRSTRLEN];
    LPTSTR S;
    ULONG Length;

    //
    // Quick sanity checks.
    //
    if ((Address == NULL) ||
        (AddressString == NULL) ||
        (AddressStringLength == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }
    S = String;

    //
    // Now translate this address.
    //
    S = RtlIpv4AddressToStringT(Address, S);
    if (Port != 0) {
        S += _stprintf(S, _T(":%u"), RtlUshortByteSwap(Port));
    }
    Length = (ULONG)(S - String + 1);
    if (*AddressStringLength < Length) {
        //
        // Before return, tell the caller how big
        // the buffer we need. 
        //
        *AddressStringLength = Length;
        return STATUS_INVALID_PARAMETER;
    }
    RtlCopyMemory(AddressString, String, Length * sizeof(TCHAR));
    *AddressStringLength = Length;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\assert.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    assert.c

Abstract:

    This module implements the RtlAssert function that is referenced by the
    debugging version of the ASSERT macro defined in NTDEF.H

Author:

    Steve Wood (stevewo) 03-Oct-1989

Revision History:

    Jay Krell (JayKrell) November 2000
        added RtlAssert2, support for __FUNCTION__ (lost the change to ntrtl.w, will reapply later)
        added break Once instead of the usual dumb Break repeatedly
        March 2002 removed RtlAssert2
--*/

#include <nt.h>
#include <ntrtl.h>
#include <zwapi.h>

//
// RtlAssert is not called unless the caller is compiled with DBG non-zero
// therefore it does no harm to always have this routine in the kernel.
// This allows checked drivers to be thrown on the system and have their
// asserts be meaningful.
//

#define RTL_ASSERT_ALWAYS_ENABLED 1

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

#undef RtlAssert

typedef CONST CHAR * PCSTR;

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID VoidFailedAssertion,
    PVOID VoidFileName,
    ULONG LineNumber,
    PCHAR MutableMessage
    )
{
#if DBG || RTL_ASSERT_ALWAYS_ENABLED
    char Response[ 2 ];

    CONST PCSTR FailedAssertion = (PCSTR)VoidFailedAssertion;
    CONST PCSTR FileName = (PCSTR)VoidFileName;
    CONST PCSTR Message  = (PCSTR)MutableMessage;

#ifndef BLDR_KERNEL_RUNTIME
    CONTEXT Context;

    RtlCaptureContext( &Context );
#endif

    while (TRUE) {
        DbgPrint( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );
        DbgPrompt( "Break repeatedly, break Once, Ignore, terminate Process, or terminate Thread (boipt)? ",
                   Response,
                   sizeof( Response )
                 );
        switch (Response[0]) {
            case 'B':
            case 'b':
            case 'O':
            case 'o':
#ifndef BLDR_KERNEL_RUNTIME
                DbgPrint( "Execute '.cxr %p' to dump context\n", &Context);
#endif
                DbgBreakPoint();
                if (Response[0] == 'o' || Response[0] == 'O')
                    return;
                break;

            case 'I':
            case 'i':
                return;

            case 'P':
            case 'p':
                ZwTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
                break;

            case 'T':
            case 't':
                ZwTerminateThread( NtCurrentThread(), STATUS_UNSUCCESSFUL );
                break;
            }
        }

    DbgBreakPoint();
    ZwTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
#endif
}

#ifdef _X86_
#pragma optimize("", on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\atom.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    atom.c

Abstract:

    This file contains the common code to implement atom tables.  It is called
    by both the user mode Win32 Atom API functions (Local/GlobalxxxAtom) and
    by the kernel mode window manager code to access global atoms.

Author:

    Steve Wood (stevewo) 26-Oct-1990

Revision History:

--*/

#include "ntrtlp.h"
#include "atom.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
PVOID
RtlpAllocateAtom(
    IN ULONG NumberOfBytes,
    IN ULONG Tag
    );
void
RtlpFreeAtom(
    IN PVOID p
    );
void
RtlpInitializeLockAtomTable(
    IN OUT PRTL_ATOM_TABLE AtomTable
    );
BOOLEAN
RtlpLockAtomTable(
    IN PRTL_ATOM_TABLE AtomTable
    );
void
RtlpUnlockAtomTable(
    IN PRTL_ATOM_TABLE AtomTable
    );
void
RtlpDestroyLockAtomTable(
    IN OUT PRTL_ATOM_TABLE AtomTable
    );
BOOLEAN
RtlpInitializeHandleTableForAtomTable(
    PRTL_ATOM_TABLE AtomTable
    );
void
RtlpDestroyHandleTableForAtomTable(
    PRTL_ATOM_TABLE AtomTable
    );
PRTL_ATOM_TABLE_ENTRY
RtlpAtomMapAtomToHandleEntry(
    IN PRTL_ATOM_TABLE AtomTable,
    IN ULONG HandleIndex
    );
BOOLEAN
RtlpCreateHandleForAtom(
    PRTL_ATOM_TABLE p,
    PRTL_ATOM_TABLE_ENTRY a
    );
void
RtlpFreeHandleForAtom(
    PRTL_ATOM_TABLE p,
    PRTL_ATOM_TABLE_ENTRY a
    );
BOOLEAN
RtlpGetIntegerAtom(
    PWSTR Name,
    PRTL_ATOM Atom OPTIONAL
    );
PRTL_ATOM_TABLE_ENTRY
RtlpHashStringToAtom(
    IN PRTL_ATOM_TABLE p,
    IN PWSTR Name,
    OUT PRTL_ATOM_TABLE_ENTRY **PreviousAtom OPTIONAL,
    OUT PULONG NameLength
    );
#pragma alloc_text(PAGE,RtlpAllocateAtom)
#pragma alloc_text(PAGE,RtlpFreeAtom)
#pragma alloc_text(PAGE,RtlpInitializeLockAtomTable)
#pragma alloc_text(PAGE,RtlInitializeAtomPackage)
#pragma alloc_text(PAGE,RtlpLockAtomTable)
#pragma alloc_text(PAGE,RtlpUnlockAtomTable)
#pragma alloc_text(PAGE,RtlpDestroyLockAtomTable)
#pragma alloc_text(PAGE,RtlpInitializeHandleTableForAtomTable)
#pragma alloc_text(PAGE,RtlpDestroyHandleTableForAtomTable)
#pragma alloc_text(PAGE,RtlpAtomMapAtomToHandleEntry)
#pragma alloc_text(PAGE,RtlpCreateHandleForAtom)
#pragma alloc_text(PAGE,RtlpFreeHandleForAtom)
#pragma alloc_text(PAGE,RtlInitializeAtomPackage)
#pragma alloc_text(PAGE,RtlCreateAtomTable)
#pragma alloc_text(PAGE,RtlDestroyAtomTable)
#pragma alloc_text(PAGE,RtlEmptyAtomTable)
#pragma alloc_text(PAGE,RtlpGetIntegerAtom)
#pragma alloc_text(PAGE,RtlpHashStringToAtom)
#pragma alloc_text(PAGE,RtlAddAtomToAtomTable)
#pragma alloc_text(PAGE,RtlLookupAtomInAtomTable)
#pragma alloc_text(PAGE,RtlDeleteAtomFromAtomTable)
#pragma alloc_text(PAGE,RtlPinAtomInAtomTable)
#pragma alloc_text(PAGE,RtlQueryAtomInAtomTable)
#pragma alloc_text(PAGE,RtlQueryAtomsInAtomTable)
#endif

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma data_seg("PAGEDATA")
#endif

ULONG RtlpAtomAllocateTag;

#if defined(NTOS_KERNEL_RUNTIME)
typedef struct _RTLP_ATOM_QUOTA {
    PEPROCESS_QUOTA_BLOCK QuotaBlock;
    SIZE_T PagedAmount;
} RTLP_ATOM_QUOTA, *PRTLP_ATOM_QUOTA;

#endif

PVOID
RtlpAllocateAtom(
    IN ULONG NumberOfBytes,
    IN ULONG Tag
    )
{
#if defined(NTOS_KERNEL_RUNTIME)
    PRTLP_ATOM_QUOTA AllocatedBlock;

    NumberOfBytes += sizeof(RTLP_ATOM_QUOTA);

    AllocatedBlock = ExAllocatePoolWithTag( PagedPool,
                                            NumberOfBytes,
                                            Tag );
    if (AllocatedBlock) {
        AllocatedBlock->QuotaBlock
            = PsChargeSharedPoolQuota( PsGetCurrentProcess(),
                                       NumberOfBytes,
                                       0 );
        if (! AllocatedBlock->QuotaBlock) {
            ExFreePoolWithTag( AllocatedBlock, Tag );
            AllocatedBlock = NULL;
        } else {
            AllocatedBlock->PagedAmount = NumberOfBytes;
            AllocatedBlock++;
        }
    }

    return AllocatedBlock;
#else
    return RtlAllocateHeap( RtlProcessHeap(),
                            RtlpAtomAllocateTag,
                            NumberOfBytes );
#endif
}


void
RtlpFreeAtom(
    IN PVOID p
    )
{
#if defined(NTOS_KERNEL_RUNTIME)
    PRTLP_ATOM_QUOTA AllocatedBlock = (PRTLP_ATOM_QUOTA) p;

    ASSERT( AllocatedBlock );
    AllocatedBlock--;
    ASSERT( AllocatedBlock );
    ASSERT( AllocatedBlock->QuotaBlock );
    ASSERT( AllocatedBlock->PagedAmount );
    PsReturnSharedPoolQuota( AllocatedBlock->QuotaBlock,
                             AllocatedBlock->PagedAmount,
                             0 );
    
    ExFreePool( AllocatedBlock );
#else
    RtlFreeHeap( RtlProcessHeap(), 0, p );
#endif
    return;
}


void
RtlpInitializeLockAtomTable(
    IN OUT PRTL_ATOM_TABLE AtomTable
    )
{
#if defined(NTOS_KERNEL_RUNTIME)
//    ExInitializeFastMutex( &AtomTable->FastMutex );
    ExInitializePushLock( &AtomTable->PushLock );
#else
    RtlInitializeCriticalSection( &AtomTable->CriticalSection );
#endif
    return;
}

BOOLEAN
RtlpLockAtomTable(
    IN PRTL_ATOM_TABLE AtomTable
    )
{
    if (AtomTable == NULL || AtomTable->Signature != RTL_ATOM_TABLE_SIGNATURE) {
        return FALSE;
        }

#if defined(NTOS_KERNEL_RUNTIME)
    KeEnterCriticalRegion ();
    ExAcquirePushLockExclusive( &AtomTable->PushLock );
#else
    RtlEnterCriticalSection( &AtomTable->CriticalSection );
#endif

    return TRUE;
}

void
RtlpUnlockAtomTable(
    IN PRTL_ATOM_TABLE AtomTable
    )
{
#if defined(NTOS_KERNEL_RUNTIME)
    ExReleasePushLockExclusive( &AtomTable->PushLock );
    KeLeaveCriticalRegion ();
#else
    RtlLeaveCriticalSection( &AtomTable->CriticalSection );
#endif
}


void
RtlpDestroyLockAtomTable(
    IN OUT PRTL_ATOM_TABLE AtomTable
    )
{
#if defined(NTOS_KERNEL_RUNTIME)
#else
    RtlDeleteCriticalSection( &AtomTable->CriticalSection );
#endif
}


BOOLEAN
RtlpInitializeHandleTableForAtomTable(
    PRTL_ATOM_TABLE AtomTable
    )
{
#if defined(NTOS_KERNEL_RUNTIME)
    AtomTable->ExHandleTable = ExCreateHandleTable( NULL );
    if (AtomTable->ExHandleTable != NULL) {
        //
        // Make sure atom handle tables are NOT part of object handle enumeration
        //

        ExRemoveHandleTable( AtomTable->ExHandleTable );
        return TRUE;
        }
    else {
        return FALSE;
        }
#else
    RtlInitializeHandleTable( (ULONG)(USHORT)~RTL_ATOM_MAXIMUM_INTEGER_ATOM,
                              sizeof( RTL_ATOM_HANDLE_TABLE_ENTRY ),
                              &AtomTable->RtlHandleTable
                            );
    return TRUE;
#endif
}

void
RtlpDestroyHandleTableForAtomTable(
    PRTL_ATOM_TABLE AtomTable
    )
{
#if defined(NTOS_KERNEL_RUNTIME)
    ExDestroyHandleTable( AtomTable->ExHandleTable, NULL );
#else
    RtlDestroyHandleTable( &AtomTable->RtlHandleTable );
#endif
    return;
}

PRTL_ATOM_TABLE_ENTRY
RtlpAtomMapAtomToHandleEntry(
    IN PRTL_ATOM_TABLE AtomTable,
    IN ULONG HandleIndex
    )
{
#if defined(NTOS_KERNEL_RUNTIME)
    PHANDLE_TABLE_ENTRY ExHandleEntry;
    PRTL_ATOM_TABLE_ENTRY a;
    EXHANDLE ExHandle;

    ExHandle.GenericHandleOverlay = 0;
    ExHandle.Index = HandleIndex;

    ExHandleEntry = ExMapHandleToPointer( AtomTable->ExHandleTable,
                                          ExHandle.GenericHandleOverlay
                                        );
    if (ExHandleEntry != NULL) {
        a = ExHandleEntry->Object;
        ExUnlockHandleTableEntry( AtomTable->ExHandleTable, ExHandleEntry );
        return a;
        }
#else
    PRTL_ATOM_HANDLE_TABLE_ENTRY HandleEntry;

    if (RtlIsValidIndexHandle( &AtomTable->RtlHandleTable,
                               HandleIndex,
                               (PRTL_HANDLE_TABLE_ENTRY *)&HandleEntry
                             )
       ) {
        return HandleEntry->Atom;
        }
#endif
    return NULL;
}

BOOLEAN
RtlpCreateHandleForAtom(
    PRTL_ATOM_TABLE p,
    PRTL_ATOM_TABLE_ENTRY a
    )
{
#if defined(NTOS_KERNEL_RUNTIME)
    EXHANDLE ExHandle;
    HANDLE_TABLE_ENTRY ExHandleEntry;

    ExHandleEntry.Object = a;
    ExHandleEntry.GrantedAccess = 0;
    ExHandle.GenericHandleOverlay = ExCreateHandle( p->ExHandleTable, &ExHandleEntry );
    if (ExHandle.GenericHandleOverlay != NULL) {
        a->HandleIndex = (USHORT)ExHandle.Index;
        a->Atom = (RTL_ATOM)((USHORT)a->HandleIndex | RTL_ATOM_MAXIMUM_INTEGER_ATOM);
        return TRUE;
        }
#else
    PRTL_ATOM_HANDLE_TABLE_ENTRY HandleEntry;
    ULONG HandleIndex;

    HandleEntry = (PRTL_ATOM_HANDLE_TABLE_ENTRY)RtlAllocateHandle( &p->RtlHandleTable,
                                                                   &HandleIndex
                                                                 );
    if (HandleEntry != NULL) {
        if (HandleIndex < RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
            a->HandleIndex = (USHORT)HandleIndex;
            a->Atom = (RTL_ATOM)((USHORT)HandleIndex | RTL_ATOM_MAXIMUM_INTEGER_ATOM);
            HandleEntry->Atom = a;
            HandleEntry->LockCount = 0;
            HandleEntry->Flags = RTL_HANDLE_ALLOCATED;
            return TRUE;
            }

        RtlFreeHandle( &p->RtlHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
        }
#endif
    return FALSE;
}

void
RtlpFreeHandleForAtom(
    PRTL_ATOM_TABLE p,
    PRTL_ATOM_TABLE_ENTRY a
    )
{
#if defined(NTOS_KERNEL_RUNTIME)
    EXHANDLE ExHandle;

    ExHandle.GenericHandleOverlay = 0;
    ExHandle.Index = a->HandleIndex;
    ExDestroyHandle( p->ExHandleTable, ExHandle.GenericHandleOverlay, NULL );
#else
    PRTL_ATOM_HANDLE_TABLE_ENTRY HandleEntry;

    if (RtlIsValidIndexHandle( &p->RtlHandleTable,
                               a->HandleIndex,
                               (PRTL_HANDLE_TABLE_ENTRY *)&HandleEntry
                             )
       ) {
        RtlFreeHandle( &p->RtlHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
        }
#endif
    return;
}

NTSTATUS
RtlInitializeAtomPackage(
    IN ULONG AllocationTag
    )
{
    RTL_PAGED_CODE();
    RtlpAtomAllocateTag = AllocationTag;
    return STATUS_SUCCESS;
}

NTSTATUS
RtlCreateAtomTable(
    IN ULONG NumberOfBuckets,
    OUT PVOID *AtomTableHandle
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p;
    ULONG Size;

    RTL_PAGED_CODE();
    Status = STATUS_SUCCESS;
    if (*AtomTableHandle == NULL) {
        if (NumberOfBuckets <= 1) {
            NumberOfBuckets = RTL_ATOM_TABLE_DEFAULT_NUMBER_OF_BUCKETS;
            }

        Size = sizeof( RTL_ATOM_TABLE ) +
               (sizeof( RTL_ATOM_TABLE_ENTRY ) * (NumberOfBuckets-1));

        p = (PRTL_ATOM_TABLE)RtlpAllocateAtom( Size, 'TmtA' );
        if (p == NULL) {
            Status = STATUS_NO_MEMORY;
            }
        else {
            RtlZeroMemory( p, Size );
            p->NumberOfBuckets = NumberOfBuckets;
            if (RtlpInitializeHandleTableForAtomTable( p )) {
                RtlpInitializeLockAtomTable( p );
                p->Signature = RTL_ATOM_TABLE_SIGNATURE;
                *AtomTableHandle = p;
                }
            else {
                Status = STATUS_NO_MEMORY;
                RtlpFreeAtom( p );
                }
            }
        }

    return Status;
}


NTSTATUS
RtlDestroyAtomTable(
    IN PVOID AtomTableHandle
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a, aNext, *pa;
    ULONG i;

    RTL_PAGED_CODE();
    Status = STATUS_SUCCESS;
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        pa = &p->Buckets[ 0 ];
        for (i=0; i<p->NumberOfBuckets; i++) {
            aNext = *pa;
            *pa++ = NULL;
            while ((a = aNext) != NULL) {
                aNext = a->HashLink;
                a->HashLink = NULL;
                RtlpFreeAtom( a );
                }
            }
        p->Signature = 0;
        RtlpUnlockAtomTable( p );

        RtlpDestroyHandleTableForAtomTable( p );
        RtlpDestroyLockAtomTable( p );
        RtlZeroMemory( p, sizeof( RTL_ATOM_TABLE ) );
        RtlpFreeAtom( p );
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}

NTSTATUS
RtlEmptyAtomTable(
    IN PVOID AtomTableHandle,
    IN BOOLEAN IncludePinnedAtoms
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a, aNext, *pa, *pa1;
    ULONG i;

    RTL_PAGED_CODE();
    Status = STATUS_SUCCESS;
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        pa = &p->Buckets[ 0 ];
        for (i=0; i<p->NumberOfBuckets; i++) {
            pa1 = pa++;
            while ((a = *pa1) != NULL) {
                if (IncludePinnedAtoms || !(a->Flags & RTL_ATOM_PINNED)) {
                    *pa1 = a->HashLink;
                    a->HashLink = NULL;
                    RtlpFreeHandleForAtom( p, a );
                    RtlpFreeAtom( a );
                    }
                else {
                    pa1 = &a->HashLink;
                    }
                }
            }

        RtlpUnlockAtomTable( p );
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}

BOOLEAN
RtlpGetIntegerAtom(
    PWSTR Name,
    PRTL_ATOM Atom OPTIONAL
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PWSTR s;
    ULONG n;
    RTL_ATOM Temp;

    if (((ULONG_PTR)Name & -0x10000) == 0) {
        Temp = (RTL_ATOM)(USHORT)PtrToUlong(Name);
        if (Temp >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
            return FALSE;
            }
        else {
            if (Temp == RTL_ATOM_INVALID_ATOM) {
                Temp = RTL_ATOM_MAXIMUM_INTEGER_ATOM;
                }

            if (ARGUMENT_PRESENT( Atom )) {
                *Atom = Temp;
                }

            return TRUE;
            }
        }
    else
    if (*Name != L'#') {
        return FALSE;
        }

    s = ++Name;
    while (*s != UNICODE_NULL) {
        if (*s < L'0' || *s > L'9') {
            return FALSE;
            }
        else {
            s++;
            }
        }

    n = 0;
    UnicodeString.Buffer = Name;
    UnicodeString.Length = (USHORT)((PCHAR)s - (PCHAR)Name);
    UnicodeString.MaximumLength = UnicodeString.Length;
    Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &n );
    if (NT_SUCCESS( Status )) {
        if (ARGUMENT_PRESENT( Atom )) {
            if (n == 0 || n > RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
                *Atom = RTL_ATOM_MAXIMUM_INTEGER_ATOM;
                }
            else {
                *Atom = (RTL_ATOM)n;
                }
            }

        return TRUE;
        }
    else {
        return FALSE;
        }
}

PRTL_ATOM_TABLE_ENTRY
RtlpHashStringToAtom(
    IN PRTL_ATOM_TABLE p,
    IN PWSTR Name,
    OUT PRTL_ATOM_TABLE_ENTRY **PreviousAtom OPTIONAL,
    OUT PULONG NameLength
    )
{
    ULONG Length, Hash;
    WCHAR c;
    PWCH s;
    RTL_ATOM Atom;
    PRTL_ATOM_TABLE_ENTRY *pa, a;

    if (((ULONG_PTR)Name & -0x10000) == 0) {
        Atom = (RTL_ATOM)(USHORT)PtrToUlong(Name);
        a = NULL;
        if (Atom >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
            a = RtlpAtomMapAtomToHandleEntry( p,
                                              (ULONG)(Atom & (USHORT)~RTL_ATOM_MAXIMUM_INTEGER_ATOM)
                                            );
            }

        if (ARGUMENT_PRESENT( PreviousAtom )) {
            *PreviousAtom = NULL;
            }

        return a;
        }

    s = Name;
    Hash = 0;
    while (*s != UNICODE_NULL) {
        c = RtlUpcaseUnicodeChar( *s++ );
        Hash = Hash + (c << 1) + (c >> 1) + c;
        }
    Length = (ULONG) (s - Name);
    if (Length > RTL_ATOM_MAXIMUM_NAME_LENGTH) {
        pa = NULL;
        a = NULL;
        }
    else {
        pa = &p->Buckets[ Hash % p->NumberOfBuckets ];
        while (a = *pa) {
            if (a->NameLength == Length && !_wcsicmp( a->Name, Name )) {
                break;
                }
            else {
                pa = &a->HashLink;
                }
            }
        }

    if (ARGUMENT_PRESENT( PreviousAtom )) {
        *PreviousAtom = pa;
        }

    if (a == NULL && ARGUMENT_PRESENT( NameLength )) {
        *NameLength = Length * sizeof( WCHAR );
        }

    return a;
}


NTSTATUS
RtlAddAtomToAtomTable(
    IN PVOID AtomTableHandle,
    IN PWSTR AtomName OPTIONAL,
    IN OUT PRTL_ATOM Atom OPTIONAL
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a, *pa;
    ULONG NameLength;
    RTL_ATOM Temp;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        if (RtlpGetIntegerAtom( AtomName, &Temp )) {
            if (Temp >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
                Temp = RTL_ATOM_INVALID_ATOM;
                Status = STATUS_INVALID_PARAMETER;
                }
            else {
                Status = STATUS_SUCCESS;
                }

            if (ARGUMENT_PRESENT( Atom )) {
                *Atom = Temp;
                }
            }
        else
        if (*AtomName == UNICODE_NULL) {
            Status = STATUS_OBJECT_NAME_INVALID;
            }
        else {
            a = RtlpHashStringToAtom( p, AtomName, &pa, &NameLength );
            if (a == NULL) {
                if (pa != NULL) {
                    Status = STATUS_NO_MEMORY;
                    a = RtlpAllocateAtom( FIELD_OFFSET( RTL_ATOM_TABLE_ENTRY, Name ) +
                                          NameLength + sizeof( UNICODE_NULL ),
                                          'AmtA'
                                        );
                    if (a != NULL) {
                        a->HashLink = NULL;
                        a->ReferenceCount = 1;
                        a->Flags = 0;
                        RtlCopyMemory( a->Name, AtomName, NameLength );
                        a->NameLength = (UCHAR)(NameLength / sizeof( WCHAR ));
                        a->Name[ a->NameLength ] = UNICODE_NULL;
                        if (RtlpCreateHandleForAtom( p, a )) {
                            a->Atom = (RTL_ATOM)a->HandleIndex | RTL_ATOM_MAXIMUM_INTEGER_ATOM;
                            *pa = a;
                            if (ARGUMENT_PRESENT( Atom )) {
                                *Atom = a->Atom;
                                }

                            Status = STATUS_SUCCESS;
                            }
                        else {
                            RtlpFreeAtom( a );
                            }
                        }
                    }
                else {
                    Status = STATUS_INVALID_PARAMETER;
                    }
                }
            else {
                if (!(a->Flags & RTL_ATOM_PINNED)) {
                    if (a->ReferenceCount == 0xFFFF) {
                        KdPrint(( "RTL: Pinning atom (%x) as reference count about to wrap\n", Atom ));
                        a->Flags |= RTL_ATOM_PINNED;
                        }
                    else {
                        a->ReferenceCount += 1;
                        }
                    }

                if (ARGUMENT_PRESENT( Atom )) {
                    *Atom = a->Atom;
                    }

                Status = STATUS_SUCCESS;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}

NTSTATUS
RtlLookupAtomInAtomTable(
    IN PVOID AtomTableHandle,
    IN PWSTR AtomName,
    OUT PRTL_ATOM Atom OPTIONAL
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a;
    RTL_ATOM Temp;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        if (RtlpGetIntegerAtom( AtomName, &Temp )) {
            if (Temp >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
                Temp = RTL_ATOM_INVALID_ATOM;
                Status = STATUS_INVALID_PARAMETER;
                }
            else {
                Status = STATUS_SUCCESS;
                }

            if (ARGUMENT_PRESENT( Atom )) {
                *Atom = Temp;
                }
            }
        else
        if (*AtomName == UNICODE_NULL) {
            Status = STATUS_OBJECT_NAME_INVALID;
            }
        else {
            a = RtlpHashStringToAtom( p, AtomName, NULL, NULL );
            if (a == NULL) {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                }
            else {
                if (RtlpAtomMapAtomToHandleEntry( p, (ULONG)a->HandleIndex ) != NULL) {
                    Status = STATUS_SUCCESS;
                    if (ARGUMENT_PRESENT( Atom )) {
                        *Atom = a->Atom;
                        }
                    }
                else {
                    Status = STATUS_INVALID_HANDLE;
                    }
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}


NTSTATUS
RtlDeleteAtomFromAtomTable(
    IN PVOID AtomTableHandle,
    IN RTL_ATOM Atom
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a, *pa;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        Status = STATUS_INVALID_HANDLE;
        if (Atom >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
            a = RtlpAtomMapAtomToHandleEntry( p,
                                              (ULONG)(Atom & (USHORT)~RTL_ATOM_MAXIMUM_INTEGER_ATOM)
                                            );
            if (a != NULL && a->Atom == Atom) {
                Status = STATUS_SUCCESS;
                if (a->Flags & RTL_ATOM_PINNED) {
                    KdPrint(( "RTL: Ignoring attempt to delete a pinned atom (%x)\n", Atom ));
                    Status = STATUS_WAS_LOCKED;        // This is a success status code!
                    }
                else
                if (--a->ReferenceCount == 0) {
                    a = RtlpHashStringToAtom( p, a->Name, &pa, NULL );
                    if (a != NULL) {
                        if (pa != NULL) {
                            *pa = a->HashLink;
                        }
                        RtlpFreeHandleForAtom( p, a );
                        RtlpFreeAtom( a );
                        }
                    }
                }
            }
        else
        if (Atom != RTL_ATOM_INVALID_ATOM) {
            Status = STATUS_SUCCESS;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}

NTSTATUS
RtlPinAtomInAtomTable(
    IN PVOID AtomTableHandle,
    IN RTL_ATOM Atom
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a, *pa;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        Status = STATUS_INVALID_HANDLE;
        if (Atom >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
            a = RtlpAtomMapAtomToHandleEntry( p,
                                              (ULONG)(Atom & (USHORT)~RTL_ATOM_MAXIMUM_INTEGER_ATOM)
                                            );
            if (a != NULL && a->Atom == Atom) {
                Status = STATUS_SUCCESS;
                a->Flags |= RTL_ATOM_PINNED;
                }
            }
        else
        if (Atom != RTL_ATOM_INVALID_ATOM) {
            Status = STATUS_SUCCESS;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}

NTSTATUS
RtlQueryAtomInAtomTable(
    IN PVOID AtomTableHandle,
    IN RTL_ATOM Atom,
    OUT PULONG AtomUsage OPTIONAL,
    OUT PULONG AtomFlags OPTIONAL,
    IN OUT PWSTR AtomName OPTIONAL,
    IN OUT PULONG AtomNameLength OPTIONAL
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a;
    WCHAR AtomNameBuffer[ 16 ];
    ULONG CopyLength;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }
    try {
        if (Atom < RTL_ATOM_MAXIMUM_INTEGER_ATOM) {
            if (Atom == RTL_ATOM_INVALID_ATOM) {
                Status = STATUS_INVALID_PARAMETER;
                }
            else {
                Status = STATUS_SUCCESS;
                if (ARGUMENT_PRESENT( AtomUsage )) {
                    *AtomUsage = 1;
                    }

                if (ARGUMENT_PRESENT( AtomFlags )) {
                    *AtomFlags = RTL_ATOM_PINNED;
                    }

                if (ARGUMENT_PRESENT( AtomName )) {
                    CopyLength = _snwprintf( AtomNameBuffer,
                                             sizeof( AtomNameBuffer ) / sizeof( WCHAR ),
                                             L"#%u",
                                             Atom
                                           ) * sizeof( WCHAR );
                    if (CopyLength >= *AtomNameLength) {
                        if (*AtomNameLength >= sizeof( UNICODE_NULL )) {
                            CopyLength = *AtomNameLength - sizeof( UNICODE_NULL );
                            }
                        else {
                            CopyLength = 0;
                            }
                        }

                    if (CopyLength != 0) {
                        RtlCopyMemory( AtomName, AtomNameBuffer, CopyLength );
                        AtomName[ CopyLength / sizeof( WCHAR ) ] = UNICODE_NULL;
                        *AtomNameLength = CopyLength;
                        }
                    else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                        }
                    }
                }
            }
        else {
            a = RtlpAtomMapAtomToHandleEntry( p,
                                              (ULONG)(Atom & (USHORT)~RTL_ATOM_MAXIMUM_INTEGER_ATOM)
                                            );
            if (a != NULL && a->Atom == Atom) {
                Status = STATUS_SUCCESS;
                if (ARGUMENT_PRESENT( AtomUsage )) {
                    *AtomUsage = a->ReferenceCount;
                    }

                if (ARGUMENT_PRESENT( AtomFlags )) {
                    *AtomFlags = a->Flags;
                    }

                if (ARGUMENT_PRESENT( AtomName )) {
                    //
                    // Fill in as much of the atom string as possible, and
                    // always zero terminate. This is what win3.1 does.
                    //

                    CopyLength = a->NameLength * sizeof( WCHAR );
                    if (CopyLength >= *AtomNameLength) {
                        if (*AtomNameLength >= sizeof( UNICODE_NULL )) {
                            CopyLength = *AtomNameLength - sizeof( UNICODE_NULL );
                            }
                        else {
                            *AtomNameLength = CopyLength;
                            CopyLength = 0;
                            }
                        }
                    if (CopyLength != 0) {
                        RtlCopyMemory( AtomName, a->Name, CopyLength );
                        AtomName[ CopyLength / sizeof( WCHAR ) ] = UNICODE_NULL;
                        *AtomNameLength = CopyLength;
                        }
                    else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                        }
                    }
                }
            else {
                Status = STATUS_INVALID_HANDLE;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}

NTSTATUS
RtlQueryAtomsInAtomTable(
    IN PVOID AtomTableHandle,
    IN ULONG MaximumNumberOfAtoms,
    OUT PULONG NumberOfAtoms,
    OUT PRTL_ATOM Atoms
    )
{
    NTSTATUS Status;
    PRTL_ATOM_TABLE p = (PRTL_ATOM_TABLE)AtomTableHandle;
    PRTL_ATOM_TABLE_ENTRY a;
    ULONG i;
    ULONG CurrentAtomIndex;

    RTL_PAGED_CODE();
    if (!RtlpLockAtomTable( p )) {
        return STATUS_INVALID_PARAMETER;
        }

    Status = STATUS_SUCCESS;
    try {
        CurrentAtomIndex = 0;
        for (i=0; i<p->NumberOfBuckets; i++) {
            a = p->Buckets[ i ];
            while (a) {
                if (CurrentAtomIndex < MaximumNumberOfAtoms) {
                    Atoms[ CurrentAtomIndex ] = a->Atom;
                    }
                else {
                    Status = STATUS_INFO_LENGTH_MISMATCH;
                    }

                CurrentAtomIndex += 1;
                a = a->HashLink;
                }
            }

        *NumberOfAtoms = CurrentAtomIndex;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    RtlpUnlockAtomTable( p );

    return Status;
}

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\acledit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Acledit.c

Abstract:

    This Module implements the Acl rtl editing functions that are defined in
    ntseapi.h

Author:

    Gary Kimura     (GaryKi)    9-Nov-1989

Environment:

    Pure Runtime Library Routine

Revision History:

--*/

#include <ntrtlp.h>
#include <seopaque.h>

//
//  Define the local macros and procedure for this module
//

//
//  Return a pointer to the first Ace in an Acl (even if the Acl is empty).
//
//      PACE_HEADER
//      FirstAce (
//          IN PACL Acl
//          );
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Return a pointer to the next Ace in a sequence (even if the input
//  Ace is the one in the sequence).
//
//      PACE_HEADER
//      NextAce (
//          IN PACE_HEADER Ace
//          );
//

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

#define LongAligned( ptr )  (LongAlign(ptr) == ((PVOID)(ptr)))
#define WordAligned( ptr )  (WordAlign(ptr) == ((PVOID)(ptr)))


    VOID
RtlpAddData (
    IN PVOID From,
    IN ULONG FromSize,
    IN PVOID To,
    IN ULONG ToSize
    );

VOID
RtlpDeleteData (
    IN PVOID Data,
    IN ULONG RemoveSize,
    IN ULONG TotalSize
    );

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
NTSTATUS
RtlpAddKnownAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN UCHAR NewType
    );
NTSTATUS
RtlpAddKnownObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid,
    IN UCHAR NewType
    );
#pragma alloc_text(PAGE,RtlCreateAcl)
#pragma alloc_text(PAGE,RtlValidAcl)
#pragma alloc_text(PAGE,RtlQueryInformationAcl)
#pragma alloc_text(PAGE,RtlSetInformationAcl)
#pragma alloc_text(PAGE,RtlAddAce)
#pragma alloc_text(PAGE,RtlDeleteAce)
#pragma alloc_text(PAGE,RtlGetAce)
#pragma alloc_text(PAGE,RtlAddCompoundAce)
#pragma alloc_text(PAGE,RtlpAddKnownAce)
#pragma alloc_text(PAGE,RtlpAddKnownObjectAce)
#pragma alloc_text(PAGE,RtlAddAccessAllowedAce)
#pragma alloc_text(PAGE,RtlAddAccessAllowedAceEx)
#pragma alloc_text(PAGE,RtlAddAccessDeniedAce)
#pragma alloc_text(PAGE,RtlAddAccessDeniedAceEx)
#pragma alloc_text(PAGE,RtlAddAuditAccessAce)
#pragma alloc_text(PAGE,RtlAddAuditAccessAceEx)
#pragma alloc_text(PAGE,RtlAddAccessAllowedObjectAce)
#pragma alloc_text(PAGE,RtlAddAccessDeniedObjectAce)
#pragma alloc_text(PAGE,RtlAddAuditAccessObjectAce)
#pragma alloc_text(PAGE,RtlFirstFreeAce)
#pragma alloc_text(PAGE,RtlpAddData)
#pragma alloc_text(PAGE,RtlpDeleteData)
#endif


NTSTATUS
RtlCreateAcl (
    IN PACL Acl,
    IN ULONG AclLength,
    IN ULONG AclRevision
    )

/*++

Routine Description:

    This routine initializes an ACL data structure.  After initialization
    it is an ACL with no ACE (i.e., a deny all access type ACL)

Arguments:

    Acl - Supplies the buffer containing the ACL being initialized

    AclLength - Supplies the length of the ace buffer in bytes

    AclRevision - Supplies the revision for this Acl

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful

               STATUS_BUFFER_TOO_SMALL if the AclLength is too small,

               STATUS_INVALID_PARAMETER if the revision is out of range

--*/

{
    RTL_PAGED_CODE();

    //
    //  Check to see the size of the buffer is large enough to hold at
    //  least the ACL header
    //

    if (AclLength < sizeof(ACL)) {

        //
        //  Buffer to small even for the ACL header
        //

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    //  Check to see if the revision is currently valid.  Later versions
    //  of this procedure might accept more revision levels
    //

    if (AclRevision < MIN_ACL_REVISION || AclRevision > MAX_ACL_REVISION) {

        //
        //  Revision not current
        //

        return STATUS_INVALID_PARAMETER;

    }

    if ( AclLength > MAX_USTRING ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Initialize the ACL
    //

    Acl->AclRevision = (UCHAR)AclRevision;  // Used to hardwire ACL_REVISION2 here
    Acl->Sbz1 = 0;
    Acl->AclSize = (USHORT) (AclLength & 0xfffc);
    Acl->AceCount = 0;
    Acl->Sbz2 = 0;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


BOOLEAN
RtlValidAcl (
    IN PACL Acl
    )

/*++

Routine Description:

    This procedure validates an ACL.

    This involves validating the revision level of the ACL and ensuring
    that the number of ACEs specified in the AceCount fit in the space
    specified by the AclSize field of the ACL header.

Arguments:

    Acl - Pointer to the ACL structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of Acl is valid.

--*/

{
    RTL_PAGED_CODE();

    try {
        PACE_HEADER Ace;
        PISID Sid;
        PISID Sid2;
        ULONG i;
        UCHAR AclRevision = ACL_REVISION2;


        //
        //  Check the ACL revision level
        //
        if (!ValidAclRevision(Acl)) {
            return(FALSE);
        }


        if (!WordAligned(&Acl->AclSize)) {
            return(FALSE);
        }

        if (Acl->AclSize < sizeof(ACL)) {
            return(FALSE);
        }
        //
        // Validate all of the ACEs.
        //

        Ace = ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)));

        for (i = 0; i < Acl->AceCount; i++) {

            //
            //  Check to make sure we haven't overrun the Acl buffer
            //  with our ace pointer.  Make sure the ACE_HEADER is in
            //  the ACL also.
            //

            if ((PUCHAR)Ace + sizeof(ACE_HEADER) >= ((PUCHAR)Acl + Acl->AclSize)) {
                return(FALSE);
            }

            if (!WordAligned(&Ace->AceSize)) {
                return(FALSE);
            }

            if ((PUCHAR)Ace + Ace->AceSize > ((PUCHAR)Acl + Acl->AclSize)) {
                return(FALSE);
            }

            //
            // It is now safe to reference fields in the ACE header.
            //

            //
            // The ACE header fits into the ACL, if this is a known type of ACE,
            // make sure the SID is within the bounds of the ACE
            //

            if (IsKnownAceType(Ace)) {

                if (!LongAligned(Ace->AceSize)) {
                    return(FALSE);
                }

                if (Ace->AceSize < sizeof(KNOWN_ACE) - sizeof(ULONG) + sizeof(SID) - sizeof(ULONG)) {
                    return(FALSE);
                }

                //
                // It's now safe to reference the parts of the SID structure, though
                // not the SID itself.
                //

                Sid = (PISID) & (((PKNOWN_ACE)Ace)->SidStart);

                if (Sid->Revision != SID_REVISION) {
                    return(FALSE);
                }

                if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                    return(FALSE);
                }

                //
                // SeLengthSid computes the size of the SID based on the subauthority count,
                // so it is safe to use even though we don't know that the body of the SID
                // is safe to reference.
                //

                if (Ace->AceSize < sizeof(KNOWN_ACE) - sizeof(ULONG) + SeLengthSid( Sid )) {
                    return(FALSE);
                }


            //
            // If it's a compound ACE, then perform roughly the same set of tests, but
            // check the validity of both SIDs.
            //

            } else if (IsCompoundAceType(Ace)) {

                //
                // Compound ACEs became valid in revision 3
                //
                if ( Acl->AclRevision < ACL_REVISION3 ) {
                    return FALSE;
                }

                if (!LongAligned(Ace->AceSize)) {
                    return(FALSE);
                }

                if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + sizeof(SID)) {
                    return(FALSE);
                }

                //
                // The only currently defined Compound ACE is an Impersonation ACE.
                //

                if (((PKNOWN_COMPOUND_ACE)Ace)->CompoundAceType != COMPOUND_ACE_IMPERSONATION) {
                    return(FALSE);
                }

                //
                // Examine the first SID and make sure it's structurally valid,
                // and it lies within the boundaries of the ACE.
                //

                Sid = (PISID) & (((PKNOWN_COMPOUND_ACE)Ace)->SidStart);

                if (Sid->Revision != SID_REVISION) {
                    return(FALSE);
                }

                if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                    return(FALSE);
                }

                //
                // Compound ACEs contain two SIDs.  Make sure this ACE is large enough to contain
                // not only the first SID, but the body of the 2nd.
                //

                if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + SeLengthSid( Sid ) + sizeof(SID)) {
                    return(FALSE);
                }

                //
                // It is safe to reference the interior of the 2nd SID.
                //

                Sid2 = (PISID) ((PUCHAR)Sid + SeLengthSid( Sid ));

                if (Sid2->Revision != SID_REVISION) {
                    return(FALSE);
                }

                if (Sid2->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                    return(FALSE);
                }

                if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + SeLengthSid( Sid ) + SeLengthSid( Sid2 )) {
                    return(FALSE);
                }


            //
            // If it's an object ACE, then perform roughly the same set of tests.
            //

            } else if (IsObjectAceType(Ace)) {
                ULONG GuidSize=0;

                //
                // Object ACEs became valid in revision 4
                //
                if ( Acl->AclRevision < ACL_REVISION4 ) {
                    return FALSE;
                }

                if (!LongAligned(Ace->AceSize)) {
                    return(FALSE);
                }

                //
                // Ensure there is room for the ACE header.
                //
                if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG)) {
                    return(FALSE);
                }


                //
                // Ensure there is room for the GUIDs and SID header
                //
                if ( RtlObjectAceObjectTypePresent( Ace ) ) {
                    GuidSize += sizeof(GUID);
                }

                if ( RtlObjectAceInheritedObjectTypePresent( Ace ) ) {
                    GuidSize += sizeof(GUID);
                }

                if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG) + GuidSize + sizeof(SID)) {
                    return(FALSE);
                }

                //
                // It's now safe to reference the parts of the SID structure, though
                // not the SID itself.
                //

                Sid = (PISID) RtlObjectAceSid( Ace );

                if (Sid->Revision != SID_REVISION) {
                    return(FALSE);
                }

                if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                    return(FALSE);
                }

                if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG) + GuidSize + SeLengthSid( Sid ) ) {
                    return(FALSE);
                }
            }

            //
            //  And move Ace to the next ace position
            //

            Ace = ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize));
        }

        return(TRUE);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        return FALSE;
    }

}


NTSTATUS
RtlQueryInformationAcl (
    IN PACL Acl,
    OUT PVOID AclInformation,
    IN ULONG AclInformationLength,
    IN ACL_INFORMATION_CLASS AclInformationClass
    )

/*++

Routine Description:

    This routine returns to the caller information about an ACL.  The requested
    information can be AclRevisionInformation, or AclSizeInformation.

Arguments:

    Acl - Supplies the Acl being examined

    AclInformation - Supplies the buffer to receive the information being
        requested

    AclInformationLength - Supplies the length of the AclInformation buffer
        in bytes

    AclInformationClass - Supplies the type of information being requested

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PACL_REVISION_INFORMATION RevisionInfo;
    PACL_SIZE_INFORMATION SizeInfo;


    PVOID FirstFree;
    NTSTATUS Status;

    RTL_PAGED_CODE();

    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision( Acl )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Case on the information class being requested
    //

    switch (AclInformationClass) {

    case AclRevisionInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_REVISION_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Get the Acl revision and return
        //

        RevisionInfo = (PACL_REVISION_INFORMATION)AclInformation;
        RevisionInfo->AclRevision = Acl->AclRevision;

        break;

    case AclSizeInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_SIZE_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Locate the first free spot in the Acl
        //

        if (!RtlFirstFreeAce( Acl, &FirstFree )) {

            //
            //  The input Acl is ill-formed
            //

            return STATUS_INVALID_PARAMETER;

        }

        //
        //  Given a pointer to the first free spot we can now easily compute
        //  the number of free bytes and used bytes in the Acl.
        //

        SizeInfo = (PACL_SIZE_INFORMATION)AclInformation;
        SizeInfo->AceCount = Acl->AceCount;

        if (FirstFree == NULL) {

            //
            //  With a null first free we don't have any free space in the Acl
            //

            SizeInfo->AclBytesInUse = Acl->AclSize;

            SizeInfo->AclBytesFree = 0;

        } else {

            //
            //  The first free is not null so we have some free room left in
            //  the acl
            //

            SizeInfo->AclBytesInUse = (ULONG)((PUCHAR)FirstFree - (PUCHAR)Acl);

            SizeInfo->AclBytesFree = Acl->AclSize - SizeInfo->AclBytesInUse;

        }

        break;

    default:

        return STATUS_INVALID_INFO_CLASS;

    }

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlSetInformationAcl (
    IN PACL Acl,
    IN PVOID AclInformation,
    IN ULONG AclInformationLength,
    IN ACL_INFORMATION_CLASS AclInformationClass
    )

/*++

Routine Description:

    This routine sets the state of an ACL.  For now only the revision
    level can be set and for now only a revision level of 1 is accepted
    so this procedure is rather simple

Arguments:

    Acl - Supplies the Acl being altered

    AclInformation - Supplies the buffer containing the information being
        set

    AclInformationLength - Supplies the length of the Acl information buffer

    AclInformationClass - Supplies the type of information begin set

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PACL_REVISION_INFORMATION RevisionInfo;

    RTL_PAGED_CODE();

    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision( Acl )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Case on the information class being requested
    //

    switch (AclInformationClass) {

    case AclRevisionInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_REVISION_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Get the Acl requested ACL revision level
        //

        RevisionInfo = (PACL_REVISION_INFORMATION)AclInformation;

        //
        //  Don't let them lower the revision of an ACL.
        //

        if (RevisionInfo->AclRevision < Acl->AclRevision ) {

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Assign the new revision.
        //

        Acl->AclRevision = (UCHAR)RevisionInfo->AclRevision;

        break;

    default:

        return STATUS_INVALID_INFO_CLASS;

    }

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlAddAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG StartingAceIndex,
    IN PVOID AceList,
    IN ULONG AceListLength
    )

/*++

Routine Description:

    This routine adds a string of ACEs to an ACL.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    StartingAceIndex - Supplies the ACE index which will be the index of
        the first ace inserted in the acl. 0 for the beginning of the list
        and MAXULONG for the end of the list.

    AceList - Supplies the list of Aces to be added to the Acl

    AceListLength - Supplies the size, in bytes, of the AceList buffer

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful, and an appropriate error
        status otherwise

--*/

{
    PVOID FirstFree;

    PACE_HEADER Ace;
    ULONG NewAceCount;

    PVOID AcePosition;
    ULONG i;
    UCHAR NewRevision;

    RTL_PAGED_CODE();

    //
    //  Check the ACL structure
    //

    if (!RtlValidAcl(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Locate the first free ace and check to see that the Acl is
    //  well formed.
    //

    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // If the AceRevision is greater than the ACL revision, then we want to
    // increase the ACL revision to be the same as the new ACE revision.
    // We can do this because our previously defined ACE types ( 0 -> 3 ) have
    // not changed structure nor been discontinued in the new revision.  So
    // we can bump the revision and the older types will not be misinterpreted.
    //
    // Compute what the final revision of the ACL is going to be, and save it
    // for later so we can update it once we know we're going to succeed.
    //

    NewRevision = (UCHAR)AceRevision > Acl->AclRevision ? (UCHAR)AceRevision : Acl->AclRevision;

    //
    // Check that the AceList is well formed, we do this by simply zooming
    // down the Ace list until we're equal to or have exceeded the ace list
    // length.  If we are equal to the length then we're well formed otherwise
    // we're ill-formed.  We'll also calculate how many Ace's there are
    // in the AceList
    //
    // In addition, now we have to make sure that we haven't been handed an
    // ACE type that is inappropriate for the AceRevision that was passed
    // in.
    //

    for (Ace = AceList, NewAceCount = 0;
         Ace < (PACE_HEADER)((PUCHAR)AceList + AceListLength);
         Ace = NextAce( Ace ), NewAceCount++) {

        //
        // Ensure the ACL revision allows this ACE type.
        //

        if ( Ace->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE ) {
            // V2 ACE are always valid.
        } else if ( Ace->AceType <= ACCESS_MAX_MS_V3_ACE_TYPE ) {
            if ( AceRevision < ACL_REVISION3 ) {
                return STATUS_INVALID_PARAMETER;
            }
        } else if ( Ace->AceType <= ACCESS_MAX_MS_V4_ACE_TYPE ) {
            if ( AceRevision < ACL_REVISION4 ) {
                return STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    //  Check to see if we've exceeded the ace list length
    //

    if (Ace > (PACE_HEADER)((PUCHAR)AceList + AceListLength)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Check to see if there is enough room in the Acl to store the additional
    //  Ace list
    //

    if (FirstFree == NULL ||
        (PUCHAR)FirstFree + AceListLength > (PUCHAR)Acl + Acl->AclSize) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    //  All of the input has checked okay, we now need to locate the position
    //  where to insert the new ace list.  We won't check the acl for
    //  validity because we did earlier when got the first free ace position.
    //

    AcePosition = FirstAce( Acl );

    for (i = 0; i < StartingAceIndex && i < Acl->AceCount; i++) {

        AcePosition = NextAce( AcePosition );

    }

    //
    //  Now Ace points to where we want to insert the ace list,  We do the
    //  insertion by adding ace list to the acl and shoving over the remainder
    //  of the list down the acl.  We know this will work because we earlier
    //  check to make sure the new acl list will fit in the acl size
    //

    RtlpAddData( AceList, AceListLength,
             AcePosition, (ULONG) ((PUCHAR)FirstFree - (PUCHAR)AcePosition));

    //
    //  Update the Acl Header
    //

    Acl->AceCount = (USHORT)(Acl->AceCount + NewAceCount);

    Acl->AclRevision = NewRevision;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDeleteAce (
    IN OUT PACL Acl,
    IN ULONG AceIndex
    )

/*++

Routine Description:

    This routine deletes one ACE from an ACL.

Arguments:

    Acl - Supplies the Acl being modified

    AceIndex - Supplies the index of the Ace to delete.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PVOID FirstFree;

    PACE_HEADER Ace;
    ULONG i;

    RTL_PAGED_CODE();

    //
    //  Check the ACL structure
    //

    if (!RtlValidAcl(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Make sure the AceIndex is within proper range, it's ulong so we know
    //  it can't be negative
    //

    if (AceIndex >= Acl->AceCount) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Locate the first free spot, this will tell us how much data
    //  we'll need to colapse.  If the results is false then the acl is
    //  ill-formed
    //

    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Now locate the ace that we're going to delete.  This loop
    //  doesn't need to check the acl for being well formed.
    //

    Ace = FirstAce( Acl );

    for (i = 0; i < AceIndex; i++) {

        Ace = NextAce( Ace );

    }

    //
    //  We've found the ace to delete to simply copy over the rest of
    //  the acl over this ace.  The delete data procedure also deletes
    //  rest of the string that it's moving over so we don't have to
    //

    RtlpDeleteData( Ace, Ace->AceSize, (ULONG) ((PUCHAR)FirstFree - (PUCHAR)Ace));

    //
    //  Update the Acl header
    //

    Acl->AceCount--;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlGetAce (
    IN PACL Acl,
    ULONG AceIndex,
    OUT PVOID *Ace
    )

/*++

Routine Description:

    This routine returns a pointer to an ACE in an ACl referenced by
    ACE index

Arguments:

    Acl - Supplies the ACL being queried

    AceIndex - Supplies the Ace index to locate

    Ace - Receives the address of the ACE within the ACL

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    ULONG i;

    RTL_PAGED_CODE();

    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Check the AceIndex against the Ace count of the Acl, it's ulong so
    //  we know it can't be negative
    //

    if (AceIndex >= Acl->AceCount) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  To find the Ace requested by zooming down the Ace List.
    //

    *Ace = FirstAce( Acl );

    for (i = 0; i < AceIndex; i++) {

        //
        //  Check to make sure we haven't overrun the Acl buffer
        //  with our ace pointer.  If we have then our input is bogus
        //

        if (*Ace >= (PVOID)((PUCHAR)Acl + Acl->AclSize)) {

            return STATUS_INVALID_PARAMETER;

        }

        //
        //  And move Ace to the next ace position
        //

        *Ace = NextAce( *Ace );

    }

    //
    //  Now Ace points to the Ace we're after, but make sure we aren't
    //  beyond the Acl.
    //

    if (*Ace >= (PVOID)((PUCHAR)Acl + Acl->AclSize)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  The Ace is still within the Acl so return success to our caller
    //

    return STATUS_SUCCESS;

}


NTSTATUS
RtlAddCompoundAce (
    IN PACL Acl,
    IN ULONG AceRevision,
    IN UCHAR CompoundAceType,
    IN ACCESS_MASK AccessMask,
    IN PSID ServerSid,
    IN PSID ClientSid
    )

/*++

Routine Description:

    This routine adds a KNOWN_COMPOUND_ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    CompoundAceType - Supplies the type of compound ACE being added.
        Currently the only defined type is COMPOUND_ACE_IMPERSONATION.

    AccessMask - The mask of accesses to be granted to the specified SID pair.

    ServerSid - Pointer to the Server SID to be placed in the ACE.

    ClientSid - Pointer to the Client SID to be placed in the ACE.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/




{
    PVOID FirstFree;
    USHORT AceSize;
    PKNOWN_COMPOUND_ACE GrantAce;
    UCHAR NewRevision;

    RTL_PAGED_CODE();

    //
    // Validate the structure of the SID
    //

    if (!RtlValidSid(ServerSid) || !RtlValidSid(ClientSid)) {
        return STATUS_INVALID_SID;
    }

    //
    //  Check the ACL & ACE revision levels
    // Compund ACEs become valid in version 3.
    //

    if ( Acl->AclRevision > ACL_REVISION4 ||
         AceRevision < ACL_REVISION3 ||
         AceRevision > ACL_REVISION4 ) {
        return STATUS_REVISION_MISMATCH;
    }

    //
    // Calculate the new revision of the ACL.  The new revision is the maximum
    // of the old revision and and new ACE's revision.  This is possible because
    // the format of previously defined ACEs did not change across revisions.
    //

    NewRevision = Acl->AclRevision > (UCHAR)AceRevision ? Acl->AclRevision : (UCHAR)AceRevision;

    //
    //  Locate the first free ace and check to see that the Acl is
    //  well formed.
    //

    if (!RtlValidAcl( Acl )) {
        return STATUS_INVALID_ACL;
    }

    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_ACL;
    }

    //
    //  Check to see if there is enough room in the Acl to store the new
    //  ACE
    //

    AceSize = (USHORT)(sizeof(KNOWN_COMPOUND_ACE) -
                       sizeof(ULONG)              +
                       SeLengthSid(ClientSid)    +
                       SeLengthSid(ServerSid)
                       );

    if (  FirstFree == NULL ||
          ((PUCHAR)FirstFree + AceSize > ((PUCHAR)Acl + Acl->AclSize))
       ) {

        return STATUS_ALLOTTED_SPACE_EXCEEDED;
    }

    //
    // Add the ACE to the end of the ACL
    //

    GrantAce = (PKNOWN_COMPOUND_ACE)FirstFree;
    GrantAce->Header.AceFlags = 0;
    GrantAce->Header.AceType = ACCESS_ALLOWED_COMPOUND_ACE_TYPE;
    GrantAce->Header.AceSize = AceSize;
    GrantAce->Mask = AccessMask;
    GrantAce->CompoundAceType = CompoundAceType;
    RtlCopySid( SeLengthSid(ServerSid), (PSID)(&GrantAce->SidStart), ServerSid );
    RtlCopySid( SeLengthSid(ClientSid), (PSID)(((PCHAR)&GrantAce->SidStart) + SeLengthSid(ServerSid)), ClientSid );

    //
    // Increment the number of ACEs by 1.
    //

    Acl->AceCount += 1;

    //
    // Adjust the Acl revision, if necessary
    //

    Acl->AclRevision = NewRevision;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlpAddKnownAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN UCHAR NewType
    )

/*++

Routine Description:

    This routine adds KNOWN_ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.  The type is specified by the caller.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be denied to the specified SID.

    Sid - Pointer to the SID being denied access.

    NewType - Type of ACE to be added.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    PVOID FirstFree;
    USHORT AceSize;
    PKNOWN_ACE GrantAce;
    UCHAR NewRevision;
    ULONG TestedAceFlags;

    RTL_PAGED_CODE();

    //
    // Validate the structure of the SID
    //

    if (!RtlValidSid(Sid)) {
        return STATUS_INVALID_SID;
    }

    //
    //  Check the ACL & ACE revision levels
    //

    if ( Acl->AclRevision > ACL_REVISION4 || AceRevision > ACL_REVISION4 ) {

        return STATUS_REVISION_MISMATCH;
    }

    //
    // Calculate the new revision of the ACL.  The new revision is the maximum
    // of the old revision and and new ACE's revision.  This is possible because
    // the format of previously defined ACEs did not change across revisions.
    //

    NewRevision = Acl->AclRevision > (UCHAR)AceRevision ? Acl->AclRevision : (UCHAR)AceRevision;

    //
    // Validate the AceFlags.
    //

    TestedAceFlags = AceFlags & ~VALID_INHERIT_FLAGS;
    if ( TestedAceFlags != 0 ) {

        if ( NewType == SYSTEM_AUDIT_ACE_TYPE ) {
            TestedAceFlags &=
                ~(SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG);
        }

        if ( TestedAceFlags != 0 ) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Locate the first free ace and check to see that the Acl is
    //  well formed.
    //

    if (!RtlValidAcl( Acl )) {
        return STATUS_INVALID_ACL;
    }
    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_ACL;
    }

    //
    //  Check to see if there is enough room in the Acl to store the new
    //  ACE
    //

    AceSize = (USHORT)(sizeof(ACE_HEADER) +
                      sizeof(ACCESS_MASK) +
                      SeLengthSid(Sid));

    if (  FirstFree == NULL ||
          ((PUCHAR)FirstFree + AceSize > ((PUCHAR)Acl + Acl->AclSize))
       ) {

        return STATUS_ALLOTTED_SPACE_EXCEEDED;
    }

    //
    // Add the ACE to the end of the ACL
    //

    GrantAce = (PKNOWN_ACE)FirstFree;
    GrantAce->Header.AceFlags = (UCHAR)AceFlags;
    GrantAce->Header.AceType = NewType;
    GrantAce->Header.AceSize = AceSize;
    GrantAce->Mask = AccessMask;
    RtlCopySid( SeLengthSid(Sid), (PSID)(&GrantAce->SidStart), Sid );

    //
    // Increment the number of ACEs by 1.
    //

    Acl->AceCount += 1;

    //
    // Adjust the Acl revision, if necessary
    //

    Acl->AclRevision = NewRevision;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}

NTSTATUS
RtlpAddKnownObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid,
    IN UCHAR NewType
    )

/*++

Routine Description:

    This routine adds KNOWN_ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.  The type is specified by the caller.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be denied to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    Sid - Pointer to the SID being denied access.

    NewType - Type of ACE to be added.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    PVOID FirstFree;
    USHORT AceSize;
    PKNOWN_OBJECT_ACE GrantAce;
    UCHAR NewRevision;
    ULONG TestedAceFlags;
    ULONG AceObjectFlags = 0;
    ULONG SidSize;
    PCHAR Where;

    RTL_PAGED_CODE();

    //
    // Validate the structure of the SID
    //

    if (!RtlValidSid(Sid)) {
        return STATUS_INVALID_SID;
    }

    //
    //  Check the ACL & ACE revision levels
    // Object ACEs became valid in version 4.
    //

    if ( Acl->AclRevision > ACL_REVISION4 || AceRevision != ACL_REVISION4 ) {

        return STATUS_REVISION_MISMATCH;
    }

    //
    // Calculate the new revision of the ACL.  The new revision is the maximum
    // of the old revision and and new ACE's revision.  This is possible because
    // the format of previously defined ACEs did not change across revisions.
    //

    NewRevision = Acl->AclRevision > (UCHAR)AceRevision ? Acl->AclRevision : (UCHAR)AceRevision;

    //
    // Validate the AceFlags.
    //


    TestedAceFlags = AceFlags & ~VALID_INHERIT_FLAGS;
    if ( TestedAceFlags != 0 ) {

        if ( NewType == SYSTEM_AUDIT_ACE_TYPE ||
             NewType == SYSTEM_AUDIT_OBJECT_ACE_TYPE ) {
            TestedAceFlags &=
                ~(SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG);
        }

        if ( TestedAceFlags != 0 ) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Locate the first free ace and check to see that the Acl is
    //  well formed.
    //

    if (!RtlValidAcl( Acl )) {
        return STATUS_INVALID_ACL;
    }
    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_ACL;
    }

    //
    //  Check to see if there is enough room in the Acl to store the new
    //  ACE
    //

    SidSize = SeLengthSid(Sid);
    AceSize = (USHORT)(sizeof(ACE_HEADER) +
                      sizeof(ACCESS_MASK) +
                      sizeof(ULONG) +
                      SidSize);

    if ( ARGUMENT_PRESENT(ObjectTypeGuid) ) {
        AceObjectFlags |= ACE_OBJECT_TYPE_PRESENT;
        AceSize += sizeof(GUID);
    }

    if ( ARGUMENT_PRESENT(InheritedObjectTypeGuid) ) {
        AceObjectFlags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
        AceSize += sizeof(GUID);
    }

    if (  FirstFree == NULL ||
          ((PUCHAR)FirstFree + AceSize > ((PUCHAR)Acl + Acl->AclSize))
       ) {

        return STATUS_ALLOTTED_SPACE_EXCEEDED;
    }

    //
    // Add the ACE to the end of the ACL
    //

    GrantAce = (PKNOWN_OBJECT_ACE)FirstFree;
    GrantAce->Header.AceFlags = (UCHAR) AceFlags;
    GrantAce->Header.AceType = NewType;
    GrantAce->Header.AceSize = AceSize;
    GrantAce->Mask = AccessMask;
    GrantAce->Flags = AceObjectFlags;
    Where = (PCHAR) (&GrantAce->SidStart);
    if ( ARGUMENT_PRESENT(ObjectTypeGuid) ) {
        RtlCopyMemory( Where, ObjectTypeGuid, sizeof(GUID) );
        Where += sizeof(GUID);
    }
    if ( ARGUMENT_PRESENT(InheritedObjectTypeGuid) ) {
        RtlCopyMemory( Where, InheritedObjectTypeGuid, sizeof(GUID) );
        Where += sizeof(GUID);
    }
    RtlCopySid( SidSize, (PSID)Where, Sid );
    Where += SidSize;

    //
    // Increment the number of ACEs by 1.
    //

    Acl->AceCount += 1;

    //
    // Adjust the Acl revision, if necessary
    //

    Acl->AclRevision = NewRevision;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlAddAccessAllowedAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be granted to the specified SID.

    Sid - Pointer to the SID being granted access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

--*/

{
    RTL_PAGED_CODE();

    return RtlpAddKnownAce (
               Acl,
               AceRevision,
               0,   // No inherit flags
               AccessMask,
               Sid,
               ACCESS_ALLOWED_ACE_TYPE
               );
}


NTSTATUS
RtlAddAccessAllowedAceEx (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    Sid - Pointer to the SID being granted access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    return RtlpAddKnownAce (
               Acl,
               AceRevision,
               AceFlags,
               AccessMask,
               Sid,
               ACCESS_ALLOWED_ACE_TYPE
               );
}


NTSTATUS
RtlAddAccessDeniedAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be denied to the specified SID.

    Sid - Pointer to the SID being denied access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

--*/

{
    RTL_PAGED_CODE();

    return RtlpAddKnownAce (
               Acl,
               AceRevision,
               0,   // No inherit flags
               AccessMask,
               Sid,
               ACCESS_DENIED_ACE_TYPE
               );

}


NTSTATUS
RtlAddAccessDeniedAceEx (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be denied to the specified SID.

    Sid - Pointer to the SID being denied access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    return RtlpAddKnownAce (
               Acl,
               AceRevision,
               AceFlags,
               AccessMask,
               Sid,
               ACCESS_DENIED_ACE_TYPE
               );

}


NTSTATUS
RtlAddAuditAccessAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN BOOLEAN AuditSuccess,
    IN BOOLEAN AuditFailure
    )

/*++

Routine Description:

    This routine adds a SYSTEM_AUDIT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance.

    Parameters are used to indicate whether auditing is to be performed
    on success, failure, or both.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be denied to the specified SID.

    Sid - Pointer to the SID to be audited.

    AuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    AuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

--*/

{
    ULONG AceFlags = 0;
    RTL_PAGED_CODE();

    if (AuditSuccess) {
        AceFlags |= SUCCESSFUL_ACCESS_ACE_FLAG;
    }
    if (AuditFailure) {
        AceFlags |= FAILED_ACCESS_ACE_FLAG;
    }

    return RtlpAddKnownAce (
                Acl,
                AceRevision,
                AceFlags,
                AccessMask,
                Sid,
                SYSTEM_AUDIT_ACE_TYPE );

}

NTSTATUS
RtlAddAuditAccessAceEx (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN BOOLEAN AuditSuccess,
    IN BOOLEAN AuditFailure
    )

/*++

Routine Description:

    This routine adds a SYSTEM_AUDIT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance.

    Parameters are used to indicate whether auditing is to be performed
    on success, failure, or both.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be denied to the specified SID.

    Sid - Pointer to the SID to be audited.

    AuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    AuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    if (AuditSuccess) {
        AceFlags |= SUCCESSFUL_ACCESS_ACE_FLAG;
    }
    if (AuditFailure) {
        AceFlags |= FAILED_ACCESS_ACE_FLAG;
    }

    return RtlpAddKnownAce (
                Acl,
                AceRevision,
                AceFlags,
                AccessMask,
                Sid,
                SYSTEM_AUDIT_ACE_TYPE );

}


NTSTATUS
RtlAddAccessAllowedObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an object specific ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    Sid - Pointer to the SID being granted access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    //
    // If no object types are specified,
    //  build a non-object ACE.
    //
    if (ObjectTypeGuid == NULL && InheritedObjectTypeGuid == NULL ) {
        return RtlpAddKnownAce (
                   Acl,
                   AceRevision,
                   AceFlags,
                   AccessMask,
                   Sid,
                   ACCESS_ALLOWED_ACE_TYPE
                   );
    }

    return RtlpAddKnownObjectAce (
               Acl,
               AceRevision,
               AceFlags,
               AccessMask,
               ObjectTypeGuid,
               InheritedObjectTypeGuid,
               Sid,
               ACCESS_ALLOWED_OBJECT_ACE_TYPE
               );
}


NTSTATUS
RtlAddAccessDeniedObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine adds an object specific ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    Sid - Pointer to the SID being denied access.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    //
    // If no object types are specified,
    //  build a non-object ACE.
    //
    if (ObjectTypeGuid == NULL && InheritedObjectTypeGuid == NULL ) {
        return RtlpAddKnownAce (
                   Acl,
                   AceRevision,
                   AceFlags,
                   AccessMask,
                   Sid,
                   ACCESS_DENIED_ACE_TYPE
                   );
    }

    return RtlpAddKnownObjectAce (
               Acl,
               AceRevision,
               AceFlags,
               AccessMask,
               ObjectTypeGuid,
               InheritedObjectTypeGuid,
               Sid,
               ACCESS_DENIED_OBJECT_ACE_TYPE
               );
}


NTSTATUS
RtlAddAuditAccessObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid,
    IN BOOLEAN AuditSuccess,
    IN BOOLEAN AuditFailure
    )

/*++

Routine Description:

    This routine adds an object specific ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    Sid - Pointer to the SID to be audited.

    AuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    AuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    STATUS_SUCCESS - The ACE was successfully added.

    STATUS_INVALID_ACL - The specified ACL is not properly formed.

    STATUS_REVISION_MISMATCH - The specified revision is not known
        or is incompatible with that of the ACL.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The new ACE does not fit into the
        ACL.  A larger ACL buffer is required.

    STATUS_INVALID_SID - The provided SID is not a structurally valid
        SID.

    STATUS_INVALID_PARAMETER - The AceFlags parameter was invalid.

--*/

{
    RTL_PAGED_CODE();

    if (AuditSuccess) {
        AceFlags |= SUCCESSFUL_ACCESS_ACE_FLAG;
    }
    if (AuditFailure) {
        AceFlags |= FAILED_ACCESS_ACE_FLAG;
    }

    //
    // If no object types are specified,
    //  build a non-object ACE.
    //
    if (ObjectTypeGuid == NULL && InheritedObjectTypeGuid == NULL ) {
        return RtlpAddKnownAce (
                   Acl,
                   AceRevision,
                   AceFlags,
                   AccessMask,
                   Sid,
                   SYSTEM_AUDIT_ACE_TYPE
                   );
    }

    return RtlpAddKnownObjectAce (
               Acl,
               AceRevision,
               AceFlags,
               AccessMask,
               ObjectTypeGuid,
               InheritedObjectTypeGuid,
               Sid,
               SYSTEM_AUDIT_OBJECT_ACE_TYPE
               );
}

#if 0

NTSTATUS
RtlMakePosixAcl(
    IN ULONG AclRevision,
    IN PSID UserSid,
    IN PSID GroupSid,
    IN ACCESS_MASK UserAccess,
    IN ACCESS_MASK GroupAccess,
    IN ACCESS_MASK OtherAccess,
    IN ULONG AclLength,
    OUT PACL Acl,
    OUT PULONG ReturnLength
    )
/*++

Routine Description:

    NOTE: THIS ROUTINE IS STILL BEING SPEC'D.

    Make an ACL representing Posix protection from AccessMask and
    security account ID (SID) information.

Arguments:

    AclRevision - Indicates the ACL revision level of the access masks
        provided.  The ACL generated will be revision compatible with this
        value and will not be a higher revision than this value.

    UserSid - Provides the SID of the user (owner).

    GroupSid - Provides the SID of the primary group.

    UserAccess - Specifies the accesses to be given to the user (owner).

    GroupAccess - Specifies the accesses to be given to the primary group.

    OtherAccess - Specifies the accesses to be given to others (WORLD).

    AclLength - Provides the length (in bytes) of the Acl buffer.

    Acl - Points to a buffer to receive the generated ACL.

    ReturnLength - Returns the actual length needed to store the resultant
        ACL.  If this length is greater than that specified in AclLength,
        then STATUS_BUFFER_TOO_SMALL is returned and no ACL is generated.

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_UNKNOWN_REVISION - The revision level specified is not supported
        by this service.

    STATUS_BUFFER_TOO_SMALL - Indicates the length of the output buffer
        wasn't large enough to hold the generated ACL.  The length needed
        is returned via the ReturnLength parameter.

--*/

{

    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    ULONG UserSidLength;
    ULONG GroupSidLength;
    ULONG WorldSidLength;
    ULONG RequiredAclSize;
    ULONG AceSize;
    ULONG CurrentAce;
    PACCESS_ALLOWED_ACE Ace;
    NTSTATUS Status;

    RTL_PAGED_CODE();

    if (!RtlValidSid( UserSid ) || !RtlValidSid( GroupSid )) {
        return( STATUS_INVALID_SID );
    }

    UserSidLength = SeLengthSid( UserSid );
    GroupSidLength = SeLengthSid( GroupSid );
    WorldSidLength = RtlLengthRequiredSid( 1 );

    //
    // Figure out how much room we need for an ACL and three
    // ACCESS_ALLOWED Ace's
    //

    RequiredAclSize = sizeof( ACL );

    AceSize = sizeof( ACCESS_ALLOWED_ACE ) - sizeof( ULONG );

    RequiredAclSize += (AceSize * 3)  +
                       UserSidLength  +
                       GroupSidLength +
                       WorldSidLength ;

    if (RequiredAclSize > AclLength) {
        *ReturnLength = RequiredAclSize;
        return( STATUS_BUFFER_TOO_SMALL );
    }

    //
    // The passed buffer is big enough, build the ACL in it.
    //

    Status = RtlCreateAcl(
                 Acl,
                 RequiredAclSize,
                 AclRevision
                 );

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    CurrentAce = (ULONG)Acl + sizeof( ACL );
    Ace = (PACCESS_ALLOWED_ACE)CurrentAce;

    //
    // Build the user (owner) ACE
    //

    Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    Ace->Header.AceSize = (USHORT)(UserSidLength + AceSize);
    Ace->Header.AceFlags = 0;

    Ace->Mask = UserAccess;

    RtlCopyMemory(
        (PVOID)(Ace->SidStart),
        UserSid,
        UserSidLength
        );

    CurrentAce += (ULONG)(Ace->Header.AceSize);
    Ace = (PACCESS_ALLOWED_ACE)CurrentAce;

    //
    // Build the group ACE
    //

    Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    Ace->Header.AceSize = (USHORT)(GroupSidLength + AceSize);
    Ace->Header.AceFlags = 0;

    Ace->Mask = GroupAccess;

    RtlCopyMemory(
        (PVOID)(Ace->SidStart),
        GroupSid,
        GroupSidLength
        );

    CurrentAce += (ULONG)(Ace->Header.AceSize);
    Ace = (PACCESS_ALLOWED_ACE)CurrentAce;

    //
    // Build the World ACE
    //

    Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    Ace->Header.AceSize = (USHORT)(GroupSidLength + AceSize);
    Ace->Header.AceFlags = 0;

    Ace->Mask = OtherAccess;

    RtlInitializeSid(
        (PSID)(Ace->SidStart),
        &WorldSidAuthority,
        1
        );

    *(RtlSubAuthoritySid((PSID)(Ace->SidStart), 0 )) = SECURITY_WORLD_RID;

    return( STATUS_SUCCESS );

}

NTSTATUS
RtlInterpretPosixAcl(
    IN ULONG AclRevision,
    IN PSID UserSid,
    IN PSID GroupSid,
    IN PACL Acl,
    OUT PACCESS_MASK UserAccess,
    OUT PACCESS_MASK GroupAccess,
    OUT PACCESS_MASK OtherAccess
    )
/*++

Routine Description:

    NOTE: THIS ROUTINE IS STILL BEING SPEC'D.

    Interpret an ACL representing Posix protection, returning AccessMasks.
    Use security account IDs (SIDs) for object owner and primary group
    identification.

    This algorithm will pick up the first match of a given SID and ignore
    all further matches of that SID.  The first unrecognized SID becomes
    the "other" SID.

Arguments:

    AclRevision - Indicates the ACL revision level of the access masks to
        be returned.

    UserSid - Provides the SID of the user (owner).

    GroupSid - Provides the SID of the primary group.

    Acl - Points to a buffer containing the ACL to interpret.

    UserAccess - Receives the accesses allowed for the user (owner).

    GroupAccess - Receives the accesses allowed for the primary group.

    OtherAccess - Receives the accesses allowed for others (WORLD).

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_UNKNOWN_REVISION - The revision level specified is not supported
        by this service.

    STATUS_EXTRENEOUS_INFORMATION - This warning status value indicates the
        ACL contained protection or other information unrelated to Posix
        style protection.  This is a warning only.  The interpretation was
        otherwise successful and all access masks were returned.

    STATUS_COULD_NOT_INTERPRET - Indicates the ACL does not contain
        sufficient Posix style (user/group) protection information.  The
        ACL could not be interpreted.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN UserFound = FALSE;
    BOOLEAN GroupFound = FALSE;
    BOOLEAN OtherFound = FALSE;
    ULONG i;
    PKNOWN_ACE Ace;

    RTL_PAGED_CODE();

    if (AclRevision != ACL_REVISION2) {
        return( STATUS_UNKNOWN_REVISION );
    }

    if (Acl->AceCount > 3) {
        Status = STATUS_EXTRANEOUS_INFORMATION;
    }

    for (i=0, Ace = FirstAce( Acl );
        (i < Acl->AceCount) && (!UserFound || !GroupFound || !OtherFound);
        i++, Ace = NextAce( Ace )) {

        if (Ace->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) {
            Status = STATUS_EXTRANEOUS_INFORMATION;
            continue;
        }

        if (RtlEqualSid(
               (PSID)(Ace->SidStart),
               UserSid
               ) && !UserFound) {

            *UserAccess = Ace->Mask;
            UserFound = TRUE;
            continue;
        }

        if (RtlEqualSid(
               (PSID)(Ace->SidStart),
               GroupSid
               ) && !GroupFound) {

            *GroupAccess = Ace->Mask;
            GroupFound = TRUE;
            continue;
        }

        //
        // It isn't the user, and it isn't the group, pick it up
        // as "other"
        //

        if (!OtherFound) {
            *OtherAccess = Ace->Mask;
            OtherFound = TRUE;
            continue;
        }

    }

    //
    // Make sure we got everything we need, error otherwise
    //

    if (!UserFound || !GroupFound || !OtherFound) {
        Status = STATUS_COULD_NOT_INTERPRET;
    }

    return( Status );

}

#endif // 0


//
//  Internal support routine
//

BOOLEAN
RtlFirstFreeAce (
    IN PACL Acl,
    OUT PVOID *FirstFree
    )

/*++

Routine Description:

    This routine returns a pointer to the first free byte in an Acl
    or NULL if the acl is ill-formed.  If the Acl is full then the
    return pointer is to the byte immediately following the acl, and
    TRUE will be returned.

Arguments:

    Acl - Supplies a pointer to the Acl to examine

    FirstFree - Receives a pointer to the first free position in the Acl

Return Value:

    BOOLEAN - TRUE if the Acl is well formed and FALSE otherwise

--*/

{
    PACE_HEADER Ace;
    ULONG i;

    RTL_PAGED_CODE();

    //
    //  To find the first free spot in the Acl we need to search for
    //  the last ace.  We do this by zooming down the list until
    //  we've exhausted the ace count or the ace size (which ever comes
    //  first).  In the following loop Ace points to the next spot
    //  for an Ace and I is the ace index
    //

    *FirstFree = NULL;

    for ( i=0, Ace = FirstAce( Acl );
          i < Acl->AceCount;
          i++, Ace = NextAce( Ace )) {

        //
        //  Check to make sure we haven't overrun the Acl buffer
        //  with our Ace pointer.  If we have then our input is bogus.
        //

        if (Ace >= (PACE_HEADER)((PUCHAR)Acl + Acl->AclSize)) {

            return FALSE;

        }

    }

    //
    //  Now Ace points to the first free spot in the Acl so set the
    //  output variable and check to make sure it is still in the Acl
    //  or just one beyond the end of the acl (i.e., the acl is full).
    //

    if (Ace <= (PACE_HEADER)((PUCHAR)Acl + Acl->AclSize)) {

        *FirstFree = Ace;
    }

    //
    //  The Acl is well formed so return the first free spot we've found
    //  (or NULL if there is no free space for another ACE)
    //

    return TRUE;

}


//
//  Internal support routine
//

VOID
RtlpAddData (
    IN PVOID From,
    IN ULONG FromSize,
    IN PVOID To,
    IN ULONG ToSize
    )

/*++

Routine Description:

    This routine copies data to a string of bytes.  It does this by moving
    over data in the to string so that the from string will fit.  It also
    assumes that the checks that the data will fit in memory have already
    been done.  Pictorally the results are as follows.

    Before:

        From -> ffffffffff

        To   -> tttttttttttttttt

    After:

        From -> ffffffffff

        To   -> fffffffffftttttttttttttttt

Arguments:

    From - Supplies a pointer to the source buffer

    FromSize - Supplies the size of the from buffer in bytes

    To - Supplies a pointer to the destination buffer

    ToSize - Supplies the size of the to buffer in bytes

Return Value:

    None

--*/

{
    LONG i;

    //
    //  Shift over the To buffer enough to fit in the From buffer
    //

    for (i = ToSize - 1; i >= 0; i--) {

        ((PUCHAR)To)[i+FromSize] = ((PUCHAR)To)[i];
    }

    //
    //  Now copy over the From buffer
    //

    for (i = 0; (ULONG)i < FromSize; i += 1) {

        ((PUCHAR)To)[i] = ((PUCHAR)From)[i];

    }

    //
    //  and return to our caller
    //

    return;

}


//
//  Internal support routine
//

VOID
RtlpDeleteData (
    IN PVOID Data,
    IN ULONG RemoveSize,
    IN ULONG TotalSize
    )

/*++

Routine Description:

    This routine deletes a string of bytes from the front of a data buffer
    and compresses the data.  It also zeros out the part of the string
    that is no longer in use.  Pictorially the results are as follows

    Before:

        Data       = DDDDDddddd
        RemoveSize = 5
        TotalSize  = 10

    After:

        Data      = ddddd00000

Arguments:

    Data - Supplies a pointer to the data being altered

    RemoveSize - Supplies the number of bytes to delete from the front
        of the data buffer

    TotalSize - Supplies the total number of bytes in the data buffer
        before the delete operation

Return Value:

    None

--*/

{
    ULONG i;

    //
    //  Shift over the buffer to remove the amount
    //

    for (i = RemoveSize; i < TotalSize; i++) {

        ((PUCHAR)Data)[i-RemoveSize] = ((PUCHAR)Data)[i];

    }

    //
    //  Now as a safety precaution we'll zero out the rest of the string
    //

    for (i = TotalSize - RemoveSize; i < TotalSize; i++) {

        ((PUCHAR)Data)[i] = 0;
    }

    //
    //  And return to our caller
    //

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\avltable.c ===
/*++

Copyright (c) 1990, 1999  Microsoft Corporation

Module Name:

    AvlTable.c

Abstract:

    This module implements a new version of the generic table package based on balanced
    binary trees (later named AVL), as described in Knuth, "The Art of Computer Programming,
    Volume 3, Sorting and Searching", and refers directly to algorithms as they are presented
    in the second edition Copyrighted in 1973.  Whereas gentable.c relys on splay.c for
    its tree support, this module is self-contained in that it implements the balanced
    binary trees directly.

Author:

    Tom Miller      [TomM]      17-March-1999
        (much of the non-AVL related code in this module is based on gentable.c by GaryKi
        and revised by TonyE)

Environment:

    Pure Utility Routines

--*/

#include <nt.h>

#include <ntrtl.h>

#pragma pack(8)

//
//  The checkit routine or macro may be defined to check occurrences of the link pointers for
//  valid pointer values, if structures are being corrupted.
//

#if 0
PVOID
checkit(PVOID p)
{
    if (p != NULL) {
        ASSERT(!FlagOn((ULONG)p, 3) && FlagOn((ULONG)p, 0x80000000));
    }
    return p;
}
#else
#define checkit(p) (p)
#endif

//
//  Build a table of the best case efficiency of a balanced binary tree, holding the
//  most possible nodes that can possibly be held in a binary tree with a given number
//  of levels.  The answer is always (2**n) - 1.
//
//  (Used for debug only.)
//

ULONG BestCaseFill[33] = {  0,          1,          3,          7,          0xf,        0x1f,       0x3f,       0x7f,
                            0xff,       0x1ff,      0x3ff,      0x7ff,      0xfff,      0x1fff,     0x3fff,     0x7fff,
                            0xffff,     0x1ffff,    0x3ffff,    0x7ffff,    0xfffff,    0x1fffff,   0x3fffff,   0x7fffff,
                            0xffffff,   0x1ffffff,  0x3ffffff,  0x7ffffff,  0xfffffff,  0x1fffffff, 0x3fffffff, 0x7fffffff,
                            0xffffffff  };

//
//  Build a table of the worst case efficiency of a balanced binary tree, holding the
//  fewest possible nodes that can possibly be contained in a balanced binary tree with
//  the given number of levels.  After the first two levels, each level n is obviously
//  occupied by a root node, plus one subtree the size of level n-1, and another subtree
//  which is the size of n-2, i.e.:
//
//      WorstCaseFill[n] = 1 + WorstCaseFill[n-1] + WorstCaseFill[n-2]
//
//  The efficiency of a typical balanced binary tree will normally fall between the two
//  extremes, typically closer to the best case.  Note however that even with the worst
//  case, it only takes 32 compares to find an element in a worst case tree populated with
//  ~3.5M nodes.  Unbalanced trees and splay trees, on the other hand, can and will sometimes
//  degenerate to a straight line, requiring on average n/2 compares to find a node.
//
//  A specific case (that will frequently occur in TXF), is one where the nodes are inserted
//  in collated order.  In this case an unbalanced or a splay tree will generate a straight
//  line, yet the balanced binary tree will always create a perfectly balanced tree (best-case
//  fill) in this situation.
//
//  (Used for debug only.)
//

ULONG WorstCaseFill[33] = { 0,          1,          2,          4,          7,          12,         20,         33,
                            54,         88,         143,        232,        376,        609,        986,        1596,
                            2583,       4180,       6764,       10945,      17710,      28656,      46367,      75024,
                            121392,     196417,     317810,     514228,     832039,     1346268,    2178308,    3524577,
                            5702886     };

//
//  This structure is the header for a generic table entry.
//  Align this structure on a 8 byte boundary so the user
//  data is correctly aligned.
//

typedef struct _TABLE_ENTRY_HEADER {

    RTL_BALANCED_LINKS BalancedLinks;
    LONGLONG UserData;

} TABLE_ENTRY_HEADER, *PTABLE_ENTRY_HEADER;

#pragma pack()

//
//  The default matching function which matches everything.
//

NTSTATUS
MatchAll (
    IN PRTL_AVL_TABLE Table,
    IN PVOID P1,
    IN PVOID P2
    )

{
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(Table);
    UNREFERENCED_PARAMETER(P1);
    UNREFERENCED_PARAMETER(P2);
}


TABLE_SEARCH_RESULT
FindNodeOrParent(
    IN PRTL_AVL_TABLE Table,
    IN PVOID Buffer,
    OUT PRTL_BALANCED_LINKS *NodeOrParent
    )

/*++

Routine Description:

    This routine is used by all of the routines of the generic
    table package to locate the a node in the tree.  It will
    find and return (via the NodeOrParent parameter) the node
    with the given key, or if that node is not in the tree it
    will return (via the NodeOrParent parameter) a pointer to
    the parent.

Arguments:

    Table - The generic table to search for the key.

    Buffer - Pointer to a buffer holding the key.  The table
             package doesn't examine the key itself.  It leaves
             this up to the user supplied compare routine.

    NodeOrParent - Will be set to point to the node containing the
                   the key or what should be the parent of the node
                   if it were in the tree.  Note that this will *NOT*
                   be set if the search result is TableEmptyTree.

Return Value:

    TABLE_SEARCH_RESULT - TableEmptyTree: The tree was empty.  NodeOrParent
                                          is *not* altered.

                          TableFoundNode: A node with the key is in the tree.
                                          NodeOrParent points to that node.

                          TableInsertAsLeft: Node with key was not found.
                                             NodeOrParent points to what would be
                                             parent.  The node would be the left
                                             child.

                          TableInsertAsRight: Node with key was not found.
                                              NodeOrParent points to what would be
                                              parent.  The node would be the right
                                              child.

--*/

{

    if (RtlIsGenericTableEmptyAvl(Table)) {

        return TableEmptyTree;

    } else {

        //
        //  Used as the iteration variable while stepping through
        //  the generic table.
        //

        PRTL_BALANCED_LINKS NodeToExamine = Table->BalancedRoot.RightChild;

        //
        //  Just a temporary.  Hopefully a good compiler will get
        //  rid of it.
        //

        PRTL_BALANCED_LINKS Child;

        //
        //  Holds the value of the comparasion.
        //

        RTL_GENERIC_COMPARE_RESULTS Result;

        ULONG NumberCompares = 0;

        while (TRUE) {

            //
            //  Compare the buffer with the key in the tree element.
            //

            Result = Table->CompareRoutine(
                         Table,
                         Buffer,
                         &((PTABLE_ENTRY_HEADER) NodeToExamine)->UserData
                         );

            //
            //  Make sure the depth of tree is correct.
            //

            ASSERT(++NumberCompares <= Table->DepthOfTree);

            if (Result == GenericLessThan) {

                if (Child = NodeToExamine->LeftChild) {

                    NodeToExamine = Child;

                } else {

                    //
                    //  Node is not in the tree.  Set the output
                    //  parameter to point to what would be its
                    //  parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return TableInsertAsLeft;
                }

            } else if (Result == GenericGreaterThan) {

                if (Child = NodeToExamine->RightChild) {

                    NodeToExamine = Child;

                } else {

                    //
                    //  Node is not in the tree.  Set the output
                    //  parameter to point to what would be its
                    //  parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return TableInsertAsRight;
                }

            } else {

                //
                //  Node is in the tree (or it better be because of the
                //  assert).  Set the output parameter to point to
                //  the node and tell the caller that we found the node.
                //

                ASSERT(Result == GenericEqual);
                *NodeOrParent = NodeToExamine;
                return TableFoundNode;
            }
        }
    }
}


VOID
PromoteNode (
    IN PRTL_BALANCED_LINKS C
    )

/*++

Routine Description:

    This routine performs the fundamental adjustment required for balancing
    the binary tree during insert and delete operations.  Simply put, the designated
    node is promoted in such a way that it rises one level in the tree and its parent
    drops one level in the tree, becoming now the child of the designated node.
    Generally the path length to the subtree "opposite" the original parent.  Balancing
    occurs as the caller chooses which nodes to promote according to the balanced tree
    algorithms from Knuth.

    This is not the same as a splay operation, typically a splay "promotes" a designated
    node twice.

    Note that the pointer to the root node of the tree is assumed to be contained in a
    RTL_BALANCED_LINK structure itself, to allow the algorithms below to change the root
    of the tree without checking for special cases.  Note also that this is an internal
    routine, and the caller guarantees that it never requests to promote the root itself.

    This routine only updates the tree links; the caller must update the balance factors
    as appropriate.

Arguments:

    C - pointer to the child node to be promoted in the tree.

Return Value:

    None.

--*/

{
    PRTL_BALANCED_LINKS P, G;

    //
    //  Capture the current parent and grandparent (may be the root).
    //

    P = C->Parent;
    G = P->Parent;

    //
    //  Break down the promotion into two cases based upon whether C is a left or right child.
    //

    if (P->LeftChild == C) {

        //
        //  This promotion looks like this:
        //
        //          G           G
        //          |           |
        //          P           C
        //         / \   =>    / \
        //        C   z       x   P
        //       / \             / \
        //      x   y           y   z
        //

        P->LeftChild = checkit(C->RightChild);

        if (P->LeftChild != NULL) {
            P->LeftChild->Parent = checkit(P);
        }

        C->RightChild = checkit(P);

        //
        //  Fall through to update parent and G <-> C relationship in common code.
        //

    } else {

        ASSERT(P->RightChild == C);

        //
        //  This promotion looks like this:
        //
        //        G               G
        //        |               |
        //        P               C
        //       / \     =>      / \
        //      x   C           P   z
        //         / \         / \
        //        y   z       x   y
        //

        P->RightChild = checkit(C->LeftChild);

        if (P->RightChild != NULL) {
            P->RightChild->Parent = checkit(P);
        }

        C->LeftChild = checkit(P);
    }

    //
    //  Update parent of P, for either case above.
    //

    P->Parent = checkit(C);

    //
    //  Finally update G <-> C links for either case above.
    //

    if (G->LeftChild == P) {
        G->LeftChild = checkit(C);
    } else {
        ASSERT(G->RightChild == P);
        G->RightChild = checkit(C);
    }
    C->Parent = checkit(G);
}


ULONG
RebalanceNode (
    IN PRTL_BALANCED_LINKS S
    )

/*++

Routine Description:

    This routine performs a rebalance around the input node S, for which the
    Balance factor has just effectively become +2 or -2.  When called, the
    Balance factor still has a value of +1 or -1, but the respective longer
    side has just become one longer as the result of an insert or delete operation.

    This routine effectively implements steps A7.iii (test for Case 1 or Case 2) and
    steps A8 and A9 of Knuths balanced insertion algorithm, plus it handles Case 3
    identified in the delete section, which can only happen on deletes.

    The trick is, to convince yourself that while travling from the insertion point
    at the bottom of the tree up, that there are only these two cases, and that when
    traveling up from the deletion point, that there are just these three cases.
    Knuth says it is obvious!

Arguments:

    S - pointer to the node which has just become unbalanced.

Return Value:

    TRUE if Case 3 was detected (causes delete algorithm to terminate).

--*/

{
    PRTL_BALANCED_LINKS R, P;
    CHAR a;

    //
    //  Capture which side is unbalanced.
    //

    a = S->Balance;
    if (a == +1) {
        R = S->RightChild;
    } else {
        R = S->LeftChild;
    }

    //
    //  If the balance of R and S are the same (Case 1 in Knuth) then a single
    //  promotion of R will do the single rotation.  (Step A8, A10)
    //
    //  Here is a diagram of the Case 1 transformation, for a == +1 (a mirror
    //  image transformation occurs when a == -1), and where the subtree
    //  heights are h and h+1 as shown (++ indicates the node out of balance):
    //
    //                  |                   |
    //                  S++                 R
    //                 / \                 / \
    //               (h)  R+     ==>      S  (h+1)
    //                   / \             / \
    //                 (h) (h+1)       (h) (h)
    //
    //  Note that on an insert we can hit this case by inserting an item in the
    //  right subtree of R.  The original height of the subtree before the insert
    //  was h+2, and it is still h+2 after the rebalance, so insert rebalancing may
    //  terminate.
    //
    //  On a delete we can hit this case by deleting a node from the left subtree
    //  of S.  The height of the subtree before the delete was h+3, and after the
    //  rebalance it is h+2, so rebalancing must continue up the tree.
    //

    if (R->Balance == a) {

        PromoteNode( R );
        R->Balance = 0;
        S->Balance = 0;
        return FALSE;

    //
    //  Otherwise, we have to promote the appropriate child of R twice (Case 2
    //  in Knuth).  (Step A9, A10)
    //
    //  Here is a diagram of the Case 2 transformation, for a == +1 (a mirror
    //  image transformation occurs when a == -1), and where the subtree
    //  heights are h and h-1 as shown.  There are actually two minor subcases,
    //  differing only in the original balance of P (++ indicates the node out
    //  of balance).
    //
    //                  |                   |
    //                  S++                 P
    //                 / \                 / \
    //                /   \               /   \
    //               /     \             /     \
    //             (h)      R-   ==>    S-      R
    //                     / \         / \     / \
    //                    P+ (h)     (h)(h-1)(h) (h)
    //                   / \
    //               (h-1) (h)
    //
    //
    //                  |                   |
    //                  S++                 P
    //                 / \                 / \
    //                /   \               /   \
    //               /     \             /     \
    //             (h)      R-   ==>    S       R+
    //                     / \         / \     / \
    //                    P- (h)     (h) (h)(h-1)(h)
    //                   / \
    //                 (h) (h-1)
    //
    //  Note that on an insert we can hit this case by inserting an item in the
    //  left subtree of R.  The original height of the subtree before the insert
    //  was h+2, and it is still h+2 after the rebalance, so insert rebalancing may
    //  terminate.
    //
    //  On a delete we can hit this case by deleting a node from the left subtree
    //  of S.  The height of the subtree before the delete was h+3, and after the
    //  rebalance it is h+2, so rebalancing must continue up the tree.
    //

    }  else if (R->Balance == -a) {

        //
        //  Pick up the appropriate child P for the double rotation (Link(-a,R)).
        //

        if (a == 1) {
            P = R->LeftChild;
        } else {
            P = R->RightChild;
        }

        //
        //  Promote him twice to implement the double rotation.
        //

        PromoteNode( P );
        PromoteNode( P );

        //
        //  Now adjust the balance factors.
        //

        S->Balance = 0;
        R->Balance = 0;
        if (P->Balance == a) {
            S->Balance = -a;
        } else if (P->Balance == -a) {
            R->Balance = a;
        }

        P->Balance = 0;
        return FALSE;

    //
    //  Otherwise this is Case 3 which can only happen on Delete (identical to Case 1 except
    //  R->Balance == 0).  We do a single rotation, adjust the balance factors appropriately,
    //  and return TRUE.  Note that the balance of S stays the same.
    //
    //  Here is a diagram of the Case 3 transformation, for a == +1 (a mirror
    //  image transformation occurs when a == -1), and where the subtree
    //  heights are h and h+1 as shown (++ indicates the node out of balance):
    //
    //                  |                   |
    //                  S++                 R-
    //                 / \                 / \
    //               (h)  R      ==>      S+ (h+1)
    //                   / \             / \
    //                (h+1)(h+1)       (h) (h+1)
    //
    //  This case can not occur on an insert, because it is impossible for a single insert to
    //  balance R, yet somehow grow the right subtree of S at the same time.  As we move up
    //  the tree adjusting balance factors after an insert, we terminate the algorithm if a
    //  node becomes balanced, because that means the subtree length did not change!
    //
    //  On a delete we can hit this case by deleting a node from the left subtree
    //  of S.  The height of the subtree before the delete was h+3, and after the
    //  rebalance it is still h+3, so rebalancing may terminate in the delete path.
    //

    } else {

        PromoteNode( R );
        R->Balance = -a;
        return TRUE;
    }
}


VOID
DeleteNodeFromTree (
    IN PRTL_AVL_TABLE Table,
    IN PRTL_BALANCED_LINKS NodeToDelete
    )

/*++

Routine Description:

    This routine deletes the specified node from the balanced tree, rebalancing
    as necessary.  If the NodeToDelete has at least one NULL child pointers, then
    it is chosen as the EasyDelete, otherwise a subtree predecessor or successor
    is found as the EasyDelete.  In either case the EasyDelete is deleted
    and the tree is rebalanced.  Finally if the NodeToDelete was different
    than the EasyDelete, then the EasyDelete is linked back into the tree in
    place of the NodeToDelete.

Arguments:

    Table - The generic table in which the delete is to occur.

    NodeToDelete - Pointer to the node which the caller wishes to delete.

Return Value:

    None.

--*/

{
    PRTL_BALANCED_LINKS EasyDelete;
    PRTL_BALANCED_LINKS P;
    CHAR a;

    //
    //  If the NodeToDelete has at least one NULL child pointer, then we can
    //  delete it directly.
    //

    if ((NodeToDelete->LeftChild == NULL) || (NodeToDelete->RightChild == NULL)) {

        EasyDelete = NodeToDelete;

    //
    //  Otherwise, we may as well pick the longest side to delete from (if one is
    //  is longer), as that reduces the probability that we will have to rebalance.
    //

    } else if (NodeToDelete->Balance >= 0) {

        //
        //  Pick up the subtree successor.
        //

        EasyDelete = NodeToDelete->RightChild;
        while (EasyDelete->LeftChild != NULL) {
            EasyDelete = EasyDelete->LeftChild;
        }
    } else {

        //
        //  Pick up the subtree predecessor.
        //

        EasyDelete = NodeToDelete->LeftChild;
        while (EasyDelete->RightChild != NULL) {
            EasyDelete = EasyDelete->RightChild;
        }
    }

    //
    //  Rebalancing must know which side of the first parent the delete occurred
    //  on.  Assume it is the left side and otherwise correct below.
    //

    a = -1;

    //
    //  Now we can do the simple deletion for the no left child case.
    //

    if (EasyDelete->LeftChild == NULL) {

        if (RtlIsLeftChild(EasyDelete)) {
            EasyDelete->Parent->LeftChild = checkit(EasyDelete->RightChild);
        } else {
            EasyDelete->Parent->RightChild = checkit(EasyDelete->RightChild);
            a = 1;
        }

        if (EasyDelete->RightChild != NULL) {
            EasyDelete->RightChild->Parent = checkit(EasyDelete->Parent);
        }

    //
    //  Now we can do the simple deletion for the no right child case,
    //  plus we know there is a left child.
    //

    } else {

        if (RtlIsLeftChild(EasyDelete)) {
            EasyDelete->Parent->LeftChild = checkit(EasyDelete->LeftChild);
        } else {
            EasyDelete->Parent->RightChild = checkit(EasyDelete->LeftChild);
            a = 1;
        }

        EasyDelete->LeftChild->Parent = checkit(EasyDelete->Parent);
    }

    //
    //  For delete rebalancing, set the balance at the root to 0 to properly
    //  terminate the rebalance without special tests, and to be able to detect
    //  if the depth of the tree actually decreased.
    //

    Table->BalancedRoot.Balance = 0;
    P = EasyDelete->Parent;

    //
    //  Loop until the tree is balanced.
    //

    while (TRUE) {

        //
        //  First handle the case where the tree became more balanced.  Zero
        //  the balance factor, calculate a for the next loop and move on to
        //  the parent.
        //

        if (P->Balance == a) {

            P->Balance = 0;

        //
        //  If this node is curently balanced, we can show it is now unbalanced
        //  and terminate the scan since the subtree length has not changed.
        //  (This may be the root, since we set Balance to 0 above!)
        //

        } else if (P->Balance == 0) {

            P->Balance = -a;

            //
            //  If we shortened the depth all the way back to the root, then the tree really
            //  has one less level.
            //

            if (Table->BalancedRoot.Balance != 0) {
                Table->DepthOfTree -= 1;
            }

            break;

        //
        //  Otherwise we made the short side 2 levels less than the long side,
        //  and rebalancing is required.  On return, some node has been promoted
        //  to above node P.  If Case 3 from Knuth was not encountered, then we
        //  want to effectively resume rebalancing from P's original parent which
        //  is effectively its grandparent now.
        //

        } else {

            //
            //  We are done if Case 3 was hit, i.e., the depth of this subtree is
            //  now the same as before the delete.
            //

            if (RebalanceNode(P)) {
                break;
            }

            P = P->Parent;
        }

        a = -1;
        if (RtlIsRightChild(P)) {
            a = 1;
        }
        P = P->Parent;
    }

    //
    //  Finally, if we actually deleted a predecessor/successor of the NodeToDelete,
    //  we will link him back into the tree to replace NodeToDelete before returning.
    //  Note that NodeToDelete did have both child links filled in, but that may no
    //  longer be the case at this point.
    //

    if (NodeToDelete != EasyDelete) {
        *EasyDelete = *NodeToDelete;
        if (RtlIsLeftChild(NodeToDelete)) {
            EasyDelete->Parent->LeftChild = checkit(EasyDelete);
        } else {
            ASSERT(RtlIsRightChild(NodeToDelete));
            EasyDelete->Parent->RightChild = checkit(EasyDelete);
        }
        if (EasyDelete->LeftChild != NULL) {
            EasyDelete->LeftChild->Parent = checkit(EasyDelete);
        }
        if (EasyDelete->RightChild != NULL) {
            EasyDelete->RightChild->Parent = checkit(EasyDelete);
        }
    }
}


PRTL_BALANCED_LINKS
RealSuccessor (
    IN PRTL_BALANCED_LINKS Links
    )

/*++

Routine Description:

    The RealSuccessor function takes as input a pointer to a balanced link
    in a tree and returns a pointer to the successor of the input node within
    the entire tree.  If there is not a successor, the return value is NULL.

Arguments:

    Links - Supplies a pointer to a balanced link in a tree.

Return Value:

    PRTL_BALANCED_LINKS - returns a pointer to the successor in the entire tree

--*/

{
    PRTL_BALANCED_LINKS Ptr;

    /*
        first check to see if there is a right subtree to the input link
        if there is then the real successor is the left most node in
        the right subtree.  That is find and return S in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  S
                   \
    */

    if ((Ptr = Links->RightChild) != NULL) {

        while (Ptr->LeftChild != NULL) {
            Ptr = Ptr->LeftChild;
        }

        return Ptr;

    }

    /*
        we do not have a right child so check to see if have a parent and if
        so find the first ancestor that we are a left decendent of. That
        is find and return S in the following diagram

                       S
                      /
                     .
                      .
                       .
                      Links

        Note that this code depends on how the BalancedRoot is initialized, which is
        Parent points to self, and the RightChild points to an actual node which is
        the root of the tree, and LeftChild does not point to self.
    */

    Ptr = Links;
    while (RtlIsRightChild(Ptr)) {
        Ptr = Ptr->Parent;
    }

    if (RtlIsLeftChild(Ptr)) {
        return Ptr->Parent;
    }

    //
    //  otherwise we are do not have a real successor so we simply return
    //  NULL.
    //
    //  This can only occur when we get back to the root, and we can tell
    //  that since the Root is its own parent.
    //

    ASSERT(Ptr->Parent == Ptr);

    return NULL;
}


PRTL_BALANCED_LINKS
RealPredecessor (
    IN PRTL_BALANCED_LINKS Links
    )

/*++

Routine Description:

    The RealPredecessor function takes as input a pointer to a balanced link
    in a tree and returns a pointer to the predecessor of the input node
    within the entire tree.  If there is not a predecessor, the return value
    is NULL.

Arguments:

    Links - Supplies a pointer to a balanced link in a tree.

Return Value:

    PRTL_BALANCED_LINKS - returns a pointer to the predecessor in the entire tree

--*/

{
    PRTL_BALANCED_LINKS Ptr;

    /*
      first check to see if there is a left subtree to the input link
      if there is then the real predecessor is the right most node in
      the left subtree.  That is find and return P in the following diagram

                  Links
                   /
                  .
                   .
                    .
                     P
                    /
    */

    if ((Ptr = Links->LeftChild) != NULL) {

        while (Ptr->RightChild != NULL) {
            Ptr = Ptr->RightChild;
        }

        return Ptr;

    }

    /*
      we do not have a left child so check to see if have a parent and if
      so find the first ancestor that we are a right decendent of. That
      is find and return P in the following diagram

                       P
                        \
                         .
                        .
                       .
                    Links

        Note that this code depends on how the BalancedRoot is initialized, which is
        Parent points to self, and the RightChild points to an actual node which is
        the root of the tree.
    */

    Ptr = Links;
    while (RtlIsLeftChild(Ptr)) {
        Ptr = Ptr->Parent;
    }

    if (RtlIsRightChild(Ptr) && (Ptr->Parent->Parent != Ptr->Parent)) {
        return Ptr->Parent;
    }

    //
    //  otherwise we are do not have a real predecessor so we simply return
    //  NULL
    //

    return NULL;

}


VOID
RtlInitializeGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    IN PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    IN PRTL_AVL_FREE_ROUTINE FreeRoutine,
    IN PVOID TableContext
    )

/*++

Routine Description:

    The procedure InitializeGenericTableAvl takes as input an uninitialized
    generic table variable and pointers to the three user supplied routines.
    This must be called for every individual generic table variable before
    it can be used.

Arguments:

    Table - Pointer to the generic table to be initialized.

    CompareRoutine - User routine to be used to compare to keys in the
                     table.

    AllocateRoutine - User routine to call to allocate memory for a new
                      node in the generic table.

    FreeRoutine - User routine to call to deallocate memory for
                        a node in the generic table.

    TableContext - Supplies user supplied context for the table.

Return Value:

    None.

--*/

{

#ifdef NTFS_FREE_ASSERTS
    ULONG i;

    for (i=2; i < 33; i++) {
        ASSERT(WorstCaseFill[i] == (1 + WorstCaseFill[i-1] + WorstCaseFill[i-2]));
    }
#endif

    //
    //  Initialize each field of the Table parameter.
    //

    RtlZeroMemory( Table, sizeof(RTL_AVL_TABLE) );
    Table->BalancedRoot.Parent = &Table->BalancedRoot;
    Table->CompareRoutine = CompareRoutine;
    Table->AllocateRoutine = AllocateRoutine;
    Table->FreeRoutine = FreeRoutine;
    Table->TableContext = TableContext;

}


PVOID
RtlInsertElementGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN PVOID Buffer,
    IN CLONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL
    )

/*++

Routine Description:

    The function InsertElementGenericTableAvl will insert a new element
    in a table.  It does this by allocating space for the new element
    (this includes splay links), inserting the element in the table, and
    then returning to the user a pointer to the new element (which is
    the first available space after the splay links).  If an element
    with the same key already exists in the table the return value is a pointer
    to the old element.  The optional output parameter NewElement is used
    to indicate if the element previously existed in the table.  Note: the user
    supplied Buffer is only used for searching the table, upon insertion its
    contents are copied to the newly created element.  This means that
    pointer to the input buffer will not point to the new element.

Arguments:

    Table - Pointer to the table in which to (possibly) insert the
            key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

    BufferSize - The amount of space to allocate when the (possible)
                 insertion is made.  Note that if we actually do
                 not find the node and we do allocate space then we
                 will add the size of the BALANCED_LINKS to this buffer
                 size.  The user should really take care not to depend
                 on anything in the first sizeof(BALANCED_LINKS) bytes
                 of the memory allocated via the memory allocation
                 routine.

    NewElement - Optional Flag.  If present then it will be set to
                 TRUE if the buffer was not "found" in the generic
                 table.

Return Value:

    PVOID - Pointer to the user defined data.

--*/

{

    //
    //  Holds a pointer to the node in the table or what would be the
    //  parent of the node.
    //

    PRTL_BALANCED_LINKS NodeOrParent;

    //
    //  Holds the result of the table lookup.
    //

    TABLE_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Table,
                 Buffer,
                 &NodeOrParent
                 );

    //
    //  Call the full routine to do the real work.
    //

    return RtlInsertElementGenericTableFullAvl(
                Table,
                Buffer,
                BufferSize,
                NewElement,
                NodeOrParent,
                Lookup
                );
}


PVOID
RtlInsertElementGenericTableFullAvl (
    IN PRTL_AVL_TABLE Table,
    IN PVOID Buffer,
    IN CLONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL,
    IN PVOID NodeOrParent,
    IN TABLE_SEARCH_RESULT SearchResult
    )

/*++

Routine Description:

    The function InsertElementGenericTableFullAvl will insert a new element
    in a table.  It does this by allocating space for the new element
    (this includes splay links), inserting the element in the table, and
    then returning to the user a pointer to the new element.  If an element
    with the same key already exists in the table the return value is a pointer
    to the old element.  The optional output parameter NewElement is used
    to indicate if the element previously existed in the table.  Note: the user
    supplied Buffer is only used for searching the table, upon insertion its
    contents are copied to the newly created element.  This means that
    pointer to the input buffer will not point to the new element.
    This routine is passed the NodeOrParent and SearchResult from a
    previous RtlLookupElementGenericTableFullAvl.

Arguments:

    Table - Pointer to the table in which to (possibly) insert the
            key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

    BufferSize - The amount of space to allocate when the (possible)
                 insertion is made.  Note that if we actually do
                 not find the node and we do allocate space then we
                 will add the size of the BALANCED_LINKS to this buffer
                 size.  The user should really take care not to depend
                 on anything in the first sizeof(BALANCED_LINKS) bytes
                 of the memory allocated via the memory allocation
                 routine.

    NewElement - Optional Flag.  If present then it will be set to
                 TRUE if the buffer was not "found" in the generic
                 table.

   NodeOrParent - Result of prior RtlLookupElementGenericTableFullAvl.

   SearchResult - Result of prior RtlLookupElementGenericTableFullAvl.

Return Value:

    PVOID - Pointer to the user defined data.

--*/

{
    //
    //  Node will point to the splay links of what
    //  will be returned to the user.
    //

    PTABLE_ENTRY_HEADER NodeToReturn;

    if (SearchResult != TableFoundNode) {

        //
        //  We just check that the table isn't getting
        //  too big.
        //

        ASSERT(Table->NumberGenericTableElements != (MAXULONG-1));

        //
        //  The node wasn't in the (possibly empty) tree.
        //  Call the user allocation routine to get space
        //  for the new node.
        //

        NodeToReturn = Table->AllocateRoutine(
                           Table,
                           BufferSize+FIELD_OFFSET( TABLE_ENTRY_HEADER, UserData )
                           );

        //
        //  If the return is NULL, return NULL from here to indicate that
        //  the entry could not be added.
        //

        if (NodeToReturn == NULL) {

            if (ARGUMENT_PRESENT(NewElement)) {

                *NewElement = FALSE;
            }

            return(NULL);
        }

        RtlZeroMemory( NodeToReturn, sizeof(RTL_BALANCED_LINKS) );

        Table->NumberGenericTableElements++;

        //
        //  Insert the new node in the tree.
        //

        if (SearchResult == TableEmptyTree) {

            Table->BalancedRoot.RightChild = &NodeToReturn->BalancedLinks;
            NodeToReturn->BalancedLinks.Parent = &Table->BalancedRoot;
            ASSERT(Table->DepthOfTree == 0);
            Table->DepthOfTree = 1;

        } else {

            PRTL_BALANCED_LINKS R = &NodeToReturn->BalancedLinks;
            PRTL_BALANCED_LINKS S = (PRTL_BALANCED_LINKS)NodeOrParent;

            if (SearchResult == TableInsertAsLeft) {

                ((PRTL_BALANCED_LINKS)NodeOrParent)->LeftChild = checkit(&NodeToReturn->BalancedLinks);

            } else {

                ((PRTL_BALANCED_LINKS)NodeOrParent)->RightChild = checkit(&NodeToReturn->BalancedLinks);
            }

            NodeToReturn->BalancedLinks.Parent = NodeOrParent;

            //
            //  The above completes the standard binary tree insertion, which
            //  happens to correspond to steps A1-A5 of Knuth's "balanced tree
            //  search and insertion" algorithm.  Now comes the time to adjust
            //  balance factors and possibly do a single or double rotation as
            //  in steps A6-A10.

            //
            //  Set the Balance factor in the root to a convenient value
            //  to simplify loop control.
            //

            Table->BalancedRoot.Balance = -1;

            //
            //  Now loop to adjust balance factors and see if any balance operations
            //  must be performed, using NodeOrParent to ascend the tree.
            //

            while (TRUE) {

                CHAR a;

                //
                //  Calculate the next adjustment.
                //

                a = 1;
                if (RtlIsLeftChild(R)) {
                    a = -1;
                }

                //
                //  If this node was balanced, show that it is no longer and keep looping.
                //  This is essentially A6 of Knuth's algorithm, where he updates all of
                //  the intermediate nodes on the insertion path which previously had
                //  balance factors of 0.  We are looping up the tree via Parent pointers
                //  rather than down the tree as in Knuth.
                //

                if (S->Balance == 0) {

                    S->Balance = a;
                    R = S;
                    S = S->Parent;

                //
                //  If this node has the opposite balance, then the tree got more balanced
                //  (or we hit the root) and we are done.
                //

                } else if (S->Balance != a) {

                    //
                    //  Step A7.ii
                    //

                    S->Balance = 0;

                    //
                    //  If S is actually the root, then this means the depth of the tree
                    //  just increased by 1!  (This is essentially A7.i, but we just
                    //  initialized the root balance to force it through here.)
                    //

                    if (Table->BalancedRoot.Balance == 0) {
                        Table->DepthOfTree += 1;
                    }

                    break;

                //
                //  Otherwise the tree became unbalanced (path length differs by 2 below us)
                //  and we need to do one of the balancing operations, and then we are done.
                //  The RebalanceNode routine does steps A7.iii, A8 and A9.
                //

                } else {

                    RebalanceNode( S );
                    break;
                }
            }
        }

        //
        //  Copy the users buffer into the user data area of the table.
        //

        RtlCopyMemory( &NodeToReturn->UserData, Buffer, BufferSize );

    } else {

        NodeToReturn = NodeOrParent;
    }

    //
    //  Optionally return the NewElement boolean.
    //

    if (ARGUMENT_PRESENT(NewElement)) {
        *NewElement = ((SearchResult == TableFoundNode)?(FALSE):(TRUE));
    }

    //
    //  Sanity check tree size and depth.
    //

    ASSERT((Table->NumberGenericTableElements >= WorstCaseFill[Table->DepthOfTree]) &&
           (Table->NumberGenericTableElements <= BestCaseFill[Table->DepthOfTree]));

    //
    //  Insert the element on the ordered list;
    //

    return &NodeToReturn->UserData;
}


BOOLEAN
RtlDeleteElementGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function DeleteElementGenericTableAvl will find and delete an element
    from a generic table.  If the element is located and deleted the return
    value is TRUE, otherwise if the element is not located the return value
    is FALSE.  The user supplied input buffer is only used as a key in
    locating the element in the table.

Arguments:

    Table - Pointer to the table in which to (possibly) delete the
            memory accessed by the key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

Return Value:

    BOOLEAN - If the table contained the key then true, otherwise false.

--*/

{

    //
    //  Holds a pointer to the node in the table or what would be the
    //  parent of the node.
    //
    PRTL_BALANCED_LINKS NodeOrParent;

    //
    //  Holds the result of the table lookup.
    //
    TABLE_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Table,
                 Buffer,
                 &NodeOrParent
                 );

    if (Lookup != TableFoundNode) {

        return FALSE;

    } else {

        //
        //  Make RtlEnumerateGenericTableAvl safe by replacing the RestartKey
        //  with its predecessor if it gets deleted.  A NULL means return the
        //  first node in the tree.  (The Splay routines do not always correctly
        //  resume from predecessor on delete!)
        //

        if (NodeOrParent == Table->RestartKey) {
            Table->RestartKey = RealPredecessor( NodeOrParent );
        }

        //
        //  Make RtlEnumerateGenericTableLikeADirectory safe by incrementing the
        //  DeleteCount.
        //

        Table->DeleteCount += 1;

        //
        //  Delete the node from the splay tree.
        //

        DeleteNodeFromTree( Table, NodeOrParent );
        Table->NumberGenericTableElements--;

        //
        //  On all deletes, reset the ordered pointer to force a recount from 0.
        //

        Table->WhichOrderedElement = 0;
        Table->OrderedPointer = NULL;

        //
        //  Sanity check tree size and depth.
        //

        ASSERT((Table->NumberGenericTableElements >= WorstCaseFill[Table->DepthOfTree]) &&
               (Table->NumberGenericTableElements <= BestCaseFill[Table->DepthOfTree]));

        //
        //  The node has been deleted from the splay table.
        //  Now give the node to the user deletion routine.
        //  NOTE: We are giving the deletion routine a pointer
        //  to the splay links rather then the user data.  It
        //  is assumed that the deallocation is rather bad.
        //

        Table->FreeRoutine(Table,NodeOrParent);
        return TRUE;
    }
}


PVOID
RtlLookupElementGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function LookupElementGenericTable will find an element in a generic
    table.  If the element is located the return value is a pointer to
    the user defined structure associated with the element, otherwise if
    the element is not located the return value is NULL.  The user supplied
    input buffer is only used as a key in locating the element in the table.

Arguments:

    Table - Pointer to the users Generic table to search for the key.

    Buffer - Used for the comparasion.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{
    //
    //  Holds a pointer to the node in the table or what would be the
    //  parent of the node.
    //
    PRTL_BALANCED_LINKS NodeOrParent;

    //
    //  Holds the result of the table lookup.
    //
    TABLE_SEARCH_RESULT Lookup;

    return RtlLookupElementGenericTableFullAvl(
                Table,
                Buffer,
                &NodeOrParent,
                &Lookup
                );
}


PVOID
NTAPI
RtlLookupElementGenericTableFullAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    )

/*++

Routine Description:

    The function LookupElementGenericTableFullAvl will find an element in a generic
    table.  If the element is located the return value is a pointer to
    the user defined structure associated with the element.  If the element is not
    located then a pointer to the parent for the insert location is returned.  The
    user must look at the SearchResult value to determine which is being returned.
    The user can use the SearchResult and parent for a subsequent FullInsertElement
    call to optimize the insert.

Arguments:

    Table - Pointer to the users Generic table to search for the key.

    Buffer - Used for the comparasion.

    NodeOrParent - Address to store the desired Node or parent of the desired node.

    SearchResult - Describes the relationship of the NodeOrParent with the desired Node.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{

    //
    //  Lookup the element and save the result.
    //

    *SearchResult = FindNodeOrParent(
                        Table,
                        Buffer,
                        (PRTL_BALANCED_LINKS *)NodeOrParent
                        );

    if (*SearchResult != TableFoundNode) {

        return NULL;

    } else {

        //
        //  Return a pointer to the user data.
        //

        return &((PTABLE_ENTRY_HEADER)*NodeOrParent)->UserData;
    }
}


PVOID
RtlEnumerateGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN BOOLEAN Restart
    )

/*++

Routine Description:

    The function EnumerateGenericTableAvl will return to the caller one-by-one
    the elements of of a table.  The return value is a pointer to the user
    defined structure associated with the element.  The input parameter
    Restart indicates if the enumeration should start from the beginning
    or should return the next element.  If there are no more new elements to
    return the return value is NULL.  As an example of its use, to enumerate
    all of the elements in a table the user would write:

        for (ptr = EnumerateGenericTableAvl(Table,TRUE);
             ptr != NULL;
             ptr = EnumerateGenericTableAvl(Table, FALSE)) {
                :
        }

    For a summary of when to use each of the four enumeration routines, see
    RtlEnumerateGenericTableLikeADirectory.

Arguments:

    Table - Pointer to the generic table to enumerate.

    Restart - Flag that if true we should start with the least
              element in the tree otherwise, return we return
              a pointer to the user data for the root and make
              the real successor to the root the new root.

Return Value:

    PVOID - Pointer to the user data.

--*/

{
    //
    //  If he said Restart, then zero Table->RestartKey before calling the
    //  common routine.
    //

    if (Restart) {
        Table->RestartKey = NULL;
    }

    return RtlEnumerateGenericTableWithoutSplayingAvl( Table, &Table->RestartKey );
}


BOOLEAN
RtlIsGenericTableEmptyAvl (
    IN PRTL_AVL_TABLE Table
    )

/*++

Routine Description:

    The function IsGenericTableEmptyAvl will return to the caller TRUE if
    the input table is empty (i.e., does not contain any elements) and
    FALSE otherwise.

Arguments:

    Table - Supplies a pointer to the Generic Table.

Return Value:

    BOOLEAN - if enabled the tree is empty.

--*/

{
    //
    //  Table is empty if the root pointer is null.
    //

    return ((Table->NumberGenericTableElements)?(FALSE):(TRUE));
}


PVOID
RtlGetElementGenericTableAvl (
    IN PRTL_AVL_TABLE Table,
    IN ULONG I
    )

/*++

Routine Description:


    The function GetElementGenericTableAvl will return the i'th element in the
    generic table by collation order.  I = 0 implies the first/lowest element,
    I = (RtlNumberGenericTableElements2(Table)-1) will return the last/highest
    element in the generic table.  The type of I is ULONG.  Values
    of I > than (NumberGenericTableElements(Table)-1) will return NULL.  If
    an arbitrary element is deleted from the generic table it will cause
    all elements inserted after the deleted element to "move up".

    For a summary of when to use each of the four enumeration routines, see
    RtlEnumerateGenericTableLikeADirectory.

    NOTE!!!  THE ORIGINAL GENERIC TABLE PACKAGE RETURNED ITEMS FROM THIS ROUTINE
    IN INSERT ORDER, BUT THIS ROUTINE RETURNS ELEMENTS IN COLLATION ORDER. MOST
    CALLERS MAY NOT CARE, BUT IF INSERT ORDER IS REQUIRED, THE CALLER MUST MAINTAIN
    INSERT ORDER VIA LINKS IN USERDATA, BECAUSE THIS TABLE PACKAGE DOES NOT MAINTAIN
    INSERT ORDER.  ALSO, LIKE THE PREVIOUS IMPLEMENTATION, THIS ROUTINE MAY SKIP OR
    REPEAT NODES IF ENUMERATION OCCURS IN PARALLEL WITH INSERTS AND DELETES.

    IN CONCLUSION, THIS ROUTINE IS NOT RECOMMENDED, AND IS SUPPLIED FOR BACKWARDS
    COMPATIBILITY ONLY.  SEE COMMENTS ABOUT WHICH ROUTINE TO CHOOSE IN THE ROUTINE
    COMMENTS FOR RtlEnumerateGenericTableLikeADirectory.

Arguments:

    Table - Pointer to the generic table from which to get the ith element.

    I - Which element to get.


Return Value:

    PVOID - Pointer to the user data.

--*/

{
    //
    //  Current location in the table, 0-based like I.
    //

    ULONG CurrentLocation = Table->WhichOrderedElement;

    //
    //  Hold the number of elements in the table.
    //

    ULONG NumberInTable = Table->NumberGenericTableElements;

    //
    //  Will hold distances to travel to the desired node;
    //

    ULONG ForwardDistance,BackwardDistance;

    //
    //  Will point to the current element in the linked list.
    //

    PRTL_BALANCED_LINKS CurrentNode = (PRTL_BALANCED_LINKS)Table->OrderedPointer;

    //
    //  If it's out of bounds get out quick.
    //

    if ((I == MAXULONG) || ((I + 1) > NumberInTable)) return NULL;

    //
    //  NULL means first node.  We just loop until we find the leftmost child of the root.
    //  Because of the above test, we know there is at least one element in the table.
    //

    if (CurrentNode == NULL) {

        for (
            CurrentNode = Table->BalancedRoot.RightChild;
            CurrentNode->LeftChild;
            CurrentNode = CurrentNode->LeftChild
            ) {
            NOTHING;
        }
        CurrentLocation = 0;

        //
        //  Update the table to save repeating this loop on a subsequent call.
        //

        Table->OrderedPointer = CurrentNode;
        Table->WhichOrderedElement = 0;
    }

    //
    //  If we're already at the node then return it.
    //

    if (I == CurrentLocation) {

        return &((PTABLE_ENTRY_HEADER)CurrentNode)->UserData;
    }

    //
    //  Calculate the forward and backward distance to the node.
    //

    if (CurrentLocation > I) {

        //
        //  When CurrentLocation is greater than where we want to go,
        //  if moving forward gets us there quicker than moving backward
        //  then it follows that moving forward from the first node in tree is
        //  going to take fewer steps. (This is because, moving forward
        //  in this case must move *through* the listhead.)
        //
        //  The work here is to figure out if moving backward would be quicker.
        //
        //  Moving backward would be quicker only if the location we wish  to
        //  go to is half way or more between the listhead and where we
        //  currently are.
        //

        if (I >= (CurrentLocation/2)) {

            //
            //  Where we want to go is more than half way from the listhead
            //  We can traval backwards from our current location.
            //

            for (
                BackwardDistance = CurrentLocation - I;
                BackwardDistance;
                BackwardDistance--
                ) {

                CurrentNode = RealPredecessor(CurrentNode);
            }

        } else {

            //
            //  We just loop until we find the leftmost child of the root,
            //  which is the lowest entry in the tree.
            //

            for (
                CurrentNode = Table->BalancedRoot.RightChild;
                CurrentNode->LeftChild;
                CurrentNode = CurrentNode->LeftChild
                ) {
                NOTHING;
            }

            //
            //  Where we want to go is less than halfway between the start
            //  and where we currently are.  Start from the first node.
            //

            for (
                ;
                I;
                I--
                ) {

                CurrentNode = RealSuccessor(CurrentNode);
            }
        }

    } else {


        //
        //  When CurrentLocation is less than where we want to go,
        //  if moving backwards gets us there quicker than moving forwards
        //  then it follows that moving backwards from the last node is
        //  going to take fewer steps.
        //

        ForwardDistance = I - CurrentLocation;

        //
        //  Do the backwards calculation assuming we are starting with the
        //  last element in the table.  (Thus BackwardDistance is 0 for the
        //  last element in the table.)
        //

        BackwardDistance = NumberInTable - (I + 1);

        //
        //  For our heuristic check, bias BackwardDistance by 1, so that we
        //  do not always have to loop down the right side of the tree to
        //  return the last element in the table!
        //

        if (ForwardDistance <= (BackwardDistance + 1)) {

            for (
                ;
                ForwardDistance;
                ForwardDistance--
                ) {

                CurrentNode = RealSuccessor(CurrentNode);
            }

        } else {

            //
            //  We just loop until we find the rightmost child of the root,
            //  which is the highest entry in the tree.
            //

            for (
                CurrentNode = Table->BalancedRoot.RightChild;
                CurrentNode->RightChild;
                CurrentNode = CurrentNode->RightChild
                ) {
                NOTHING;
            }

            for (
                ;
                BackwardDistance;
                BackwardDistance--
                ) {

                CurrentNode = RealPredecessor(CurrentNode);
            }
        }
    }

    //
    //  We're where we want to be.  Save our current location and return
    //  a pointer to the data to the user.
    //

    Table->OrderedPointer = CurrentNode;
    Table->WhichOrderedElement = I;

    return &((PTABLE_ENTRY_HEADER)CurrentNode)->UserData;
}


ULONG
RtlNumberGenericTableElementsAvl (
    IN PRTL_AVL_TABLE Table
    )

/*++

Routine Description:

    The function NumberGenericTableElements2 returns a ULONG value
    which is the number of generic table elements currently inserted
    in the generic table.

Arguments:

    Table - Pointer to the generic table from which to find out the number
    of elements.


Return Value:

    ULONG - The number of elements in the generic table.

--*/

{
    return Table->NumberGenericTableElements;
}


PVOID
RtlEnumerateGenericTableWithoutSplayingAvl (
    IN PRTL_AVL_TABLE Table,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    The function EnumerateGenericTableWithoutSplayingAvl will return to the
    caller one-by-one the elements of of a table.  The return value is a
    pointer to the user defined structure associated with the element.
    The input parameter RestartKey indicates if the enumeration should
    start from the beginning or should return the next element.  If the
    are no more new elements to return the return value is NULL.  As an
    example of its use, to enumerate all of the elements in a table the
    user would write:

        *RestartKey = NULL;

        for (ptr = EnumerateGenericTableWithoutSplayingAvl(Table, &RestartKey);
             ptr != NULL;
             ptr = EnumerateGenericTableWithoutSplayingAvl(Table, &RestartKey)) {
                :
        }

    For a summary of when to use each of the four enumeration routines, see
    RtlEnumerateGenericTableLikeADirectory.

Arguments:

    Table - Pointer to the generic table to enumerate.

    RestartKey - Pointer that indicates if we should restart or return the next
                element.  If the contents of RestartKey is NULL, the search
                will be started from the beginning.

Return Value:

    PVOID - Pointer to the user data.

--*/

{
    if (RtlIsGenericTableEmptyAvl(Table)) {

        //
        //  Nothing to do if the table is empty.
        //

        return NULL;

    } else {

        //
        //  Will be used as the "iteration" through the tree.
        //
        PRTL_BALANCED_LINKS NodeToReturn;

        //
        //  If the restart flag is true then go to the least element
        //  in the tree.
        //

        if (*RestartKey == NULL) {

            //
            //  We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = Table->BalancedRoot.RightChild;
                NodeToReturn->LeftChild;
                NodeToReturn = NodeToReturn->LeftChild
                ) {
                ;
            }

            *RestartKey = NodeToReturn;

        } else {

            //
            //  The caller has passed in the previous entry found
            //  in the table to enable us to continue the search.  We call
            //  RealSuccessor to step to the next element in the tree.
            //

            NodeToReturn = RealSuccessor(*RestartKey);

            if (NodeToReturn) {
                *RestartKey = NodeToReturn;
            }
        }

        //
        //  If there actually is a next element in the enumeration
        //  then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   ((PVOID)&((PTABLE_ENTRY_HEADER)NodeToReturn)->UserData)
                  :((PVOID)(NULL)));
    }
}


PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory (
    IN PRTL_AVL_TABLE Table,
    IN PRTL_AVL_MATCH_FUNCTION MatchFunction OPTIONAL,
    IN PVOID MatchData OPTIONAL,
    IN ULONG NextFlag,
    IN OUT PVOID *RestartKey,
    IN OUT PULONG DeleteCount,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function EnumerateGenericTableLikeADirectory will return to the
    caller one-by-one the elements of a table in collation order.  The
    return value is a pointer to the user defined structure associated
    with the element.  The in/out parameter RestartKey indicates if the
    enumeration should start from a specified key or should return the
    next element.  If there are no more new elements to return the return
    value is NULL.  As an example of its use, to enumerate all *matched*
    elements in a table the user would write:

        NextFlag = FALSE;
        RestartKey = NULL;
        DeleteCount = 0;
        (Initialize Buffer for start/resume point)

        for (ptr = EnumerateGenericTableLikeADirectory(Table, ...);
             ptr != NULL;
             ptr = EnumerateGenericTableLikeADirectory(Table, ...)) {
                :
        }

    The primary goal of this routine is to provide directory enumeration
    style semantics, for components like TXF which stores lookaside information
    on directories for pending create/delete operations.  In addition a caller
    may be interested in using the extended functionality available for
    directory enumerations, such as the match function or flexible resume
    semantics.

    Enumerations via this routine across intermixed insert and delete operations
    are safe.  All names not involved in inserts and deletes will be returned
    exactly once (unless explicitly resumed from an earlier point), and
    all intermixed inserts and deletes will be seen or not seen based on their
    state at the time the enumeration processes the respective directory range.

    To summarize the four(!) enumeration routines and when to use them:

      - For the simplest way for a single thread to enumerate the entire table
        in collation order and safely across inserts and deletes, use
        RtlEnumerateGenericTableAvl.  This routine is not reentrant, and thus
        requires exclusive access to the table across the entire enumeration.
        (This routine often used by a caller who is deleting all elements of the
        table.)
      - For the simplest way for multiple threads to enumerate the entire table
        in collation order and in parallel, use RtlEnumerateGenericTableWithoutSplayingAvl.
        This routine is not safe across inserts and deletes, and thus should be
        synchronized with shared access to lock out changes across the entire
        enumeration.
      - For the simplest way for multiple threads to enumerate the entire table
        in collation order and in parallel, and with progress across inserts and deletes,
        use RtlGetElementGenericTableAvl.  This routine requires only shared access
        across each individual call (rather than across the entire enumeration).
        However, inserts and deletes can cause items to be repeated or dropped during
        the enumeration.  THEREFORE, THE ROUTINE IS NOT RECOMMENDED.  Use shared access
        across the entire enumeration with the previous routine, or use the LikeADirectory
        routine for shared access on each call only with no repeats or drops.
      - To enumerate the table in multiple threads in collation order, safely
        across inserts and deletes, and with shared access only across individual
        calls, use RtlEnumerateGenericTableLikeADirectory.  This is the only routine
        that supports collation order and synchronization only over individual calls
        without erroneously dropping or repeating names due to inserts or deletes.
        Use this routine also if a matching function or flexible resume semantics are
        required.

Arguments:

    Table - Pointer to the generic table to enumerate.

    MatchFunction - A match function to determine which entries are to be returned.
                    If not specified, all nodes will be returned.

    MatchData - Pointer to be passed to the match function - a simple example might
                be a string expression with wildcards.

    NextFlag - FALSE to return the first/current entry described by RestartKey or
               Buffer (if matched).  TRUE to return the next entry after that (if
               matched).

    RestartKey - Pointer that indicates if we should restart or return the next
                element.  If the contents of RestartKey is NULL, the enumeration
                will be started/resumed from the position described in Buffer.
                If not NULL, the enumeration will resume from the most recent point,
                if there were no intervening deletes.  If there was an intervening
                delete, enumeration will resume from the position described in
                Buffer.  On return this field is updated to remember the key being
                returned.

    DeleteCount - This field is effectively ignored if RestartKey is NULL (nonresume case).
                  Otherwise, enumeration will resume from the RestartKey iff there
                  have been no intervening deletes in the table.  On return this
                  field is always updated with the current DeleteCount from the table.

    Buffer - Passed to the comparison routine if not resuming from RestartKey, to navigate
             the table.  This buffer must contain a key expression.  To repeat a remembered
             key, pass the key here, and insure RestartKey = NULL and NextFlag is FALSE.
             To return the next key after a remembered key, pass the key here, and insure
             RestartKey = NULL and NextFlag = TRUE - In either case, if the remembered key
             is now deleted, the next matched key will be returned.

             To enumerate the table from the beginning, initialize Buffer to contain
             <min-key> before the first call with RestartKey = NULL.  To start from an
             arbitrary point in the table, initialize this key to contain the desired
             starting key (or approximate key) before the first call.  So, for example,
             with the proper collate and match functions, to get all entries starting with
             TXF, you could initialize Buffer to be TXF*.  The collate routine would position
             to the first key starting with TXF (as if * was 0), and the match function would
             return STATUS_NO_MORE_MATCHES when the first key was encountered lexigraphically
             beyond TXF* (as if * were 0xFFFF).

Return Value:

    PVOID - Pointer to the user data, or NULL if there are no more matching entries

--*/

{
    NTSTATUS Status;

    //
    //  Holds a pointer to the node in the table or what would be the
    //  parent of the node.
    //

    PTABLE_ENTRY_HEADER NodeOrParent = (PTABLE_ENTRY_HEADER)*RestartKey;

    //
    //  Holds the result of the table lookup.
    //

    TABLE_SEARCH_RESULT Lookup;

    //
    //  Get out if the table is empty.
    //

    if (RtlIsGenericTableEmptyAvl(Table)) {

        *RestartKey = NULL;
        return NULL;
    }

    //
    //  If no MatchFunction was specified, then match all.
    //

    if (MatchFunction == NULL) {
        MatchFunction = &MatchAll;
    }

    //
    //  If there was a delete since the last time DeleteCount was captured, then we
    //  cannot trust the RestartKey.
    //

    if (*DeleteCount != Table->DeleteCount) {
        NodeOrParent = NULL;
    }

    //
    //  No saved key at this pointer, position ourselves in the directory by the key value.
    //

    ASSERT(FIELD_OFFSET(TABLE_ENTRY_HEADER, BalancedLinks) == 0);

    if (NodeOrParent == NULL) {

        Lookup = FindNodeOrParent(
                     Table,
                     Buffer,
                     (PRTL_BALANCED_LINKS *)&NodeOrParent
                     );

        //
        //  If the exact key was not found, we can still use this position, but clea NextFlag
        //  so we do not skip over something that has not been returned yet.
        //

        if (Lookup != TableFoundNode) {

            NextFlag = FALSE;

            //
            //  NodeOrParent points to a parent at which our key buffer could be inserted.
            //  If we were to be the left child, then NodeOrParent just happens to be the correct
            //  successor, otherwise if we would be the right child, then the successor of the
            //  specified key is the successor of  the current NodeOrParent.
            //

            if (Lookup == TableInsertAsRight) {
                NodeOrParent = (PTABLE_ENTRY_HEADER)RealSuccessor((PRTL_BALANCED_LINKS)NodeOrParent);
            }
        }
    }

    //
    //  Now see if we are supposed to skip one.
    //

    if (NextFlag) {
        ASSERT(NodeOrParent != NULL);
        NodeOrParent = (PTABLE_ENTRY_HEADER)RealSuccessor((PRTL_BALANCED_LINKS)NodeOrParent);
    }

    //
    //  Continue to enumerate until we hit the end of the matches or get a match.
    //

    while ((NodeOrParent != NULL) && ((Status = (*MatchFunction)(Table, &NodeOrParent->UserData, MatchData)) == STATUS_NO_MATCH)) {
        NodeOrParent = (PTABLE_ENTRY_HEADER)RealSuccessor((PRTL_BALANCED_LINKS)NodeOrParent);
    }

    //
    //  If we terminated the above loop with a pointer, it is either because we got a match, or
    //  because the match function knows that there will be no more matches.  Fill in the OUT
    //  parameters the same in either case, but only return the UserData pointer if we really
    //  got a match.
    //

    if (NodeOrParent != NULL) {
        ASSERT((Status == STATUS_SUCCESS) || (Status == STATUS_NO_MORE_MATCHES));
        *RestartKey = NodeOrParent;
        *DeleteCount = Table->DeleteCount;
        if (Status == STATUS_SUCCESS) {
            return &NodeOrParent->UserData;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\bitmap.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    BitMap.c

Abstract:

    Implementation of the bit map routines for the NT rtl.

    Bit numbers within the bit map are zero based.  The first is numbered
    zero.

    The bit map routines keep track of the number of bits clear or set by
    subtracting or adding the number of bits operated on as bit ranges
    are cleared or set; individual bit states are not tested.
    This means that if a range of bits is set,
    it is assumed that the total range is currently clear.

Author:

    Gary Kimura (GaryKi) & Lou Perazzoli (LouP)     29-Jan-1990

Revision History:

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlInitializeBitMap)
#endif

#define RightShiftUlong(E1,E2) ((E2) < 32 ? (E1) >> (E2) : 0)
#define LeftShiftUlong(E1,E2)  ((E2) < 32 ? (E1) << (E2) : 0)

#if DBG
VOID
DumpBitMap (
    PRTL_BITMAP BitMap
    )
{
    ULONG i;
    BOOLEAN AllZeros, AllOnes;

    DbgPrint(" BitMap:%08lx", BitMap);

    DbgPrint(" (%08x)", BitMap->SizeOfBitMap);
    DbgPrint(" %08lx\n", BitMap->Buffer);

    AllZeros = FALSE;
    AllOnes = FALSE;

    for (i = 0; i < ((BitMap->SizeOfBitMap + 31) / 32); i += 1) {

        if (BitMap->Buffer[i] == 0) {

            if (AllZeros) {

                NOTHING;

            } else {

                DbgPrint("%4d:", i);
                DbgPrint(" %08lx\n", BitMap->Buffer[i]);
            }

            AllZeros = TRUE;
            AllOnes = FALSE;

        } else if (BitMap->Buffer[i] == 0xFFFFFFFF) {

            if (AllOnes) {

                NOTHING;

            } else {

                DbgPrint("%4d:", i);
                DbgPrint(" %08lx\n", BitMap->Buffer[i]);
            }

            AllZeros = FALSE;
            AllOnes = TRUE;

        } else {

            AllZeros = FALSE;
            AllOnes = FALSE;

            DbgPrint("%4d:", i);
            DbgPrint(" %08lx\n", BitMap->Buffer[i]);
        }
    }
}
#endif


//
//  There are three macros to make reading the bytes in a bitmap easier.
//

#define GET_BYTE_DECLARATIONS() \
    PUCHAR _CURRENT_POSITION;

#define GET_BYTE_INITIALIZATION(RTL_BITMAP,BYTE_INDEX) {               \
    _CURRENT_POSITION = &((PUCHAR)((RTL_BITMAP)->Buffer))[BYTE_INDEX]; \
}

#define GET_BYTE(THIS_BYTE)  (         \
    THIS_BYTE = *(_CURRENT_POSITION++) \
)


//
//  Lookup table that tells how many contiguous bits are clear (i.e., 0) in
//  a byte
//

CONST CCHAR RtlpBitsClearAnywhere[] =
         { 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
           4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
           5,4,3,3,2,2,2,2,3,2,2,2,2,2,2,2,
           4,3,2,2,2,2,2,2,3,2,2,2,2,2,2,2,
           6,5,4,4,3,3,3,3,3,2,2,2,2,2,2,2,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           7,6,5,5,4,4,4,4,3,3,3,3,3,3,3,3,
           4,3,2,2,2,2,2,2,3,2,2,2,2,2,2,2,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           6,5,4,4,3,3,3,3,3,2,2,2,2,2,2,2,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,0 };

//
//  Lookup table that tells how many contiguous LOW order bits are clear
//  (i.e., 0) in a byte
//

CONST CCHAR RtlpBitsClearLow[] =
          { 8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0 };

//
//  Lookup table that tells how many contiguous HIGH order bits are clear
//  (i.e., 0) in a byte
//

CONST CCHAR RtlpBitsClearHigh[] =
          { 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
            3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

//
//  Lookup table that tells how many clear bits (i.e., 0) there are in a byte
//

CONST CCHAR RtlpBitsClearTotal[] =
          { 8,7,7,6,7,6,6,5,7,6,6,5,6,5,5,4,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            4,3,3,2,3,2,2,1,3,2,2,1,2,1,1,0 };

//
//  Bit Mask for clearing and setting bits within bytes.  FillMask[i] has the first
//  i bits set to 1.  ZeroMask[i] has the first i bits set to zero.
//

static CONST UCHAR FillMask[] = { 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF };

static CONST UCHAR ZeroMask[] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xf0, 0xe0, 0xc0, 0x80, 0x00 };


VOID
RtlInitializeBitMap (
    IN PRTL_BITMAP BitMapHeader,
    IN PULONG BitMapBuffer,
    IN ULONG SizeOfBitMap
    )

/*++

Routine Description:

    This procedure initializes a bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the BitMap Header to initialize

    BitMapBuffer - Supplies a pointer to the buffer that is to serve as the
        BitMap.  This must be an a multiple number of longwords in size.

    SizeOfBitMap - Supplies the number of bits required in the Bit Map.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    //
    //  Initialize the BitMap header.
    //

    BitMapHeader->SizeOfBitMap = SizeOfBitMap;
    BitMapHeader->Buffer = BitMapBuffer;

    //
    //  And return to our caller
    //

    //DbgPrint("InitializeBitMap"); DumpBitMap(BitMapHeader);
    return;
}


VOID
RtlClearBit (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG BitNumber
    )

/*++

Routine Description:

    This procedure clears a single bit in the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bit map.

    BitNumber - Supplies the number of the bit to be cleared in the bit map.

Return Value:

    None.

--*/

{

    PCHAR ByteAddress;
    ULONG ShiftCount;

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    ByteAddress = (PCHAR)BitMapHeader->Buffer + (BitNumber >> 3);
    ShiftCount = BitNumber & 0x7;
    *ByteAddress &= (CHAR)(~(1 << ShiftCount));
    return;
}

VOID
RtlSetBit (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG BitNumber
    )

/*++

Routine Description:

    This procedure sets a single bit in the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bit map.

    BitNumber - Supplies the number of the bit to be set in the bit map.

Return Value:

    None.

--*/

{

    PCHAR ByteAddress;
    ULONG ShiftCount;

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    ByteAddress = (PCHAR)BitMapHeader->Buffer + (BitNumber >> 3);
    ShiftCount = BitNumber & 0x7;
    *ByteAddress |= (CHAR)(1 << ShiftCount);
    return;
}

BOOLEAN
RtlTestBit (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG BitNumber
    )

/*++

Routine Description:

    This procedure tests the state of a single bit in the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bit map.

    BitNumber - Supplies the number of the bit to be tested in the bit map.

Return Value:

    The state of the specified bit is returned as the function value.

--*/

{

    PCHAR ByteAddress;
    ULONG ShiftCount;

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    ByteAddress = (PCHAR)BitMapHeader->Buffer + (BitNumber >> 3);
    ShiftCount = BitNumber & 0x7;
    return (BOOLEAN)((*ByteAddress >> ShiftCount) & 1);
}

VOID
RtlClearAllBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure clears all bits in the specified Bit Map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap

Return Value:

    None.

--*/

{
    //
    //  Clear all the bits
    //

    RtlZeroMemory( BitMapHeader->Buffer,
                   ((BitMapHeader->SizeOfBitMap + 31) / 32) * 4
                 );

    //
    //  And return to our caller
    //

    //DbgPrint("ClearAllBits"); DumpBitMap(BitMapHeader);
    return;
}


VOID
RtlSetAllBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure sets all bits in the specified Bit Map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap

Return Value:

    None.

--*/

{
    //
    //  Set all the bits
    //

    RtlFillMemoryUlong( BitMapHeader->Buffer,
                        ((BitMapHeader->SizeOfBitMap + 31) / 32) * 4,
                        0xffffffff
                      );

    //
    //  And return to our caller
    //

    //DbgPrint("SetAllBits"); DumpBitMap(BitMapHeader);
    return;
}


ULONG
RtlFindClearBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of clear bits.  If a run is not found from the
    hint to the end of the bitmap, we will search again from the
    beginning of the bitmap.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region of clear bits found.  If not such a region cannot be found
        a -1 (i.e. 0xffffffff) is returned.

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG HintBit;
    ULONG MainLoopIndex;

    GET_BYTE_DECLARATIONS();

    //
    //  To make the loops in our test run faster we'll extract the
    //  fields from the bitmap header
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Set any unused bits in the last byte so we won't count them.  We do
    //  this by first checking if there is any odd bits in the last byte.
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 1's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] |=
                                                    ZeroMask[SizeOfBitMap % 8];
    }

    //
    //  Calculate from the hint index where the hint byte is and set ourselves
    //  up to read the hint on the next call to GET_BYTE.  To make the
    //  algorithm run fast we'll only honor hints down to the byte level of
    //  granularity.  There is a possibility that we'll need to execute
    //  our main logic twice.  Once to test from the hint byte to the end of
    //  the bitmap and the other to test from the start of the bitmap.  First
    //  we need to make sure the Hint Index is within range.
    //

    if (HintIndex >= SizeOfBitMap) {

        HintIndex = 0;
    }

    HintBit = HintIndex % 8;

    for (MainLoopIndex = 0; MainLoopIndex < 2; MainLoopIndex += 1) {

        ULONG StartByteIndex;
        ULONG EndByteIndex;

        UCHAR CurrentByte;

        //
        //  Check for the first time through the main loop, which indicates
        //  that we are going to start our search at our hint byte
        //

        if (MainLoopIndex == 0) {

            StartByteIndex = HintIndex / 8;
            EndByteIndex = SizeInBytes;

        //
        //  This is the second time through the loop, make sure there is
        //  actually something to check before the hint byte
        //

        } else if (HintIndex != 0) {

            //
            //  The end index for the second time around is based on the
            //  number of bits we need to find.  We need to use this inorder
            //  to take the case where the preceding byte to the hint byte
            //  is the start of our run, and the run includes the hint byte
            //  and some following bytes, based on the number of bits needed
            //  The computation is to take the number of bits needed minus
            //  2 divided by 8 and then add 2.  This will take in to account
            //  the worst possible case where we have one bit hanging off
            //  of each end byte, and all intervening bytes are all zero.
            //

            if (NumberToFind < 2) {

                EndByteIndex = (HintIndex + 7) / 8;

            } else {

                EndByteIndex = (HintIndex + 7) / 8 + ((NumberToFind - 2) / 8) + 2;

                //
                //  Make sure we don't overrun the end of the bitmap
                //

                if (EndByteIndex > SizeInBytes) {

                    EndByteIndex = SizeInBytes;
                }
            }

            HintIndex = 0;
            HintBit = 0;
            StartByteIndex = 0;

        //
        //  Otherwise we already did a complete loop through the bitmap
        //  so we should simply return -1 to say nothing was found
        //

        } else {

            return 0xffffffff;
        }

        //
        //  Set ourselves up to get the next byte
        //

        GET_BYTE_INITIALIZATION(BitMapHeader, StartByteIndex);

        //
        //  Get the first byte, and set any bits before the hint bit.
        //

        GET_BYTE( CurrentByte );

        CurrentByte |= FillMask[HintBit];

        //
        //  If the number of bits can only fit in 1 or 2 bytes (i.e., 9 bits or
        //  less) we do the following test case.
        //

        if (NumberToFind <= 9) {

            ULONG CurrentBitIndex;
            UCHAR PreviousByte;

            PreviousByte = 0xff;

            //
            //  Examine all the bytes within our test range searching
            //  for a fit
            //

            CurrentBitIndex = StartByteIndex * 8;

            while (TRUE) {

                //
                //  If this is the first itteration of the loop, mask Current
                //  byte with the real hint.
                //

                //
                //  Check to see if the current byte coupled with the previous
                //  byte will satisfy the requirement. The check uses the high
                //  part of the previous byte and low part of the current byte.
                //

                if (((ULONG)RtlpBitsClearHigh[PreviousByte] +
                           (ULONG)RtlpBitsClearLow[CurrentByte]) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these two bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the current byte (bit 0) and subtracting the
                    //  number of bits its takes to get to the first cleared
                    //  high bit.
                    //

                    StartingIndex = CurrentBitIndex -
                                             (LONG)RtlpBitsClearHigh[PreviousByte];

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  The previous byte does not help, so check the current byte.
                //

                if ((ULONG)RtlpBitsClearAnywhere[CurrentByte] >= NumberToFind) {

                    UCHAR BitMask;
                    ULONG i;

                    //
                    //  It all fits in a single byte, so calculate the bit
                    //  number.  We do this by taking a mask of the appropriate
                    //  size and shifting it over until it fits.  It fits when
                    //  we can bitwise-and the current byte with the bitmask
                    //  and get a zero back.
                    //

                    BitMask = FillMask[ NumberToFind ];
                    for (i = 0; (BitMask & CurrentByte) != 0; i += 1) {

                        BitMask <<= 1;
                    }

                    //
                    //  return to our caller the located bit index, and the
                    //  number that we found.
                    //

                    return CurrentBitIndex + i;
                }

                //
                //  For the next iteration through our loop we need to make
                //  the current byte into the previous byte, and go to the
                //  top of the loop again.
                //

                PreviousByte = CurrentByte;

                //
                //  Increment our Bit Index, and either exit, or get the
                //  next byte.
                //

                CurrentBitIndex += 8;

                if ( CurrentBitIndex < EndByteIndex * 8 ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }

            } // end loop CurrentBitIndex

        //
        //  The number to find is greater than 9 but if it is less than 15
        //  then we know it can be satisfied with at most 2 bytes, or 3 bytes
        //  if the middle byte (of the 3) is all zeros.
        //

        } else if (NumberToFind < 15) {

            ULONG CurrentBitIndex;

            UCHAR PreviousPreviousByte;
            UCHAR PreviousByte;

            PreviousByte = 0xff;

            //
            //  Examine all the bytes within our test range searching
            //  for a fit
            //

            CurrentBitIndex = StartByteIndex * 8;

            while (TRUE) {

                //
                //  For the next iteration through our loop we need to make
                //  the current byte into the previous byte, the previous
                //  byte into the previous previous byte, and go forward.
                //

                PreviousPreviousByte = PreviousByte;
                PreviousByte = CurrentByte;

                //
                //  Increment our Bit Index, and either exit, or get the
                //  next byte.
                //

                CurrentBitIndex += 8;

                if ( CurrentBitIndex < EndByteIndex * 8 ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }

                //
                //  if the previous byte is all zeros then maybe the
                //  request can be satisfied using the Previous Previous Byte
                //  Previous Byte, and the Current Byte.
                //

                if ((PreviousByte == 0)

                    &&

                    (((ULONG)RtlpBitsClearHigh[PreviousPreviousByte] + 8 +
                          (ULONG)RtlpBitsClearLow[CurrentByte]) >= NumberToFind)) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these three bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the previous byte (bit 0) and subtracting
                    //  the number of bits its takes to get to the first
                    //  cleared high bit.
                    //

                    StartingIndex = (CurrentBitIndex - 8) -
                                     (LONG)RtlpBitsClearHigh[PreviousPreviousByte];

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  Check to see if the Previous byte and current byte
                //  together satisfy the request.
                //

                if (((ULONG)RtlpBitsClearHigh[PreviousByte] +
                           (ULONG)RtlpBitsClearLow[CurrentByte]) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these two bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the current byte (bit 0) and subtracting the
                    //  number of bits its takes to get to the first cleared
                    //  high bit.
                    //

                    StartingIndex = CurrentBitIndex -
                                             (LONG)RtlpBitsClearHigh[PreviousByte];

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

            } // end loop CurrentBitIndex

        //
        //  The number to find is greater than or equal to 15.  This request
        //  has to have at least one byte of all zeros to be satisfied
        //

        } else {

            ULONG CurrentByteIndex;

            ULONG ZeroBytesNeeded;
            ULONG ZeroBytesFound;

            UCHAR StartOfRunByte;
            LONG StartOfRunIndex;

            //
            //  First precalculate how many zero bytes we're going to need
            //

            ZeroBytesNeeded = (NumberToFind - 7) / 8;

            //
            //  Indicate for the first time through our loop that we haven't
            //  found a zero byte yet, and indicate that the start of the
            //  run is the byte just before the start byte index
            //

            ZeroBytesFound = 0;
            StartOfRunByte = 0xff;
            StartOfRunIndex = StartByteIndex - 1;

            //
            //  Examine all the bytes in our test range searching for a fit
            //

            CurrentByteIndex = StartByteIndex;

            while (TRUE) {

                //
                //  If the number of zero bytes fits our minimum requirements
                //  then we can do the additional test to see if we
                //  actually found a fit
                //

                if ((ZeroBytesFound >= ZeroBytesNeeded - 1)

                        &&

                    ((ULONG)RtlpBitsClearHigh[StartOfRunByte] + ZeroBytesFound*8 +
                     (ULONG)RtlpBitsClearLow[CurrentByte]) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  StartOfRunIndex times 8 and adding the number of bits
                    //  it takes to get to the first cleared high bit.
                    //

                    StartingIndex = (StartOfRunIndex * 8) +
                                     (8 - (LONG)RtlpBitsClearHigh[StartOfRunByte]);

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  Check to see if the byte is zero and increment
                //  the number of zero bytes found
                //

                if (CurrentByte == 0) {

                    ZeroBytesFound += 1;

                //
                //  The byte isn't a zero so we need to start over again
                //  looking for zero bytes.
                //

                } else {

                    ZeroBytesFound = 0;
                    StartOfRunByte = CurrentByte;
                    StartOfRunIndex = CurrentByteIndex;
                }

                //
                //  Increment our Byte Index, and either exit, or get the
                //  next byte.
                //

                CurrentByteIndex += 1;

                if ( CurrentByteIndex < EndByteIndex ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }

            } // end loop CurrentByteIndex
        }
    }

    //
    //  We never found a fit so we'll return -1
    //

    return 0xffffffff;
}


ULONG
RtlFindSetBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of set bits.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region of set bits found.  If such a region cannot be found then
        a -1 (i.e., 0xffffffff) is returned.

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG HintBit;
    ULONG MainLoopIndex;

    GET_BYTE_DECLARATIONS();

    //
    //  To make the loops in our test run faster we'll extract the
    //  fields from the bitmap header
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Set any unused bits in the last byte so we won't count them.  We do
    //  this by first checking if there is any odd bits in the last byte.
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 0's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] &=
                                                    FillMask[SizeOfBitMap % 8];
    }

    //
    //  Calculate from the hint index where the hint byte is and set ourselves
    //  up to read the hint on the next call to GET_BYTE.  To make the
    //  algorithm run fast we'll only honor hints down to the byte level of
    //  granularity.  There is a possibility that we'll need to execute
    //  our main logic twice.  Once to test from the hint byte to the end of
    //  the bitmap and the other to test from the start of the bitmap.  First
    //  we need to make sure the Hint Index is within range.
    //

    if (HintIndex >= SizeOfBitMap) {

        HintIndex = 0;
    }

    HintBit = HintIndex % 8;

    for (MainLoopIndex = 0; MainLoopIndex < 2; MainLoopIndex += 1) {

        ULONG StartByteIndex;
        ULONG EndByteIndex;

        UCHAR CurrentByte;

        //
        //  Check for the first time through the main loop, which indicates
        //  that we are going to start our search at our hint byte
        //

        if (MainLoopIndex == 0) {

            StartByteIndex = HintIndex / 8;
            EndByteIndex = SizeInBytes;

        //
        //  This is the second time through the loop, make sure there is
        //  actually something to check before the hint byte
        //

        } else if (HintIndex != 0) {

            //
            //  The end index for the second time around is based on the
            //  number of bits we need to find.  We need to use this inorder
            //  to take the case where the preceding byte to the hint byte
            //  is the start of our run, and the run includes the hint byte
            //  and some following bytes, based on the number of bits needed
            //  The computation is to take the number of bits needed minus
            //  2 divided by 8 and then add 2.  This will take in to account
            //  the worst possible case where we have one bit hanging off
            //  of each end byte, and all intervening bytes are all zero.
            //  We only need to add one in the following equation because
            //  HintByte is already counted.
            //

            if (NumberToFind < 2) {

                EndByteIndex = (HintIndex + 7) / 8;

            } else {

                EndByteIndex = (HintIndex + 7) / 8 + ((NumberToFind - 2) / 8) + 2;

                //
                //  Make sure we don't overrun the end of the bitmap
                //

                if (EndByteIndex > SizeInBytes) {

                    EndByteIndex = SizeInBytes;
                }
            }

            StartByteIndex = 0;
            HintIndex = 0;
            HintBit = 0;

        //
        //  Otherwise we already did a complete loop through the bitmap
        //  so we should simply return -1 to say nothing was found
        //

        } else {

            return 0xffffffff;
        }

        //
        //  Set ourselves up to get the next byte
        //

        GET_BYTE_INITIALIZATION(BitMapHeader, StartByteIndex);

        //
        //  Get the first byte, and clear any bits before the hint bit.
        //

        GET_BYTE( CurrentByte );

        CurrentByte &= ZeroMask[HintBit];

        //
        //  If the number of bits can only fit in 1 or 2 bytes (i.e., 9 bits or
        //  less) we do the following test case.
        //

        if (NumberToFind <= 9) {

            ULONG CurrentBitIndex;

            UCHAR PreviousByte;

            PreviousByte = 0x00;

            //
            //  Examine all the bytes within our test range searching
            //  for a fit
            //

            CurrentBitIndex = StartByteIndex * 8;

            while (TRUE) {

                //
                //  Check to see if the current byte coupled with the previous
                //  byte will satisfy the requirement. The check uses the high
                //  part of the previous byte and low part of the current byte.
                //

                if (((ULONG)RtlpBitsSetHigh(PreviousByte) +
                             (ULONG)RtlpBitsSetLow(CurrentByte)) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these two bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the current byte (bit 0) and subtracting the
                    //  number of bits its takes to get to the first set
                    //  high bit.
                    //

                    StartingIndex = CurrentBitIndex -
                                               (LONG)RtlpBitsSetHigh(PreviousByte);

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  The previous byte does not help, so check the current byte.
                //

                if ((ULONG)RtlpBitSetAnywhere(CurrentByte) >= NumberToFind) {

                    UCHAR BitMask;
                    ULONG i;

                    //
                    //  It all fits in a single byte, so calculate the bit
                    //  number.  We do this by taking a mask of the appropriate
                    //  size and shifting it over until it fits.  It fits when
                    //  we can bitwise-and the current byte with the bit mask
                    //  and get back the bit mask.
                    //

                    BitMask = FillMask[ NumberToFind ];
                    for (i = 0; (BitMask & CurrentByte) != BitMask; i += 1) {

                        BitMask <<= 1;
                    }

                    //
                    //  return to our caller the located bit index, and the
                    //  number that we found.
                    //

                    return CurrentBitIndex + i;
                }

                //
                //  For the next iteration through our loop we need to make
                //  the current byte into the previous byte, and go to the
                //  top of the loop again.
                //

                PreviousByte = CurrentByte;

                //
                //  Increment our Bit Index, and either exit, or get the
                //  next byte.
                //

                CurrentBitIndex += 8;

                if ( CurrentBitIndex < EndByteIndex * 8 ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }

            } // end loop CurrentBitIndex

        //
        //  The number to find is greater than 9 but if it is less than 15
        //  then we know it can be satisfied with at most 2 bytes, or 3 bytes
        //  if the middle byte (of the 3) is all ones.
        //

        } else if (NumberToFind < 15) {

            ULONG CurrentBitIndex;

            UCHAR PreviousPreviousByte;
            UCHAR PreviousByte;

            PreviousByte = 0x00;

            //
            //  Examine all the bytes within our test range searching
            //  for a fit
            //

            CurrentBitIndex = StartByteIndex * 8;

            while (TRUE) {

                //
                //  For the next iteration through our loop we need to make
                //  the current byte into the previous byte, the previous
                //  byte into the previous previous byte, and go to the
                //  top of the loop again.
                //

                PreviousPreviousByte = PreviousByte;
                PreviousByte = CurrentByte;

                //
                //  Increment our Bit Index, and either exit, or get the
                //  next byte.
                //

                CurrentBitIndex += 8;

                if ( CurrentBitIndex < EndByteIndex * 8 ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }

                //
                //  if the previous byte is all ones then maybe the
                //  request can be satisfied using the Previous Previous Byte
                //  Previous Byte, and the Current Byte.
                //

                if ((PreviousByte == 0xff)

                        &&

                    (((ULONG)RtlpBitsSetHigh(PreviousPreviousByte) + 8 +
                            (ULONG)RtlpBitsSetLow(CurrentByte)) >= NumberToFind)) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these three bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the previous byte (bit 0) and subtracting
                    //  the number of bits its takes to get to the first
                    //  set high bit.
                    //

                    StartingIndex = (CurrentBitIndex - 8) -
                                       (LONG)RtlpBitsSetHigh(PreviousPreviousByte);

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  Check to see if the Previous byte and current byte
                //  together satisfy the request.
                //

                if (((ULONG)RtlpBitsSetHigh(PreviousByte) +
                             (ULONG)RtlpBitsSetLow(CurrentByte)) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these two bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the current byte (bit 0) and subtracting the
                    //  number of bits its takes to get to the first set
                    //  high bit.
                    //

                    StartingIndex = CurrentBitIndex -
                                               (LONG)RtlpBitsSetHigh(PreviousByte);

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }
            } // end loop CurrentBitIndex

        //
        //  The number to find is greater than or equal to 15.  This request
        //  has to have at least one byte of all ones to be satisfied
        //

        } else {

            ULONG CurrentByteIndex;

            ULONG OneBytesNeeded;
            ULONG OneBytesFound;

            UCHAR StartOfRunByte;
            LONG StartOfRunIndex;

            //
            //  First precalculate how many one bytes we're going to need
            //

            OneBytesNeeded = (NumberToFind - 7) / 8;

            //
            //  Indicate for the first time through our loop that we haven't
            //  found a one byte yet, and indicate that the start of the
            //  run is the byte just before the start byte index
            //

            OneBytesFound = 0;
            StartOfRunByte = 0x00;
            StartOfRunIndex = StartByteIndex - 1;

            //
            //  Examine all the bytes in our test range searching for a fit
            //

            CurrentByteIndex = StartByteIndex;

            while (TRUE) {

                //
                //  If the number of zero bytes fits our minimum requirements
                //  then we can do the additional test to see if we
                //  actually found a fit
                //

                if ((OneBytesFound >= OneBytesNeeded - 1)

                        &&

                    ((ULONG)RtlpBitsSetHigh(StartOfRunByte) + OneBytesFound*8 +
                     (ULONG)RtlpBitsSetLow(CurrentByte)) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  StartOfRunIndex times 8 and adding the number of bits
                    //  it takes to get to the first set high bit.
                    //

                    StartingIndex = (StartOfRunIndex * 8) +
                                       (8 - (LONG)RtlpBitsSetHigh(StartOfRunByte));

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  Check to see if the byte is all ones and increment
                //  the number of one bytes found
                //

                if (CurrentByte == 0xff) {

                    OneBytesFound += 1;

                //
                //  The byte isn't all ones so we need to start over again
                //  looking for one bytes.
                //

                } else {

                    OneBytesFound = 0;
                    StartOfRunByte = CurrentByte;
                    StartOfRunIndex = CurrentByteIndex;
                }

                //
                //  Increment our Byte Index, and either exit, or get the
                //  next byte.
                //

                CurrentByteIndex += 1;

                if ( CurrentByteIndex < EndByteIndex ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }
            } // end loop CurrentByteIndex
        }
    }

    //
    //  We never found a fit so we'll return -1
    //

    return 0xffffffff;
}


ULONG
RtlFindClearBitsAndSet (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of clear bits, sets the bits and returns the
    number of bits found, and the starting bit number which was clear
    then set.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region found.  If such a region cannot be located a -1 (i.e.,
        0xffffffff) is returned.

--*/

{
    ULONG StartingIndex;

    //
    //  First look for a run of clear bits that equals the size requested
    //

    StartingIndex = RtlFindClearBits( BitMapHeader,
                                      NumberToFind,
                                      HintIndex );

    //DbgPrint("FindClearBits %08lx, ", NumberToFind);
    //DbgPrint("%08lx", StartingIndex);
    //DumpBitMap(BitMapHeader);

    if (StartingIndex != 0xffffffff) {

        //
        //  We found a large enough run of clear bits so now set them
        //

        RtlSetBits( BitMapHeader, StartingIndex, NumberToFind );
    }

    //
    //  And return to our caller
    //

    return StartingIndex;

}


ULONG
RtlFindSetBitsAndClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of set bits, clears the bits and returns the
    number of bits found and the starting bit number which was set then
    clear.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region found.  If such a region cannot be located a -1 (i.e.,
        0xffffffff) is returned.


--*/

{
    ULONG StartingIndex;

    //
    //  First look for a run of set bits that equals the size requested
    //

    if ((StartingIndex = RtlFindSetBits( BitMapHeader,
                                         NumberToFind,
                                         HintIndex )) != 0xffffffff) {

        //
        //  We found a large enough run of set bits so now clear them
        //

        RtlClearBits( BitMapHeader, StartingIndex, NumberToFind );
    }

    //
    //  And return to our caller
    //

    return StartingIndex;
}


VOID
RtlClearBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG NumberToClear
    )

/*++

Routine Description:

    This procedure clears the specified range of bits within the
    specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized Bit Map.

    StartingIndex - Supplies the index (zero based) of the first bit to clear.

    NumberToClear - Supplies the number of bits to clear.

Return Value:

    None.

--*/

{
    PCHAR CurrentByte;
    ULONG BitOffset;

    //DbgPrint("ClearBits %08lx, ", NumberToClear);
    //DbgPrint("%08lx", StartingIndex);

    ASSERT( StartingIndex + NumberToClear <= BitMapHeader->SizeOfBitMap );

    //
    //  Special case the situation where the number of bits to clear is
    //  zero.  Turn this into a noop.
    //

    if (NumberToClear == 0) {

        return;
    }

    //
    //  Get a pointer to the first byte that needs to be cleared.
    //

    CurrentByte = ((PCHAR) BitMapHeader->Buffer) + (StartingIndex / 8);

    //
    //  If all the bit's we're setting are in the same byte just do it and
    //  get out.
    //

    BitOffset = StartingIndex % 8;
    if ((BitOffset + NumberToClear) <= 8) {

        *CurrentByte &= ~(FillMask[ NumberToClear ] << BitOffset);

    }  else {

        //
        //  Do the first byte manually because the first bit may not be byte aligned.
        //
        //  Note:   The first longword will always be cleared byte wise to simplify the
        //          logic of checking for short copies (<32 bits).
        //

        if (BitOffset > 0) {

            *CurrentByte &= FillMask[ BitOffset ];
            CurrentByte += 1;
            NumberToClear -= 8 - BitOffset;

        }

        //
        //  Fill the full bytes in the middle.  Use the RtlZeroMemory() because its
        //  going to be hand tuned asm code spit out by the compiler.
        //

        if (NumberToClear > 8) {

            RtlZeroMemory( CurrentByte, NumberToClear / 8 );
            CurrentByte += NumberToClear / 8;
            NumberToClear %= 8;

        }

        //
        //  Clear the remaining bits, if there are any, in the last byte.
        //

        if (NumberToClear > 0) {

            *CurrentByte &= ZeroMask[ NumberToClear ];

        }

    }

    //
    //  And return to our caller
    //

    //DumpBitMap(BitMapHeader);

    return;
}

VOID
RtlSetBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG NumberToSet
    )

/*++

Routine Description:

    This procedure sets the specified range of bits within the
    specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialied BitMap.

    StartingIndex - Supplies the index (zero based) of the first bit to set.

    NumberToSet - Supplies the number of bits to set.

Return Value:

    None.

--*/
{
    PCHAR CurrentByte;
    ULONG BitOffset;

    //DbgPrint("SetBits %08lx, ", NumberToSet);
    //DbgPrint("%08lx", StartingIndex);

    ASSERT( StartingIndex + NumberToSet <= BitMapHeader->SizeOfBitMap );

    //
    //  Special case the situation where the number of bits to set is
    //  zero.  Turn this into a noop.
    //

    if (NumberToSet == 0) {

        return;
    }

    //
    //  Get a pointer to the first byte that needs to be set.
    //

    CurrentByte = ((PCHAR) BitMapHeader->Buffer) + (StartingIndex / 8);

    //
    //  If all the bit's we're setting are in the same byte just do it and
    //  get out.
    //

    BitOffset = StartingIndex % 8;
    if ((BitOffset + NumberToSet) <= 8) {

        *CurrentByte |= (FillMask[ NumberToSet ] << BitOffset);

    } else {

        //
        //  Do the first byte manually because the first bit may not be byte aligned.
        //
        //  Note:   The first longword will always be set byte wise to simplify the
        //          logic of checking for short copies (<32 bits).
        //

        if (BitOffset > 0) {

            *CurrentByte |= ZeroMask[ BitOffset ];
            CurrentByte += 1;
            NumberToSet -= 8 - BitOffset;

        }

        //
        //  Fill the full bytes in the middle.  Use the RtlFillMemory() because its
        //  going to be hand tuned asm code spit out by the compiler.
        //

        if (NumberToSet > 8) {

            RtlFillMemory( CurrentByte, NumberToSet / 8, 0xff );
            CurrentByte += NumberToSet / 8;
            NumberToSet %= 8;

        }

        //
        //  Set the remaining bits, if there are any, in the last byte.
        //

        if (NumberToSet > 0) {

            *CurrentByte |= FillMask[ NumberToSet ];

        }

    }

    //
    //  And return to our caller
    //

    //DumpBitMap(BitMapHeader);

    return;
}


#if DBG
BOOLEAN NtfsDebugIt = FALSE;
#endif

ULONG
RtlFindClearRuns (
    IN PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    )

/*++

Routine Description:

    This procedure finds N contiguous runs of clear bits
    within the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    RunArray - Receives the bit position, and length of each of the free runs
        that the procedure locates.  The array will be sorted according to
        length.

    SizeOfRunArray - Supplies the maximum number of entries the caller wants
        returned in RunArray

    LocateLongestRuns - Indicates if this routine is to return the longest runs
        it can find or just the first N runs.


Return Value:

    ULONG - Receives the number of runs that the procedure has located and
        returned in RunArray

--*/

{
    ULONG RunIndex;
    ULONG i;
    LONG j;

    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG CurrentRunSize;
    ULONG CurrentRunIndex;
    ULONG CurrentByteIndex;
    UCHAR CurrentByte;

    UCHAR BitMask;
    UCHAR TempNumber;

    GET_BYTE_DECLARATIONS();

    //
    //  Reference the bitmap header to make the loop run faster
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Set any unused bits in the last byte so we won't count them.  We do
    //  this by first checking if there is any odd bits in the last byte.
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 1's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] |= ZeroMask[SizeOfBitMap % 8];
    }

    //
    //  Set it up so we can the use GET_BYTE macro
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, 0);

    //
    //  Set our RunIndex and current run variables.  Run Index allays is the index
    //  of the next location to fill in or it could be one beyond the end of the
    //  array.
    //

    RunIndex = 0;
    for (i = 0; i < SizeOfRunArray; i += 1) { RunArray[i].NumberOfBits = 0; }

    CurrentRunSize = 0;
    CurrentRunIndex = 0;

    //
    //  Examine every byte in the BitMap
    //

    for (CurrentByteIndex = 0;
         CurrentByteIndex < SizeInBytes;
         CurrentByteIndex += 1) {

        GET_BYTE( CurrentByte );

#if DBG
        if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx\n",__LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte); }
#endif

        //
        //  If the current byte is not all zeros we need to (1) check if
        //  the current run is big enough to be inserted in the output
        //  array, and (2) check if the current byte inside of itself can
        //  be inserted, and (3) start a new current run
        //

        if (CurrentByte != 0x00) {

            //
            //  Compute the final size of the current run
            //

            CurrentRunSize += RtlpBitsClearLow[CurrentByte];

            //
            //  Check if the current run be stored in the output array by either
            //  there being room in the array or the last entry is smaller than
            //  the current entry
            //

            if (CurrentRunSize > 0) {

                if ((RunIndex < SizeOfRunArray) ||
                    (RunArray[RunIndex-1].NumberOfBits < CurrentRunSize)) {

                    //
                    //  If necessary increment the RunIndex and shift over the output
                    //  array until we find the slot where the new run belongs.  We only
                    //  do the shifting if we're returning longest runs.
                    //

                    if (RunIndex < SizeOfRunArray) { RunIndex += 1; }

                    for (j = RunIndex-2; LocateLongestRuns && (j >= 0) && (RunArray[j].NumberOfBits < CurrentRunSize); j -= 1) {

                        RunArray[j+1] = RunArray[j];
                    }

                    RunArray[j+1].NumberOfBits = CurrentRunSize;
                    RunArray[j+1].StartingIndex = CurrentRunIndex;

#if DBG
                    if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                        __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
#endif

                    //
                    //  Now if the array is full and we are not doing longest runs return
                    //  to our caller
                    //

                    if (!LocateLongestRuns && (RunIndex >= SizeOfRunArray)) {

                        return RunIndex;
                    }
                }
            }

            //
            //  The next run starts with the remaining clear bits in the
            //  current byte.  We set this up before we check inside the
            //  current byte for a longer run, because the latter test
            //  might require extra work.
            //

            CurrentRunSize = RtlpBitsClearHigh[ CurrentByte ];
            CurrentRunIndex = (CurrentByteIndex * 8) + (8 - CurrentRunSize);

            //
            //  Set the low and high bits, otherwise we'll wind up thinking that we have a
            //  small run that needs to get added to the array, but these bits have
            //  just been accounting for
            //

            CurrentByte |= FillMask[RtlpBitsClearLow[CurrentByte]] |
                           ZeroMask[8-RtlpBitsClearHigh[CurrentByte]];

            //
            //  Check if the current byte contains a run inside of it that
            //  should go into the output array.  There may be multiple
            //  runs in the byte that we need to insert.
            //

            while ((CurrentByte != 0xff)

                        &&

                   ((RunIndex < SizeOfRunArray) ||
                    (RunArray[RunIndex-1].NumberOfBits < (ULONG)RtlpBitsClearAnywhere[CurrentByte]))) {

                TempNumber = RtlpBitsClearAnywhere[CurrentByte];

                //
                //  Somewhere in the current byte is a run to be inserted of
                //  size TempNumber.  All we need to do is find the index for this run.
                //

                BitMask = FillMask[ TempNumber ];

                for (i = 0; (BitMask & CurrentByte) != 0; i += 1) {

                    BitMask <<= 1;
                }

                //
                //  If necessary increment the RunIndex and shift over the output
                //  array until we find the slot where the new run belongs.  We only
                //  do the shifting if we're returning longest runs.
                //

                if (RunIndex < SizeOfRunArray) { RunIndex += 1; }

                for (j = RunIndex-2; LocateLongestRuns && (j >= 0) && (RunArray[j].NumberOfBits < TempNumber); j -= 1) {

                    RunArray[j+1] = RunArray[j];
                }

                RunArray[j+1].NumberOfBits = TempNumber;
                RunArray[j+1].StartingIndex = (CurrentByteIndex * 8) + i;

#if DBG
                if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                    __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
#endif

                //
                //  Now if the array is full and we are not doing longest runs return
                //  to our caller
                //

                if (!LocateLongestRuns && (RunIndex >= SizeOfRunArray)) {

                    return RunIndex;
                }

                //
                //  Mask out the bits and look for another run in the current byte
                //

                CurrentByte |= BitMask;
            }

        //
        //  Otherwise the current byte is all zeros and
        //  we simply continue with the current run
        //

        } else {

            CurrentRunSize += 8;
        }
    }

#if DBG
    if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx\n",__LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte); }
#endif

    //
    //  See if we finished looking over the bitmap with an open current
    //  run that should be inserted in the output array
    //

    if (CurrentRunSize > 0) {

        if ((RunIndex < SizeOfRunArray) ||
            (RunArray[RunIndex-1].NumberOfBits < CurrentRunSize)) {

            //
            //  If necessary increment the RunIndex and shift over the output
            //  array until we find the slot where the new run belongs.
            //

            if (RunIndex < SizeOfRunArray) { RunIndex += 1; }

            for (j = RunIndex-2; LocateLongestRuns && (j >= 0) && (RunArray[j].NumberOfBits < CurrentRunSize); j -= 1) {

                RunArray[j+1] = RunArray[j];
            }

            RunArray[j+1].NumberOfBits = CurrentRunSize;
            RunArray[j+1].StartingIndex = CurrentRunIndex;

#if DBG
            if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
#endif
        }
    }

    //
    //  Return to our caller
    //

    return RunIndex;
}


ULONG
RtlFindLongestRunClear (
    IN PRTL_BITMAP BitMapHeader,
    OUT PULONG StartingIndex
    )

/*++

Routine Description:

    This procedure finds the largest contiguous range of clear bits
    within the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    StartingIndex - Receives the index (zero based) of the first run
        equal to the longest run of clear bits in the BitMap.

Return Value:

    ULONG - Receives the number of bits contained in the largest contiguous
        run of clear bits.

--*/

{
    RTL_BITMAP_RUN RunArray[1];

    //
    //  Locate the longest run in the bitmap.  If there is one then
    //  return that run otherwise return the error condition.
    //

    if (RtlFindClearRuns( BitMapHeader, RunArray, 1, TRUE ) == 1) {

        *StartingIndex = RunArray[0].StartingIndex;
        return RunArray[0].NumberOfBits;
    }

    *StartingIndex = 0;
    return 0;
}


ULONG
RtlFindFirstRunClear (
    IN PRTL_BITMAP BitMapHeader,
    OUT PULONG StartingIndex
    )

/*++

Routine Description:

    This procedure finds the first contiguous range of clear bits
    within the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    StartingIndex - Receives the index (zero based) of the first run
        equal to the longest run of clear bits in the BitMap.

Return Value:

    ULONG - Receives the number of bits contained in the first contiguous
        run of clear bits.

--*/

{
    return RtlFindNextForwardRunClear(BitMapHeader, 0, StartingIndex);
}


ULONG
RtlNumberOfClearBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure counts and returns the number of clears bits within
    the specified bitmap.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

Return Value:

    ULONG - The total number of clear bits in the bitmap

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG i;
    UCHAR CurrentByte;

    ULONG TotalClear;

    GET_BYTE_DECLARATIONS();

    //
    //  Reference the bitmap header to make the loop run faster
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Set any unused bits in the last byte so we don't count them.  We
    //  do this by first checking if there are any odd bits in the last byte
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 1's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] |=
                                                    ZeroMask[SizeOfBitMap % 8];
    }

    //
    //  Set if up so we can use the GET_BYTE macro
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, 0 );

    //
    //  Examine every byte in the bitmap
    //

    TotalClear = 0;
    for (i = 0; i < SizeInBytes; i += 1) {

        GET_BYTE( CurrentByte );

        TotalClear += RtlpBitsClearTotal[CurrentByte];
    }

    return TotalClear;
}


ULONG
RtlNumberOfSetBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure counts and returns the number of set bits within
    the specified bitmap.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

Return Value:

    ULONG - The total number of set bits in the bitmap

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG i;
    UCHAR CurrentByte;

    ULONG TotalSet;

    GET_BYTE_DECLARATIONS();

    //
    //  Reference the bitmap header to make the loop run faster
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Clear any unused bits in the last byte so we don't count them.  We
    //  do this by first checking if there are any odd bits in the last byte
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 0's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] &=
                                                    FillMask[SizeOfBitMap % 8];
    }

    //
    //  Set if up so we can use the GET_BYTE macro
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, 0 );

    //
    //  Examine every byte in the bitmap
    //

    TotalSet = 0;
    for (i = 0; i < SizeInBytes; i += 1) {

        GET_BYTE( CurrentByte );

        TotalSet += RtlpBitsSetTotal(CurrentByte);
    }

    return TotalSet;
}


BOOLEAN
RtlAreBitsClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG Length
    )

/*++

Routine Description:

    This procedure determines if the range of specified bits are all clear.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

    StartingIndex - Supplies the starting bit index to examine

    Length - Supplies the number of bits to examine

Return Value:

    BOOLEAN - TRUE if the specified bits in the bitmap are all clear, and
        FALSE if any are set or if the range is outside the bitmap or if
        Length is zero.

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG EndingIndex;

    ULONG StartingByte;
    ULONG EndingByte;

    ULONG StartingOffset;
    ULONG EndingOffset;

    ULONG i;
    UCHAR Byte;

    GET_BYTE_DECLARATIONS();

    //
    //  To make the loops in our test run faster we'll extract the fields
    //  from the bitmap header
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  First make sure that the specified range is contained within the
    //  bitmap, and the length is not zero.
    //

    if ((StartingIndex + Length > SizeOfBitMap) || (Length == 0)) {

        return FALSE;
    }

    //
    //  Compute the ending index, starting and ending byte, and the starting
    //  and ending offset within each byte
    //

    EndingIndex = StartingIndex + Length - 1;

    StartingByte = StartingIndex / 8;
    EndingByte = EndingIndex / 8;

    StartingOffset = StartingIndex % 8;
    EndingOffset = EndingIndex % 8;

    //
    //  Set ourselves up to get the next byte
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, StartingByte );

    //
    //  Special case the situation where the starting byte and ending
    //  byte are one in the same
    //

    if (StartingByte == EndingByte) {

        //
        //  Get the single byte we are to look at
        //

        GET_BYTE( Byte );

        //
        //  Now we compute the mask of bits we're after and then AND it with
        //  the byte.  If it is zero then the bits in question are all clear
        //  otherwise at least one of them is set.
        //

        if ((ZeroMask[StartingOffset] & FillMask[EndingOffset+1] & Byte) == 0) {

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        //
        //  Get the first byte that we're after, and then
        //  compute the mask of bits we're after for the first byte then
        //  AND it with the byte itself.
        //

        GET_BYTE( Byte );

        if ((ZeroMask[StartingOffset] & Byte) != 0) {

            return FALSE;
        }

        //
        //  Now for every whole byte inbetween read in the byte,
        //  and make sure it is all zeros
        //

        for (i = StartingByte+1; i < EndingByte; i += 1) {

            GET_BYTE( Byte );

            if (Byte != 0) {

                return FALSE;
            }
        }

        //
        //  Get the last byte we're after, and then
        //  compute the mask of bits we're after for the last byte then
        //  AND it with the byte itself.
        //

        GET_BYTE( Byte );

        if ((FillMask[EndingOffset+1] & Byte) != 0) {

            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
RtlAreBitsSet (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG Length
    )

/*++

Routine Description:

    This procedure determines if the range of specified bits are all set.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

    StartingIndex - Supplies the starting bit index to examine

    Length - Supplies the number of bits to examine

Return Value:

    BOOLEAN - TRUE if the specified bits in the bitmap are all set, and
        FALSE if any are clear or if the range is outside the bitmap or if
        Length is zero.

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG EndingIndex;

    ULONG StartingByte;
    ULONG EndingByte;

    ULONG StartingOffset;
    ULONG EndingOffset;

    ULONG i;
    UCHAR Byte;

    GET_BYTE_DECLARATIONS();

    //
    //  To make the loops in our test run faster we'll extract the fields
    //  from the bitmap header
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  First make sure that the specified range is contained within the
    //  bitmap, and the length is not zero.
    //

    if ((StartingIndex + Length > SizeOfBitMap) || (Length == 0)) {

        return FALSE;
    }

    //
    //  Compute the ending index, starting and ending byte, and the starting
    //  and ending offset within each byte
    //

    EndingIndex = StartingIndex + Length - 1;

    StartingByte = StartingIndex / 8;
    EndingByte = EndingIndex / 8;

    StartingOffset = StartingIndex % 8;
    EndingOffset = EndingIndex % 8;

    //
    //  Set ourselves up to get the next byte
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, StartingByte );

    //
    //  Special case the situation where the starting byte and ending
    //  byte are one in the same
    //

    if (StartingByte == EndingByte) {

        //
        //  Get the single byte we are to look at
        //

        GET_BYTE( Byte );

        //
        //  Now we compute the mask of bits we're after and then AND it with
        //  the complement of the byte If it is zero then the bits in question
        //  are all clear otherwise at least one of them is clear.
        //

        if ((ZeroMask[StartingOffset] & FillMask[EndingOffset+1] & ~Byte) == 0) {

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        //
        //  Get the first byte that we're after, and then
        //  compute the mask of bits we're after for the first byte then
        //  AND it with the complement of the byte itself.
        //

        GET_BYTE( Byte );

        if ((ZeroMask[StartingOffset] & ~Byte) != 0) {

            return FALSE;
        }

        //
        //  Now for every whole byte inbetween read in the byte,
        //  and make sure it is all ones
        //

        for (i = StartingByte+1; i < EndingByte; i += 1) {

            GET_BYTE( Byte );

            if (Byte != 0xff) {

                return FALSE;
            }
        }

        //
        //  Get the last byte we're after, and then
        //  compute the mask of bits we're after for the last byte then
        //  AND it with the complement of the byte itself.
        //

        GET_BYTE( Byte );

        if ((FillMask[EndingOffset+1] & ~Byte) != 0) {

            return FALSE;
        }
    }

    return TRUE;
}

static CONST ULONG FillMaskUlong[] = {
    0x00000000, 0x00000001, 0x00000003, 0x00000007,
    0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
    0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
    0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
    0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
    0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
    0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
    0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
    0xffffffff
};


ULONG
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    )
{
    ULONG Start;
    ULONG End;
    PULONG PHunk, BitMapEnd;
    ULONG Hunk;

    //
    // Take care of the boundary case of the null bitmap
    //

    if (BitMapHeader->SizeOfBitMap == 0) {

        *StartingRunIndex = FromIndex;
        return 0;
    }

    //
    //  Compute the last word address in the bitmap
    //

    BitMapEnd = BitMapHeader->Buffer + ((BitMapHeader->SizeOfBitMap - 1) / 32);

    //
    //  Scan forward for the first clear bit
    //

    Start = FromIndex;

    //
    //  Build pointer to the ULONG word in the bitmap
    //  containing the Start bit
    //

    PHunk = BitMapHeader->Buffer + (Start / 32);

    //
    //  If the first subword is set then we can proceed to
    //  take big steps in the bitmap since we are now ULONG
    //  aligned in the search. Make sure we aren't improperly
    //  looking at the last word in the bitmap.
    //

    if (PHunk != BitMapEnd) {

        //
        //  Read in the bitmap hunk. Set the previous bits in this word.
        //

        Hunk = *PHunk | FillMaskUlong[Start % 32];

        if (Hunk == (ULONG)~0) {

            //
            //  Adjust the pointers forward
            //

            Start += 32 - (Start % 32);
            PHunk++;

            while ( PHunk < BitMapEnd ) {

                //
                //  Stop at first word with unset bits
                //

                if (*PHunk != (ULONG)~0) break;

                PHunk++;
                Start += 32;
            }
        }
    }

    //
    //  Bitwise search forward for the clear bit
    //

    while ((Start < BitMapHeader->SizeOfBitMap) && (RtlCheckBit( BitMapHeader, Start ) == 1)) { Start += 1; }

    //
    //  Scan forward for the first set bit
    //

    End = Start;

    //
    //  If we aren't in the last word of the bitmap we may be
    //  able to keep taking big steps
    //

    if (PHunk != BitMapEnd) {

        //
        //  We know that the clear bit was in the last word we looked at,
        //  so continue from there to find the next set bit, clearing the
        //  previous bits in the word
        //

        Hunk = *PHunk & ~FillMaskUlong[End % 32];

        if (Hunk == (ULONG)0) {

            //
            //  Adjust the pointers forward
            //

            End += 32 - (End % 32);
            PHunk++;

            while ( PHunk < BitMapEnd ) {

                //
                //  Stop at first word with set bits
                //

                if (*PHunk != (ULONG)0) break;

                PHunk++;
                End += 32;
            }
        }
    }

    //
    //  Bitwise search forward for the set bit
    //

    while ((End < BitMapHeader->SizeOfBitMap) && (RtlCheckBit( BitMapHeader, End ) == 0)) { End += 1; }

    //
    //  Compute the index and return the length
    //

    *StartingRunIndex = Start;
    return (End - Start);
}


ULONG
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    )
{
    ULONG Start;
    ULONG End;
    PULONG PHunk;
    ULONG Hunk;

    RTL_PAGED_CODE();

    //
    //  Take care of the boundary case of the null bitmap
    //

    if (BitMapHeader->SizeOfBitMap == 0) {

        *StartingRunIndex = FromIndex;
        return 0;
    }

    //
    //  Scan backwards for the first clear bit
    //

    End = FromIndex;

    //
    //  Build pointer to the ULONG word in the bitmap
    //  containing the End bit, then read in the bitmap
    //  hunk. Set the rest of the bits in this word, NOT
    //  inclusive of the FromIndex bit.
    //

    PHunk = BitMapHeader->Buffer + (End / 32);
    Hunk = *PHunk | ~FillMaskUlong[(End % 32) + 1];

    //
    //  If the first subword is set then we can proceed to
    //  take big steps in the bitmap since we are now ULONG
    //  aligned in the search
    //

    if (Hunk == (ULONG)~0) {

        //
        //  Adjust the pointers backwards
        //

        End -= (End % 32) + 1;
        PHunk--;

        while ( PHunk > BitMapHeader->Buffer ) {

            //
            //  Stop at first word with set bits
            //

            if (*PHunk != (ULONG)~0) break;

            PHunk--;
            End -= 32;
        }
    }

    //
    //  Bitwise search backward for the clear bit
    //

    while ((End != MAXULONG) && (RtlCheckBit( BitMapHeader, End ) == 1)) { End -= 1; }

    //
    //  Scan backwards for the first set bit
    //

    Start = End;

    //
    //  We know that the clear bit was in the last word we looked at,
    //  so continue from there to find the next set bit, clearing the
    //  previous bits in the word.
    //

    Hunk = *PHunk & FillMaskUlong[Start % 32];

    //
    //  If the subword is unset then we can proceed in big steps
    //

    if (Hunk == (ULONG)0) {

        //
        //  Adjust the pointers backward
        //

        Start -= (Start % 32) + 1;
        PHunk--;

        while ( PHunk > BitMapHeader->Buffer ) {

            //
            //  Stop at first word with set bits
            //

            if (*PHunk != (ULONG)0) break;

            PHunk--;
            Start -= 32;
        }
    }

    //
    //  Bitwise search backward for the set bit
    //

    while ((Start != MAXULONG) && (RtlCheckBit( BitMapHeader, Start ) == 0)) { Start -= 1; }

    //
    //  Compute the index and return the length
    //

    *StartingRunIndex = Start + 1;
    return (End - Start);
}

#define BM_4567 0xFFFFFFFF00000000UI64
#define BM_67   0xFFFF000000000000UI64
#define BM_7    0xFF00000000000000UI64
#define BM_5    0x0000FF0000000000UI64
#define BM_23   0x00000000FFFF0000UI64
#define BM_3    0x00000000FF000000UI64
#define BM_1    0x000000000000FF00UI64

#define BM_0123 0x00000000FFFFFFFFUI64
#define BM_01   0x000000000000FFFFUI64
#define BM_0    0x00000000000000FFUI64
#define BM_2    0x0000000000FF0000UI64
#define BM_45   0x0000FFFF00000000UI64
#define BM_4    0x000000FF00000000UI64
#define BM_6    0x00FF000000000000UI64

CCHAR
RtlFindMostSignificantBit (
    IN ULONGLONG Set
    )
/*++

Routine Description:

    This procedure finds the most significant non-zero bit in Set and
    returns it's zero-based position.

Arguments:

    Set - Supplies the 64-bit bitmap.

Return Value:

    Set != 0:
        Bit position of the most significant set bit in Set.

    Set == 0:
        -1.

--*/
{

#if defined(_AMD64_)

    ULONG bitOffset;

    if (BitScanReverse64(&bitOffset, Set)) {
        return (CCHAR)bitOffset;

    } else {
        return -1;
    }

#else

    UCHAR index;
    UCHAR bitOffset;
    UCHAR lookup;

    if ((Set & BM_4567) != 0) {
        if ((Set & BM_67) != 0) {
            if ((Set & BM_7) != 0) {
                bitOffset = 7 * 8;
            } else {
                bitOffset = 6 * 8;
            }
        } else {
            if ((Set & BM_5) != 0) {
                bitOffset = 5 * 8;
            } else {
                bitOffset = 4 * 8;
            }
        }
    } else {
        if ((Set & BM_23) != 0) {
            if ((Set & BM_3) != 0) {
                bitOffset = 3 * 8;
            } else {
                bitOffset = 2 * 8;
            }
        } else {
            if ((Set & BM_1) != 0) {
                bitOffset = 1 * 8;
            } else {

                //
                // The test for Set == 0 is postponed to here, it is expected
                // to be rare.  Note that if we had our own version of
                // RtlpBitsClearHigh[] we could eliminate this test entirely,
                // reducing the average number of tests from 3.125 to 3.
                //

                if (Set == 0) {
                    return -1;
                }

                bitOffset = 0 * 8;
            }
        }
    }

    lookup = (UCHAR)(Set >> bitOffset);
    index = (7 - RtlpBitsClearHigh[lookup]) + bitOffset;
    return index;

#endif

}

CCHAR
RtlFindLeastSignificantBit (
    IN ULONGLONG Set
    )
/*++

Routine Description:

    This procedure finds the least significant non-zero bit in Set and
    returns it's zero-based position.

Arguments:

    Set - Supplies the 64-bit bitmap.

Return Value:

    Set != 0:
        Bit position of the least significant non-zero bit in Set.

    Set == 0:
        -1.

--*/
{

#if defined(_AMD64_)

    ULONG bitOffset;

    if (BitScanForward64(&bitOffset, Set)) {
        return (CCHAR)bitOffset;

    } else {
        return -1;
    }

#else

    UCHAR index;
    UCHAR bitOffset;
    UCHAR lookup;

    if ((Set & BM_0123) != 0) {
        if ((Set & BM_01) != 0) {
            if ((Set & BM_0) != 0) {
                bitOffset = 0 * 8;
            } else {
                bitOffset = 1 * 8;
            }
        } else {
            if ((Set & BM_2) != 0) {
                bitOffset = 2 * 8;
            } else {
                bitOffset = 3 * 8;
            }
        }
    } else {
        if ((Set & BM_45) != 0) {
            if ((Set & BM_4) != 0) {
                bitOffset = 4 * 8;
            } else {
                bitOffset = 5 * 8;
            }
        } else {
            if ((Set & BM_6) != 0) {
                bitOffset = 6 * 8;
            } else {

                //
                // The test for Set == 0 is postponed to here, it is expected
                // to be rare.  Note that if we had our own version of
                // RtlpBitsClearHigh[] we could eliminate this test entirely,
                // reducing the average number of tests from 3.125 to 3.
                //

                if (Set == 0) {
                    return -1;
                }

                bitOffset = 7 * 8;
            }
        }
    }

    lookup = (UCHAR)(Set >> bitOffset);
    index = RtlpBitsClearLow[lookup] + bitOffset;
    return index;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\byteswap.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    byteswap.c

Abstract:

    This module defines functions for performing endian conversions.

Author:

    Forrest Foltz (forrestf) 10-Dec-1997

Revision History:


--*/

#include "nt.h"
#include "ntrtlp.h"


#undef RtlUshortByteSwap
USHORT
FASTCALL
RtlUshortByteSwap(
    IN USHORT Source
    )

/*++

Routine Description:

    The RtlUshortByteSwap function exchanges bytes 0 and 1 of Source
    and returns the resulting USHORT.

Arguments:

    Source - 16-bit value to byteswap.

Return Value:

    Swapped 16-bit value.

--*/
{
    USHORT swapped;

    swapped = ((Source) << (8 * 1)) |
              ((Source) >> (8 * 1));

    return swapped;
}


#undef RtlUlongByteSwap
ULONG
FASTCALL
RtlUlongByteSwap(
    IN ULONG Source
    )

/*++

Routine Description:

    The RtlUlongByteSwap function exchanges byte pairs 0:3 and 1:2 of
    Source and returns the resulting ULONG.

Arguments:

    Source - 32-bit value to byteswap.

Return Value:

    Swapped 32-bit value.

--*/
{
    ULONG swapped;

    swapped = ((Source)              << (8 * 3)) |
              ((Source & 0x0000FF00) << (8 * 1)) |
              ((Source & 0x00FF0000) >> (8 * 1)) |
              ((Source)              >> (8 * 3));

    return swapped;
}


#undef RtlUlonglongByteSwap
ULONGLONG
FASTCALL
RtlUlonglongByteSwap(
    IN ULONGLONG Source
    )

/*++

Routine Description:

    The RtlUlongByteSwap function exchanges byte pairs 0:7, 1:6, 2:5, and
    3:4 of Source and returns the resulting ULONGLONG.

Arguments:

    Source - 64-bit value to byteswap.

Return Value:

    Swapped 64-bit value.

--*/
{
    ULONGLONG swapped;

    swapped = ((Source)                      << (8 * 7)) |
              ((Source & 0x000000000000FF00) << (8 * 5)) |
              ((Source & 0x0000000000FF0000) << (8 * 3)) |
              ((Source & 0x00000000FF000000) << (8 * 1)) |
              ((Source & 0x000000FF00000000) >> (8 * 1)) |
              ((Source & 0x0000FF0000000000) >> (8 * 3)) |
              ((Source & 0x00FF000000000000) >> (8 * 5)) |
              ((Source)                      >> (8 * 7));

    return swapped;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\bootstatus.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    bootstatus.c

Abstract:

    This module contains the code for manipulating the boot status file.

    The boot status file has some odd requirements and needs to be accessed/
    modified both by kernel and user-mode code.

--*/

#include "ntrtlp.h"
// #include <nt.h>
// #include <ntrtl.h>
// #include <zwapi.h>

#define BSD_UNICODE 1
#include "bootstatus.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlLockBootStatusData)
#pragma alloc_text(PAGE,RtlUnlockBootStatusData)
#pragma alloc_text(PAGE,RtlGetSetBootStatusData)
#pragma alloc_text(PAGE,RtlCreateBootStatusDataFile)
#endif

#define MYTAG 'fdsb'    // bsdf


NTSTATUS
RtlLockBootStatusData(
    OUT PHANDLE BootStatusDataHandle
    )
{
    OBJECT_ATTRIBUTES objectAttributes;

    WCHAR fileNameBuffer[MAXIMUM_FILENAME_LENGTH+1];
    UNICODE_STRING fileName;

    HANDLE dataFileHandle;

    IO_STATUS_BLOCK ioStatusBlock;

    NTSTATUS status;

    wcsncpy(fileNameBuffer, L"\\SystemRoot", MAXIMUM_FILENAME_LENGTH);
    wcsncat(fileNameBuffer, 
            BSD_FILE_NAME, 
            MAXIMUM_FILENAME_LENGTH - wcslen(fileNameBuffer));

    RtlInitUnicodeString(&fileName, fileNameBuffer);

    InitializeObjectAttributes(&objectAttributes,
                               &fileName,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                               NULL,
                               NULL);

    status = ZwOpenFile(&dataFileHandle,
                        FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                        &objectAttributes,
                        &ioStatusBlock,
                        0,
                        FILE_SYNCHRONOUS_IO_NONALERT);

    ASSERT(status != STATUS_PENDING);

    if(NT_SUCCESS(status)) {
        *BootStatusDataHandle = dataFileHandle;
    } else {
        *BootStatusDataHandle = NULL;
    }

    return status;
}

VOID
RtlUnlockBootStatusData(
    IN HANDLE BootStatusDataHandle
    )
{
    IO_STATUS_BLOCK ioStatusBlock;

    USHORT i = COMPRESSION_FORMAT_NONE;
    
    NTSTATUS status;

    //
    // Decompress the data file.  If the file is not already compressed then
    // this should be a very lightweight operation (so say the FS guys).  
    //
    // On the other hand if the file is compressed then the boot loader will
    // be unable to write to it and auto-recovery is effectively disabled.
    //

    status = ZwFsControlFile(
                BootStatusDataHandle,
                NULL,
                NULL,
                NULL,
                &ioStatusBlock,
                FSCTL_SET_COMPRESSION,
                &i, 
                sizeof(USHORT),
                NULL,
                0
                );

    ASSERT(status != STATUS_PENDING);

    status = ZwFlushBuffersFile(BootStatusDataHandle, &ioStatusBlock);

    ASSERT(status != STATUS_PENDING);

    ZwClose(BootStatusDataHandle);

    return;
}


#define FIELD_SIZE(type, field)  sizeof(((type *)0)->field)
#define FIELD_OFFSET_AND_SIZE(n)   {FIELD_OFFSET(BSD_BOOT_STATUS_DATA, n), FIELD_SIZE(BSD_BOOT_STATUS_DATA, n)}


NTSTATUS
RtlGetSetBootStatusData(
    IN HANDLE Handle,
    IN BOOLEAN Get,
    IN RTL_BSD_ITEM_TYPE DataItem,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG BytesReturned OPTIONAL
    )
{
    struct {
        ULONG FieldOffset;
        ULONG FieldLength;
    } bootStatusFields[] = {
        FIELD_OFFSET_AND_SIZE(Version),
        FIELD_OFFSET_AND_SIZE(ProductType),
        FIELD_OFFSET_AND_SIZE(AutoAdvancedBoot),
        FIELD_OFFSET_AND_SIZE(AdvancedBootMenuTimeout),
        FIELD_OFFSET_AND_SIZE(LastBootSucceeded),
        FIELD_OFFSET_AND_SIZE(LastBootShutdown)
    };

    LARGE_INTEGER fileOffset;
    ULONG dataFileVersion;

    ULONG itemLength;

    ULONG bytesRead;

    IO_STATUS_BLOCK ioStatusBlock;

    NTSTATUS status;

    ASSERT(RtlBsdItemMax == (sizeof(bootStatusFields) / sizeof(bootStatusFields[0])));

    //
    // Read the version number out of the data file.
    //

    fileOffset.QuadPart = 0;

    status = ZwReadFile(Handle,
                        NULL,
                        NULL,
                        NULL,
                        &ioStatusBlock,
                        &dataFileVersion,
                        sizeof(ULONG),
                        &fileOffset,
                        NULL);

    ASSERT(status != STATUS_PENDING);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // If the data item requsted isn't one we have code to handle then 
    // return invalid parameter.
    //

    if(DataItem >= (sizeof(bootStatusFields) / sizeof(bootStatusFields[0]))) {
        return STATUS_INVALID_PARAMETER;
    }

    fileOffset.QuadPart = bootStatusFields[DataItem].FieldOffset;
    itemLength = bootStatusFields[DataItem].FieldLength;

    //
    // If the data item offset is beyond the end of the file then return a 
    // versioning error.
    //

    if((fileOffset.QuadPart + itemLength) > dataFileVersion) {
        return STATUS_REVISION_MISMATCH;
    }

    if(DataBufferLength < itemLength) { 
        DataBufferLength = itemLength;
        return STATUS_BUFFER_TOO_SMALL;
    }

    if(Get) {
        status = ZwReadFile(Handle,
                            NULL,
                            NULL,
                            NULL,
                            &ioStatusBlock,
                            DataBuffer,
                            itemLength,
                            &fileOffset,
                            NULL);
    } else {
        status = ZwWriteFile(Handle,
                             NULL,
                             NULL,
                             NULL,
                             &ioStatusBlock,
                             DataBuffer,
                             itemLength,
                             &fileOffset,
                             NULL);
    }

    ASSERT(status != STATUS_PENDING);

    if(NT_SUCCESS(status) && ARGUMENT_PRESENT(BytesReturned)) {
        *BytesReturned = (ULONG) ioStatusBlock.Information;
    }

    return status;
}


NTSTATUS
RtlCreateBootStatusDataFile(
    VOID
    )
{
    OBJECT_ATTRIBUTES objectAttributes;

    WCHAR fileNameBuffer[MAXIMUM_FILENAME_LENGTH+1];
    UNICODE_STRING fileName;

    HANDLE dataFileHandle;

    IO_STATUS_BLOCK ioStatusBlock;

    LARGE_INTEGER t;
    UCHAR zero = 0;

    BSD_BOOT_STATUS_DATA defaultValues;

    NTSTATUS status;

    wcsncpy(fileNameBuffer, L"\\SystemRoot", MAXIMUM_FILENAME_LENGTH);
    wcsncat(fileNameBuffer, 
            BSD_FILE_NAME, 
            MAXIMUM_FILENAME_LENGTH - wcslen(fileNameBuffer));

    RtlInitUnicodeString(&fileName, fileNameBuffer);

    InitializeObjectAttributes(&objectAttributes,
                               &fileName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // The file must be large enough that it doesn't reside in the MFT entry 
    // or the loader won't be able to write to it.
    // 

    t.QuadPart = 2048;

    //
    // Create the file.
    //

    status = ZwCreateFile(&dataFileHandle,
                          FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                          &objectAttributes,
                          &(ioStatusBlock),
                          &t,
                          FILE_ATTRIBUTE_SYSTEM,
                          0,
                          FILE_CREATE,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    ASSERT(status != STATUS_PENDING);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Write a single zero byte to the 0x7ffth byte in the file to make
    // sure that 2k are actually allocated.  This is to ensure that the 
    // file will not become attribute resident even after a conversion
    // from FAT to NTFS.
    //

    t.QuadPart = t.QuadPart - 1;
    status = ZwWriteFile(dataFileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         &zero,
                         1,
                         &t,
                         NULL);

    ASSERT(status != STATUS_PENDING);

    if(!NT_SUCCESS(status)) {
        goto CreateDone;
    }

    //
    // Now write out the default values to the beginning of the file.
    //

    defaultValues.Version = sizeof(BSD_BOOT_STATUS_DATA);
    RtlGetNtProductType(&(defaultValues.ProductType));
    defaultValues.AutoAdvancedBoot = FALSE;
    defaultValues.AdvancedBootMenuTimeout = 30;
    defaultValues.LastBootSucceeded = TRUE;
    defaultValues.LastBootShutdown = FALSE;

    t.QuadPart = 0;

    status = ZwWriteFile(dataFileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         &defaultValues,
                         sizeof(BSD_BOOT_STATUS_DATA),
                         &t,
                         NULL);

    ASSERT(status != STATUS_PENDING);

    if(!NT_SUCCESS(status)) {

        //
        // The data file was created and we can assume the contents were zeroed
        // even if we couldn't write out the defaults.  Since this wouldn't 
        // enable auto-advanced boot we'll leave the data file in place with 
        // its zeroed contents.
        //

    }

CreateDone:

    ZwClose(dataFileHandle);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\cnvint.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    cnvint.c

Abstract:

    Text to integer and integer to text converion routines.

Author:

    Steve Wood (stevewo) 23-Aug-1990

Revision History:

--*/

#include <ntrtlp.h>

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlIntegerToChar)
#pragma alloc_text(PAGE,RtlCharToInteger)
#pragma alloc_text(PAGE,RtlUnicodeStringToInteger)
#pragma alloc_text(PAGE,RtlIntegerToUnicode)
#pragma alloc_text(PAGE,RtlIntegerToUnicodeString)
#pragma alloc_text(PAGE,RtlLargeIntegerToChar)
#pragma alloc_text(PAGE,RtlLargeIntegerToUnicode)
#pragma alloc_text(PAGE,RtlInt64ToUnicodeString)
#endif

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGECONST")
#endif
const CHAR RtlpIntegerChars[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

const WCHAR RtlpIntegerWChars[] = { L'0', L'1', L'2', L'3', L'4', L'5',
                              L'6', L'7', L'8', L'9', L'A', L'B',
                              L'C', L'D', L'E', L'F' };

NTSTATUS
RtlIntegerToChar (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[33], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = (1 << Shift) - 1;
    }

    s = &Result[33];
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
        } else {
            Digit = Value % Base;
            Value = Value / Base;
        }

        *--s = RtlpIntegerChars[Digit];
    } while (Value != 0);

    Length = (ULONG) (&Result[33] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *String++ = '0';
            OutputLength--;
        }
    }

    if ((LONG)Length > OutputLength) {
        return (STATUS_BUFFER_OVERFLOW);
    } else {
        try {
            RtlCopyMemory (String, s, Length);

            if ((LONG)Length < OutputLength) {
                String[Length] = '\0';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return (GetExceptionCode ());
        }

        return (STATUS_SUCCESS);
    }
}


NTSTATUS
RtlCharToInteger (
    IN PCSZ String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    CHAR c, Sign;
    ULONG Result, Digit, Shift;

    RTL_PAGED_CODE();

    while ((Sign = *String++) <= ' ') {
        if (!*String) {
            String--;
            break;
        }
    }

    c = Sign;
    if (c == '-' || c == '+') {
        c = *String++;
    }

    if (!ARGUMENT_PRESENT( Base )) {
        Base = 10;
        Shift = 0;
        if (c == '0') {
            c = *String++;
            if (c == 'x') {
                Base = 16;
                Shift = 4;
            } else if (c == 'o') {
                Base = 8;
                Shift = 3;
            } else if (c == 'b') {
                Base = 2;
                Shift = 1;
            } else {
                String--;
            }

            c = *String++;
        }
    } else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
        }
    }

    Result = 0;
    while (c) {
        if (c >= '0' && c <= '9') {
            Digit = c - '0';
        } else if (c >= 'A' && c <= 'F') {
            Digit = c - 'A' + 10;
        } else if (c >= 'a' && c <= 'f') {
            Digit = c - 'a' + 10;
        } else {
            break;
        }

        if (Digit >= Base) {
            break;
        }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
        } else {
            Result = (Result << Shift) | Digit;
        }

        c = *String++;
    }

    if (Sign == '-') {
        Result = (ULONG)(-(LONG)Result);
    }

    try {
        *Value = Result;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlUnicodeStringToInteger (
    IN PCUNICODE_STRING String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    PCWSTR s;
    WCHAR c, Sign;
    ULONG nChars, Result, Digit, Shift;

    RTL_PAGED_CODE();

    s = String->Buffer;
    nChars = String->Length / sizeof( WCHAR );
    while (nChars-- && (Sign = *s++) <= ' ') {
        if (!nChars) {
            Sign = UNICODE_NULL;
            break;
            }
        }

    c = Sign;
    if (c == L'-' || c == L'+') {
        if (nChars) {
            nChars--;
            c = *s++;
            }
        else {
            c = UNICODE_NULL;
            }
        }

    if (!ARGUMENT_PRESENT( Base )) {
        Base = 10;
        Shift = 0;
        if (c == L'0') {
            if (nChars) {
                nChars--;
                c = *s++;
                if (c == L'x') {
                    Base = 16;
                    Shift = 4;
                    }
                else
                if (c == L'o') {
                    Base = 8;
                    Shift = 3;
                    }
                else
                if (c == L'b') {
                    Base = 2;
                    Shift = 1;
                    }
                else {
                    nChars++;
                    s--;
                    }
                }

            if (nChars) {
                nChars--;
                c = *s++;
                }
            else {
                c = UNICODE_NULL;
                }
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
            }
        }

    Result = 0;
    while (c != UNICODE_NULL) {
        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';
            }
        else
        if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;
            }
        else
        if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        if (!nChars) {
            break;
            }
        nChars--;
        c = *s++;
        }

    if (Sign == L'-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlIntegerToUnicode (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result[33], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    return (STATUS_INVALID_PARAMETER);
    }

    if (Shift != 0) {
        Mask = (1 << Shift) - 1;
    }

    s = &Result[33];
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
        } else {
            Digit = Value % Base;
            Value = Value / Base;
        }

        *--s = RtlpIntegerWChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG) (&Result[33] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *String++ = L'0';
            OutputLength--;
        }
    }

    if ((LONG)Length > OutputLength) {
        return (STATUS_BUFFER_OVERFLOW);
    } else {
        try {
            RtlCopyMemory (String, s, Length * sizeof (WCHAR));

            if ((LONG)Length < OutputLength) {
                String[Length] = L'\0';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return (GetExceptionCode ());
        }

        return (STATUS_SUCCESS);
    }
}


NTSTATUS
RtlIntegerToUnicodeString (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )
{
    NTSTATUS Status;
    UCHAR ResultBuffer[16];
    ANSI_STRING AnsiString;

    RTL_PAGED_CODE();

    Status = RtlIntegerToChar (Value, Base, sizeof (ResultBuffer), ResultBuffer);
    if (NT_SUCCESS (Status)) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof (ResultBuffer);
        AnsiString.Length = (USHORT)strlen (ResultBuffer);
        Status = RtlAnsiStringToUnicodeString (String, &AnsiString, FALSE);
     }

    return( Status );
}


#define MAX_DIGITS 65

NTSTATUS
RtlLargeIntegerToChar (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[MAX_DIGITS], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch (Base) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:
        case 10:    Shift = 0;  break;
        default:    return (STATUS_INVALID_PARAMETER);
    }

    if (Shift != 0) {
        Mask = (1 << Shift) - 1;
    }

    s = &Result[MAX_DIGITS];

    if (Shift != 0) {
        ULONGLONG tValue;

        tValue = (ULONGLONG) Value->QuadPart;
        do {
            Digit  = (ULONG) (tValue & Mask);
            tValue = tValue >> Shift;
            *--s = RtlpIntegerChars[Digit];
        } while (tValue != 0);

    } else {
        LARGE_INTEGER TempValue = *Value;
        do {
            TempValue = RtlExtendedLargeIntegerDivide (TempValue, Base, &Digit);
            *--s = RtlpIntegerChars [Digit];
        } while (TempValue.QuadPart != 0);
    }

    Length = (ULONG)(&Result[MAX_DIGITS] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *String++ = '0';
            OutputLength--;
        }
    }

    if ((LONG)Length > OutputLength) {
        return (STATUS_BUFFER_OVERFLOW);
    } else {
        try {
            RtlCopyMemory (String, s, Length);

            if ((LONG)Length < OutputLength) {
                String[Length] = '\0';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return (GetExceptionCode ());
        }

        return (STATUS_SUCCESS);
    }
}

NTSTATUS
RtlLargeIntegerToUnicode (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result [MAX_DIGITS], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch (Base) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:
        case 10:    Shift = 0;  break;
        default:    return (STATUS_INVALID_PARAMETER);
    }

    if (Shift != 0) {
        Mask = (1 << Shift) - 1;
    }

    s = &Result [MAX_DIGITS];
    if (Shift != 0) {
        ULONGLONG tValue;

        tValue = (ULONGLONG) Value->QuadPart;
        do {
            Digit  = (ULONG) (tValue & Mask);
            tValue = tValue >> Shift;
            *--s = RtlpIntegerWChars[Digit];
        } while (tValue != 0);
    } else {
        LARGE_INTEGER TempValue = *Value;
        do {
            TempValue = RtlExtendedLargeIntegerDivide (TempValue, Base, &Digit);
            *--s = RtlpIntegerWChars[Digit];
        } while (TempValue.QuadPart != 0);
    }

    Length = (ULONG)(&Result[MAX_DIGITS] - s);

    ASSERT (Length <= MAX_DIGITS);

    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *String++ = L'0';
            OutputLength--;
        }
    }

    if ((LONG)Length > OutputLength) {
        return (STATUS_BUFFER_OVERFLOW);
    } else {
        try {
            RtlCopyMemory (String, s, Length * sizeof(WCHAR));

            if ((LONG)Length < OutputLength) {
                String [Length] = L'\0';
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return (GetExceptionCode ());
        }

        return (STATUS_SUCCESS);
    }
}

NTSTATUS
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )

{

    NTSTATUS Status;
    UCHAR ResultBuffer[32];
    ANSI_STRING AnsiString;
    LARGE_INTEGER Temp;

    RTL_PAGED_CODE();

    Temp.QuadPart = Value;
    Status = RtlLargeIntegerToChar(&Temp,
                                   Base,
                                   sizeof(ResultBuffer),
                                   ResultBuffer);

    if (NT_SUCCESS(Status)) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof(ResultBuffer);
        AnsiString.Length = (USHORT)strlen(ResultBuffer);
        Status = RtlAnsiStringToUnicodeString(String, &AnsiString, FALSE);
    }

    return Status;
}

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\debug.c ===
//      TITLE("Debug Support Functions")
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    debug.c
//
// Abstract:
//
//    This module implements functions to support debugging NT.  They call
//    architecture specific routines to do the actual work.
//
// Author:
//
//    Steven R. Wood (stevewo) 8-Nov-1994
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "stdarg.h"
#include "stdio.h"
#include "ntrtlp.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include <ntdbg.h>

#if !defined(BLDR_KERNEL_RUNTIME) || (defined(BLDR_KERNEL_RUNTIME) && defined(ENABLE_LOADER_DEBUG))

ULONG
DbgPrint(
    IN PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{

    va_list arglist;

    va_start(arglist, Format);
    return vDbgPrintExWithPrefix("", -1, 0, Format, arglist);
}

ULONG
DbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    ComponentId - Supplies the Id of the calling component.
//    Level      - Supplies the output filter level.
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{

    va_list arglist;

    va_start(arglist, Format);
    return vDbgPrintExWithPrefix("", ComponentId, Level, Format, arglist);
}

ULONG
vDbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Format,
    va_list arglist
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    ComponentId - Supplies the Id of the calling component.
//
//    Level      - Supplies the output filter level or mask.
//
//    Arguments   - Supplies a pointer to a variable argument list.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{

    return vDbgPrintExWithPrefix("", ComponentId, Level, Format, arglist);
}

ULONG
vDbgPrintExWithPrefix(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Format,
    va_list arglist
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    Prefix - Supplies a pointer to text that is to prefix the formatted
//        output.
//
//    ComponentId - Supplies the Id of the calling component.
//
//    Level      - Supplies the output filter level or mask.
//
//    Arguments   - Supplies a pointer to a variable argument list.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{

    UCHAR Buffer[512];
    int cb;
    int Length;
    STRING Output;
    NTSTATUS Status;

    //
    // If the debug output will be suppressed, then return success
    // immediately.
    //

#if !defined(BLDR_KERNEL_RUNTIME)

    if ((ComponentId != -1) &&
        (NtQueryDebugFilterState(ComponentId, Level) == FALSE)) {
        return STATUS_SUCCESS;
    }

#endif

#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)

    if (NtCurrentTeb()->InDbgPrint) {
        return STATUS_SUCCESS;
    }

    NtCurrentTeb()->InDbgPrint = TRUE;

#endif

    //
    // Format the output into a buffer and then print it.
    //

#if !defined(BLDR_KERNEL_RUNTIME)

    try {
        cb = strlen(Prefix);
        if (cb > sizeof(Buffer)) {
            cb = sizeof(Buffer);
        }

        strncpy(Buffer, Prefix, cb);
        Length = _vsnprintf(Buffer + cb , sizeof(Buffer) - cb, Format, arglist);

    } except (EXCEPTION_EXECUTE_HANDLER) {

#if !defined(NTOS_KERNEL_RUNTIME)

        NtCurrentTeb()->InDbgPrint = FALSE;

#endif

        return GetExceptionCode();
    }

#else

    cb = strlen(Prefix);
    strcpy(Buffer, Prefix);
    Length = _vsnprintf(Buffer + cb, sizeof(Buffer) - cb, Format, arglist);

#endif

    //
    // Check if buffer overflow occurred during formatting. If buffer overflow
    // occurred, then terminate the buffer with an end of line.
    //

    if (Length == -1) {
        Buffer[sizeof(Buffer) - 1] = '\n';
        Length = sizeof(Buffer);

    } else {
        Length += cb;
    }

    Output.Buffer = Buffer;
    Output.Length = (USHORT)Length;

    //
    // If APP is being debugged, raise an exception and the debugger
    // will catch and handle this. Otherwise, kernel debugger service
    // is called.
    //

#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)

    //
    // For non-Intel architectures, can't raise exceptions until the PebLock
    // is initialized, since the Function Table lookup code uses the PebLock
    // to serialize access to the loaded module database. 
    //

#if !i386

    if (NtCurrentPeb()->FastPebLock != NULL)

#endif  //!i386

    if (NtCurrentPeb()->BeingDebugged) {

        EXCEPTION_RECORD ExceptionRecord;

        //
        // Construct an exception record.
        //

        ExceptionRecord.ExceptionCode = DBG_PRINTEXCEPTION_C;
        ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
        ExceptionRecord.NumberParameters = 2;
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.ExceptionInformation[ 0 ] = Output.Length + 1;
        ExceptionRecord.ExceptionInformation[ 1 ] = (ULONG_PTR)(Output.Buffer);

        try {
            RtlRaiseException( &ExceptionRecord );
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }

#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)

        NtCurrentTeb()->InDbgPrint = FALSE;

#endif

        return STATUS_SUCCESS;
    }

#endif

    Status = DebugPrint(&Output, ComponentId, Level);
    if (Status == STATUS_BREAKPOINT) {
        DbgBreakPointWithStatus(DBG_STATUS_CONTROL_C);
        Status = STATUS_SUCCESS;
    }

#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)

    NtCurrentTeb()->InDbgPrint = FALSE;

#endif

    return Status;
}

ULONG
DbgPrintReturnControlC(
    PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    This routine is exactly the same as DbgPrint except that control-C
//    is NOT handled here.   Instead, status indicating control-C is
//    returned to the caller to do with as they will.
//
// Arguments:
//
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{
    va_list arglist;
    UCHAR Buffer[512];
    int cb;
    STRING Output;
#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)
    CONST PPEB Peb = NtCurrentPeb();
#endif

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);
    Buffer[sizeof(Buffer) - 1] = 0;
    cb = _vsnprintf(Buffer, sizeof(Buffer) - 1, Format, arglist);
    if (cb == -1) {             // detect buffer overflow
        cb = sizeof(Buffer);
        Buffer[sizeof(Buffer) - 1] = '\n';
    }
    Output.Buffer = Buffer;
    Output.Length = (USHORT) cb;

    //
    // If APP is being debugged, raise an exception and the debugger
    // will catch and handle this. Otherwise, kernel debugger service
    // is called.
    //

#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)
#if !i386
    //
    // For non-Intel architectures, can't raise exceptions until the PebLock
    // is initialized, since the Function Table lookup code uses the PebLock
    // to serialize access to the loaded module database.  What a crock
    //
    if (Peb->FastPebLock != NULL)

    //
    // For IA64 and probably AMD64, can't raise exceptions until ntdll is in
    // Peb->Ldr, so that RtlPcToFileHeader can find ntdll in Peb->Ldr. The
    // dbgprints / exceptions are necessarily from ntdll at this point.
    // The first two things in Peb->Ldr are the .exe and ntdll.dll, so
    // check that there are two things in the list.
    //
    if ((Peb->Ldr != NULL) &&
       (Peb->Ldr->InLoadOrderModuleList.Flink != &Peb->Ldr->InLoadOrderModuleList) &&
       (Peb->Ldr->InLoadOrderModuleList.Blink != Peb->Ldr->InLoadOrderModuleList.Flink))
#endif  //!i386
    if (Peb->BeingDebugged) {
        EXCEPTION_RECORD ExceptionRecord;

        //
        // Construct an exception record.
        //

        ExceptionRecord.ExceptionCode = DBG_PRINTEXCEPTION_C;
        ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
        ExceptionRecord.NumberParameters = 2;
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.ExceptionInformation[ 0 ] = Output.Length + 1;
        ExceptionRecord.ExceptionInformation[ 1 ] = (ULONG_PTR)(Output.Buffer);
        try {
            RtlRaiseException( &ExceptionRecord );
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
        return STATUS_SUCCESS;
        }
#endif
    return DebugPrint(&Output, 0, 0);
}

ULONG
DbgPrompt(
    IN PCHAR Prompt,
    OUT PCHAR Response,
    IN ULONG MaximumResponseLength
    )

//++
//
// Routine Description:
//
//    This function displays the prompt string on the debugging console and
//    then reads a line of text from the debugging console.  The line read
//    is returned in the memory pointed to by the second parameter.  The
//    third parameter specifies the maximum number of characters that can
//    be stored in the response area.
//
// Arguments:
//
//    Prompt - specifies the text to display as the prompt.
//
//    Response - specifies where to store the response read from the
//       debugging console.
//
//    Prompt - specifies the maximum number of characters that can be
//       stored in the Response buffer.
//
// Return Value:
//
//    Number of characters stored in the Response buffer.  Includes the
//    terminating newline character, but not the null character after
//    that.
//
//--

{

    STRING Input;
    STRING Output;

    //
    // Output the prompt string and read input.
    //

    Input.MaximumLength = (USHORT)MaximumResponseLength;
    Input.Buffer = Response;
    Output.Length = (USHORT)strlen( Prompt );
    Output.Buffer = Prompt;
    return DebugPrompt( &Output, &Input );
}

#if defined(NTOS_KERNEL_RUNTIME) || defined(BLDR_KERNEL_RUNTIME)


VOID
DbgLoadImageSymbols(
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly loaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{

    PIMAGE_NT_HEADERS NtHeaders;
    KD_SYMBOLS_INFO SymbolInfo;

    SymbolInfo.BaseOfDll = ImageBase;
    SymbolInfo.ProcessId = ProcessId;
    NtHeaders = RtlImageNtHeader( ImageBase );
    if (NtHeaders != NULL) {
        SymbolInfo.CheckSum = (ULONG)NtHeaders->OptionalHeader.CheckSum;
        SymbolInfo.SizeOfImage = (ULONG)NtHeaders->OptionalHeader.SizeOfImage;

    } else {

#if defined(BLDR_KERNEL_RUNTIME)

        //
        // There is only one image loaded in the loader environment that
        // does not have an NT image header. The image is the OS loader
        // and it is loaded by the firmware which strips the file header
        // and the optional ROM header. All the debugger requires is a
        // good guest at the size of the image.
        //

        SymbolInfo.SizeOfImage = 0x100000;

#else

        SymbolInfo.SizeOfImage = 0;

#endif

        SymbolInfo.CheckSum    = 0;
    }

    DebugService2(FileName, &SymbolInfo, BREAKPOINT_LOAD_SYMBOLS);

    return;
}


VOID
DbgUnLoadImageSymbols (
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly unloaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{
    KD_SYMBOLS_INFO SymbolInfo;

    SymbolInfo.BaseOfDll = ImageBase;
    SymbolInfo.ProcessId = ProcessId;
    SymbolInfo.CheckSum    = 0;
    SymbolInfo.SizeOfImage = 0;

    DebugService2(FileName, &SymbolInfo, BREAKPOINT_UNLOAD_SYMBOLS);

    return;
}


VOID
DbgCommandString(
    IN PCH Name,
    IN PCH Command
    )

//++
//
// Routine Description:
//
//    Tells the debugger to execute a command string
//
// Arguments:
//
//    Name - Identifies the originator of the command.
//
//    Command - Command string.
//
// Return Value:
//
//--

{
    STRING NameStr, CommandStr;

    NameStr.Buffer = Name;
    NameStr.Length = (USHORT)strlen(Name);
    CommandStr.Buffer = Command;
    CommandStr.Length = (USHORT)strlen(Command);
    DebugService2(&NameStr, &CommandStr, BREAKPOINT_COMMAND_STRING);
}

#endif // defined(NTOS_KERNEL_RUNTIME)

#if !defined(BLDR_KERNEL_RUNTIME)
NTSTATUS
DbgQueryDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level
    )

//++
//
// Routine Description:
//
//    This function queries the debug print enable for a specified component
//    level.  If Level is > 31, it's assumed to be a mask otherwise, it indicates
//    a specific debug level to test for (ERROR/WARNING/TRACE/INFO, etc).
//
// Arguments:
//
//     ComponentId - Supplies the component id.
//
//     Level - Supplies the debug filter level number or mask.
//
// Return Value:
//
//     STATUS_INVALID_PARAMETER_1 is returned if the component id is not
//         valid.
//
//     TRUE is returned if output is enabled for the specified component
//         and level or is enabled for the system.
//
//     FALSE is returned if output is not enabled for the specified component
//         and level and is not enabled for the system.
//
//--

{

    return NtQueryDebugFilterState(ComponentId, Level);
}

NTSTATUS
DbgSetDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    )

//++
//
// Routine Description:
//
//    This function sets the state of the debug print enable for a specified
//    component and level. The debug print enable state for the system is set
//    by specifying the distinguished value -1 for the component id.
//
// Arguments:
//
//    ComponentId - Supplies the Id of the calling component.
//
//    Level - Supplies the output filter level or mask.
//
//    State - Supplies a boolean value that determines the new state.
//
// Return Value:
//
//    STATUS_ACCESS_DENIED is returned if the required privilege is not held.
//
//    STATUS_INVALID_PARAMETER_1 is returned if the component id is not
//        valid.
//
//    STATUS_SUCCESS  is returned if the debug print enable state is set for
//        the specified component.
//
//--

{
    return NtSetDebugFilterState(ComponentId, Level, State);
}

#endif
#endif // !defined(BLDR_KERNEL_RUNTIME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\checksum.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imagedir.c

Abstract:

    The module contains the code to translate an image directory type to
    the address of the data for that entry.

Author:

    Steve Wood (stevewo) 18-Aug-1989

Environment:

    User Mode or Kernel Mode

Revision History:

--*/

#include "ntrtlp.h"

//
// Define forward referenced prootypes.
//

USHORT
ChkSum(
    ULONG PartialSum,
    PUSHORT Source,
    ULONG Length
    );


#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,ChkSum)
#pragma alloc_text(PAGE,LdrVerifyMappedImageMatchesChecksum)
#pragma alloc_text(PAGE, RtlComputeCrc32)
#endif

//
// This is the precomputed data table for the CRC32 algorithm as specified
// in IS0 3309. See RFC-1662 and RFC-1952 for implementation details and
// references.
//
// To calculate this table, use the following function:
//
//  VOID
//  PrintCrcTable(
//      )
//  {
//    ULONG32 Val;
//    ULONG i, k;
//
//      for (i = 0; i < 256; i++) {
//         Val = (ULONG) i;
//          for (k = 0; k < 8; k++) {
//              if (Val & 1) {
//                  Val = 0xedb88320L ^ (Val >> 1);
//              } else {
//                  Val = Val >> 1;
//              }
//          }
//
//          printf ("0x%08x, ", Val);
//
//          if ( (i+1) % 6 == 0) {
//              printf ("\n");
//          }
//      }
//  }
//
//


#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif

const ULONG32 RtlCrc32Table [] = {
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg()
#pragma data_seg()
#endif

USHORT
ChkSum(
    ULONG PartialSum,
    PUSHORT Source,
    ULONG Length
    )

/*++

Routine Description:

    Compute a partial checksum on a portion of an imagefile.

Arguments:

    PartialSum - Supplies the initial checksum value.

    Sources - Supplies a pointer to the array of words for which the
        checksum is computed.

    Length - Supplies the length of the array in words.

Return Value:

    The computed checksum value is returned as the function value.

--*/

{

    RTL_PAGED_CODE();

    //
    // Compute the word wise checksum allowing carries to occur into the
    // high order half of the checksum longword.
    //

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }

    //
    // Fold final carry into a single word result and return the resultant
    // value.
    //

    return (USHORT)(((PartialSum >> 16) + PartialSum) & 0xffff);
}

BOOLEAN
LdrVerifyMappedImageMatchesChecksum (
    IN PVOID BaseAddress,
    IN ULONG FileLength
    )

/*++

Routine Description:

    This functions computes the checksum of an image mapped as a data file.

Arguments:

    BaseAddress - Supplies a pointer to the base of the mapped file.

    FileLength - Supplies the length of the file in bytes.

Return Value:

    TRUE - The checksum stored in the image matches the checksum of the data.

    FALSE - The checksum in the image is not correct.

--*/

{

    PUSHORT AdjustSum;
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT PartialSum;
    ULONG HeaderSum;
    ULONG CheckSum;

    RTL_PAGED_CODE();

    //
    // Compute the checksum of the file and zero the header checksum value.
    //

    HeaderSum = 0;
    PartialSum = ChkSum(0, (PUSHORT)BaseAddress, (FileLength + 1) >> 1);

    //
    // If the file is an image file, then subtract the two checksum words
    // in the optional header from the computed checksum before adding
    // the file length, and set the value of the header checksum.
    //

    NtHeaders = RtlImageNtHeader(BaseAddress);
    if (NtHeaders != NULL) {
        HeaderSum = NtHeaders->OptionalHeader.CheckSum;

#ifndef NTOS_KERNEL_RUNTIME
        //
        // On Nt 3.1 and 3.5, we allowed printer drivers with 0 checksums into
        // csrss unintentionally. This means that we must allow this forever.
        // I don't want to allow this for kernel mode drivers, so I will only
        // allow 0 checksums of the high order bit is clear ?
        //


        if ( HeaderSum == 0 ) {
            return TRUE;
        }
#endif // NTOS_KERNEL_RUNTIME

        AdjustSum = (PUSHORT)(&NtHeaders->OptionalHeader.CheckSum);
        PartialSum -= (PartialSum < AdjustSum[0]);
        PartialSum -= AdjustSum[0];
        PartialSum -= (PartialSum < AdjustSum[1]);
        PartialSum -= AdjustSum[1];
    } else {
        PartialSum = 0;
        HeaderSum = FileLength;
    }

    //
    // Compute the final checksum value as the sum of the paritial checksum
    // and the file length.
    //

    CheckSum = (ULONG)PartialSum + FileLength;
    return (CheckSum == HeaderSum);
}



ULONG32
RtlComputeCrc32(
    ULONG32 PartialCrc,
    PUCHAR Buffer,
    ULONG Length
    )

/*++

Routine Description:

    Compute the CRC32 as specified in in IS0 3309. See RFC-1662 and RFC-1952
    for implementation details and references.

    Pre- and post-conditioning (one's complement) is done by this function, so
    it should not be done by the caller. That is, do:

        Crc = RtlComputeCrc32 ( 0, buffer, length );

    instead of

        Crc = RtlComputeCrc32 ( 0xffffffff, buffer, length );

    or
        Crc = RtlComputeCrc32 ( 0xffffffff, buffer, length) ^ 0xffffffff;


Arguments:

    PartialCrc - A partially calculated CRC32.

    Buffer - The buffer you want to CRC.

    Length - The length of the buffer in bytes.

Return Value:

    The updated CRC32 value.

Environment:

    Kernel mode at IRQL of APC_LEVEL or below, User mode, or within
    the boot-loader.

--*/



{
    ULONG32 Crc;
    ULONG i;


    RTL_PAGED_CODE ();

    //
    // Compute the CRC32 checksum.
    //

    Crc = PartialCrc ^ 0xffffffffL;

    for (i = 0; i < Length; i++) {
        Crc = RtlCrc32Table [(Crc ^ Buffer [ i ]) & 0xff] ^ (Crc >> 8);
    }

    return (Crc ^ 0xffffffffL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\eballoc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    eballoc.c

Abstract:

    Process/Thread Environment Block allocation functions

Author:

    Steve Wood (stevewo) 10-May-1990

Revision History:

--*/

#include "ntrtlp.h"
#include <nturtl.h>

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(INIT,RtlAcquirePebLock)
#pragma alloc_text(INIT,RtlReleasePebLock)
#endif


#undef RtlAcquirePebLock

VOID
RtlAcquirePebLock( VOID )
{

#if !defined(NTOS_KERNEL_RUNTIME)

    PPEB Peb;

    Peb = NtCurrentPeb();

    RtlEnterCriticalSection (Peb->FastPebLock);

#endif
}


#undef RtlReleasePebLock

VOID
RtlReleasePebLock( VOID )
{
#if !defined(NTOS_KERNEL_RUNTIME)

    PPEB Peb;

    Peb = NtCurrentPeb();

    RtlLeaveCriticalSection (Peb->FastPebLock);

#endif
}

#if DBG
VOID
RtlAssertPebLockOwned( VOID )
{
#if !defined(NTOS_KERNEL_RUNTIME)

    ASSERT(NtCurrentPeb()->FastPebLock->OwningThread == NtCurrentTeb()->ClientId.UniqueThread);

#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\environ.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    environ.c

Abstract:

    Environment Variable support

Author:

    Steven R. Wood (stevewo) 30-Jan-1991

Revision History:

--*/

#include "ntrtlp.h"
#include "zwapi.h"
#include "nturtl.h"
#include "string.h"
#include "ntrtlpath.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(INIT,RtlCreateEnvironment          )
#pragma alloc_text(INIT,RtlDestroyEnvironment         )
#pragma alloc_text(INIT,RtlSetCurrentEnvironment      )
#pragma alloc_text(INIT,RtlQueryEnvironmentVariable_U )
#pragma alloc_text(INIT,RtlSetEnvironmentVariable     )
#pragma alloc_text(INIT,RtlSetEnvironmentStrings)
#endif

BOOLEAN RtlpEnvironCacheValid;

NTSTATUS
RtlCreateEnvironment(
    IN BOOLEAN CloneCurrentEnvironment OPTIONAL,
    OUT PVOID *Environment
    )
{
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    PVOID pNew, pOld;
    PPEB Peb;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

    //
    // If not cloning a copy of the current process's environment variable
    // block, just allocate a block of committed memory and return its
    // address.
    //

    pNew = NULL;
    if (!CloneCurrentEnvironment) {
createEmptyEnvironment:
        MemoryInformation.RegionSize = 1;
        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          &pNew,
                                          0,
                                          &MemoryInformation.RegionSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (NT_SUCCESS( Status )) {
            *Environment = pNew;
        }

        return( Status );
    }

    Peb = NtCurrentPeb ();

    ProcessParameters = Peb->ProcessParameters;

    //
    // Acquire the Peb Lock for the duration while we munge the environment
    // variable storage block.
    //

    RtlAcquirePebLock();

    //
    // Capture the pointer to the current process's environment variable
    // block and initialize the new pointer to null for our finally clause.
    //

    pOld = ProcessParameters->Environment;
    if (pOld == NULL) {
        RtlReleasePebLock();
        goto createEmptyEnvironment;
    }

    try {
        try {
            //
            // Query the current size of the current process's environment
            // variable block.  Return status if failure.
            //

            Status = ZwQueryVirtualMemory (NtCurrentProcess (),
                                           pOld,
                                           MemoryBasicInformation,
                                           &MemoryInformation,
                                           sizeof (MemoryInformation),
                                           NULL);
            if (!NT_SUCCESS (Status)) {
                leave;
            }

            //
            // Allocate memory to contain a copy of the current process's
            // environment variable block.  Return status if failure.
            //

            Status = ZwAllocateVirtualMemory (NtCurrentProcess (),
                                              &pNew,
                                              0,
                                              &MemoryInformation.RegionSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE);
            if (!NT_SUCCESS (Status)) {
                leave;
            }

            //
            // Copy the current process's environment to the allocated memory
            // and return a pointer to the copy.
            //

            RtlCopyMemory (pNew, pOld, MemoryInformation.RegionSize);
            *Environment = pNew;
        } except (EXCEPTION_EXECUTE_HANDLER) {
              Status = STATUS_ACCESS_VIOLATION;
        }
    } finally {
        RtlReleasePebLock ();

        if (Status == STATUS_ACCESS_VIOLATION) {
            if (pNew != NULL) {
                ZwFreeVirtualMemory (NtCurrentProcess(),
                                     &pNew,
                                     &MemoryInformation.RegionSize,
                                     MEM_RELEASE);
            }
        }

    }

    return (Status);
}


NTSTATUS
RtlDestroyEnvironment(
    IN PVOID Environment
    )
{
    NTSTATUS Status;
    SIZE_T RegionSize;

    //
    // Free the specified environment variable block.
    //

    RtlpEnvironCacheValid = FALSE;

    RegionSize = 0;
    Status = ZwFreeVirtualMemory( NtCurrentProcess(),
                                  &Environment,
                                  &RegionSize,
                                  MEM_RELEASE
                                );
    //
    // Return status.
    //

    return( Status );
}


NTSTATUS
RtlSetCurrentEnvironment(
    IN PVOID Environment,
    OUT PVOID *PreviousEnvironment OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID pOld;
    PPEB Peb;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

    //
    // Acquire the Peb Lock for the duration while we munge the environment
    // variable storage block.
    //

    Peb = NtCurrentPeb ();

    ProcessParameters = Peb->ProcessParameters;


    Status = STATUS_SUCCESS;

    RtlAcquirePebLock ();

    RtlpEnvironCacheValid = FALSE;

    //
    // Capture current process's environment variable block pointer to
    // return to caller or destroy.
    //

    pOld = ProcessParameters->Environment;

    //
    // Change current process's environment variable block pointer to
    // point to the passed block.
    //

    ProcessParameters->Environment = Environment;

    //
    // Release the Peb Lock
    //

    RtlReleasePebLock ();

    //
    // If caller requested it, return the pointer to the previous
    // process environment variable block and set the local variable
    // to NULL so we dont destroy it below.
    //

    if (ARGUMENT_PRESENT (PreviousEnvironment)) {
        *PreviousEnvironment = pOld;
    } else {
        //
        // If old environment not returned to caller, destroy it.
        //
 
        if (pOld != NULL) {
            RtlDestroyEnvironment (pOld);
        }
    }


    //
    // Return status
    //

    return (Status);
}

UNICODE_STRING RtlpEnvironCacheName;
UNICODE_STRING RtlpEnvironCacheValue;

NTSTATUS
RtlQueryEnvironmentVariable_U(
    IN PVOID Environment OPTIONAL,
    IN PCUNICODE_STRING Name,
    IN OUT PUNICODE_STRING Value
    )
{
    NTSTATUS Status;
    UNICODE_STRING CurrentName;
    UNICODE_STRING CurrentValue;
    PWSTR p, q;
    PPEB Peb;
    BOOLEAN PebLockLocked = FALSE;
    SIZE_T len;
    SIZE_T NameLength, NameChars;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

    Status = STATUS_VARIABLE_NOT_FOUND;

    Peb = NtCurrentPeb();

    ProcessParameters = Peb->ProcessParameters;

    try {
        if (ARGUMENT_PRESENT (Environment)) {
            p = Environment;
            if (*p == UNICODE_NULL) {
                leave;
            }
        } else {


            //
            // Acquire the Peb Lock for the duration while we munge the
            // environment variable storage block.
            //

            PebLockLocked = TRUE;

            RtlAcquirePebLock ();

            //
            // Capture the pointer to the current process's environment variable
            // block.
            //

            p = ProcessParameters->Environment;

        }

        if (RtlpEnvironCacheValid && p == ProcessParameters->Environment) {
            if (RtlEqualUnicodeString (Name, &RtlpEnvironCacheName, TRUE)) {

                //
                // Names are equal.  Always return the length of the
                // value string, excluding the terminating null.  If
                // there is room in the caller's buffer, return a copy
                // of the value string and success status.  Otherwise
                // return an error status.  In the latter case, the caller
                // can examine the length field of their value string
                // so they can determine much memory is needed.
                //

                Value->Length = RtlpEnvironCacheValue.Length;
                if (Value->MaximumLength >= RtlpEnvironCacheValue.Length) {
                    RtlCopyMemory (Value->Buffer,
                                   RtlpEnvironCacheValue.Buffer,
                                   RtlpEnvironCacheValue.Length);
                    //
                    // Null terminate returned string if there is room.
                    //

                    if (Value->MaximumLength > RtlpEnvironCacheValue.Length) {
                        Value->Buffer[RtlpEnvironCacheValue.Length/sizeof(WCHAR)] = L'\0';
                    }

                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_BUFFER_TOO_SMALL;
                }
                leave;
            }
        }

        //
        // The environment variable block consists of zero or more null
        // terminated UNICODE strings.  Each string is of the form:
        //
        //      name=value
        //
        // where the null termination is after the value.
        //
        NameLength = Name->Length;
        NameChars = NameLength / sizeof (WCHAR);

        if (p != NULL) while (1) {

            //
            // Get the length of the terminated string. This should be in the
            // form 'keyword=value'
            //
            len = wcslen (p);
            if (len == 0) {
                break;
            }

            //
            // See if this environment variable is big enough to be our target.
            // If must be at least one bigger than the name we are searching
            // for since it must contain an '=' sign.
            //

            if (NameChars < len) {
                q = &p[NameChars];
                //
                // We have a possible match. See if there is an '=' at the correct point.
                //
                if (*q == L'=') {
                    //
                    // We have a possible match. Now compare the string out right
                    //
                    CurrentName.Length = (USHORT) NameLength;
                    CurrentName.Buffer = p;

                    //
                    // After comparing the strings we want to make sure we are not
                    // matching something that we shouldn't. For example if somebody
                    // did a lookup of "FRED=BOB" we don't want this to match "FRED=BOB=ALBERT".
                    // The lookup name is invalid and the environment variable is really FRED here
                    // not "FRED=BOB". To eliminate this case we make sure that the "=" character
                    // is at the appropriate place
                    // There are environment variable of the for =C:
                    // In order not to eliminate these we skip the first character in our search.
                    //
                    if (RtlEqualUnicodeString (Name, &CurrentName, TRUE) &&
                        (wcschr (p+1, L'=') == q)) {
                        //
                        // Names are equal.  Always return the length of the
                        // value string, excluding the terminating null.  If
                        // there is room in the caller's buffer, return a copy
                        // of the value string and success status.  Otherwise
                        // return an error status.  In the latter case, the caller
                        // can examine the length field of their value string
                        // so they can determine much memory is needed.
                        //
                        CurrentValue.Buffer = q+1;
                        CurrentValue.Length = (USHORT) ((len - 1) * sizeof (WCHAR) - NameLength);

                        Value->Length = CurrentValue.Length;
                        if (Value->MaximumLength >= CurrentValue.Length) {
                            RtlCopyMemory( Value->Buffer,
                                           CurrentValue.Buffer,
                                           CurrentValue.Length
                                         );
                            //
                            // Null terminate returned string if there is room.
                            //

                            if (Value->MaximumLength > CurrentValue.Length) {
                                Value->Buffer[ CurrentValue.Length/sizeof(WCHAR) ] = L'\0';
                            }

                            if (Environment == ProcessParameters->Environment) {
                                RtlpEnvironCacheValid = TRUE;
                                RtlpEnvironCacheName = CurrentName;
                                RtlpEnvironCacheValue = CurrentValue;
                            }

                            Status = STATUS_SUCCESS;
                        } else {
                            Status = STATUS_BUFFER_TOO_SMALL;
                        }

                        break;
                    }

                }
            }
            p += len + 1;
        }

        // If it's not in the real env block, let's see if it's a pseudo environment variable
        if (Status == STATUS_VARIABLE_NOT_FOUND) {
            static const UNICODE_STRING CurrentWorkingDirectoryPseudoVariable = RTL_CONSTANT_STRING(L"__CD__");
            static const UNICODE_STRING ApplicationDirectoryPseudoVariable = RTL_CONSTANT_STRING(L"__APPDIR__");

            if (RtlEqualUnicodeString(Name, &CurrentWorkingDirectoryPseudoVariable, TRUE)) {
                // Get the PEB lock if we don't already have it.
                if (!PebLockLocked) {
                    PebLockLocked = TRUE;
                    RtlAcquirePebLock();
                }

                // get cdw here...
                CurrentValue = ProcessParameters->CurrentDirectory.DosPath;
                Status = STATUS_SUCCESS;
            } else if (RtlEqualUnicodeString(Name, &ApplicationDirectoryPseudoVariable, TRUE)) {
                USHORT PrefixLength = 0;

                if (!PebLockLocked) {
                    PebLockLocked = TRUE;
                    RtlAcquirePebLock();
                }

                // get appdir here 
                CurrentValue = ProcessParameters->ImagePathName;

                Status = RtlFindCharInUnicodeString(
                                RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                                &CurrentValue,
                                &RtlDosPathSeperatorsString,
                                &PrefixLength);
                if (NT_SUCCESS(Status)) {
                    CurrentValue.Length = PrefixLength + sizeof(WCHAR);
                } else if (Status == STATUS_NOT_FOUND) {
                    // Use the whole thing; just translate the status to successs.
                    Status = STATUS_SUCCESS;
                }
            }

            if (NT_SUCCESS(Status)) {
                Value->Length = CurrentValue.Length;
                if (Value->MaximumLength >= CurrentValue.Length) {
                    RtlCopyMemory(Value->Buffer, CurrentValue.Buffer, CurrentValue.Length);

                    //
                    // Null terminate returned string if there is room.
                    //

                    if (Value->MaximumLength > CurrentValue.Length)
                        Value->Buffer[ CurrentValue.Length/sizeof(WCHAR) ] = L'\0';
                }
            }
        }



    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_ACCESS_VIOLATION;
    }


    //
    // Release the Peb lock.
    //

    if (PebLockLocked) {
        RtlReleasePebLock();
    }

    //
    // Return status.
    //

    return Status;
}


NTSTATUS
RtlSetEnvironmentVariable(
    IN OUT PVOID *Environment OPTIONAL,
    IN PCUNICODE_STRING Name,
    IN PCUNICODE_STRING Value OPTIONAL
    )
{
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    UNICODE_STRING CurrentName;
    UNICODE_STRING CurrentValue;
    PVOID pOld, pNew;
    ULONG n, Size;
    SIZE_T NewSize;
    LONG CompareResult;
    PWSTR p, pStart, pEnd;
    PWSTR InsertionPoint;
    PPEB Peb;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

    //
    // Validate passed in name and reject if zero length or anything but the first
    // character is an equal sign.
    //
    n = Name->Length / sizeof( WCHAR );
    if (n == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    try {
        p = Name->Buffer;
        while (--n) {
            if (*++p == L'=') {
                return STATUS_INVALID_PARAMETER;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    Peb = NtCurrentPeb ();

    ProcessParameters = Peb->ProcessParameters;

    Status = STATUS_VARIABLE_NOT_FOUND;

    pNew = NULL;
    InsertionPoint = NULL;

    if (ARGUMENT_PRESENT (Environment)) {
        pOld = *Environment;
    } else {
        //
        // Acquire the Peb Lock for the duration while we munge the
        // environment variable storage block.
        //

        RtlAcquirePebLock();

        //
        // Capture the pointer to the current process's environment variable
        // block.
        //

        pOld = ProcessParameters->Environment;
    }

    RtlpEnvironCacheValid = FALSE;

    try {
        try {

            //
            // The environment variable block consists of zero or more null
            // terminated UNICODE strings.  Each string is of the form:
            //
            //      name=value
            //
            // where the null termination is after the value.
            //

            p = pOld;
            pEnd = NULL;
            if (p != NULL) while (*p) {
                //
                // Determine the size of the name and value portions of
                // the current string of the environment variable block.
                //

                CurrentName.Buffer = p;
                CurrentName.Length = 0;
                CurrentName.MaximumLength = 0;
                while (*p) {
                    //
                    // If we see an equal sign, then compute the size of
                    // the name portion and scan for the end of the value.
                    //

                    if (*p == L'=' && p != CurrentName.Buffer) {
                        CurrentName.Length = (USHORT)(p - CurrentName.Buffer) * sizeof(WCHAR);
                        CurrentName.MaximumLength = (USHORT)(CurrentName.Length+sizeof(WCHAR));
                        CurrentValue.Buffer = ++p;

                        while(*p) {
                            p++;
                        }
                        CurrentValue.Length = (USHORT)(p - CurrentValue.Buffer) * sizeof(WCHAR);
                        CurrentValue.MaximumLength = (USHORT)(CurrentValue.Length+sizeof(WCHAR));

                        //
                        // At this point we have the length of both the name
                        // and value portions, so exit the loop so we can
                        // do the compare.
                        //
                        break;
                    }
                    else {
                        p++;
                    }
                }

                //
                // Skip over the terminating null character for this name=value
                // pair in preparation for the next iteration of the loop.
                //

                p++;

                //
                // Compare the current name with the one requested, ignore
                // case.
                //

                if (!(CompareResult = RtlCompareUnicodeString( Name, &CurrentName, TRUE ))) {
                    //
                    // Names are equal.  Now find the end of the current
                    // environment variable block.
                    //

                    pEnd = p;
                    while (*pEnd) {
                        while (*pEnd++) {
                        }
                    }
                    pEnd++;

                    if (!ARGUMENT_PRESENT( Value )) {
                        //
                        // If the caller did not specify a new value, then delete
                        // the entire name=value pair by copying up the remainder
                        // of the environment variable block.
                        //

                        RtlMoveMemory( CurrentName.Buffer,
                                       p,
                                       (ULONG) ((pEnd - p)*sizeof(WCHAR))
                                     );
                        Status = STATUS_SUCCESS;

                    } else if (Value->Length <= CurrentValue.Length) {
                        //
                        // New value is smaller, so copy new value, then null
                        // terminate it, and then move up the remainder of the
                        // variable block so it is immediately after the new
                        // null terminated value.
                        //

                        pStart = CurrentValue.Buffer;
                        RtlMoveMemory( pStart, Value->Buffer, Value->Length );
                        pStart += Value->Length/sizeof(WCHAR);
                        *pStart++ = L'\0';

                        RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)) );
                        Status = STATUS_SUCCESS;
                    } else {
                        //
                        // New value is larger, so query the current size of the
                        // environment variable block.  Return status if failure.
                        //

                        Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                                       pOld,
                                                       MemoryBasicInformation,
                                                       &MemoryInformation,
                                                       sizeof( MemoryInformation ),
                                                       NULL
                                                     );
                        if (!NT_SUCCESS( Status )) {
                            leave;
                        }

                        //
                        // See if there is room for new, larger value.  If not
                        // allocate a new copy of the environment variable
                        // block.
                        //

                        NewSize = (pEnd - (PWSTR)pOld)*sizeof(WCHAR) +
                                    Value->Length - CurrentValue.Length;
                        if (NewSize >= MemoryInformation.RegionSize) {
                            //
                            // Allocate memory to contain a copy of the current
                            // process's environment variable block.  Return
                            // status if failure.
                            //

                            Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                                              &pNew,
                                                              0,
                                                              &NewSize,
                                                              MEM_COMMIT,
                                                              PAGE_READWRITE
                                                            );
                            if (!NT_SUCCESS( Status )) {
                                leave;
                            }

                            //
                            // Copy the current process's environment to the allocated memory
                            // inserting the new value as we do the copy.
                            //

                            Size = (ULONG) (CurrentValue.Buffer - (PWSTR)pOld);
                            RtlMoveMemory( pNew, pOld, Size*sizeof(WCHAR) );
                            pStart = (PWSTR)pNew + Size;
                            RtlMoveMemory( pStart, Value->Buffer, Value->Length );
                            pStart += Value->Length/sizeof(WCHAR);
                            *pStart++ = L'\0';
                            RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)));

    			    if (ARGUMENT_PRESENT( Environment )) {
    			        *Environment = pNew;
                            } else {
    			        ProcessParameters->Environment = pNew;
                                Peb->EnvironmentUpdateCount += 1;
                            }

                            ZwFreeVirtualMemory (NtCurrentProcess(),
                                                 &pOld,
                                                 &MemoryInformation.RegionSize,
                                                 MEM_RELEASE);
                            pNew = pOld;
                        } else {
                            pStart = CurrentValue.Buffer + Value->Length/sizeof(WCHAR) + 1;
                            RtlMoveMemory (pStart, p, (ULONG)((pEnd - p)*sizeof(WCHAR)));
                            *--pStart = L'\0';

                            RtlMoveMemory (pStart - Value->Length/sizeof(WCHAR),
                                           Value->Buffer,
                                           Value->Length);
                        }
                    }

                    break;
                } else if (CompareResult < 0) {
                    //
                    // Requested name is less than the current name.  Save this
                    // spot in case the variable is not in a sorted position.
                    // The insertion point for the new variable is before the
                    // variable just examined.
                    //

                    if (InsertionPoint == NULL) {
                        InsertionPoint = CurrentName.Buffer;
                    }
                }
            }

            //
            // If we found an insertion point, reset the string
            // pointer back to it.
            //

            if (InsertionPoint != NULL) {
                p = InsertionPoint;
            }

            //
            // If variable name not found and a new value parameter was specified
            // then insert the new variable name and its value at the appropriate
            // place in the environment variable block (i.e. where p points to).
            //

            if (pEnd == NULL && ARGUMENT_PRESENT( Value )) {
                if (p != NULL) {
                    //
                    // Name not found.  Now find the end of the current
                    // environment variable block.
                    //

                    pEnd = p;
                    while (*pEnd) {
                        while (*pEnd++) {
                        }
                    }
                    pEnd++;

                    //
                    // New value is present, so query the current size of the
                    // environment variable block.  Return status if failure.
                    //

                    Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                                   pOld,
                                                   MemoryBasicInformation,
                                                   &MemoryInformation,
                                                   sizeof( MemoryInformation ),
                                                   NULL
                                                 );
                    if (!NT_SUCCESS( Status )) {
                        leave;
                    }

                    //
                    // See if there is room for new, larger value.  If not
                    // allocate a new copy of the environment variable
                    // block.
                    //

                    NewSize = (pEnd - (PWSTR)pOld) * sizeof(WCHAR) +
                              Name->Length +
                              sizeof(WCHAR) +
                              Value->Length +
                              sizeof(WCHAR);
                } else {
                    NewSize = Name->Length +
                              sizeof(WCHAR) +
                              Value->Length +
                              sizeof(WCHAR);
                    MemoryInformation.RegionSize = 0;
                }

                if (NewSize >= MemoryInformation.RegionSize) {
                    //
                    // Allocate memory to contain a copy of the current
                    // process's environment variable block.  Return
                    // status if failure.
                    //

                    Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                                      &pNew,
                                                      0,
                                                      &NewSize,
                                                      MEM_COMMIT,
                                                      PAGE_READWRITE
                                                    );
                    if (!NT_SUCCESS( Status )) {
                        leave;
                    }

                    //
                    // Copy the current process's environment to the allocated memory
                    // inserting the new value as we do the copy.
                    //

                    if (p != NULL) {
                        Size = (ULONG)(p - (PWSTR)pOld);
                        RtlMoveMemory( pNew, pOld, Size*sizeof(WCHAR) );
                    } else {
                        Size = 0;
                    }
                    pStart = (PWSTR)pNew + Size;
                    RtlMoveMemory( pStart, Name->Buffer, Name->Length );
                    pStart += Name->Length/sizeof(WCHAR);
                    *pStart++ = L'=';
                    RtlMoveMemory( pStart, Value->Buffer, Value->Length );
                    pStart += Value->Length/sizeof(WCHAR);
                    *pStart++ = L'\0';
                    if (p != NULL) {
                        RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)) );
                    }

                    if (ARGUMENT_PRESENT( Environment )) {
    		        *Environment = pNew;
                    } else {
    		        ProcessParameters->Environment = pNew;
                        Peb->EnvironmentUpdateCount += 1;
                    }

                    ZwFreeVirtualMemory (NtCurrentProcess(),
                                         &pOld,
                                         &MemoryInformation.RegionSize,
                                         MEM_RELEASE);
                } else {
                    pStart = p + Name->Length/sizeof(WCHAR) + 1 + Value->Length/sizeof(WCHAR) + 1;
                    RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)) );
                    RtlMoveMemory( p, Name->Buffer, Name->Length );
                    p += Name->Length/sizeof(WCHAR);
                    *p++ = L'=';
                    RtlMoveMemory( p, Value->Buffer, Value->Length );
                    p += Value->Length/sizeof(WCHAR);
                    *p++ = L'\0';
                }
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
              //
              // If abnormally terminating, assume access violation.
              //

              Status = STATUS_ACCESS_VIOLATION;
        }
    } finally {
        //
        // Release the Peb lock.
        //

        if (!ARGUMENT_PRESENT( Environment )) {
            RtlReleasePebLock();
        }
    }

    //
    // Return status.
    //

    return( Status );
}

NTSTATUS
NTAPI
RtlSetEnvironmentStrings(
    IN PWCHAR NewEnvironment,
    IN SIZE_T NewEnvironmentSize
    )
/*++

Routine Description:

    This routine allows the replacement of the current environment block with a new one.

Arguments:

    NewEnvironment - Pointer to a set of zero terminated strings terminated by two terminators

    NewEnvironmentSize - Size of the block to put in place in bytes

Return Value:

    NTSTATUS - Status of function call

--*/
{
    PPEB Peb;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID pOld, pNew;
    NTSTATUS Status, Status1;
    SIZE_T NewSize, OldSize;
    MEMORY_BASIC_INFORMATION MemoryInformation;


    //
    // Assert if the block is not well formed
    //
    ASSERT (NewEnvironmentSize > sizeof (WCHAR) * 2);
    ASSERT ((NewEnvironmentSize & (sizeof (WCHAR) - 1)) == 0);
    ASSERT (NewEnvironment[NewEnvironmentSize/sizeof(WCHAR)-1] == L'\0');
    ASSERT (NewEnvironment[NewEnvironmentSize/sizeof(WCHAR)-2] == L'\0');

    Peb = NtCurrentPeb ();

    ProcessParameters = Peb->ProcessParameters;

    RtlAcquirePebLock ();

    pOld = ProcessParameters->Environment;

    Status = ZwQueryVirtualMemory (NtCurrentProcess (),
                                   pOld,
                                   MemoryBasicInformation,
                                   &MemoryInformation,
                                   sizeof (MemoryInformation),
                                   NULL);
    if (!NT_SUCCESS (Status)) {
        goto unlock_and_exit;
    }

    if (MemoryInformation.RegionSize >= NewEnvironmentSize) {
        RtlpEnvironCacheValid = FALSE;
        RtlCopyMemory (pOld, NewEnvironment, NewEnvironmentSize);
        Status = STATUS_SUCCESS;
        goto unlock_and_exit;
    }

    //
    // Drop the lock around expensive operations
    //

    RtlReleasePebLock ();

    pOld = NULL;
    pNew = NULL;

    NewSize = NewEnvironmentSize;

    Status = ZwAllocateVirtualMemory (NtCurrentProcess (),
                                      &pNew,
                                      0,
                                      &NewSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Fill in the new block.
    //
    RtlCopyMemory (pNew, NewEnvironment, NewEnvironmentSize);

    //
    // Reacquire the lock. The existing block may have been reallocated
    // and so may now be big enough. Ignore this and use the block we
    // have created anyway.
    //

    RtlAcquirePebLock ();

    pOld = ProcessParameters->Environment;

    ProcessParameters->Environment = pNew;

    RtlpEnvironCacheValid = FALSE;

    RtlReleasePebLock ();


    //
    // Release the old block.
    //

    OldSize = 0;

    Status1 = ZwFreeVirtualMemory (NtCurrentProcess(),
                                   &pOld,
                                   &OldSize,
                                   MEM_RELEASE);

    ASSERT (NT_SUCCESS (Status1));

    return STATUS_SUCCESS;


unlock_and_exit:;
    RtlReleasePebLock ();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\compress.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    compress.c

Abstract:

    This module implements the NT Rtl compression engine.

Author:

    Gary Kimura     [GaryKi]    21-Jan-1994

Revision History:

--*/

#include "ntrtlp.h"


//
//  The following arrays hold procedures that we call to do the various
//  compression functions.  Each new compression function will need to
//  be added to this array.  For one that are currently not supported
//  we will fill in a not supported routine.
//

NTSTATUS
RtlCompressWorkSpaceSizeNS (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

NTSTATUS
RtlCompressBufferNS (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDecompressBufferNS (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

NTSTATUS
RtlDecompressFragmentNS (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDescribeChunkNS (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

NTSTATUS
RtlReserveChunkNS (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGELKCONST")
#endif

//
//  Routines to query the amount of memory needed for each workspace
//

const PRTL_COMPRESS_WORKSPACE_SIZE RtlWorkSpaceProcs[8] = {
    NULL,                          // 0
    NULL,                          // 1
    RtlCompressWorkSpaceSizeLZNT1, // 2
    RtlCompressWorkSpaceSizeNS,    // 3
    RtlCompressWorkSpaceSizeNS,    // 4
    RtlCompressWorkSpaceSizeNS,    // 5
    RtlCompressWorkSpaceSizeNS,    // 6
    RtlCompressWorkSpaceSizeNS     // 7
};

//
//  Routines to compress a buffer
//

const PRTL_COMPRESS_BUFFER RtlCompressBufferProcs[8] = {
    NULL,                   // 0
    NULL,                   // 1
    RtlCompressBufferLZNT1, // 2
    RtlCompressBufferNS,    // 3
    RtlCompressBufferNS,    // 4
    RtlCompressBufferNS,    // 5
    RtlCompressBufferNS,    // 6
    RtlCompressBufferNS     // 7
};

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGECONST")
#endif

//
//  Routines to decompress a buffer
//

const PRTL_DECOMPRESS_BUFFER RtlDecompressBufferProcs[8] = {
    NULL,                     // 0
    NULL,                     // 1
    RtlDecompressBufferLZNT1, // 2
    RtlDecompressBufferNS,    // 3
    RtlDecompressBufferNS,    // 4
    RtlDecompressBufferNS,    // 5
    RtlDecompressBufferNS,    // 6
    RtlDecompressBufferNS     // 7
};

//
//  Routines to decompress a fragment
//

const PRTL_DECOMPRESS_FRAGMENT RtlDecompressFragmentProcs[8] = {
    NULL,                       // 0
    NULL,                       // 1
    RtlDecompressFragmentLZNT1, // 2
    RtlDecompressFragmentNS,    // 3
    RtlDecompressFragmentNS,    // 4
    RtlDecompressFragmentNS,    // 5
    RtlDecompressFragmentNS,    // 6
    RtlDecompressFragmentNS     // 7
};

//
//  Routines to describe the current chunk
//

const PRTL_DESCRIBE_CHUNK RtlDescribeChunkProcs[8] = {
    NULL,                  // 0
    NULL,                  // 1
    RtlDescribeChunkLZNT1, // 2
    RtlDescribeChunkNS,    // 3
    RtlDescribeChunkNS,    // 4
    RtlDescribeChunkNS,    // 5
    RtlDescribeChunkNS,    // 6
    RtlDescribeChunkNS     // 7
};

//
//  Routines to reserve for a chunk
//

const PRTL_RESERVE_CHUNK RtlReserveChunkProcs[8] = {
    NULL,                 // 0
    NULL,                 // 1
    RtlReserveChunkLZNT1, // 2
    RtlReserveChunkNS,    // 3
    RtlReserveChunkNS,    // 4
    RtlReserveChunkNS,    // 5
    RtlReserveChunkNS,    // 6
    RtlReserveChunkNS     // 7
};

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)

//
// N.B. The two functions below are placed in the PAGELK section
//      because they need to be locked down in memory during Hibernation,
//      since they are used to enable compression of the Hiberfile.
//

#pragma alloc_text(PAGELK, RtlGetCompressionWorkSpaceSize)
#pragma alloc_text(PAGELK, RtlCompressBuffer)

#pragma alloc_text(PAGE, RtlDecompressChunks)
#pragma alloc_text(PAGE, RtlCompressChunks)
#pragma alloc_text(PAGE, RtlDecompressBuffer)
#pragma alloc_text(PAGE, RtlDecompressFragment)
#pragma alloc_text(PAGE, RtlDescribeChunk)
#pragma alloc_text(PAGE, RtlReserveChunk)
#pragma alloc_text(PAGE, RtlCompressWorkSpaceSizeNS)
#pragma alloc_text(PAGE, RtlCompressBufferNS)
#pragma alloc_text(PAGE, RtlDecompressBufferNS)
#pragma alloc_text(PAGE, RtlDecompressFragmentNS)
#pragma alloc_text(PAGE, RtlDescribeChunkNS)
#pragma alloc_text(PAGE, RtlReserveChunkNS)
#endif


NTSTATUS
RtlGetCompressionWorkSpaceSize (
    IN USHORT CompressionFormatAndEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    )


/*++

Routine Description:

    This routine returns to the caller the size in bytes of the
    different work space buffers need to perform the compression

Arguments:

    CompressionFormatAndEngine - Supplies the format and engine
        specification for the compressed data.

    CompressBufferWorkSpaceSize - Receives the size in bytes needed
        to compress a buffer.

    CompressBufferWorkSpaceSize - Receives the size in bytes needed
        to decompress a fragment.

Return Value:

    STATUS_SUCCESS - the operation worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    //
    //  Declare two variables to hold the format and engine specification
    //

    USHORT Format = CompressionFormatAndEngine & 0x00ff;
    USHORT Engine = CompressionFormatAndEngine & 0xff00;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the routine to return the workspace sizes.
    //

    return RtlWorkSpaceProcs[ Format ]( Engine,
                                        CompressBufferWorkSpaceSize,
                                        CompressFragmentWorkSpaceSize );
}


NTSTATUS
RtlCompressBuffer (
    IN USHORT CompressionFormatAndEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed buffer and produces
    its compressed equivalent provided the compressed data fits within
    the specified destination buffer.

    An output variable indicates the number of bytes used to store
    the compressed buffer.

Arguments:

    CompressionFormatAndEngine - Supplies the format and engine
        specification for the compressed data.

    UncompressedBuffer - Supplies a pointer to the uncompressed data.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to where the compressed data
        is to be stored.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    UncompressedChunkSize - Supplies the chunk size to use when
        compressing the input buffer.  The only valid values are
        512, 1024, 2048, and 4096.

    FinalCompressedSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed data.

    WorkSpace - Mind your own business, just give it to me.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input buffer was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    //
    //  Declare two variables to hold the format and engine specification
    //

    USHORT Format = CompressionFormatAndEngine & 0x00ff;
    USHORT Engine = CompressionFormatAndEngine & 0xff00;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the compression routine for the individual format
    //

    return RtlCompressBufferProcs[ Format ]( Engine,
                                             UncompressedBuffer,
                                             UncompressedBufferSize,
                                             CompressedBuffer,
                                             CompressedBufferSize,
                                             UncompressedChunkSize,
                                             FinalCompressedSize,
                                             WorkSpace );
}


NTSTATUS
RtlDecompressBuffer (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and produces
    its uncompressed equivalent provided the uncompressed data fits
    within the specified destination buffer.

    An output variable indicates the number of bytes used to store the
    uncompressed data.

Arguments:

    CompressionFormat - Supplies the format of the compressed data.

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        data is to be stored.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to the compressed data.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the uncompressed buffer to store the uncompressed data.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    //
    //  Declare two variables to hold the format specification
    //

    USHORT Format = CompressionFormat & 0x00ff;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the compression routine for the individual format
    //

    return RtlDecompressBufferProcs[ Format ]( UncompressedBuffer,
                                               UncompressedBufferSize,
                                               CompressedBuffer,
                                               CompressedBufferSize,
                                               FinalUncompressedSize );
}


NTSTATUS
RtlDecompressFragment (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and extract an
    uncompressed fragment.

    Output bytes are copied to the fragment buffer until either the
    fragment buffer is full or the end of the uncompressed buffer is
    reached.

    An output variable indicates the number of bytes used to store the
    uncompressed fragment.

Arguments:

    CompressionFormat - Supplies the format of the compressed data.

    UncompressedFragment - Supplies a pointer to where the uncompressed
        fragment is to be stored.

    UncompressedFragmentSize - Supplies the size, in bytes, of the
        uncompressed fragment buffer.

    CompressedBuffer - Supplies a pointer to the compressed data buffer.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FragmentOffset - Supplies the offset (zero based) where the uncompressed
        fragment is being extract from.  The offset is the position within
        the original uncompressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the Uncompressed fragment buffer to store the data.

Return Value:

    STATUS_SUCCESS - the operation worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    //
    //  Declare two variables to hold the format specification
    //

    USHORT Format = CompressionFormat & 0x00ff;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the compression routine for the individual format
    //

    return RtlDecompressFragmentProcs[ Format ]( UncompressedFragment,
                                                 UncompressedFragmentSize,
                                                 CompressedBuffer,
                                                 CompressedBufferSize,
                                                 FragmentOffset,
                                                 FinalUncompressedSize,
                                                 WorkSpace );
}


NTSYSAPI
NTSTATUS
NTAPI
RtlDescribeChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer, and returns
    a description of the current chunk in that buffer, updating
    the CompressedBuffer pointer to point to the next chunk (if
    there is one).

Arguments:

    CompressionFormat - Supplies the format of the compressed data.

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Receives the size of the current chunk pointed
        to by CompressedBuffer.  Returns 0 if STATUS_NO_MORE_ENTRIES.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

    STATUS_NO_MORE_ENTRIES - There is no chunk at the current pointer.

--*/

{
    //
    //  Declare two variables to hold the format specification
    //

    USHORT Format = CompressionFormat & 0x00ff;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the compression routine for the individual format
    //

    return RtlDescribeChunkProcs[ Format ]( CompressedBuffer,
                                            EndOfCompressedBufferPlus1,
                                            ChunkBuffer,
                                            ChunkSize );
}


NTSYSAPI
NTSTATUS
NTAPI
RtlReserveChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer, and reserves
    space for a chunk of the specified size - filling in any pattern
    as is necessary for a chunk of that size.  On return it has
    updated the CompressedBuffer pointer to point to the next chunk (if
    there is one).

Arguments:

    CompressionFormat - Supplies the format of the compressed data.

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Supplies the compressed size of the chunk to be received.
                Two special values are 0, and whatever the maximum
                uncompressed chunk size is for the routine.  0 means
                the chunk should be filled with a pattern that equates
                to all 0's.  The maximum chunk size implies that the
                compression routine should prepare to receive all of the
                data in uncompressed form.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    //
    //  Declare two variables to hold the format specification
    //

    USHORT Format = CompressionFormat & 0x00ff;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the compression routine for the individual format
    //

    return RtlReserveChunkProcs[ Format ]( CompressedBuffer,
                                           EndOfCompressedBufferPlus1,
                                           ChunkBuffer,
                                           ChunkSize );
}


NTSTATUS
RtlDecompressChunks (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN PUCHAR CompressedTail,
    IN ULONG CompressedTailSize,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer which is a stream
    of chunks and decompresses it into the specified destination buffer.
    The compressed data may be in two pieces, such that the "tail" of
    the buffer is top aligned in the buffer at CompressedTail, and the
    rest of the data is top aligned in the CompressedBuffer.  The
    CompressedBuffer can overlap and be top-aligned in the UncompressedBuffer,
    to allow something close to in-place decompression.  The CompressedTail
    must be large enough to completely contain the final chunk and it
    chunk header.

Arguments:

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        data is to be stored.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to the compressed data, part 1.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    CompressedTail - Supplies a pointer to the compressed data, part 2,
        which must be the bytes immediately following the CompressedBuffer.

    CompressedTailSize - Supplies the size of the CompressedTail.

    CompressedDataInfo - Supplies a complete description of the
        compressed data with all the chunk sizes and compression
        parameters.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    NTSTATUS Status;
    PULONG CurrentCompressedChunkSize;
    ULONG SizeToDecompress, FinalUncompressedSize;
    ULONG ChunksToGo = CompressedDataInfo->NumberOfChunks;
    ULONG UncompressedChunkSize = 1 << CompressedDataInfo->ChunkShift;

    CurrentCompressedChunkSize = &CompressedDataInfo->CompressedChunkSizes[0];

    //
    //  Loop to decompress chunks.
    //

    do {

        //
        //  Calculate uncompressed size of next chunk to decompress.
        //

        SizeToDecompress = UncompressedBufferSize;
        if (SizeToDecompress >= UncompressedChunkSize) {
            SizeToDecompress = UncompressedChunkSize;
        }

        //
        //  If the next chunk is all zeros, then zero it.
        //

        if ((ChunksToGo == 0) || (*CurrentCompressedChunkSize == 0)) {

            RtlZeroMemory( UncompressedBuffer, SizeToDecompress );

            //
            //  Test for out of chunks here and set to 1, so we can
            //  unconditionally decrement below.  Also back up the 
            //  CompressedChunkSize pointer because we dereference
            //  it as well.
            //

            if (ChunksToGo == 0) {
                ChunksToGo = 1;
                CurrentCompressedChunkSize -= 1;
            }

        //
        //  If the next chunk is not compressed, just copy it.
        //

        } else if (*CurrentCompressedChunkSize == UncompressedChunkSize) {

            //
            //  Does this chunk extend beyond the end of the current
            //  buffer?  If so, that probably means we can move the
            //  first part of the chunk, and then switch to the Compressed
            //  tail to get the rest.
            //

            if (SizeToDecompress >= CompressedBufferSize) {

                //
                //  If we have already switched to the tail, then this must
                //  be badly formatted compressed data.
                //

                if ((CompressedTailSize == 0) && (SizeToDecompress > CompressedBufferSize)) {
                    return STATUS_BAD_COMPRESSION_BUFFER;
                }

                //
                //  Copy the first part, and then the second part from the tail.
                //  Then switch to make the tail the current buffer.
                //

                RtlCopyMemory( UncompressedBuffer, CompressedBuffer, CompressedBufferSize );
                RtlCopyMemory( UncompressedBuffer + CompressedBufferSize,
                               CompressedTail,
                               SizeToDecompress - CompressedBufferSize );

                //
                //  If we exhausted the first buffer, move into the tail, knowing
                //  that we adjust these pointers by *CurrentCompressedChunkSize
                //  below.
                //

                CompressedBuffer = CompressedTail - CompressedBufferSize;
                CompressedBufferSize = CompressedTailSize + CompressedBufferSize;
                CompressedTailSize = 0;

            //
            //  Otherwise we can just copy the whole chunk.
            //

            } else {
                RtlCopyMemory( UncompressedBuffer, CompressedBuffer, SizeToDecompress );
            }

        //
        //  Otherwise it is a normal chunk to decompress.
        //

        } else {

            //
            //  Does this chunk extend beyond the end of the current
            //  buffer?  If so, that probably means we can move the
            //  first part of the chunk, and then switch to the Compressed
            //  tail to get the rest.  Since the tail must be at least
            //  ChunkSize, the last chunk cannot be the one that is
            //  overlapping into the tail.  Therefore, it is safe for
            //  us to copy the chunk to decompress into the last chunk
            //  of the uncompressed buffer, and decompress it from there.
            //

            if (*CurrentCompressedChunkSize > CompressedBufferSize) {

                //
                //  If we have already switched to the tail, then this must
                //  be badly formatted compressed data.
                //

                if (CompressedTailSize == 0) {
                    return STATUS_BAD_COMPRESSION_BUFFER;
                }

                //
                //  Move the beginning of the chunk to the beginning of the last
                //  chunk in the uncompressed buffer.  This move could overlap.
                //

                RtlMoveMemory( UncompressedBuffer + UncompressedBufferSize - UncompressedChunkSize,
                               CompressedBuffer,
                               CompressedBufferSize );

                //
                //  Move the rest of the chunk from the tail.
                //

                RtlCopyMemory( UncompressedBuffer + UncompressedBufferSize - UncompressedChunkSize + CompressedBufferSize,
                               CompressedTail,
                               *CurrentCompressedChunkSize - CompressedBufferSize );

                //
                //  We temporarily set CompressedBuffer to describe where we
                //  copied the chunk to make the call in common code, then we
                //  switch it into the tail below.
                //

                CompressedBuffer = UncompressedBuffer + UncompressedBufferSize - UncompressedChunkSize;
            }

            //
            //  Attempt the decompress.
            //

            Status =
            RtlDecompressBuffer( CompressedDataInfo->CompressionFormatAndEngine,
                                 UncompressedBuffer,
                                 SizeToDecompress,
                                 CompressedBuffer,
                                 *CurrentCompressedChunkSize,
                                 &FinalUncompressedSize );

            if (!NT_SUCCESS(Status)) {
                return Status;
            }

            //
            //  If we did not get a full chunk, zero the rest.
            //

            if (SizeToDecompress > FinalUncompressedSize) {
                RtlZeroMemory( UncompressedBuffer + FinalUncompressedSize,
                               SizeToDecompress - FinalUncompressedSize );
            }

            //
            //  If we exhausted the first buffer, move into the tail, knowing
            //  that we adjust these pointers by *CurrentCompressedChunkSize
            //  below.
            //

            if (*CurrentCompressedChunkSize >= CompressedBufferSize) {
                CompressedBuffer = CompressedTail - CompressedBufferSize;
                CompressedBufferSize = CompressedTailSize + CompressedBufferSize;
                CompressedTailSize = 0;
            }
        }

        //
        //  Update for next possible pass through the loop.
        //

        UncompressedBuffer += SizeToDecompress;
        UncompressedBufferSize -= SizeToDecompress;
        CompressedBuffer += *CurrentCompressedChunkSize;
        CompressedBufferSize -= *CurrentCompressedChunkSize;
        CurrentCompressedChunkSize += 1;
        ChunksToGo -= 1;

    } while (UncompressedBufferSize != 0);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlCompressChunks(
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed buffer and produces
    its compressed equivalent provided the compressed data fits within
    the specified destination buffer.

    The desired compression parameters must be supplied via the
    CompressedDataInfo structure, and this structure then returns all
    of the compressed chunk sizes.

    Note that since any given chunk (or all chunks) can simply be
    transmitted uncompressed, all error possibilities are actually
    stopped in this routine, except for STATUS_BUFFER_TOO_SMALL.
    This code will be returned when the data is not compressing
    sufficiently to warrant sending the data compressed.  The caller
    must field this error, and send the data uncompressed.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed data.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to where the compressed data
        is to be stored.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    CompressedDataInfo - Supplies the compression parameters, such as
        CompressionFormat, CompressionUnitSize, ChunkSize and ClusterSize,
        returns all of the compressed chunk sizes.

    CompressedDataInfoLength - Size of the supplied CompressedDataInfo
        in bytes.

    WorkSpace - A workspace area of the correct size as returned from
        RtlGetCompressionWorkSpaceSize.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_TOO_SMALL - the data is not compressing sufficiently to
        warrant sending the data compressed.

--*/

{
    NTSTATUS Status;
    PULONG CurrentCompressedChunkSize;
    ULONG SizeToCompress, FinalCompressedSize;
    ULONG UncompressedChunkSize = 1 << CompressedDataInfo->ChunkShift;

    //
    //  Make sure CompressedDataInfo is long enough.
    //

    ASSERT(CompressedDataInfoLength >=
           (sizeof(COMPRESSED_DATA_INFO) +
            ((UncompressedBufferSize - 1) >> (CompressedDataInfo->ChunkShift - 2))));

    //
    //  For the worst case, the compressed buffer actually has to be
    //  the same size as the uncompressed buffer, minus 1/16th.  We then
    //  will actually use that size.  If the data is not compressing very
    //  well, it is cheaper for us to actually send the data to the
    //  server uncompressed, than poorly compressed, because if the
    //  data is poorly compressed, the server will end up doing an
    //  extra copy before trying to compress the data again anyway.
    //

    ASSERT(CompressedBufferSize >= (UncompressedBufferSize - (UncompressedBufferSize / 16)));
    CompressedBufferSize = (UncompressedBufferSize - (UncompressedBufferSize / 16));

    //
    //  Initialize NumberOfChunks returned and the pointer to the first chunk size.
    //

    CompressedDataInfo->NumberOfChunks = 0;
    CurrentCompressedChunkSize = &CompressedDataInfo->CompressedChunkSizes[0];

    //
    //  Loop to decompress chunks.
    //

    do {

        //
        //  Calculate uncompressed size of next chunk to decompress.
        //

        SizeToCompress = UncompressedBufferSize;
        if (SizeToCompress >= UncompressedChunkSize) {
            SizeToCompress = UncompressedChunkSize;
        }

        //
        //  Now compress the next chunk.
        //

        Status = RtlCompressBuffer( CompressedDataInfo->CompressionFormatAndEngine,
                                    UncompressedBuffer,
                                    SizeToCompress,
                                    CompressedBuffer,
                                    CompressedBufferSize,
                                    UncompressedChunkSize,
                                    &FinalCompressedSize,
                                    WorkSpace );

        //
        //  If the Buffer was all zeros, then we will not send anything.
        //

        if (Status == STATUS_BUFFER_ALL_ZEROS) {

            FinalCompressedSize = 0;

        //
        //  Otherwise, if there was any kind of error (we only expect the
        //  case where the data did not compress), then just copy the
        //  data and return UncompressedChunkSize for this one.
        //

        } else if (!NT_SUCCESS(Status)) {

            //
            //  The most likely error is STATUS_BUFFER_TOO_SMALL.
            //  But in any case, our only recourse would be to send
            //  the data uncompressed.  To be completely safe, we
            //  see if there is enough space for an uncompressed chunk
            //  in the CompressedBuffer, and if not we return
            //  buffer too small (which is probably what we had anyway!).
            //

            if (CompressedBufferSize < UncompressedChunkSize) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            //  Copy the uncompressed chunk.
            //

            RtlCopyMemory( CompressedBuffer, UncompressedBuffer, SizeToCompress );
            if (UncompressedChunkSize > SizeToCompress) {
                RtlZeroMemory( (PCHAR)CompressedBuffer + SizeToCompress,
                               UncompressedChunkSize - SizeToCompress );
            }

            FinalCompressedSize = UncompressedChunkSize;
        }

        ASSERT(FinalCompressedSize <= CompressedBufferSize);

        //
        //  At this point, we have handled any error status.
        //

        Status = STATUS_SUCCESS;

        //
        //  Store the final chunk size.
        //

        *CurrentCompressedChunkSize = FinalCompressedSize;
        CurrentCompressedChunkSize += 1;
        CompressedDataInfo->NumberOfChunks += 1;

        //
        //  Prepare for the next trip through the loop.
        //

        UncompressedBuffer += SizeToCompress;
        UncompressedBufferSize -= SizeToCompress;
        CompressedBuffer += FinalCompressedSize;
        CompressedBufferSize -= FinalCompressedSize;

    } while (UncompressedBufferSize != 0);

    return Status;
}


NTSTATUS
RtlCompressWorkSpaceSizeNS (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    )
{
    return STATUS_UNSUPPORTED_COMPRESSION;
}

NTSTATUS
RtlCompressBufferNS (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    )
{
    return STATUS_UNSUPPORTED_COMPRESSION;
}

NTSTATUS
RtlDecompressBufferNS (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    )
{
    return STATUS_UNSUPPORTED_COMPRESSION;
}

NTSTATUS
RtlDecompressFragmentNS (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    )
{
    return STATUS_UNSUPPORTED_COMPRESSION;
}

NTSYSAPI
NTSTATUS
NTAPI
RtlDescribeChunkNS (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    )

{
    return STATUS_UNSUPPORTED_COMPRESSION;
}

NTSYSAPI
NTSTATUS
NTAPI
RtlReserveChunkNS (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    )

{
    return STATUS_UNSUPPORTED_COMPRESSION;
}

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\error.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains a routine for converting NT status codes
    to DOS/OS|2 error codes.

Author:

    David Treadwell (davidtr)   04-Apr-1991

Revision History:

--*/

#include <ntrtlp.h>
#include "winerror.h"
#include "error.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE, RtlGetLastNtStatus)
#pragma alloc_text(PAGE, RtlGetLastWin32Error)
#pragma alloc_text(PAGE, RtlNtStatusToDosError)
#pragma alloc_text(PAGE, RtlRestoreLastWin32Error)
#pragma alloc_text(PAGE, RtlSetLastWin32Error)
#pragma alloc_text(PAGE, RtlSetLastWin32ErrorAndNtStatusFromNtStatus)
#endif

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

ULONG
RtlNtStatusToDosError (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine converts an NT status code to its DOS/OS|2 equivalent.
    Remembers the Status code value in the TEB.

Arguments:

    Status - Supplies the status value to convert.

Return Value:

    The matching DOS/OS|2 error code.

--*/

{
    PTEB Teb;

    Teb = NtCurrentTeb();

    if (Teb) {
        try {
            Teb->LastStatusValue = Status;
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return RtlNtStatusToDosErrorNoTeb( Status );
}

ULONG
RtlNtStatusToDosErrorNoTeb (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine converts an NT status code to its DOS/OS 2 equivalent
    and returns the translated value.

Arguments:

    Status - Supplies the status value to convert.

Return Value:

    The matching DOS/OS 2 error code.

--*/

{

    ULONG Offset;
    ULONG Entry;
    ULONG Index;

    //
    // Convert any HRESULTs to their original form of a NTSTATUS or a
    // WIN32 error
    //


    if (Status & 0x20000000) {

        //
        // The customer bit is set so lets just pass the
        // error code on thru
        //

        return Status;

    }
    else if ((Status & 0xffff0000) == 0x80070000) {

        //
        // The status code  was a win32 error already.
        //

        return(Status & 0x0000ffff);
    }
    else if ((Status & 0xf0000000) == 0xd0000000) {

        //
        // The status code is a HRESULT from NTSTATUS
        //

        Status &= 0xcfffffff;
    }
    

    //
    // Scan the run length table and compute the entry in the translation
    // table that maps the specified status code to a DOS error code.
    //

    Entry = 0;
    Index = 0;
    do {
        if ((ULONG)Status >= RtlpRunTable[Entry + 1].BaseCode) {
            Index += (RtlpRunTable[Entry].RunLength * RtlpRunTable[Entry].CodeSize);

        } else {
            Offset = (ULONG)Status - RtlpRunTable[Entry].BaseCode;
            if (Offset >= RtlpRunTable[Entry].RunLength) {
                break;

            } else {
                Index += (Offset * (ULONG)RtlpRunTable[Entry].CodeSize);
                if (RtlpRunTable[Entry].CodeSize == 1) {
                    return (ULONG)RtlpStatusTable[Index];

                } else {
                    return (((ULONG)RtlpStatusTable[Index + 1] << 16) |
                                                (ULONG)RtlpStatusTable[Index]);
                }
            }
        }

        Entry += 1;
    } while (Entry < (sizeof(RtlpRunTable) / sizeof(RUN_ENTRY)));

    //
    // The translation to a DOS error code failed.
    //
    // The redirector maps unknown OS/2 error codes by ORing 0xC001 into
    // the high 16 bits.  Detect this and return the low 16 bits if true.
    //

    if (((ULONG)Status >> 16) == 0xC001) {
        return ((ULONG)Status & 0xFFFF);
    }

#ifndef NTOS_KERNEL_RUNTIME
    DbgPrint("RTL: RtlNtStatusToDosError(0x%lx): No Valid Win32 Error Mapping\n",Status);
    DbgPrint("RTL: Edit ntos\\rtl\\generr.c to correct the problem\n");
    DbgPrint("RTL: ERROR_MR_MID_NOT_FOUND is being returned\n");

#if DBG
    if ((Status & 0x0fff0000) != ((FACILITY_MSMQ) << 16)){

        //
        // If this is MSMQ facility error, skip the assert
        //

        DbgBreakPoint();
    }
    
#endif // DBG

#endif // NTOS_KERNEL_RUNTIME

    return ERROR_MR_MID_NOT_FOUND;
}

NTSTATUS
NTAPI
RtlGetLastNtStatus(
	VOID
	)
{
	return NtCurrentTeb()->LastStatusValue;
}

LONG
NTAPI
RtlGetLastWin32Error(
	VOID
	)
{
	return NtCurrentTeb()->LastErrorValue;
}

VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
	NTSTATUS Status
	)
{
	//
	// RtlNtStatusToDosError stores into NtCurrentTeb()->LastStatusValue.
	//
	RtlSetLastWin32Error(RtlNtStatusToDosError(Status));
}

VOID
NTAPI
RtlSetLastWin32Error(
	LONG Win32Error
	)
{
//
// Arguably this should clear or reset the last nt status, but it does not
// touch it.
//
	NtCurrentTeb()->LastErrorValue = Win32Error;
}

VOID
NTAPI
RtlRestoreLastWin32Error(
	LONG Win32Error
	)
{
#if DBG
	if ((LONG)NtCurrentTeb()->LastErrorValue != Win32Error)
#endif
		NtCurrentTeb()->LastErrorValue = Win32Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\rtl\excptdbg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    excptdbg.c

Abstract:

    This module implements an exception dispatcher logging facility.

Author:

    Kent Forschmiedt (kentf) 05-Oct-1995

Revision History:

    Jonathan Schwartz (jschwart)  16-Jun-2000
        Added RtlUnhandledExceptionFilter

    Jay Krell (a-JayK) November 2000
        Added RtlUnhandledExceptionFilter2, takes __FUNCTION__ parameter

--*/

#include "ntrtlp.h"

PLAST_EXCEPTION_LOG RtlpExceptionLog;
ULONG RtlpExceptionLogCount;
ULONG RtlpExceptionLogSize;


VOID
RtlInitializeExceptionLog(
    IN ULONG Entries
    )
/*++

Routine Description:

    This routine allocates space for the exception dispatcher logging
    facility, and records the address and size of the log area in globals
    where they can be found by the debugger.

    If memory is not available, the table pointer will remain NULL
    and the logging functions will do nothing.

Arguments:

    Entries - Supplies the number of entries to allocate for

Return Value:

    None

--*/
{
#if defined(NTOS_KERNEL_RUNTIME)
    RtlpExceptionLog = (PLAST_EXCEPTION_LOG)ExAllocatePoolWithTag( NonPagedPool, sizeof(LAST_EXCEPTION_LOG) * Entries, 'gbdE' );
#else
    //RtlpExceptionLog = (PLAST_EXCEPTION_LOG)RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(LAST_EXCEPTION_LOG) * Entries );
#endif
    if (RtlpExceptionLog) {
        RtlpExceptionLogSize = Entries;
    }
}


ULONG
RtlpLogExceptionHandler(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN ULONG_PTR ControlPc,
    IN PVOID HandlerData,
    IN ULONG Size
    )
/*++

Routine Description:

    Records the dispatching of exceptions to frame-based handlers.
    The debugger may inspect the table later and interpret the data
    to discover the address of the filters and handlers.

Arguments:

    ExceptionRecord - Supplies an exception record

    ContextRecord - Supplies the context at the exception

    ControlPc - Supplies the PC where control left the frame being
        dispatched to.

    HandlerData - Supplies a pointer to the host-dependent exception
        data.  On the RISC machines this is a RUNTIME_FUNCTION record;
        on x86 it is the registration record from the stack frame.

    Size - Supplies the size of HandlerData

Returns:

    The index to the log entry used, so that if the handler returns
    a disposition it may be recorded.

--*/
{
#if !defined(NTOS_KERNEL_RUNTIME)

    return 0;

#else

    ULONG LogIndex;

    if (!RtlpExceptionLog) {
        return 0;
    }

    ASSERT(Size <= MAX_EXCEPTION_LOG_DATA_SIZE * sizeof(ULONG));

    do {
        LogIndex = RtlpExceptionLogCount;
    } while (LogIndex != (ULONG)InterlockedCompareExchange(
                                    (PLONG)&RtlpExceptionLogCount,
                                    ((LogIndex + 1) % MAX_EXCEPTION_LOG),
                                    LogIndex));

    //
    // the debugger will have to interpret the exception handler
    // data, because it cannot be done safely here.
    //

    RtlCopyMemory(RtlpExceptionLog[LogIndex].HandlerData,
                  HandlerData,
                  Size);
    RtlpExceptionLog[LogIndex].ExceptionRecord = *ExceptionRecord;
    RtlpExceptionLog[LogIndex].ContextRecord = *ContextRecord;
    RtlpExceptionLog[LogIndex].Disposition = -1;

    return LogIndex;
#endif  // !NTOS_KERNEL_RUNTIME
}


VOID
RtlpLogLastExceptionDisposition(
    ULONG LogIndex,
    EXCEPTION_DISPOSITION Disposition
    )
/*++

Routine Description:

    Records the disposition from an exception handler.

Arguments:

    LogIndex - Supplies the entry number of the exception log record.

    Disposition - Supplies the disp