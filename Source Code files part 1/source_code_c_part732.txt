clude "precomp.h"
#include "priv.h"

CInetMonPort::CInetMonPort (
    LPCTSTR     lpszPortName,
    LPCTSTR     lpszDevDesc,
    PCPORTMGR   pPortMgr):
    m_bValid           (FALSE),
    m_pNext            (NULL),
    m_cRef             (0),
    m_cPrinterRef      (0),
    m_bDeletePending   (FALSE),
    m_lpszHost         (NULL),
    m_lpszShare        (NULL),
    m_pPortMgr         (pPortMgr),
    m_pGetPrinterCache           (NULL),
    m_pEnumJobsCache   (NULL),
    m_bCheckConnection (TRUE),
    m_hTerminateEvent  (NULL),
    m_pjmList          (NULL)

{
    PCINETMONPORT   pIniPort;
    PCINETMONPORT   pPort;
    LPTSTR          lpszHost;
    LPTSTR          lpszShare;
    INTERNET_PORT   iPort;
    BOOL            bSecure;

    // Parse out the host/share.  This call returns allocated
    // string-buffers.  It is our responsibility to free the
    // memory once we're done with it.
    //
    if (utlParseHostShare(lpszPortName, &lpszHost, &lpszShare, &iPort, &bSecure)) {

        // The (lpszDevDesc) could be NULL only if it's PP_REMOTE.
        //
        if (lpszDevDesc && *lpszDevDesc)
            m_lpszDesc = memAllocStr(lpszDevDesc);
        else
            m_lpszDesc = memAllocStr(lpszPortName);

        m_lpszName = memAllocStr (lpszPortName);

        // If succeeded, then continue to initialize the port.
        //
        if (m_lpszDesc && m_lpszName) {

            // Initialize the port-elements.
            //
            m_lpszHost         = lpszHost;
            m_lpszShare        = lpszShare;

            DBG_MSG(DBG_LEV_INFO, (TEXT("Info: _inet_create_port: Host(%s) Share(%s)"), lpszHost, lpszShare));

            m_pGetPrinterCache = new GetPrinterCache (this);
            m_pEnumJobsCache = new EnumJobsCache (this);

            if (m_pGetPrinterCache && m_pEnumJobsCache && m_pGetPrinterCache->bValid() && m_pEnumJobsCache->bValid ()) {
                m_bValid = TRUE;
            }
        }
    }
}


CInetMonPort::~CInetMonPort ()
{
    FreeGetPrinterCache ();
    FreeEnumJobsCache ();

    // Free the entry and all memory allocated on
    // behalf of the entry.
    //
    memFreeStr(m_lpszDesc);
    memFreeStr(m_lpszHost);
    memFreeStr(m_lpszShare);

    // Remove any job-entries.
    //
    pjmDelList(m_pjmList);

    m_pPortMgr->Remove ();
    delete m_pPortMgr;

    if (m_hTerminateEvent)
        CloseHandle (m_hTerminateEvent);
}


VOID
CInetMonPort::IncRef ()
{
    m_cRef++;
}

VOID
CInetMonPort::DecRef ()
{
    m_cRef--;
}

VOID
CInetMonPort::IncPrinterRef ()
{
    m_cPrinterRef++;
}

VOID
CInetMonPort::DecPrinterRef ()
{
    m_cPrinterRef--;
}

/*****************************************************************************\
* _inet_size_entry (Local Routine)
*
* Returns the size of an entry depending upon the print-level.
*
\*****************************************************************************/
DWORD
CInetMonPort::_inet_size_entry(
    DWORD       dwLevel)
{
    DWORD cb;

    switch (dwLevel) {

    case PRINT_LEVEL_1:

        cb = sizeof(PORT_INFO_1) + utlStrSize(m_lpszName);

        break;

    case PRINT_LEVEL_2:

        cb = sizeof(PORT_INFO_2)            +
             utlStrSize(m_lpszName) +
             utlStrSize(m_lpszDesc) +
             utlStrSize(g_szLocalPort);

        break;

    default:

        cb = 0;

        break;
    }

    return cb;
}


/*****************************************************************************\
* _inet_copy_entry (Local Routine)
*
* Returns a copy of the port-entry.
*
\*****************************************************************************/
LPBYTE
CInetMonPort::_inet_copy_entry(
    DWORD       dwLevel,
    LPBYTE      pPortInfo,
    LPBYTE      pEnd)
{
    LPTSTR SourceStrings[sizeof(PORT_INFO_2) / sizeof(LPTSTR)];
    LPTSTR *pSourceStrings=SourceStrings;
    DWORD  *pOffsets;


    static DWORD s_dwPortInfo1Strings[] = {
        offsetof(LPPORT_INFO_1A, pName),
        0xFFFFFFFF
    };

    static DWORD s_dwPortInfo2Strings[] = {
        offsetof(LPPORT_INFO_2A, pPortName),
        offsetof(LPPORT_INFO_2A, pMonitorName),
        offsetof(LPPORT_INFO_2A, pDescription),
        0xFFFFFFFF
    };


    //
    //
    switch (dwLevel) {
    case PORT_LEVEL_1:
        pOffsets = s_dwPortInfo1Strings;
        break;

    case PORT_LEVEL_2:
        pOffsets = s_dwPortInfo2Strings;
        break;

    default:
        return pEnd;
    }


    //
    //
    switch (dwLevel) {

    case PORT_LEVEL_1:
        *pSourceStrings++ = m_lpszName;
        pEnd = utlPackStrings(SourceStrings, pPortInfo, pOffsets, pEnd);
        break;

    case PORT_LEVEL_2:
        *pSourceStrings++ = (LPTSTR)m_lpszName;
        *pSourceStrings++ = (LPTSTR)g_szLocalPort;
        *pSourceStrings++ = (LPTSTR)m_lpszDesc;

#if 0
        ((PPORT_INFO_2)pPortInfo)->fPortType = PORT_TYPE_WRITE | PORT_TYPE_NET_ATTACHED;
#else
        ((PPORT_INFO_2)pPortInfo)->fPortType = PORT_TYPE_WRITE | PORT_TYPE_REDIRECTED;
#endif
        ((PPORT_INFO_2)pPortInfo)->Reserved  = 0;

        pEnd = utlPackStrings(SourceStrings, pPortInfo, pOffsets, pEnd);
        break;
    }

    return pEnd;
}

/*****************************************************************************\
* _inet_req_jobstart (Local Routine)
*
* Performs the job-start request.  This writes out the header info to the
* spool-job.
*
\*****************************************************************************/
BOOL
CInetMonPort::_inet_req_jobstart(
    PIPPREQ_PRTJOB ppj,
    PJOBMAP        pjmJob)
{
    LPBYTE  lpIppHdr;
    REQINFO ri;
    DWORD   cbIppHdr;
    DWORD   dwRet;
    DWORD   cbWr;
    BOOL    bRet = FALSE;


    // Convert the IPPREQ_PRTJOB to a IPP-stream-header.
    //
    ZeroMemory(&ri, sizeof(REQINFO));
    ri.cpReq = CP_UTF8;
    ri.idReq = IPP_REQ_PRINTJOB;

    ri.fReq[0] = IPP_REQALL;
    ri.fReq[1] = IPP_REQALL;

    dwRet = WebIppSndData(IPP_REQ_PRINTJOB,
                          &ri,
                          (LPBYTE)ppj,
                          ppj->cbSize,
                          &lpIppHdr,
                          &cbIppHdr);

    if (dwRet == WEBIPP_OK) {

        bRet = pjmSplWrite(pjmJob, lpIppHdr, cbIppHdr, &cbWr);

        WebIppFreeMem(lpIppHdr);
    }

    return bRet;
}


/*****************************************************************************\
* _inet_IppPrtRsp (Local Routine)
*
* Retrieves a get response from the IPP server.
*
\*****************************************************************************/
BOOL CALLBACK _inet_IppPrtRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hJobReq,
    PCINETMONPORT   pIniPort,
    PJOBMAP         pjmJob)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_JOB lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_PRINTJOB)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile (pConnection, hJobReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (bRet = lpRsp->bRet) {

                        // Set the remote-job-id to the job-entry.  This
                        // entry was added at the time the spool-job-file
                        // was created.
                        //
                        semEnterCrit();
                        pjmSetJobRemote(pjmJob, lpRsp->ji.ji2.JobId, lpRsp->ji.ipp.pJobUri);
                        semLeaveCrit();

                    } else {

                        // If the job failed to open on the server, then
                        // we will set the last-error from the server
                        // response.
                        //
                        SetLastError(lpRsp->dwLastError);
                    }

                    WebIppFreeMem(lpRsp);

                    goto EndPrtRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //
                    break;

                default:
                    DBG_MSG(DBG_LEV_ERROR, (TEXT("_inet_IppPrtRsp - Err : Receive Data Error (dwRet=%d, LE=%d)"),
                                             dwRet, WebIppGetError(hIpp)));
                    SetLastError(ERROR_INVALID_DATA);

                    goto EndPrtRsp;
                }

            } else {

                goto EndPrtRsp;
            }
        }

EndPrtRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* InetmonSendReq
*
*
\*****************************************************************************/
BOOL
CInetMonPort::SendReq(
    LPBYTE     lpIpp,
    DWORD      cbIpp,
    IPPRSPPROC pfnRsp,
    LPARAM     lParam,
    BOOL       bLeaveCrit)
{
    BOOL        bRet = FALSE;

    CMemStream  *pStream;

    pStream = new CMemStream (lpIpp, cbIpp);

    if (pStream && pStream->bValid ()){

        bRet = SendReq (pStream, pfnRsp, lParam, bLeaveCrit);
    }

    if (pStream) {
        delete pStream;
    }
    return bRet;
}

BOOL
CInetMonPort::SendReq(
    CStream    *pStream,
    IPPRSPPROC pfnRsp,
    LPARAM     lParam,
    BOOL       bLeaveCrit)
{
    DWORD       dwLE = ERROR_SUCCESS;
    BOOL        bRet = FALSE;

    semCheckCrit();

    if (bLeaveCrit)
        //
        // We must increaset the port ref count to make sure the
        // port is not deleted.
        //
        semSafeLeaveCrit(this);

    bRet = m_pPortMgr->SendRequest (this, pStream, pfnRsp, lParam);

    dwLE = GetLastError();

    if (bLeaveCrit)
        semSafeEnterCrit(this);

    if (!bRet) {
        // Need to check connection next time
        m_bCheckConnection = TRUE;
    }

    if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS))
        SetLastError(dwLE);

    return bRet;
}

/*****************************************************************************\
* InetmonClosePort
*
* Close the internet connection.
*
\*****************************************************************************/
BOOL
CInetMonPort::ClosePort(
    HANDLE hPrinter)
{
    CLogonUserData* pUser = NULL;

    semCheckCrit();

    // Now see if this is the last port handle that a user is closing
    if (hPrinter != NULL) { // This means we couldn't create the printer handle and
                            // had to close the port
        pUser = m_pPortMgr->GetUserIfLastDecRef (((LPINET_HPRINTER)hPrinter)->hUser);


        if (pUser) {
            // We need to stop the Cache Manager thread if the same user owns it
            DBG_MSG(DBG_LEV_INFO, (TEXT("Info: Last User Close Printer %p."), pUser));

            InvalidateGetPrinterCacheForUser(pUser );
            InvalidateEnumJobsCacheForUser(pUser );

            semLeaveCrit ();

            //
            // In some cases, wininet takes a long time to clean up the
            // browser session, so we have to leave the CS when making
            // InternetSetOption calls to wininet
            //

            EndBrowserSession ();

            semEnterCrit ();

            delete ( pUser );
        }

    }

    //
    // We stop decrease the ref count since we don't increase the
    // refcount at Open
    //

    DecPrinterRef();

    return TRUE;
}

/*****************************************************************************\
* InetmonStartDocPort
*
* Start the beginning of a StartDoc call.
*
\*****************************************************************************/
BOOL
CInetMonPort::StartDocPort(
    DWORD   dwLevel,
    LPBYTE  pDocInfo,
    PJOBMAP pjmJob)
{
    LPTSTR         lpszUser;
    PIPPREQ_PRTJOB ppj;
    BOOL           bRet = FALSE;
    DWORD          dwLE;

    semCheckCrit();

    // We are going to hit the network, so leave the critical section
    // To make sure the port will not be deleted, we increase the
    // ref count
    //
    semSafeLeaveCrit(this);

    bRet = m_pPortMgr->CheckConnection();

    dwLE = GetLastError();

    semSafeEnterCrit(this);

    if (bRet) {

        // Reset the value
        bRet = FALSE;


        // Get the username.
        //
        if (lpszUser = GetUserName()) {

            // Build a IPP_PRTJOB_REQ struct.  This routine assures that
            // all strings are in Ascii format.
            //
            ppj = WebIppCreatePrtJobReq(FALSE,
                                        lpszUser,
                                        ((PDOC_INFO_2)pDocInfo)->pDocName,
                                        m_lpszName);

            if (ppj) {

                // Start the job.  This writes out header info to the
                // spool-file.
                //
                bRet = _inet_req_jobstart(ppj, pjmJob);

                WebIppFreeMem(ppj);
            }

            memFreeStr(lpszUser);
        }

    } else {

        m_bCheckConnection = FALSE;
        SetLastError (dwLE);
    }

    if (bRet == FALSE) {
        DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : InetmonStartDocPort:  Failed %d"), GetLastError()));
    }

    return bRet;
}


/*****************************************************************************\
* InetmonEndDocPort
*
* Signify the end of writing to a port.  This is called after StartDocPort.
*
\*****************************************************************************/
BOOL
CInetMonPort::EndDocPort(
    PJOBMAP pjmJob)
{
    BOOL        bRet = FALSE;
    CFileStream *pStream = NULL;

    semCheckCrit();

    if (pStream = pjmSplLock(pjmJob)) {

        bRet = SendReq(pStream, (IPPRSPPROC)_inet_IppPrtRsp, (LPARAM)pjmJob, TRUE);

        pjmSplUnlock(pjmJob);
    }

    return bRet;
}


/*****************************************************************************\
* InetmonWritePort
*
* Write bytes to the port.  This goes to the spool-file until the
* InetmonEndDocPort() is called.
*
\*****************************************************************************/
BOOL
CInetMonPort::WritePort(
    PJOBMAP pjmJob,
    LPBYTE  lpData,
    DWORD   cbData,
    LPDWORD pcbWr)
{
    BOOL bRet;

    semCheckCrit();

    bRet = pjmSplWrite(pjmJob, lpData, cbData, pcbWr);

    return bRet;
}


/*****************************************************************************\
* InetmonAbortPort
*
* Aborts our print-spooling process.
*
\*****************************************************************************/
BOOL
CInetMonPort::AbortPort(
    PJOBMAP pjmJob)
{
    semCheckCrit();

    return TRUE; //(_inet_validate_port(hPort) ? TRUE : FALSE);
}


/*****************************************************************************\
* InetmonGetPortName
*
* Return the name of the port.
*
\*****************************************************************************/
LPCTSTR
CInetMonPort::GetPortName(
    VOID)
{
    LPCTSTR     lpszName = NULL;

    semCheckCrit();

    lpszName = (LPCTSTR)m_lpszName;

    return lpszName;
}


/*****************************************************************************\
* InetmonGetPJMList
*
*
\*****************************************************************************/
PJOBMAP*
CInetMonPort::GetPJMList(
    VOID)
{
    PJOBMAP*     ppjmList = NULL;

    semCheckCrit();

    ppjmList = &m_pjmList;

    return ppjmList;
}

/*****************************************************************************\
* InetmonIncUserRefCount
*
* Increases the reference count on the port for the given user
*
\*****************************************************************************/
DWORD
CInetMonPort::IncUserRefCount(
    PCLOGON_USERDATA hUser )
{

    DWORD       dwRet = (DWORD) -1;

    dwRet = m_pPortMgr->IncreaseUserRefCount (hUser);

    return dwRet;
}

VOID
CInetMonPort::FreeGetPrinterCache (
    VOID)
{
    if (m_pGetPrinterCache) {
        semLeaveCrit ();
        m_pGetPrinterCache->Shutdown ();
        semEnterCrit ();
    }
}

BOOL
CInetMonPort::BeginReadGetPrinterCache (
    PPRINTER_INFO_2 *ppInfo2)
{
    BOOL bRet = FALSE;

    if (m_pGetPrinterCache) {
        semLeaveCrit ();
        bRet = m_pGetPrinterCache->BeginReadCache (ppInfo2);
        semEnterCrit ();
    }

    return bRet;
}

VOID
CInetMonPort::EndReadGetPrinterCache (
    VOID)
{
    if (m_pGetPrinterCache) {
        m_pGetPrinterCache->EndReadCache ();
    }
}


VOID
CInetMonPort::InvalidateGetPrinterCache (
    VOID)
{
    if (m_pGetPrinterCache) {
        semLeaveCrit ();
        m_pGetPrinterCache->InvalidateCache ();
        semEnterCrit ();
    }
}

VOID
CInetMonPort::InvalidateGetPrinterCacheForUser(
    HANDLE hUser)
/*++

Routine Description:
    Close the cache if the current user is currently controlling it.

Arguments:
    hUser    - The user for which we want to close the cache

Return Value:
    None.

--*/
    {
    CLogonUserData   *pUser  = (CLogonUserData *)hUser;

    if (m_pGetPrinterCache && pUser) {

        semLeaveCrit ();
        m_pGetPrinterCache->InvalidateCacheForUser (pUser);
        semEnterCrit ();
    }
}

VOID
CInetMonPort::FreeEnumJobsCache (
    VOID)
{
    semLeaveCrit ();
    m_pEnumJobsCache->Shutdown ();
    semEnterCrit ();
}

BOOL
CInetMonPort::BeginReadEnumJobsCache (
    LPPPJOB_ENUM *ppje)
{
    BOOL bRet = FALSE;

    if (m_pEnumJobsCache) {
        semLeaveCrit ();
        bRet =  m_pEnumJobsCache->BeginReadCache(ppje);
        semEnterCrit ();
    }

    return bRet;

}

VOID
CInetMonPort::EndReadEnumJobsCache (
    VOID)
{
    if (m_pEnumJobsCache) {
        m_pEnumJobsCache->EndReadCache();
    }
}

VOID
CInetMonPort::InvalidateEnumJobsCache (
    VOID)
{
    if (m_pEnumJobsCache) {
        semLeaveCrit ();
        m_pEnumJobsCache->InvalidateCache ();
        semEnterCrit ();
    }
}

VOID
CInetMonPort::InvalidateEnumJobsCacheForUser(
    HANDLE hUser)
/*++

Routine Description:
    Close the cache if the current user is currently controlling it.

Arguments:
    hUser    - The user for which we want to close the cache

Return Value:
    None.

--*/
{

    if (m_pEnumJobsCache && hUser) {

        semLeaveCrit ();
        m_pEnumJobsCache->InvalidateCacheForUser ((CLogonUserData *)hUser);
        semEnterCrit ();
    }
}

BOOL
CInetMonPort::ReadFile (
    CAnyConnection *pConnection,
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd)
{
    return m_pPortMgr->ReadFile (pConnection, hReq, lpvBuffer, cbBuffer, lpcbRd);
}

BOOL
CInetMonPort::GetCurrentConfiguration (
    PINET_XCV_CONFIGURATION pXcvConfiguration)
{
    return m_pPortMgr->GetCurrentConfiguration(pXcvConfiguration);
}

BOOL
CInetMonPort::ConfigurePort (
    PINET_XCV_CONFIGURATION pXcvConfigurePortReqData,
    PINET_CONFIGUREPORT_RESPDATA pXcvAddPortRespData,
    DWORD cbSize,
    PDWORD cbSizeNeeded)
{
    return m_pPortMgr->ConfigurePort (pXcvConfigurePortReqData,
                                      pXcvAddPortRespData,
                                      cbSize,
                                      cbSizeNeeded);
}


HANDLE
CInetMonPort::CreateTerminateEvent (
    VOID)
{
    if (!m_hTerminateEvent) {
        //
        // Craete a manual reset event since multiple threads may be waiting
        //

        m_hTerminateEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
    }

    return m_hTerminateEvent;
}

BOOL
CInetMonPort::WaitForTermination (
    DWORD dwWaitTime)
{
    BOOL bTerminate = FALSE;

    semLeaveCrit();

    DWORD dwRet = WaitForSingleObject (m_hTerminateEvent, dwWaitTime);

    if (dwRet == WAIT_OBJECT_0 || dwRet == WAIT_FAILED)
        bTerminate = TRUE;

    semEnterCrit();

    return bTerminate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\globals.cxx ===
/*****************************************************************************\
* MODULE: globals.c
*
* This is the common global variable module.  Any globals used throughout the
* executable should be placed in here and the cooresponding declaration
* should be in "globals.h".
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


// Global variables which can change state.
//
HINSTANCE        g_hInst            = NULL;
DWORD            g_dwJobLimit       = 1000;        // 1000 iterations.
CRITICAL_SECTION g_csMonitorSection = {0, 0, 0, 0, 0, 0};
BOOL             g_bUpgrade         = FALSE;

CCriticalSection *g_pcsEndBrowserSessionLock = NULL;

CRITICAL_SECTION g_csCreateSection  = {0, 0, 0, 0, 0, 0};
HANDLE           g_eResetConnections= INVALID_HANDLE_VALUE;
DWORD            g_dwConCount       = 0;

#ifdef DEBUG
DWORD            g_dwCritOwner      = 0;
#endif


// Holds the machine-name.
//
TCHAR g_szMachine[MAX_COMPUTERNAME_LENGTH + 1] = {0};

LPTSTR g_szRegProvider = NULL;
LPTSTR g_szRegPrintProviders = NULL;

TCHAR g_szDefSplDir [MAX_PATH];
TCHAR g_szDisplayStr[MAX_PATH];

// Spooler-Directory Strings.
//
CONST TCHAR g_szSplDir9X []     = TEXT("\\spool\\printers");
CONST TCHAR g_szSplPfx   []     = TEXT("IPP");


// Constant string identifiers.
//
CONST TCHAR g_szUserAgent[]     = TEXT("Internet Print Provider");
CONST TCHAR g_szLocalPort[]     = TEXT("Internet Port");
CONST TCHAR g_szDisplayName[]   = TEXT("DisplayName");
CONST TCHAR g_szLibraryName[]   = TEXT("inetpp.dll");
CONST TCHAR g_szWinInetDll[]    = TEXT("wininet.dll");
CONST TCHAR g_szUriPrinters[]   = TEXT("scripts/%s/.printer");
CONST TCHAR g_szPOST[]          = TEXT("POST");
CONST TCHAR g_szGET[]           = TEXT("GET");
CONST TCHAR g_szContentLen[]    = TEXT("Content-length: %d\r\n");
CONST TCHAR g_szContentType[]   = TEXT("Content-type: application/ipp\r\n");
CONST TCHAR g_szEmptyString[]   = TEXT("");
CONST TCHAR g_szDescription[]   = TEXT("Windows NT Internet Printing");
CONST TCHAR g_szComment[]       = TEXT("Internet URL Printers");
CONST TCHAR g_szProviderName[]  = TEXT("Windows NT Internet Provider");
CONST TCHAR g_szNewLine[]       = TEXT("\n");
CONST TCHAR g_szConfigureMsg[]  = TEXT("There is nothing to configure for this port.");
CONST TCHAR g_szRegPorts[]      = TEXT("Ports");
CONST TCHAR g_szAuthDlg[]       = TEXT("AuthDlg");
CONST TCHAR g_szDocRemote[]     = TEXT("Remote Downlevel Document");
CONST TCHAR g_szDocLocal[]      = TEXT("Local Downlevel Document");

// Registry Value
//
CONST TCHAR g_szAuthMethod[]    = TEXT("Authentication");
CONST TCHAR g_szUserName[]      = TEXT("UserName");
CONST TCHAR g_szPassword[]      = TEXT("Password");
CONST TCHAR g_szPerUserPath[]   = TEXT("Printers\\Inetnet Print Provider");



// Http Version Number
//
CONST TCHAR g_szHttpVersion[]   = TEXT("HTTP/1.1");

CONST TCHAR g_szProcessName[] = TEXT("spoolsv.exe");


// String constants for the Internet API.  These strings are
// used exclusively by the GetProcAddress() call, which does not
// support Unicode.  Therefore, these strings should NOT be wrapped
// by the TEXT macro.
//
CONST CHAR g_szInternetCloseHandle[] = "InternetCloseHandle";
CONST CHAR g_szInternetErrorDlg[]    = "InternetErrorDlg";
CONST CHAR g_szInternetReadFile[]    = "InternetReadFile";
CONST CHAR g_szInternetWriteFile[]   = "InternetWriteFile";


#ifdef UNIMPLEMENTED

// NOTE: Currently, the release of WININET.DLL that was used (07-Aug-1996)
//       does not support the Unicode calls.  So, in order to support this
//       this correctly (Until it becomes available), this DLL will still
//       be compilable and runable in Unicode.  However, the WININET calls
//       will be dealt with as Ansi in the (inetwrap.c) module.
//
//       Change this to (#ifdef UNICODE) once WinInet is fixed
//       to support Unicode.  For now, we can rely on the wrappers
//       in "inetwrap.c"
//
//       15-Oct-1996 : ChrisWil
//

CONST CHAR g_szHttpQueryInfo[]         = "HttpQueryInfoW";
CONST CHAR g_szInternetOpenUrl[]       = "InternetOpenUrlW";
CONST CHAR g_szHttpSendRequest[]       = "HttpSendRequestW";
CONST CHAR g_szHttpSendRequestEx[]     = "HttpSendRequestExW";
CONST CHAR g_szInternetOpen[]          = "InternetOpenW";
CONST CHAR g_szInternetConnect[]       = "InternetConnectW";
CONST CHAR g_szHttpOpenRequest[]       = "HttpOpenRequestW";
CONST CHAR g_szHttpAddRequestHeaders[] = "HttpAddRequestHeadersW";
CONST CHAR g_szHttpEndRequest[]        = "HttpEndRequestW";
CONST CHAR g_szInternetSetOption[]     = "InternetSetOptionW";

#else

CONST CHAR g_szHttpQueryInfo[]         = "HttpQueryInfoA";
CONST CHAR g_szInternetOpenUrl[]       = "InternetOpenUrlA";
CONST CHAR g_szHttpSendRequest[]       = "HttpSendRequestA";
CONST CHAR g_szHttpSendRequestEx[]     = "HttpSendRequestExA";
CONST CHAR g_szInternetOpen[]          = "InternetOpenA";
CONST CHAR g_szInternetConnect[]       = "InternetConnectA";
CONST CHAR g_szHttpOpenRequest[]       = "HttpOpenRequestA";
CONST CHAR g_szHttpAddRequestHeaders[] = "HttpAddRequestHeadersA";
CONST CHAR g_szHttpEndRequest[]        = "HttpEndRequestA";
CONST CHAR g_szInternetSetOption[]     = "InternetSetOptionA";

#endif


// Internet API pointers for controling the Url output.
//
PFNHTTPQUERYINFO         g_pfnHttpQueryInfo;
PFNINTERNETOPENURL       g_pfnInternetOpenUrl;
PFNINTERNETERRORDLG      g_pfnInternetErrorDlg;
PFNHTTPSENDREQUEST       g_pfnHttpSendRequest;
PFNHTTPSENDREQUESTEX     g_pfnHttpSendRequestEx;
PFNINTERNETREADFILE      g_pfnInternetReadFile;
PFNINTERNETWRITEFILE     g_pfnInternetWriteFile;
PFNINTERNETCLOSEHANDLE   g_pfnInternetCloseHandle;
PFNINTERNETOPEN          g_pfnInternetOpen;
PFNINTERNETCONNECT       g_pfnInternetConnect;
PFNHTTPOPENREQUEST       g_pfnHttpOpenRequest;
PFNHTTPADDREQUESTHEADERS g_pfnHttpAddRequestHeaders;
PFNHTTPENDREQUEST        g_pfnHttpEndRequest;
PFNINTERNETSETOPTION     g_pfnInternetSetOption;


PCINETMON gpInetMon = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\inetpp.cxx ===
/*****************************************************************************\
* MODULE: inetpp.c
*
* The module contains routines for handling the INETPP functionality.  Use
* of these routines require the locking/unlocking of a critical-section
* to maninpulate the INIMONPORT list.  All internal routines assume the
* crit-sect is locked prior to executing.  CheckMonCrit() is a debugging
* call to verify the monitor-crit-sect is locked.
*
* NOTE: Each of the Inetmon* calls must be protected by the global-crit-sect.
*       If a new routine is added to this module which is to be called from
*       another module, be sure to include the call to (semCheckCrit), so
*       that the debug-code can catch unprotected access.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*   14-Nov-1997 ChrisWil    Added local-spooling functionality.
*   10-Jul-1998 WeihaiC     Change Authentication Dialog Code
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


CInetMon::CInetMon ()
{
    // Initialize the monitor-port-list.
    //
    m_pPortList = (PINIMONPORTLIST)memAlloc(sizeof(INIMONPORTLIST));

    m_bValid = (m_pPortList != NULL);
}

CInetMon::~CInetMon ()
{
}

/*****************************************************************************\
* _inet_validate_portname (Local Routine)
*
* Validate the portname.
*
* NOTE: If this check becomes more rigorous, it must account for the (%)
*       character (escape).
*
\*****************************************************************************/
BOOL
CInetMon::_inet_validate_portname(
    LPCTSTR lpszPortName)
{
    if (lpszPortName && (*lpszPortName))
        return TRUE;

    DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : _inet_validate_portname : Invalid Name")));
    SetLastError(ERROR_INVALID_NAME);

    return FALSE;
}


/*****************************************************************************\
* _inet_find_port (Local Routine)
*
* Locates the entry in the list where the port-name resides.  Return the
* full entry-type (INIMONPORT) for the location.
*
\*****************************************************************************/
PCINETMONPORT
CInetMon::_inet_find_port(
    LPCTSTR lpszPortName)
{
    PCINETMONPORT pIniPort;

    pIniPort = m_pPortList->pIniFirstPort;

    while (pIniPort && lstrcmpi(lpszPortName, pIniPort->m_lpszName))
        pIniPort = pIniPort->m_pNext;

    return pIniPort;
}

/*****************************************************************************\
* _inet_create_port (Local Routine)
*
* Create a new port data structure and link into the list.  This routine
* assumes that the Crit is held.
*
* This routine also assumes the pszPortName is a valid http:// format.
*
\*****************************************************************************/
PCINETMONPORT
CInetMon::_inet_create_port(
    LPCTSTR     lpszPortName,
    PCPORTMGR   pPortMgr)
{
    PCINETMONPORT pIniPort;
    PCINETMONPORT pPort;
    BOOL bRet = FALSE;


    if ((pIniPort = new CInetMonPort (lpszPortName, g_szLocalPort, pPortMgr)) &&
        pIniPort->bValid ()) {

        // Set the link.  If this is the first port added, the
        // we set the global variable.
        //
        if (pPort = m_pPortList->pIniFirstPort) {

            while (pPort->GetNext())
                pPort = pPort->GetNext();

            pPort->SetNext (pIniPort);

        } else {

            m_pPortList->pIniFirstPort = pIniPort;
        }

        bRet = TRUE;
    }

    if (!bRet) {

        if (pIniPort) {
            delete pIniPort;
            pIniPort = NULL;
        }
    }

    return pIniPort;
}

/*****************************************************************************\
* _inet_delete_port (Local Routine)
*
* Free a port data structure that is no longer needed.
*
\*****************************************************************************/
BOOL
CInetMon::_inet_delete_port(
    LPCTSTR lpszPortName)
{
    PCINETMONPORT pIniPort;
    PCINETMONPORT pPrvPort;
    BOOL        bRet = FALSE;


    // Keep track of our previous/current entries, so that
    // we can remove the specified port.
    //
    pIniPort = m_pPortList->pIniFirstPort;

    while (pIniPort && lstrcmpi(pIniPort->m_lpszName, lpszPortName)) {

        pPrvPort = pIniPort;
        pIniPort = pIniPort->GetNext ();
    }


    // If the PortName is found, then delete it.
    //
    if (pIniPort) {

        if (pIniPort->m_cRef > 0 && pIniPort->m_hTerminateEvent) {

            // To tell spooling thread to terminate
            //
            SetEvent (pIniPort->m_hTerminateEvent);

            semSafeLeaveCrit(pIniPort);
            //
            // Leave the critical section so that the spooling thread can decrease the ref count
            //

            Sleep (250);

            semSafeEnterCrit (pIniPort);

        }

        // Only allow this port to be deleted if the reference count
        // is at zero.
        //

        if (pIniPort->m_cRef == 0) {

            pIniPort->m_bDeletePending = TRUE;

            //
            // Remove the pointer from the list
            //
            // If this is our first-port then we need to handle
            // differently as we keep a global-pointer to this.
            //
            if (pIniPort == m_pPortList->pIniFirstPort) {

                m_pPortList->pIniFirstPort = pIniPort->GetNext();

            } else {

                pPrvPort->SetNext(pIniPort->GetNext());
            }

            // We only free the memeory if there are no open handles
            //
            if (pIniPort->m_cPrinterRef == 0) {

                DBG_MSG(DBG_LEV_INFO, (TEXT("Info: pIniPort Freed %p."), pIniPort));

                delete pIniPort;
            }

            bRet = TRUE;

        } else {

            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: _inet_delete_port: Port in use: Name(%s)"), lpszPortName));
            SetLastError(ERROR_BUSY);
        }

    } else {

        DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: _inet_delete_port: Unrecognized PortName: Name(%s)"), lpszPortName));
        SetLastError(ERROR_UNKNOWN_PORT);
    }

    return bRet;
}

/*****************************************************************************\
* _inet_is_xcv_open
*
* Check whether it is a XCV Open
*
\*****************************************************************************/
BOOL
CInetMon::_inet_is_xcv_open (
    LPCTSTR     lpszPortName,
    LPTSTR      *ppszServerName,
    LPTSTR      *ppszRealPortName,
    LPBOOL      pbXcv)
{
    static CONST TCHAR cchSlash = _T ('\\');
    static CONST TCHAR cszXcvPort[] = _T (",XcvPort ");
    static CONST DWORD cdwXcvPortLen = (sizeof (cszXcvPort) / sizeof (TCHAR)) - 1;
    BOOL bRet = TRUE;
    LPCTSTR pServerStart = NULL;
    LPTSTR pServerEnd = NULL;
    LPTSTR pszServerName = NULL;
    LPTSTR pszRealPortName = NULL;


    // "\\Server\,XcvPort Object_" */

    DWORD dwLen = lstrlen (lpszPortName);
    *pbXcv = FALSE;

    if (dwLen > cdwXcvPortLen + 1) {

        if (lpszPortName[0] == _T (',')) {
            // No Server
            pServerEnd = (LPTSTR) lpszPortName;
        }
        else if (lpszPortName[0] == cchSlash && lpszPortName[1] == cchSlash)  {

            pServerStart = lpszPortName + 2;
            if (pServerEnd = _tcschr (pServerStart, cchSlash))
                pServerEnd ++;
        }
        else {
            return bRet;
        }

        if (pServerEnd && ! _tcsncmp (pServerEnd, cszXcvPort, cdwXcvPortLen)) {

            LPCTSTR pPortStart = pServerEnd + cdwXcvPortLen;

            if (pServerStart) {
                pszServerName = new TCHAR [(pServerEnd - 1) - pServerStart + 1];
                if (!pszServerName) {
                    bRet = FALSE;
                }
                else {
                    StringCchCopy(pszServerName, pServerEnd - 1 - pServerStart, pServerStart);
                    pszServerName[pServerEnd - 1 - pServerStart] = 0;
                }
            }

            if (bRet) {
                size_t uSize = lstrlen (pPortStart) + 1;

                pszRealPortName = new TCHAR [uSize];

                if (!pszRealPortName)
                    bRet = FALSE;
                else {
                    if (SUCCEEDED(StringCchCopy(pszRealPortName, uSize, pPortStart)))
                        *pbXcv = TRUE;
                    else
                        bRet = FALSE;
                }
            }

            if (!bRet) {
                if (pszServerName) {
                    delete [] pszServerName;
                    pszServerName = NULL;
                }

                if (pszRealPortName) {
                    delete [] pszRealPortName;
                    pszRealPortName = NULL;
                }
            }

            *ppszServerName = pszServerName;
            *ppszRealPortName = pszRealPortName;

        }

    }

    return bRet;
}

PCINETMONPORT
CInetMon::InetmonOpenPort(
    LPCTSTR lpszPortName,
    PBOOL   pbXcv)
{
    PCINETMONPORT   pIniPort = NULL;
    PCPORTMGR       pPortMgr = NULL;
    DWORD           dwLE;

    *pbXcv = FALSE;

    semCheckCrit();

    if (_inet_validate_portname(lpszPortName)) {

        // Let's first look to see if it is a XCV call

        LPTSTR pszServerName = NULL;
        LPTSTR pszRealPortName = NULL;
        BOOL bXcv;

        if (_inet_is_xcv_open (lpszPortName, &pszServerName, &pszRealPortName, &bXcv) && bXcv) {

            if (pIniPort = _inet_find_port(pszRealPortName)) {

                if (!pIniPort->m_bDeletePending) {
                    // The refrernce to the iniport is not changed, since the client may open a XCV handle
                    // to delete the port
                    //
                    *pbXcv = TRUE;
                }
                else {
                    DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : InetmonOpenPort (XCV) : Open deleted port: Port(%s)"), lpszPortName));
                    SetLastError(ERROR_INVALID_NAME);
                }
            }

            // This is a valid XcvOpen
            if (pszServerName) {
                delete [] pszServerName;
            }
            if (pszRealPortName) {
                delete [] pszRealPortName;
            }

            if (pIniPort)
            {
                return pIniPort;
            }
        }

        // Let's first look to see if this port is already in the
        // list.  If not, then add it to the list and continue with
        // the open.
        //
        if ((pIniPort = _inet_find_port(lpszPortName)) == NULL) {

            semLeaveCrit();
            // Leave the critical section becuase the following call will hit the network
            pPortMgr = new CPortMgr;

            if (pPortMgr != NULL) {
                if (! pPortMgr->Create (lpszPortName)) {
                    delete (pPortMgr);
                    pPortMgr = NULL;
                }
            }

            dwLE = GetLastError ();
            semEnterCrit();

            if (! (pPortMgr)) {
                // The connection is invalid

                DBG_MSG(DBG_LEV_ERROR, (TEXT("Err: InetmonOpenPort : PortMgrCreate Failed: LastError(%d)"), GetLastError()));

                if (dwLE != ERROR_ACCESS_DENIED &&
                    dwLE != ERROR_INVALID_PRINTER_NAME &&
                    dwLE != ERROR_INVALID_NAME) {

                    dwLE = ERROR_PRINTER_NOT_FOUND;
                }

                SetLastError ( dwLE );

                goto exit_openport;
            }

            if (_inet_create_port(lpszPortName, pPortMgr) == FALSE) {

                DBG_MSG(DBG_LEV_ERROR, (TEXT("Err: InetmonOpenPort : Add Port Failed: LastError(%d)"), GetLastError()));
                SetLastError(ERROR_INVALID_NAME);

                goto exit_openport;
            }
        }


        if (pIniPort || (pIniPort = _inet_find_port(lpszPortName))) {

            if (!pIniPort->m_bDeletePending) {
                //
                // We stop increasing the ref count since the open handles
                // won't have affect on the port deletion, i.e. the port
                // may be deleted even when there are open handles.
                //
                // pIniPort->m_cRef ++;

                //
                //  Increase the printer open handle ref count. This
                //  count is used to manage the life time of the PCINETMONPORT
                //  data structure. i.e. if the port is deleted when there are
                //  open handles, PCINETMONPORT is not freed until
                //
                //  pIniPort->m_cPrinterRef == 0
                //

                pIniPort->IncPrinterRef ();

            }
            else {
                DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : InetmonOpenPort : Open deleted port: Port(%s)"), lpszPortName));
                SetLastError(ERROR_INVALID_NAME);
            }


        } else {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : InetmonOpenPort : Invalid Name: Port(%s)"), lpszPortName));
            SetLastError(ERROR_INVALID_NAME);
        }
    }

exit_openport:

    return pIniPort;
}

BOOL
CInetMon::InetmonReleasePort(
    PCINETMONPORT   pIniPort)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: InetmonReleasePort: pIniPort(%08lX)"), pIniPort));

    semCheckCrit();

    // Validate the port and proceed to close the port.
    //
    pIniPort->DecPrinterRef ();

    if (pIniPort->m_bDeletePending && pIniPort->m_cPrinterRef == 0) {
        //
        // There is no open handles, free PCINETMONPORT
        //

        DBG_MSG(DBG_LEV_INFO, (TEXT("Info: InetmonReleasePort free pIniPort  %p."), pIniPort));

        delete pIniPort;
    }

    return TRUE;
}

/*****************************************************************************\
* InetmonClosePort
*
* Close the internet connection.
*
\*****************************************************************************/
BOOL
CInetMon::InetmonClosePort(
    PCINETMONPORT   pIniPort,
    HANDLE          hPrinter)
{

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: InetmonClosePort: pIniPort(%08lX)"), pIniPort));

    semCheckCrit();

    pIniPort->ClosePort (hPrinter);

    if (pIniPort->m_bDeletePending && pIniPort->m_cPrinterRef == 0) {
        //
        // There is no open handles, free PCINETMONPORT
        //

        DBG_MSG(DBG_LEV_INFO, (TEXT("Info: pIniPort Freed %p."), pIniPort));

        delete pIniPort;
    }

    return TRUE;
}

/*****************************************************************************\
* InetmonEnumPorts
*
* Enumerate the ports registered in our list.
*
\*****************************************************************************/
BOOL
CInetMon::InetmonEnumPorts(
    LPTSTR  lpszServerName,
    DWORD   dwLevel,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    PCINETMONPORT   pIniPort;
    DWORD           cb;
    LPBYTE          pEnd;
    DWORD           dwError = ERROR_SUCCESS;

    semCheckCrit();

    // Traverse the list to build the size of the entire list.
    //
    cb = 0;

    pIniPort = m_pPortList->pIniFirstPort;

    while (pIniPort) {

        cb += pIniPort->_inet_size_entry(dwLevel);

        pIniPort = pIniPort->m_pNext;
    }


    // Store the size of the list (This is the size needed).
    //
    *pcbNeeded = cb;


    // If the size of the list is capable of being stored in the buffer
    // passed in, then we can return the entries.
    //
    if (cb <= cbBuf) {

        pEnd = pPorts + cbBuf;

        *pcReturned = 0;

        pIniPort = m_pPortList->pIniFirstPort;

        while (pIniPort) {

            pEnd = pIniPort->_inet_copy_entry(dwLevel, pPorts, pEnd);

            switch (dwLevel) {

            case PRINT_LEVEL_1:
                pPorts += sizeof(PORT_INFO_1);
                break;

            case PRINT_LEVEL_2:
                pPorts += sizeof(PORT_INFO_2);
                break;
            }

            pIniPort = pIniPort->m_pNext;

            (*pcReturned)++;
        }

    } else {

        dwError = ERROR_INSUFFICIENT_BUFFER;
    }

    if (dwError != ERROR_SUCCESS) {
        SetLastError(dwError);
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************\
* InetmonDeletePort
*
* Deletes a port from the INIMONPORT list.
*
\*****************************************************************************/
BOOL
CInetMon::InetmonDeletePort(
    LPCTSTR lpszPortName,
    HWND    hWnd,
    LPCTSTR lpszMonitorName)
{
    BOOL bRet = FALSE;

    semCheckCrit();

    if (_inet_validate_portname(lpszPortName))
        bRet = _inet_delete_port(lpszPortName);

    return bRet;
}


/*****************************************************************************\
* InetmonAddPort
*
* Adds a port to the INIMONPORT list.
*
\*****************************************************************************/
BOOL
CInetMon::InetmonAddPort(
    LPCTSTR lpszPortName,
    LPCTSTR lpszMonitorName)
{
    BOOL bRet = FALSE;
    PCPORTMGR pPortMgr = NULL;

    semCheckCrit();

    // If the port is not-found, then we can add it.  Otherwise,
    // the port already exists.
    //
    if (_inet_validate_portname(lpszPortName)) {

        if (_inet_find_port(lpszPortName) == NULL) {

            pPortMgr = new CPortMgr;

            if (pPortMgr != NULL) {
                if (!pPortMgr->Init (lpszPortName)) {
                    delete pPortMgr;
                    pPortMgr = NULL;
                }

                if (pPortMgr) {
                    bRet = (_inet_create_port(lpszPortName, pPortMgr) != NULL);
                }
            }
        }
    }

    return bRet;
}


/*****************************************************************************\
* InetmonFindPort
*
* Looks for port in INIMONPORT list.
*
\*****************************************************************************/
PCINETMONPORT
CInetMon::InetmonFindPort(
    LPCTSTR lpszPortName)
{
    PCINETMONPORT hPort = NULL;

    semCheckCrit();

    if (_inet_validate_portname(lpszPortName))
        hPort = _inet_find_port(lpszPortName) ;

    return hPort;
}

/********************************************************************************
** End of FIle (inetpp.c)
********************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\inetport.h ===
/*****************************************************************************\
* MODULE: inetpp.h
*
* Header file for the INETPP provider routines.
*
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   13-Sep-2000 weihaic Created
*
\*****************************************************************************/

#ifndef _INETPORT_H
#define _INETPORT_H

typedef class CInetMonPort* PCINETMONPORT;
class GetPrinterCache;
class EnumJobsCache;

class CInetMonPort {
public:
    CInetMonPort (
        LPCTSTR     lpszPortName,
        LPCTSTR     lpszDevDesc,
        PCPORTMGR   pPortMgr);

    ~CInetMonPort ();

    inline BOOL
    bValid (VOID) CONST { return m_bValid; };


    VOID
    IncRef ();

    VOID
    DecRef ();

    VOID
    IncPrinterRef ();

    VOID
    DecPrinterRef ();

    BOOL
    SendReq(
        LPBYTE     lpIpp,
        DWORD      cbIpp,
        IPPRSPPROC pfnRsp,
        LPARAM     lParam,
        BOOL       bLeaveCrit);

    BOOL
    SendReq(
        CStream    *pStream,
        IPPRSPPROC pfnRsp,
        LPARAM     lParam,
        BOOL       bLeaveCrit);

    BOOL
    ClosePort(
        HANDLE hPrinter);

    BOOL
    StartDocPort(
        DWORD   dwLevel,
        LPBYTE  pDocInfo,
        PJOBMAP pjmJob);

    BOOL
    EndDocPort(
        PJOBMAP pjmJob);

    BOOL
    WritePort(
        PJOBMAP pjmJob,
        LPBYTE  lpData,
        DWORD   cbData,
        LPDWORD pcbWr);

    BOOL
    AbortPort(
        PJOBMAP pjmJob);

    LPCTSTR
    GetPortName(
        VOID);

    PJOBMAP*
    GetPJMList(
        VOID);

    DWORD
    IncUserRefCount(
        PCLOGON_USERDATA hUser );

    VOID
    FreeGetPrinterCache (
        VOID);

    BOOL
    BeginReadGetPrinterCache (
        PPRINTER_INFO_2 *ppInfo2);

    VOID
    EndReadGetPrinterCache (
        VOID);

    VOID
    InvalidateGetPrinterCache (
        VOID);

    VOID
    FreeEnumJobsCache (
        VOID);

    BOOL
    BeginReadEnumJobsCache (
        LPPPJOB_ENUM *ppje);

    VOID
    EndReadEnumJobsCache (
        VOID);

    VOID
    InvalidateEnumJobsCache (
        VOID);

    BOOL
    ReadFile (
        CAnyConnection *pConnection,
        HINTERNET hReq,
        LPVOID    lpvBuffer,
        DWORD     cbBuffer,
        LPDWORD   lpcbRd);

    BOOL
    GetCurrentConfiguration (
        PINET_XCV_CONFIGURATION pXcvConfiguration);

    BOOL
    ConfigurePort (
        PINET_XCV_CONFIGURATION pXcvConfigurePortReqData,
        PINET_CONFIGUREPORT_RESPDATA pXcvAddPortRespData,
        DWORD cbSize,
        PDWORD cbSizeNeeded);

    HANDLE
    CreateTerminateEvent (
        VOID);

    BOOL
    WaitForTermination (
        DWORD dwWaitTime);

    inline BOOL
    bDeletePending (
        VOID) CONST {return m_bDeletePending;};

    inline VOID
    SetPowerUpTime (
        time_t t) {m_dwPowerUpTime = t;};

    inline time_t
    GetPowerUpTime (
        VOID) CONST {return m_dwPowerUpTime;};


    friend class CInetMon;

protected:

    inline PCINETMONPORT
    GetNext (
        VOID) { return m_pNext;};

    inline VOID
    SetNext (
        PCINETMONPORT pNext) { m_pNext = pNext;};

    DWORD
    _inet_size_entry(
        DWORD       dwLevel);

    LPBYTE
    _inet_copy_entry(
        DWORD       dwLevel,
        LPBYTE      pPortInfo,
        LPBYTE      pEnd);

    BOOL
    _inet_req_jobstart(
        PIPPREQ_PRTJOB ppj,
        PJOBMAP        pjmJob);

private:

    VOID
    InvalidateGetPrinterCacheForUser(
        HANDLE hUser);

    VOID
    InvalidateEnumJobsCacheForUser(
        HANDLE hUser) ;

    BOOL                   m_bValid;
    DWORD                  m_cb;               // Size of struct plus <portname>
    PCINETMONPORT          m_pNext;            // Pointer to next port entry
    DWORD                  m_cRef;             // Port reference count.
    DWORD                  m_cPrinterRef;      // Printer handle ref count.
    LPTSTR                 m_lpszName;         // Name of port output device
    LPTSTR                 m_lpszDesc;         // Description of output device
    LPTSTR                 m_lpszHost;         // Name of host connection
    LPTSTR                 m_lpszShare;        // Name of share (after host)
    GetPrinterCache        *m_pGetPrinterCache;          // Handle of the cache
    EnumJobsCache          *m_pEnumJobsCache;  // Handle of the cache for enumjobs
    BOOL                   m_bCheckConnection; // Need to check connection
    PJOBMAP                m_pjmList;          //
    PCPORTMGR              m_pPortMgr;         // Handle of port manager, pointer to PortMgr class
    BOOL                   m_bDeletePending;   // TRUE if the port is being deleted.
    time_t                 m_dwPowerUpTime;    // This is the time the printer was originally
                                               // powered up, relative to UCT
    HANDLE                 m_hTerminateEvent;  // Terminate event
} ;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\inetwrap.h ===
/*****************************************************************************\
* MODULE: inetwrap.h
*
* Header file for wininet wrapper routines.  Until the library can support
* Unicode, this module is necessary for NT.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*   15-Jul-1998 v-chrisw    Allow safe DelayLoad of wininet.
*
\*****************************************************************************/
#ifndef INETWRAP_H
#define INETWRAP_H

#define WCtoMB(pszUStr, pszAStr, uSize)     \
    WideCharToMultiByte(CP_ACP,             \
                        0,                  \
                        (LPWSTR)pszUStr,    \
                        -1,                 \
                        (LPSTR)pszAStr,     \
                        uSize,              \
                        NULL,               \
                        NULL)



HINTERNET wrapInternetOpen(
    LPCTSTR lpszAgent,
    DWORD   dwAccess,
    LPCTSTR lpszProxyName,
    LPCTSTR lpszProxyBypass,
    DWORD   dwFlags);

HINTERNET wrapInternetOpenUrl(
    HINTERNET hInternet,
    LPCTSTR   lpszUrl,
    LPCTSTR   lpszHeaders,
    DWORD     dwHeaderLen,
    DWORD     dwFlags,
    DWORD_PTR dwContext);

HINTERNET wrapInternetConnect(
    HINTERNET     hSession,
    LPCTSTR       lpszServerName,
    INTERNET_PORT nServerPort,
    LPCTSTR       lpszUserName,
    LPCTSTR       lpszPassword,
    DWORD         dwService,
    DWORD         dwFlags,
    DWORD_PTR     dwContext);

BOOL wrapHttpQueryInfo(
    HINTERNET hRequest,
    DWORD     dwInfoLevel,
    LPVOID    lpvBuffer,
    LPDWORD   lpdwBufferLen,
    LPDWORD   lpdwIndex);

BOOL wrapHttpSendRequest(
    HINTERNET hRequest,
    LPCTSTR   lpszHeaders,
    DWORD     dwHeaderLen,
    LPVOID    lpvOptional,
    DWORD     dwOptionalLen);

BOOL wrapHttpSendRequestEx(
    HINTERNET          hRequest,
    LPINTERNET_BUFFERS lpBufIn,
    LPINTERNET_BUFFERS lpBufOut,
    DWORD              dwFlags,
    DWORD_PTR          dwContext);

HINTERNET wrapHttpOpenRequest(
    HINTERNET hConnect,
    LPCTSTR   lpszVerb,
    LPCTSTR   lpszObjectName,
    LPCTSTR   lpszVersion,
    LPCTSTR   lpszReferer,
    LPCTSTR   *lplpszAccept,
    DWORD     dwFlags,
    DWORD_PTR dwContext);

BOOL wrapHttpAddRequestHeaders(
    HINTERNET hRequest,
    LPCTSTR   lpszHeaders,
    DWORD     cbLength,
    DWORD     dwModifiers);

BOOL wrapHttpEndRequest(
    HINTERNET          hRequest,
    LPINTERNET_BUFFERS lpBuf,
    DWORD              dwFlags,
    DWORD_PTR          dwContext);

BOOL wrapInternetSetOption(
    HINTERNET hRequest,
    IN DWORD  dwOption,
    IN LPVOID lpBuffer,
    IN DWORD  dwBufferLength);

BOOL wrapInternetCloseHandle(
    HINTERNET hHandle);

BOOL wrapInternetReadFile(
    HINTERNET hRequest,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd);

BOOL wrapInternetWriteFile(
    HINTERNET hRequest,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbWr);

DWORD wrapInternetErrorDlg(
    HWND      hWnd,
    HINTERNET hReq,
    DWORD     dwError,
    DWORD     dwFlags,
    LPVOID    pvParam);


#define InetInternetOpen          wrapInternetOpen
#define InetInternetOpenUrl       wrapInternetOpenUrl
#define InetInternetConnect       wrapInternetConnect
#define InetHttpQueryInfo         wrapHttpQueryInfo
#define InetHttpSendRequest       wrapHttpSendRequest
#define InetHttpSendRequestEx     wrapHttpSendRequestEx
#define InetHttpOpenRequest       wrapHttpOpenRequest
#define InetHttpAddRequestHeaders wrapHttpAddRequestHeaders
#define InetHttpEndRequest        wrapHttpEndRequest
#define InetInternetSetOption     wrapInternetSetOption
#define InetInternetCloseHandle   wrapInternetCloseHandle
#define InetInternetReadFile      wrapInternetReadFile
#define InetInternetWriteFile     wrapInternetWriteFile
#define InetInternetErrorDlg      wrapInternetErrorDlg


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\inetwrap.cxx ===
/*****************************************************************************\
* MODULE: inetwrap.c
*
* This module contains wrapper routines to translate internet calls from
* Unicode to Ansi.  This is necessary right now since the WININET routines
* do not support Unicode for Windows NT.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*   15-Jul-1998 v-chrisw    Allow safe DelayLoad of wininet.
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* wrapInternetOpen
*
*
\*****************************************************************************/
HINTERNET wrapInternetOpen(
    LPCTSTR lpszAgent,
    DWORD   dwAccess,
    LPCTSTR lpszProxyName,
    LPCTSTR lpszProxyBypass,
    DWORD   dwFlags)
{
    HINTERNET hRet = NULL;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiAgent = NULL;
    LPSTR lpszAnsiProxyName = NULL;
    LPSTR lpszAnsiProxyBypass = NULL;
    BOOL  bRet = TRUE;


    if (lpszAgent && (uSize = WCtoMB(lpszAgent, NULL, 0))) {

        if (lpszAnsiAgent = new CHAR[uSize])
            bRet = WCtoMB(lpszAgent, lpszAnsiAgent, uSize);
        else
            bRet = FALSE;
    }


    if (bRet && lpszProxyName && (uSize = WCtoMB(lpszProxyName, NULL, 0))) {

        if (lpszAnsiProxyName = new CHAR[uSize])
            bRet = WCtoMB(lpszProxyName, lpszAnsiProxyName, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszProxyBypass && (uSize = WCtoMB(lpszProxyBypass, NULL, 0))) {

        if (lpszAnsiProxyBypass = new CHAR[uSize])
            bRet = WCtoMB(lpszProxyBypass, lpszAnsiProxyBypass, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            hRet = g_pfnInternetOpen((LPCTSTR)lpszAnsiAgent,
                                     dwAccess,
                                     (LPCTSTR)lpszAnsiProxyName,
                                     (LPCTSTR)lpszAnsiProxyBypass,
                                     dwFlags);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetOpen exception!")));

            hRet = NULL;
        }
    }

    if (lpszAnsiAgent)
        delete [](lpszAnsiAgent);

    if (lpszAnsiProxyName)
        delete [](lpszAnsiProxyName);

    if (lpszAnsiProxyBypass)
        delete [](lpszAnsiProxyBypass);

#else

    __try {

        hRet =  g_pfnInternetOpen(lpszAgent,
                                  dwAccess,
                                  lpszProxyName,
                                  lpszProxyBypass,
                                  dwFlags);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetOpen exception!")));

        hRet = NULL;
    }

#endif

    return hRet;
}


/*****************************************************************************\
* wrapInternetOpenUrl
*
*
\*****************************************************************************/
HINTERNET wrapInternetOpenUrl(
    HINTERNET hInternet,
    LPCTSTR   lpszUrl,
    LPCTSTR   lpszHeaders,
    DWORD     dwHeaderLen,
    DWORD     dwFlags,
    DWORD_PTR dwContext)
{
    HINTERNET hRet = NULL;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiUrl = NULL;
    LPSTR lpszAnsiHeaders = NULL;
    BOOL  bRet = TRUE;


    if (lpszUrl && (uSize = WCtoMB(lpszUrl, NULL, 0))) {

        if (lpszAnsiUrl = new CHAR[uSize])
            bRet = WCtoMB(lpszUrl, lpszAnsiUrl, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszHeaders && (uSize = WCtoMB(lpszHeaders, NULL, 0))) {

        if (lpszAnsiHeaders = new CHAR[uSize])
            bRet = WCtoMB(lpszHeaders, lpszAnsiHeaders, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            hRet = g_pfnInternetOpenUrl(hInternet,
                                        (LPCTSTR)lpszAnsiUrl,
                                        (LPCTSTR)lpszAnsiHeaders,
                                        dwHeaderLen,
                                        dwFlags,
                                        dwContext);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetOpenUrl exception!")));

            hRet = NULL;
        }
    }

    if (lpszAnsiUrl)
        delete [](lpszAnsiUrl);

    if (lpszAnsiHeaders)
        delete [](lpszAnsiHeaders);

#else

    __try {

        hRet = g_pfnInternetOpenUrl(hInternet,
                                    lpszUrl,
                                    lpszHeaders,
                                    dwHeaderLen,
                                    dwFlags,
                                    dwContext);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetOpenUrl exception!")));

        hRet = NULL;
    }

#endif

    return hRet;
}


/*****************************************************************************\
* wrapInternetConnect
*
*
\*****************************************************************************/
HINTERNET wrapInternetConnect(
    HINTERNET     hSession,
    LPCTSTR       lpszServerName,
    INTERNET_PORT nServerPort,
    LPCTSTR       lpszUserName,
    LPCTSTR       lpszPassword,
    DWORD         dwService,
    DWORD         dwFlags,
    DWORD_PTR     dwContext)
{
    HINTERNET hRet = NULL;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiServerName = NULL;
    LPSTR lpszAnsiUserName = NULL;
    LPSTR lpszAnsiPassword = NULL;
    BOOL  bRet = TRUE;


    if (lpszServerName && (uSize = WCtoMB(lpszServerName, NULL, 0))) {

        if (lpszAnsiServerName = new CHAR[uSize])
            bRet = WCtoMB(lpszServerName, lpszAnsiServerName, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszUserName && (uSize = WCtoMB(lpszUserName, NULL, 0))) {

        if (lpszAnsiUserName = new CHAR[uSize])
            bRet = WCtoMB(lpszUserName, lpszAnsiUserName, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszPassword && (uSize = WCtoMB(lpszPassword, NULL, 0))) {

        if (lpszAnsiPassword = new CHAR[uSize])
            bRet = WCtoMB(lpszPassword, lpszAnsiPassword, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            hRet = g_pfnInternetConnect(hSession,
                                        (LPCTSTR)lpszAnsiServerName,
                                        nServerPort,
                                        (LPCTSTR)lpszAnsiUserName,
                                        (LPCTSTR)lpszAnsiPassword,
                                        dwService,
                                        dwFlags,
                                        dwContext);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetConnect exception!")));

            hRet = NULL;
        }
    }


    if (lpszAnsiServerName)
        delete [](lpszAnsiServerName);

    if (lpszAnsiUserName)
        delete [](lpszAnsiUserName);

    if (lpszAnsiPassword)
        delete [](lpszAnsiPassword);

#else

    __try {

        hRet = g_pfnInternetConnect(hSession,
                                    lpszServerName,
                                    nServerPort,
                                    lpszUserName,
                                    lpszPassword,
                                    dwService,
                                    dwFlags,
                                    dwContext);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetConnect exception!")));

        hRet = NULL;
    }

#endif

    return hRet;
}


/*****************************************************************************\
* wrapHttpQueryInfo
*
*
\*****************************************************************************/
BOOL wrapHttpQueryInfo(
    HINTERNET hRequest,
    DWORD     dwInfoLevel,
    LPVOID    lpvBuffer,
    LPDWORD   lpdwBufferLen,
    LPDWORD   lpdwIndex)
{
    BOOL bRet;


    __try {

        bRet = g_pfnHttpQueryInfo(hRequest,
                                  dwInfoLevel,
                                  lpvBuffer,
                                  lpdwBufferLen,
                                  lpdwIndex);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpQueryInfo exception!")));

        bRet = FALSE;
    }

    return bRet;
}


/*****************************************************************************\
* wrapHttpSendRequest
*
*
\*****************************************************************************/
BOOL wrapHttpSendRequest(
    HINTERNET hRequest,
    LPCTSTR   lpszHeaders,
    DWORD     dwHeaderLen,
    LPVOID    lpvOptional,
    DWORD     dwOptionalLen)
{
    BOOL bRet = TRUE;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiHeaders = NULL;


    if (lpszHeaders && (uSize = WCtoMB(lpszHeaders, NULL, 0))) {

        if (lpszAnsiHeaders = new CHAR[uSize])
            bRet = WCtoMB(lpszHeaders, lpszAnsiHeaders, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            bRet = g_pfnHttpSendRequest(hRequest,
                                        (LPCTSTR)lpszAnsiHeaders,
                                        dwHeaderLen,
                                        lpvOptional,
                                        dwOptionalLen);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpSendRequest exception!")));

            bRet = FALSE;
        }
    }

    if (lpszAnsiHeaders)
        delete [](lpszAnsiHeaders);

#else

    __try {

        bRet = g_pfnHttpSendRequest(hRequest,
                                    lpszHeaders,
                                    dwHeaderLen,
                                    lpvOptional,
                                    dwOptionalLen);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpSendRequest exception!")));

        bRet = FALSE;
    }

#endif

    return bRet;
}


/*****************************************************************************\
* wrapHttpSendRequestEx
*
*
\*****************************************************************************/
BOOL wrapHttpSendRequestEx(
    HINTERNET          hRequest,
    LPINTERNET_BUFFERS lpBufIn,
    LPINTERNET_BUFFERS lpBufOut,
    DWORD              dwFlags,
    DWORD_PTR          dwContext)
{
    BOOL bRet = TRUE;


    // NOTE : This now works for Header values defined in lpBufIn and lpBufOut, we assume that
    // the "size" of the header in the structure is not set by the calling routine, if it is we
    // overwrite the size when we convert it....
    //
    // NOTE2: We do not support linked Buffer Strucures, only 1!!!!!
    // NOTE3: We do not support lpBufOut to return values. It must be NULL

#ifdef UNICODE
    UINT                uSize               = 0;
    LPSTR               lpszAnsiHeaders     = NULL;
    LPCWSTR             lpcszHeader;
    INTERNET_BUFFERSA   ConvertBuf;

    DBG_ASSERT((lpBufOut == NULL) , (TEXT("inetwrap : We do not support output buffers!")));
    DBG_ASSERT((lpBufIn->Next == NULL) , (TEXT("inetwrap : We do not support chained input buffers!")));
    
    lpcszHeader = lpBufIn->lpcszHeader;
    
    if (lpcszHeader && (uSize = WCtoMB(lpcszHeader, NULL, 0))) {
        if (lpszAnsiHeaders = new CHAR[uSize]) 
            bRet = WCtoMB(lpcszHeader, lpszAnsiHeaders, uSize--);
        else
            bRet = FALSE;
    }

    if (bRet) {
        ConvertBuf.dwStructSize     = sizeof(ConvertBuf);
        ConvertBuf.Next             = NULL;
        ConvertBuf.lpcszHeader      = lpszAnsiHeaders;
        ConvertBuf.dwHeadersLength  = (DWORD)uSize;
        ConvertBuf.dwHeadersTotal   = lpBufIn->dwHeadersTotal;
        ConvertBuf.lpvBuffer        = lpBufIn->lpvBuffer; 
        ConvertBuf.dwBufferLength   = lpBufIn->dwBufferLength;
        ConvertBuf.dwBufferTotal    = lpBufIn->dwBufferTotal;
        ConvertBuf.dwOffsetLow      = lpBufIn->dwOffsetLow;
        ConvertBuf.dwOffsetHigh     = lpBufIn->dwOffsetHigh;

        __try {

            bRet = g_pfnHttpSendRequestEx(hRequest,
                                          &ConvertBuf,
                                          lpBufOut,
                                          dwFlags,
                                          dwContext);  
        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpSendRequestEx exception!")));

            bRet = FALSE;
        }
    }

    if (lpszAnsiHeaders)
        delete [](lpszAnsiHeaders);

#else
    __try {

        bRet = g_pfnHttpSendRequestEx(hRequest,
                                      lpBufIn,
                                      lpBufOut,
                                      dwFlags,
                                      dwContext);  
                                      
    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpSendRequestEx exception!")));

        bRet = FALSE;
    }
#endif

    return bRet;
}


/*****************************************************************************\
* wrapHttpOpenRequest
*
*
\*****************************************************************************/
HINTERNET wrapHttpOpenRequest(
    HINTERNET hConnect,
    LPCTSTR   lpszVerb,
    LPCTSTR   lpszObjectName,
    LPCTSTR   lpszVersion,
    LPCTSTR   lpszReferer,
    LPCTSTR   *lplpszAccept,
    DWORD     dwFlags,
    DWORD_PTR dwContext)
{
    HINTERNET hRet = NULL;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiVerb = NULL;
    LPSTR lpszAnsiObjectName = NULL;
    LPSTR lpszAnsiVersion = NULL;
    LPSTR lpszAnsiReferer = NULL;
    BOOL  bRet = TRUE;


    if (lpszVerb && (uSize = WCtoMB(lpszVerb, NULL, 0))) {

        if (lpszAnsiVerb = new CHAR[uSize])
            bRet = WCtoMB(lpszVerb, lpszAnsiVerb, uSize);
    }

    if (bRet && lpszObjectName && (uSize = WCtoMB(lpszObjectName, NULL, 0))) {

        if (lpszAnsiObjectName = new CHAR[uSize])
            bRet = WCtoMB(lpszObjectName, lpszAnsiObjectName, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszVersion && (uSize = WCtoMB(lpszVersion, NULL, 0))) {

        if (lpszAnsiVersion = new CHAR[uSize])
            bRet = WCtoMB(lpszVersion, lpszAnsiVersion, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszReferer && (uSize = WCtoMB(lpszReferer, NULL, 0))) {

        if (lpszAnsiReferer = new CHAR[uSize])
            bRet = WCtoMB(lpszReferer, lpszAnsiReferer, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            hRet = g_pfnHttpOpenRequest(hConnect,
                                        (LPCTSTR)lpszAnsiVerb,
                                        (LPCTSTR)lpszAnsiObjectName,
                                        (LPCTSTR)lpszAnsiVersion,
                                        (LPCTSTR)lpszAnsiReferer,
                                        (LPCTSTR *)lplpszAccept,
                                        dwFlags,
                                        dwContext);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpOpenRequest exception!")));

            hRet = NULL;
        }
    }

    if (lpszAnsiVerb)
        delete [](lpszAnsiVerb);

    if (lpszAnsiObjectName)
        delete [](lpszAnsiObjectName);

    if (lpszAnsiVersion)
        delete [](lpszAnsiVersion);

    if (lpszAnsiReferer)
        delete [](lpszAnsiReferer);

#else


    __try {

        hRet = g_pfnHttpOpenRequest(hConnect,
                                    lpszVerb,
                                    lpszObjectName,
                                    lpszVersion,
                                    lpszReferer,
                                    lplpszAccept,
                                    dwFlags,
                                    dwContext);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpOpenRequest exception!")));

        hRet = NULL;
    }

#endif

    return hRet;
}


/*****************************************************************************\
* wrapHttpAddRequestHeaders
*
*
\*****************************************************************************/
BOOL wrapHttpAddRequestHeaders(
    HINTERNET hRequest,
    LPCTSTR   lpszHeaders,
    DWORD     cbLength,
    DWORD     dwModifiers)
{
    BOOL bRet = TRUE;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiHeaders = NULL;


    if (lpszHeaders && (uSize = WCtoMB(lpszHeaders, NULL, 0))) {

        if (lpszAnsiHeaders = new CHAR[uSize])
            WCtoMB(lpszHeaders, lpszAnsiHeaders, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            bRet = g_pfnHttpAddRequestHeaders(hRequest,
                                              (LPCTSTR)lpszAnsiHeaders,
                                              cbLength,
                                              dwModifiers);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpAddRequestHeaders exception!")));

            bRet = FALSE;
        }
    }

    if (lpszAnsiHeaders)
        delete [](lpszAnsiHeaders);

#else

    __try {

        bRet = g_pfnHttpAddRequestHeaders(hRequest,
                                          lpszHeaders,
                                          cbLength,
                                          dwModifiers);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpAdRequestHeaders exception!")));

        bRet = FALSE;
    }

#endif

    return bRet;
}


/*****************************************************************************\
* wrapHttpEndRequest
*
*
\*****************************************************************************/
BOOL wrapHttpEndRequest(
    HINTERNET          hRequest,
    LPINTERNET_BUFFERS lpBuf,
    DWORD              dwFlags,
    DWORD_PTR          dwContext)
{
    BOOL bRet;


    __try {

#ifdef UNICODE

        DBG_ASSERT((lpBuf == NULL), (TEXT("Assert: NULL Buffer is only support")));

        bRet = g_pfnHttpEndRequest(hRequest, lpBuf, dwFlags, dwContext); 
        
#else

        bRet = g_pfnHttpEndRequest(hRequest, lpBuf, dwFlags, dwContext);

#endif

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpOpenRequest exception!")));

        bRet = FALSE;
    }

    return bRet;
}


/*****************************************************************************\
* wrapInternetSetOption
*
*
\*****************************************************************************/
BOOL wrapInternetSetOption(
    HINTERNET hRequest,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength)
{
    BOOL bRet = TRUE;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiBuffer = NULL;


    switch (dwOption) {

    case INTERNET_OPTION_USERNAME:
    case INTERNET_OPTION_PASSWORD:
    case INTERNET_OPTION_PROXY_USERNAME:
    case INTERNET_OPTION_PROXY_PASSWORD:

        if (lpBuffer && (uSize = WCtoMB(lpBuffer, NULL, 0))) {

            if (lpszAnsiBuffer = new CHAR[uSize])
                bRet = WCtoMB(lpBuffer, lpszAnsiBuffer, uSize);
            else
                bRet = FALSE;
        }

        if (bRet) {

            __try {

                bRet = g_pfnInternetSetOption(hRequest,
                                              dwOption,
                                              lpszAnsiBuffer,
                                              dwBufferLength);

            } __except(1) {

                DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetSetOption exception!")));

                bRet = FALSE;
            }
        }

        if (lpszAnsiBuffer)
            delete [](lpszAnsiBuffer);
        break;

    default:

        __try {

            bRet = g_pfnInternetSetOption(hRequest,
                                          dwOption,
                                          lpBuffer,
                                          dwBufferLength);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetSetOption exception!")));

            bRet = FALSE;
        }
        break;
    }

#else

    __try {

        bRet = g_pfnInternetSetOption(hRequest,
                                      dwOption,
                                      lpBuffer,
                                      dwBufferLength);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetSetOption exception!")));

        bRet = FALSE;
    }

#endif

    return bRet;
}



/*****************************************************************************\
* wrapInternetCloseHandle
*
*
\*****************************************************************************/
BOOL wrapInternetCloseHandle(
    HINTERNET hHandle)
{
    BOOL bRet;


    __try {

        bRet = g_pfnInternetCloseHandle(hHandle);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetCloseHandle exception!")));

        bRet = FALSE;
    }

    return bRet;
}


/*****************************************************************************\
* wrapInternetReadFile
*
*
\*****************************************************************************/
BOOL wrapInternetReadFile(
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd)
{
    BOOL bRet;


    __try {

        bRet = g_pfnInternetReadFile(hReq, lpvBuffer, cbBuffer, lpcbRd);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetReadFile exception!")));

        bRet = FALSE;
    }

    return bRet;
}


/*****************************************************************************\
* wrapInternetWriteFile
*
*
\*****************************************************************************/
BOOL wrapInternetWriteFile(
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbWr)
{
    BOOL bRet;


    __try {

        bRet = g_pfnInternetWriteFile(hReq, lpvBuffer, cbBuffer, lpcbWr);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetWriteFile exception!")));

        bRet = FALSE;
    }

    return bRet;
}


/*****************************************************************************\
* wrapInternetErrorDlg
*
*
\*****************************************************************************/
DWORD wrapInternetErrorDlg(
    HWND      hWnd,
    HINTERNET hReq,
    DWORD     dwError,
    DWORD     dwFlags,
    LPVOID    pvParam)
{
    DWORD dwRet;


    __try {

        dwRet = g_pfnInternetErrorDlg(hWnd, hReq, dwError, dwFlags, pvParam);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetErrorDlg exception!")));

        dwRet = 0;
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\inetpp.h ===
/*****************************************************************************\
* MODULE: inetpp.h
*
* Header file for the INETPP provider routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _INETPP_H
#define _INETPP_H

// Buffer sizes/Constants.
//
#define MAX_INET_BUFFER     256
#define MIN_DISK_SPACE     8192
#define MAX_IPP_BUFFER     1024
#define MAX_INET_RETRY        3    // 3 times for internet-connect.


// Error return codes for Request-Auth-Sends.
//
#define RET_SUCESS  0
#define RET_FAILURE 1


// Return value for the customized authentication dialog
//
#define AUTHDLG_OK         1
#define AUTHDLG_CANCEL     2
#define AUTHDLG_TIMEOUT    3
#define AUTHDLG_ERROR      4

// Flags.
//
#define INETPP_REQ_FLAGS (INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_RELOAD)


// Offsets into structure.  Used for the PORT_INFO fields in obtaining
// port-information.
//
#ifdef offsetof
#undef offsetof
#endif
#define offsetof(type, identifier)  ((DWORD)(UINT_PTR)(&(((type)0)->identifier)))

// Function types for the HTTP calls in WININET.DLL.
//
typedef BOOL      (WINAPI *PFNHTTPQUERYINFO)         (HINTERNET, DWORD, LPVOID, LPDWORD, LPDWORD);
typedef HINTERNET (WINAPI *PFNINTERNETOPENURL)       (HINTERNET, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR);
typedef DWORD     (WINAPI *PFNINTERNETERRORDLG)      (HWND, HINTERNET, DWORD, DWORD, LPVOID);
typedef BOOL      (WINAPI *PFNHTTPSENDREQUEST)       (HINTERNET, LPCTSTR, DWORD, LPVOID, DWORD);
#ifdef UNIMPLEMENTED
typedef BOOL      (WINAPI *PFNHTTPSENDREQUESTEX)     (HINTERNET, LPINTERNET_BUFFERS, LPINTERNET_BUFFERS, DWORD, DWORD_PTR);
#else
typedef BOOL      (WINAPI *PFNHTTPSENDREQUESTEX)     (HINTERNET, LPINTERNET_BUFFERSA, LPINTERNET_BUFFERS, DWORD, DWORD_PTR);
#endif
typedef BOOL      (WINAPI *PFNINTERNETREADFILE)      (HINTERNET, LPVOID, DWORD, LPDWORD);
typedef BOOL      (WINAPI *PFNINTERNETWRITEFILE)     (HINTERNET, LPCVOID, DWORD, LPDWORD);
typedef BOOL      (WINAPI *PFNINTERNETCLOSEHANDLE)   (HINTERNET);
typedef HINTERNET (WINAPI *PFNINTERNETOPEN)          (LPCTSTR, DWORD, LPCTSTR, LPCTSTR, DWORD);
typedef HINTERNET (WINAPI *PFNINTERNETCONNECT)       (HINTERNET, LPCTSTR, INTERNET_PORT, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR);
typedef HINTERNET (WINAPI *PFNHTTPOPENREQUEST)       (HINTERNET, LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR *, DWORD, DWORD_PTR);
typedef BOOL      (WINAPI *PFNHTTPADDREQUESTHEADERS) (HINTERNET, LPCTSTR, DWORD, DWORD);
typedef BOOL      (WINAPI *PFNHTTPENDREQUEST)        (HINTERNET, LPINTERNET_BUFFERS, DWORD, DWORD_PTR); 
typedef BOOL      (WINAPI *PFNINTERNETSETOPTION)     (HINTERNET, DWORD, LPVOID, DWORD);


// InetmonSendReq Response callback.
//
typedef BOOL (CALLBACK *IPPRSPPROC)(CAnyConnection *pConnection, 
                                    HINTERNET hReq, 
                                    PCINETMONPORT pIniPort, 
                                    LPARAM lParam);


class CInetMon {
public:

    CInetMon ();
    ~CInetMon ();

    inline BOOL
    bValid (VOID) CONST { return m_bValid; }
    
    BOOL 
    InetmonSendReq(
        HANDLE     hPort,
        LPBYTE     lpIpp,
        DWORD      cbIpp,
        IPPRSPPROC pfnRsp,
        LPARAM     lParam,
        BOOL       bLeaveCrit);

    PCINETMONPORT 
    InetmonOpenPort(
        LPCTSTR lpszPortName, 
        PBOOL   pbXcv);

    BOOL 
    InetmonReleasePort(
        PCINETMONPORT   pIniPort);

    BOOL 
    InetmonClosePort(
        PCINETMONPORT hPort,
        HANDLE hPrinter);

    BOOL 
    InetmonEnumPorts(
        LPTSTR  lpszServerName,
        DWORD   dwLevel,
        LPBYTE  pPorts,
        DWORD   cbBuf,
        LPDWORD pcbNeeded,
        LPDWORD pcReturned);

    BOOL 
    InetmonDeletePort(
        LPCTSTR lpszPortName,
        HWND    hWnd,
        LPCTSTR lpszMonitorName);

    BOOL 
    InetmonAddPort(
        LPCTSTR lpszPortName,
        LPCTSTR lpszMonitorName);

    PCINETMONPORT 
    InetmonFindPort(
        LPCTSTR lpszPortName);

private:

    // Port-List Structure.  This defines the global-header for the
    // print-provider port-list.
    //
    typedef struct _INIMONPORTLIST {
        HINTERNET       hSession;           // Handle for session connection.
        int             cRef;               // Count of hSession opens.
        PCINETMONPORT   pIniFirstPort;      // List of port-entries.
    } INIMONPORTLIST;
    
    typedef INIMONPORTLIST *PINIMONPORTLIST;
    
    inline BOOL 
    _inet_validate_portname(
        LPCTSTR         lpszPortName);

    PCINETMONPORT 
    _inet_find_port(
        LPCTSTR         lpszPortName);

    PCINETMONPORT 
    _inet_create_port(
        LPCTSTR         lpszPortName,
        PCPORTMGR       pPortMgr);

    BOOL 
    _inet_delete_port(
        LPCTSTR         lpszPortName);

    DWORD 
    _inet_size_entry(
        PCINETMONPORT   pIniPort,
        DWORD           dwLevel);

    LPBYTE 
    _inet_copy_entry(
        PCINETMONPORT   pIniPort,
        DWORD           dwLevel,
        LPBYTE          pPortInfo,
        LPBYTE          pEnd);

    BOOL
    _inet_is_xcv_open (
        LPCTSTR         lpszPortName,
        LPTSTR          *ppszServerName,
        LPTSTR          *ppszRealPortName,
        LPBOOL          pbXcv);

    BOOL            m_bValid;
    PINIMONPORTLIST m_pPortList;

};

typedef class CInetMon* PCINETMON;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\globals.h ===
/*****************************************************************************\
* MODULE: globals.h
*
* Global header file.  Any global variables should be localized to this
* location.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/


// Global variables.
//
extern HINSTANCE        g_hInst;
extern CRITICAL_SECTION g_csMonitorSection;
extern DWORD            g_dwCritOwner;
extern DWORD            g_dwJobLimit;
extern BOOL             g_bUpgrade;
extern CRITICAL_SECTION g_csCreateSection;
extern HANDLE           g_eResetConnections;
extern DWORD            g_dwConCount;

extern CCriticalSection  *g_pcsEndBrowserSessionLock;

// Constant string identifiers.
//
extern TCHAR g_szMachine[];

extern LPTSTR g_szRegProvider;
extern LPTSTR g_szRegPrintProviders;
extern TCHAR g_szDefSplDir [];
extern TCHAR g_szDisplayStr[];

extern CONST TCHAR g_szSplDir9X [];
extern CONST TCHAR g_szSplPfx   [];

extern CONST TCHAR g_szUserAgent[];
extern CONST TCHAR g_szLocalPort[];
extern CONST TCHAR g_szDisplayName[];
extern CONST TCHAR g_szLibraryName[];
extern CONST TCHAR g_szWinInetDll[];
extern CONST TCHAR g_szUriPrinters[];
extern CONST TCHAR g_szPOST[];
extern CONST TCHAR g_szGET[];
extern CONST TCHAR g_szContentLen[];
extern CONST TCHAR g_szContentType[];
extern CONST TCHAR g_szEmptyString[];
extern CONST TCHAR g_szDescription[];
extern CONST TCHAR g_szComment[];
extern CONST TCHAR g_szProviderName[];
extern CONST TCHAR g_szNewLine[];
extern CONST TCHAR g_szProcessName[];
extern CONST TCHAR g_szConfigureMsg[];
extern CONST TCHAR g_szRegPorts[];
extern CONST TCHAR g_szAuthDlg[];
extern CONST TCHAR g_szDocRemote[];
extern CONST TCHAR g_szDocLocal[];

extern CONST TCHAR g_szAuthMethod[];
extern CONST TCHAR g_szAuthMethod[];
extern CONST TCHAR g_szUserName[];
extern CONST TCHAR g_szPassword[];
extern CONST TCHAR g_szPerUserPath[];


// Http Version Number
//
extern CONST TCHAR g_szHttpVersion[];

// Internet API strings.  These MUST NOT be unicode enabled.
//
extern CONST CHAR g_szInternetCloseHandle[];
extern CONST CHAR g_szInternetErrorDlg[];
extern CONST CHAR g_szInternetReadFile[];
extern CONST CHAR g_szInternetWriteFile[];
extern CONST CHAR g_szHttpQueryInfo[];
extern CONST CHAR g_szInternetOpenUrl[];
extern CONST CHAR g_szHttpSendRequest[];
extern CONST CHAR g_szHttpSendRequestEx[];
extern CONST CHAR g_szInternetOpen[];
extern CONST CHAR g_szInternetConnect[];
extern CONST CHAR g_szHttpOpenRequest[];
extern CONST CHAR g_szHttpAddRequestHeaders[];
extern CONST CHAR g_szHttpEndRequest[];
extern CONST CHAR g_szInternetSetOption[];


// Internet API for controling the Url output.
//
extern PFNHTTPQUERYINFO         g_pfnHttpQueryInfo;
extern PFNINTERNETOPENURL       g_pfnInternetOpenUrl;
extern PFNINTERNETERRORDLG      g_pfnInternetErrorDlg;
extern PFNHTTPSENDREQUEST       g_pfnHttpSendRequest;
extern PFNHTTPSENDREQUESTEX     g_pfnHttpSendRequestEx;
extern PFNINTERNETREADFILE      g_pfnInternetReadFile;
extern PFNINTERNETWRITEFILE     g_pfnInternetWriteFile;
extern PFNINTERNETCLOSEHANDLE   g_pfnInternetCloseHandle;
extern PFNINTERNETOPEN          g_pfnInternetOpen;
extern PFNINTERNETCONNECT       g_pfnInternetConnect;
extern PFNHTTPOPENREQUEST       g_pfnHttpOpenRequest;
extern PFNHTTPADDREQUESTHEADERS g_pfnHttpAddRequestHeaders;
extern PFNHTTPENDREQUEST        g_pfnHttpEndRequest;
extern PFNINTERNETSETOPTION     g_pfnInternetSetOption;


// IPP string which uses NULL-command to server.
//
#define g_szUriIPP g_szUriPrinters
#define MAXDWORD 0xffffffff

#define COMMITTED_STACK_SIZE (1024*32)

extern PCINETMON gpInetMon;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\lusrdata.cxx ===
/*****************************************************************************\
* MODULE:       lusrdata.cxx
*
* PURPOSE:      This specialises the user data class to keep track of data
*               useful for the user port reference count.
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     1/11/2000  mlawrenc    Implemented
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"

CLogonUserData::CLogonUserData()
/*++

Routine Description:
    Default constructor for Logon User Data, once the parent
    gets the SID, we get the session ID.

--*/
    : CUserData() ,
      m_ulSessionId(0),
      m_dwRefCount(1) {

    if (m_bValid) {  // We get the user SID successfully
        m_bValid = _GetClientSessionId( );
    }
}

BOOL
CLogonUserData::_GetClientSessionId(
    VOID )
/*++

Routine Description:

    Set the session ID from the client token and set it if we can get it.

Return Value:

    TRUE if we could get the session ID, false otherwise.

--*/
{
    BOOL          bResult;
    HANDLE        hToken;
    ULONG         ulSessionId, ulReturnLength;

    //
    // We should be impersonating the client, so we will get the
    // SessionId from our token.
    //

    bResult = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 FALSE,              // Use impersonation
                 &hToken
                 );

    if( bResult ) {

        //
        // Query the SessionID from the token added by HYDRA
        //
        bResult = GetTokenInformation(
             hToken,
             (TOKEN_INFORMATION_CLASS)TokenSessionId,
             &m_ulSessionId,
             sizeof(m_ulSessionId),
             &ulReturnLength
             );

        m_ulSessionId = bResult ? m_ulSessionId : 0;

        CloseHandle( hToken );

        bResult = TRUE;
    }

    return bResult;
}


CLogonUserData &
CLogonUserData::operator=(
    const CLogonUserData &rhs) {

    this->CUserData::operator=( rhs );

    m_ulSessionId = rhs.m_ulSessionId;

    return *this;
}

int
CLogonUserData::Compare(
    const CLogonUserData *second) const
/*++

Routine Description:

    Compare the CLogonUser with another.

Arguments:
    second - The CLogonUser we are comparing this with.

Return Value:

    TRUE if they are different, FALSE if they are the same.

--*/
    {

    if (m_bValid && second->m_bValid) {
        return m_ulSessionId != second->m_ulSessionId ||
               RtlEqualSid(m_pSid, second->m_pSid) == FALSE;
    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\mem.h ===
/*****************************************************************************\
* MODULE: mem.h
*
* Header file for memory handling routines (mem.c).
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _INETPPMEM_H
#define _INETPPMEM_H

/*-----------------------------------*\
| Constants
\*-----------------------------------*/
#define DEADBEEF      0xdeadbeef                    // Tail Marker.
#define MAPMEM        ((HANDLE)-1)                  // File-Map-Memory.


/*-----------------------------------*\
| MEMHEAD Structure
\*-----------------------------------*/
typedef struct _MEMHEAD {

    struct _MEMHEAD *pmPrev;    // Reference to previous mem-block (dbg-only).
    struct _MEMHEAD *pmNext;    // Reference to next mem-block     (dbg-only).
    DWORD           dwTag;      // Memory Tag.
    DWORD           cbSize;     // size of block allocated (non-aligned size).
    PVOID           pvMem[1];   // Start of user-addressable memory.

} MEMHEAD;
typedef MEMHEAD      *PMEMHEAD;
typedef MEMHEAD NEAR *NPMEMHEAD;
typedef MEMHEAD FAR  *LPMEMHEAD;


/*-----------------------------------*\
| MEMTAIL Structure
\*-----------------------------------*/
typedef struct _MEMTAIL {

    DWORD dwSignature;

} MEMTAIL;
typedef MEMTAIL      *PMEMTAIL;
typedef MEMTAIL NEAR *NPMEMTAIL;
typedef MEMTAIL FAR  *LPMEMTAIL;

#define MEM_HEADSIZE  (FIELD_OFFSET(MEMHEAD, pvMem))     //
#define MEM_TAILSIZE  (1 * sizeof(DWORD))           //
#define MEM_SIZE      (MEM_HEADSIZE + MEM_TAILSIZE) //

/*-----------------------------------*\
| memAlignSize
\*-----------------------------------*/
_inline BOOL memAlignSize(
    DWORD cbSize)
{
    return ((cbSize & 3) ? (cbSize + (sizeof(DWORD) - (cbSize & 3))) : cbSize);
}

PVOID memAlloc(
    UINT cbSize);

BOOL memFree(
    PVOID  pMem,
    UINT   cbSize);

UINT memGetSize(
    PVOID pMem);

VOID memCopy(
    PSTR *ppDst,
    PSTR pSrc,
    UINT cbSize,
    PSTR *ppBuf);

PTSTR memAllocStr(
    LPCTSTR lpszStr);

BOOL memFreeStr(
   PTSTR lpszStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\mem.cxx ===
/*****************************************************************************\
* MODULE: mem.c
*
* Memory management routines.  These routines provide head/tail checking
* to verify memory corruption problems.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*********************************************************** local routine ***\
* mem_HeadPtr
*
*   Returns the pointer to the head-block.  This needs to decrement enough
*   to account for the extra information stored at the head.
*
\*****************************************************************************/
_inline PMEMHEAD mem_HeadPtr(
    PVOID pvMem)
{
    return (PMEMHEAD)(pvMem ? (((PBYTE)pvMem) - MEM_HEADSIZE) : NULL);
}


/*********************************************************** local routine ***\
* mem_TailPtr
*
*   Returns the pointer to the tail-block.  This requires the aligned-size
*   to retrieve the offset.
*
\*****************************************************************************/
_inline PMEMTAIL mem_TailPtr(
    PMEMHEAD pmh,
    DWORD    cbAlign)
{
    return (PMEMTAIL)((PBYTE)pmh + cbAlign - MEM_TAILSIZE);
}

#ifdef DEBUG

PMEMHEAD g_pmHead = NULL;

/*********************************************************** local routine ***\
* mem_InsPtr
*
*   Inserts the pointer into our list for tracking allocations.
*
\*****************************************************************************/
_inline VOID mem_InsPtr(
    PMEMHEAD pmHead)
{
    if (g_pmHead) {

        g_pmHead->pmPrev = pmHead;
        pmHead->pmNext   = g_pmHead;

    } else {

        pmHead->pmNext = NULL;
    }

    g_pmHead = pmHead;
}


/*********************************************************** local routine ***\
* mem_DelPtr
*
*   Removes the pointer from our list of tracked allocations.
|
\*****************************************************************************/
_inline VOID mem_DelPtr(
    PMEMHEAD pmHead)
{
    PMEMHEAD pmPtr;


    if (pmHead->pmNext) {

        pmPtr         = pmHead->pmNext;
        pmPtr->pmPrev = pmHead->pmPrev;
    }

    if (pmHead->pmPrev) {

        pmPtr         = pmHead->pmPrev;
        pmPtr->pmNext = pmHead->pmNext;

    } else {

        g_pmHead = pmHead->pmNext;
    }
}


/*****************************************************************************\
* _mem_validate (Local Routine)
*
* Checks memory blocks allocated by memAlloc. These blocks contain
* debugging information that helps to check for pointer overruns and
* underruns.
*
* Returns a pointer to the memory header.  Otherwise, we return NULL.
*
\*****************************************************************************/
PVOID _mem_validate(
    PVOID pvMem,
    UINT  cbSize)
{
    DWORD    cbAlign;
    PMEMHEAD pmHead;
    PMEMTAIL pmTail;
    PMEMHEAD pmRet = NULL;


    // Retrieve the head-pointer.
    //
    if (pmHead = mem_HeadPtr(pvMem)) {

        // Calculate the "real" size of our allocated block and round it
        // up to an even number of DWORD blocks.
        //
        cbAlign = memAlignSize(cbSize + MEM_SIZE);


        // Get the tail location.
        //
        pmTail = mem_TailPtr(pmHead, cbAlign);


        // Compare the values that memAlloc stored at the beginning
        // and end of the block
        //
        if ((pmHead->cbSize == cbSize) && (pmTail->dwSignature == DEADBEEF))
            pmRet = pmHead;


        // Assert if errors.
        //
        DBG_ASSERT((pmHead->cbSize == cbSize), (TEXT("Err : _mem_validate: Bad Size at %08lX"), pvMem));
        DBG_ASSERT((pmTail->dwSignature == DEADBEEF), (TEXT("Err : _mem_validate: Block Corruption at %08lX"), pvMem));

    } else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : _mem_validate: Bad Pointer")));
    }

    return pmRet;
}

#else

/*********************************************************** local routine ***\
* Non-Debug Mappings.
*
*   On non-debug builds, we will just return the most efficient values.
*
\*****************************************************************************/
#define mem_InsPtr(pmHead)           {}
#define mem_DelPtr(pmHead)           {}
#define _mem_validate(pvMem, cbSize)  mem_HeadPtr(pvMem)

#endif

/*****************************************************************************\
* memAlloc
*
*
\*****************************************************************************/
PVOID memAlloc(
    UINT cbSize)
{
    PMEMHEAD pmHead;
    PMEMTAIL pmTail;
    DWORD    cbAlign;


    // The size of this memory-block will include header-information.  So,
    // we will add the header-size and align our memory on DWORD boundries.
    //
    cbAlign = memAlignSize(cbSize + MEM_SIZE);


    // Attempt to allocate the memory.  Proceed to setup
    // the memory block.
    //
    if (pmHead = (PMEMHEAD)GlobalAlloc(GPTR, cbAlign)) {

        pmTail = mem_TailPtr(pmHead, cbAlign);


        // Zero the memory-block so that we're dealing with
        // a clean contiguous array.
        //
        ZeroMemory((PVOID)pmHead, cbAlign);


        // Set up header/tail-information.  This contains the requested
        // size of the memory-block.  Increment the block so we return
        // the next available memory for the caller to use.
        //
        pmTail->dwSignature = DEADBEEF;
        pmHead->dwTag       = 0;
        pmHead->cbSize      = cbSize;
        pmHead->pmPrev      = NULL;
        pmHead->pmNext      = NULL;

        mem_InsPtr(pmHead);

    } else {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return (pmHead ? pmHead->pvMem : NULL);
}


/*****************************************************************************\
* memFree
*
*
\*****************************************************************************/
BOOL memFree(
    PVOID pvMem,
    UINT  cbSize)
{
    PMEMHEAD pmHead;
    BOOL     bRet = FALSE;


    // Try to at least make sure it's our memory and that no pointers have
    // gone astray in it.
    //
    if (pmHead = (PMEMHEAD) _mem_validate(pvMem, cbSize)) {

        mem_DelPtr(pmHead);

        bRet = (GlobalFree((PVOID)pmHead) == NULL);
    }

    return bRet;
}


/*****************************************************************************\
* memCopy
*
* Copies a block of memory into a Win32 format buffer -- a structure at the
* front of the buffer and strings packed into the end.
*
* On entry, *buf should point to the last available byte in the buffer.
*
\*****************************************************************************/
VOID memCopy(
    PSTR *ppDst,
    PSTR pSrc,
    UINT cbSize,
    PSTR *ppBuf)
{

    if (pSrc != NULL) {

        // Place bytes at end of buffer.
        //
        (*ppBuf) -= cbSize + 1;

        memcpy(*ppBuf, pSrc, cbSize);


        // Place buffer address in structure and save pointer to new
        // last available byte.
        //
        *ppDst = *ppBuf;

        (*ppBuf)--;

    } else {

        *ppDst = NULL;
    }
}


/*****************************************************************************\
* memGetSize
*
* Returns the size of a block of memory that was allocated with memAlloc().
*
\*****************************************************************************/
UINT memGetSize(
    PVOID pvMem)
{
    PMEMHEAD pmHead;

    return ((pmHead = mem_HeadPtr(pvMem)) ? pmHead->cbSize : 0);
}



/*****************************************************************************\
* memAllocStr
*
* Allocates local memory to store the specified string.  This takes in a
* (lpszStr) which is copied to the new memory.
*
\*****************************************************************************/
PTSTR memAllocStr(
    LPCTSTR lpszStr)
{
    PTSTR   pMem    = NULL;
    size_t  uSize   = 0;

    if (lpszStr == NULL)
    {
        return NULL;
    }

    uSize = utlStrSize(lpszStr);

    pMem = (PTSTR)memAlloc(uSize);

    if (pMem)
    {
        if (FAILED(StringCbCopy((LPTSTR)pMem, uSize, lpszStr)))
        {
            memFreeStr (pMem);
            pMem = NULL;
        }
    }

    return pMem;
}

/*****************************************************************************\
* memFreeStr
*
* Frees the memory allocated by memAllocStr.
*
\*****************************************************************************/
BOOL memFreeStr(
   PTSTR pszStr)
{
   return memFree(pszStr, memGetSize(pszStr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ntcon.cxx ===
/*****************************************************************************\
* MODULE: iecon.cxx
*
* The module contains class for connections using IE's default configuration
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   07/31/98    Weihaic     Created
*
\*****************************************************************************/


#include "precomp.h"
#include "priv.h"

CNTConnection::CNTConnection (
    BOOL bSecure,
    INTERNET_PORT nServerPort,
    BOOL bIgnoreSecurityDlg):

    CAnyConnection (bSecure, nServerPort, bIgnoreSecurityDlg, AUTH_NT)
{
}

BOOL
CNTConnection::SendRequest(
    HINTERNET      hReq,
    LPCTSTR        lpszHdr,
    CStream        *pStream)
{
    static const DWORD dwMaxRetry = 3;

    BOOL    bRet = FALSE;
    DWORD   dwRet;
    DWORD   dwFlags;
    DWORD   i;

    dwFlags = FLAGS_ERROR_UI_FLAGS_NO_UI;

    for (i = 0; i < dwMaxRetry; i++ ) {
        bRet = CAnyConnection::SendRequest (hReq,
                                            lpszHdr,
                                            pStream);

        if (bRet || GetLastError () != ERROR_ACCESS_DENIED) {
            break;
        }


        dwRet = InetInternetErrorDlg(GetDesktopWindow(),
                                     hReq,
                                     bRet ? ERROR_SUCCESS : GetLastError(),
                                     dwFlags,
                                     NULL);
        if (dwRet != ERROR_INTERNET_FORCE_RETRY) {
            break;
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ppchange.cxx ===
/*****************************************************************************\
* MODULE: ppchange.h
*
* This module contains functions that handle notification
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*   28-Apr-1998     Weihai Chen (weihaic)
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


typedef struct INET_HPRINTER_LIST {
   LPINET_HPRINTER hPrinter;
   struct INET_HPRINTER_LIST *next;
} INET_HPRINTER_LIST;

typedef INET_HPRINTER_LIST *PINET_HPRINTER_LIST;
typedef INET_HPRINTER_LIST *NPINET_HPRINTER_LIST;
typedef INET_HPRINTER_LIST *LPINET_HPRINTER_LIST;


static INET_HPRINTER_LIST g_pHandleList = {NULL, NULL};

/*****************************************************************************\
* AddHandleToList
*
* Add the printer handle to a global link list
*
\*****************************************************************************/
BOOL
AddHandleToList (
   LPINET_HPRINTER hPrinter
   )
{
   LPINET_HPRINTER_LIST pPrt;

   if (pPrt = (LPINET_HPRINTER_LIST)memAlloc(sizeof(INET_HPRINTER_LIST))) {
      pPrt->next = g_pHandleList.next;
      pPrt->hPrinter =  hPrinter;
      g_pHandleList.next = pPrt;

      return TRUE;
   }
   else
      return FALSE;
}

/*****************************************************************************\
* DeleteHandleFromList
*
* Remove a printer handle from the global link list
*
\*****************************************************************************/
BOOL
DeleteHandleFromList (
   LPINET_HPRINTER hPrinter
   )
{
   LPINET_HPRINTER_LIST pPrt = &g_pHandleList;
   LPINET_HPRINTER_LIST pTmp;

   while (pPrt->next) {
      if (pPrt->next->hPrinter == hPrinter) {
         pTmp = pPrt->next;
         pPrt->next = pTmp->next;
         memFree (pTmp, sizeof(INET_HPRINTER_LIST));
         return TRUE;
      }
      pPrt = pPrt->next;
   }

   return FALSE;
}

/*****************************************************************************\
* RefreshNotificationPort
*
* Go through the handle list and call the refresh if the notify handle is not
* null
*
\*****************************************************************************/
void
RefreshNotificationPort (
   HANDLE hPort
   )
{
    LPINET_HPRINTER_LIST pPrt = g_pHandleList.next;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: RefreshNotificationPort: Port(%08lX)"), hPort));
    
    while (pPrt) {
        if (utlValidatePrinterHandle (pPrt->hPrinter) == hPort) { 
            if (pPrt->hPrinter->hNotify) {
                
                DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: ReplyPrinterChangeNotification: hNotify(%08lX)"),
                                            pPrt->hPrinter->hNotify));
                
                ReplyPrinterChangeNotification (pPrt->hPrinter->hNotify,
                                                PRINTER_CHANGE_ALL,
                                                NULL,
                                                NULL);
            }

        }
        pPrt = pPrt->next;
    }
}


/*****************************************************************************\
* RefreshNotification
*
* Go through the handle list and call the refresh if the notify handle is not
* null
*
\*****************************************************************************/
void
RefreshNotification (
   LPINET_HPRINTER hPrinter
   )
{

    RefreshNotificationPort (hPrinter->hPort);
}

/*****************************************************************************\
* PPFindFirstPrinterChangeNotification
*
* Handle the notification request
*
\*****************************************************************************/
BOOL
PPFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus,
    PVOID pPrinterNotifyOptions,
    PVOID pPrinterNotifyInit
    )
{
    static PRINTER_NOTIFY_INIT PPNotify = {
        sizeof (PRINTER_NOTIFY_INIT),
        0,
        30000
    };

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPFindFirstPrinterChangeNotification: Printer(%08lX)"), hPrinter));

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: hNotify(%08lX)"),hNotify));

    semEnterCrit();

    if (utlValidatePrinterHandle(hPrinter)) {

        ((LPINET_HPRINTER )hPrinter) ->hNotify = hNotify;
        fdwFlags = PRINTER_CHANGE_ALL;
        *pfdwStatus = PRINTER_NOTIFY_STATUS_POLL | PRINTER_NOTIFY_STATUS_ENDPOINT;
        * ((LPPRINTER_NOTIFY_INIT *) pPrinterNotifyInit) = &PPNotify;
    }

    semLeaveCrit ();

    return TRUE;
}

BOOL
PPFindClosePrinterChangeNotification(
    HANDLE hPrinter
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\portmgr.cxx ===
/*****************************************************************************\
* MODULE: portmgr.cxx
*
* The module contains routines for handling the http port connection
* for internet priting
*
* Copyright (C) 1996-1998 Microsoft Corporation
*
* History:
*   22-Jul-1996 WeihaiC     Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

// This the length used to fetch the authentication scheme. I don't see any reason
// that the authentication scheme could be longer.
#define MAX_SCHEME_LEN 255

CPortMgr::CPortMgr ():
    // Put all the private member variable here
    m_hSession (NULL),
    m_hConnect (NULL),
    m_lpszPassword (NULL),
    m_lpszUserName (NULL),
    m_lpszHostName (NULL),
    m_lpszUri (NULL),
    m_lpszPortName (NULL),
    m_bPortCreate (FALSE),
    m_bForceAuthSupported (TRUE),   //We set it to be TRUE so that we will always try it.
    m_pPortSettingMgr (NULL),
    m_bSecure (FALSE),
    m_nPort (0),
    m_bValid (FALSE)

{
}

CPortMgr::~CPortMgr ()
{
    LocalFree (m_lpszPassword);
    LocalFree (m_lpszUserName);
    LocalFree (m_lpszHostName);
    LocalFree (m_lpszUri);
    LocalFree (m_lpszPortName);

    m_hSession = NULL;
    m_hConnect = NULL;
}

HINTERNET
CPortMgr::_OpenRequest (
    CAnyConnection *pConnection)
{
    HINTERNET hReq = NULL;

    if (pConnection && pConnection->OpenSession ()) {

        if (pConnection->Connect (m_lpszHostName)) {
            hReq = pConnection->OpenRequest (m_lpszUri);
        }
    }

    return hReq;
}

BOOL
CPortMgr::_CloseRequest (
    CAnyConnection *pConnection,
    HINTERNET hReq)
{
    BOOL bRet = FALSE;

    if (pConnection->CloseRequest (hReq)) {
        if (pConnection->Disconnect ()) {
            bRet = pConnection->CloseSession();
        }
    }
    return bRet;
}

/*****************************************************************************\
* Function: SendRequest
*
* This function is to send an IPP request to an established connection
*
* The intension of the function is to send the request with specified
* authentication instead of anonymous even if anonymous is enabled.
* The alogortihm is as following
* 1. If it is anonymous, just send the request and return
* 2. Otherwise,
* 3. If m_bForceAuthSupported, send ForceAuth to turn off anonymous, otherwise, goto 4
* 3.a.    Issue Force Authentication
* 3.b.    If the return value is  401 access denied, perform proper retry and return
* 3.c.    Otherwise, (We don't get 401 access denied). If we get other errors, return FALSE
* 3.d.    Check the IPP response of the Forth Authentication
* 3.e.    If the IPP response is OK, we return TRUE
* 3.f.    Otherwise, (Not Supported), we assume that the server does not
*         support Force Authentication, so we marek m_bForceAuthSupported as FALSE
*         and  move on by returning a FALSE.
*
* 4. Send the real IPP request.
*
\*****************************************************************************/

BOOL
CPortMgr::_SendRequest (
    CAnyConnection  *pConnection,
    HINTERNET       hJobReq,
    CStream         *pStream)
{
    BOOL  bRet = FALSE;

    DWORD cbData;

    // Generate the Http header and indicate the size
    // of the data we're sending.
    //
    if (pStream->GetTotalSize (&cbData) && cbData) {

        DWORD dwLE = ERROR_SUCCESS;
        DWORD dwAuthMethod = pConnection->GetAuthMethod ();

        // We need to force authentication if the method is NTLM or others
        if (m_bForceAuthSupported &&
            ( dwAuthMethod == AUTH_OTHER ||  dwAuthMethod == AUTH_NT)) {

            HINTERNET hReq;
            // Open a request and send force authentication IPP request

            if (hReq = pConnection->OpenRequest (m_lpszUri)) {

                bRet = _IppForceAuth (pConnection,
                                     hReq,
                                     m_lpszPortName,
                                     &dwAuthMethod);

                if (!bRet) {
                    dwLE = GetLastError ();
                }

                pConnection->CloseRequest (hReq);
            }

            if (m_bForceAuthSupported && !bRet && dwLE == ERROR_ACCESS_DENIED) {
                // If forth authentication is supported but the server authentication fails, we return an error

                DBG_MSG(DBG_LEV_ERROR, (TEXT("CPortMgr::_SendRequest : Failed (lasterror=%d)"), dwLE));

                SetLastError (dwLE);
                return bRet;
            }
        }

        if (pConnection->SendRequest (hJobReq,
                                     g_szContentType,
                                     pStream)) {
            bRet = TRUE;
        }
        else {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("CPortMgr::_SendRequest : pConnection->SendRequest Failed (lasterror=%d)"),
                                    GetLastError ()));

        }
    }

    return bRet;
}

BOOL
CPortMgr::ReadFile (
    CAnyConnection *pConnection,
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd)
{
    BOOL bRet = FALSE;

    if (m_bValid && pConnection) {
        bRet = pConnection->ReadFile (hReq, lpvBuffer, cbBuffer, lpcbRd);
    }

    return bRet;
}

/*****************************************************************************\
* _IppForceAuthRsp (Local Callback Routine)
*
* Retrieves a forth-authentication response from the IPP server
*
\*****************************************************************************/
BOOL
CPortMgr::_IppForceAuthRsp(
    CAnyConnection *pConnection,
    HINTERNET      hReq,
    LPARAM         lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_PRN lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_FORCEAUTH)) {

        while (TRUE) {

            cbRd = 0;
            if (pConnection->ReadFile (hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (!lpRsp) {
                        SetLastError (ERROR_INVALID_DATA);
                    }
                    else if ((bRet = lpRsp->bRet) == TRUE)
                        // This is from our server. We have already had the authentication
                        // established
                        bRet = TRUE;

                    else
                        SetLastError(lpRsp->dwLastError);

                    WebIppFreeMem(lpRsp);

                    goto EndValRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //

                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("CPortMgr::_IppForceAuthRsp Err : Receive Data Error (dwRet=%d, LE=%d)"),
                         dwRet, WebIppGetError(hIpp)));

                    SetLastError(ERROR_INVALID_DATA);

                    goto EndValRsp;
                }

            } else {

                goto EndValRsp;
            }
        }

EndValRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


BOOL
CPortMgr::_IppForceAuth (
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    LPCTSTR         lpszPortName,
    PDWORD          pdwAuthMethod)
{
    LPIPPREQ_GETPRN pgp;
    REQINFO         ri;
    DWORD           dwRet;
    LPBYTE          lpIpp;
    DWORD           cbIpp;
    DWORD           dwLE = ERROR_SUCCESS;
    BOOL            bRet = FALSE;
    DWORD           dwAuthMethod = pConnection->GetAuthMethod ();

    if (pgp = WebIppCreateGetPrnReq(0, lpszPortName)) {

        // Convert the request to IPP, and perform the
        // post.
        //
        ZeroMemory(&ri, sizeof(REQINFO));
        ri.cpReq = CP_UTF8;
        ri.idReq = IPP_REQ_FORCEAUTH;

        ri.fReq[0] = IPP_REQALL;
        ri.fReq[1] = IPP_REQALL;

        dwRet = WebIppSndData(IPP_REQ_FORCEAUTH,
                              &ri,
                              (LPBYTE)pgp,
                              pgp->cbSize,
                              &lpIpp,
                              &cbIpp);


        // The request-structure has been converted
        // to IPP format, so it is ready to go to
        // the server.
        //
        //
        if (dwRet == WEBIPP_OK) {

            bRet = pConnection->SendRequest (hReq, g_szContentType, cbIpp, lpIpp);

            if (!bRet) {
                // Check if it is an access denied or some other error

                dwLE = GetLastError();

                if (dwLE == ERROR_ACCESS_DENIED && dwAuthMethod == AUTH_UNKNOWN) {
                    CHAR szAuthScheme[MAX_SCHEME_LEN];
                    static CHAR szNTLM[] = "NTLM";
                    static CHAR szKerbero[] = "Kerbero";
                    static CHAR szNegotiate[] = "Negotiate";

                    if (pConnection->GetAuthSchem (hReq, szAuthScheme, MAX_SCHEME_LEN)) {
                        // We've got the scheme
                        if (! (*szAuthScheme)) {
                            // It does not have authentication enabled, only Anonymous is supported
                            *pdwAuthMethod = AUTH_ANONYMOUS;
                        }
                        if (strstr (szAuthScheme, szNTLM) ||
                            strstr (szAuthScheme, szKerbero) ||
                            strstr (szAuthScheme, szNegotiate)) {

                            // We have authentication scheme that can authentication with no
                            // popup, let's use it.
                            *pdwAuthMethod = AUTH_NT;

                        }
                        else {
                            // We have an authentications scheme, but we need to popup for username
                            // and password
                            *pdwAuthMethod = AUTH_OTHER;
                        }
                        bRet = TRUE;
                    }
                }
            }
            else {
                // It means somehow, either the authentication is done,
                // or we get unsupported operation

                bRet = _IppForceAuthRsp(pConnection, hReq, 0L);

                if (!bRet) {
                    // the response from the server does not seem to be OK, so
                    // we mark m_bForceAuthSupported as FALSE so that we will not
                    // send the ForceAuth request to the server again.

                    m_bForceAuthSupported = FALSE;
                }

                if (bRet && dwAuthMethod == AUTH_UNKNOWN) {
                    // The authentication is done, so let's use NTLM authentication

                    *pdwAuthMethod = AUTH_NT;
                }
                // else degrade to old logic
            }

            WebIppFreeMem(lpIpp);

        }

        WebIppFreeMem(pgp);
    }

    if (dwLE == ERROR_INVALID_DATA) {
        dwLE = ERROR_INVALID_PRINTER_NAME;
    }

    if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS))
        SetLastError(dwLE);

    return bRet;
}
BOOL
CPortMgr::_ForceAuth (
    CAnyConnection  *pConnection,
    LPCTSTR         lpszPortName,
    LPTSTR          lpszHost,
    LPTSTR          lpszUri,
    PDWORD          pdwAuthMethod)
{
    HINTERNET       hReq;
    DWORD           dwLE = ERROR_SUCCESS;
    BOOL            bRet = FALSE;

    if (pConnection->OpenSession()) {

        if (pConnection->Connect (lpszHost)) {

            // Make the request.
            //
            if (hReq = pConnection->OpenRequest (lpszUri)) {

                // If request handle is established, then all
                // is OK so far.
                //

                bRet = _IppForceAuth (pConnection,
                                      hReq,
                                      lpszPortName,
                                      pdwAuthMethod);
                dwLE = GetLastError();

                pConnection->CloseRequest (hReq);
            }

            pConnection->Disconnect ();
        }

        pConnection->CloseSession ();
    }

    if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS))
        SetLastError(dwLE);

    return bRet;
}

/*****************************************************************************\
* _IppValRsp (Local Callback Routine)
*
* Retrieves a get-printer-attributes response from the IPP server
*
\*****************************************************************************/
BOOL
CPortMgr::_IppValRsp(
    CAnyConnection *pConnection,
    HINTERNET      hReq,
    LPARAM         lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_PRN lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_GETPRN)) {

        while (TRUE) {

            cbRd = 0;
            if (pConnection->ReadFile (hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (!lpRsp) {
                        SetLastError (ERROR_INVALID_DATA);
                    }
                    else if ((bRet = lpRsp->bRet) == FALSE)
                        SetLastError(lpRsp->dwLastError);

                    WebIppFreeMem(lpRsp);

                    goto EndValRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //

                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("CPortMgr::_IppValRsp - Err : Receive Data Error (dwRet=%d, LE=%d)"),
                                             dwRet, WebIppGetError(hIpp)));

                    SetLastError(ERROR_INVALID_DATA);

                    goto EndValRsp;
                }

            } else {

                goto EndValRsp;
            }
        }

EndValRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}

BOOL
CPortMgr::_IppValidate (
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    LPCTSTR         lpszPortName)
{
    LPIPPREQ_GETPRN pgp;
    REQINFO         ri;
    DWORD           dwRet;
    LPBYTE          lpIpp;
    DWORD           cbIpp;
    DWORD           dwLE = ERROR_SUCCESS;
    BOOL            bRet = FALSE;

    if (pgp = WebIppCreateGetPrnReq(0, lpszPortName)) {

        // Convert the request to IPP, and perform the
        // post.
        //
        ZeroMemory(&ri, sizeof(REQINFO));
        ri.cpReq = CP_UTF8;
        ri.idReq = IPP_REQ_GETPRN;

        ri.fReq[0] = IPP_REQALL;
        ri.fReq[1] = IPP_REQALL;

        dwRet = WebIppSndData(IPP_REQ_GETPRN,
                              &ri,
                              (LPBYTE)pgp,
                              pgp->cbSize,
                              &lpIpp,
                              &cbIpp);


        // The request-structure has been converted
        // to IPP format, so it is ready to go to
        // the server.
        //
        //
        if (dwRet == WEBIPP_OK) {

            CMemStream *pStream = new CMemStream (lpIpp, cbIpp);

            if (pStream) {
                bRet = _SendRequest (pConnection, hReq, pStream);

                delete pStream;
            }

            if (bRet)
                bRet = _IppValRsp(pConnection, hReq, 0L);

            if (!bRet) {

                dwLE = GetLastError();

            }

            WebIppFreeMem(lpIpp);

        }

        WebIppFreeMem(pgp);
    }

    if (dwLE == ERROR_INVALID_DATA) {
        dwLE = ERROR_INVALID_PRINTER_NAME;
    }

    if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS))
        SetLastError(dwLE);

    return bRet;
}

BOOL
CPortMgr::_CheckConnection (
    CAnyConnection  *pConnection,
    LPCTSTR         lpszPortName,
    LPTSTR          lpszHost,
    LPTSTR          lpszUri)
{
    HINTERNET       hReq;
    DWORD           dwLE = ERROR_SUCCESS;
    BOOL            bRet = FALSE;

    if (pConnection->OpenSession()) {

        if (pConnection->Connect (lpszHost)) {

            // Make the request.
            //
            if (hReq = pConnection->OpenRequest (lpszUri)) {

                // If request handle is established, then all
                // is OK so far.
                //

                bRet = _IppValidate (pConnection,
                                     hReq,
                                     lpszPortName);
                dwLE = GetLastError();

                pConnection->CloseRequest (hReq);
            }

            pConnection->Disconnect ();
        }

        pConnection->CloseSession ();
    }

    if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS))
        SetLastError(dwLE);

    return bRet;
}

BOOL
CPortMgr::CheckConnection (void)
{
    HINTERNET       hReq;
    BOOL            bRet = FALSE;
    DWORD           dwLE = ERROR_SUCCESS;
    CAnyConnection *pConnection = NULL;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Enter CheckConnection")));

    if (m_bValid) {
        pConnection = _GetCurrentConnection ();

        if (hReq = _OpenRequest  (pConnection)) {
            bRet = _IppValidate (pConnection,
                                 hReq,
                                 m_lpszPortName);

            if (!bRet) {
                dwLE = GetLastError();
            }

            _CloseRequest (pConnection, hReq);
        }

        if (pConnection) {
            delete pConnection;
        }

        if (!bRet && dwLE != ERROR_SUCCESS) {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("CPortMgr::CheckConnection : Failed (lasterror=%d)"), dwLE));

            SetLastError (dwLE);
        }
    }
    else
        SetLastError (ERROR_INVALID_HANDLE);

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Leave CheckConnection ret=%d, lasterror=%d"), bRet, GetLastError ()));

    return bRet;
}

/*****************************************************************************\
* Function: Create
*
* This function is to establish the network connection with the given port name
*
* The intension of the function is to establish a network connection with
* authentication instead of anonymous. The alogortihm is as following
* 1. Try Anonymous
* 2. If anonymous connection is NOT possible, go to step 5
* 3. Try Force Authentication (Call _ForceAuth)
* 3.a.    Issue Force Authentication
* 3.b.    If the return value is  401 access denied, we start to check the
*         authentication scheme, otherwise, mark m_dwAuthMethod
*         as AUTH_ANONYMOUS and return TRUE
* 3.c.    If either NTLM, Kerbero or Negotiate is in the scheme, we mark
*         m_dwAuthMethod as AUTH_NT
*         Otherwise, we mark it as AUTH_OTHER
*         return TRUE
* 3.d.    (We don't get 401 access denied). If we get other errors, return FALSE
* 3.e.    Check the IPP response of the Forth Authentication
* 3.f.    If the IPP response is OK, we know we have established authentication
*         (This should not happen in the first time, but will happen afterward)
*         but we will mark m_dwAuthMethod as AUTH_NT anyway and return TRUE.
* 3.g.    Otherwise, (Not Supported), we assume that the server does not
*        support Force Authentication, so we move on by returning a FALSE.
*
* 4. If it returns OK, we start to use the authentication method indicated
*     in m_dwAuthMethod
* 5. Try NTLM or other no-popup authentication
* 6. Try Other popup authentications
*
* If the connection is established, the function returns TRUE.
*
\*****************************************************************************/

BOOL
CPortMgr::Create (
    LPCTSTR lpszPortName)
{
    LPTSTR lpszHost = NULL;
    LPTSTR lpszShare = NULL;
    INTERNET_PORT nPort;
    CAnyConnection *pConnection = NULL;
    BOOL bRet = FALSE;
    DWORD dwLE = 0;
    BOOL    bDone;
    BOOL bSecure;
    BOOL bAnonymous = FALSE;
    DWORD dwAuthMethod;

    // Try to find out if the server can be accessed without going
    // through Proxy Server
    //
    if ( utlParseHostShare(lpszPortName,
                             &lpszHost,
                             &lpszShare,
                             &nPort,
                             &bSecure)) {

        bDone = ! (AssignString (m_lpszHostName, lpszHost) &&
                AssignString (m_lpszUri, lpszShare) &&
                AssignString (m_lpszPortName, lpszPortName));

        m_bSecure = bSecure;
        m_nPort = nPort;

        // Set the flag to indicate it is creation time.
        //

        m_bPortCreate = TRUE;

        // Try connect and the get the proxy
        if (!bDone) {

            // We don't care about if the reset succeeded or not
            EndBrowserSession ();
        }

        // Try anonymous with/without proxy

        if (!bDone && (pConnection = new CAnonymousConnection (bSecure, nPort, FALSE))
             && pConnection->IsValid ()) {

            bDone = TRUE;

            if (_CheckConnection(pConnection, lpszPortName, lpszHost, lpszShare)) {
                bAnonymous = TRUE;
            }
            else {
                dwLE = GetLastError ();

                if (dwLE == ERROR_INTERNET_NAME_NOT_RESOLVED) {

                    // The server name is wrong, reset tht last error
                    // to invalid printer name
                    //

                    SetLastError (ERROR_INVALID_PRINTER_NAME);
                }
                else if (dwLE == HTTP_STATUS_FORBIDDEN) {
                    SetLastError (ERROR_ACCESS_DENIED);
                }
                else if (dwLE != ERROR_INVALID_PRINTER_NAME)
                    bDone = FALSE; // Cont to the next mode
            }

            if (bAnonymous) {

                // We've got an anonymous authentication
                if (_ForceAuth(pConnection, lpszPortName, lpszHost, lpszShare, &dwAuthMethod)) {

                    // We've got an authentication method
                    if (dwAuthMethod != AUTH_ANONYMOUS) {
                        bDone = FALSE;
                        SetLastError (ERROR_ACCESS_DENIED);

                        if (dwAuthMethod == AUTH_OTHER) {
                            bDone = TRUE;
                            //weihaic goto TryOther;
                        }
                    }
                    else
                        bRet = TRUE;
                }
                else {
                    // We've got anonymous, and the serve does not support FORCE_AUTH
                    // so let us use it.
                    dwAuthMethod = AUTH_ANONYMOUS;
                    bRet = TRUE;
                }
            }
        }

        // You must have got access denied in this case

        // Let's try again without any password, it will work if the server has NTLM/Kerbero enabled.
        //
        if (!bDone && GetLastError () == ERROR_ACCESS_DENIED) {

            if (pConnection) {
                delete (pConnection);
                pConnection = NULL;
            }
            bDone = TRUE;

            if ( (pConnection = new CNTConnection (bSecure, nPort, FALSE) )
                 && pConnection->IsValid ()) {

                if (_CheckConnection(pConnection, lpszPortName, lpszHost, lpszShare)) {
                    dwAuthMethod = AUTH_NT;
                    bRet = TRUE;
                }
                else {
                    dwLE = GetLastError ();

                    if (dwLE != ERROR_INVALID_PRINTER_NAME)
                        bDone = FALSE; // Cont to the next mode
                }
            }
        }


        if (!bDone && GetLastError () == ERROR_ACCESS_DENIED && bAnonymous) {
            // We know that anonymous is enabled, so let us degrade the connection to anonymous
            if (pConnection) {
                delete (pConnection);
                pConnection = NULL;
            }

            // We must reset m_dwAuthMethod since when we try other authentication
            // m_dwAuthMethod is set to AUTH_OTHER, if we do not reset the value
            // when we try to send request to the server, it will fail with access
            // denied.
            //

            dwAuthMethod = AUTH_UNKNOWN;

            if (!bDone && (pConnection = new CAnonymousConnection (bSecure, nPort, FALSE))
                 && pConnection->IsValid ()) {

                bDone = TRUE;

                if (_CheckConnection(pConnection, lpszPortName, lpszHost, lpszShare)) {
                    bRet = TRUE;
                    dwAuthMethod = AUTH_ANONYMOUS;
                }
            }
        }
    }
    // Exit point

    //
    // We need to create the port at first if we get access denied
    // then users can configure the port using a different user name
    // and password
    //

    if (!bRet && GetLastError () == ERROR_ACCESS_DENIED) {
        //
        // Force anonymous connection. This will fail anyway.
        //
        dwAuthMethod = AUTH_ACCESS_DENIED;
        bRet = TRUE;
    }

    if (bRet) {
        m_bValid = TRUE;

        m_pPortSettingMgr = new CPortConfigDataMgr (lpszPortName);

        if (m_pPortSettingMgr && m_pPortSettingMgr->bValid ()) {

            CPortConfigData ConfigData;

            ConfigData.SetAuthMethod (dwAuthMethod);

            bRet = m_pPortSettingMgr->SetPerPortSettings (ConfigData);
        }
        else
            bRet = FALSE;
    }

    if (lpszHost) {
        memFreeStr (lpszHost);
    }

    if (lpszShare) {
        memFreeStr (lpszShare);
    }

    if (!bRet) {
        // Clean up the connection class
        if (pConnection) {
            delete (pConnection);
            pConnection = NULL;
        }

        if (GetLastError () != ERROR_ACCESS_DENIED) {
            // Invalid Printer Name

            // The NT router expects inetpp to returen ERROR_INVALID_NAME,
            // if we return ERROR_INVALID_PRINTER_NAME, the router will return
            // this error back to the user
            //
            SetLastError (ERROR_INVALID_NAME);
        }

    }

    m_bPortCreate = FALSE;

    return bRet;

}

BOOL
CPortMgr::ConfigurePort (
    PINET_XCV_CONFIGURATION pXcvConfigurePortReqData,
    PINET_CONFIGUREPORT_RESPDATA pXcvAddPortRespData,
    DWORD cbSize,
    PDWORD cbSizeNeeded)
{
    LPTSTR lpszHost = NULL;
    LPTSTR lpszShare = NULL;
    INTERNET_PORT nPort;
    CAnyConnection *pConnection = NULL;
    BOOL bRet = FALSE;
    DWORD dwLE = 0;
    BOOL    bDone;
    BOOL bSecure;
    BOOL bAnonymous = FALSE;
    CPortConfigData OldConfigData;
    LPCTSTR pPassword = NULL;


    // Reset everything
    EndBrowserSession ();

    //
    // We must retry force authentication when configuration changes
    //
    m_bForceAuthSupported = TRUE;


    BOOL bIgnoreSecurityDlg = pXcvConfigurePortReqData->bIgnoreSecurityDlg;
    DWORD dwAuthMethod = pXcvConfigurePortReqData->dwAuthMethod;

    switch (dwAuthMethod) {
    case AUTH_ANONYMOUS:
        pConnection = new CAnonymousConnection (m_bSecure, m_nPort, bIgnoreSecurityDlg);
        break;
    case AUTH_NT:
        pConnection = new CNTConnection (m_bSecure, m_nPort, bIgnoreSecurityDlg);
        break;
    case AUTH_OTHER:

        if (m_pPortSettingMgr->GetCurrentSettings  (&OldConfigData))
            pPassword = OldConfigData.GetPassword();

        pPassword = (pXcvConfigurePortReqData->bPasswordChanged)?pXcvConfigurePortReqData->szPassword:pPassword;

        pConnection = new COtherConnection (m_bSecure, m_nPort,
                                            pXcvConfigurePortReqData->szUserName,
                                            pPassword,
                                            bIgnoreSecurityDlg);
    default:
        break;
    }

    if (pConnection && pConnection->IsValid()) {

        if (_CheckConnection(pConnection, m_lpszPortName, m_lpszHostName, m_lpszUri)) {

            bRet = TRUE;
        }
        else {
            dwLE = GetLastError ();

            if (dwLE == ERROR_INTERNET_NAME_NOT_RESOLVED) {

                // The server name is wrong, reset tht last error
                // to invalid printer name
                //

                SetLastError (ERROR_INVALID_PRINTER_NAME);
            }
            else if (dwLE == HTTP_STATUS_FORBIDDEN) {
                SetLastError (ERROR_ACCESS_DENIED);
            }
            else if (dwLE != ERROR_INVALID_PRINTER_NAME)
                SetLastError (dwLE);
        }
    }
    // Exit point

    if (bRet) {
        m_bValid = TRUE;

        CPortConfigData ConfigData;

        bRet = ConfigData.SetAuthMethod (dwAuthMethod);

        if (bRet) {

            if (dwAuthMethod == AUTH_OTHER) {
                bRet = ConfigData.SetUserName (pXcvConfigurePortReqData->szUserName) &&
                    ConfigData.SetPassword (pPassword);
            }
            else
                bRet = ConfigData.SetUserName(NULL) && ConfigData.SetPassword(NULL);

            if (bRet) {
                bRet = m_pPortSettingMgr->SetPerUserSettings  (ConfigData);
            }

            if (bRet && pXcvConfigurePortReqData->bSettingForAll)
                bRet = m_pPortSettingMgr->SetPerPortSettings  (ConfigData);
        }
    }
    return bRet;

}

BOOL
CPortMgr::GetCurrentConfiguration (
    PINET_XCV_CONFIGURATION pXcvConfiguration)
{
    CPortConfigData ConfigData;

    ZeroMemory (pXcvConfiguration, sizeof (INET_XCV_CONFIGURATION));

    m_pPortSettingMgr->GetCurrentSettings (&ConfigData);

    pXcvConfiguration->dwVersion = 1;
    pXcvConfiguration->dwAuthMethod = ConfigData.GetAuthMethod ();
    if (pXcvConfiguration->dwAuthMethod == AUTH_OTHER) {
        if (ConfigData.GetUserName()) {
            StringCchCopy(pXcvConfiguration->szUserName, COUNTOF(pXcvConfiguration->szUserName), ConfigData.GetUserName());
        }
    }
    pXcvConfiguration->bIgnoreSecurityDlg = ConfigData.GetIgnoreSecurityDlg();

    return TRUE;

}

BOOL
CPortMgr::Init (
    LPCTSTR lpszPortName)
{
    LPTSTR lpszHost = NULL;
    LPTSTR lpszShare = NULL;
    INTERNET_PORT nPort;
    BOOL bRet = FALSE;
    BOOL bSecure = FALSE;

    if ( utlParseHostShare(lpszPortName,
                         &lpszHost,
                         &lpszShare,
                         &nPort,
                         &bSecure)) {

        m_pPortSettingMgr = new CPortConfigDataMgr (lpszPortName);

        if (m_pPortSettingMgr && m_pPortSettingMgr->bValid ()) {
            bRet = TRUE;
        }
    }

    if (bRet) {

        m_bValid = TRUE;

        m_bSecure = bSecure;
        m_nPort = nPort;

        bRet = AssignString (m_lpszHostName, lpszHost) &&
               AssignString (m_lpszUri, lpszShare) &&
               AssignString (m_lpszPortName, lpszPortName);
    }

    if (lpszHost) {
        memFreeStr (lpszHost);
    }

    if (lpszShare) {
        memFreeStr (lpszShare);
    }

    return bRet;

}

BOOL
CPortMgr::Remove (void)
{
    if (m_pPortSettingMgr) {
        m_pPortSettingMgr->DeleteAllSettings ();

    }
    return TRUE;
}

CAnyConnection *
CPortMgr::_GetCurrentConnection ()
{
    CPortConfigData ConfigData;
    CAnyConnection *pConnection = NULL;

    if (m_pPortSettingMgr->GetCurrentSettings (&ConfigData)) {

        switch (ConfigData.GetAuthMethod ()) {
        case AUTH_ANONYMOUS:

            pConnection = new CAnonymousConnection (m_bSecure, m_nPort, ConfigData.GetIgnoreSecurityDlg());
            break;

        case AUTH_NT:
            pConnection = new CNTConnection (m_bSecure, m_nPort, ConfigData.GetIgnoreSecurityDlg());
            break;

        case AUTH_OTHER:
            pConnection = new COtherConnection (m_bSecure, m_nPort,
                                                ConfigData.GetUserName(), ConfigData.GetPassword(),
                                                ConfigData.GetIgnoreSecurityDlg());

            break;
        case AUTH_ACCESS_DENIED:
            SetLastError (ERROR_ACCESS_DENIED);
            break;
        default:
            SetLastError (ERROR_INVALID_HANDLE);
            break;
        }
    }
    else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("_GetCurrentConnection - Err  GetCurrentSettings failed (LE=%d)"), GetLastError ()));

        SetLastError (ERROR_INVALID_HANDLE);
    }
    return pConnection;

}

BOOL
CPortMgr::SendRequest(
    PCINETMONPORT   pIniPort,
    LPBYTE          lpIpp,
    DWORD           cbIpp,
    IPPRSPPROC      pfnRsp,
    LPARAM          lParam)
{
    BOOL        bRet = FALSE;
    CMemStream  *pStream;

    pStream = new CMemStream (lpIpp, cbIpp);

    if (pStream && pStream->bValid ()){
        bRet = SendRequest (pIniPort, pStream, pfnRsp, lParam);
    }

    if (pStream) {
        delete pStream;
    }
    return bRet;

}

BOOL
CPortMgr::SendRequest(
    PCINETMONPORT   pIniPort,
    CStream         *pStream,
    IPPRSPPROC      pfnRsp,
    LPARAM          lParam)
{
    HINTERNET   hReq;
    DWORD       dwLE = ERROR_SUCCESS;
    BOOL        bRet = FALSE;

    if (m_bValid) {

        CAnyConnection * pConnection;

        pConnection = _GetCurrentConnection ();

        if (pConnection) {

            hReq = _OpenRequest  (pConnection);

            // If succeeded, then build the content-length-header.
            //
            if (hReq) {

                bRet = _SendRequest (pConnection, hReq, pStream);

                if (bRet)
                    bRet = (pfnRsp ? (*pfnRsp)(pConnection, hReq, pIniPort, lParam) : TRUE);

                dwLE = GetLastError();

                _CloseRequest (pConnection, hReq);
            }
        }
        else
            dwLE = GetLastError ();

        if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS)) {

            if (dwLE == HTTP_STATUS_FORBIDDEN) {
                SetLastError (ERROR_ACCESS_DENIED);
            }
            else
                SetLastError(dwLE);

        }
    }
    else {
        SetLastError (ERROR_INVALID_HANDLE);
    }

    return bRet;

}

DWORD
CPortMgr::IncreaseUserRefCount(
    CLogonUserData *pUser)
/*++

Routine Description:
    Increase the Ref Count for the current user in the Port Manager.

Arguments:
    pUser  -  The user that we want to increment the RefCount for.

Return Value:
    The current refcount for the user, or MAXDWORD if the user could not be found.

--*/
    {
    CLogonUserData *pPortUser = NULL;
    CLogonUserData *pNewUser  = NULL;
    DWORD          dwRefCount = MAXDWORD;

    DBG_ASSERT( pUser          , (TEXT("CPortMgr::IncreaseUserRefCount - pUser is NULL.")) );
    DBG_ASSERT( pUser->bValid(), (TEXT("CPortMgr::IncreaseUserRefCount - pUser is invalid.")) );

    m_UserList.Lock(); // We need to be sure only one CurUser is considered per port per time.

    if (pPortUser = m_UserList.Find( pUser )) {

        // We have found the port user, increment their refcount.
        dwRefCount = pPortUser->IncRefCount();

        DBG_MSG(DBG_LEV_INFO,
                (TEXT("Info: IncRef to (%d), User (%p)"), dwRefCount, pPortUser ) );
    } else {

        pNewUser = new CLogonUserData;  // A new user automatically has a ref-count of 1.

        if (pNewUser != NULL) {

            *pNewUser = *pUser;             // Assign data across

            if (!pNewUser->bValid() ||
                !m_UserList.Insert( pNewUser )) {
                delete pNewUser;
                pNewUser = NULL;

                SetLastError( ERROR_INVALID_PARAMETER );
            } else
            dwRefCount = 1;
        }
    }

    m_UserList.Unlock();

    return dwRefCount;
}

CLogonUserData*
CPortMgr::GetUserIfLastDecRef(
    CLogonUserData *pUser)
/*++

Routine Description:
    This routine finds the reference count for the current user. If the reference count is
    zero we return a pointer to the user, otherwise we return NULL. This will be used by
    the Cache Manager to invalid the cache for the particular user.

    NOTE: Caller must Free the pUser.

Arguments:
    None

Return Value:
    A pointer to the user if their RefCount has gone to Zero, NULL otherwise.

--*/
    {
    CLogonUserData *pPortUser = NULL;
    CLogonUserData *pNewUser  = NULL;
    DWORD          dwRefCount;

    DBG_ASSERT( pUser         , (TEXT("CPortMgr::GetUserIfLastDecRef - pUser is NULL.")) );
    DBG_ASSERT( pUser->bValid(), (TEXT("CPortMgr::GetUserIfLastDecRef - pUser is invalid.")) );

    m_UserList.Lock();

    if (pPortUser = m_UserList.Find( pUser )) {
        // We have found the port user, increment their refcount.

        // Make sure that two threads aren't handling the RefCount at the same
        // time
        dwRefCount = pPortUser->DecRefCount();

        DBG_MSG(DBG_LEV_INFO,
                (TEXT("Info: DecRef to (%d), User (%p)"), dwRefCount, pPortUser ) );

        if (dwRefCount == 0) {
            pNewUser = new CLogonUserData;

            if (pNewUser != NULL) {
                *pNewUser = *pPortUser;
            }

        m_UserList.Delete( pPortUser );     // We don't need him in the list anymore

        }
    }

    m_UserList.Unlock();

    return pNewUser;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ppchange.h ===
/*****************************************************************************\
* MODULE: ppchange.h
*
* Prototypes for private funcions in ppchange.c.  These functions handle
* notification support
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*   28-Apr-1998     Weihai Chen (weihaic)
*
\*****************************************************************************/

#ifndef _PPCHANGE_H
#define _PPCHANGE_H

BOOL
AddHandleToList (
    LPINET_HPRINTER hPrinter);

BOOL
DeleteHandleFromList (
    LPINET_HPRINTER hPrinter);

void
RefreshNotificationPort (
   HANDLE hPort
   );

void
RefreshNotification (
   LPINET_HPRINTER hPrinter);

BOOL
PPFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus,
    PVOID pPrinterNotifyOptions,
    PVOID pPrinterNotifyInit);

BOOL
PPFindClosePrinterChangeNotification(
    HANDLE hPrinter
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ppinfo.h ===
/*****************************************************************************\
* MODULE: ppinfo.h
*
* Prototypes for print-job information routines.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _PPINFO_H
#define _PPINFO_H

// Mask of printer enum type flags for EnumPrinter requests that our
// provider doesn't handle.
//
#define PRINTER_ENUM_NOTFORUS  (PRINTER_ENUM_DEFAULT  | \
                                PRINTER_ENUM_LOCAL    | \
                                PRINTER_ENUM_FAVORITE | \
                                PRINTER_ENUM_SHARED     \
                               )

// This macro returns a pointer to the location specified by length.  This
// assumes calculations in BYTES.  We cast it to the LPTSTR to assure the
// pointer reference will support UNICODE.
//
#define ENDOFBUFFER(buf, length)  (LPTSTR)((((LPSTR)buf) + (length - sizeof(TCHAR))))


// PrintProcessor information routines.
//
BOOL PPEnumPrinters(
    DWORD   dwType,
    LPTSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned);

BOOL PPGetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  lpbPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ppinfo.cxx ===
/*****************************************************************************\
* MODULE: ppinfo.c
*
* This module contains the print-information routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   09-Jun-1993 JonMarb     Created
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/


#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* ppprn_IppGetRsp (Local Callback Routine)
*
* Retrieves a GetPrinter response from the IPP server
*
\*****************************************************************************/
BOOL CALLBACK ppinfo_IppGetRsp(
    CAnyConnection *pConnection,
    HINTERNET hReq,
    PCINETMONPORT   pIniPort,
    LPARAM    lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_PRN lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_GETPRN)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile (pConnection, hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (!lpRsp) {
                        SetLastError (ERROR_INVALID_DATA);
                    }
                    else if ((bRet = lpRsp->bRet) == FALSE)
                        SetLastError(lpRsp->dwLastError);
                    else {

                        pIniPort->SetPowerUpTime (lpRsp->pi.ipp.dwPowerUpTime);
                        ((LPPRINTER_INFO_2)lParam)->Status       = lpRsp->pi.pi2.Status;
                        ((LPPRINTER_INFO_2)lParam)->cJobs        = lpRsp->pi.pi2.cJobs;
                        ((LPPRINTER_INFO_2)lParam)->pPrinterName = memAllocStr(lpRsp->pi.pi2.pPrinterName);
                        ((LPPRINTER_INFO_2)lParam)->pDriverName  = memAllocStr(lpRsp->pi.pi2.pDriverName);
                    }

                    WebIppFreeMem(lpRsp);

                    goto EndGetRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //

                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppinfo_IppGetRsp - Err : Receive Data Error (dwRet=%d, LE=%d)"),
                         dwRet, WebIppGetError(hIpp)));

                    SetLastError(ERROR_INVALID_DATA);

                    goto EndGetRsp;
                }

            } else {

                goto EndGetRsp;
            }
        }

EndGetRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* ppinfo_Get (Local Routine)
*
* Gets printer info from server.
*
\*****************************************************************************/
BOOL ppinfo_Get(
    PCINETMONPORT           pIniPort,
    LPPRINTER_INFO_2 ppi2)
{
    PIPPREQ_GETPRN pgp;
    REQINFO        ri;
    DWORD          dwRet;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    LPCTSTR        lpszUri;
    BOOL           bRet = FALSE;

    lpszUri = pIniPort->GetPortName();


    // Create our ipp-reqest-structure.
    //
    if (pgp = WebIppCreateGetPrnReq(0, lpszUri)) {

        // Convert the reqest to IPP, and perform the
        // post.
        //
        ZeroMemory(&ri, sizeof(REQINFO));
        ri.cpReq = CP_UTF8;
        ri.idReq = IPP_REQ_GETPRN;

        ri.fReq[0] = IPP_REQALL;
        ri.fReq[1] = IPP_REQALL;

        dwRet = WebIppSndData(IPP_REQ_GETPRN,
                              &ri,
                              (LPBYTE)pgp,
                              pgp->cbSize,
                              &lpIpp,
                              &cbIpp);


        // The request-structure has been converted to IPP format,
        // so it is ready to go to the server.
        //
        if (dwRet == WEBIPP_OK) {

            bRet = pIniPort->SendReq(lpIpp,
                                     cbIpp,
                                     ppinfo_IppGetRsp,
                                     (LPARAM)ppi2,
                                     TRUE);

            WebIppFreeMem(lpIpp);

        } else {

            SetLastError(ERROR_OUTOFMEMORY);
        }

        WebIppFreeMem(pgp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* _ppinfo_set_str (Local Routine)
*
* Copies strings into a Win32 format buffer -- a structure at the front of
* the buffer and strings packed into the end.
*
* On entry,
*   dest points to the place to write the string offset in the buffer.
*   src points to a null terminated string, can be NULL.
*   *buf should point to the last available byte in the buffer.
*
* Asumption:
*   This routine assumes that the memory between dest and *buf are availabe
*   for the string data.
*
\*****************************************************************************/
VOID _ppinfo_set_str(
    LPTSTR  *dest,
    LPCTSTR src,
    LPTSTR  *buf)
{
    if (src != NULL) {

        size_t uSize = lstrlen(src);

        //
        // If the destination pointer is greater than or equal to buffer pointer adjusted
        // by the length of the string the string will overflow the buffer.  If this
        // happens we place a null as the destination pointer.  This routine
        // really should return a failure code, to inform the caller an error error
        // happened.
        //
        if ((DWORD_PTR)dest >= (DWORD_PTR)((*buf) - uSize))
        {
            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: String fill overrun in _ppinfo_set_str")));

            *dest = TEXT('\0');
        }
        else
        {
            // Place string at end of buffer.  This performs pointer
            // arithmatic, so the offsets are TCHAR in size.
            //
            (*buf) -= uSize;

            //
            // Copy the string data.
            //
            StringCchCopy(*buf, uSize+1, src);

            // Place string address in structure and save pointer to new
            // last available byte.
            //
            *dest = *buf;
            (*buf)--;
        }

    } else {

        *dest = TEXT('\0');
    }
}


/*****************************************************************************\
* _ppinfo_describe_provider (Local Routine)
*
* Fills a PRINTER_INFO_1 structure with information about the print provider.
* Returns TRUE if successful.  Otherwise, it returns FALSE.  Extended error
* information is available from GetLastError.
*
\*****************************************************************************/
BOOL _ppinfo_describe_provider(
    LPPRINTER_INFO_1 pInfo,
    DWORD            cbSize,
    LPDWORD          pcbNeeded,
    LPDWORD          pcbReturned)
{
    LPTSTR pszString;


    // Calculate the space needed (in bytes) that is necessary to
    // store the information for the print-processor.
    //
    *pcbNeeded = sizeof(PRINTER_INFO_1)       +
                 utlStrSize(g_szDescription)  +
                 utlStrSize(g_szProviderName) +
                 utlStrSize(g_szComment);

    if (*pcbNeeded > cbSize) {

        *pcbReturned = 0;

        DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: _describe_provider: Not enough memory")));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }


    // Initialize the fields which do not need to copy strings.
    //
    pInfo->Flags = (PRINTER_ENUM_ICON1 | PRINTER_ENUM_CONTAINER);

    //
    // Hide this provider from the UI, there is nothing underneath to enumerate.
    //
    pInfo->Flags |= PRINTER_ENUM_HIDE;

    // Set the string information.  First set the (pszString) pointer
    // to the first location at the end of the buffer which will store
    // the string.
    //
    pszString = ENDOFBUFFER(pInfo, cbSize);

    _ppinfo_set_str(&pInfo->pDescription, g_szDescription , &pszString);
    _ppinfo_set_str(&pInfo->pName       , g_szProviderName, &pszString);
    _ppinfo_set_str(&pInfo->pComment    , g_szComment     , &pszString);


    // Return the number of structures copied.
    //
    *pcbReturned = 1;

    return TRUE;
}


/*****************************************************************************\
* _ppinfo_net_get_info (Local Routine)
*
* Fills a supplied PRINTER_INFO_2 structure with all the information
* we can dig up on the specified IPP1 print server.
*
* Takes a pointer to PPRINTER_INFO_2 which is allocated to be the correct size
*
* Returns TRUE if successful, FALSE if otherwise.
*
\*****************************************************************************/
BOOL _ppinfo_net_get_info(
    IN  PCINETMONPORT   pIniPort,
    OUT PPRINTER_INFO_2 *ppInfo,
    OUT LPDWORD         lpBufAllocated,
    IN  ALLOCATORFN     pAllocator)
{
    PRINTER_INFO_2  pi2;
    PPRINTER_INFO_2 pInfo;
    LPTSTR          pszString;
    LPCTSTR          pszPortName;
    DWORD           dwAllocSize;
    BOOL            bRet = FALSE;


    // Make a server-call to get the printer-information.
    //
    DBG_ASSERT( ppInfo,         (TEXT("_ppinfo_net_get_info passed in NULL LPPI2 *")) );
    DBG_ASSERT( pAllocator,     (TEXT("_ppinfo_net_get_info passed in NULL Allocator")) );
    DBG_ASSERT( lpBufAllocated, (TEXT("_ppinfo_net_get_info passed in NULL buffer allocated return size")) );

    *ppInfo = NULL;             // NULL out ppInfo, just in case
    *lpBufAllocated = 0;        // Set allocated size to zero

    ZeroMemory(&pi2, sizeof(PRINTER_INFO_2));

    if (!ppinfo_Get(pIniPort, &pi2))
        goto BailOut;

    pszPortName = pIniPort->GetPortName();

    dwAllocSize = ( ( pi2.pPrinterName ? lstrlen( pi2.pPrinterName) + 1 : 0) +
                    ( pszPortName      ? lstrlen( pszPortName )     + 1 : 0) +
                    ( pi2.pDriverName  ? lstrlen( pi2.pDriverName ) + 1 : 0) +
                      7 * 1 ) * sizeof(TCHAR) + sizeof(PRINTER_INFO_2);

    pInfo = (PPRINTER_INFO_2)pAllocator( dwAllocSize );

    if (NULL == pInfo)
        goto Cleanup;

    pszString = ENDOFBUFFER( pInfo, dwAllocSize );

    // Set non-string entries.
    //
    pInfo->cJobs               = pi2.cJobs;
    pInfo->Status              = pi2.Status;
    pInfo->pDevMode            = NULL;
    pInfo->pSecurityDescriptor = NULL;
    pInfo->Attributes          = PRINTER_ATTRIBUTE_NETWORK;
    pInfo->Priority            = pi2.Priority;
    pInfo->StartTime           = pi2.StartTime;
    pInfo->UntilTime           = pi2.UntilTime;
    pInfo->AveragePPM          = pi2.AveragePPM;


    // Set any remaining fields that we can't fill to reasonable values.
    //
    _ppinfo_set_str(&pInfo->pPrinterName   , pi2.pPrinterName         , &pszString);
    _ppinfo_set_str(&pInfo->pShareName     , g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pPortName      , pszPortName              , &pszString);
    _ppinfo_set_str(&pInfo->pDriverName    , pi2.pDriverName          , &pszString);
    _ppinfo_set_str(&pInfo->pComment       , g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pLocation      , g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pSepFile       , g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pPrintProcessor, g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pDatatype      , g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pParameters    , g_szEmptyString          , &pszString);

    *lpBufAllocated = dwAllocSize;  // Set the size to what we have allocated
    *ppInfo = pInfo;                // Return the allocated structure
    // Since we've allocated our strings in ppinfo_get, we will need
    // to explicitly free them.
    //

    bRet = TRUE;

Cleanup:

    if (pi2.pPrinterName) memFreeStr(pi2.pPrinterName);
    if (pi2.pDriverName) memFreeStr(pi2.pDriverName);

BailOut:

    return bRet;
}


/*****************************************************************************\
* _ppinfo_calc_level1 (Local Routine)
*
* Calculates the amount of buffer space needed to store a single level 1
* GetPrinter() result buffer.
*
\*****************************************************************************/
DWORD _ppinfo_calc_level1(
    PPRINTER_INFO_2 pSrcInfo)
{
    DWORD cbSize;

    //
    // Figure out how many bytes of buffer space we're going to need.
    //
    cbSize = sizeof(PRINTER_INFO_1)             +
             utlStrSize(g_szEmptyString)        +  // description
             utlStrSize(pSrcInfo->pPrinterName) +  // name
             utlStrSize(pSrcInfo->pComment);       // comment

    return cbSize;
}


/*****************************************************************************\
* _ppinfo_calc_level2 (Local Routine)
*
* Calculates the amount of buffer space needed to
* store a single level 2 GetPrinter() result buffer.
*
\*****************************************************************************/
DWORD _ppinfo_calc_level2(
    LPCTSTR         pszServerName,
    PPRINTER_INFO_2 pSrcInfo)
{
    DWORD     cbSize;
    LPDEVMODE pDevmode;

    //
    // Figure out how many bytes of buffer space we're going to need.
    //
    cbSize = sizeof(PRINTER_INFO_2)                +
             utlStrSize(pszServerName)             +  // Server Name
             utlStrSize(pSrcInfo->pPrinterName)    +  // Printer Name
             utlStrSize(pSrcInfo->pShareName)      +  // Share Name
             utlStrSize(pSrcInfo->pPortName)       +  // Port Name
             utlStrSize(pSrcInfo->pDriverName)     +  // Driver Name
             utlStrSize(pSrcInfo->pComment)        +  // Comment
             utlStrSize(pSrcInfo->pLocation)       +  // Location
             utlStrSize(pSrcInfo->pSepFile)        +  // Separator file
             utlStrSize(pSrcInfo->pPrintProcessor) +  // Print processor
             utlStrSize(pSrcInfo->pDatatype)       +  // Data type
             utlStrSize(pSrcInfo->pParameters);       // Parameters

    if (pSrcInfo->pDevMode != NULL) {
        pDevmode = pSrcInfo->pDevMode;
        cbSize  += pDevmode->dmSize + pDevmode->dmDriverExtra;
    }

    return cbSize;
}


/*****************************************************************************\
* _ppinfo_calc_level4 (Local Routine)
*
* Calculates the amount of buffer space needed to
* store a single level 4 GetPrinter() result buffer.
*
\*****************************************************************************/
DWORD _ppinfo_calc_level4(
    PPRINTER_INFO_2 pSrcInfo)
{
    DWORD cbSize;

    //
    // Figure out how many bytes of buffer space we're going to need.
    //
    cbSize = sizeof(PRINTER_INFO_4)                +
             utlStrSize(pSrcInfo->pPrinterName)    +  // Printer Name
             utlStrSize(pSrcInfo->pServerName);


    return cbSize;
}

/*****************************************************************************\
* _ppinfo_calc_level2 (Local Routine)
*
* Calculates the amount of buffer space needed to
* store a single level 5 GetPrinter() result buffer.
*
\*****************************************************************************/
DWORD _ppinfo_calc_level5(
    PPRINTER_INFO_2 pSrcInfo)
{
    DWORD cbSize;


    //
    // Figure out how many bytes of buffer space we're going to need.
    //
    cbSize = sizeof(PRINTER_INFO_5)                +
             utlStrSize(pSrcInfo->pPrinterName)    +  // Printer Name
             utlStrSize(pSrcInfo->pPortName);


    return cbSize;
}


/*****************************************************************************\
* _ppinfo_build_level1 (Local Routine)
*
* Given a pointer to a source PRINTER_INFO_2 structure, a
* destination PRINTER_INFO_1 structure and a pointer to the
* start of string storage space, fills the PRINTER_INFO_1 structure.
*
* Called by GetPrinter and EnumPrinters, level 1.  Returns an
* LPSTR pointer to the last available data byte remaining in the
* buffer.
*
\*****************************************************************************/
LPTSTR _ppinfo_build_level1(
    PPRINTER_INFO_2 pSrcInfo,
    PPRINTER_INFO_1 pDstInfo,
    LPTSTR          pszString)
{
    // Flags.
    //
    pDstInfo->Flags = PRINTER_ENUM_CONTAINER;

    pDstInfo->Flags |= PRINTER_ENUM_HIDE;

    // Description
    //
    // CODEWORK - The Win32 structure has a field for "description" that has
    // no equivalent in the network printer info structure.  What do we
    // really want here?  For now, I'm copying in an empty string as a
    // placeholder.
    //
    _ppinfo_set_str(&pDstInfo->pDescription, g_szEmptyString       , &pszString);
    _ppinfo_set_str(&pDstInfo->pName       , pSrcInfo->pPrinterName, &pszString);
    _ppinfo_set_str(&pDstInfo->pComment    , pSrcInfo->pComment    , &pszString);

    return pszString;
}


/*****************************************************************************\
* _ppinfo_build_level2 (Local Routine)
*
* Given a server name, a pointer to a source PRINTER_INFO_2
* structure, a destination PRINTER_INFO_2 structure and a pointer to
* the start of string storage space, fills the PRINTER_INFO_2 structure.
*
* Called by GetPrinter and EnumPrinters, level 2.  Returns an
* LPTSTR pointer to the last available data char in the data buffer.
*
\*****************************************************************************/
LPTSTR _ppinfo_build_level2(
    LPCTSTR         pszServerName,
    PPRINTER_INFO_2 pSrcInfo,
    PPRINTER_INFO_2 pDstInfo,
    LPTSTR          pszString)
{

    // Set non-string entries.
    //
    pDstInfo->pSecurityDescriptor = NULL;
    pDstInfo->Attributes          = pSrcInfo->Attributes;
    pDstInfo->Priority            = pSrcInfo->Priority;
    pDstInfo->DefaultPriority     = pSrcInfo->Priority;
    pDstInfo->StartTime           = pSrcInfo->StartTime;
    pDstInfo->UntilTime           = pSrcInfo->UntilTime;
    pDstInfo->Status              = pSrcInfo->Status;
    pDstInfo->cJobs               = pSrcInfo->cJobs;
    pDstInfo->AveragePPM          = pSrcInfo->AveragePPM;


    // Copy the required data to the Win 32 PRINTER_INFO_2 structure.
    //
    // SPECWORK - several of these fields are filled with "" placeholders.
    // We probably need to put real information  in some of them.
    // The current inetpp protocol does not supply this information to us.
    //
    _ppinfo_set_str(&pDstInfo->pServerName    , pszServerName            , &pszString);
    _ppinfo_set_str(&pDstInfo->pPrinterName   , pSrcInfo->pPrinterName   , &pszString);
    _ppinfo_set_str(&pDstInfo->pShareName     , pSrcInfo->pShareName     , &pszString);
    _ppinfo_set_str(&pDstInfo->pPortName      , pSrcInfo->pPortName      , &pszString);
    _ppinfo_set_str(&pDstInfo->pDriverName    , pSrcInfo->pDriverName    , &pszString);
    _ppinfo_set_str(&pDstInfo->pComment       , pSrcInfo->pComment       , &pszString);
    _ppinfo_set_str(&pDstInfo->pLocation      , pSrcInfo->pLocation      , &pszString);
    _ppinfo_set_str(&pDstInfo->pSepFile       , pSrcInfo->pSepFile       , &pszString);
    _ppinfo_set_str(&pDstInfo->pPrintProcessor, pSrcInfo->pPrintProcessor, &pszString);
    _ppinfo_set_str(&pDstInfo->pDatatype      , pSrcInfo->pDatatype      , &pszString);
    _ppinfo_set_str(&pDstInfo->pParameters    , pSrcInfo->pParameters    , &pszString);

    // If a devmode exist, then it will need to be copied as well.
    //
    if (pSrcInfo->pDevMode != NULL) {

        memCopy((LPSTR *)&pDstInfo->pDevMode,
                (LPSTR)pSrcInfo->pDevMode,
                pSrcInfo->pDevMode->dmSize + pSrcInfo->pDevMode->dmDriverExtra,
                (LPSTR *)&pszString);

    } else {

        pDstInfo->pDevMode = NULL;
    }

    return pszString;
}

/*****************************************************************************\
* _ppinfo_build_level4 (Local Routine)
*
* Given a server name, a pointer to a source PRINTER_INFO_2
* structure, a destination PRINTER_INFO_5 structure and a pointer to
* the start of string storage space, fills the PRINTER_INFO_4 structure.
*
* Called by GetPrinter and EnumPrinters, level 2.  Returns an
* LPTSTR pointer to the last available data char in the data buffer.
*
\*****************************************************************************/
LPTSTR _ppinfo_build_level4(
    PPRINTER_INFO_2 pSrcInfo,
    PPRINTER_INFO_4 pDstInfo,
    LPTSTR          pszString)
{
    // Set non-string entries.
    //
    pDstInfo->Attributes = pSrcInfo->Attributes;


    // Copy the required data to the Win 32 PRINTER_INFO_4 structure.
    //
    _ppinfo_set_str(&pDstInfo->pPrinterName, pSrcInfo->pPrinterName, &pszString);
    _ppinfo_set_str(&pDstInfo->pServerName , pSrcInfo->pServerName , &pszString);

    return pszString;
}

/*****************************************************************************\
* _ppinfo_build_level5 (Local Routine)
*
* Given a server name, a pointer to a source PRINTER_INFO_2
* structure, a destination PRINTER_INFO_5 structure and a pointer to
* the start of string storage space, fills the PRINTER_INFO_5 structure.
*
* Called by GetPrinter and EnumPrinters, level 2.  Returns an
* LPTSTR pointer to the last available data char in the data buffer.
*
\*****************************************************************************/
LPTSTR _ppinfo_build_level5(
    PPRINTER_INFO_2 pSrcInfo,
    PPRINTER_INFO_5 pDstInfo,
    LPTSTR          pszString)
{
    // Set non-string entries.
    //
    pDstInfo->Attributes               = pSrcInfo->Attributes;
    pDstInfo->DeviceNotSelectedTimeout = 0;
    pDstInfo->TransmissionRetryTimeout = 0;


    // Copy the required data to the Win 32 PRINTER_INFO_5 structure.
    //
    _ppinfo_set_str(&pDstInfo->pPrinterName, pSrcInfo->pPrinterName, &pszString);
    _ppinfo_set_str(&pDstInfo->pPortName   , pSrcInfo->pPortName   , &pszString);

    return pszString;
}


/*****************************************************************************\
* _ppinfo_get_level1 (Local Routine)
*
* Given pInfo, a block of information on a printer returned by a
* DosPrintQGetInfo call, fill a PRINTER_INFO_1 structure.  Returns
* TRUE if successful, FALSE otherwise.  Places the number of bytes
* of (lpbBuffer) used in the DWORD pointed to by (pcbNeeded).
*
\*****************************************************************************/
BOOL _ppinfo_get_level1(
    PPRINTER_INFO_2 pSrcInfo,
    LPBYTE          lpbBuffer,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded)
{
    // Figure out how many bytes of buffer space we're going to need.
    // Set error code and return failure if we don't have enough.
    //
    *pcbNeeded = _ppinfo_calc_level1(pSrcInfo);

    if (*pcbNeeded > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }


    // Copy the required data from the structure to the Win32
    // structure.
    //
    _ppinfo_build_level1(pSrcInfo,
                         (PPRINTER_INFO_1)lpbBuffer,
                         ENDOFBUFFER(lpbBuffer, cbBuf));

    return TRUE;

}


/*****************************************************************************\
* _ppinfo_get_level2 (Local Routine)
*
* Given pInfo, a block of information on a printer returned by a
* PrintQGetInfo call, fill a PRINTER_INFO_2 structure.  Returns
* TRUE if successful, FALSE otherwise. Places the number of bytes of
* (lpbBuffer) used in the DWORD pointed to by (pcbNeeded).
*
\*****************************************************************************/
BOOL _ppinfo_get_level2(
    PPRINTER_INFO_2 pSrcInfo,
    LPBYTE          lpbBuffer,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded)
{
    // Figure out how many bytes of buffer space we're going to need.
    // Set error code and return failure if we don't have enough.
    //
    *pcbNeeded = _ppinfo_calc_level2(g_szEmptyString, pSrcInfo);

    if (*pcbNeeded > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Copy the required data to the Win 32 PRINTER_INFO_2 structure.
    //
    _ppinfo_build_level2(g_szEmptyString,
                         pSrcInfo,
                         (PPRINTER_INFO_2)lpbBuffer,
                         ENDOFBUFFER(lpbBuffer, cbBuf));

    return TRUE;
}

/*****************************************************************************\
* _ppinfo_get_level4 (Local Routine)
*
* Given pInfo, a block of information on a printer returned by a
* PrintQGetInfo call, fill a PRINTER_INFO_4 structure.  Returns
* TRUE if successful, FALSE otherwise. Places the number of bytes of
* (lpbBuffer) used in the DWORD pointed to by (pcbNeeded).
*
\*****************************************************************************/
BOOL _ppinfo_get_level4(
    PPRINTER_INFO_2 pSrcInfo,
    LPBYTE          lpbBuffer,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded)
{
    // Figure out how many bytes of buffer space we're going to need.
    // Set error code and return failure if we don't have enough.
    //
    *pcbNeeded = _ppinfo_calc_level4(pSrcInfo);

    if (*pcbNeeded > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Copy the required data to the Win 32 PRINTER_INFO_2 structure.
    //
    _ppinfo_build_level4(pSrcInfo,
                         (PPRINTER_INFO_4)lpbBuffer,
                         ENDOFBUFFER(lpbBuffer, cbBuf));

    return TRUE;
}


/*****************************************************************************\
* _ppinfo_get_level5 (Local Routine)
*
* Given pInfo, a block of information on a printer returned by a
* PrintQGetInfo call, fill a PRINTER_INFO_5 structure.  Returns
* TRUE if successful, FALSE otherwise. Places the number of bytes of
* (lpbBuffer) used in the DWORD pointed to by (pcbNeeded).
*
\*****************************************************************************/
BOOL _ppinfo_get_level5(
    PPRINTER_INFO_2 pSrcInfo,
    LPBYTE          lpbBuffer,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded)
{
    // Figure out how many bytes of buffer space we're going to need.
    // Set error code and return failure if we don't have enough.
    //
    *pcbNeeded = _ppinfo_calc_level5(pSrcInfo);

    if (*pcbNeeded > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Copy the required data to the Win 32 PRINTER_INFO_2 structure.
    //
    _ppinfo_build_level5(pSrcInfo,
                         (PPRINTER_INFO_5)lpbBuffer,
                         ENDOFBUFFER(lpbBuffer, cbBuf));

    return TRUE;
}

/*****************************************************************************\
* _ppinfo_enumprinters_NT (Local Routine)
*
* This is the WinNT specific routine for EnumPrinters.
*
*
\*****************************************************************************/
BOOL _ppinfo_enumprinters(
    DWORD   dwType,
    LPTSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned)
{
    BOOL bReturn = FALSE;


    // Throw back enumeration requests that we don't handle. The routing
    // layer above us is specifically looking for the ERROR_INVALID_NAME.
    //
    if (dwType & PRINTER_ENUM_NOTFORUS)
        goto enum_name_failure;


    // If the request is one that we handle, but the caller didn't supply
    // a printer name, we'll fail. Again, to keep things going as the
    // router expects, we must return an ERROR_INVALID_NAME condition.
    //
    if (utlStrSize(pszName) == 0) {

        if ((dwLevel == PRINT_LEVEL_1) && (dwType & PRINTER_ENUM_NAME)) {

            return _ppinfo_describe_provider((LPPRINTER_INFO_1)pPrinterEnum,
                                             cbBuf,
                                             pcbNeeded,
                                             pcbReturned);

        } else {

            goto enum_name_failure;
        }

    } else {

        if ((dwLevel == PRINT_LEVEL_1) && (dwType & PRINTER_ENUM_NAME)) {

            // In this case, the user has asked us to enumerate the
            // printers in some domain. Until we decide what we really want
            // to do.  We'll simply return success with an empty enumeration.
            //

            goto enum_empty_success;
        }
    }


    // Check Remote enumeration.  Remote enumeration valid only if
    // it's a level-1 printer.
    //
    if (dwType & PRINTER_ENUM_REMOTE) {

        if (dwLevel != PRINT_LEVEL_1) {

            goto enum_level_failure;

        } else {

            // In this case, the user has asked us to enumerate the
            // printers in our domain. Until we decide what we really
            // want to do, we'll simply return success with an empty
            // enumeration.
            //
            goto enum_empty_success;
        }

    } else if (dwType & PRINTER_ENUM_CONNECTIONS) {

        // In this case, the user has asked us to enumerate our favorite
        // connections.
        //

enum_empty_success:

        *pcbNeeded   = 0;
        *pcbReturned = 0;

        return TRUE;
    }


    DBG_MSG(DBG_LEV_INFO, (TEXT("Info: PPEnumPrinters: Type(%ld)  Name(%s)  Level(%ld)"), dwType, pszName, dwLevel));


    // Check print-levels.  These are error cases.  We should
    // really have performed the enumeration above.
    //
    switch (dwLevel) {

    case PRINT_LEVEL_1:
    case PRINT_LEVEL_2:

enum_name_failure:

        DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPEnumPrinters: Invalid Name")));
        SetLastError(ERROR_INVALID_NAME);
        break;

    default:

enum_level_failure:

        DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPEnumPrinters: Invalid Level: %d"), dwLevel));
        SetLastError(ERROR_INVALID_LEVEL);
        break;
    }

    return FALSE;
}

/*****************************************************************************\
* PPEnumPrinters
*
* Enumerates the available printers.  Returns TRUE if successful.  Otherwise,
* it returns FALSE.
*
* NOTE: Supports level 2 PRINTER_INFO to provide Point-and-Print
*       functionality.
*
\*****************************************************************************/
BOOL PPEnumPrinters(
    DWORD   dwType,
    LPTSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPEnumPrinters: Type(%d) Level(%d) Name(%s)"), dwType, dwLevel, (pszName ? pszName : TEXT("<NULL>"))));

    return _ppinfo_enumprinters(dwType,
                                pszName,
                                dwLevel,
                                pPrinterEnum,
                                cbBuf,
                                pcbNeeded,
                                pcbReturned);
}


/*****************************************************************************\
* PPGetPrinter
*
* Retrieves information about a printer. Returns TRUE if successful, FALSE
* if an error occurred. NOTE: Supports level 2 Printer_INFO to provide
* Point and Print functionality for Chicago.
*
\*****************************************************************************/
BOOL PPGetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  lpbPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    PCINETMONPORT   pIniPort;
    PPRINTER_INFO_2 pSrcInfo;
    DWORD           cbSrcSize;
    DWORD           dwTemp;
    BOOL            bResult = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPGetPrinter: Printer(%08lX) Level(%ld)"), hPrinter, dwLevel));

    if (pcbNeeded)
        *pcbNeeded = 0;

    semEnterCrit();

    // Make sure we have a valid printer handle.
    //
    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        if (pIniPort->BeginReadGetPrinterCache (&pSrcInfo)) {

            // Reformat the data according to the requested info Level.
            //
            switch (dwLevel) {

            case PRINT_LEVEL_1:
                bResult = _ppinfo_get_level1(pSrcInfo, lpbPrinter, cbBuf, pcbNeeded);
                break;

            case PRINT_LEVEL_2:
                bResult = _ppinfo_get_level2(pSrcInfo, lpbPrinter, cbBuf, pcbNeeded);
                break;

            case PRINT_LEVEL_4:
                bResult = _ppinfo_get_level4(pSrcInfo, lpbPrinter, cbBuf, pcbNeeded);
                break;

            case PRINT_LEVEL_5:
                bResult = _ppinfo_get_level5(pSrcInfo, lpbPrinter, cbBuf, pcbNeeded);
                break;

            default:
                DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPGetPrinter: Invalid Level")));
                SetLastError(ERROR_INVALID_LEVEL);
                bResult = FALSE;
                break;
            }


        }

        pIniPort->EndReadGetPrinterCache ();

        if (GetLastError() == ERROR_ACCESS_DENIED) {
            pIniPort->InvalidateGetPrinterCache ();
        }
    }

    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        pcbNeeded &&
        *pcbNeeded == 0) {
        // We can't set ERROR_INSUFFICIENT_BUFFER here since it was an internal error
        // and we are not reporting a size
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }


    semLeaveCrit();

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\othercon.cxx ===
/*****************************************************************************\
* MODULE: iecon.cxx
*
* The module contains class for connections using IE's default configuration
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   07/31/98    Weihaic     Created
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"

const DWORD cdwDialogTimeout = 4000000;


COtherConnection::COtherConnection (
    BOOL bSecure,
    INTERNET_PORT nServerPort,
    LPCTSTR lpszUserName,
    LPCTSTR lpszPassword,
    BOOL bIgnoreSecurityDlg):
    CAnyConnection (bSecure, nServerPort, bIgnoreSecurityDlg, AUTH_OTHER)
{
    m_bValid = AssignString (m_lpszUserName, lpszUserName) &&
               AssignString (m_lpszPassword, lpszPassword);
}

COtherConnection::~COtherConnection ()
{
}

HINTERNET
COtherConnection::OpenRequest (
    LPTSTR lpszUrl)
{
    return CAnyConnection::OpenRequest (lpszUrl);
}

BOOL
COtherConnection::SendRequest(
    HINTERNET      hReq,
    LPCTSTR        lpszHdr,
    DWORD          cbHdr,
    LPBYTE         pidi)
{
    static const DWORD dwMaxRetry = 2;

    BOOL    bRet = FALSE;
    DWORD   i;

    HANDLE hToken;


    //
    //  We have to revert to the local system account to prevent wininet from sending
    //  the logon user credential automatically to the remote machine.
    //

    if (hToken = RevertToPrinterSelf()) {

        for (i = 0; i < dwMaxRetry; i++ ) {

            if (SetPassword (hReq, m_lpszUserName, m_lpszPassword)) {

                bRet = CAnyConnection:: SendRequest (hReq,
                                                    lpszHdr,
                                                    cbHdr,
                                                    pidi);

                if (bRet || GetLastError () != ERROR_ACCESS_DENIED) {
                    break;
                }
            }
        }

        if (!ImpersonatePrinterClient(hToken)) {
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL
COtherConnection::SendRequest(
    HINTERNET      hReq,
    LPCTSTR        lpszHdr,
    CStream        *pStream)
{
    static const DWORD dwMaxRetry = 2;

    BOOL    bRet = FALSE;
    DWORD   i;

    HANDLE hToken;


    //
    //  We have to revert to the local system account to prevent wininet from sending
    //  the logon user credential automatically to the remote machine.
    //

    if (hToken = RevertToPrinterSelf()) {

        for (i = 0; i < dwMaxRetry; i++ ) {

            if (SetPassword (hReq, m_lpszUserName, m_lpszPassword)) {

                bRet = CAnyConnection:: SendRequest (hReq,
                                                     lpszHdr,
                                                     pStream);

                if (bRet || GetLastError () != ERROR_ACCESS_DENIED) {
                    break;
                }
            }
        }

        if (!ImpersonatePrinterClient(hToken)) {
            bRet = FALSE;
        }
    }

    return bRet;
}



BOOL
COtherConnection::ReadFile (
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd)
{
    BOOL bRet = FALSE;
    HANDLE hToken;

    if (hToken = RevertToPrinterSelf()) {

        bRet = CAnyConnection::ReadFile (hReq, lpvBuffer, cbBuffer, lpcbRd);

        if (!ImpersonatePrinterClient(hToken)) {
            bRet = FALSE;
        }
    }

    return bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ping.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ping.c

Abstract:

    Packet INternet Groper utility for TCP/IP.

Author:

    Numerous TCP/IP folks.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    WeihaiC     5-Dec-98.   Moved from \nt\private\net\sockets\tcpcmd\ping
    MohsinA,    21-Oct-96.  INADDR_NONE check to avoid broadcast.
    MohsinA,    13-Nov-96.  Max packet size < 64K.

Notes:

--*/

//:ts=4
typedef unsigned long   ULONG;
typedef unsigned short  ushort;
typedef unsigned int    UINT;
typedef unsigned char   UCHAR;

#include "precomp.h"
#include "icmpapi.h"

#define NOGDI
#define NOMINMAX


#define MAX_BUFFER_SIZE       (sizeof(ICMP_ECHO_REPLY) + 0xfff7 + MAX_OPT_SIZE)
#define DEFAULT_BUFFER_SIZE         (0x2000 - 8)
#define DEFAULT_SEND_SIZE           32
#define DEFAULT_COUNT               4
#define DEFAULT_TTL                 32
#define DEFAULT_TOS                 0
#define DEFAULT_TIMEOUT             5000L
#define MIN_INTERVAL                1000L
#define TRUE                        1
#define FALSE                       0
#define STDOUT                      1

#define net_long(x) (((((ULONG)(x))&0xffL)<<24) | \
                     ((((ULONG)(x))&0xff00L)<<8) | \
                     ((((ULONG)(x))&0xff0000L)>>8) | \
                     ((((ULONG)(x))&0xff000000L)>>24))

WSADATA WsaData;


// ========================================================================
// Caveat: return 0 for invalid, else internet address.
//         I would prefer -1 for error. - MohsinA, 21-Nov-96.

unsigned long
get_pingee(char *ahstr, char **hstr, int *was_inaddr, int dnsreq)
{
        struct hostent *hostp = NULL;
        long            inaddr;

        if( strcmp( ahstr, "255.255.255.255" ) == 0 ){
            return 0L;
        }

        if ((inaddr = inet_addr(ahstr)) == -1L) {
            hostp = gethostbyname(ahstr);
            if (hostp) {
                /*
                 * If we find a host entry, set up the internet address
                 */
                inaddr = *(long *)hostp->h_addr;
                *was_inaddr = 0;
            } else {
                // Neither dotted, not name.
                return(0L);
            }

        } else {
            // Is dotted.
            *was_inaddr = 1;
            if (dnsreq == 1) {
                hostp = gethostbyaddr((char *)&inaddr,sizeof(inaddr),AF_INET);
            }
        }

        *hstr = hostp ? hostp->h_name : (char *)NULL;
        return(inaddr);
}




// ========================================================================

BOOL Ping (LPTSTR pszServerName)
{
    UINT    i;
    int     found_addr = 0;
    int     dnsreq = 0;
    char    *hostname = NULL;
    int     was_inaddr;
    DWORD   numberOfReplies;
    UINT    Count = DEFAULT_COUNT;
    UCHAR   TTL = DEFAULT_TTL;
    UCHAR FAR  *Opt = (UCHAR FAR *)0;         // Pointer to send options
    UINT    OptLength = 0;
    int     OptIndex = 0;               // Current index into SendOptions
    int     SRIndex = -1;               // Where to put address, if source routing
    UCHAR   TOS = DEFAULT_TOS;
    UCHAR   Flags = 0;
    ULONG   Timeout = DEFAULT_TIMEOUT;
    IP_OPTION_INFORMATION SendOpts;
    int     EndOffset;
    DWORD   errorCode;
    HANDLE  IcmpHandle = NULL;
    struct in_addr addr;
    PICMP_ECHO_REPLY  reply;
    BOOL    sourceRouting = FALSE;
    char    *SendBuffer = NULL;
    char    *RcvBuffer = NULL;
    UINT    RcvSize;
    UINT    SendSize = DEFAULT_SEND_SIZE;
    BOOL    bRet = FALSE;
    IPAddr  address = 0;   // was local to main earlier.
    char    *arg;

    // ====================================================================

#ifdef UNICODE

    LPSTR pszAnsiServerName = NULL;
    DWORD uSize;

    if (pszServerName && (uSize = WideCharToMultiByte(CP_ACP,
                                                      0,
                                                      pszServerName,
                                                      -1,
                                                      NULL,
                                                      0,
                                                      NULL,
                                                      NULL))) {

        if (pszAnsiServerName = (LPSTR) LocalAlloc(LPTR, uSize)) {
            if (!WideCharToMultiByte (CP_ACP,
                                      0,
                                      pszServerName,
                                      -1,
                                      pszAnsiServerName,
                                      uSize,
                                      NULL,
                                      NULL))

                goto CleanUp;

        }
        else
            goto CleanUp;

    }

    arg = pszAnsiServerName;

#else
    arg = pszServerName;
#endif


    if (WSAStartup( 0x0101, &WsaData))
        goto CleanUp;

    // Added check for INADDR_NONE, MohsinA, 21-Oct-96.

    address = get_pingee(arg, &hostname, &was_inaddr, dnsreq);
    if(!address || (address == INADDR_NONE) ){
        SetLastError (DNS_ERROR_INVALID_IP_ADDRESS);
        goto CleanUp;
    }

    IcmpHandle = IcmpCreateFile();

    if (IcmpHandle == INVALID_HANDLE_VALUE) {
        goto CleanUp;
    }

    if (! (SendBuffer = (char *) LocalAlloc(LMEM_FIXED, SendSize))) {
        goto CleanUp;
    }

    //
    // Calculate receive buffer size and try to allocate it.
    //
    if (SendSize <= DEFAULT_SEND_SIZE) {
        RcvSize = DEFAULT_BUFFER_SIZE;
    }
    else {
        RcvSize = MAX_BUFFER_SIZE;
    }

    if (! (RcvBuffer = (char *)LocalAlloc(LMEM_FIXED, RcvSize))) {
        goto CleanUp;
    }

    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < SendSize; i++) {
        SendBuffer[i] = 'a' + (i % 23);
    }

    //
    // Initialize the send options
    //
    SendOpts.OptionsData = Opt;
    SendOpts.OptionsSize = (UCHAR)OptLength;
    SendOpts.Ttl         = TTL;
    SendOpts.Tos         = TOS;
    SendOpts.Flags       = Flags;

    addr.s_addr = address;

    numberOfReplies = IcmpSendEcho(IcmpHandle,
                                   address,
                                   SendBuffer,
                                   (unsigned short) SendSize,
                                   &SendOpts,
                                   RcvBuffer,
                                   RcvSize,
                                   Timeout);

    if (numberOfReplies == 0) {

        errorCode = GetLastError();

        goto CleanUp;
    }
    else {

        reply = (PICMP_ECHO_REPLY) RcvBuffer;

        while (numberOfReplies--) {

            if (reply->Status == IP_SUCCESS) {

                bRet = TRUE;
                break;
            }

            reply++;
        }
    }

CleanUp:

#ifdef UNICODE
    if (pszAnsiServerName) {
        LocalFree(pszAnsiServerName);
    }
#endif

    if (IcmpHandle) {
        IcmpCloseHandle(IcmpHandle);
    }

    if (SendBuffer) {
        LocalFree(SendBuffer);
    }

    if (RcvBuffer) {
        LocalFree(RcvBuffer);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ppinit.cxx ===
/*****************************************************************************\
* MODULE: ppinit.c
*
* This module contains the initialization routines for the Print-Provider.
* The spooler calls InitializePrintProvider() to retreive the list of
* calls that the Print-Processor supports.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


/*****************************************************************************\
* _init_provider_worker (Local Routine)
*
*
\*****************************************************************************/
void _init_provider_worker ()
{
    // Get the default spool directory

    HANDLE  hServer = NULL;
    DWORD   dwType = REG_SZ;
    DWORD   cbSize = MAX_PATH * sizeof (TCHAR);


    g_szDefSplDir[0] = 0;

    semEnterCrit ();

    if (OpenPrinter (NULL, &hServer, NULL)) {

        if (ERROR_SUCCESS != GetPrinterData (hServer,
                                             SPLREG_DEFAULT_SPOOL_DIRECTORY,
                                             &dwType,
                                             (LPBYTE) g_szDefSplDir,
                                             cbSize,
                                             &cbSize)) {
        }

        ClosePrinter (hServer);

    }

    SplClean ();

    semLeaveCrit ();
}

/*****************************************************************************\
* _init_write_displayname (Local Routine)
*
*
\*****************************************************************************/
BOOL _init_write_displayname(VOID)
{
    LONG  lRet;
    HKEY  hkPath;
    DWORD dwType;
    DWORD cbSize;

    if (!LoadString (g_hInst,
                     IDS_DISPLAY_NAME,
                     g_szDisplayStr,
                     MAX_PATH)) {
        g_szDisplayStr[0] = 0;
    }

    // Open the key to the Print-Providor.
    //
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        g_szRegProvider,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkPath);

    if (lRet == ERROR_SUCCESS) {

        // Look for the "displayname".  If it doesn't exist, then write it.
        //
        dwType = REG_SZ;
        cbSize = 0;

        lRet = RegQueryValueEx(hkPath,
                               g_szDisplayName,
                               NULL,
                               &dwType,
                               (LPBYTE)NULL,
                               &cbSize);

        // Write the string.
        //
        if ((lRet != ERROR_SUCCESS) || (cbSize == 0)) {

            dwType = REG_SZ;
            cbSize = (lstrlen(g_szDisplayStr) + 1) * sizeof(TCHAR);

            lRet = RegSetValueEx(hkPath,
                                 g_szDisplayName,
                                 0,
                                 dwType,
                                 (LPBYTE)g_szDisplayStr,
                                 cbSize);
        }

        RegCloseKey(hkPath);
    }

    if (lRet != ERROR_SUCCESS) {
        SetLastError (lRet);
        return FALSE;
    }
    else
        return TRUE;
}


/*****************************************************************************\
* _init_find_filename (Local Routine)
*
*
\*****************************************************************************/
LPTSTR _init_find_filename(
   LPCTSTR lpszPathName)
{
   LPTSTR lpszFileName;

   if (lpszPathName == NULL)
      return NULL;


   // Look for the filename in the path, by starting at the end
   // and looking for the ('\') char.
   //
   if (!(lpszFileName = utlStrChrR(lpszPathName, TEXT('\\'))))
      lpszFileName = (LPTSTR)lpszPathName;
   else
      lpszFileName++;

   return lpszFileName;
}


/*****************************************************************************\
* _init_load_netapi (Local Routine)
*
* Initialize INET API pointers.
*
\*****************************************************************************/
BOOL _init_load_netapi(VOID)
{
    g_pfnHttpQueryInfo         = (PFNHTTPQUERYINFO)        HttpQueryInfoA;
    g_pfnInternetOpenUrl       = (PFNINTERNETOPENURL)      InternetOpenUrlA;
    g_pfnInternetErrorDlg      = (PFNINTERNETERRORDLG)     InternetErrorDlg;
    g_pfnHttpSendRequest       = (PFNHTTPSENDREQUEST)      HttpSendRequestA;
    g_pfnHttpSendRequestEx     = (PFNHTTPSENDREQUESTEX)    HttpSendRequestExA;
    g_pfnInternetReadFile      = (PFNINTERNETREADFILE)     InternetReadFile;
    g_pfnInternetWriteFile     = (PFNINTERNETWRITEFILE)    InternetWriteFile;
    g_pfnInternetCloseHandle   = (PFNINTERNETCLOSEHANDLE)  InternetCloseHandle;
    g_pfnInternetOpen          = (PFNINTERNETOPEN)         InternetOpenA;
    g_pfnInternetConnect       = (PFNINTERNETCONNECT)      InternetConnectA;
    g_pfnHttpOpenRequest       = (PFNHTTPOPENREQUEST)      HttpOpenRequestA;
    g_pfnHttpAddRequestHeaders = (PFNHTTPADDREQUESTHEADERS)HttpAddRequestHeadersA;
    g_pfnHttpEndRequest        = (PFNHTTPENDREQUEST)       HttpEndRequestA;
    g_pfnInternetSetOption     = (PFNINTERNETSETOPTION)    InternetSetOptionA;
    return TRUE;
}


/*****************************************************************************\
* _init_load_provider (Local Routine)
*
* This performs the startup initialization for the print-provider.
*
\*****************************************************************************/
BOOL _init_load_provider()
{
    LPTSTR lpszFileName;
    TCHAR  szBuf[MAX_PATH];
    DWORD  i = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL bRet = FALSE;


    // Get the module name for this process.
    //
    if (!GetModuleFileName(NULL, szBuf, MAX_PATH))
        goto exit_load;


    // Get the filename from the full module-name. and check that
    // it's the spooler.
    //
    if (lpszFileName = _init_find_filename(szBuf)) {

        if (lstrcmpi(lpszFileName, g_szProcessName) == 0) {

            // Initialize the computer name.
            //
            if (!GetComputerName(g_szMachine, &i))
                goto exit_load;

            // Initialize the internet API pointers.
            //
            if (_init_load_netapi() == FALSE)
                goto exit_load;

            //
            // Assume success.
            //
            bRet = TRUE;

            //
            // Try and initialize the crit-sect for synchronizing port access.
            //
            __try {
                InitializeCriticalSection(&g_csMonitorSection);
            }
            __except (1) {
                bRet = FALSE;
                SetLastError (ERROR_INVALID_HANDLE);
            }

            return bRet;
        }
    }

exit_load:

    return bRet;
}

/*****************************************************************************\
* _init_load_ports (Local Routine)
*
* This performs the port initialization for the print-provider.
*
\*****************************************************************************/
BOOL _init_load_ports(
    LPTSTR lpszRegPath)
{
    LONG  lStat;
    HKEY  hkPath;
    HKEY  hkPortNames;
    TCHAR szPortName[MAX_PATH];
    BOOL  bRet = FALSE;
    LPTSTR pEnd = NULL;
    size_t uSize = 0;

    //
    // Make sure there is a registry-path pointing to the
    // INET provider entry.
    //
    if (lpszRegPath == NULL)
        return FALSE;

    //
    // Copy the string to global-memory.  We will need this if we require
    // the need to write to the registry when creating new ports.
    //
    uSize = 1 + lstrlen (lpszRegPath);

    if (! (g_szRegProvider = (LPTSTR) memAlloc (uSize * sizeof (TCHAR)))) {
        return FALSE;
    }

    StringCchCopy(g_szRegProvider, uSize, lpszRegPath);

    //
    // Copy the registry key of all the printer providers
    //
    if (! (g_szRegPrintProviders = (LPTSTR) memAlloc (uSize * sizeof (TCHAR)))) {
        return FALSE;
    }

    StringCchCopy(g_szRegPrintProviders, uSize, lpszRegPath);

    pEnd = wcsrchr (g_szRegPrintProviders, L'\\');

    if ( pEnd )
    {
        *pEnd = 0;
    }

    // Open registry key for Provider-Name.
    //
    lStat = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszRegPath, 0, KEY_READ, &hkPath);

    if (lStat == ERROR_SUCCESS) {

        bRet = TRUE;

        // Open the "ports" key for enumeration of the ports. We need to
        // build up this list at the provider initialization time so that
        // we can return the list of ports if called to EnumPorts().
        //
        lStat = RegOpenKeyEx(hkPath, g_szRegPorts, 0, KEY_READ, &hkPortNames);

        if (lStat == ERROR_SUCCESS) {

            DWORD dwSize;
            DWORD i = 0;

            while (lStat == ERROR_SUCCESS) {

                dwSize = sizeof(szPortName) / sizeof (TCHAR);

                lStat = RegEnumKey (hkPortNames,
                                    i,
                                    szPortName,
                                    dwSize);

                if (lStat == ERROR_SUCCESS) {

                    // Do not short-cut this call to InetmonAddPort(),
                    // as this will leave the crit-sect unprotected.
                    //
                    PPAddPort(szPortName, NULL, NULL);
                }

                i++;
            }

            RegCloseKey(hkPortNames);

        } else {

            DBG_MSG(DBG_LEV_INFO, (TEXT("RegOpenKeyEx(%s) failed: Error = %lu"), g_szRegPorts, lStat));
            SetLastError(lStat);
        }

        RegCloseKey(hkPath);

    } else {

        DBG_MSG(DBG_LEV_WARN, (TEXT("RegOpenKeyEx(%s) failed: Error = %lu"), lpszRegPath, lStat));
        SetLastError(lStat);
    }

    return bRet;
}

/*****************************************************************************\
* _init_create_sync (Local Routine)
*
* This creates the events and Critical Section needed for handling the synchronisation
* in the monitor.
*
\*****************************************************************************/
_inline BOOL _init_create_sync(VOID)
{
    BOOL bRet = TRUE;

    g_dwConCount  = 0;

    __try {
        InitializeCriticalSection(&g_csCreateSection);
    }
    __except (1) {
        bRet = FALSE;
        SetLastError (ERROR_INVALID_HANDLE);
    }

    if (bRet) {

        g_eResetConnections = CreateEvent( NULL, TRUE, TRUE, NULL );

        if (g_eResetConnections == NULL)
            bRet = FALSE;
    }

    return bRet;
}

/*****************************************************************************\
* InitializePrintProvider (API)
*
* The spooler calls this routine to initialize the Print-Provider.  The list
* of functions in the table are passed back to the spooler for it to use
* when interfacing with the provider.
*
\*****************************************************************************/
static PRINTPROVIDOR pfnPPList[] = {

    PPOpenPrinter,
    PPSetJob,
    PPGetJob,
    PPEnumJobs,
    stubAddPrinter,
    stubDeletePrinter,
    PPSetPrinter,
    PPGetPrinter,
    PPEnumPrinters,
    stubAddPrinterDriver,
    stubEnumPrinterDrivers,
    stubGetPrinterDriver,
    stubGetPrinterDriverDirectory,
    stubDeletePrinterDriver,
    stubAddPrintProcessor,
    stubEnumPrintProcessors,
    stubGetPrintProcessorDirectory,
    stubDeletePrintProcessor,
    stubEnumPrintProcessorDatatypes,
    PPStartDocPrinter,
    PPStartPagePrinter,
    PPWritePrinter,
    PPEndPagePrinter,
    PPAbortPrinter,
    stubReadPrinter,
    PPEndDocPrinter,
    PPAddJob,
    PPScheduleJob,
    stubGetPrinterData,
    stubSetPrinterData,
    stubWaitForPrinterChange,
    PPClosePrinter,
    stubAddForm,
    stubDeleteForm,
    stubGetForm,
    stubSetForm,
    stubEnumForms,
    stubEnumMonitors,
    PPEnumPorts,
    stubAddPort,
    NULL,
    NULL,
    stubCreatePrinterIC,
    stubPlayGdiScriptOnPrinterIC,
    stubDeletePrinterIC,
    stubAddPrinterConnection,
    stubDeletePrinterConnection,
    stubPrinterMessageBox,
    stubAddMonitor,
    stubDeleteMonitor,
    NULL,   // stubResetPrinter,
    NULL,   // stubGetPrinterDriverEx should not be called as specified in spoolss\dll\nullpp.c
    PPFindFirstPrinterChangeNotification,
    PPFindClosePrinterChangeNotification,
    NULL,   // stubAddPortEx,
    NULL,   // stubShutDown,
    NULL,   // stubRefreshPrinterChangeNotification,
    NULL,   // stubOpenPrinterEx,
    NULL,   // stubAddPrinterEx,
    NULL,   // stubSetPort,
    NULL,   // stubEnumPrinterData,
    NULL,   // stubDeletePrinterData,
    NULL,   // fpClusterSplOpen
    NULL,   // fpClusterSplClose
    NULL,   // fpClusterSplIsAlive
    NULL,   // fpSetPrinterDataEx
    NULL,   // fpGetPrinterDataEx
    NULL,   // fpEnumPrinterDataEx
    NULL,   // fpEnumPrinterKey
    NULL,   // fpDeletePrinterDataEx
    NULL,   // fpDeletePrinterKey
    NULL,   // fpSeekPrinter
    NULL,   // fpDeletePrinterDriverEx
    NULL,   // fpAddPerMachineConnection
    NULL,   // fpDeletePerMachineConnection
    NULL,   // fpEnumPerMachineConnections
    PPXcvData,   // fpXcvData
    NULL,   // fpAddPrinterDriverEx
    NULL,   // fpSplReadPrinter
    NULL,   // fpDriverUnloadComplete
    NULL,   // fpGetSpoolFileInfo
    NULL,   // fpCommitSpoolData
    NULL,   // fpCloseSpoolFileHandle
    NULL,   // fpFlushPrinter
    NULL,   // fpSendRecvBidiData
    NULL,   // fpAddDriverCatalog
};

BOOL WINAPI InitializePrintProvidor(
    LPPRINTPROVIDOR pPP,
    DWORD           cEntries,
    LPWSTR          pszFullRegistryPath)
{
    HANDLE hThread;
    DWORD dwThreadId;

    g_pcsEndBrowserSessionLock = new CCriticalSection ();

    if (!g_pcsEndBrowserSessionLock || g_pcsEndBrowserSessionLock->bValid () == FALSE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (_init_load_provider() == FALSE) {
        DBG_ASSERT(FALSE, (TEXT("Assert: Failed module initialization")));
        return FALSE;
    }

    if (!pszFullRegistryPath || !*pszFullRegistryPath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    gpInetMon = new CInetMon;

    if (!gpInetMon || gpInetMon->bValid() == FALSE) {

        if (gpInetMon) {
            delete gpInetMon;
        }

        return FALSE;
    }

    if (gpInetMon && !gpInetMon->bValid ()) {
        delete gpInetMon;

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: InitializePrintProvidor")));

    memcpy(pPP, pfnPPList, min(sizeof(pfnPPList), (int)cEntries));

    // Initialise synchronisation objects

    if (!_init_create_sync())
        return FALSE;

    g_bUpgrade = SplIsUpgrade();

    if (_init_load_ports((LPTSTR)pszFullRegistryPath) == FALSE) {
        DBG_ASSERT(FALSE, (TEXT("Assert: Failed port initialization")));
        return FALSE;
    }


    if (!_init_write_displayname())
        return FALSE;


    if (hThread = CreateThread (NULL,
                                0,
                                (LPTHREAD_START_ROUTINE) _init_provider_worker,
                                NULL,
                                0,
                                &dwThreadId)) {
        CloseHandle (hThread);
        return TRUE;
    }
    else
        return FALSE;
}


/*****************************************************************************\
* DllMain
*
* This is the main entry-point for the library.
*
\*****************************************************************************/
extern "C"
BOOL WINAPI DllMain(
    HINSTANCE hInstDll,
    DWORD     dwAttach,
    LPVOID    lpcReserved)
{
    switch (dwAttach)
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hInstDll;
        DisableThreadLibraryCalls(hInstDll);
        break;

    case DLL_PROCESS_DETACH:
        DeleteCriticalSection(&g_csCreateSection);
        DeleteCriticalSection(&g_csMonitorSection);
        CloseHandle(g_eResetConnections);
        delete g_pcsEndBrowserSessionLock;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Weihai Chen (WeihaiC)  30-Mar-2000

Environment:

    User Mode -Win32

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <winspool.h>

#include <wininet.h>
#include <tchar.h>
#include <mdcommsg.h>

#include <stdlib.h>
#include <winsock.h>
#include <minmax.h>

#include <ipexport.h>

#include <lmcons.h>
#include <lmapibuf.h>

#include <strsafe.h>
#include <splcom.h>

#include <winsplp.h>
#include <NCshared.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ppport.h ===
/*****************************************************************************\
* MODULE: ppport.h
*
* Prototypes for private funcions in ppport.c.  These functions handle port
* related calls.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   18-Nov-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _PPPORT_H
#define _PPPORT_H

BOOL PPEnumPorts(
    LPTSTR  lpszServerName,
    DWORD   dwLevel,
    LPBYTE  pbPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeed,
    LPDWORD pcbRet);

BOOL PPDeletePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName);

BOOL PPAddPort(
    LPTSTR lpszPortName,
    HWND   hWnd,
    LPTSTR lpszMonitorName);

BOOL PPConfigurePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ppjobs.h ===
/*****************************************************************************\
* MODULE: ppjobs.h
*
* Header file for print-job routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _PPJOBS_H
#define _PPJOBS_H


BOOL PPEnumJobs(
    HANDLE  hPrinter,
    DWORD   nJobStart,
    DWORD   cJobs,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   cbJob,
    LPDWORD pcbNeeded,
    LPDWORD pcItems);

BOOL PPGetJob(
    HANDLE  hPrinter,
    DWORD   idJob,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   cbJob,
    LPDWORD pcbNeed);

BOOL PPSetJob(
    HANDLE hPrinter,
    DWORD  dwJobId,
    DWORD  dwLevel,
    LPBYTE pbJob,
    DWORD  dwCommand);

BOOL PPAddJob(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

BOOL PPScheduleJob(
    HANDLE hPrinter,
    DWORD  idJob);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\priv.h ===
/*****************************************************************************\
* MODULE: priv.h
*
* Private header for the Print-Processor library.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "spllib.hxx"
#include "inetlib.h"

#include "common.h"
#include "inetxcv.h"

#include "sid.h"
#include "anonycon.hxx"
#include "anycon.hxx"
#include "cachemgr.hxx"
#include "lusrdata.hxx"
#include "ntcon.hxx"
#include "othercon.hxx"
#include "portmgr.hxx"
#include "pusrdata.hxx"
#include "userdata.hxx"

#include "spljob.h"
#include "splpjm.h"
#include "ppjobs.h"
#include "inetport.h"
#include "inetpp.h"
#include "globals.h"
#include "debug.h"
#include "basicsec.h"
#include "mem.h"
#include "sem.h"
#include "util.h"
#include "stubs.h"
#include "inetwrap.h"
#include "ppinfo.h"
#include "ppport.h"
#include "ppprn.h"
#include "xcv.h"
#include "ppchange.h"
#include "stream.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ppjobs.cxx ===
/*****************************************************************************\
* MODULE: ppjobs.c
*
* This module contains the print-job manipulating routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

BOOL
_ppprn_end_docprinter_async (
    PCINETMONPORT       pIniPort,
    PJOBMAP             pjmJob);

typedef struct _ADDJOB_INFO_2W {
    LPWSTR    pData;
    DWORD     JobId;
} ADDJOB_INFO_2W, *PADDJOB_INFO_2W, *LPADDJOB_INFO_2W;


DWORD
ppjob_GetOneSize (
    DWORD dwLevel)
{
    DWORD cbIdx;

    switch (dwLevel) {
    case PRINT_LEVEL_1:
        cbIdx = sizeof(JOB_INFO_1);
        break;
    case PRINT_LEVEL_2:
        cbIdx = sizeof(JOB_INFO_2);
        break;
    case PRINT_LEVEL_3:
        cbIdx = sizeof(JOB_INFO_3);
        break;
    }
    return cbIdx;
}
/*****************************************************************************\
* ppjob_IppPrtRsp (Local Routine)
*
* Retrieves a get response from the IPP server.  Our (pjmJob) in the
* parameter list references a job-entry.
*
\*****************************************************************************/
BOOL CALLBACK ppjob_IppPrtRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hJobReq,
    PCINETMONPORT   pIniPort,
    PJOBMAP         pjmJob)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_JOB lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_PRINTJOB)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile ( pConnection, hJobReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (bRet = lpRsp->bRet) {

                        // Set the remote-job-id to the job-entry.  This
                        // entry was added at the time the spool-job-file
                        // was created.
                        //
                        semEnterCrit();
                        pjmSetJobRemote(pjmJob, lpRsp->ji.ji2.JobId, lpRsp->ji.ipp.pJobUri);
                        semLeaveCrit();

                    } else {

                        // If the job failed to open on the server, then
                        // we will set the last-error from the server
                        // response.
                        //
                        SetLastError(lpRsp->dwLastError);
                    }

                    WebIppFreeMem(lpRsp);

                    goto EndPrtRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //
                    break;

                default:
                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppjob_IppPrtRsp : Receive Data Error")));
                    SetLastError(ERROR_INVALID_DATA);

                    goto EndPrtRsp;
                }

            } else {

                goto EndPrtRsp;
            }
        }

EndPrtRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}



/*****************************************************************************\
* ppjob_GetJobSize (Local Routine)
*
* Returns the size necessary to hold the jobinfo.
*
\*****************************************************************************/
DWORD ppjob_GetJobSize(
    LPJOB_INFO_2 pji2,
    DWORD        dwLevel)
{
    DWORD cbSize;


    switch (dwLevel) {

    case PRINT_LEVEL_1:

        cbSize = sizeof(JOB_INFO_1)             +
                 utlStrSize(pji2->pPrinterName) +
                 utlStrSize(pji2->pMachineName) +
                 utlStrSize(pji2->pUserName)    +
                 utlStrSize(pji2->pDocument)    +
                 utlStrSize(pji2->pDatatype)    +
                 utlStrSize(pji2->pStatus);
        break;

    case PRINT_LEVEL_2:

        cbSize = sizeof(JOB_INFO_2)                +
                 utlStrSize(pji2->pPrinterName)    +
                 utlStrSize(pji2->pMachineName)    +
                 utlStrSize(pji2->pUserName)       +
                 utlStrSize(pji2->pDocument)       +
                 utlStrSize(pji2->pNotifyName)     +
                 utlStrSize(pji2->pDatatype)       +
                 utlStrSize(pji2->pPrintProcessor) +
                 utlStrSize(pji2->pParameters)     +
                 utlStrSize(pji2->pDriverName)     +
                 utlStrSize(pji2->pStatus);

        if (pji2->pDevMode)
            cbSize += (pji2->pDevMode->dmSize + pji2->pDevMode->dmDriverExtra);

        cbSize = (cbSize + sizeof(DWORD)-1) & ~(sizeof(DWORD)-1);

        break;

    case PRINT_LEVEL_3:
        cbSize = sizeof(JOB_INFO_3);
        break;

    default:
        cbSize = 0;
        break;
    }

    return cbSize;
}


/*****************************************************************************\
* ppjob_CopyJob (Local Routine)
*
* Copies a job-info structure to another.
*
\*****************************************************************************/
LPBYTE ppjob_CopyJob(
    LPBYTE       pbJobDst,
    DWORD        dwLevel,
    LPJOB_INFO_2 pji2Src,
    LPBYTE       pbEnd)
{
    LPJOB_INFO_1 pji1Dst;
    LPJOB_INFO_2 pji2Dst;
    LPJOB_INFO_3 pji3Dst;
    LPJOBMAP     pjm;
    LPDWORD      pOffsets;
    DWORD        cbDM;
    LPTSTR*      lpszSrc;
    LPTSTR       aszSrc[(sizeof(JOB_INFO_2) / sizeof(LPTSTR))];

    static DWORD s_JI1Offsets[] = {

        offsetof(LPJOB_INFO_1, pPrinterName),
        offsetof(LPJOB_INFO_1, pMachineName),
        offsetof(LPJOB_INFO_1, pUserName),
        offsetof(LPJOB_INFO_1, pDocument),
        offsetof(LPJOB_INFO_1, pDatatype),
        offsetof(LPJOB_INFO_1, pStatus),
        0xFFFFFFFF
    };

    static DWORD s_JI2Offsets[] = {

        offsetof(LPJOB_INFO_2, pPrinterName),
        offsetof(LPJOB_INFO_2, pMachineName),
        offsetof(LPJOB_INFO_2, pUserName),
        offsetof(LPJOB_INFO_2, pDocument),
        offsetof(LPJOB_INFO_2, pNotifyName),
        offsetof(LPJOB_INFO_2, pDatatype),
        offsetof(LPJOB_INFO_2, pPrintProcessor),
        offsetof(LPJOB_INFO_2, pParameters),
        offsetof(LPJOB_INFO_2, pDriverName),
        offsetof(LPJOB_INFO_2, pDevMode),
        offsetof(LPJOB_INFO_2, pStatus),
        offsetof(LPJOB_INFO_2, pSecurityDescriptor),
        0xFFFFFFFF
    };

    static DWORD s_JI3Offsets[]={0xFFFFFFFF};


    // Set the start of the string-buffer.
    //
    ZeroMemory(aszSrc, sizeof(aszSrc));
    lpszSrc = aszSrc;


    // Process the appropriate structure.
    //
    switch (dwLevel) {

    case PRINT_LEVEL_1:

        pji1Dst  = (LPJOB_INFO_1)pbJobDst;
        pOffsets = s_JI1Offsets;


        // Copy fixed values.
        //
        pji1Dst->JobId        = pji2Src->JobId;
        pji1Dst->Status       = pji2Src->Status;
        pji1Dst->Priority     = pji2Src->Priority;
        pji1Dst->Position     = pji2Src->Position;
        pji1Dst->TotalPages   = pji2Src->TotalPages;
        pji1Dst->PagesPrinted = pji2Src->PagesPrinted;
        pji1Dst->Submitted    = pji2Src->Submitted;


        // Copy strings.
        //
        *lpszSrc++ = pji2Src->pPrinterName;
        *lpszSrc++ = pji2Src->pMachineName;
        *lpszSrc++ = pji2Src->pUserName;
        *lpszSrc++ = pji2Src->pDocument;
        *lpszSrc++ = pji2Src->pDatatype;
        *lpszSrc++ = pji2Src->pStatus;

        break;

    case PRINT_LEVEL_2:

        pji2Dst  = (LPJOB_INFO_2)pbJobDst;
        pOffsets = s_JI2Offsets;


        // Copy fixed values.
        //
        pji2Dst->JobId               = pji2Src->JobId;
        pji2Dst->Status              = pji2Src->Status;
        pji2Dst->Priority            = pji2Src->Priority;
        pji2Dst->Position            = pji2Src->Position;
        pji2Dst->StartTime           = pji2Src->StartTime;
        pji2Dst->UntilTime           = pji2Src->UntilTime;
        pji2Dst->TotalPages          = pji2Src->TotalPages;
        pji2Dst->Size                = pji2Src->Size;
        pji2Dst->Submitted           = pji2Src->Submitted;
        pji2Dst->Time                = pji2Src->Time;
        pji2Dst->PagesPrinted        = pji2Src->PagesPrinted;
        pji2Dst->pSecurityDescriptor = NULL;
        pji2Dst->pDevMode            = NULL;


        // Copy strings.
        //
        *lpszSrc++ = pji2Src->pPrinterName;
        *lpszSrc++ = pji2Src->pMachineName;
        *lpszSrc++ = pji2Src->pUserName;
        *lpszSrc++ = pji2Src->pDocument;
        *lpszSrc++ = pji2Src->pNotifyName;
        *lpszSrc++ = pji2Src->pDatatype;
        *lpszSrc++ = pji2Src->pPrintProcessor;
        *lpszSrc++ = pji2Src->pParameters;
        *lpszSrc++ = pji2Src->pDriverName;
        *lpszSrc++ = NULL;
        *lpszSrc++ = pji2Src->pStatus;
        *lpszSrc++ = NULL;


        if (pji2Src->pDevMode) {

            cbDM = pji2Src->pDevMode->dmSize + pji2Src->pDevMode->dmDriverExtra;

            pbEnd -= cbDM;
            pbEnd  = (LPBYTE)((UINT_PTR)pbEnd & ~((UINT_PTR)sizeof(UINT_PTR) - 1));

            pji2Dst->pDevMode = (LPDEVMODE)pbEnd;

            CopyMemory(pji2Dst->pDevMode, pji2Src->pDevMode, cbDM);
        }

        break;

    case PRINT_LEVEL_3:

        pji3Dst  = (LPJOB_INFO_3)pbJobDst;
        pOffsets = s_JI3Offsets;

        pji3Dst->JobId = pji2Src->JobId;
        break;
    }


    return utlPackStrings(aszSrc, (LPBYTE)pbJobDst, pOffsets, pbEnd);
}

BOOL ppjob_CalcAndCopyJob(
    LPBYTE          pbJob,
    DWORD           cbJob,
    PDWORD          pcbNeed,
    PJOB_INFO_2     pji2,
    DWORD           dwLevel)
{

    BOOL bRet = FALSE;
    LPBYTE  pbEnd;

    // Fill in what we need.
    //
    *pcbNeed = ppjob_GetJobSize(pji2, dwLevel);

    // If our buffer is big-enough, then
    // proceed to fill in the info.
    //
    if (cbJob >= *pcbNeed) {

        pbEnd = pbJob + cbJob;

        ppjob_CopyJob(pbJob, dwLevel, pji2, pbEnd);

        bRet = TRUE;

    } else {

        SetLastError (ERROR_INSUFFICIENT_BUFFER);
    }

    return bRet;
}


/*****************************************************************************\
* ppjob_IppEnuRsp (Local Callback Routine)
*
* Retrieves a get response from the IPP server.  Our (lParam) in the
* parameter list references a LPPPJOB_ENUM pointer which we are to fill
* in from the enumeration.
*
\*****************************************************************************/
BOOL CALLBACK ppjob_IppEnuRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    PCINETMONPORT   pIniPort,
    LPARAM          lParam)
{
    HANDLE          hIpp;
    DWORD           dwRet;
    DWORD           cbRd;
    LPBYTE          pbEnd;
    DWORD           idx;
    DWORD           idx2;
    LPBYTE          lpDta;
    DWORD           cbDta;
    LPIPPRET_ENUJOB lpRsp;
    DWORD           cbRsp;
    LPPPJOB_ENUM    pje;
    LPIPPJI2        pji2;
    LPJOBMAP        pjm;
    PDWORD          pidJob;
    DWORD           cbSize;
    PJOBMAP*        pjmList;
    BYTE            bBuf[MAX_IPP_BUFFER];
    BOOL            bRet = FALSE;
    time_t          dwPrinterT0;



    if (hIpp = WebIppRcvOpen(IPP_RET_ENUJOB)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile ( pConnection, hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (bRet = lpRsp->bRet) {


                        if (lpRsp->cItems && lpRsp->cbItems) {

                            semEnterCrit();
                            pjmList = pIniPort->GetPJMList();

                            pjmCleanRemoteFlag(pjmList);

                            pji2  = lpRsp->pItems;

                            // We go over the IPP response and put them into PJM list
                            // At the mean time, we convert the remote job ID to
                            // local job id and store them into the IPP response
                            // data structure.
                            //

                            for (idx = 0; idx < lpRsp->cItems; idx++) {

                                // Fixup the job-id to the local id we
                                // can deal with.
                                //
                                pidJob = & (pji2[idx].ji2.JobId);

                                if (pjm = pjmFind(pjmList, PJM_REMOTEID, *pidJob)) {

                                    *pidJob = pjmJobId(pjm, PJM_LOCALID);

                                } else {

                                    if (pjm = pjmAdd(pjmList, pIniPort, NULL, NULL))
                                        pjmSetJobRemote(pjm, *pidJob, pji2[idx].ipp.pJobUri);

                                    *pidJob = pjmJobId(pjm, PJM_LOCALID);
                                }
                            }

                            // Call our routine to clean our client-list
                            // of jobs.  This will remove any entries
                            // that no longer exist on the server.
                            //
                            cbSize = sizeof(PPJOB_ENUM) + lpRsp->cbItems;

                            // Allocate storage for enumeration.
                            //
                            if (pje = (LPPPJOB_ENUM)memAlloc(cbSize)) {
                                dwPrinterT0 = pIniPort->GetPowerUpTime();
                                // This now containts the powerup time for the printer in
                                // our time


                                pje->cItems = lpRsp->cItems;
                                pje->cbSize = lpRsp->cbItems;


                                pji2  = lpRsp->pItems;
                                pbEnd = ((LPBYTE)pje->ji2) + pje->cbSize;

                                for (idx = 0; idx < lpRsp->cItems; idx++) {


                                    pbEnd = ppjob_CopyJob((LPBYTE)&pje->ji2[idx],
                                                          2,
                                                          &pji2[idx].ji2,
                                                          pbEnd);

                                    WebIppConvertSystemTime(&pje->ji2[idx].ji2.Submitted, dwPrinterT0);

                                }


                                pjmRemoveOldEntries(pjmList);

                                semLeaveCrit();

                                *((LPPPJOB_ENUM *)lParam) = pje;

                            } else {

                                SetLastError(ERROR_OUTOFMEMORY);
                            }
                        }
                        else {

                            //
                            // This is the case where the job count is 0 on the server
                            // We still need to allocate the structure so that the client
                            // enum-job function can merge the localjobs.
                            //

                            cbSize = sizeof(PPJOB_ENUM);

                            // Allocate storage for enumeration.
                            //
                            if (pje = (LPPPJOB_ENUM)memAlloc(cbSize)) {

                                pje->cItems = 0;
                                pje->cbSize = 0;

                                *((LPPPJOB_ENUM *)lParam) = pje;

                            } else {

                                SetLastError(ERROR_OUTOFMEMORY);
                            }
                        }


                    } else {

                        SetLastError(lpRsp->dwLastError);
                    }

                    WebIppFreeMem(lpRsp);

                    goto EndEnuRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //
                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppjob_IppEnuRsp : Receive Data Error")));
                    SetLastError(ERROR_INVALID_DATA);

                    goto EndEnuRsp;
                }

            } else {

                goto EndEnuRsp;
            }
        }

EndEnuRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* ppjob_IppSetRsp (Local Callback Routine)
*
* Retrieves a SetJob response from the IPP server
*
\*****************************************************************************/
BOOL CALLBACK ppjob_IppSetRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    PCINETMONPORT   pIniPort,
    LPARAM          lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_JOB lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen((WORD)(LPARAM)lParam)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile (pConnection, hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if ((bRet = lpRsp->bRet) == FALSE)
                        SetLastError(lpRsp->dwLastError);

                    WebIppFreeMem(lpRsp);

                    goto EndSetRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //

                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppjob_IppSetRsp : Receive Data Error")));
                    SetLastError(ERROR_INVALID_DATA);

                    goto EndSetRsp;
                }

            } else {

                goto EndSetRsp;
            }
        }

EndSetRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* ppjob_IppGetRsp (Local Callback Routine)
*
* Retrieves a get response from the IPP server.  Our (lParam) in the
* parameter list references a JOB_INFO_2 pointer which we are to fill
* in from the call.
*
\*****************************************************************************/
BOOL CALLBACK ppjob_IppGetRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    PCINETMONPORT   pIniPort,
    LPARAM          lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       pbEnd;
    DWORD        idx;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_JOB lpRsp;
    DWORD        cbRsp;
    LPJOB_INFO_2 pji2;
    LPJOBMAP     pjm;
    DWORD        cbSize;
    BYTE         bBuf[MAX_IPP_BUFFER];
    PJOBMAP*     pjmList;
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_GETJOB)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile ( pConnection, hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (bRet = lpRsp->bRet) {

                        cbSize = ppjob_GetJobSize(&lpRsp->ji.ji2, 2);

                        // Allocate storage for enumeration.
                        //
                        if (pji2 = (LPJOB_INFO_2)memAlloc(cbSize)) {

                            pbEnd = ((LPBYTE)pji2) + cbSize;

                            ppjob_CopyJob((LPBYTE)pji2, 2, &lpRsp->ji.ji2, pbEnd);


                            semEnterCrit();

                            pjmList = pIniPort->GetPJMList();


                            // Fixup the job-id to the local id we
                            // can deal with.
                            //
                            if (pjm = pjmFind(pjmList, PJM_REMOTEID, pji2->JobId)) {

                                pji2->JobId = pjmJobId(pjm, PJM_LOCALID);

                            } else {

                                if (pjm = pjmAdd(pjmList, pIniPort, NULL, NULL))
                                    pjmSetJobRemote(pjm, pji2->JobId, lpRsp->ji.ipp.pJobUri);

                                pji2->JobId = pjmJobId(pjm, PJM_LOCALID);
                            }

                            semLeaveCrit();


                            *((LPJOB_INFO_2 *)lParam) = pji2;

                        } else {

                            SetLastError(ERROR_OUTOFMEMORY);
                        }


                    } else {

                        SetLastError(lpRsp->dwLastError);
                    }

                    WebIppFreeMem(lpRsp);

                    goto EndGetRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //
                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppjob_IppGetRsp - Err : Receive Data Error (dwRet=%d, LE=%d)"),
                         dwRet, WebIppGetError(hIpp)));

                    SetLastError(ERROR_INVALID_DATA);

                    goto EndGetRsp;
                }

            } else {

                goto EndGetRsp;
            }
        }

EndGetRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* ppjob_Set (Local Routine)
*
* Sets a job command in the queue.
*
\*****************************************************************************/
BOOL ppjob_Set(
    PCINETMONPORT   pIniPort,
    DWORD           idJob,
    DWORD           dwCmd)
{
    PIPPREQ_SETJOB psj;
    PJOBMAP        pjm;
    WORD           wReq;
    REQINFO        ri;
    DWORD          dwRet;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    PJOBMAP*       pjmList;
    BOOL           bRet = FALSE;



    // Make sure we have a JobMap entry which we can
    // obtain the remote information.
    //
    pjmList = pIniPort->GetPJMList();

    if (pjm = pjmFind(pjmList, PJM_LOCALID, idJob)) {

        // If we're still spooling, then we haven't yet
        // hit the server.  Otherwise, we've performed the EndDoc()
        // and the job is being processed remotely.
        //
        if (pjmChkState(pjm, PJM_SPOOLING)) {

            switch (dwCmd) {
            case JOB_CONTROL_CANCEL:
            case JOB_CONTROL_DELETE:
                pjmSetState(pjm, PJM_CANCEL);
                //
                //  If the async thread is on, we let that thread to clean the job queue
                //
                if (!pjmChkState(pjm, PJM_ASYNCON))
                {
                    //
                    // Otherwise, we delete the job here.
                    //
                    pjmClrState (pjm, PJM_SPOOLING);
                }
                break;

            case JOB_CONTROL_PAUSE:
                pjmSetState(pjm, PJM_PAUSE);
                break;

            case JOB_CONTROL_RESUME:
                pjmClrState(pjm, PJM_PAUSE);
                break;

            case JOB_CONTROL_RESTART:
                pjmUpdateLocalJobStatus (pjm, JOB_STATUS_RESTART);

                if (!pjmChkState(pjm, PJM_ASYNCON))
                {
                    _ppprn_end_docprinter_async (pIniPort, pjm);
                }
                break;
            }

            bRet = TRUE;

        } else {

            // Look through list to get local/remote job mappings.
            //
            psj = WebIppCreateSetJobReq(pjmJobId(pjm, PJM_REMOTEID),
                                        dwCmd,
                                        pIniPort->GetPortName());

            if (psj) {

                switch (dwCmd) {
                case JOB_CONTROL_CANCEL:
                case JOB_CONTROL_DELETE:
                    wReq = IPP_REQ_CANCELJOB;
                    break;

                case JOB_CONTROL_PAUSE:
                    wReq = IPP_REQ_PAUSEJOB;
                    break;

                case JOB_CONTROL_RESUME:
                    wReq = IPP_REQ_RESUMEJOB;
                    break;

                case JOB_CONTROL_RESTART:
                    wReq = IPP_REQ_RESTARTJOB;
                    break;

                default:
                    wReq = 0;
                    break;
                }


                // Convert the reqest to IPP, and perform the
                // post.
                //
                ZeroMemory(&ri, sizeof(REQINFO));
                ri.cpReq = CP_UTF8;
                ri.idReq = wReq;

                ri.fReq[0] = IPP_REQALL;
                ri.fReq[1] = IPP_REQALL;

                dwRet = WebIppSndData(wReq,
                                      &ri,
                                      (LPBYTE)psj,
                                      psj->cbSize,
                                      &lpIpp,
                                      &cbIpp);


                // The request-structure has been converted to IPP format,
                // so it is ready to go to the server.
                //
                if (dwRet == WEBIPP_OK) {

                    bRet = pIniPort->SendReq(lpIpp,
                                             cbIpp,
                                             ppjob_IppSetRsp,
                                             (LPARAM)(wReq | IPP_RESPONSE),
                                             TRUE);

                    WebIppFreeMem(lpIpp);

                } else {

                    SetLastError(ERROR_OUTOFMEMORY);
                }

                // Once we've verified the request for cancel, then
                // we should remove the job from our list.
                //
                // NOTE: Should this be deleted always?  Or should
                //       we make this dependent on the success of
                //       the server-call?
                //
                //       06-Jan-1998 <chriswil> Will Revisit.
                //
                if (dwCmd == JOB_CONTROL_CANCEL)
                    pjmDel(pjmList, pjm);

                WebIppFreeMem(psj);

            } else {

                SetLastError(ERROR_OUTOFMEMORY);
            }
        }

    } else {

        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRet;
}


/*****************************************************************************\
* ppjob_Enum (Local Routine)
*
* Enumerates jobs.  IPP has the ENUJOB request which can be used for both
* specific jobs, or enumerated-jobs.  We will distinguish whether we're
* enumerating by a (IPP_GETJOB_ALL) job-id.
*
\*****************************************************************************/
BOOL ppjob_Enum(
    PCINETMONPORT   pIniPort,
    DWORD           nJobStart,
    DWORD           cJobs,
    DWORD           dwLevel,
    LPBYTE          pbJob,
    DWORD           cbJob,
    LPDWORD         pcbNeed,
    LPDWORD         pcItems)
{
    PIPPREQ_ENUJOB pgj;
    REQINFO        ri;
    DWORD          dwRet;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    DWORD          idx;
    DWORD          cbSize;
    DWORD          cbIdx;
    DWORD          dwLastError = ERROR_INVALID_DATA;
    LPBYTE         pbEnd;
    LPPPJOB_ENUM   pje = NULL;
    BOOL           bRet = FALSE;
    DWORD          curIdx = 0;
    DWORD          dwLocalJobCount = 0;
    DWORD          cbLocalJobSize = 0;
    PJOBMAP*       pjmList;
    PJOBMAP        pjmTmpList;
    JOB_INFO_2     JobInfo2;
    BOOL           bFound;


    // Specifying (IPP_GETJOB_ALL) will enumerate all jobs.
    //

    pjmList = pIniPort->GetPJMList ();
    pbEnd = pbJob + cbJob;
    cbIdx = ppjob_GetOneSize (dwLevel);

    if (pIniPort->BeginReadEnumJobsCache (&pje)) {

        bRet        = TRUE;
        dwLastError = GetLastError();

        // Upon return, our (pje) pointer contains an
        // enumeration structure of JOB_INFO_2 items.
        //
        // Based upon the level passed in, we need to either
        // return these items or a converted JOB_INFO_1.
        //
        if (pje) {

            // Calculate the size we'll need to store the
            // enumerated items.
            //
            for (idx = 0, cbSize = 0; idx < pje->cItems; idx++)
                cbSize += ppjob_GetJobSize(&pje->ji2[idx].ji2, dwLevel);

            dwLocalJobCount = pjmGetLocalJobCount(pjmList, &cbLocalJobSize);

            if (dwLocalJobCount > 0) {

                cbSize += cbLocalJobSize;
            }

            // Fill in the return-value indicating
            // the buffer necessary to hold the items.
            //
            *pcbNeed = cbSize;


            // If the user buffer is of sufficient size,
            // then copy/convert the items.
            //
            if (cbJob >= cbSize) {

                *pcItems = pje->cItems + dwLocalJobCount;


                for (idx = 0; idx < pje->cItems && cJobs; idx++) {

                    if ((idx >= nJobStart)) {

                        pbEnd = ppjob_CopyJob(pbJob,
                                              dwLevel,
                                              &pje->ji2[idx].ji2,
                                              pbEnd);


                        pbJob += cbIdx;

                        cJobs--;
                    }
                }

                curIdx = idx;
            } else {
                bRet        = FALSE;
                dwLastError = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    }
    else {

        dwLocalJobCount = pjmGetLocalJobCount(pjmList, &cbLocalJobSize);

        if (dwLocalJobCount > 0) {

            cbSize = cbLocalJobSize;

            // Fill in the return-value indicating
            // the buffer necessary to hold the items.
            //
            *pcbNeed = cbSize;

            // If the user buffer is of sufficient size,
            // then copy/convert the items.
            //
            if (cbJob >= cbSize) {

                *pcItems = dwLocalJobCount;
                bRet = TRUE;

            } else {
                bRet        = FALSE;
                dwLastError = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else {
            dwLastError = GetLastError();
        }

    }

    if (bRet) {

        pjmTmpList = *pjmList;

        for (idx = curIdx; idx < curIdx + dwLocalJobCount && cJobs; idx++) {

            pjmTmpList = pjmNextLocalJob (&pjmTmpList, &JobInfo2, &bFound);

            if ((idx >= nJobStart)) {

                if (bFound) {

                    DBG_ASSERT( ((pbJob < pbEnd)?TRUE:FALSE),
                                (TEXT("ppjob_Enum: idx = %d, cbIdx = %d, cJobs = %d dwLocalJobCount = %d dwLocalSize=%d, pjd=%p\n"),
                                idx, cbIdx, cJobs, dwLocalJobCount, dwLocalJobCount, pje));

                    pbEnd = ppjob_CopyJob(pbJob,
                                          dwLevel,
                                          &JobInfo2,
                                          pbEnd);



                    pbJob += cbIdx;

                    cJobs--;
                }
                else {
                    bRet = FALSE;
                    dwLastError = ERROR_INVALID_PARAMETER;
                    break;
                }

            }
        }
    }

    // This function has to be called to release the critical section
    //
    pIniPort->EndReadEnumJobsCache ();

    if (!bRet) {

        SetLastError(dwLastError);
    }

    return bRet;
}

/*****************************************************************************\
* ppjob_EnumForCache (Local Routine)
*
* Enumerates jobs.  IPP has the ENUJOB request which can be used for both
* specific jobs, or enumerated-jobs.  We will distinguish whether we're
* enumerating by a (IPP_GETJOB_ALL) job-id.
*
* Upon return,  ppbJob stores a pointer to the cache
*
\*****************************************************************************/
BOOL ppjob_EnumForCache(
    PCINETMONPORT   pIniPort,
    LPPPJOB_ENUM    *ppje)
{
    PIPPREQ_ENUJOB pgj;
    REQINFO        ri;
    DWORD          dwRet;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    DWORD          idx;
    DWORD          cbSize;
    DWORD          cbIdx;
    DWORD          dwLastError = ERROR_INVALID_DATA;
    LPBYTE         pbEnd;
    LPPPJOB_ENUM   pje = NULL;
    BOOL           bRet = FALSE;



    // Specifying (IPP_GETJOB_ALL) will enumerate all jobs.
    //
    pgj = WebIppCreateEnuJobReq(IPP_GETJOB_ALL, pIniPort->GetPortName());

    if (pgj) {

        // Convert the reqest to IPP, and perform the
        // post.
        //
        ZeroMemory(&ri, sizeof(REQINFO));
        ri.cpReq = CP_UTF8;
        ri.idReq = IPP_REQ_ENUJOB;

        ri.fReq[0] = IPP_REQALL;
        ri.fReq[1] = IPP_REQALL;

        dwRet = WebIppSndData(IPP_REQ_ENUJOB,
                              &ri,
                              (LPBYTE)pgj,
                              pgj->cbSize,
                              &lpIpp,
                              &cbIpp);


        // The request-structure has been converted to IPP format,
        // so it is ready to go to the server.
        //
        if (dwRet == WEBIPP_OK) {

            // This routine returns with a LastError set to that
            // which the response-routine sets.
            //
            if (pIniPort->SendReq(lpIpp,
                                  cbIpp,
                                  ppjob_IppEnuRsp,
                                  (LPARAM)&pje,
                                  TRUE)) {

                dwLastError = GetLastError();
                bRet        = TRUE;
                *ppje       = pje;

            } else {

                dwLastError = GetLastError();
            }

            WebIppFreeMem(lpIpp);

        } else {

            dwLastError = ERROR_OUTOFMEMORY;
        }

        WebIppFreeMem(pgj);

    } else {

        dwLastError = ERROR_OUTOFMEMORY;
    }

    if (!bRet) {

        SetLastError(dwLastError);
    }

    return bRet;
}

/*****************************************************************************\
* ppjob_Get (Local Routine)
*
* Returns information regarding a job.
*
\*****************************************************************************/
BOOL ppjob_Get(
    PCINETMONPORT   pIniPort,
    DWORD           idJob,
    DWORD           dwLevel,
    LPBYTE          pbJob,
    DWORD           cbJob,
    LPDWORD         pcbNeed)
{
    PJOBMAP        pjm;
    PIPPREQ_GETJOB pgj;
    REQINFO        ri;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    DWORD          dwRet;
    LPBYTE         pbEnd;
    PJOBMAP*       pjmList;
    LPJOB_INFO_2   pji2 = NULL;
    BOOL           bRet = FALSE;
    DWORD          dwLastError = ERROR_INVALID_DATA;


    // Look in our JobMap list for the local-job-id.  If we see
    // one, the we can get the job-information.
    //
    pjmList = pIniPort->GetPJMList();

    if (pjm = pjmFind(pjmList, PJM_LOCALID, idJob)) {

        if (pjm->bRemoteJob) {

            // Build a request-structure that we will pass into
            // the IPP layer for processing.
            //
            pgj = WebIppCreateGetJobReq(pjmJobId(pjm, PJM_REMOTEID), pIniPort->GetPortName());

            if (pgj) {

                // Convert the reqest to IPP that is suitible for
                // our post.
                //
                ZeroMemory(&ri, sizeof(REQINFO));
                ri.cpReq = CP_UTF8;
                ri.idReq = IPP_REQ_GETJOB;

                ri.fReq[0] = IPP_REQALL;
                ri.fReq[1] = IPP_REQALL;

                dwRet = WebIppSndData(IPP_REQ_GETJOB,
                                      &ri,
                                      (LPBYTE)pgj,
                                      pgj->cbSize,
                                      &lpIpp,
                                      &cbIpp);


                // The request-structure has been converted to IPP format,
                // so it is ready to go to the server.  We set a callback
                // to the function that will receive our data.
                //
                if (dwRet == WEBIPP_OK) {

                    pIniPort->SendReq(lpIpp,
                                      cbIpp,
                                      ppjob_IppGetRsp,
                                      (LPARAM)&pji2,
                                      TRUE);


                    // Upon return, our (pji2) contains the JOB_INFO_2
                    // structure.
                    //
                    if (pji2) {

                        bRet = ppjob_CalcAndCopyJob(pbJob, cbJob, pcbNeed, pji2, dwLevel);

                        if (!bRet) {
                            dwLastError = GetLastError ();
                        }

                        memFree(pji2, memGetSize(pji2));
                    }

                    WebIppFreeMem(lpIpp);

                } else {

                    dwLastError = ERROR_OUTOFMEMORY;
                }

                WebIppFreeMem(pgj);

            } else {

                dwLastError = ERROR_OUTOFMEMORY;
            }
        }
        else {

            //
            // This is a local job
            //

            if (pjm = pjmFind(pjmList, PJM_LOCALID, idJob)) {

                JOB_INFO_2 JobInfo2;
                BOOL bFound;

                pjmNextLocalJob(&pjm, &JobInfo2, &bFound);

                if (bFound) {

                    bRet = ppjob_CalcAndCopyJob(pbJob, cbJob, pcbNeed, &JobInfo2, dwLevel);

                    if (!bRet) {
                        dwLastError = GetLastError ();
                    }
                }
                else
                    dwLastError = ERROR_INVALID_PARAMETER;

            } else {
                dwLastError = ERROR_INVALID_PARAMETER;
            }

        }

    } else {

        dwLastError = ERROR_INVALID_PARAMETER;
    }


    // Set the lasterror if failure.
    //
    if (!bRet) {

        SetLastError(dwLastError);
    }

    return bRet;
}

/*****************************************************************************\
* ppjob_Add (Local Routine)
*
* Returns information for an addjob call.
*
\*****************************************************************************/
BOOL ppjob_Add(
    HANDLE          hPrinter,
    PCINETMONPORT   pIniPort,
    DWORD           dwLevel,
    LPCTSTR         lpszName,
    LPBYTE          pbData,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded)
{
    PJOBMAP  pjm;
    LPCTSTR  lpszSplFile;
    LPTSTR*  lpszSrc;
    LPBYTE   pbEnd;
    PJOBMAP* pjmList;
    LPTSTR   aszSrc[(sizeof(ADDJOB_INFO_1) / sizeof(LPTSTR))];
    BOOL     bRet = FALSE;

    static DWORD s_AJI1Offsets[] = {
        offsetof(LPADDJOB_INFO_1, Path),
        0xFFFFFFFF
    };


    // Create a spool-file and job that we will use
    // for this AddJob() call.
    //
    pjmList = pIniPort->GetPJMList();

    if (pjm = pjmAdd(pjmList, pIniPort, lpszName, NULL)) {

        // Set the job into spooling-state.  This internally
        // creates the spool-file.  By specifying PJM_NOOPEN,
        // we indicate that no open-handles are to be maintained
        // on the spool-file.
        //
        if (pjmSetState(pjm, PJM_SPOOLING | PJM_NOOPEN)) {

            // Get the spool-file.
            //
            lpszSplFile = pjmSplFile(pjm);


            // If a return-size is provided, then set it.
            //
            if (pcbNeeded)
                *pcbNeeded = sizeof(ADDJOB_INFO_1) + utlStrSize(lpszSplFile);


            // If the buffer is capable of holding the
            // return-structure, then proceed.
            //
            if (pbData && (cbBuf >= *pcbNeeded)) {

                // Clean out the string-array and setup
                // for building the structure.
                //
                ZeroMemory(aszSrc, sizeof(aszSrc));
                lpszSrc = aszSrc;


                // Initialize fixed values.
                //
                ((LPADDJOB_INFO_1)pbData)->JobId = pjmJobId(pjm, PJM_LOCALID);


                // Pack the file-name into the return-structure.
                //
                pbEnd = pbData + cbBuf;
                *lpszSrc++ = (LPTSTR)lpszSplFile;
                utlPackStrings(aszSrc, pbData, s_AJI1Offsets, pbEnd);


                // Mark this printer to indicate it's in a
                // addjob.
                //
                // NOTE: do we really need to consume the printer
                //       for an AddJob().  LocalSpl does this and
                //       sets the job into the printer.  I don't
                //       see why this is necessary.
                //
                PP_SetStatus(hPrinter, PP_ADDJOB);

                bRet = TRUE;

            } else {

                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }

        } else {

            SetLastError(ERROR_FILE_NOT_FOUND);
        }

    } else {

        SetLastError(ERROR_INVALID_HANDLE);
    }

    return bRet;
}

/*****************************************************************************\
* ppjob_Schedule (Local Routine)
*
* Prints the scheduled job.
*
\*****************************************************************************/
BOOL ppjob_Schedule(
    HANDLE          hPrinter,
    PCINETMONPORT   pIniPort,
    PJOBMAP         pjm)
{
    HANDLE         hOut;
    BOOL           bRemote;
    LPCTSTR        lpszUser;
    PIPPREQ_PRTJOB ppj;
    REQINFO        ri;
    LPBYTE         pbOut;
    LPBYTE         pbIpp;
    LPBYTE         pbSpl;
    DWORD          cbOut;
    DWORD          cbIpp;
    DWORD          cbSpl;
    DWORD          dwRet;
    DWORD          cbWr;
    PJOBMAP*       pjmList;
    DWORD          dwLE     = ERROR_INVALID_HANDLE;
    CFileStream    *pStream = NULL;
    CFileStream    *pSplStream = NULL;
    BOOL           bRet     = FALSE;


    // Lock the file so we can obtain the spool-data.
    //
    pjmList = pIniPort->GetPJMList();

    if (pSplStream = pjmSplLock(pjm)) {

        // Check to determine if this is a remote-call.
        //
        bRemote = TRUE;


        // Get the user-name if one was specified in AddJob().
        //
        lpszUser = pjmSplUser(pjm);


        // Create the print-job-request that we'll be using.
        //
        ppj = WebIppCreatePrtJobReq(FALSE,
                                    (lpszUser ? lpszUser : TEXT("Unknown")),
                                    (bRemote ? g_szDocRemote: g_szDocLocal),
                                    pIniPort->GetPortName());

        if (ppj) {

            ZeroMemory(&ri, sizeof(REQINFO));
            ri.cpReq = CP_UTF8;
            ri.idReq = IPP_REQ_PRINTJOB;

            ri.fReq[0] = IPP_REQALL;
            ri.fReq[1] = IPP_REQALL;

            dwRet = WebIppSndData(IPP_REQ_PRINTJOB,
                                  &ri,
                                  (LPBYTE)ppj,
                                  ppj->cbSize,
                                  &pbIpp,
                                  &cbIpp);

            // Make sure we were able to get the ipp-header.
            //
            if (dwRet == WEBIPP_OK) {

                // Create the outputfile that will be used to
                // contain both the ipp-header as well as the
                // spool-data.
                //
                if (hOut = SplCreate(pjmJobId(pjm, PJM_LOCALID), SPLFILE_SPL)) {

                    // Output the header and data.
                    //
                    if (SplWrite(hOut, pbIpp, cbIpp, &cbWr) &&
                        SplWrite(hOut, pSplStream) &&

                        // Output the request.
                        //
                        (pStream = SplLock(hOut))) {

                        bRet = pIniPort->SendReq(pStream,
                                                 (IPPRSPPROC)ppjob_IppPrtRsp,
                                                 (LPARAM)pjm,
                                                 TRUE);

                        if (bRet == FALSE)
                            dwLE = GetLastError();

                        SplUnlock(hOut);

                    } else {

                        dwLE = GetLastError();
                    }


                    // Free up the spool-output-file.
                    //
                    SplFree(hOut);

                } else {

                    dwLE = GetLastError();
                }

                WebIppFreeMem(pbIpp);

            } else {

                dwLE = ERROR_OUTOFMEMORY;
            }

            WebIppFreeMem(ppj);

        } else {

            dwLE = ERROR_OUTOFMEMORY;
        }

        pjmSplUnlock(pjm);

    } else {

        dwLE = GetLastError();
    }


    // Clear out our spooling-status.  This will close
    // and delete the spool-file as the job is now in the
    // hands of spooler.
    //
    pjmClrState(pjm, PJM_SPOOLING);


    // If a cancel was set on this job, then delete it's entry from
    // our list.
    //
    if (pjmChkState(pjm, PJM_CANCEL) && pjmList != NULL)
        pjmDel(pjmList, pjm);


    // Set lasterror if problem occured.
    //
    if (bRet == FALSE)
        SetLastError(dwLE);

    return bRet;
}

/*****************************************************************************\
* PPEnumJobs
*
* Retrives the information about a specified set of print jobs for a
* specified printer.  Returns TRUE if successful.  Otherwise, it returns
* FALSE.
*
\*****************************************************************************/
BOOL PPEnumJobs(
    HANDLE  hPrinter,
    DWORD   nJobStart,
    DWORD   cJobs,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   cbJob,
    LPDWORD pcbNeeded,
    LPDWORD pcItems)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPEnumJobs: Printer(%08lX) dwLevel(%d)"), hPrinter, dwLevel));

    semEnterCrit();

    *pcbNeeded = 0;
    *pcItems   = 0;


    // Make sure we have a valid printer handle.
    //
    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        // Attempt to get a list of jobs from the ipp print spooler.
        // Format the job information to the requested information level.
        //
        switch (dwLevel) {

        case PRINT_LEVEL_1:
        case PRINT_LEVEL_2:

            bRet = ppjob_Enum(pIniPort,
                              nJobStart,
                              cJobs,
                              dwLevel,
                              pbJob,
                              cbJob,
                              pcbNeeded,
                              pcItems);
            break;

        default:
            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPEnumJobs: Invalid Level (%d)"), dwLevel));
            SetLastError(ERROR_INVALID_LEVEL);
            break;
        }
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPGetJob
*
* Retrieves information about a print job on a specified printer.  Returns
* TRUE if successful.  Otherwise, it returns FASLSE.
*
\*****************************************************************************/
BOOL PPGetJob(
    HANDLE  hPrinter,
    DWORD   idJob,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   cbJob,
    LPDWORD pcbNeed)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPGetJob: Printer(%08lX) dwLevel(%d)"), hPrinter, dwLevel));

    semEnterCrit();

    *pcbNeed = 0;

    // Make sure we're looking at a valid printer handle.
    //
    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        // Switch on print-level.
        //
        switch (dwLevel) {

        case PRINT_LEVEL_1:
        case PRINT_LEVEL_2:

            bRet = ppjob_Get(pIniPort, idJob, dwLevel, pbJob, cbJob, pcbNeed);
            break;

        default:
            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPGetJob: Invalid Level (%d)"), dwLevel));
            SetLastError(ERROR_INVALID_LEVEL);
            break;
        }
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPSetJob
*
* Sets information for and issues commands to a print job.  Returns TRUE
* if successful.  Otherwise, it returns FALSE.
*
\*****************************************************************************/
BOOL PPSetJob(
    HANDLE hPrinter,
    DWORD  dwJobId,
    DWORD  dwLevel,
    LPBYTE pbJob,
    DWORD  dwCmd)
{
    PCINETMONPORT pIniPort;
    BOOL   bResult = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPSetJob: Printer(%08lX) dwLevel(%d)"), hPrinter, dwLevel));

    semEnterCrit();

    // Make sure we've got a valid printer handle.
    //
    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        // Set job parameters.
        //
        switch (dwLevel) {

        case PRINT_LEVEL_0:

            // Do not set parameters. (0) represents "no-command".
            //
            switch (dwCmd) {

            case JOB_CONTROL_CANCEL:
            case JOB_CONTROL_DELETE:
            case JOB_CONTROL_PAUSE:
            case JOB_CONTROL_RESUME:
            case JOB_CONTROL_RESTART:
                bResult = ppjob_Set(pIniPort, dwJobId, dwCmd);
                if (bResult) {
                    // Invalidate has to occur before notfication refresh, otherwise, you
                    // get an outdated result
                    //
                    pIniPort->InvalidateEnumJobsCache ();
                    pIniPort->InvalidateGetPrinterCache ();

                    RefreshNotification((LPINET_HPRINTER)hPrinter);
                }
                break;

            case 0:
                bResult = TRUE;
                break;
            }
            break;

        default:
            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPSetJob: Invalid Level (%d)"), dwLevel));
            SetLastError(ERROR_INVALID_LEVEL);
            break;
        }

    }

    semLeaveCrit();

    return bResult;
}


/*****************************************************************************\
* PPAddJob
*
* Sets up for a local-spooled job.  Since we are truly a remote-printer, we
* need to fail this call and signify the correct error-code.
*
\*****************************************************************************/
BOOL PPAddJob(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    PCINETMONPORT pIniPort;
    LPTSTR lpszName;
    BOOL   bRet = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPAddJob: Printer(%08lX) dwLevel(%d)"), hPrinter, dwLevel));


    // Zero out the return-parameters.
    //
    *pcbNeeded = 0;


    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        if (pbData && pcbNeeded) {

            switch (dwLevel) {

            case PRINT_LEVEL_2:

                lpszName = (LPTSTR)(pbData + (ULONG_PTR)((LPADDJOB_INFO_2W)pbData)->pData);


                // Make sure this string-address does not extend past the
                // end of available buffer specified.
                //
                if (lpszName > (LPTSTR)(pbData + cbBuf)) {

                    SetLastError(ERROR_INVALID_LEVEL);

                    goto EndAdd;
                }


                // Ensure NULL termination.
                //
                *(PTCHAR)(((ULONG_PTR)(pbData + cbBuf - sizeof(TCHAR))&~1)) = 0;
                break;

            case PRINT_LEVEL_1:
                lpszName = NULL;
                break;

            default:
                SetLastError(ERROR_INVALID_LEVEL);
                goto EndAdd;
            }


            // Do the add.
            //
            bRet = ppjob_Add(hPrinter,
                             pIniPort,
                             dwLevel,
                             lpszName,
                             pbData,
                             cbBuf,
                             pcbNeeded);

        } else {

            SetLastError(ERROR_INVALID_PARAMETER);
        }
    }

EndAdd:

    semLeaveCrit();

    return bRet;
}

/*****************************************************************************\
* PPScheduleJob
*
* This schedules the job.  Since we don't support the PPAddJob(), this call
* must fail.
*
\*****************************************************************************/
BOOL PPScheduleJob(
    HANDLE hPrinter,
    DWORD  idJob)
{
    PCINETMONPORT   pIniPort;
    PJOBMAP         pjm;
    PJOBMAP*        pjmList;
    BOOL            bRet = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPScheduleJob: Printer(%08lX) idJob(%d)"), hPrinter, idJob));

    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        pjmList = pIniPort->GetPJMList();

        if (pjm = pjmFind(pjmList, PJM_LOCALID, idJob)) {

            if (pjmChkState(pjm, PJM_SPOOLING)) {

                bRet = ppjob_Schedule(hPrinter, pIniPort, pjm);

            } else {

                SetLastError(ERROR_SPL_NO_ADDJOB);
            }

        } else {

            SetLastError(ERROR_INVALID_PARAMETER);
        }

        PP_ClrStatus(hPrinter, PP_ADDJOB);
    }

    semLeaveCrit();

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ppport.cxx ===
/*****************************************************************************\
* MODULE: ppport.c
*
* This module contains the routines which handle port related calls.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   18-Nov-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* _ppport_validate_enumport (Local Routine)
*
* Validate the servername and level of EnumPorts.
*
\*****************************************************************************/
_inline BOOL _ppport_validate_enumport(
    LPCTSTR lpszServerName,
    DWORD   dwLevel)
{
    if (MyName (lpszServerName) ) {

        if (dwLevel <= PRINT_LEVEL_2) {

            return TRUE;

        } else {

            SetLastError(ERROR_INVALID_LEVEL);
        }

    } else {

        SetLastError(ERROR_INVALID_NAME);
    }

    return FALSE;
}


/*****************************************************************************\
* _ppport_validate_portname (Local Routine)
*
* Validates the portname string.
*
\*****************************************************************************/
_inline BOOL _ppport_validate_portname(
    LPCTSTR lpszPortName)
{
    if (lpszPortName == NULL) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    return TRUE;
}


/*****************************************************************************\
* PPEnumPorts
*
* Enumerates the ports available through the print-provider.
*
*
\*****************************************************************************/
BOOL PPEnumPorts(
    LPTSTR  lpszServerName,
    DWORD   dwLevel,
    LPBYTE  pbPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeed,
    LPDWORD pcbRet)
{
    BOOL bRet = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPEnumPorts")));

    semEnterCrit();

    if (_ppport_validate_enumport(lpszServerName, dwLevel))
        bRet = gpInetMon->InetmonEnumPorts(lpszServerName, dwLevel, pbPorts, cbBuf, pcbNeed, pcbRet);

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPDeletePort
*
* Deletes a port from the list.
*
* The following is not true anymore -- weihaic
*
* For internal use only. THIS IS NOT EXPORTED to the spooler.
* HTTP Provider cannot remotely delete a port on the server.
*
\*****************************************************************************/
BOOL PPDeletePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName)
{
    BOOL bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPDeletePort")));

    semEnterCrit();

    if (_ppport_validate_portname(lpszPortName)) {

        DWORD dwReturned;
        DWORD dwNeeded;
        DWORD i;
        PPRINTER_INFO_5 pPrinters = NULL;
        BOOL bFound = FALSE;

        // Leave critical section to call enum printers
        semLeaveCrit();

        if (!EnumPrinters( PRINTER_ENUM_LOCAL, NULL, 5, NULL, 0, &dwNeeded, &dwReturned) &&
            GetLastError () == ERROR_INSUFFICIENT_BUFFER) {


            pPrinters = ( PPRINTER_INFO_5) LocalAlloc (LPTR, dwNeeded);

            if (pPrinters) {

                if (EnumPrinters( PRINTER_ENUM_LOCAL, NULL, 5, (PBYTE) pPrinters,
                                  dwNeeded, &dwNeeded, &dwReturned)) {


                    for (i = 0; i< dwReturned; i++) {
                        if (!lstrcmpi (pPrinters[i].pPortName, lpszPortName)) {
                            bFound = TRUE;
                            break;
                        }
                    }

                    if (bFound) {
                        SetLastError (ERROR_BUSY);
                    }

                }

                LocalFree (pPrinters);
            }
        }

        semEnterCrit();

        if (!bFound && _ppport_validate_portname(lpszPortName)) {
            bRet = gpInetMon->InetmonDeletePort(lpszPortName, hWnd, NULL);
        }
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPAddPort
*
* Adds a port to the list.
*
* For internal use only. THIS IS NOT EXPORTED to the spooler.
* HTTP Provider cannot remotely add a port to the server.
*
\*****************************************************************************/
BOOL PPAddPort(
    LPTSTR lpszPortName,
    HWND   hWnd,
    LPTSTR lpszMonitorName)
{
    BOOL bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPAddPort")));

    semEnterCrit();

    if (_ppport_validate_portname(lpszPortName))
        bRet = gpInetMon->InetmonAddPort(lpszPortName, lpszMonitorName);

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPConfigurePort
*
*
\*****************************************************************************/
BOOL PPConfigurePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName)
{
    return stubConfigurePort(lpszServerName, hWnd, lpszPortName);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ppprn.h ===
/*****************************************************************************\
* MODULE: ppprn.h
*
* Prototypes for private funcions in ppprn.c.  These functions control the
* printer during the course of a single job.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#ifndef _PPPRN_H
#define _PPPRN_H

#define IPO_SIGNATURE     0x5152     // 'RQ' is the signature value
#define IPO_XCV_SIGNATURE 0x5153     // 'SQ' is the signature value

// Mask styles.
//
#define PP_STARTDOC       0x00000001 // To serialize access to the port
#define PP_ENDDOC         0x00000002 // To serialize access to job.
#define PP_FIRSTWRITE     0x00000004 //
#define PP_ZOMBIE         0x00000008 //
#define PP_CANCELLED      0x00000010 //
#define PP_ADDJOB         0x00000020

// hPrinter Structure.
//
typedef struct _INET_HPRINTER {

    DWORD               dwSignature;
    LPTSTR              lpszName;
    HANDLE              hPort;
    DWORD               dwStatus;
    HANDLE              hNotify;
    PCLOGON_USERDATA    hUser;  // This is used to keep track of the current user logon
    PJOBMAP pjmJob;

} INET_HPRINTER;
typedef INET_HPRINTER *PINET_HPRINTER;
typedef INET_HPRINTER *NPINET_HPRINTER;
typedef INET_HPRINTER *LPINET_HPRINTER;

typedef struct _INET_XCV_HPRINTER {

    DWORD   dwSignature;
    LPTSTR  lpszName;
} INET_XCV_HPRINTER;
typedef INET_XCV_HPRINTER *PINET_XCV_HPRINTER;
typedef INET_XCV_HPRINTER *NPINET_XCV_HPRINTER;
typedef INET_XCV_HPRINTER *LPINET_XCV_HPRINTER;


typedef struct {
    PCINETMONPORT   pIniPort;
    PJOBMAP         pjmJob;
    CSid*           pSidToken;
} ENDDOCTHREADCONTEXT;

typedef ENDDOCTHREADCONTEXT *PENDDOCTHREADCONTEXT;

_inline VOID PP_SetStatus(
    HANDLE hPrinter,
    DWORD  dwStatus)
{
    ((LPINET_HPRINTER)hPrinter)->dwStatus |= dwStatus;
}

_inline VOID PP_ClrStatus(
    HANDLE hPrinter,
    DWORD  dwStatus)
{
    ((LPINET_HPRINTER)hPrinter)->dwStatus &= ~dwStatus;
}

_inline BOOL PP_ChkStatus(
    HANDLE hPrinter,
    DWORD  dwStatus)
{
    return (((LPINET_HPRINTER)hPrinter)->dwStatus & dwStatus);
}

_inline PJOBMAP PP_GetJobInfo(
    HANDLE hPrinter)
{
    return ((LPINET_HPRINTER)hPrinter)->pjmJob;
}



PJOBMAP PP_OpenJobInfo(HANDLE, HANDLE);
VOID    PP_CloseJobInfo(HANDLE);



BOOL PPAbortPrinter(
    HANDLE hPrinter);

BOOL PPClosePrinter(
    HANDLE hPrinter);

BOOL PPEndDocPrinter(
    HANDLE hPrinter);

BOOL PPEndPagePrinter(
    HANDLE hPrinter);

BOOL PPOpenPrinter(
    LPTSTR            lpszPrnName,
    LPHANDLE           phPrinter,
    LPPRINTER_DEFAULTS pDefaults);

DWORD PPStartDocPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE pDocInfo);

BOOL PPStartPagePrinter(
    HANDLE hPrinter);

BOOL PPWritePrinter(
    HANDLE  hPrinter,
    LPVOID  lpvBuf,
    DWORD   cbBuf,
    LPDWORD pcbWr);


BOOL PPSetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE pbPrinter,
    DWORD  dwCmd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\ppprn.cxx ===
/*****************************************************************************\
* MODULE: ppprn.c
*
* This module contains the routines which control the printer during the
* course of a single job.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   09-Jun-1993 JonMarb     Created
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* _ppprn_free_hprinter (Local Routine)
*
* Free up the hPrinter  handle.
*
\*****************************************************************************/
_inline VOID _ppprn_free_hprinter(
    HANDLE hPrinter)
{
    LPINET_HPRINTER pPrt;


    if (pPrt = (LPINET_HPRINTER)hPrinter) {

        DeleteHandleFromList (pPrt);

        if (pPrt->lpszName)
            memFreeStr(pPrt->lpszName);

        if (pPrt->hUser)
            delete ( pPrt->hUser );

        memFree(pPrt, sizeof(INET_HPRINTER));

    }
}

/*****************************************************************************\
* _ppprn_inc_user_refcount (Local Routine)
*
* Increment the reference count for the Port on the current printer
*
\*****************************************************************************/
_inline DWORD __ppprn_inc_user_refcout(
    HANDLE hPrinter ) {

    LPINET_HPRINTER pPrt;
    DWORD           dwRet = MAXDWORD;

    if (pPrt = (LPINET_HPRINTER)hPrinter) {
        dwRet = (PCINETMONPORT (pPrt->hPort))->IncUserRefCount(pPrt->hUser );

    } else
        SetLastError( ERROR_INVALID_PARAMETER );

    return dwRet;
}

/*****************************************************************************\
* _ppprn_make_hprinter (Local Routine)
*
* Returns a printer handle.
*
\*****************************************************************************/
HANDLE _ppprn_make_hprinter(
    HANDLE  hPort,
    LPCTSTR lpszPrnName)
{
    LPINET_HPRINTER pPrt;


    if (pPrt = (LPINET_HPRINTER)memAlloc(sizeof(INET_HPRINTER))) {

        pPrt->dwSignature = IPO_SIGNATURE;
        pPrt->lpszName    = memAllocStr(lpszPrnName);
        pPrt->hPort       = hPort;
        pPrt->dwStatus    = 0;
        pPrt->pjmJob      = NULL;
        pPrt->hUser       = new CLogonUserData;

        if (
            pPrt->lpszName
            && pPrt->hUser
            && pPrt->hUser->bValid ()
            && AddHandleToList (pPrt)
            ) {

            return (HANDLE)pPrt;

        } else {

            if (pPrt->lpszName)
                memFreeStr (pPrt->lpszName);

            if (pPrt->hUser) {
                delete ( pPrt->hUser );
            }
            memFree (pPrt, sizeof(INET_HPRINTER));
        }
    }

    return NULL;
}

/*****************************************************************************\
* _ppprn_free_xcv_hprinter (Local Routine)
*
* Free a xcv printer handle.
*
\*****************************************************************************/
_inline VOID _ppprn_free_xcv_hprinter(
    HANDLE hPrinter)
{
    LPINET_XCV_HPRINTER pPrt;


    if (pPrt = (LPINET_XCV_HPRINTER)hPrinter) {

        memFreeStr (pPrt->lpszName);
        memFree(pPrt, sizeof(INET_XCV_HPRINTER));

    }
}

/*****************************************************************************\
* _ppprn_make_xcv_hprinter (Local Routine)
*
* Returns a xcv printer handle.
*
\*****************************************************************************/
HANDLE _ppprn_make_xcv_hprinter(
    PCINETMONPORT  pIniPort)
{
    LPINET_XCV_HPRINTER pPrt;


    if (pPrt = (LPINET_XCV_HPRINTER)memAlloc(sizeof(INET_XCV_HPRINTER))) {

        pPrt->dwSignature = IPO_XCV_SIGNATURE;
        pPrt->lpszName    = memAllocStr(pIniPort->GetPortName());
    }

    return pPrt;
}

/*****************************************************************************\
* ppprn_IppSetRsp (Local Callback Routine)
*
* Retrieves a SetPrinter response from the IPP server
*
\*****************************************************************************/
BOOL CALLBACK ppprn_IppSetRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    PCINETMONPORT   pIniPort,
    LPARAM          lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_PRN lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;

    if (hIpp = WebIppRcvOpen((WORD)(LPARAM)lParam)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile (pConnection, hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if ((bRet = lpRsp->bRet) == FALSE)
                        SetLastError(lpRsp->dwLastError);

                    WebIppFreeMem(lpRsp);

                    goto EndSetRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //

                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppprn_IppSetRsp - Err : Receive Data Error (dwRet=%d, LE=%d)"),
                                            dwRet, WebIppGetError(hIpp)));

                    SetLastError(ERROR_INVALID_DATA);

                    goto EndSetRsp;
                }

            } else {

                goto EndSetRsp;
            }
        }

EndSetRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* ppprn_Set (Local Routine)
*
* Sets a printer command.
*
\*****************************************************************************/
BOOL ppprn_Set(
    PCINETMONPORT   pIniPort,
    DWORD           dwCmd)
{
    PIPPREQ_SETPRN psp;
    REQINFO        ri;
    DWORD          dwRet;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    WORD           wReq;
    LPTSTR         lpszUsrName;
    BOOL           bRet = FALSE;


    // Create our ipp-reqest-structure.
    //
    if (lpszUsrName = GetUserName()) {

        psp = WebIppCreateSetPrnReq(dwCmd,
                                    lpszUsrName,
                                    pIniPort->GetPortName());


        memFreeStr(lpszUsrName);

        if (psp) {

            switch (dwCmd) {
            case PRINTER_CONTROL_PAUSE:
                wReq = IPP_REQ_PAUSEPRN;
                break;

            case PRINTER_CONTROL_RESUME:
                wReq = IPP_REQ_RESUMEPRN;
                break;

            case PRINTER_CONTROL_PURGE:
                wReq = IPP_REQ_CANCELPRN;
                break;

            default:
                wReq = 0;
                break;
            }


            // Convert the reqest to IPP, and perform the
            // post.
            //
            ZeroMemory(&ri, sizeof(REQINFO));
            ri.cpReq = CP_UTF8;
            ri.idReq = wReq;

            ri.fReq[0] = IPP_REQALL;
            ri.fReq[1] = IPP_REQALL;

            dwRet = WebIppSndData(wReq,
                                  &ri,
                                  (LPBYTE)psp,
                                  psp->cbSize,
                                  &lpIpp,
                                  &cbIpp);


            // The request-structure has been converted to IPP format,
            // so it is ready to go to the server.
            //
            if (dwRet == WEBIPP_OK) {

                bRet = pIniPort->SendReq(lpIpp,
                                                cbIpp,
                                                ppprn_IppSetRsp,
                                                (LPARAM)(wReq | IPP_RESPONSE),
                                                TRUE);

                WebIppFreeMem(lpIpp);

            } else {

                SetLastError(ERROR_OUTOFMEMORY);
            }

            WebIppFreeMem(psp);

        } else {

            SetLastError(ERROR_OUTOFMEMORY);
        }
    }

    return bRet;
}


VOID
_ppprn_working_thread (
    PENDDOCTHREADCONTEXT pThreadData)
{
    BOOL            bRet            = FALSE;
    PJOBMAP         pjm             = pThreadData->pjmJob;
    PCINETMONPORT   pIniPort        = pThreadData->pIniPort;
    static DWORD    cdwWaitTime     = 15000;

    DBGMSGT (DBG_LEV_CALLTREE, ("Enter  _ppprn_working_thread (%p)\n", pThreadData));

    pThreadData->pSidToken->SetCurrentSid ();
    delete pThreadData->pSidToken;
    pThreadData->pSidToken = NULL;

    semEnterCrit();

    pjmUpdateLocalJobStatus (pjm, JOB_STATUS_PRINTING);

    //
    // The document is cancelled
    //
    if (pjmChkState(pThreadData->pjmJob, PJM_CANCEL)) {

        bRet = TRUE;
    }
    else {

        // Refresh the notification handle
        //
        RefreshNotificationPort (pIniPort);


        bRet = pIniPort->EndDocPort(pjm);
    }

    //
    // Check this flags again, since we left CriticalSection during file transfer
    //
    if (pjmChkState(pThreadData->pjmJob, PJM_CANCEL)) {

        bRet = TRUE;
    }

    if (bRet) {
        //
        // Clear our spooling-state.  This will free up any spool-job-resources.
        //
        pjmClrState(pjm, PJM_SPOOLING);

        //
        // Invalidate both job and printer caches
        //
        pIniPort->InvalidateGetPrinterCache ();
        pIniPort->InvalidateEnumJobsCache ();
    }
    else {
        pjmUpdateLocalJobStatus (pjm, JOB_STATUS_ERROR);

    }

    // Refresh the notification handle
    //
    RefreshNotificationPort (pIniPort);

    //
    //  Clean the async thread flag
    //
    pjmClrState(pjm, PJM_ASYNCON);

    pIniPort->DecRef();

    semLeaveCrit();

    delete pThreadData;

    DBGMSGT (DBG_LEV_CALLTREE, ("Leave  _ppprn_working_thread (ret = %d)\n", bRet));
}


BOOL
_ppprn_end_docprinter_async (
    PCINETMONPORT       pIniPort,
    PJOBMAP             pjmJob)

{
    BOOL    bRet = FALSE;

    PENDDOCTHREADCONTEXT pThreadData = new ENDDOCTHREADCONTEXT;


    if (pThreadData) {
        pThreadData->pIniPort = pIniPort;
        pThreadData->pjmJob = pjmJob;
        pThreadData->pSidToken = new CSid;


        if (pThreadData->pSidToken && pThreadData->pSidToken->bValid ()) {
            HANDLE hThread;

            pjmSetState(pjmJob, PJM_ASYNCON);

            //
            // Increase the ref count of the port to make sure it is not deleted
            //

            pIniPort->IncRef();

            if (pIniPort->CreateTerminateEvent() &&
                (hThread = CreateThread (NULL,
                                         COMMITTED_STACK_SIZE,
                                         (LPTHREAD_START_ROUTINE)_ppprn_working_thread,
                                         (PVOID) pThreadData, 0, NULL))) {
                CloseHandle (hThread);
                bRet = TRUE;
            }
            else {

                //
                // Fail to create the thread
                //
                pIniPort->DecRef ();

                pjmClrState(pjmJob, PJM_ASYNCON);
            }
        }

        if (!bRet) {
            if (pThreadData->pSidToken) {
                delete (pThreadData->pSidToken);
                pThreadData->pSidToken = NULL;
            }

            delete (pThreadData);
        }
    }

    return bRet;
}

/*****************************************************************************\
* PP_OpenJobInfo
*
* Opens a job-information.  This is called at StartDoc timeframe when we
* need to start a spool-job.
*
\*****************************************************************************/
PJOBMAP PP_OpenJobInfo(
    HANDLE          hPrinter,
    PCINETMONPORT   pIniPort,
    LPTSTR          pDocName)
{
    PJOBMAP*        pjmList;
    LPINET_HPRINTER lpPrt = (LPINET_HPRINTER)hPrinter;
    LPTSTR          pUserName = GetUserName();


    pjmList = pIniPort->GetPJMList();

    if (lpPrt->pjmJob = pjmAdd(pjmList, pIniPort, pUserName, pDocName)) {

        // Set the state to spooling for our job-entry.  This wil
        // create the spool-file object.
        //
        pjmSetState(lpPrt->pjmJob, PJM_SPOOLING);

    }

    memFreeStr (pUserName);

    return lpPrt->pjmJob;
}


/*****************************************************************************\
* PP_CloseJobInfo
*
* Close our spool-job and clear out the information regarding a printjob from
* the printer.
*
\*****************************************************************************/
VOID PP_CloseJobInfo(
    HANDLE hPrinter)
{
    PJOBMAP*        pjmList;
    LPINET_HPRINTER lpPrt = (LPINET_HPRINTER)hPrinter;


    // Clear our spooling-state.  This will free up any spool-job-resources.
    //
    pjmClrState(lpPrt->pjmJob, PJM_SPOOLING);


    // If we had cancelled our print-job, then we can remove the
    // entry.
    //
    if (pjmChkState(lpPrt->pjmJob, PJM_CANCEL)) {

        pjmList = ((PCINETMONPORT)(lpPrt->hPort))->GetPJMList();

        pjmDel(pjmList, lpPrt->pjmJob);
    }


    // Clear out or spool-status.
    //
    lpPrt->pjmJob = NULL;
}

VOID PP_CloseJobInfo2(
    HANDLE hPrinter)
{
    PJOBMAP*        pjmList;
    LPINET_HPRINTER lpPrt = (LPINET_HPRINTER)hPrinter;

    // Clear out or spool-status.
    //
    lpPrt->pjmJob = NULL;
}


/*****************************************************************************\
* PPAbortPrinter
*
* Deletes a printer's spool file if the printer is configured for spooling.
* Returns TRUE if successful, FALSE if an error occurs.
*
\*****************************************************************************/
BOOL PPAbortPrinter(
    HANDLE hPrinter)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPAbortPrinter(%08lX)"), hPrinter));


    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        if ( PP_ChkStatus(hPrinter, PP_STARTDOC) &&
            !PP_ChkStatus(hPrinter, PP_ENDDOC)) {

            if (bRet = pIniPort->AbortPort(PP_GetJobInfo(hPrinter))) {

                // If this call was successful, the job-info
                // will have been freed.  Therefore, it is OK
                // to set the printer-jobreq to NULL.
                //
                PP_SetStatus(hPrinter, PP_CANCELLED);
                PP_ClrStatus(hPrinter, PP_STARTDOC);
                PP_CloseJobInfo(hPrinter);
            }

        } else {

            if (PP_ChkStatus(hPrinter, PP_CANCELLED))
                SetLastError(ERROR_PRINT_CANCELLED);
            else
                SetLastError(ERROR_SPL_NO_STARTDOC);

            bRet = TRUE;
        }
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPClosePrinter
*
* Closes a printer that was previously opened with PPOpenPrinter.  Returns
* TRUE if successful, FALSE if an error occurs.
*
\*****************************************************************************/
BOOL PPClosePrinter(
    HANDLE hPrinter)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;
    BOOL   bDeletePending = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPClosePrinter: Printer(%08lX)"), hPrinter));

    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandleForClose(hPrinter, &bDeletePending) ) {

        if (bDeletePending) {

            bRet = gpInetMon->InetmonReleasePort(pIniPort);
            _ppprn_free_hprinter(hPrinter);

        }
        else {


            if ( PP_ChkStatus(hPrinter, PP_STARTDOC) &&
                !PP_ChkStatus(hPrinter, PP_ENDDOC)) {

                PP_SetStatus(hPrinter, PP_ENDDOC);

                pIniPort->EndDocPort(PP_GetJobInfo(hPrinter));

                PP_ClrStatus(hPrinter, (PP_STARTDOC | PP_ENDDOC));
                PP_CloseJobInfo(hPrinter);
            }


            // Our write-port does leave the crit-sect.  If this
            // routine is called while we're still in an end-doc, then
            // we will set a zombie-flag and let the End-Doc clean up
            // the handle for us.
            //
            if (PP_ChkStatus(hPrinter, PP_ENDDOC)) {

                bRet = TRUE;

                PP_SetStatus(hPrinter, PP_ZOMBIE);

            } else {

                bRet = gpInetMon->InetmonClosePort(pIniPort, hPrinter );
                _ppprn_free_hprinter(hPrinter);
            }
        }
    }

    else if (utlValidateXcvPrinterHandle(hPrinter) ) {

        //
        // We don't need to dec-ref on the http port for XCV handle
        //

        //
        // Free memory
        //
        _ppprn_free_xcv_hprinter(hPrinter);
    }

    semLeaveCrit();

    return bRet;
}

/*****************************************************************************\
* PPEndDocPrinter
*
* Ends a print job on the specified printer.  Returns TRUE if successful,
* FALSE otherwise.
*
\*****************************************************************************/

BOOL PPEndDocPrinter(
    HANDLE hPrinter)
{
    PCINETMONPORT  pIniPort;
    PJOBMAP pjmJob;
    DWORD   dwLE;
    BOOL    bRet = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPEndDocPrinter: Printer(%08lX)"), hPrinter));

    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        // Verify that we are in a StartDoc.
        //
        if ( PP_ChkStatus(hPrinter, PP_STARTDOC) &&
            !PP_ChkStatus(hPrinter, PP_ENDDOC)) {

            PP_SetStatus(hPrinter, PP_ENDDOC);


            // Get the job we're dealing with.
            //
            pjmJob = PP_GetJobInfo(hPrinter);


            // End the job.  This closes our spooling
            // and submits it to the server.  If our job was
            // cancelled at anytime prior to EndDoc(), then we should
            // only remove the local-spool-job and not hit the server.
            //
            if (pjmChkState(pjmJob, PJM_CANCEL)) {

                bRet = TRUE;

            } else {

                if ((bRet = _ppprn_end_docprinter_async(pIniPort, pjmJob)) == FALSE)
                    dwLE = ERROR_CAN_NOT_COMPLETE;

            }

            // Clear our flags so others can use the
            // printer.
            //
            PP_ClrStatus(hPrinter, (PP_STARTDOC | PP_ENDDOC));

            PP_CloseJobInfo2(hPrinter);

            // Since the end-doc-port leaves the crit-sect, there's
            // the possibility that the printer-handle has been
            // closed.  If so, check for zombie-status and delete
            // the printer-handle accordingly.
            //
            if (PP_ChkStatus(hPrinter, PP_ZOMBIE)) {

                gpInetMon->InetmonClosePort(pIniPort, hPrinter);

                _ppprn_free_hprinter(hPrinter);
            }

        } else {

            if (PP_ChkStatus(hPrinter, PP_CANCELLED))
                dwLE = ERROR_PRINT_CANCELLED;
            else
                dwLE = ERROR_SPL_NO_STARTDOC;
        }

    } else {

        dwLE = ERROR_INVALID_HANDLE;
    }

    semLeaveCrit();

    if (bRet == FALSE)
        SetLastError(dwLE);

    return bRet;
}

/*****************************************************************************\
* PPEndPagePrinter
*
* Informs the printer that the data sent with WritePrinter since the last
* BeginPage functions, constitutes a page.  Returns TRUE if successful.
* Otherwise, it returns FALSE.
*
\*****************************************************************************/
BOOL PPEndPagePrinter(
    HANDLE hPrinter)
{
    BOOL bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPEndPagePrinter: hPrinter(%08lX)"), hPrinter));

    semEnterCrit();

    if (utlValidatePrinterHandle(hPrinter) != NULL) {

        if (PP_ChkStatus(hPrinter, PP_CANCELLED))
            SetLastError(ERROR_PRINT_CANCELLED);
        else
            bRet = TRUE;
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPOpenPrinter
*
* Obtains a handle for the specified printer (queue).
*
* NOTE: We're going to delay the validation of the printer-port-name until
*       later (StartDoc), as to handle cases where the server is down.  If
*       this is not done, we appear to hang at the UI as we attempt to
*       send a request to the server.
*
* Return Value:
*
*   We have to return the correct router code to the spooler
*
*       ROUTER_* status code:
*
*    ROUTER_SUCCESS, phPrinter holds return handle, name cached
*    ROUTER_UNKNOWN, printer not recognized, error updated
*    ROUTER_STOP_ROUTING, printer recognized, but failure, error updated
*
*
\*****************************************************************************/
BOOL PPOpenPrinter(
    LPTSTR             lpszPrnName,
    LPHANDLE           phPrinter,
    LPPRINTER_DEFAULTS pDefaults)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;
    DWORD  dwRet = ROUTER_UNKNOWN;
    DWORD  dwLE;
    BOOL   bXcv = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPOpenPrinter: Name(%s)"), lpszPrnName));

    semEnterCrit();

    // Open the port for the printer, and create the true
    // printer handle.
    //

    if (pIniPort = gpInetMon->InetmonOpenPort(lpszPrnName, &bXcv)) {

        if (!bXcv) {
            // Not an XcvOpen call

            if (*phPrinter = _ppprn_make_hprinter(pIniPort, lpszPrnName)) {

                if (__ppprn_inc_user_refcout( *phPrinter ) != MAXDWORD ) {
                    dwRet = ROUTER_SUCCESS;
                } else {
                    _ppprn_free_hprinter( *phPrinter );
                    // This will also free the hUser
                    *phPrinter = NULL;
                    // Make sure we don't return anything and the router stops.
                    dwRet = ROUTER_STOP_ROUTING;
                }

            } else {

                SetLastError(ERROR_OUTOFMEMORY);

                gpInetMon->InetmonClosePort(pIniPort, NULL );
                dwRet = ROUTER_STOP_ROUTING;
            }
        }
        else {
            // XcvOpen call

            if (*phPrinter = _ppprn_make_xcv_hprinter(pIniPort)) {
                    dwRet = ROUTER_SUCCESS;
            }
            else {
                SetLastError(ERROR_OUTOFMEMORY);

                //
                // We don't need to dec-ref port since we never add-ref in XCV Open
                //

                dwRet = ROUTER_STOP_ROUTING;
            }
        }
    }

    semLeaveCrit();

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPOpenPrinter : Return Value(%d), LastError(%d)"), dwRet, GetLastError()));

    return dwRet;
}

/*****************************************************************************\
* PPStartDocPrinter
*
* Ends a print job on the specified printer.  Returns a print job ID if
* successful.  Otherwise, it returns zero.
*
\*****************************************************************************/
DWORD PPStartDocPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE pDocInfo)
{
    PCINETMONPORT pIniPort = NULL;
    PJOBMAP pjmJob;
    DWORD   idJob = 0;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPStartDocPrinter: Printer(%08lX) dwLevel(%d)"), hPrinter, dwLevel));


    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        // Look at the support levels, then do the StartDocPrinter on
        // the port.
        //
        switch (dwLevel) {

        case PRINT_LEVEL_1:

            // Serialize access to the port.  Don't allow startdoc on
            // the printer if one is already in progress.
            //
            if (PP_ChkStatus(hPrinter, PP_STARTDOC)) {

                SetLastError(ERROR_BUSY);

            } else {

                if (pjmJob = PP_OpenJobInfo(hPrinter, pIniPort, ((PDOC_INFO_1) pDocInfo)->pDocName)) {

                    // Get the JobId for the start-doc, then set the info
                    // into the printer-handle.
                    //
                    if (pIniPort->StartDocPort(dwLevel, pDocInfo, pjmJob)) {

                        idJob = pjmJobId(pjmJob, PJM_LOCALID);

                        PP_ClrStatus(hPrinter, PP_CANCELLED);
                        PP_SetStatus(hPrinter, (PP_STARTDOC | PP_FIRSTWRITE));

                    } else {

                        PP_CloseJobInfo(hPrinter);
                    }

                } else {

                    SetLastError(ERROR_OUTOFMEMORY);
                }
            }
            break;

        default:
            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPStartDocPrinter: Invalid Level (%d)"), dwLevel));
            SetLastError(ERROR_INVALID_LEVEL);
            break;
        }
    }

    semLeaveCrit();

    return idJob;
}


/*****************************************************************************\
* PPStartPagePrinter
*
* Informs the spool subsystem that a page is about to be started on this
* printer.  Returns TRUE if successful.  Otherwise, FALSE if an error occurs.
*
\*****************************************************************************/
BOOL PPStartPagePrinter(
    HANDLE hPrinter)
{
    BOOL bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPStartPagePrinter: hPrinter(%08lX)"), hPrinter));

    semEnterCrit();

    if (utlValidatePrinterHandle(hPrinter) != NULL) {

        if (PP_ChkStatus(hPrinter, PP_CANCELLED))
            SetLastError(ERROR_PRINT_CANCELLED);
        else
            bRet = TRUE;
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPWritePrinter
*
* Sends the data pointed to by pBuf to the specified printer.  Returns TRUE
* if successful.  Otherwise, it returns FALSE.
*
\*****************************************************************************/
BOOL PPWritePrinter(
    HANDLE  hPrinter,
    LPVOID  lpvBuf,
    DWORD   cbBuf,
    LPDWORD pcbWr)
{
    PCINETMONPORT  pIniPort;
    PJOBMAP pjmJob;
    BOOL    bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPWritePrinter: Printer(%08lX)"), hPrinter));


    semEnterCrit();

    *pcbWr = 0;

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        // If we're in a start-doc, and end-doc hasn't been
        // called, then we can still write to the port.
        //
        if ( PP_ChkStatus(hPrinter, PP_STARTDOC) &&
            !PP_ChkStatus(hPrinter, PP_ENDDOC)) {


            pjmJob = PP_GetJobInfo(hPrinter);


            // If we received a SetJob(CANCEL), during the print-spooling
            // process, then we need to mark our job as done.
            //
            if (!pjmChkState(pjmJob, PJM_CANCEL)) {

                bRet = pIniPort->WritePort(pjmJob, (LPBYTE) lpvBuf, cbBuf, pcbWr);

                pjmAddJobSize (pjmJob, *pcbWr);

                // We do not need to update the cache since the job info is stored locally
                //
                RefreshNotificationPort (pIniPort);

            } else {

                bRet = TRUE;

                if (pIniPort->AbortPort(pjmJob)) {

                    // If this call was successful, the job-info
                    // will have been freed.  Therefore, it is OK
                    // to set the printer-jobreq to NULL.
                    //
                    PP_SetStatus(hPrinter, PP_CANCELLED);
                    PP_ClrStatus(hPrinter, PP_STARTDOC);
                    PP_CloseJobInfo(hPrinter);
                }
            }

        } else {

            if (PP_ChkStatus(hPrinter, PP_CANCELLED))
                SetLastError(ERROR_PRINT_CANCELLED);
            else
                SetLastError(ERROR_SPL_NO_STARTDOC);
        }
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPSetPrinter
*
* Set printer command.
*
\*****************************************************************************/
BOOL PPSetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE pbPrinter,
    DWORD  dwCmd)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPSetPrinter: Printer(%08lX)"), hPrinter));


    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {


        // Set printer parameters.
        //
        switch (dwLevel) {

        case PRINT_LEVEL_0:

            // Do not set parameters. (0) represents "no-command".
            //
            switch (dwCmd) {

            case PRINTER_CONTROL_PAUSE:
            case PRINTER_CONTROL_RESUME:
            case PRINTER_CONTROL_PURGE:
                bRet = ppprn_Set(pIniPort, dwCmd);

                if (bRet) {
                    pIniPort->InvalidateGetPrinterCache ();

                    if (dwCmd == PRINTER_CONTROL_PURGE) {
                        //
                        //  Clean job cache if the command is to cancel all documents
                        //
                        pIniPort->InvalidateEnumJobsCache ();
                    }

                    RefreshNotification((LPINET_HPRINTER)hPrinter);
                }

                break;

            case 0:
                bRet = TRUE;
                break;
            }
            break;

        default:
            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPSetPrinter: Invalid Level (%d)"), dwLevel));
            SetLastError(ERROR_INVALID_LEVEL);
            break;
        }
    }

    semLeaveCrit();

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\resource.h ===
#define IDS_DISPLAY_NAME            1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\sem.h ===
/*****************************************************************************\
* MODULE: sem.h
*
* Header file for the semaphore/crit-sect handling.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   24-Aug-1997 HWP-Guys    Created.
*
\*****************************************************************************/
#ifndef _INETPPSEM_H
#define _INETPPSEM_H

#ifdef DEBUG

/*****************************************************************************\
* _sem_dbg_EnterCrit
*
\*****************************************************************************/
_inline VOID _sem_dbg_EnterCrit(VOID)
{
    EnterCriticalSection(&g_csMonitorSection);

    g_dwCritOwner = GetCurrentThreadId();
}

/*****************************************************************************\
* _sem_dbg_LeaveCrit
*
\*****************************************************************************/
_inline VOID _sem_dbg_LeaveCrit(VOID)
{
    g_dwCritOwner = 0;

    LeaveCriticalSection(&g_csMonitorSection);
}

/*****************************************************************************\
* _sem_dbg_CheckCrit
*
\*****************************************************************************/
_inline VOID _sem_dbg_CheckCrit(VOID)
{
    DWORD dwCurrent = GetCurrentThreadId();

    DBG_ASSERT((dwCurrent == g_dwCritOwner), (TEXT("Assert: _sem_dbg_CheckCrit: Thread(%d), Owner(%d)"), dwCurrent, g_dwCritOwner));
}

#define semEnterCrit() _sem_dbg_EnterCrit()
#define semLeaveCrit() _sem_dbg_LeaveCrit()
#define semCheckCrit() _sem_dbg_CheckCrit()

#else

#define semEnterCrit() EnterCriticalSection(&g_csMonitorSection)
#define semLeaveCrit() LeaveCriticalSection(&g_csMonitorSection)
#define semCheckCrit() {}

#endif

_inline VOID semSafeLeaveCrit(PCINETMONPORT pIniPort)
{
    pIniPort->IncRef ();
    semLeaveCrit();
}

_inline VOID semSafeEnterCrit(PCINETMONPORT pIniPort)
{
    semEnterCrit();
    pIniPort->DecRef ();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\pusrdata.cxx ===
/*****************************************************************************\
* MODULE:       pusrdata.hxx
*
* PURPOSE:      This specialises the user data class to keep track of data
*               useful to a basic connection port.
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     1/11/2000  mlawrenc    Implemented
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"

CPortUserData::CPortUserData()

/*++

Constructor:

    Default constructor for Port User Information.

--*/
  : CUserData(),
    m_lpszUserName (NULL),
    m_lpszPassword (NULL),
    m_bNeverPopup (FALSE) {

    if (m_bValid)
        m_bValid = _GetLogonSession(m_lastLogonTime);
}

CPortUserData::CPortUserData (
    LPTSTR lpszUserName,
    LPTSTR lpszPassword,
    BOOL   bNeverPopup)
/*++

Constructor:

    Constructor for the CPortUserData used for dialogue control

Arguments:
    lpszUserName    - User name that this user has authenticated as on this port.
    lpszPassword    - Password that the user authenticated under
    bNeverPopup     - Whether user pushed cancel or not.

--*/
  : CUserData(),
    m_lpszUserName (NULL),
    m_lpszPassword (NULL),
    m_bNeverPopup (bNeverPopup) {

    if (m_bValid) {
        m_bValid = _GetLogonSession (m_lastLogonTime) &&
                   AssignString (m_lpszUserName, lpszUserName) &&
                   AssignString (m_lpszPassword, lpszPassword);
    }
}

CPortUserData::~CPortUserData()
/*++

Destructor:

    Destructor for Port User Data.

--*/
    {
    LocalFree (m_lpszUserName);
    LocalFree (m_lpszPassword);
}


BOOL
CPortUserData::SetPassword (
    LPTSTR lpszPassword)
{
    if (m_bValid) {
        m_bValid = AssignString (m_lpszPassword, lpszPassword);
    }
    return m_bValid;
}

BOOL
CPortUserData::SetUserName (
    LPTSTR lpszUserName)
{
    if (m_bValid) {
        m_bValid = AssignString (m_lpszUserName, lpszUserName);
    }
    return m_bValid;
}

BOOL
CPortUserData::SetPopupFlag (
    BOOL bNeverPopup)
/*++

Routine Description:

    Set the fact that we should not pop up the dialogue box again,
    Record the logon time when we made the decision, if the logon time
    advances, we will disregard this flag.

Arguments:
    bNeverPopup - TRUE if the user pushed Cancel.

Return Value:

    TRUE if we could get the logon time.

--*/
    {
    if (m_bNeverPopup = bNeverPopup) {
        m_bValid = _GetLogonSession (m_lastLogonTime);
    }

    return m_bValid;
}


BOOL
CPortUserData::GetPopupFlag (void)
{
    FILETIME    LogonTime;

    if (m_bNeverPopup) {

        if (_GetLogonSession (LogonTime)) {

            if (CompareFileTime (&LogonTime, &m_lastLogonTime)) { // New logon session
                  m_bNeverPopup = FALSE;
            }
        }
    }

    return m_bNeverPopup;
}

BOOL
CPortUserData::_GetLogonSession (FILETIME &LogonTime)
{
    // Read the registry and check if it is a new logon session

    BOOL        bRet             = FALSE;
    HKEY        hProvidersKey    = NULL;
    DWORD       dwType           = REG_BINARY;
    DWORD       dwSize           = sizeof (FILETIME);

    LPTSTR      szPrintProviders = g_szRegPrintProviders;
    LPTSTR      szLogonTime      = TEXT ("LogonTime");
    HANDLE      hToken;

    if (hToken = RevertToPrinterSelf()) {


        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          szPrintProviders,
                                          0,
                                          KEY_QUERY_VALUE,
                                          &hProvidersKey) &&

            ERROR_SUCCESS == RegQueryValueEx (hProvidersKey,
                                              szLogonTime,
                                              0,
                                              &dwType,
                                              (LPBYTE) &LogonTime,
                                              &dwSize)) {
            bRet = TRUE;

            RegCloseKey (hProvidersKey);
        }

        if (!ImpersonatePrinterClient(hToken))
            bRet = FALSE;
    }

    return bRet;
}


CPortUserData &
CPortUserData::operator=(const CPortUserData &rhs) {
    LocalFree (m_lpszUserName);
    LocalFree (m_lpszPassword);

    m_lpszUserName = NULL;
    m_lpszPassword = NULL;
    m_bNeverPopup = FALSE;

    this->CUserData::operator= ( rhs );

    if (m_bValid) {
        m_bNeverPopup = rhs.m_bNeverPopup;
        m_bValid = AssignString (m_lpszUserName, rhs.m_lpszUserName) &&
                   AssignString (m_lpszPassword, rhs.m_lpszPassword);
    }

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\sid.cxx ===
#include "precomp.h"
#include "priv.h"

CSid::CSid ():
    m_hToken (NULL)
{
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_IMPERSONATE,
                         TRUE,
                         &m_hToken)) {

        DBG_MSG (DBG_LEV_CALLTREE, (_T ("OpenThreadToken failed: %d\n"), GetLastError()));
        m_bValid = FALSE;

    } else

        m_bValid =  TRUE;
}

CSid::~CSid()
{
    if (m_hToken) {
        CloseHandle (m_hToken);
    }
}



BOOL
CSid::SetCurrentSid ()
{
#ifdef DEBUG
    WCHAR UserName[256];
    DWORD cbUserName=256;

    GetUserName(UserName, &cbUserName);

    DBG_MSG (DBG_LEV_CALLTREE, (_T ("SetCurrentSid BEFORE: user name is %ws\n"), UserName));
#endif

    NtSetInformationThread(NtCurrentThread(), ThreadImpersonationToken,
                           &m_hToken, sizeof(m_hToken));

#ifdef DEBUG
    cbUserName = 256;

    GetUserName(UserName, &cbUserName);

    DBG_MSG (DBG_LEV_CALLTREE, (_T ("SetCurrentSid AFTER: user name is %ws\n"), UserName));
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\sources.inc ===
MAJORCOMP=windows
MINORCOMP=inetpp

TARGETNAME=inetpp

TARGETPATH=obj

TARGETTYPE=DYNLINK

DELAYLOAD=wininet.dll
DLOAD_ERROR_HANDLER=inetpp.dll

TARGETLIBS= \
         $(SDK_LIB_PATH)\version.lib              \
         $(SDK_LIB_PATH)\wininet.lib              \
         $(NET_LIB_PATH)\icmp.lib                 \
         $(LIB_PLATFORM_PATH)\*\gdi32.lib         \
         $(LIB_PLATFORM_PATH)\*\user32.lib        \
         $(LIB_PLATFORM_PATH)\*\kernel32.lib      \
         $(LIB_PLATFORM_PATH)\*\advapi32.lib      \
         $(LIB_PLATFORM_PATH)\*\shell32.lib       \
         $(LIB_PLATFORM_PATH)\*\winspool.lib      \
         $(PROJECT_ROOT)\lib\$(O)\spoolss.lib     \
         $(SDK_LIB_PATH)\crypt32.lib              \
         $(SDK_LIB_PATH)\ws2_32.lib               \
         $(PROJECT_ROOT)\lib\$(O)\spllib.lib      \
         $(PROJECT_ROOT)\lib\$(O)\inetlib.lib

DLLENTRY=_DllMainCRTStartup

USE_MSVCRT=1

INCLUDES=.;..;..\..\inc;$(PROJECT_ROOT)\print\spooler\inc;

DLLDEF = ..\inetpp.def

SOURCES=..\inetpp.rc    \
        ..\cachemgr.cxx \
        ..\debug.cxx    \
        ..\mem.cxx      \
        ..\globals.cxx  \
        ..\inetport.cxx \
        ..\inetpp.cxx   \
        ..\ppinfo.cxx   \
        ..\ppinit.cxx   \
        ..\ppjobs.cxx   \
        ..\ppport.cxx   \
        ..\ppprn.cxx    \
        ..\spljob.cxx   \
        ..\splpjm.cxx   \
        ..\stubs.cxx    \
        ..\util.cxx     \
        ..\inetwrap.cxx \
        ..\portmgr.cxx  \
        ..\anycon.cxx   \
        ..\ping.cxx     \
        ..\stream.cxx   \
        ..\ppchange.cxx \
        ..\ntcon.cxx    \
        ..\othercon.cxx \
        ..\userdata.cxx \
        ..\pusrdata.cxx \
        ..\lusrdata.cxx \
        ..\config.cxx   \
        ..\anonycon.cxx \
        ..\sid.cxx      \
        ..\xcv.cxx

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\sid.h ===
#ifndef _CSID_H
#define _CSID_H

class CSid
{
public:
    CSid ();
    ~CSid();

    inline BOOL 
    bValid () CONST {
        return m_bValid;
    }

    BOOL         
    SetCurrentSid ();

private:
    HANDLE m_hToken;
    BOOL m_bValid;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\spljob.h ===
/*****************************************************************************\
* MODULE: spljob.h
*
* Header file for the local-jobfile-spooling.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#ifndef _SPLJOB_H
#define _SPLJOB_H

#define SPLFILE_SPL 0   // Specifies a file extension of .spl.
#define SPLFILE_TMP 1   // Specifies a file extension of .tmp.

class CFileStream;
    
typedef struct _SPLFILE {

    LPTSTR      lpszFile;    // Name of file.
    HANDLE      hFile;       // Handle to file.
    CFileStream *pStream;    // Stream interface

} SPLFILE;
typedef SPLFILE *PSPLFILE;
typedef SPLFILE *NPSPLFILE;
typedef SPLFILE *LPSPLFILE;

HANDLE SplCreate(DWORD, DWORD);
BOOL   SplFree(HANDLE);
BOOL   SplWrite(HANDLE, LPBYTE, DWORD, LPDWORD);
BOOL   SplWrite(HANDLE  hSpl, CStream *pStream);

CFileStream* SplLock(HANDLE hSpl);
BOOL   SplUnlock(HANDLE);
BOOL   SplClose(HANDLE);
BOOL   SplOpen(HANDLE);
VOID   SplClean(VOID);


/*****************************************************************************\
* SplFileName
*
\*****************************************************************************/
_inline LPCTSTR SplFileName(
    HANDLE hSpl)
{
    return (hSpl ? ((PSPLFILE)hSpl)->lpszFile : NULL);
}


/*****************************************************************************\
* SplFileSize
*
\*****************************************************************************/
_inline DWORD SplFileSize(
    HANDLE hSpl)
{
    return (hSpl ? GetFileSize(((PSPLFILE)hSpl)->hFile, NULL) : 0);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\spljob.cxx ===
/*****************************************************************************\
* MODULE: spljob.c
*
* This module contains the routines to deal with spooling a job to file.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*   14-Nov-1997 ChrisWil    Added local-spooling functionality.
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* Spl_GetCurDir
*
* Returns string indicating current-directory.
*
\*****************************************************************************/
LPTSTR Spl_GetCurDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;


    cbSize = GetCurrentDirectory(0, NULL);

    if (cbSize && (lpszDir = (LPTSTR)memAlloc((cbSize * sizeof(TCHAR)))))
        GetCurrentDirectory(cbSize, lpszDir);

    return lpszDir;
}


/*****************************************************************************\
* Spl_GetDir
*
* Returns the spooler-directory where print-jobs are processed.
*
\*****************************************************************************/
LPTSTR Spl_GetDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;

    if (*g_szDefSplDir)
    {
        size_t uSize = lstrlen (g_szDefSplDir) + 1;

        lpszDir = (LPTSTR) memAlloc(sizeof (TCHAR) * uSize);

        if (lpszDir)
        {
            StringCchCopy(lpszDir, uSize, g_szDefSplDir);
        }
    }

    return lpszDir;
}


/*****************************************************************************\
* Spl_MemCheck  (Local Routine)
*
* This routine checks for out-of-disk-space and out-of-memory conditions.
*
\*****************************************************************************/
VOID Spl_MemCheck(
    LPCTSTR lpszDir)
{
    ULARGE_INTEGER i64FreeBytesToCaller;
    ULARGE_INTEGER i64TotalBytes;
    LPTSTR lpszRoot;
    LPTSTR lpszPtr;


    // Look for out-of-diskspace
    //
    if (lpszRoot = memAllocStr(lpszDir)) {

        // Set the path to be only a root-drive-path.
        //
        if (lpszPtr = utlStrChr(lpszRoot, TEXT('\\'))) {

            lpszPtr++;

            if (*lpszPtr != TEXT('\0'))
                *lpszPtr = TEXT('\0');
        }

        // Get the drive-space information.
        //
        if (GetDiskFreeSpaceEx (lpszRoot, &i64FreeBytesToCaller, &i64TotalBytes, NULL)) {

            // We'll assume out-of-disk-space for anything less
            // then MIN_DISK_SPACE.
            //
            if (i64FreeBytesToCaller.QuadPart <= MIN_DISK_SPACE) {

                DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : _inet_MemCheck : Out of disk space.")));

                SetLastError(ERROR_DISK_FULL);
            }
        }

        memFreeStr(lpszRoot);

    } else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : _inet_MemCheck : Out of memory.")));

        SetLastError(ERROR_OUTOFMEMORY);
    }
}


/*****************************************************************************\
* Spl_OpnFile  (Local Routine)
*
* This routine creates/opens a spool-file.
*
\*****************************************************************************/
HANDLE spl_OpnFile(
    LPCTSTR lpszFile)
{
    HANDLE hFile;

    hFile = CreateFile(lpszFile,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);


    return ((hFile && (hFile != INVALID_HANDLE_VALUE)) ? hFile : NULL);
}


/*****************************************************************************\
* Spl_BldFile  (Local Routine)
*
* This routine builds a spool-file-name.  The returned file name is of the form.
* c:\windows\system32\spool\printers\splnnn.tmp or
* c:\windows\system32\spool\printers\tmpnnn.tmp
*
* The idJob argument is not used, it was previously used when the file
* name was derived from the job id.  This is not done anymore because it
* leads to file name squatting issues in the spool directory.
*
\*****************************************************************************/
LPTSTR spl_BldFile(
    DWORD idJob,
    DWORD dwType)
{
    static CONST TCHAR s_szSpl[] = TEXT("spl");
    static CONST TCHAR s_szTmp[] = TEXT("tmp");

    HRESULT hRetval             = E_FAIL;
    LPTSTR  pszDir              = NULL;
    LPTSTR  pszFile             = NULL;
    LPTSTR  pszSplFile          = NULL;
    UINT    cchSize             = 0;
    LPCTSTR pszPrefix           = dwType == SPLFILE_TMP ? s_szTmp : s_szSpl;
    TCHAR   szBuffer[MAX_PATH]  = {0};

    pszDir = Spl_GetDir();

    hRetval = pszDir ? S_OK : GetLastErrorAsHResultAndFail();

    if (SUCCEEDED(hRetval))
    {
        hRetval = GetTempFileName(pszDir, pszPrefix, 0, szBuffer) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        cchSize = _tcslen(szBuffer) + 1;

        pszFile = (LPTSTR)memAlloc(cchSize * sizeof(TCHAR));

        hRetval = pszFile ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = StringCchCopy(pszFile, cchSize, szBuffer);
    }

    if (SUCCEEDED(hRetval))
    {
        pszSplFile  = pszFile;
        pszFile     = NULL;
    }

    if (pszFile)
    {
        memFreeStr(pszFile);
    }

    if (pszDir)
    {
        memFreeStr(pszDir);
    }

    if (FAILED(hRetval))
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return pszSplFile;
}


/*****************************************************************************\
* SplLock
*
* Open a stream interface to the spool file
*
\*****************************************************************************/
CFileStream* SplLock(
    HANDLE hSpl)
{
    PSPLFILE pSpl;
    CFileStream *pStream = NULL;

    if (pSpl = (PSPLFILE)hSpl) {
        pStream = new CFileStream (pSpl->hFile);
        pSpl->pStream = pStream;
    }

    return pStream;
}


/*****************************************************************************\
* SplUnlock
*
* Close our file-mapping.
*
\*****************************************************************************/
BOOL SplUnlock(
    HANDLE hSpl)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;

    if (pSpl = (PSPLFILE)hSpl) {

        if (pSpl->pStream) {
            delete pSpl->pStream;

            pSpl->pStream = NULL;
        }
    }

    return bRet;
}


/*****************************************************************************\
* SplWrite
*
* Write data to our spool-file.
*
\*****************************************************************************/
BOOL SplWrite(
    HANDLE  hSpl,
    LPBYTE  lpData,
    DWORD   cbData,
    LPDWORD lpcbWr)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;
    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {

        if (pSpl = (PSPLFILE)hSpl) {

            // Write the data to our spool-file.
            //
            bRet = WriteFile(pSpl->hFile, lpData, cbData, lpcbWr, NULL);


            // If we failed, or our bytes written aren't what we
            // expected, then we need to check for out-of-memory.
            //
            if (!bRet || (cbData != *lpcbWr))
                Spl_MemCheck(pSpl->lpszFile);
        }

        if (!ImpersonatePrinterClient(hToken))
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

/*****************************************************************************\
* SplWrite
*
* Write data to our spool-file.
*
\*****************************************************************************/
BOOL SplWrite(
    HANDLE  hSpl,
    CStream *pStream)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;
    static   DWORD cbBufSize = 32 * 1024;    //Copy size is 32K
    PBYTE    pBuf;
    DWORD    cbTotal;

    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {

        if (pSpl = (PSPLFILE)hSpl) {

            pBuf = new BYTE[cbBufSize];

            if (pBuf && pStream->GetTotalSize (&cbTotal)) {

                DWORD cbRemain = cbTotal;

                while (cbRemain > 0 && bRet) {

                    DWORD cbToRead = cbRemain > cbBufSize? cbBufSize:cbRemain;
                    DWORD cbRead, cbWritten;

                    if (pStream->Read (pBuf, cbToRead, &cbRead) && cbToRead == cbRead) {

                        // Write the data to our spool-file.
                        //
                        bRet = WriteFile(pSpl->hFile, pBuf, cbRead, &cbWritten, NULL)
                               && cbWritten == cbRead;

                        if (bRet) {
                            cbRemain -= cbToRead;
                        }

                    }
                    else
                        bRet = FALSE;
                }

                // If we failed, or our bytes written aren't what we
                // expected, then we need to check for out-of-memory.
                //
                if (!bRet)
                    Spl_MemCheck(pSpl->lpszFile);

            }

            if (pBuf) {
                delete [] pBuf;
            }

        }

        if (!ImpersonatePrinterClient(hToken))
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL PrivateSplFree(
    HANDLE hSpl)
{
    BOOL     bRet = FALSE;
    PSPLFILE pSpl;

    if (pSpl = (PSPLFILE)hSpl) {

        if (pSpl->pStream)
            delete pSpl->pStream;

        if (pSpl->hFile)
            CloseHandle(pSpl->hFile);

        bRet = DeleteFile(pSpl->lpszFile);

        if (pSpl->lpszFile)
            memFreeStr(pSpl->lpszFile);

        memFree(pSpl, sizeof(SPLFILE));
    }
    return bRet;
}

/*****************************************************************************\
* SplFree  (Local Routine)
*
* Free our spool-file.  This will delete all information regarding the
* file.
*
\*****************************************************************************/
BOOL SplFree(
    HANDLE hSpl)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;
    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {
        bRet = PrivateSplFree (hSpl);

        if (!ImpersonatePrinterClient(hToken))
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

/*****************************************************************************\
* SplCreate (Local Routine)
*
* Create a unique file for processing our spool-file.
*
\*****************************************************************************/
HANDLE SplCreate(
    DWORD idJob,
    DWORD dwType)
{
    PSPLFILE pSpl = NULL;
    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {

        if (pSpl = (PSPLFILE) memAlloc(sizeof(SPLFILE))) {

            if (pSpl->lpszFile = spl_BldFile(idJob, dwType)) {

                if (pSpl->hFile = spl_OpnFile(pSpl->lpszFile)) {

                    pSpl->pStream = NULL;

                } else {

                    memFreeStr(pSpl->lpszFile);

                    goto SplFail;
                }

            } else {

    SplFail:
                memFree(pSpl, sizeof(SPLFILE));
                pSpl = NULL;
            }
        }

        if (!ImpersonatePrinterClient(hToken))
        {
            (VOID)PrivateSplFree (pSpl);
            pSpl = NULL;
        }
    }

    return (HANDLE)pSpl;
}


/*****************************************************************************\
* SplOpen  (Local Routine)
*
* Open the handle to our spool-file.
*
\*****************************************************************************/
BOOL SplOpen(
    HANDLE hSpl)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;
    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {

        if (pSpl = (PSPLFILE)hSpl) {

            if (pSpl->hFile == NULL) {

                // Open the file and store it in the object.
                //
                pSpl->hFile = CreateFile(pSpl->lpszFile,
                                        GENERIC_READ | GENERIC_WRITE,
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);

                if (!pSpl->hFile || (pSpl->hFile == INVALID_HANDLE_VALUE))
                    pSpl->hFile = NULL;
                else
                    bRet = TRUE;

            } else {

                // Already open.
                //
                bRet = TRUE;
            }
        }

        if (!ImpersonatePrinterClient(hToken))
        {
            bRet = FALSE;
        }
    }

    return bRet;
}


/*****************************************************************************\
* SplClose
*
* Close the spool-file.
*
\*****************************************************************************/
BOOL SplClose(
    HANDLE hSpl)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;
    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {

        if (pSpl = (PSPLFILE)hSpl) {

            if (pSpl->hFile) {

                bRet = CloseHandle(pSpl->hFile);
                pSpl->hFile = NULL;

            } else {

                // Already closed.
                //
                bRet = TRUE;
            }
        }

        if (!ImpersonatePrinterClient(hToken))
        {
            bRet = FALSE;
        }
    }

    return bRet;
}


/*****************************************************************************\
* SplClean
*
* Cleans out all spool-files in the spool-directory.
*
\*****************************************************************************/
VOID SplClean(VOID)
{
    LPTSTR          lpszDir;
    LPTSTR          lpszCur;
    LPTSTR          lpszFiles;
    HANDLE          hFind;
    DWORD           cbSize;
    WIN32_FIND_DATA wfd;

    static CONST TCHAR s_szFmt[] = TEXT("%s\\%s*.*");

    // Get the spool-directory where our splipp files reside.
    //
    if (lpszDir = Spl_GetDir()) {

        if (lpszCur = Spl_GetCurDir()) {

            cbSize = utlStrSize(lpszDir)    +
                     utlStrSize(g_szSplPfx) +
                     utlStrSize(s_szFmt);

            if (lpszFiles = (LPTSTR)memAlloc(cbSize)) {

                StringCbPrintf(lpszFiles, cbSize, s_szFmt, lpszDir, g_szSplPfx);

                if (SetCurrentDirectory(lpszDir)) {

                    // Delete all the files that pertain to our criteria.
                    //
                    hFind = FindFirstFile(lpszFiles, &wfd);

                    if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

                        do {

                            DeleteFile(wfd.cFileName);

                        } while (FindNextFile(hFind, &wfd));

                        FindClose(hFind);
                    }

                    SetCurrentDirectory(lpszCur);
                }

                memFreeStr(lpszFiles);
            }

            memFreeStr(lpszCur);
        }

        memFreeStr(lpszDir);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\splpjm.h ===
/*****************************************************************************\
* MODULE: splpjm.h
*
* Header file for the job-mapping list.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   13-Jan-1997 HWP-Guys    Created.
*
\*****************************************************************************/
#ifndef _SPLPJM_H
#define _SPLPJM_H

// Constants.
//
#define PJM_LOCALID  0  // pjmFind().
#define PJM_REMOTEID 1  // pjmFind().


#define PJM_SPOOLING 0x00000001
#define PJM_CANCEL   0x00000002
#define PJM_PAUSE    0x00000004
#define PJM_NOOPEN   0x00000008
#define PJM_ASYNCON  0x00000010

class CFileStream;
typedef class CInetMonPort* PCINETMONPORT;

// JobMap Structure.  This is used to track local/remote job-ids during
// the life of a print-job.  This is necessary with our IPP printing model
// since we would otherwise lose the remote job Id at enddoc time.
//
typedef struct _JOBMAP {

    struct _JOBMAP FAR *pNext;
    PCINETMONPORT      pIniPort;
    DWORD              dwState;
    DWORD              idJobLocal;
    DWORD              idJobRemote;
    LPTSTR             lpszUri;
    LPTSTR             lpszUser;
    LPTSTR             lpszDocName;
    DWORD              dwLocalJobSize;
    SYSTEMTIME         SubmitTime;
    DWORD              dwStatus;
    HANDLE             hSplFile;
    BOOL               bRemoteJob;
} JOBMAP;
typedef JOBMAP *PJOBMAP;
typedef JOBMAP *NPJOBMAP;
typedef JOBMAP *LPJOBMAP;


typedef struct _PPJOB_ENUM {

    DWORD  cItems;
    DWORD  cbSize;
    IPPJI2 ji2[1];

} PPJOB_ENUM;
typedef PPJOB_ENUM *PPPJOB_ENUM;
typedef PPJOB_ENUM *NPPPJOB_ENUM;
typedef PPJOB_ENUM *LPPPJOB_ENUM;


// JobMap Routines.
//
PJOBMAP pjmAdd(
    PJOBMAP*        pjmList,
    PCINETMONPORT   pIniPort,
    LPCTSTR         lpszUser,
    LPCTSTR         lpszDocName);

VOID pjmCleanRemoteFlag(
    PJOBMAP* pjmList);

PJOBMAP pjmFind(
    PJOBMAP* pjmList,
    DWORD    fType,
    DWORD    idJob);

DWORD pjmGetLocalJobCount(
    PJOBMAP* pjmList,
    DWORD*   pcbItems);

PJOBMAP pjmNextLocalJob(
    PJOBMAP*    pjmList,
    PJOB_INFO_2 pJobInfo2,
    PBOOL       pbFound);

VOID pjmDel(
    PJOBMAP *pjmList,
    PJOBMAP pjm);

VOID pjmDelList(
    PJOBMAP pjmList);

CFileStream* pjmSplLock(
    PJOBMAP pjm);

BOOL pjmSplUnlock(
    PJOBMAP pjm);

BOOL pjmSplWrite(
    PJOBMAP pjm,
    LPVOID  lpMem,
    DWORD   cbMem,
    LPDWORD lpcbWr);

BOOL pjmSetState(
    PJOBMAP pjm,
    DWORD   dwState);

VOID pjmClrState(
    PJOBMAP pjm,
    DWORD   dwState);

VOID pjmSetJobRemote(
    PJOBMAP pjm,
    DWORD   idJobRemote,
    LPCTSTR lpszUri);

VOID pjmAddJobSize(
    PJOBMAP pjm,
    DWORD   dwSize);

VOID pjmRemoveOldEntries(
    PJOBMAP      *pjmList);


VOID pjmUpdateLocalJobStatus(
    PJOBMAP pjm,
    DWORD   dwStatus);


/*****************************************************************************\
* pjmJobId
*
\*****************************************************************************/
_inline DWORD pjmJobId(
    PJOBMAP pjm,
    DWORD   fType)
{
    return (pjm ? ((fType == PJM_REMOTEID) ? pjm->idJobRemote : pjm->idJobLocal) : 0);
}

/*****************************************************************************\
* pjmSplFile
*
\*****************************************************************************/
_inline LPCTSTR pjmSplFile(
    PJOBMAP pjm)
{
    return (pjm ? SplFileName(pjm->hSplFile) : NULL);
}

/*****************************************************************************\
* pjmSplUser
*
\*****************************************************************************/
_inline LPCTSTR pjmSplUser(
    PJOBMAP pjm)
{
    return (pjm ? pjm->lpszUser : NULL);
}

/*****************************************************************************\
* pjmChkState
*
\*****************************************************************************/
_inline BOOL pjmChkState(
    PJOBMAP pjm,
    DWORD   dwState)
{
    return (pjm ? (pjm->dwState & dwState) : FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\stream.cxx ===
/*****************************************************************************\
* MODULE: stream.cxx
*
* The module contains the stream interface for file and memory access
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   09/20/00    Weihaic     Created
*
\*****************************************************************************/


#include "precomp.h"
#include "priv.h"

CStream::CStream ():
   m_dwCurPos (0),
   m_bValid(FALSE)
{
}

BOOL
CStream::Reset (
    VOID) 
{
    return SetPtr(0);
}
    
BOOL
CStream::GetTotalSize (
    PDWORD  pdwSize) CONST
{
    BOOL bRet = FALSE;

    if (m_bValid && pdwSize) {
        *pdwSize = m_dwTotalSize;

        bRet = TRUE;
    }

    return bRet;
}
    
CMemStream::CMemStream (
    PBYTE pMem,
    DWORD dwTotalSize):
    m_pMem (pMem)
{
    m_dwTotalSize = dwTotalSize;
    m_bValid = TRUE;
}
    
        
BOOL
CMemStream::SetPtr (
    DWORD dwPos)
{
    BOOL bRet = FALSE;

    if (m_dwCurPos < m_dwTotalSize)
    {
        m_dwCurPos = dwPos;
        bRet = TRUE;
    }

    return bRet;
}
        
BOOL
CMemStream::Read (
    PBYTE   pBuf,
    DWORD   dwBufSize,
    PDWORD  pdwSizeRead)
{
    DWORD dwSizeLeft = m_dwTotalSize - m_dwCurPos;

    *pdwSizeRead = (dwSizeLeft > dwBufSize)?dwBufSize:dwSizeLeft;

    CopyMemory (pBuf, m_pMem + m_dwCurPos, *pdwSizeRead);

    return TRUE;
}



CFileStream::CFileStream (
    HANDLE hFile):
    m_hFile (hFile)
{
    BOOL bRet = FALSE;
    LARGE_INTEGER LargeSize; 

    if (GetFileSizeEx (m_hFile, &LargeSize) && LargeSize.HighPart == 0) {
        m_dwTotalSize = LargeSize.LowPart;
        bRet = TRUE;
    }
    
    m_bValid = bRet;
}
    
BOOL
CFileStream::SetPtr (
    DWORD dwPos)
{
    BOOL bRet = FALSE;
    LARGE_INTEGER LargePos; 

    LargePos.LowPart = dwPos;
    LargePos.HighPart = 0;

    if (m_bValid) {
        
        if (SetFilePointerEx (m_hFile, LargePos, NULL, FILE_BEGIN)) {
            m_dwCurPos = dwPos;
            bRet = TRUE;
        }
    }
    return bRet;
}
        
BOOL
CFileStream::Read (
    PBYTE   pBuf,
    DWORD   dwBufSize,
    PDWORD  pdwSizeRead)
{
    BOOL bRet = FALSE;
    
    if (m_bValid) {

        if (ReadFile (m_hFile, pBuf, dwBufSize, pdwSizeRead, NULL)) {
            m_dwCurPos+= *pdwSizeRead;
            bRet = TRUE;
        }

    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\stream.h ===
#ifndef _STREAM_H
#define _STREAM_H

class CStream
{
public:
    CStream ();

    virtual ~CStream (){};
    
    virtual inline BOOL
    bValid (VOID) CONST {
        return m_bValid;
    }
    
    virtual BOOL
    Reset (
        VOID);
    
    virtual BOOL
    GetTotalSize (
        PDWORD  pdwSize) CONST;
    
    virtual BOOL
    SetPtr (
        DWORD   dwPos) = 0;
    
    virtual BOOL
    Read (
        PBYTE   pBuf,
        DWORD   dwBufSize,
        PDWORD  pdwSizeRead) = 0;

protected:
    BOOL    m_bValid;
    DWORD   m_dwTotalSize;
    DWORD   m_dwCurPos;
};


class CMemStream: public CStream
{
public:
    CMemStream (
        PBYTE pMem,
        DWORD dwTotalSize);

    
    virtual BOOL
    SetPtr (
        DWORD   dwPos);
    
    virtual BOOL
    Read (
        PBYTE   pBuf,
        DWORD   dwBufSize,
        PDWORD  pdwSizeRead);

private:
    PBYTE   m_pMem;
};

class CFileStream: public CStream
{
public:
    CFileStream (
        HANDLE hFile);

    virtual BOOL
    SetPtr (
        DWORD   dwPos);
    
    virtual BOOL
    Read (
        PBYTE   pBuf,
        DWORD   dwBufSize,
        PDWORD  pdwSizeRead);

private:
    HANDLE  m_hFile;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\splpjm.cxx ===
/*****************************************************************************\
* MODULE: splpjm.c
*
* This module contains the routines to deal with job-mapping list.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   13-Jan-1997 ChrisWil    Created.
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* pjm_OldEntry (Local Routine)
*
*
\*****************************************************************************/
_inline BOOL pjm_IsOldEntry(
    PJOBMAP      pjm)
{
    return !pjm->bRemoteJob && !pjmChkState(pjm, PJM_SPOOLING);
}

/*****************************************************************************\
* pjm_IsLocalJob (Local Routine)
*
*
\*****************************************************************************/
_inline BOOL pjm_IsLocalJob(
    PJOBMAP      pjm)
{
    return !pjm->bRemoteJob && pjmChkState(pjm, PJM_SPOOLING);
}

    


/*****************************************************************************\
* pjm_DelEntry (Local Routine)
*
*
\*****************************************************************************/
_inline VOID pjm_DelEntry(
    PJOBMAP     pjm)
{
    if (pjm->hSplFile)
        SplFree(pjm->hSplFile);

    if (pjm->lpszUri)
        memFreeStr(pjm->lpszUri);

    if (pjm->lpszUser)
        memFreeStr(pjm->lpszUser);

    memFree(pjm, sizeof(JOBMAP));
}


/*****************************************************************************\
* pjmAdd
*
* Add a job-mapping to the list.  Access to this list needs ownership of the
* crit-sect.
*
\*****************************************************************************/
PJOBMAP pjmAdd(
    PJOBMAP         *pjmList,
    PCINETMONPORT   pIniPort,
    LPCTSTR         lpszUser,
    LPCTSTR         lpszDocName)
{
    PJOBMAP pjm = NULL;

    static DWORD s_idJobLocal = 0;

    semCheckCrit();

    if (pjmList) {

        
        // Add the new job-entry to the list.
        //
        if (pjm = (PJOBMAP)memAlloc(sizeof(JOBMAP))) {
    
            // Initialize our job-entry.
            //
            GetSystemTime (&pjm->SubmitTime);

            pjm->dwState        = 0;
            pjm->pIniPort       = pIniPort;
            pjm->idJobLocal     = ++s_idJobLocal;
            pjm->idJobRemote    = 0;
            pjm->lpszUri        = NULL;
            pjm->lpszUser       = memAllocStr(lpszUser);
            pjm->lpszDocName    = memAllocStr(lpszDocName);
            pjm->hSplFile       = NULL;
            pjm->dwLocalJobSize = 0;
            pjm->dwStatus       = JOB_STATUS_SPOOLING;
            pjm->pNext          = NULL;
    
    
            // Place it at the end of the list.
            //

            if (! *pjmList) {
                *pjmList = pjm;
            }
            else {

                for (PJOBMAP pjPtr = *pjmList; pjPtr->pNext; pjPtr = pjPtr->pNext);
                pjPtr->pNext = pjm;
            }
        }
    }

    return pjm;
}


/*****************************************************************************\
* pjmDel
*
* Delete a job-mapping from the list.  Access to this list needs owenership
* of the crit-sect.
*
\*****************************************************************************/
VOID pjmDel(
    PJOBMAP* pjmList,
    PJOBMAP  pjm)
{
    PJOBMAP pjPtr;
    PJOBMAP pjPrv;
    DWORD   idx;

    semCheckCrit();

    if (pjmList) {

        for (pjPtr = *pjmList, idx = 0; pjPtr && (pjm != pjPtr); ) {
    
            // Reposition.
            //
            pjPrv = pjPtr;
            pjPtr = pjPtr->pNext;
    
    
            // If we've iterated 1000 jobs in this list, then we've
            // either got a very heavily taxed print-system, or we
            // may have an infinite loop.
            //
            if (idx++ >= g_dwJobLimit) {
    
                DBG_MSG(DBG_LEV_ERROR, (TEXT("Error: pjmDel : Looped 1000 jobs, possible infinite loop")));
    
                return;
            }
        }
    
    
        // If we found the entry, then delete it.
        //
        if (pjPtr) {
    
            if (pjPtr == *pjmList) {
    
                *pjmList = pjPtr->pNext;
    
            } else {
    
                pjPrv->pNext = pjPtr->pNext;
            }
    
            pjm_DelEntry(pjPtr);
        }
    }
}

/*****************************************************************************\
* pjmCleanRemoteFlag
*
* Cleanup remote jobid from list.  Access to this list needs ownership of the
* crit-sect. 
*
\*****************************************************************************/
VOID pjmCleanRemoteFlag(
    PJOBMAP* pjmList)
{
    PJOBMAP pjPtr = NULL;

    semCheckCrit();

    if (pjmList) {
    
        for (pjPtr = *pjmList; pjPtr; ) {

            pjPtr->bRemoteJob = FALSE;
    
            // Next item.
            //
            pjPtr = pjPtr->pNext;
    
        }
    }
    
}

/*****************************************************************************\
* pjmGetLocalJobCount
*
* Locate number of job-entries from list.  Access to this list needs ownership of the
* crit-sect. 
*
\*****************************************************************************/
DWORD pjmGetLocalJobCount(
    PJOBMAP* pjmList,
    DWORD*   pcbItems)
{
    PJOBMAP pjPtr = NULL;
    DWORD   idx = 0;

    semCheckCrit();

    *pcbItems = 0;
    if (pjmList) {
    
        for (pjPtr = *pjmList; pjPtr; ) {

            if (pjm_IsLocalJob (pjPtr)) {

                idx++;

                *pcbItems += sizeof (JOB_INFO_2) +
                             utlStrSize (pjPtr->lpszDocName) +
                             utlStrSize (pjPtr->lpszUser);
            }

            // Next item.
            //
            pjPtr = pjPtr->pNext;

        }
    }

    return idx;
}

/*****************************************************************************\
* pjmFind
*
* Locate job-entry from list.  Access to this list needs ownership of the
* crit-sect.  This will lookup either Local/Remote id's and return its
* position.
*
\*****************************************************************************/
PJOBMAP pjmFind(
    PJOBMAP* pjmList,
    DWORD    fType,
    DWORD    idJob)
{
    PJOBMAP pjPtr = NULL;
    DWORD   idx;

    semCheckCrit();

    if (pjmList) {
    
        // Search.
        //
        for (pjPtr = *pjmList, idx = 0; pjPtr && (pjmJobId(pjPtr, fType) != idJob); ) {
    
            // Next item.
            //
            pjPtr = pjPtr->pNext;
    
    
            // If we've iterated 1000 jobs in this list, then we've
            // either got a very heavily taxed print-system, or we
            // may have an infinite loop.
            //
            if (idx++ >= g_dwJobLimit) {
    
                DBG_MSG(DBG_LEV_ERROR, (TEXT("Error: pjmFind : Looped 1000 jobs, possible infinite loop")));
    
                return NULL;
            }
        }

        if (pjPtr && fType == PJM_REMOTEID) {
            pjPtr->bRemoteJob = TRUE;
        }

    }

    return pjPtr;
}

/*****************************************************************************\
* pjmNextLocalJob
*
* Walk the list and look for any expired entries.  Access to this list needs
* ownership of the crit-sect.
*
\*****************************************************************************/
PJOBMAP pjmNextLocalJob(
    PJOBMAP*    pjmList,
    PJOB_INFO_2 pJobInfo2,
    PBOOL       pbFound)
{
    PJOBMAP pjPtr = NULL;
    DWORD   idx;
    BOOL    bFound = FALSE;

    semCheckCrit();

    if (pjmList) {
    
        for (pjPtr = *pjmList, idx = 0; pjPtr && !bFound; ) {
    
            // If we're spooling, then we can't be an old-job.
            //
            if (pjm_IsLocalJob (pjPtr)) {

                // It is a new entry
                //
                ZeroMemory (pJobInfo2, sizeof (JOB_INFO_2));
                pJobInfo2->JobId        = pjPtr->idJobLocal;
                pJobInfo2->pDocument    = pjPtr->lpszDocName;
                pJobInfo2->pUserName    = pjPtr->lpszUser;
                pJobInfo2->Size         = pjPtr->dwLocalJobSize;
                pJobInfo2->Submitted    = pjPtr->SubmitTime;
                pJobInfo2->Status       = pjPtr->dwStatus;

                if (pjmChkState (pjPtr, PJM_CANCEL)) {
                    pJobInfo2->Status |= JOB_STATUS_DELETING;
                }

                bFound = TRUE;
            }
            
            // Next item.
            //
            pjPtr = pjPtr->pNext;
    
        }
    }

    *pbFound = bFound;
    return pjPtr;
}

/*****************************************************************************\
* pjmRmoveOldEntries
*
* Walk the list and look for any expired entries.  Access to this list needs
* ownership of the crit-sect.
*
\*****************************************************************************/
VOID pjmRemoveOldEntries(
    PJOBMAP      *pjmList)
{
    PJOBMAP pjPtr;
    PJOBMAP pjDel;
    PJOBMAP pjPrv;
    DWORD   idx;

    semCheckCrit();


    for (pjPtr = *pjmList, pjPrv = *pjmList, idx = 0; pjPtr; ) {

        // If we're an old entry, then delete it.
        //
        if (pjm_IsOldEntry (pjPtr)) {

            // No remote job ID and the state is not spooling
            // It is an old entry, delete it

            pjDel = pjPtr;

            if (pjPtr == *pjmList) {

                *pjmList = pjPtr->pNext;
                pjPtr    = *pjmList;
                pjPrv    = *pjmList;

            } else {

                pjPrv->pNext = pjPtr->pNext;
                pjPtr        = pjPrv->pNext;
            }

            pjm_DelEntry(pjDel);


        } else {

            pjPrv = pjPtr;
            pjPtr = pjPtr->pNext;
        }


        // If we've iterated 1000 jobs in this list, then we've
        // either got a very heavily taxed print-system, or we
        // may have an infinite loop.
        //
        if (idx++ >= g_dwJobLimit) {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("Warn : pjmWalk : Looped 1000 jobs, possible infinite loop")));

            return;
        }
    }
}




/*****************************************************************************\
* pjmDelList
*
*
\*****************************************************************************/
VOID pjmDelList(
    PJOBMAP pjmList)
{
    PJOBMAP pjPtr;

    semCheckCrit();


    for (pjPtr = pjmList; pjPtr; ) {

        pjmList = pjPtr->pNext;

        pjm_DelEntry(pjPtr);

        pjPtr = pjmList;
    }
}


/*****************************************************************************\
* pjmSetState
*
* Set the state of the job-entry.  If we're setting this to spooling-state,
* then we go through the extra-trouble of setting up a spool-file entry as
* well.
*
\*****************************************************************************/
BOOL pjmSetState(
    PJOBMAP pjm,
    DWORD   dwState)
{
    DWORD fType;
    BOOL  bSet = FALSE;

    semCheckCrit();


    if (pjm) {

        // If the caller is setting the job into spooling-state, then
        // we need to create a spool-file.  If this state is already
        // set, then ignore this particular call.
        //
        if ((dwState & PJM_SPOOLING) && !pjmChkState(pjm, PJM_SPOOLING)) {

            // Determine the type of spl-file to open.  If PJM_NOOPEN
            // is specified, then we will close the file-handle so that
            // other processes can obtain exclusive access (i.e. AddJob,
            // and ScheduleJob require this).
            //
            fType = (dwState & PJM_NOOPEN ? SPLFILE_TMP : SPLFILE_SPL);


            // Allocate the spool-file, and close if necessary.
            //
            if (pjm->hSplFile = SplCreate(pjm->idJobLocal, fType)) {

                if (dwState & PJM_NOOPEN)
                    SplClose(pjm->hSplFile);

                bSet = TRUE;

            } else {

                goto EndSet;
            }

        } else {

            bSet = TRUE;
        }


        // Set the state.
        //
        pjm->dwState |= dwState;
    }

EndSet:

    return bSet;
}


/*****************************************************************************\
* pjmClrState
*
* Clear the state specified in the job-entry.  If we're turning of spooling,
* then we need to free up the spool-file-object.
*
\*****************************************************************************/
VOID pjmClrState(
    PJOBMAP pjm,
    DWORD   dwState)
{
    semCheckCrit();


    if (pjm) {

        // If the caller is turning off spooling, then we need to
        // clean our spool-file resources.  If there is no spooling
        // going on, then ignore.
        //
        if ((dwState & PJM_SPOOLING) && pjmChkState(pjm, PJM_SPOOLING)) {

            // Clean our spooling-file resources.
            //
            SplFree(pjm->hSplFile);
            pjm->hSplFile = NULL;
        }


        // Clear the state.
        //
        pjm->dwState &= ~dwState;
    }
}


/*****************************************************************************\
* pjmSetJobRemote
*
* Set the remote-job-id into the job-entry.  This is usually called once
* the job-id is obtained from the print-server.  We will maintain this for
* local/remote job-mapping.
*
\*****************************************************************************/
VOID pjmSetJobRemote(
    PJOBMAP pjm,
    DWORD   idJobRemote,
    LPCTSTR lpszUri)
{
    semCheckCrit();

    if (pjm) {

        // If we had a previous job-url, then we need to free it
        // before reseting it with the new.
        //
        if (pjm->lpszUri)
            memFreeStr(pjm->lpszUri);


        // Store remote-job information.
        //
        pjm->idJobRemote = idJobRemote;
        pjm->lpszUri     = memAllocStr(lpszUri);
        pjm->bRemoteJob  = TRUE;
    }
}

/*****************************************************************************\
* pjmAddJobSize
*
* Add the job size to the local job info. This is usually called by
* PPWritePrinter 
*
\*****************************************************************************/
VOID pjmAddJobSize(
    PJOBMAP pjm,
    DWORD   dwSize)
{
    semCheckCrit();

    if (pjm) {

        pjm->dwLocalJobSize += dwSize;
    }
}



/*****************************************************************************\
* pjmSplLock
*
* Lock the spool-file for reading.  This returns a file-map pointer to the
* caller.
*
\*****************************************************************************/
CFileStream* pjmSplLock(
    PJOBMAP pjm)
{
    CFileStream *pStream = NULL;

    semCheckCrit();

    if (pjm) {

        // If the state of our spool-object requires that we not
        // keep open-handles on the file, then we need to open
        // it here.  This is closed at pjmSplUnlock().
        //
        if (pjmChkState(pjm, PJM_NOOPEN))
            SplOpen(pjm->hSplFile);

        pStream = SplLock(pjm->hSplFile);
    }

    return pStream;
}


/*****************************************************************************\
* pjmSplUnlock
*
* This unlocks our file-mapped-pointer on the spool-file.
*
\*****************************************************************************/
BOOL pjmSplUnlock(
    PJOBMAP pjm)
{
    BOOL bRet = FALSE;

    semCheckCrit();


    // The spool-file must have already been locked in order to proceed
    // with this call.
    //
    if (pjm) {

        // Unlock the spool-file.
        //
        bRet = SplUnlock(pjm->hSplFile);


        // If the state of our spool-object requires that
        // we keep no open-handles, then we need to close
        // the spool-handle.
        //
        if (pjmChkState(pjm, PJM_NOOPEN))
            SplClose(pjm->hSplFile);
    }

    return bRet;
}


/*****************************************************************************\
* pjmSplWrite
*
* Write out data to the spool-file.
*
\*****************************************************************************/
BOOL pjmSplWrite(
    PJOBMAP pjm,
    LPVOID  lpMem,
    DWORD   cbMem,
    LPDWORD lpcbWr)
{
    BOOL bRet = FALSE;

    semCheckCrit();


    if (pjm) {

        if (pjmChkState(pjm, PJM_NOOPEN))
            SplOpen(pjm->hSplFile);

        bRet = SplWrite(pjm->hSplFile, (LPBYTE) lpMem, cbMem, lpcbWr);

        if (pjmChkState(pjm, PJM_NOOPEN))
            SplClose(pjm->hSplFile);
    }

    return bRet;
}

/*****************************************************************************\
* pjmSetState
*
* Set the status of the local job-entry. 
*
\*****************************************************************************/
VOID pjmUpdateLocalJobStatus(
    PJOBMAP pjm,
    DWORD   dwStatus)
{
    semCheckCrit();


    if (pjm) {

        pjm->dwStatus = dwStatus;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\stubs.h ===
/*****************************************************************************\
* MODULE: stubs.h
*
* Header module for stub routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#ifndef _STUB_H
#define _STUB_H

HANDLE stubAddPrinter(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbPrinter);

BOOL stubDeletePrinter(
    HANDLE hPrinter);

BOOL stubReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead);

DWORD stubGetPrinterData(
    HANDLE  hPrinter,
    LPTSTR  pszValueName,
    LPDWORD pType,
    LPBYTE  pbData,
    DWORD   dwSize,
    LPDWORD pcbNeeded);

DWORD stubSetPrinterData(
    HANDLE hPrinter,
    LPTSTR pszValueName,
    DWORD  dwType,
    LPBYTE pbData,
    DWORD  cbData);

DWORD stubWaitForPrinterChange(
    HANDLE hPrinter,
    DWORD  dwFlags);

BOOL stubAddPrinterConnection(
    LPTSTR pszName);

BOOL stubDeletePrinterConnection(
    LPTSTR pszName);

DWORD stubPrinterMessageBox(
    HANDLE hPrinter,
    DWORD  dwError,
    HWND   hWnd,
    LPTSTR pszText,
    LPTSTR pszCaption,
    DWORD  dwType);

BOOL stubAddPrinterDriver(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbDriverInfo);

BOOL stubDeletePrinterDriver(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszDriverName);

BOOL stubGetPrinterDriver(
    HANDLE  hPrinter,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

BOOL stubEnumPrinterDrivers(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned);

BOOL stubGetPrinterDriverDirectory(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

BOOL stubAddPrintProcessor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszPathName,
    LPTSTR pszPrintProcessorName);

BOOL stubDeletePrintProcessor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszPrintProcessorName);

BOOL stubEnumPrintProcessors(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned);

BOOL stubGetPrintProcessorDirectory(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

BOOL stubEnumPrintProcessorDatatypes(
    LPTSTR  pszName,
    LPTSTR  pszPrintProcessorName,
    DWORD   dwLevel,
    LPBYTE  pbDataypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned);

BOOL stubAddForm(
    HANDLE hPrinter,
    DWORD  Level,
    LPBYTE pForm);

BOOL stubDeleteForm(
    HANDLE hPrinter,
    LPTSTR pFormName);

BOOL stubGetForm(
    HANDLE  hPrinter,
    LPTSTR  pszFormName,
    DWORD   dwLevel,
    LPBYTE  pbForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

BOOL stubSetForm(
    HANDLE hPrinter,
    LPTSTR pszFormName,
    DWORD  dwLevel,
    LPBYTE pbForm);

BOOL stubEnumForms(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned);

BOOL stubAddMonitor(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbMonitorInfo);

BOOL stubDeleteMonitor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszMonitorName);

BOOL stubEnumMonitors(
    LPTSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned);

BOOL stubAddPort(
    LPTSTR  pName,
    HWND    hWnd,
    LPTSTR  pMonitorName);

BOOL stubDeletePort(
    LPTSTR  pName,
    HWND    hWnd,
    LPTSTR  pPortName);

BOOL stubConfigurePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName);

HANDLE stubCreatePrinterIC(
    HANDLE     hPrinter,
    LPDEVMODEW pDevMode);

BOOL stubPlayGdiScriptOnPrinterIC(
    HANDLE hPrinterIC,
    LPBYTE pbIn,
    DWORD  cIn,
    LPBYTE pbOut,
    DWORD  cOut,
    DWORD  ul);

BOOL stubDeletePrinterIC(
    HANDLE hPrinterIC);




BOOL stubResetPrinter(
    LPPRINTER_DEFAULTS lpDefault);

BOOL stubGetPrinterDriverEx(
    LPTSTR  lpEnvironment,
    DWORD   dwLevel,
    LPBYTE  lpbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVer,
    DWORD   dwClientMinorVer,
    PDWORD  pdwServerMajorVer,
    PDWORD  pdwServerMinorVer);

BOOL stubFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD  dwFlags,
    DWORD  dwOptions,
    HANDLE hNotify,
    PDWORD pdwStatus,
    PVOID  pPrinterNofityOptions,
    PVOID  pPrinterNotifyInit);

BOOL stubFindClosePrinterChangeNotification(
    HANDLE hPrinter);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\stubs.cxx ===
/*****************************************************************************\
* MODULE: stubs.c
*
* This module contains the stub routines for unimplemented (non-required)
* Print-Provider functions.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* _stub_routine (Local Routine)
*
* Common code for stubbed PP routines.  Sets last error to the specified
* number, then returns FALSE.
*
\*****************************************************************************/
BOOL _stub_routine(VOID)
{
    SetLastError(ERROR_INVALID_NAME);

    return FALSE;
}


/*****************************************************************************\
* stubAddPrinter
*
*
\*****************************************************************************/
HANDLE stubAddPrinter(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbPrinter)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPrinter")));
    return (HANDLE)IntToPtr(_stub_routine());
}


/*****************************************************************************\
* stubDeletePrinter
*
*
\*****************************************************************************/
BOOL stubDeletePrinter(
    HANDLE hPrinter)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrinter")));
    return _stub_routine();
}


/*****************************************************************************\
* stubReadPrinter
*
*
\*****************************************************************************/
BOOL stubReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubReadPrinter")));
    return _stub_routine();
}


/*****************************************************************************\
* stubGetPrinterData
*
*
\*****************************************************************************/
DWORD stubGetPrinterData(
    HANDLE  hPrinter,
    LPTSTR  pszValueName,
    LPDWORD pType,
    LPBYTE  pbData,
    DWORD   dwSize,
    LPDWORD pcbNeeded)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetPrinterData")));
    return _stub_routine();
}


/*****************************************************************************\
* stubSetPrinterData
*
*
\*****************************************************************************/
DWORD stubSetPrinterData(
    HANDLE hPrinter,
    LPTSTR pszValueName,
    DWORD  dwType,
    LPBYTE pbData,
    DWORD  cbData)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubSetPrinterData")));
    return _stub_routine();
}


/*****************************************************************************\
* stubWaitForPrinterChange
*
*
\*****************************************************************************/
DWORD stubWaitForPrinterChange(
    HANDLE hPrinter,
    DWORD  dwFlags)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubWaitForPrinterChange")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddPrinterConnection
*
*
\*****************************************************************************/
BOOL stubAddPrinterConnection(
    LPTSTR pszName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPrinterConnection")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeletePrinterConnection
*
*
\*****************************************************************************/
BOOL stubDeletePrinterConnection(
    LPTSTR pszName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrinterConnection")));
    return _stub_routine();
}


/*****************************************************************************\
* stubPrinterMessageBox
*
*
\*****************************************************************************/
DWORD stubPrinterMessageBox(
    HANDLE hPrinter,
    DWORD  dwError,
    HWND   hWnd,
    LPTSTR pszText,
    LPTSTR pszCaption,
    DWORD  dwType)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubPrinterMessageBox")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddPrinterDriver
*
*
\*****************************************************************************/
BOOL stubAddPrinterDriver(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbDriverInfo)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPrinterDriver")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeletePrinterDriver
*
*
\*****************************************************************************/
BOOL stubDeletePrinterDriver(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszDriverName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrinterDriver")));
    return _stub_routine();
}


/*****************************************************************************\
* stubGetPrinterDriver
*
*
\*****************************************************************************/
BOOL stubGetPrinterDriver(
    HANDLE  hPrinter,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetPrinterDriver")));
    return _stub_routine();
}


/*****************************************************************************\
* stubEnumPrinterDrivers
*
*
\*****************************************************************************/
BOOL stubEnumPrinterDrivers(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumPrinterDrivers")));
    return _stub_routine();
}


/*****************************************************************************\
* stubGetPrinterDriverDirectory
*
*
\*****************************************************************************/
BOOL stubGetPrinterDriverDirectory(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetPrinterDriverDirectory")));
    return _stub_routine();
}

/*****************************************************************************\
* stubAddPrintProcessor
*
*
\*****************************************************************************/
BOOL stubAddPrintProcessor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszPathName,
    LPTSTR pszPrintProcessorName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPrintProcessor")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeletePrintProcessor
*
*
\*****************************************************************************/
BOOL stubDeletePrintProcessor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszPrintProcessorName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrintProcessor")));
    return _stub_routine();
}


/*****************************************************************************\
* stubEnumPrintProcessors
*
*
\*****************************************************************************/
BOOL stubEnumPrintProcessors(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumPrintProcessors")));
    return _stub_routine();
}


/*****************************************************************************\
* stubGetPrintProcessorDirectory
*
*
\*****************************************************************************/
BOOL stubGetPrintProcessorDirectory(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetPrintProcessorDirectory")));
    return _stub_routine();
}


/*****************************************************************************\
* stubEnumPrintProcessorDatatypes
*
*
\*****************************************************************************/
BOOL stubEnumPrintProcessorDatatypes(
    LPTSTR  pszName,
    LPTSTR  pszPrintProcessorName,
    DWORD   dwLevel,
    LPBYTE  pbDataypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumPrintProcessorDatatypes")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddForm
*
*
\*****************************************************************************/
BOOL stubAddForm(
    HANDLE hPrinter,
    DWORD  Level,
    LPBYTE pForm)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddForm")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeleteForm
*
*
\*****************************************************************************/
BOOL stubDeleteForm(
    HANDLE hPrinter,
    LPTSTR pFormName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeleteForm")));
    return _stub_routine();
}


/*****************************************************************************\
* stubGetForm
*
*
\*****************************************************************************/
BOOL stubGetForm(
    HANDLE  hPrinter,
    LPTSTR  pszFormName,
    DWORD   dwLevel,
    LPBYTE  pbForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetForm")));
    return _stub_routine();
}


/*****************************************************************************\
* stubSetForm
*
*
\*****************************************************************************/
BOOL stubSetForm(
    HANDLE hPrinter,
    LPTSTR pszFormName,
    DWORD  dwLevel,
    LPBYTE pbForm)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubSetForm")));
    return _stub_routine();
}


/*****************************************************************************\
* stubEnumForms
*
*
\*****************************************************************************/
BOOL stubEnumForms(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumForms")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddMonitor
*
*
\*****************************************************************************/
BOOL stubAddMonitor(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbMonitorInfo)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddMonitor")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeleteMonitor
*
*
\*****************************************************************************/
BOOL stubDeleteMonitor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszMonitorName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeleteMonitor")));
    return _stub_routine();
}

/*****************************************************************************\
* stubEnumMonitors
*
*
\*****************************************************************************/
BOOL stubEnumMonitors(
    LPTSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumMonitors")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddPort
*
*
\*****************************************************************************/
BOOL stubAddPort(

    LPTSTR  pName,
    HWND    hWnd,
    LPTSTR  pMonitorName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPort")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeletePort
*
*
\*****************************************************************************/
BOOL stubDeletePort(

    LPTSTR  pName,
    HWND    hWnd,
    LPTSTR  pPortName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePort")));
    return _stub_routine();
}


/*****************************************************************************\
* stubConfigurePort
*
*
\*****************************************************************************/
BOOL stubConfigurePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubConfigurePort")));
    return _stub_routine();
}


/*****************************************************************************\
* stubCreatePrinterIC
*
*
\*****************************************************************************/
HANDLE stubCreatePrinterIC(
    HANDLE     hPrinter,
    LPDEVMODEW pDevMode)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubCreatePrinterIC")));
    return (HANDLE)IntToPtr(_stub_routine());
}


/*****************************************************************************\
* stubPlayGdiScriptOnPrinterIC
*
*
\*****************************************************************************/
BOOL stubPlayGdiScriptOnPrinterIC(
    HANDLE hPrinterIC,
    LPBYTE pbIn,
    DWORD  cIn,
    LPBYTE pbOut,
    DWORD  cOut,
    DWORD  ul)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubPlayGdiScriptOnPrinter")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeletePrinterIC
*
*
\*****************************************************************************/
BOOL stubDeletePrinterIC(
    HANDLE hPrinterIC)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrinterIC")));
    return _stub_routine();
}



/*****************************************************************************\
* stubResetPrinter
*
*
\*****************************************************************************/
BOOL stubResetPrinter(
    LPPRINTER_DEFAULTS lpDefault)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubResetPrinter")));
    SetLastError(ERROR_NOT_SUPPORTED);

    return FALSE;
}


/*****************************************************************************\
* stubGetPrinterDriverEx
*
*
\*****************************************************************************/
BOOL stubGetPrinterDriverEx(
    LPTSTR  lpEnvironment,
    DWORD   dwLevel,
    LPBYTE  lpbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVer,
    DWORD   dwClientMinorVer,
    PDWORD  pdwServerMajorVer,
    PDWORD  pdwServerMinorVer)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetPrinterDriverEx")));
    return _stub_routine();
}


/*****************************************************************************\
* stubFindFirstPrinterChangeNotification
*
*
\*****************************************************************************/
BOOL stubFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD  dwFlags,
    DWORD  dwOptions,
    HANDLE hNotify,
    PDWORD pdwStatus,
    PVOID  pPrinterNofityOptions,
    PVOID  pPrinterNotifyInit)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubFindFirstPrinterChangeNotification")));
    return _stub_routine();
}


/*****************************************************************************\
* stubFindClosePrinterChangeNotification
*
*
\*****************************************************************************/
BOOL stubFindClosePrinterChangeNotification(
    HANDLE hPrinter)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubFindClosePrinterChangeNotification")));
    return _stub_routine();
}

/*****************************************************************************\
* stubAddPortEx
*
*
\*****************************************************************************/
BOOL stubAddPortEx(
    LPTSTR lpszName,
    DWORD  dwLevel,
    LPBYTE lpbBuffer,
    LPTSTR lpszMonitorName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPortEx")));
    return _stub_routine();
}


/*****************************************************************************\
* stubShutDown
*
*
\*****************************************************************************/
BOOL stubShutDown(
    LPVOID lpvReserved)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubShutDown")));
    return _stub_routine();
}

/*****************************************************************************\
* stubRefreshPrinterChangeNotification
*
*
\*****************************************************************************/
BOOL stubRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD  dwReserved,
    PVOID  pvReserved,
    PVOID  pvPrinterNotifyInfo)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubRefreshPrinterChangeNotification")));
    return _stub_routine();
}


/*****************************************************************************\
* stubOpenPrinterEx
*
*
\*****************************************************************************/
BOOL stubOpenPrinterEx(
    LPTSTR             lpszPrinterName,
    LPHANDLE           phPrinter,
    LPPRINTER_DEFAULTS pDefault,
    LPBYTE             lpbClientInfo,
    DWORD              dwLevel)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubOpenPrinterEx")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddPrinterEx
*
*
\*****************************************************************************/
HANDLE stubAddPrinterEx(
    LPTSTR lpszName,
    DWORD  dwLevel,
    LPBYTE lpbPrinter,
    LPBYTE lpbClientInfo,
    DWORD  dwClientInfoLevel)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPrinterEx")));
    return (HANDLE)IntToPtr(_stub_routine());
}


/*****************************************************************************\
* stubSetPort
*
*
\*****************************************************************************/
BOOL stubSetPort(
    LPTSTR lpszName,
    LPTSTR lpszPortName,
    DWORD  dwLevel,
    LPBYTE lpbPortInfo)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubSetPort")));
    return _stub_routine();
}


/*****************************************************************************\
* stubEnumPrinterData
*
*
\*****************************************************************************/
DWORD stubEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,
    LPTSTR  lpszValueName,
    DWORD   cbValueName,
    LPDWORD pcbValueName,
    LPDWORD pdwType,
    LPBYTE  lpbData,
    DWORD   cbData,
    LPDWORD lpcbData)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumPrinterData")));
    return (DWORD)_stub_routine();
}

/*****************************************************************************\
* stubDeletePrinterData
*
*
\*****************************************************************************/
DWORD stubDeletePrinterData(
    HANDLE  hPrinter,
    LPTSTR  lpszValueName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrinterData")));
    return (DWORD)_stub_routine();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\userdata.cxx ===
/*****************************************************************************\
* MODULE: userdata.cxx
*
* The module contains class for user credentials
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   08/28/98    Weihaic     Created
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"

CUserData::CUserData ():
    m_pSid(NULL),
    m_bValid(FALSE)
    {
    m_bValid = _GetSid ();
}

CUserData::~CUserData ()
{
    LocalFree (m_pSid);
}

int
CUserData::Compare (
    CUserData * second)
{

    if (m_bValid && second->m_bValid) {
        return RtlEqualSid( m_pSid , second->m_pSid) == FALSE;
    }
    else {
        return TRUE;
    }
}

CUserData &
CUserData::operator= (const CUserData &rhs)
{
    ULONG  ulSidLen;
    DWORD  dwStatus;

    if (this == &rhs) {
        return *this;
    }

    LocalFree (m_pSid);

    m_pSid    = NULL;
    m_bValid = FALSE;

    if (!rhs.m_bValid)
        goto Cleanup;

    ulSidLen = RtlLengthSid( rhs.m_pSid );

    m_pSid = LocalAlloc( LPTR, ulSidLen );

    if (NULL == m_pSid)
        goto Cleanup;

    dwStatus = RtlCopySid( ulSidLen, m_pSid, rhs.m_pSid );

    if (NT_ERROR(dwStatus)) {
        LocalFree(m_pSid);
        m_pSid = NULL;
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Cleanup;
    }

    m_bValid = TRUE;

Cleanup:

    return *this;
}

BOOL
CUserData::_GetUserToken (
    PTOKEN_USER &TokenUserInfo)
{
    DWORD                ReturnStatus = 0;
    HANDLE               ClientToken  = NULL;
    BOOL                 bRet         = FALSE;
    ULONG                uSize        = 0;

    //
    // Compare the username specified with that in
    // the impersonation token to ensure the caller isn't bogus.
    //
    // Do this by opening the token,
    //   querying the token user info,
    //   and ensuring the returned SID is for this user.
    //

    TokenUserInfo = NULL;

    if (!OpenThreadToken(
            GetCurrentThread(),         // current thread handle
            TOKEN_QUERY,                // access required
            FALSE,                      // open as self
            &ClientToken)) {            // client token
        ReturnStatus = GetLastError();
        DBG_ASSERT( ReturnStatus , (TEXT("Err : OpenThreadToken: Failed but the lasterror = 0")));
        goto Cleanup;
    }

    //
    // Get the size of user's SID for the token.
    //

    ReturnStatus = NtQueryInformationToken(
            ClientToken,
            TokenUser,
            NULL,
            uSize,
            &uSize);

    if (!NT_ERROR (ReturnStatus) ||
         ReturnStatus != STATUS_BUFFER_TOO_SMALL) {

        // We expected to be told how big a buffer we needed and we weren't
        SetLastError (ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    //
    // Allocate the user's SID
    //

    TokenUserInfo = (PTOKEN_USER) LocalAlloc (LPTR, uSize);

    if (TokenUserInfo == NULL)
        goto Cleanup;

    ReturnStatus = NtQueryInformationToken(
            ClientToken,
            TokenUser,
            TokenUserInfo,
            uSize,
            &uSize);

    if (NT_ERROR (ReturnStatus) ) {

        // Faild after the allocation
        LocalFree( TokenUserInfo );
        TokenUserInfo = NULL;
        SetLastError (ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    //
    // Done
    //
    bRet = TRUE;

Cleanup:

    CloseHandle(ClientToken);

    return bRet;
}

BOOL
CUserData::_GetSid (VOID)
{
    BOOL         bRet = FALSE;
    PTOKEN_USER  pUser;
    ULONG        ulSidLen;
    DWORD        dwStatus;

    if (!_GetUserToken(pUser))
        goto Cleanup;
    // Now find the Sid size and copy it locally, free the pUser when done.

    ulSidLen = RtlLengthSid(pUser->User.Sid);

    m_pSid = LocalAlloc( LPTR, ulSidLen );

    if (NULL == m_pSid)
        goto Cleanup;

    dwStatus = RtlCopySid( ulSidLen, m_pSid, pUser->User.Sid );

    if (NT_ERROR(dwStatus)) {
        LocalFree(m_pSid);
        m_pSid = NULL;
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Cleanup;
    }

    bRet = TRUE;

Cleanup:

    if (pUser)
        LocalFree(pUser);

    return bRet;
}


BOOL operator== (
    const CUserData &lhs,
    const CUserData &rhs)
{

    if (lhs.m_bValid && rhs.m_bValid) {
        return RtlEqualSid(lhs.m_pSid , rhs.m_pSid );
    }
    else {
        return FALSE;
    }
}


BOOL operator!= (
    const CUserData &lhs,
    const CUserData &rhs)
{
    return ! (lhs == rhs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\util.cxx ===
/*****************************************************************************\
* MODULE: util.c
*
* This module contains utility routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* utlInternalValidatePrinterHandle
*
* Returns the port-handle if the specified printer-handle is a valid.
*
\*****************************************************************************/
PCINETMONPORT utlInternalValidatePrinterHandle(
    HANDLE hPrinter,
    BOOL bAllowDeletePending,
    PBOOL pbDeletePending)
{
    LPINET_HPRINTER pPrt;
    PCINETMONPORT     pIniPort = NULL;

    if (pbDeletePending)
        *pbDeletePending = FALSE;

    _try {

        if ((pPrt = (LPINET_HPRINTER)hPrinter)) {

            if ((pPrt->dwSignature == IPO_SIGNATURE) &&
                !(pPrt->dwStatus & PP_ZOMBIE)) {

                pIniPort = (PCINETMONPORT) pPrt->hPort;

                if (pbDeletePending) {
                    *pbDeletePending = pIniPort->bDeletePending();
                }

                if (!bAllowDeletePending) {
                    if (pIniPort->bDeletePending()) {
                        pIniPort = NULL;

                    }
                }
            }
        }

    } _except(1) {

        pIniPort = NULL;
    }

    if (pIniPort == NULL) {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("Call: utlValidatePrinterHandle: Invalid Handle: Handle(%08lX)"), hPrinter));
        SetLastError(ERROR_INVALID_HANDLE);
    }

    return pIniPort;
}

/*****************************************************************************\
* utlValidatePrinterHandle
*
* Returns the port-handle if the specified printer-handle is a valid.
*
\*****************************************************************************/
PCINETMONPORT utlValidatePrinterHandle(
    HANDLE hPrinter)
{
    return utlInternalValidatePrinterHandle (hPrinter, FALSE, NULL);
}

/*****************************************************************************\
* utlValidatePrinterHandleForClose
*
* Returns the port-handle if the specified printer-handle is a valid.
*
\*****************************************************************************/
PCINETMONPORT utlValidatePrinterHandleForClose(
    HANDLE hPrinter,
    PBOOL pbDeletePending)
{
    return utlInternalValidatePrinterHandle (hPrinter, TRUE, pbDeletePending);
}


/*****************************************************************************\
* utlValidateXcvPrinterHandle
*
* Returns the port-handle if the specified printer-handle is a valid.
*
\*****************************************************************************/
LPTSTR utlValidateXcvPrinterHandle(
    HANDLE hPrinter)
{
    LPINET_XCV_HPRINTER pPrt;
    LPTSTR          lpszPortName = NULL;


    _try {

        if ((pPrt = (LPINET_XCV_HPRINTER)hPrinter)) {

            if ((pPrt->dwSignature == IPO_XCV_SIGNATURE)) {

                lpszPortName = pPrt->lpszName;
            }
        }

    } _except(1) {

        lpszPortName = NULL;
    }

    if (lpszPortName == NULL) {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("Call: utlValidateXcvPrinterHandle: Invalid Handle: Handle(%08lX)"), hPrinter));
        SetLastError(ERROR_INVALID_HANDLE);
    }

    return lpszPortName;
}

/********************************************************************************

Name:
    EncodeUnicodePrinterName

Description:

    Encode the printer name to avoid special characters, also encode any chars
    with ASC code between 0x80 and 0xffff. This is to avoid the conversion betwwen
    different codepages when the client  and the server have different language
    packages.

    The difference between this function and EncodePrinterName in Spllib is that
    this function does not encode ' ', '$' and other special ANSI characters.

Arguments:

    lpText:     the normal text string
    lpHTMLStr:  the buf provided by the caller to store the encoded string
                if it is NULL, the function will return a FALSE
    lpdwSize:   Pointer to the size of the buffer (in characters)

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.

********************************************************************************/
BOOL EncodeUnicodePrinterName (LPCTSTR lpText, LPTSTR lpHTMLStr, LPDWORD lpdwSize)
{
#define MAXLEN_PER_CHAR 6
#define BIN2ASC(bCode,lpHTMLStr)   *lpHTMLStr++ = HexToAsc ((bCode) >> 4);\
                                   *lpHTMLStr++ = HexToAsc ((bCode) & 0xf)

    DWORD   dwLen;
    BYTE    bCode;

    if (!lpText || !lpdwSize) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    dwLen = MAXLEN_PER_CHAR * lstrlen (lpText) + 1;

    if (!lpHTMLStr || *lpdwSize < dwLen) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        *lpdwSize = dwLen;
        return FALSE;
    }

    while (*lpText) {
        if ((DWORD) (*lpText) > 0xff ) {
            // Encode as ~0hhll hh is the high byte, ll is the low byte
            *lpHTMLStr++ = TEXT ('~');
            *lpHTMLStr++ = TEXT ('0');

            // Get the high byte
            bCode = (*lpText & 0xff00) >> 8;
            BIN2ASC(bCode,lpHTMLStr);

            // Get the low byte
            bCode = (*lpText & 0xff);
            BIN2ASC(bCode,lpHTMLStr);
        }
        else if ((DWORD) (*lpText) > 0x7f) {
            // Encode as ~xx
            *lpHTMLStr++ = TEXT ('~');
            bCode = *lpText & 0xff;
            BIN2ASC(bCode,lpHTMLStr);
        }
        else {
            *lpHTMLStr++ = *lpText;
        }
        lpText++;
    }
    *lpHTMLStr = NULL;
    return TRUE;
}

/*****************************************************************************\
* utlParseHostShare
*
* Parses the PortName (http://host[:port][/][/share]) into its
* post/Share/Port components.
*
* We accept six formats
*   1. http://server
*   2. http://server:port
*   3. http://server/
*   4. http://server:port/
*   5. http://server/share
*   6. http://server:port/share
*
* This routine returns allocated pointers that must be freed by the caller.
*
\*****************************************************************************/
BOOL utlParseHostShare(
    LPCTSTR lpszPortName,
    LPTSTR  *lpszHost,
    LPTSTR  *lpszShare,
    LPINTERNET_PORT  lpPort,
    LPBOOL  lpbHTTPS)
{
    LPTSTR lpszPrt;
    LPTSTR lpszTmp;
    LPTSTR lpszPos;
    BOOL   bRet = FALSE;


    // Initialize the return buffers to NULL.
    //
    *lpszHost  = NULL;
    *lpszShare = NULL;
    *lpPort    = 0;

    // Parse the host-name and the share name.  The pszPortName is
    // currently in the format of http://host[:portnumber]/share.  We will parse
    // this from left->right since the share-name can be a path (we
    // wouldn't really know the exact length).  However, we do know the
    // location for the host-name, and anything after that should be
    // the share-name.
    //
    // First find the ':'.  The host-name should begin two "//" after
    // that.
    //
    if (lpszPrt = memAllocStr(lpszPortName)) {
        static TCHAR szHttp[] = TEXT ("http://");
        static TCHAR szHttps[] = TEXT ("https://");

        lpszTmp = NULL;

        if (!_tcsnicmp (lpszPrt, szHttp, COUNTOF (szHttp) - 1)) {
            lpszTmp = lpszPrt + COUNTOF (szHttp) - 1;
            *lpbHTTPS = FALSE;
        }
        else if (!_tcsnicmp (lpszPrt, szHttps, COUNTOF (szHttps) - 1)) {
            lpszTmp = lpszPrt + COUNTOF (szHttps) - 1;
            *lpbHTTPS = TRUE;
        }

        if (lpszTmp) {

            lpszPos = utlStrChr(lpszTmp, TEXT(':'));
            if (lpszPos) {
                //This url has a port number, we need to parse it
                *lpszPos++ = 0;

                *lpszHost = memAllocStr(lpszTmp);
                *lpPort   = (INTERNET_PORT) _ttol (lpszPos);
                lpszTmp = lpszPos;

                if (lpszPos = utlStrChr(lpszTmp, TEXT('/'))) {
                    *lpszShare = memAllocStr(++lpszPos);
                }
                else {
                    *lpszShare = memAllocStr(TEXT (""));
                }
            }
            else {
                // Use the default port number: 80

                if (lpszPos = utlStrChr(lpszTmp, TEXT('/'))) {
                    *lpszPos++ = TEXT('\0');

                    *lpszHost  = memAllocStr(lpszTmp);
                    *lpszShare = memAllocStr(lpszPos);
                }
                else {
                    // The whole thing is a host name
                    *lpszHost  = memAllocStr(lpszTmp);
                    *lpszShare = memAllocStr(TEXT (""));

                }
            }

            if (*lpszShare) {

                //
                // Let's check if we need to encode the share name
                //

                INT iMode = IS_TEXT_UNICODE_ASCII16;

                if (IsTextUnicode ((LPVOID) *lpszShare, lstrlen (*lpszShare) * sizeof (WCHAR), &iMode) == 0) {

                    // The text string is a unicode string contains non-ASCII characters
                    // We need to encode the URL into ansi strings

                    DWORD dwSize;
                    BOOL bConversion = FALSE;
                    LPWSTR pszEncodedName = NULL;

                    EncodeUnicodePrinterName (*lpszShare, NULL, &dwSize);

                    if ((pszEncodedName = (LPWSTR) memAlloc (sizeof (WCHAR) * dwSize))) {

                        if (EncodeUnicodePrinterName (*lpszShare, pszEncodedName, &dwSize)) {
                            memFreeStr (*lpszShare);
                            *lpszShare = pszEncodedName;
                            bConversion = TRUE;
                        }
                    }

                    if (!bConversion) {
                        memFreeStr (pszEncodedName);
                        memFreeStr (*lpszShare);
                        *lpszShare = NULL;
                    }
                }
            }

            if (*lpszHost && *lpszShare) {

                bRet = TRUE;

            } else {

                // Don't worry that we could be freeing a NULL pointer.
                // The mem-routines check this.
                //
                memFreeStr(*lpszHost);
                memFreeStr(*lpszShare);

                *lpszHost  = NULL;
                *lpszShare = NULL;
            }
        }

        memFreeStr(lpszPrt);
    }

    return bRet;
}


/*****************************************************************************\
* utlStrChr
*
* Looks for the first location where (c) resides.
*
\*****************************************************************************/
LPTSTR utlStrChr(
    LPCTSTR cs,
    TCHAR   c)
{
    while (*cs != TEXT('\0')) {

        if (*cs == c)
            return (LPTSTR)cs;

        cs++;
    }

    // Fail to find c in cs.
    //
    return NULL;
}


/*****************************************************************************\
* utlStrChrR
*
* Looks for first occurrence of (c) starting from the end of the buffer.
*
\*****************************************************************************/
LPTSTR utlStrChrR(
    LPCTSTR cs,
    TCHAR   c)
{
    LPTSTR ct;

    ct = (LPTSTR)cs + (lstrlen(cs) - 1);

    while (ct >= cs) {

        if (*ct == c)
            return ct;

        ct--;
    }

    // Fail to find c in cs.
    //
    return NULL;
}


/*****************************************************************************\
* utlPackStrings
*
* This routine is called after the buffer size is calculated for all the
* strings returned in the packed structure.
*
\*****************************************************************************/
LPBYTE utlPackStrings(
   LPTSTR  *pSource,
   LPBYTE  pDest,
   LPDWORD pDestOffsets,
   LPBYTE  pEnd)
{
    while (*pDestOffsets != (DWORD)-1) {

        if (*pSource) {

            size_t uSize = lstrlen(*pSource) + 1;

            pEnd -= (uSize * sizeof(TCHAR));

            StringCchCopy((LPTSTR)pEnd, uSize, *pSource);

            *(LPTSTR *)(pDest + *pDestOffsets) = (LPTSTR)pEnd;

        } else {

            *(LPTSTR *)(pDest + *pDestOffsets) = TEXT('\0');
        }

        pSource++;
        pDestOffsets++;
    }

    return pEnd;
}


/*****************************************************************************\
* utlStrSize
*
* Returns the number of bytes needed to store a string including the NULL
* terminator.
*
\*****************************************************************************/
int utlStrSize(
    LPCTSTR lpszStr)
{
    return (lpszStr ? ((lstrlen(lpszStr) + 1) * sizeof(TCHAR)) : 0);
}

BOOL
MyName(
    PCTSTR pName
    )
{
    DWORD dwIndex = 0;

    if (!pName || !*pName)
        return TRUE;

    if (*pName == L'\\' && *(pName+1) == L'\\') {

        if (!lstrcmpi(pName, g_szMachine + 2))
            return TRUE;

        return CacheIsNameInNodeList(g_szMachine, pName + 2) == S_OK;

    }

    SetLastError(ERROR_INVALID_NAME);
    return FALSE;
}

/*****************************************************************************\
* GetUserName
*
* Retrieves the username for the current logged on thread.
*
\*****************************************************************************/
LPTSTR
GetUserName(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszUser;


    // Initialize the count and retrieve the number of characters
    // necessary for the username.
    //
    cbSize = 0;
    GetUserName(NULL, &cbSize);


    // If we were not able to retrieve a valid-count, then allocate
    // an empty string to return from this call.
    //
    if (cbSize) {

        if (lpszUser = (LPTSTR)memAlloc(cbSize * sizeof(TCHAR))) {

            if (GetUserName(lpszUser, &cbSize) == FALSE) {

                *lpszUser = TEXT('\0');

                goto log_error;
            }

        } else {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : GetUserName : Out of memory")));
        }

    } else {

        lpszUser = memAllocStr(TEXT("Unknown"));

log_error:

        DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : GetUserName Failed %d"), GetLastError()));
        SetLastError(ERROR_OUTOFMEMORY);
    }

    return lpszUser;
}

VOID
EndBrowserSession (
    VOID)
{
    g_pcsEndBrowserSessionLock->Lock();

    InetInternetSetOption(NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0);

    g_pcsEndBrowserSessionLock->Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\util.h ===
/*****************************************************************************\
* MODULE: util.h
*
* Private header for the Print-Processor library.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

// Constants defined.
//
#define PRINT_LEVEL_0        0
#define PRINT_LEVEL_1        1
#define PRINT_LEVEL_2        2
#define PRINT_LEVEL_3        3
#define PRINT_LEVEL_4        4
#define PRINT_LEVEL_5        5

#define PORT_LEVEL_1         1
#define PORT_LEVEL_2         2

#define COMPUTER_MAX_NAME   32


// Utility Routines.
//
PCINETMONPORT utlValidatePrinterHandle(
    HANDLE hPrinter);

PCINETMONPORT utlValidatePrinterHandleForClose(
    HANDLE hPrinter,
    PBOOL pbDeletePending);

LPTSTR utlValidateXcvPrinterHandle(
    HANDLE hPrinter);

BOOL utlParseHostShare(
    LPCTSTR lpszPortName,
    LPTSTR  *lpszHost,
    LPTSTR  *lpszShare,
    LPINTERNET_PORT  lpPort,
    LPBOOL  lpbHTTPS);

INT utlStrSize(
    LPCTSTR lpszStr);

LPBYTE utlPackStrings(
    LPTSTR  *pSource,
    LPBYTE  pDest,
    LPDWORD pDestOffsets,
    LPBYTE  pEnd);

LPTSTR utlStrChr(
    LPCTSTR cs,
    TCHAR   c);

LPTSTR utlStrChrR(
    LPCTSTR cs,
    TCHAR   c);

// ----------------------------------------------------------------------
//
// Impersonation utilities
//
// ----------------------------------------------------------------------

BOOL MyName(
    LPCTSTR pName
);

LPTSTR
GetUserName(VOID);

VOID
EndBrowserSession (
    VOID);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\cal.cxx ===
/***************************************************************************
FILE                            cal.cxx

MODULE                          Printers ISAPI DLL

PURPOSE                         Enforces Client Access Licensing

DESCRIBED IN

HISTORY     12/10/97 babakj     created

****************************************************************************/



/*  ==============================================================================
Issues:

Notes:
- I am assumuing the IIS enforcement for authenticated access is done per Post?
  So we should not have the problem with receiving part of the job, but rejecting
  the rest due to CAL denial (assuming we use single post job submission).
- So we end up consuming the CAL during the whole Post, even while our call back
  is waiting for the rest of the bytes from the Post. If the Post never completes,
  The clean up thread will kill the job and free up the CAL.
- NtLicenseRequest API defined in ntlsapi.h in sdk\inc
   (could return LS_INSUFFICIENT_UNITS in per-server) (sample in net\svcdlls\srvsvc\server\xsproc.c.

**********************************************************************************/


#include "pch.h"
#include "spool.h"

// To define the IIS Metabase GUIDs used in this file. Every other file defines
//   GUIDs as extern, except here where we actually define them in initguid.h.
#include <initguid.h>
#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines

#pragma hdrstop


#define MY_META_TIMEOUT 1000

TCHAR const c_szProductOptionsPath[] = TEXT( "System\\CurrentControlSet\\Control\\ProductOptions" );


HANDLE
RevertToPrinterSelf(
    VOID)
{
    HANDLE   NewToken, OldToken;
    NTSTATUS Status;

    NewToken = NULL;

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_IMPERSONATE,
                 TRUE,
                 &OldToken
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    Status = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&NewToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    return OldToken;

}

BOOL
ImpersonatePrinterClient(
    HANDLE  hToken)
{
    NTSTATUS    Status;

    Status = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&hToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    NtClose(hToken);

    return TRUE;
}


BOOL IsNTW()
{
    HKEY   hKey;
    TCHAR  szProductType[MAX_PATH+1];
    DWORD  cbData = sizeof(szProductType)-sizeof(szProductType[0]);

    static BOOL  fProductTypeKnown = FALSE;
    static BOOL  bIsNTW = TRUE;      // We are being forgiving. i.e. in case of a failure, we assume NTW, so no enforcement.


    if( !fProductTypeKnown ) {

        if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szProductOptionsPath, 0, KEY_READ, &hKey)) {

            szProductType[COUNTOF(szProductType) - 1] = 0x00;
            if( RegQueryValueEx( hKey, L"ProductType", NULL, NULL, (LPBYTE)szProductType, &cbData) == ERROR_SUCCESS ) {

                fProductTypeKnown = TRUE;   // We will never check again...
                if( !lstrcmpi( L"ServerNT", szProductType ))
                    bIsNTW = FALSE;
            }
            RegCloseKey( hKey );
        }
    }

    return bIsNTW;
}

//
// if REMOTE_USER is empty it means anonymous, else, it has the username being impersonated
//
BOOL IsUserAnonymous(
    EXTENSION_CONTROL_BLOCK *pECB
)
{
    char    szRemoteUser[ MAX_PATH ];   // ISAPI interface is ANSI
    ULONG   uSize = sizeof( szRemoteUser );

    szRemoteUser[ 0 ] = 0;   // Set it to empty ANSI string

    // Notice this is an ANSI call.
    pECB->GetServerVariable( pECB->ConnID, "REMOTE_USER", szRemoteUser, &uSize ) ;

    return( !(*szRemoteUser) );  // empty string should point to a zero char
}


//
// Gets user name of the anonymous IIS account by reading it from
// the Metabase's (IISADMIN) path w3svc/AnonymousUserName.
//
// - Returns TRUE if szAnonymousAccountUserName is filled in, FALSE if failed.
// - Caller is supposed to make sure szAnonymousAccountName is MAX_PATH * sizeof(TCHAR) long.
// - We get what "mdutil Get w3svc/AnonymousUserName" gets, e.g. IUSR_MACHINENAME.
//   I am ignoring the fact that the admin might have set the user name not per machine, rather
//   at a more granular level.

//
BOOL GetAnonymousAccountUserName(
    LPTSTR szAnonymousUserName,
    DWORD dwSize
)
{
    BOOL    bRet = FALSE;
    HRESULT hr;                         // com error status
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    CComPtr<IMSAdminBase> pIMeta;       // ATL smart ptr

    DWORD dwMDRequiredDataLen;
    METADATA_RECORD mr;

    HANDLE  hToken = NULL;

    // Need to revert to our service credential to be able to read IIS Metabase.
    hToken = RevertToPrinterSelf();


    if (hToken) {
        // Create a instance of the metabase object
        hr=::CoCreateInstance(CLSID_MSAdminBase,
                              NULL,
                              CLSCTX_ALL,
                              IID_IMSAdminBase,
                              (void **)&pIMeta);


        if( SUCCEEDED( hr )) {

            // open key to ROOT on website #1 (default)
            hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                 L"/LM",
                                 METADATA_PERMISSION_READ,
                                 MY_META_TIMEOUT,
                                 &hMeta);
            if( SUCCEEDED( hr )) {

                mr.dwMDIdentifier = MD_ANONYMOUS_USER_NAME;
                mr.dwMDAttributes = 0;
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = STRING_METADATA;
                mr.dwMDDataLen    = dwSize * sizeof(TCHAR);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(szAnonymousUserName);

                hr = pIMeta->GetData( hMeta, L"/W3svc", &mr, &dwMDRequiredDataLen );
                pIMeta->CloseKey( hMeta );

                if( SUCCEEDED( hr ))

                    bRet = TRUE;
            }
        }

        if (!ImpersonatePrinterClient(hToken))
            bRet = FALSE;
    }

    return bRet;
}


//
// Gets user name of the anonymous IIS account, combines with machine name g_szComputerName to
// get the format LocalMachineName\IUSR_LocalMachineName
//
// - Returns TRUE if szAnonymousAccountName is filled in, FALSE if failed.
// - Caller is supposed to make sure szAnonymousAccountName is MAX_PATH * sizeof(TCHAR) long.
//
BOOL GetAnonymousAccountName(
    LPTSTR szAnonymousAccountName,
    DWORD dwSize
)
{
    TCHAR szAnonymousUserName[MAX_PATH];
    ULONG uSize = dwSize;

    if( !GetComputerName( szAnonymousAccountName, &dwSize ))
        return FALSE;

    if( !GetAnonymousAccountUserName( szAnonymousUserName, MAX_PATH ))
        return FALSE;

    // Now add the user name to the machine name
    if (dwSize + 1 + lstrlen (szAnonymousUserName) < uSize )
    {
        DWORD bufSize = uSize - dwSize;
        if (SUCCEEDED (StringCchPrintf( &szAnonymousAccountName[dwSize], bufSize, L"\\%ws", szAnonymousUserName ) ) )
            return TRUE;
    }

    return FALSE;
}

//
// Enforce the Client Access Licensing
//
// Returns TRUE if license granted, FALSE otherwise. phLicense contains a license handle that needs
// to be freed later, or NULL if no license was really needed, like NTW, or if non-Anonymous user
// which will be enforced by IIS.
//
// NOTE: We only read the Anonymous account name once, for performance sake, even though it
//       could change during operation.
//
//
BOOL RequestLicense(
    LS_HANDLE *phLicense,
    LPEXTENSION_CONTROL_BLOCK pECB
)
{
    static TCHAR szAnonymousAccountName[ MAX_PATH ];
    static BOOL  fHaveReadAnonymousAccount = FALSE;

    if( !phLicense )
        return FALSE;

    *phLicense = NULL;

    if( IsNTW() || !IsUserAnonymous( pECB ))
        return TRUE;

    if( !fHaveReadAnonymousAccount )
        if( !GetAnonymousAccountName( szAnonymousAccountName , MAX_PATH ))
            return TRUE;       // CAL-wise, we need to be forgiving
        else
            fHaveReadAnonymousAccount = TRUE;


    NT_LS_DATA NtLSData;

    NtLSData.DataType = NT_LS_USER_NAME;
    NtLSData.Data = szAnonymousAccountName;
    NtLSData.IsAdmin = FALSE;    // why is this important to know   ??


    return( NT_SUCCESS( NtLicenseRequest( TEXT("FilePrint"),
                                          TEXT("5.0"),
                                          phLicense,
                                          &NtLSData )));
}


void FreeLicense(
    LS_HANDLE hLicense
)
{

//   hLicense of NULL means no license was needed (like NTW,
//   or non-anonymous case where IIS will take care of it.

    if( hLicense )
        NtLSFreeHandle( hLicense );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\gencab.cxx ===
/*****************************************************************************\
* MODULE: gencab.c
*
* The module contains routines for generating a self-extracting CAB file
* for the IExpress utility.  This relies on the cdfCreate and infCreate
* to create the objects for the IExpress process.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 <chriswil>  Created.
*
\*****************************************************************************/

#include "pch.h"
#include "spool.h"
#include <initguid.h>   // To define the IIS Metabase GUIDs used in this file. Every other file defines GUIDs as extern, except here where we actually define them in initguid.h.
#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines

#define CAB_TIMEOUT 1000

/*****************************************************************************\
* Critical Section Handling
*
\*****************************************************************************/

DWORD gdwCritOwner = 0;

VOID cab_enter_crit(VOID)
{
    EnterCriticalSection(&g_csGenCab);

    gdwCritOwner = GetCurrentThreadId();
}

VOID cab_leave_crit(VOID)
{
    gdwCritOwner = 0;

    LeaveCriticalSection(&g_csGenCab);
}

VOID cab_check_crit(VOID)
{
    DWORD dwCurrent = GetCurrentThreadId();

    SPLASSERT((dwCurrent == gdwCritOwner));
}

#define EnterCABCrit() cab_enter_crit()
#define LeaveCABCrit() cab_leave_crit()
#define CheckCABCrit() cab_check_crit()


/*****************************************************************************\
* cab_SetClientSecurity (Local Routine)
*
* This routine sets the thread security so that it has max-privileges.
*
\*****************************************************************************/
HANDLE cab_SetClientSecurity(VOID)
{
    HANDLE hToken;
    HANDLE hThread = GetCurrentThread();

    if (OpenThreadToken(hThread, TOKEN_IMPERSONATE, TRUE, &hToken)) {

        if (SetThreadToken(&hThread, NULL)) {

            return hToken;
        }

        CloseHandle(hToken);
    }

    return NULL;
}


/*****************************************************************************\
* cab_ResetClientSecurity (Local Routine)
*
* This routine resets the client-security to the token passed in.  This
* is called in order to set the thread to the original security attributes.
*
\*****************************************************************************/
BOOL cab_ResetClientSecurity(
    HANDLE hToken)
{
    BOOL bRet;

    bRet = SetThreadToken(NULL, hToken);

    CloseHandle(hToken);

    return bRet;
}


/*****************************************************************************\
* cab_iexpress_sync (Local Routine)
*
* This routine sychronizes the process and won't return until the process
* is done generating the CAB executable.
*
\*****************************************************************************/
BOOL cab_iexpress_sync(
    HANDLE hProcess)
{
    DWORD dwObj;
    DWORD dwExitCode;

    while (TRUE) {

        dwObj = WaitForSingleObject(hProcess, INFINITE);


        // Look for the exit type.
        //
        switch (dwObj) {

        // The process handle triggered the wait.  Let's get the
        // exit-code and return whether the success.  Otherwise,
        // drop through and return the failure.
        //
        case WAIT_OBJECT_0:
            GetExitCodeProcess(hProcess, &dwExitCode);

            if (dwExitCode == 0)
                return TRUE;


        // Something failed in the call.  We failed.
        //
        case WAIT_FAILED:
            return FALSE;
        }
    }
}


/*****************************************************************************\
* cab_force_delete_file
*
* Reset a files attributes before deleting it. We copied them to the temp dir
* so we can delete them no matter what.
*
\*****************************************************************************/
VOID cab_force_delete_file(
    LPCTSTR lpszFileName)
{
    SetFileAttributes( lpszFileName, FILE_ATTRIBUTE_NORMAL );
    DeleteFile( lpszFileName );
}


/*****************************************************************************\
* cab_cleanup_files
*
* Cleanup any files left-over in our generation process.  Particularly,
* this will remove cab-files.
*
\*****************************************************************************/
VOID cab_cleanup_files(
    LPCTSTR lpszDstPath)
{
    TCHAR           szAllExt[MIN_CAB_BUFFER];
    HANDLE          hFind;
    DWORD           idx;
    DWORD           cItems;
    LPTSTR          lpszCurDir;
    WIN32_FIND_DATA wfd;


    static LPCTSTR s_szFiles[] = {

        g_szDotInf,
        g_szDotBin,
        g_szDotCat
    };



    // Put us into the destination directory where we
    // want to cleanup the files.
    //
    if (lpszCurDir = genGetCurDir()) {

        SetCurrentDirectory(lpszDstPath);

        // Delete the temporary dat-file used in building
        // the cdf-file
        //
        cab_force_delete_file(g_szDatFile);


        // Delete certain extension files.
        //
        cItems = sizeof(s_szFiles) / sizeof(s_szFiles[0]);

        for (idx = 0; idx < cItems; idx++) {

            StringCchPrintf(szAllExt, COUNTOF(szAllExt), TEXT("*%s"), s_szFiles[idx]);

            hFind = FindFirstFile(szAllExt, &wfd);

            if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

                do {

                    cab_force_delete_file(wfd.cFileName);

                } while (FindNextFile(hFind, &wfd));

                FindClose(hFind);
            }
        }

        SetCurrentDirectory(lpszCurDir);

        genGFree(lpszCurDir, genGSize(lpszCurDir));
    }

    return;
}


/*****************************************************************************\
* cab_rename_cab
*
* Renames the .CAB to the dstname.
*
\*****************************************************************************/
BOOL cab_rename_cab(
    LPCTSTR lpszDstName)
{
    LPTSTR lpszSrc;
    LPTSTR lpszDst;
    BOOL   bRet = FALSE;


    if (lpszSrc = genBuildFileName(NULL, lpszDstName, g_szDotCab)) {

        if (lpszDst = genBuildFileName(NULL, lpszDstName, g_szDotIpp)) {

            bRet = MoveFileEx(lpszSrc, lpszDst, MOVEFILE_REPLACE_EXISTING);

            genGFree(lpszDst, genGSize(lpszDst));
        }

        genGFree(lpszSrc, genGSize(lpszSrc));
    }

    return bRet;
}


/*****************************************************************************\
* cab_iexpress_exec (Local Routine)
*
* This exec's the IExpress utility to generate the self-extracting CAB
* file.
*
\*****************************************************************************/
BOOL cab_iexpress_exec(
    LPCTSTR lpszCabDir,
    LPCTSTR lpszDstName,
    LPCTSTR lpszSedFile)
{
    PROCESS_INFORMATION pi;
    STARTUPINFO         sti;
    LPTSTR              lpszCmd;
    DWORD               cbSize;
    LPTSTR              lpszOldDir;
    BOOL                bSuccess = FALSE;

    TCHAR               szWindowDir[MAX_PATH];
    DWORD               dwWinDirLen = 0;

    if (dwWinDirLen = GetSystemWindowsDirectory (szWindowDir, MAX_PATH))
    {
        if (szWindowDir[dwWinDirLen - 1] == TEXT ('\\'))
        {
            szWindowDir[dwWinDirLen - 1] = 0;
        }

        // Calculate enough space to hold the command-line arguments.
        //
        cbSize = (dwWinDirLen + lstrlen(lpszSedFile) + lstrlen(g_szCabCmd) + 1) * sizeof(TCHAR);


        // Allocate the command-line for the create-process call.
        //
        if (lpszCmd = (LPTSTR)genGAlloc(cbSize)) {

            // Initialize startup-info fields.
            //
            memset(&sti, 0, sizeof(STARTUPINFO));
            sti.cb = sizeof(STARTUPINFO);


            // Build the command-line string that exec's IExpress.
            //
            if (SUCCEEDED(StringCbPrintf(lpszCmd, cbSize, g_szCabCmd, szWindowDir, lpszSedFile)))
            {

                // Change the directory to the cab/sed directory.  It
                // appears that IExpress requires this to generate.
                //
                if (lpszOldDir = genGetCurDir()) {

                    SetCurrentDirectory(lpszCabDir);


                    // Exec the process.
                    //
                    if (EXEC_PROCESS(lpszCmd, &sti, &pi)) {

                        CloseHandle(pi.hThread);

                        // This will wait until the process if finished generating
                        // the file.  The return from this indicates whether the
                        // generation succeeded or not.
                        //
                        if (cab_iexpress_sync(pi.hProcess))
                            bSuccess = cab_rename_cab(lpszDstName);

                        CloseHandle(pi.hProcess);
                    }


                    // Restore our current-directory and free up any strings.
                    //
                    SetCurrentDirectory(lpszOldDir);

                    genGFree(lpszOldDir, genGSize(lpszOldDir));
                }
            }
            genGFree(lpszCmd, cbSize);
        }
    }

    return bSuccess;
}


/*****************************************************************************\
* cab_get_modtime
*
* Returns the modified-time of the CAB file.  This can be used to determine
* whether this is out of date with other files.
*
\*****************************************************************************/
BOOL cab_get_modtime(
    LPTSTR     lpszOutPath,
    LPFILETIME lpft)
{
    HANDLE hFile;
    BOOL   bRet = FALSE;


    // Open the file for reading.
    //
    hFile = gen_OpenFileRead(lpszOutPath);


    // If the file exists and was opened, go get the time.
    //
    if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

        bRet = GetFileTime(hFile, NULL, NULL, lpft);

        CloseHandle(hFile);
    }

    return bRet;
}


/*****************************************************************************\
* cab_get_drvname (Local Routine)
*
* This routine attempts to open the printer, and retrieve the printer
* driver-name associated with the FriendlyName.  This returns to pointers
* to a driver and a share-name.
*
\*****************************************************************************/
BOOL cab_get_drvname(
    LPCTSTR lpszFriendlyName,
    LPTSTR* lpszDrvName,
    LPTSTR* lpszShrName,
    DWORD   idxPlt
    )
{
    HANDLE           hPrinter;
    LPPRINTER_INFO_2 lppi;
    DWORD            cbBuf;
    DWORD            cbNeed;
    BOOL             bRet = FALSE;


    // Initialize the pointers for the fail-case.
    //
    *lpszShrName = NULL;
    *lpszDrvName = NULL;


    // Open the printer and use the handle to query the printer for
    // the driver-name.
    //
    if (OpenPrinter((LPTSTR)lpszFriendlyName, &hPrinter, NULL)) {

        // First let's see how big our buffer will need to
        // be in order to hold the PRINTER_INFO_2.
        //
        cbBuf = 0;
        GetPrinter(hPrinter, PRT_LEV_2, NULL, 0, &cbBuf);


        // Allocate storage for holding the print-info structure.
        //
        if (cbBuf && (lppi = (LPPRINTER_INFO_2)genGAlloc(cbBuf))) {

            if (GetPrinter(hPrinter, PRT_LEV_2, (LPBYTE)lppi, cbBuf, &cbNeed)) {

                //If this is a Win9X client make sure the driver name is correct
                if ( genIsWin9X(idxPlt) )
                {
                    // Call get printer driver to get the actual driver name for Win9X
                    DWORD rc, cbNeeded;
                    GetPrinterDriver( hPrinter, (LPTSTR) genStrCliEnvironment(idxPlt), 3,
                                      NULL, 0, &cbNeeded);

                    rc = GetLastError();
                    if ( rc == ERROR_INSUFFICIENT_BUFFER )
                    {
                        LPBYTE pData;
                        DWORD dwSize = cbNeeded;

                        if ( pData = (LPBYTE) genGAlloc(cbNeeded) )
                        {
                            if ( GetPrinterDriver( hPrinter, (LPTSTR) genStrCliEnvironment(idxPlt), 3,
                                                   pData, dwSize, &cbNeeded) )
                            {
                                PDRIVER_INFO_3 pDriver = (PDRIVER_INFO_3) pData;
                                *lpszDrvName = genGAllocStr(pDriver->pName);
                            }
                            genGFree( pData, dwSize );
                        }
                    }
                    else
                        *lpszDrvName = genGAllocStr(lppi->pDriverName);
                }
                else
                    *lpszDrvName = genGAllocStr(lppi->pDriverName);

                if ( *lpszDrvName ) {

                    if (*lpszShrName = genGAllocStr(lppi->pShareName)) {

                        bRet = TRUE;

                    } else {

                        genGFree(*lpszDrvName, genGSize(*lpszDrvName));

                        *lpszDrvName = NULL;
                    }
                }
            }

            genGFree(lppi, cbBuf);
        }

        ClosePrinter(hPrinter);
    }

    return bRet;
}


/*****************************************************************************\
* cab_get_dstname
*
* Returns the then name of the destination-files.  The name built
* incorporates the platform/version so that it is not duplicated with
* any other files.
*
* <Share ChkSum><Arch><Ver>.webpnp
*
* i.e. <share chksum>AXP2 - NT Alpha 4.0
*      <share chksum>A863 - NT x86   5.0
*      <share chksum>AXP3 - NT Alpha 5.0
*      <share chksum>W9X0 - Win9X
*
\*****************************************************************************/
LPTSTR cab_get_dstname(
    DWORD   idxPlt,
    DWORD   idxVer,
    LPCTSTR lpszShr)
{
    int     cchBuf;
    LPCTSTR lpszPlt;
    LPTSTR  lpszName = NULL;


    // Get the platform requested for the client.
    //
    if (lpszPlt = genStrCliCab(idxPlt)) {

        cchBuf = lstrlen(lpszPlt) + MIN_CAB_BUFFER;


        // Build the cabname according to platform and version.
        //
        if (lpszName = (LPTSTR)genGAlloc(cchBuf * sizeof(TCHAR))) {

            if (FAILED(StringCchPrintf(lpszName, cchBuf, g_szCabName, genChkSum(lpszShr), lpszPlt, idxVer)))
            {
                genGFree(lpszName, genGSize(lpszName));
                lpszName = NULL;
            }
        }
    }

    return lpszName;
}


/*****************************************************************************\
* cab_get_name
*
* Returns the name of the returned-file.
*
\*****************************************************************************/
VOID cab_get_name(
    LPCTSTR lpszDstName,
    LPCTSTR lpszShrName,
    LPTSTR  lpszName)
{
    //
    // the buffer is allocated in msw3prt.cxx with MAX_PATH characters
    //
    StringCchPrintfW(lpszName, MAX_PATH, TEXT("/printers/%s/%s%s"), g_szPrtCabs, lpszDstName, g_szDotIpp);

    return;
}


/*****************************************************************************\
* cab_get_webdir
*
* Returns the virtual-root-directory where the cab-files are to be generated
* and stored.
*
\*****************************************************************************/
LPTSTR cab_get_webdir(VOID)
{
    HRESULT hr;                         // com error status
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    CComPtr<IMSAdminBase> pIMeta;       // ATL smart ptr
    DWORD dwMDRequiredDataLen;
    METADATA_RECORD mr;
    LPTSTR  lpszDir = NULL;
    TCHAR   szBuf[MAX_CAB_BUFFER];

    // Create a instance of the metabase object
    hr=::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta);


    if ( SUCCEEDED( hr ) )
    {

        // open key to ROOT on website #1 (default)
        hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                             g_szMetabasePath,
                             METADATA_PERMISSION_READ,
                             CAB_TIMEOUT,
                             &hMeta);
        if ( SUCCEEDED( hr ) )
        {

            mr.dwMDIdentifier = MD_VR_PATH;
            mr.dwMDAttributes = 0;
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = STRING_METADATA;
            mr.dwMDDataLen    = sizeof(szBuf);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(szBuf);

            hr = pIMeta->GetData( hMeta, L"", &mr, &dwMDRequiredDataLen );
            pIMeta->CloseKey( hMeta );

            if ( SUCCEEDED( hr ) )
            {
                lpszDir = genBuildFileName(szBuf, g_szPrtCabs, NULL);

            }
        }
    }

    return lpszDir;
}

/*****************************************************************************\
* cab_get_dstpath
*
* Returns a directory string where the cabinet files are to be generated.
*
\*****************************************************************************/
LPTSTR cab_get_dstpath(VOID)
{
    HANDLE hDir;
    LPTSTR lpszDir;


    // First, we need to find the virtual-directory-root the cab files
    // are located.
    //
    if (lpszDir = cab_get_webdir()) {

        // Make sure the directory exists, or we can create it.
        //
        hDir = gen_OpenDirectory(lpszDir);

        if (hDir && (hDir != INVALID_HANDLE_VALUE)) {

            CloseHandle(hDir);

        } else {

            if (CreateDirectory(lpszDir, NULL) == FALSE) {

                genGFree(lpszDir, genGSize(lpszDir));

                lpszDir = NULL;
            }
        }
    }

    return lpszDir;
}


/*****************************************************************************\
* GenerateCAB
*
* Main entry-point for generating the CAB file.
*
* Parameters
* ----------
*   lpszFriendlyName - Name of printer (shared-name).
*   lpszPortName     - Name of output port.
*   dwCliInfo        - Client platform/architecture/version information.
*   lpszOutName      - This is returned to the caller specifying the output.
*
\*****************************************************************************/
DWORD GenerateCAB(
    LPCTSTR lpszFriendlyName,
    LPCTSTR lpszPortName,
    DWORD   dwCliInfo,
    LPTSTR  lpszOutName,
    BOOL    bSecure)
{
    INFGENPARM infParm;
    HANDLE     hToken;
    HANDLE     hsed;
    HANDLE     hinf;
    FILETIME   ftSED;
    FILETIME   ftCAB;
    DWORD      idxVer;
    DWORD      idxPlt;
    BOOL       bSed;
    BOOL       bCab;
    LPTSTR     lpszFullName;
    LPTSTR     lpszDrvName = NULL;
    LPTSTR     lpszShrName = NULL;
    LPTSTR     lpszDstName = NULL;
    LPTSTR     lpszDstPath = NULL;
    LPTSTR     lpszFrnName = NULL;
    LPCTSTR    lpszSedFile;
    DWORD      dwRet = HSE_STATUS_ERROR;
    DWORD      dwFailure = ERROR_SUCCESS;


    // Initialize the security-token so that we will have
    // max-privileges during the file-creation.
    //
    if ((hToken = cab_SetClientSecurity()) == NULL) {

        DBGMSG(DBG_ERROR, ("GenerateCab : Access Denied"));
        goto RetCabDone;
    }


    // Get the platform and version of the client (map to an index
    // into tables).  Validate the indexes to assure the information
    // is valid.
    //
    idxPlt = genIdxCliPlatform(dwCliInfo);
    idxVer = genIdxCliVersion(dwCliInfo);

    if ((idxPlt == IDX_UNKNOWN) || (idxVer == IDX_UNKNOWN)) {

        dwFailure = ERROR_BAD_ENVIRONMENT;
        DBGMSG(DBG_ERROR, ("GenerateCab : Unsupported client architecture/version"));
        goto RetCabDone;
    }


    // Get the directory where the cab-files will be placed.
    //
    if ((lpszDstPath = cab_get_dstpath()) == NULL)
        goto RetCabDone;


    // Build a cluster-capable friendly-name.
    //
    if ((lpszFrnName = genFrnName(lpszFriendlyName)) == NULL)
        goto RetCabDone;


    // Get the driver information about the friendly-name.
    //
    if (cab_get_drvname(lpszFrnName, &lpszDrvName, &lpszShrName, idxPlt) == FALSE)
        goto RetCabDone;


    // Get the destination-name.
    //
    if ((lpszDstName = cab_get_dstname(idxPlt, idxVer, lpszShrName)) == NULL)
        goto RetCabDone;


    // Fill in the inf-input-parameters.  These values should be
    // validated at this point.
    //
    infParm.lpszFriendlyName = lpszFrnName;
    infParm.lpszShareName    = lpszShrName;
    infParm.lpszPortName     = lpszPortName;
    infParm.idxPlt           = idxPlt;
    infParm.idxVer           = idxVer;
    infParm.dwCliInfo        = dwCliInfo;
    infParm.lpszDrvName      = lpszDrvName;
    infParm.lpszDstName      = lpszDstName;
    infParm.lpszDstPath      = lpszDstPath;


    // Grab the critical-section while we deal with generating
    // the files for the driver-install.
    //
    EnterCABCrit();


    // Call to have the INF/CDF files generated.  If
    // all goes well, then the SED file can be generated
    // using the INF as input.
    //
    if (hinf = infCreate(&infParm)) {

        // We created an INF object. Now process the INF
        if ( infProcess(hinf) ) {

            // Got good INF so now work on CDF
            if (hsed = cdfCreate(hinf, bSecure)) {

                // We created a CDF object. Now process the CDF
                if ( cdfProcess(hsed) ) {

                    // Allocate a string representing the full-path-name of
                    // the generated executable.
                    //
                    lpszFullName = genBuildFileName(lpszDstPath, lpszDstName, g_szDotIpp);

                    if (lpszFullName) {

                        // Get the name of the directive file that we'll be using
                        // to lauch the iexpress-package with.  Do not delete this
                        // pointer as it is handled by the SED object.
                        //
                        if (lpszSedFile = cdfGetName(hsed)) {

                            // Retrieve modified dates so that we can determine whether
                            // to generate a new-CAB or return an existing one.  If the
                            // calls return FALSE, the we can assume a file doesn't
                            // exist, so we'll generate an new one anyway.
                            //
                            bSed = cdfGetModTime(hsed, &ftSED);
                            bCab = cab_get_modtime(lpszFullName, &ftCAB);


                            // Get the name of the Cab-File that will be
                            // generated (or returned).  This is relative to the
                            // wwwroot path and is in the form /share/printer.
                            //
                            cab_get_name(lpszDstName, lpszShrName, lpszOutName);


                            // If the bCabMod is TRUE (meaning we have a CAB), and the
                            // SED is not newer than the CAB, then we really only need
                            // to return the existing CAB.  Otherwise, some files
                            // must have changed.
                            //
                            if ((bSed && bCab) && (CompareFileTime(&ftSED, &ftCAB) <= 0)) {

                                goto RetCabName;

                            } else {

                                if (cab_iexpress_exec(lpszDstPath, lpszDstName, lpszSedFile)) {
RetCabName:
                                    dwRet = HSE_STATUS_SUCCESS;
                                }
                                else
                                   dwFailure = ERROR_CANNOT_MAKE;
                            }
                        }
                        else   // If cdfGetName
                           dwFailure = GetLastError();

                        genGFree(lpszFullName, genGSize(lpszFullName));
                    }
                    else   //  If lpszFullName
                       dwFailure = GetLastError();

                }
                else   // If cdfProcess()
                   dwFailure = cdfGetError(hsed);   // Get saved error

                cdfCleanUpSourceFiles(hinf);        // Even if cdfProcess fails it might have
                                                    // partialy generated some temporary files
                cdfDestroy(hsed);
            }
            else   // If cdfCreate
               dwFailure = GetLastError();
        }
        else   // If infProcess()
           dwFailure = infGetError(hinf);   // Get saved error

        infDestroy(hinf);
    }
    else   // If infCreate
       dwFailure = GetLastError();


    // Cleanup the files generated during processing.
    //
    cab_cleanup_files(lpszDstPath);


RetCabDone:

    // If something failed but we don't know what yet.. Get the error
    if ( (dwRet == HSE_STATUS_ERROR) && ( dwFailure == ERROR_SUCCESS ) )
       dwFailure = GetLastError();

    // Free our strings allocated through this scope.
    //
    if (lpszFrnName)
        genGFree(lpszFrnName, genGSize(lpszFrnName));

    if (lpszDrvName)
        genGFree(lpszDrvName, genGSize(lpszDrvName));

    if (lpszDstName)
        genGFree(lpszDstName, genGSize(lpszDstName));

    if (lpszShrName)
        genGFree(lpszShrName, genGSize(lpszShrName));

    if (lpszDstPath)
        genGFree(lpszDstPath, genGSize(lpszDstPath));

    if (hToken)
        cab_ResetClientSecurity(hToken);

    LeaveCABCrit();

    if (dwFailure != ERROR_SUCCESS)
       SetLastError(dwFailure);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\xcv.cxx ===
/*****************************************************************************\
* MODULE: xcv.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   03/31/00  WeihaiC     Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

#define SZINETPPUI  L"InetppUI.dll"

XCV_METHOD  gpXcvMethod[] = {
                            {L"MonitorUI", GetMonitorUI},
                            {L"AddPort", DoAddPort},
                            {INET_XCV_DELETE_PORT, DoDeletePort},
                            {INET_XCV_GET_CONFIGURATION,    DoGetConfiguration},
                            {INET_XCV_SET_CONFIGURATION,    DoSetConfiguration},
                            {NULL, NULL}
                            };

BOOL
bIsAdmin ()
{
    PRINTER_DEFAULTS pd = {NULL, NULL,  SERVER_ALL_ACCESS};
    HANDLE hServer;
    BOOL bRet = FALSE;

    if (OpenPrinter (NULL, &hServer, &pd)) {
        bRet = TRUE;

        ClosePrinter (hServer);
    }

    return bRet;
}


DWORD
XcvDataPort(
    PCINETMONPORT pPort,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    )
{
    DWORD dwRet;
    DWORD i;

    for(i = 0 ; gpXcvMethod[i].pszMethod &&
                wcscmp(gpXcvMethod[i].pszMethod, pszDataName) ; ++i)
        ;

    if (gpXcvMethod[i].pszMethod) {
        dwRet = (*gpXcvMethod[i].pfn)(  pInputData,
                                        cbInputData,
                                        pOutputData,
                                        cbOutputData,
                                        pcbOutputNeeded,
                                        pPort);

    } else {
        dwRet = ERROR_INVALID_PARAMETER;
    }

    return dwRet;
}

BOOL
PPXcvData(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus)
{
    HANDLE hPort;
    LPTSTR pszPortName;


    //
    // Valid input parameters
    //

    if (!pszDataName || IsBadStringPtr (pszDataName, MAX_INET_XCV_NAME_LEN) ||
        IsBadWritePtr (pdwStatus, sizeof (DWORD))) {
        return  ERROR_INVALID_PARAMETER;
    }

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPXcvData: Name(%s)"), pszDataName));

    semEnterCrit();

    if (pszPortName = utlValidateXcvPrinterHandle(hXcv)) {

        if (hPort = gpInetMon->InetmonFindPort (pszPortName)) {

            *pdwStatus = XcvDataPort((PCINETMONPORT) hPort, pszDataName, pInputData, cbInputData,
                                     pOutputData, cbOutputData, pcbOutputNeeded);
        }
        else {

            //
            // The port may not exit or  have been deleted.
            //
            *pdwStatus = ERROR_NOT_FOUND;
        }
    }
    else
        *pdwStatus = ERROR_INVALID_HANDLE;


    semLeaveCrit();

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPXcvData : Return Value(%d), LastError(%d)"), *pdwStatus, GetLastError()));

    return TRUE;
}

DWORD ValidateInputParameters (
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    CONST DWORD cdwInputDataRequired,
    CONST DWORD cdwOutputDataRequired)
{
    if (!pInputData || !pcbOutputNeeded ||
        (cdwInputDataRequired > 0 && cbInputData != cdwInputDataRequired) ||
        IsBadReadPtr (pInputData, cbInputData) ||

        (pOutputData && cbOutputData && IsBadWritePtr (pOutputData, cbOutputData)) ||
        (pcbOutputNeeded && IsBadWritePtr (pcbOutputNeeded, sizeof (DWORD)))) {

        return  ERROR_INVALID_PARAMETER;
    }

    if (cbOutputData < cdwOutputDataRequired) {
        *pcbOutputNeeded = cdwOutputDataRequired;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    return ERROR_SUCCESS;
}

DWORD
DoGetConfiguration(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
)
{
    PINET_XCV_GETCONFIGURATION_REQ_DATA pReqData = (PINET_XCV_GETCONFIGURATION_REQ_DATA) pInputData;
    PBYTE pEncryptedData = NULL;
    DWORD dwEncryptedDataSize;
    DWORD dwRet;

    //
    // Valid input parameters
    //

    dwRet = ValidateInputParameters (pInputData,
                                     cbInputData,
                                     pOutputData,
                                     cbOutputData,
                                     pcbOutputNeeded,
                                     sizeof (INET_XCV_GETCONFIGURATION_REQ_DATA),
                                     0);

    if (dwRet != ERROR_SUCCESS) {
        return dwRet;
    }

    if (pReqData->dwVersion != 1) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get Current Configuration
    //

    INET_XCV_CONFIGURATION ConfigData;

    if (pPort->GetCurrentConfiguration (&ConfigData)) {

        if (EncryptData ((PBYTE) &ConfigData, sizeof (INET_XCV_CONFIGURATION),  &pEncryptedData,  &dwEncryptedDataSize)) {

            if (cbOutputData < dwEncryptedDataSize) {
                *pcbOutputNeeded = dwEncryptedDataSize;
                dwRet = ERROR_INSUFFICIENT_BUFFER;
            }
            else {
                CopyMemory (pOutputData, pEncryptedData, dwEncryptedDataSize);
                *pcbOutputNeeded = dwEncryptedDataSize;
                dwRet = ERROR_SUCCESS;
            }

            LocalFree (pEncryptedData);
        }
        else
            dwRet = GetLastError ();
    }
    else
        dwRet = GetLastError ();

    return dwRet;
}

DWORD
DoSetConfiguration(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
)
{

    PINET_XCV_CONFIGURATION pReqData;
    DWORD dwRet;
    PBYTE pDecryptedData;
    DWORD dwDecryptedDataSize;


    if (DecryptData (pInputData, cbInputData,  &pDecryptedData,  &dwDecryptedDataSize)) {


        //
        // Valid input parameters
        //
        dwRet = ValidateInputParameters (pDecryptedData,
                                         dwDecryptedDataSize,
                                         pOutputData,
                                         cbOutputData,
                                         pcbOutputNeeded,
                                         sizeof (INET_XCV_CONFIGURATION),
                                         sizeof (INET_CONFIGUREPORT_RESPDATA));
        if (dwRet == ERROR_SUCCESS) {

            pReqData = (PINET_XCV_CONFIGURATION) pDecryptedData;

            if (pReqData->dwVersion != 1) {
                dwRet = ERROR_INVALID_PARAMETER;
            }
            else if (pReqData->bSettingForAll && !bIsAdmin ()) {
                //
                // If the setting is for per-port, but the caller is not an admin
                //
                dwRet = ERROR_ACCESS_DENIED;
            }
            else {

                //
                // We need to leave critical section before changing configurations,
                // before leaving critical section, we need to increase the ref count
                // so that other people won't delete it
                //

                semSafeLeaveCrit (pPort);

                //
                // Get Current Configuration
                //
                if (pPort->ConfigurePort (pReqData,
                                          (PINET_CONFIGUREPORT_RESPDATA) pOutputData,
                                          cbOutputData,
                                          pcbOutputNeeded))
                    dwRet = ERROR_SUCCESS;
                else
                    dwRet = GetLastError ();

                semSafeEnterCrit (pPort);


            }
        }

        LocalFree (pDecryptedData);
    }
    else
        dwRet = GetLastError ();

    return dwRet;
}

DWORD
DoDeletePort(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
)
{
    DWORD dwRet = ERROR_SUCCESS;

    DWORD cbNeeded, dwStatus;
    BOOL bRet = FALSE;

    dwRet = ValidateInputParameters (pInputData,
                                     cbInputData,
                                     pOutputData,
                                     cbOutputData,
                                     pcbOutputNeeded,
                                     0,
                                     0);

    if (dwRet != ERROR_SUCCESS) {
        return dwRet;
    }

    if (IsBadStringPtr ((LPWSTR) pInputData, cbInputData / sizeof (WCHAR)))
        return ERROR_INVALID_PARAMETER;


    if (bIsAdmin ()) {

        if (!PPDeletePort (NULL, NULL, (LPWSTR) pInputData)) {
             dwRet = GetLastError ();
        }

    }
    else
        dwRet = ERROR_ACCESS_DENIED;


    return dwRet;
}


DWORD
DoAddPort(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PCINETMONPORT pPort
)
{
    //
    // We don't support AddPort
    //

    return ERROR_ACCESS_DENIED;

}

DWORD
GetMonitorUI(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
)
{
    DWORD dwRet;

    *pcbOutputNeeded = sizeof( SZINETPPUI );

    if (cbOutputData < *pcbOutputNeeded) {

        dwRet =  ERROR_INSUFFICIENT_BUFFER;

    } else {

        StringCbCopy((WCHAR *)pOutputData, cbOutputData, SZINETPPUI);
        dwRet = ERROR_SUCCESS;
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\xcv.h ===
/*****************************************************************************\
* MODULE: authdlg.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   03/31/00  WeihaiC     Created
*
\*****************************************************************************/
#ifndef _INETPPXCV_H
#define _INETPPXCV_H


DWORD
GetMonitorUI(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PCINETMONPORT pPort
);

DWORD
DoDeletePort(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
);

DWORD
DoGetConfiguration(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
);

DWORD
DoSetConfiguration(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
);

DWORD
DoAddPort(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
);
              
typedef DWORD   (*PFN_XCV_PROTO_TYPE)( 
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort);

typedef struct {
    PWSTR pszMethod;
    PFN_XCV_PROTO_TYPE pfn;
} XCV_METHOD, *PXCV_METHOD;


DWORD
XcvDataPort(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    );

BOOL
XcvOpenPort(
    HANDLE hMonitor,
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    );


BOOL
XcvClosePort(
    HANDLE  hXcv
    );

BOOL
PPXcvData(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\gencab.h ===
/*****************************************************************************\
* MODULE: gencab.h
*
* This is the main header for the CAB generation module.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 <chriswil>  Created.
*
\*****************************************************************************/

// Constants.
//
#define MAX_CAB_BUFFER 1024
#define MIN_CAB_BUFFER   64


// Function Macro mappings.
//
#define EXEC_PROCESS(lpszCmd, psi, ppi) \
    CreateProcess(NULL, lpszCmd, NULL, NULL, FALSE, 0, NULL, NULL, psi, ppi)


// Critical-Section Function Mappings.
//
#define InitCABCrit()   InitializeCriticalSection(&g_csGenCab)
#define FreeCABCrit()   DeleteCriticalSection(&g_csGenCab)


// Entry-point to the whole process.
//
DWORD GenerateCAB(
    LPCTSTR lpszFriendlyName,
    LPCTSTR lpszPortName,
    DWORD   dwCliInfo,
    LPTSTR  lpszOutputName,
    BOOL    bSecure);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\gencdf.cxx ===
/*****************************************************************************\
* MODULE: gencdf.c
*
* The module contains routines for generating a CDF (Cabinet Directive File)
* for the IExpress utility.
*
* Work Items:
* ----------
* 1) Redo item-allocations to use single block-heap and append information
*    to reduce heap-overhead.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 HWP-Guys    Created.
*
\*****************************************************************************/

#include "pch.h"

/*****************************************************************************\
* cdf_NextStr (Local Routine)
*
* Proceeds to the next string in a section-list.
*
\*****************************************************************************/
_inline LPTSTR cdf_NextStr(
    LPTSTR lpszStr)
{
    return (lpszStr + (lstrlen(lpszStr) + 1));
}


/******************************************************************************\
*
* GetDirectory (Local Routine)
*
* Returns the directory portion of a full pathname.
*
\******************************************************************************/
LPTSTR cdf_GetDirectoryWithSlash(LPTSTR lpszFile) {

    LPTSTR lpszSlash;
    LPTSTR lpszDir;

    lpszSlash = genFindRChar(lpszFile, TEXT('\\'));

    if (lpszSlash != NULL) {

        if (NULL != (lpszDir = (LPTSTR)genGAlloc((UINT32) (lpszSlash - lpszFile + 2) * sizeof(TCHAR)))) {

            StringCchCopy(lpszDir, (UINT32) (lpszSlash - lpszFile + 2), lpszFile);
            return lpszDir;
        }
    }

    return NULL;
}

/******************************************************************************\
*
* cdf_GetName (Local Routine)
*
* Returns the filename portion of a full pathname.
*
\******************************************************************************/
LPTSTR cdf_GetName(LPTSTR lpszFile) {

    LPTSTR lpszSlash;
    LPTSTR lpszName;
    int    nLength;

    lpszSlash = genFindRChar(lpszFile, TEXT('\\'));

    if (lpszSlash != NULL) {

        nLength = lstrlen(lpszSlash);

        if (NULL != (lpszName = (LPTSTR)genGAlloc((nLength * sizeof(TCHAR))))) {

            StringCchCopy(lpszName, nLength, ++lpszSlash);
            return lpszName;
        }
    }
    return NULL;
}

/*****************************************************************************\
* cdf_SFLAdd (Local Routine)
*
* Adds a new section to our linked-list of sections.  This adds it to the
* head of the list and returns a pointer to the new item (head).
*
\*****************************************************************************/
LPSRCFILES cdf_SFLAdd(
    LPSRCFILES psfList,
    LPCTSTR    lpszPath)
{
    LPSRCFILES psfItem;


    if (psfItem = (LPSRCFILES)genGAlloc(sizeof(SRCFILES))) {

        if (psfItem->lpszPath = genGAllocStr(lpszPath)) {

            // Allocate the files-list buffer.
            //
            if (psfItem->lpszFiles = (LPTSTR)genGAlloc(CDF_SRCFILE_BLOCK)) {

                // Position our item at the head.
                //
                psfItem->cbMax  = CDF_SRCFILE_BLOCK;
                psfItem->cbSize = 0;
                psfItem->pNext  = psfList;


                // Make sure our file beginning is zeroed.
                //
                *(psfItem->lpszFiles) = TEXT('\0');

                return psfItem;
            }

            genGFree(psfItem->lpszPath, genGSize(psfItem->lpszPath));
        }

        genGFree(psfItem, sizeof(SRCFILES));
    }

    DBGMSG(DBG_ERROR, ("cdf_SFLAdd : Out of memory"));

    return NULL;
}


/*****************************************************************************\
* cdf_SFLAddFile (Local Routine)
*
* Adds a file-item to the specified section-pointer.
*
\*****************************************************************************/
BOOL cdf_SFLAddFile(
    LPSRCFILES psfList,
    LPCTSTR    lpszFile)
{
    LPTSTR lpszList;
    LPTSTR lpszPtr;
    LPTSTR lpszNew;
    DWORD  cbSize;
    DWORD  cbOldSize;
    DWORD  cbNewSize;
    HRESULT hr;


    // Determine if adding this file exceeds our current maximum
    // buffer.  If so, then realloc a bigger chunk.  We are adding
    // two extra characters to account for the '%' which are to
    // be added to the lpszFile.
    //
    cbSize = (lstrlen(lpszFile) + 1 + 2) * sizeof(TCHAR);

    if ((psfList->cbSize + cbSize) >= psfList->cbMax) {

        cbOldSize = genGSize(psfList->lpszFiles);
        cbNewSize = cbOldSize + CDF_SRCFILE_BLOCK;

        lpszNew = (LPTSTR)genGRealloc(psfList->lpszFiles, cbOldSize, cbNewSize);

        if (lpszNew == NULL) {

            DBGMSG(DBG_ERROR, ("cdf_SFLAddFile : Out of memory"));

            return FALSE;
        }


        // Set new limit criteria.
        //
        psfList->lpszFiles = lpszNew;
        psfList->cbMax     = cbNewSize;
    }


    // We are appending the file to the end of the list.
    //
    lpszPtr = (LPTSTR)(((LPBYTE)psfList->lpszFiles) + psfList->cbSize);

    if (SUCCEEDED(hr = StringCbPrintf(lpszPtr, cbSize, TEXT("%%%s%%\0"), lpszFile)))
    {
        psfList->cbSize += cbSize;
    }

    return SUCCEEDED(hr);
}


/*****************************************************************************\
* cdf_SFLFind (Local Routine)
*
* Looks for the existence of a section-name.
*
\*****************************************************************************/
LPSRCFILES cdf_SFLFind(
    LPSRCFILES psfList,
    LPCTSTR    lpszPath)
{
    while (psfList) {

        if (lstrcmpi(psfList->lpszPath, lpszPath) == 0)
            return psfList;

        psfList = psfList->pNext;
    }

    return NULL;
}


/*****************************************************************************\
* cdf_SFLFree (Local Routine)
*
* Frees up memory associated with the source-file-list.
*
\*****************************************************************************/
BOOL cdf_SFLFree(
    LPSRCFILES psfList)
{
    LPSRCFILES psfItem;


    while (psfList) {

        genGFree(psfList->lpszFiles, genGSize(psfList->lpszFiles));
        genGFree(psfList->lpszPath , genGSize(psfList->lpszPath));

        psfItem = psfList;
        psfList = psfList->pNext;

        genGFree(psfItem, genGSize(psfItem));
    }

    return TRUE;
}


/*****************************************************************************\
* cdf_WriteStrings
*
* Outputs a string to the [Strings] section.
*
\*****************************************************************************/
_inline BOOL cdf_WriteStrings(
    LPCTSTR lpszCdfFile,
    LPCTSTR lpszKey,
    LPCTSTR lpszStr)
{
    return WritePrivateProfileString(g_szStrings, lpszKey, lpszStr, lpszCdfFile);
}


/*****************************************************************************\
* itm_InitList (Local Routine)
*
* Initializes the file-item-list.
*
\*****************************************************************************/
_inline VOID itm_InitList(
    PCDFINFO pCdfInfo)
{
    pCdfInfo->pTop = NULL;
}


/*****************************************************************************\
* itm_GetFirst (Local Routine)
*
* Returns the first PMYITEM in the list
*
\*****************************************************************************/
_inline PFILEITEM itm_GetFirst(
    PCDFINFO pCdfInfo)
{
    return pCdfInfo->pTop;
}


/*****************************************************************************\
* itm_GetNext (Local Routine)
*
* Given the current item, returns the next item in the list.
*
\*****************************************************************************/
_inline PFILEITEM itm_GetNext(
    PFILEITEM pMyItem)
{
    SPLASSERT((pMyItem != NULL));

    return pMyItem->pNext;
}


/*****************************************************************************\
* itm_GetString (Local Routine)
*
* Returns a string associated with an item. You pick the
* string by passing the number of the string.
*
\*****************************************************************************/
_inline LPTSTR itm_GetString(
    PFILEITEM pMyItem,
    UINT      nItem)
{
    SPLASSERT((pMyItem != NULL));
    SPLASSERT((nItem <= FI_COL_LAST));

    return pMyItem->aszCols[nItem];
}


/*****************************************************************************\
* itm_FullPath (Local Routine)
*
* Return a fully-qualified pathname for the item.
*
\*****************************************************************************/
_inline LPTSTR itm_FullPath(
    PFILEITEM pItem)
{
    LPTSTR lpszPath;
    LPTSTR lpszFile;


    // Gather the strings and build the name.
    //
    lpszPath = itm_GetString(pItem, FI_COL_PATH);
    lpszFile = itm_GetString(pItem, FI_COL_FILENAME);

    return genBuildFileName(NULL, lpszPath, lpszFile);
}


/*****************************************************************************\
* itm_GetTime (Local Routine)
*
* Returns a time associated with an item.
*
\*****************************************************************************/
_inline FILETIME itm_GetTime(
    PFILEITEM pMyItem)
{
    SPLASSERT((pMyItem != NULL));

    return pMyItem->ftLastModify;
}


/*****************************************************************************\
* itm_SetTime (Local Routine)
*
* Sets the last modified time of the item.
*
\*****************************************************************************/
VOID itm_SetTime(
    PFILEITEM pMyItem,
    FILETIME  ftLastModify)
{
    SPLASSERT((pMyItem != NULL));

    pMyItem->ftLastModify = ftLastModify;
}


/*****************************************************************************\
* itm_Last (Local Routine)
*
* Used to end a while loop when we've reached the end of list
*
\*****************************************************************************/
_inline BOOL itm_Last(
    PFILEITEM pMyItem)
{
    return (pMyItem == NULL);
}


/*****************************************************************************\
* itm_Free (Local Routine)
*
* Frees the memory associated with an item.
*
\*****************************************************************************/
VOID itm_Free(
    PFILEITEM pItem)
{
    LPTSTR lpszStr;

    if (lpszStr = itm_GetString(pItem, FI_COL_FILENAME))
        genGFree(lpszStr, genGSize(lpszStr));

    if (lpszStr = itm_GetString(pItem, FI_COL_PATH))
        genGFree(lpszStr, genGSize(lpszStr));

    genGFree(pItem, sizeof(FILEITEM));
}


/*****************************************************************************\
* itm_DeleteAll (Local Routine)
*
* Deletes all the items from our file list.
*
\*****************************************************************************/
VOID itm_DeleteAll(
    PCDFINFO pCdfInfo)
{
    PFILEITEM pMyItem;
    PFILEITEM pTempItem;

    pMyItem = itm_GetFirst(pCdfInfo);

    while (itm_Last(pMyItem) == FALSE) {

        pTempItem = pMyItem;
        pMyItem   = itm_GetNext(pMyItem);

        itm_Free(pTempItem);
    }

    itm_InitList(pCdfInfo);
}


/*****************************************************************************\
* itm_Add (Local Routine)
*
* Adds an item to the list.
*
\*****************************************************************************/
PFILEITEM itm_Add(
    LPCTSTR  lpszFilename,
    LPCTSTR  lpszPath,
    PCDFINFO pCdfInfo)
{
    PFILEITEM pMyItem;

    SPLASSERT((lpszFilename != NULL));
    SPLASSERT((lpszPath != NULL));


    if (pMyItem = (PFILEITEM)genGAlloc(sizeof(FILEITEM))) {

        // Allocate the strings for the path/filename.
        //
        if (pMyItem->aszCols[FI_COL_FILENAME] = genGAllocStr(lpszFilename)) {

            if (pMyItem->aszCols[FI_COL_PATH] = genGAllocStr(lpszPath)) {

                pMyItem->pNext = pCdfInfo->pTop;
                pCdfInfo->pTop = pMyItem;

                return pMyItem;
            }

            genGFree(pMyItem->aszCols[FI_COL_FILENAME], genGSize(pMyItem->aszCols[FI_COL_FILENAME]));
        }

        genGFree(pMyItem, sizeof(FILEITEM));
    }

    return NULL;
}


/*****************************************************************************\
* itm_Find (Local Routine)
*
* To see if file is already in list
*
\*****************************************************************************/
PFILEITEM itm_Find(
    LPCTSTR  lpszFindFile,
    PCDFINFO pCdfInfo,
    BOOL     bMatchFullPath)
{
    PFILEITEM pItem = itm_GetFirst(pCdfInfo);
    LPTSTR    lpszItmFile;
    BOOL      bRet = FALSE;


    // Loop through our list of items looking for a file
    // match.
    //
    while (pItem) {

        // Build the file-name from the stored-strings.
        //
        if (bMatchFullPath)
            lpszItmFile = itm_FullPath(pItem);
        else
            lpszItmFile = itm_GetString(pItem, FI_COL_FILENAME);

        if (lpszItmFile) {

            // Check for match.
            //
            if (lstrcmpi(lpszFindFile, lpszItmFile) == 0) {

                // Found.
                //
                if (bMatchFullPath)
                    genGFree(lpszItmFile, genGSize(lpszItmFile));

                return pItem;
            }

            if (bMatchFullPath)
                genGFree(lpszItmFile, genGSize(lpszItmFile));

        } else {

            return NULL;
        }

        pItem = itm_GetNext(pItem);
    }

    return NULL;
}


/*****************************************************************************\
* cdf_WriteTimeStamps
*
* Outputs a struct to the [TimeStamps] section.
*
\*****************************************************************************/
_inline BOOL cdf_WriteTimeStamps(
    LPCTSTR    lpszCdfFile,
    LPCTSTR    lpszKey,
    LPFILEITEM pFileItem)
{
    FILETIME ft = itm_GetTime(pFileItem);

    return WritePrivateProfileStruct(g_szTimeStamps, lpszKey, &ft, sizeof(FILETIME), lpszCdfFile);
}


/*****************************************************************************\
* cdf_WriteSourceFiles
*
* Outputs a struct to the [SourceFiles] section.
*
\*****************************************************************************/
_inline BOOL cdf_WriteSourceFiles(
    LPCTSTR lpszCdfFile,
    LPCTSTR lpszKey,
    LPCTSTR lpszStr)
{
    return WritePrivateProfileString(g_szSourceFiles, lpszKey, lpszStr, lpszCdfFile);
}


/*****************************************************************************\
* cdf_GetSection (Local Routine)
*
* Allocate a buffer which stores either all section-names or the list of
* items specified by (lpszSection) in an INF file.  Currently, we attempt
* a realloc if the buffer is not big enough.
*
* NOTE: should we provide a limit for the amount of allocations before
*       we accept failure?
*
*       09-Dec-1996 : ChrisWil
*
\*****************************************************************************/
LPTSTR cdf_GetSection(
    LPCTSTR lpszSct,
    BOOL    bString,
    LPCTSTR lpszCdfFile)
{
    DWORD  dwCnt;
    DWORD  cch;
    DWORD  dwSize;
    DWORD  dwLimit;
    LPTSTR lpszNames = NULL;


    dwSize  = 0;
    dwLimit = 0;

    while (dwLimit < CDF_SECTION_LIMIT) {

        // We'll start this allocation with an assumed max-size.  Upon
        // successive tries, this buffer is increased each time by the
        // original buffer allocation.
        //
        dwSize += (CDF_SECTION_BLOCK * sizeof(TCHAR));
        dwLimit++;


        // Alloc the buffer and attempt to get the names.
        //
        if (lpszNames = (LPTSTR)genGAlloc(dwSize)) {

            // If a section-name is profided, use that.  Otherwise,
            // enumerate all section-names.
            //
            cch = dwSize / sizeof(TCHAR);

            if (bString) {

                dwCnt = GetPrivateProfileString(lpszSct,
                                                NULL,
                                                g_szEmptyStr,
                                                lpszNames,
                                                cch,
                                                lpszCdfFile);

            } else {

                dwCnt = GetPrivateProfileSection(lpszSct,
                                                 lpszNames,
                                                 cch,
                                                 lpszCdfFile);
            }


            // If the call says the buffer was OK, then we can
            // assume the names are retrieved.  According to spec's,
            // if the return-count is equal to size-2, then buffer
            // isn't quite big-enough (two NULL chars).
            //
            if (dwCnt < (cch - 2))
                goto GetSectDone;


            genGFree(lpszNames, dwSize);
            lpszNames = NULL;
        }
    }

GetSectDone:

    SPLASSERT((dwLimit < CDF_SECTION_LIMIT));

    return lpszNames;
}


/*****************************************************************************\
* cdf_GetValue (Local Routine)
*
*
\*****************************************************************************/
LPTSTR cdf_GetValue(
    LPCTSTR lpszSection,
    LPCTSTR lpszKey,
    LPCTSTR lpszCdfFile)
{
    TCHAR  szBuffer[STD_CDF_BUFFER];
    DWORD  cch;
    LPTSTR lpszVal = NULL;


    cch = GetPrivateProfileString(lpszSection,
                                  lpszKey,
                                  g_szEmptyStr,
                                  szBuffer,
                                  COUNTOF(szBuffer),
                                  lpszCdfFile);

    SPLASSERT((cch < STD_CDF_BUFFER));

    return (cch ? genGAllocStr(szBuffer) : NULL);
}


/*****************************************************************************\
* cdf_GetCdfFile (Local Routine)
*
* Returns an allocated string to the CDF file (Full-Path)
*
\*****************************************************************************/
LPTSTR cdf_GetCdfFile(
    PCDFINFO pCdfInfo)
{
    LPCTSTR lpszDstPath;
    LPCTSTR lpszDstName;


    // Retrieve the strings representing the destination path and name
    // of the output file.  These strings have already been validated
    // by the INF object.
    //
    lpszDstPath = infGetDstPath(pCdfInfo->hInf);
    lpszDstName = infGetDstName(pCdfInfo->hInf);


    return genBuildFileName(lpszDstPath, lpszDstName, g_szDotSed);
}


/*****************************************************************************\
* cdf_GetUncName (Local Routine)
*
* Returns an allocated string to the unc-name.
*
\*****************************************************************************/
LPTSTR cdf_GetUncName(
    PCDFINFO pCdfInfo)
{
    DWORD   cchSize;
    LPCTSTR lpszShrName;
    LPTSTR  lpszUncName = NULL;

    static CONST TCHAR s_szFmt[] = TEXT("\\\\%s\\%s");


    if (lpszShrName = infGetShareName(pCdfInfo->hInf)) {

        cchSize= lstrlen(g_szPrintServerName) +
                 lstrlen(lpszShrName)      +
                 lstrlen(s_szFmt)          +
                 1;

        if (lpszUncName = (LPTSTR)genGAlloc((cchSize * sizeof(TCHAR))))
        {
            if (FAILED(StringCchPrintf(lpszUncName, cchSize, s_szFmt, g_szPrintServerName, lpszShrName)))
            {
                genGFree(lpszUncName, genGSize(lpszUncName));
                lpszUncName = NULL;
            }
        }
    }

    return lpszUncName;
}


/*****************************************************************************\
* cdf_BuildFriendlyName (Local Routine)
*
* Builds a \\machinename\friendly type string so that the client can
* refer to the printer as "friendly on machinename".
*
\*****************************************************************************/
LPTSTR cdf_BuildFriendlyName(
    PCDFINFO pCdfInfo)
{
    DWORD   cchSize;
    LPCTSTR lpszFrnName;
    LPTSTR  lpszPtr;
    LPTSTR  lpszFmt;
    LPTSTR  lpszName = NULL;

    static TCHAR s_szFmt0[] = TEXT("\\\\http://%s\\%s");
    static TCHAR s_szFmt1[] = TEXT("\\\\https://%s\\%s");


    if (lpszFrnName = infGetFriendlyName(pCdfInfo->hInf)) {

        if (lpszPtr = genFindChar((LPTSTR)lpszFrnName, TEXT('\\'))) {

            lpszPtr++;
            lpszPtr++;

            if (lpszPtr = genFindChar(lpszPtr, TEXT('\\'))) {

                // Check if this is a secure request.
                //
                lpszFmt = (pCdfInfo->bSecure ? s_szFmt1 : s_szFmt0);


                // This is the friendly name, not the port name, so we don't
                // call GetWebpnpUrl to encode it.
                //
                cchSize= lstrlen(g_szHttpServerName) +
                         lstrlen(++lpszPtr)          +
                         lstrlen(lpszFmt)            +
                         1;

                if (lpszName = (LPTSTR)genGAlloc(cchSize * sizeof(TCHAR)))
                {
                    if (FAILED(StringCchPrintf(lpszName, cchSize, lpszFmt, g_szHttpServerName, lpszPtr)))
                    {
                        genGFree(lpszName, genGSize(lpszName));
                        lpszName = NULL;
                    }
                }
            }
        }
    }

    return lpszName;
}


/*****************************************************************************\
* cdf_ReadFiles (Local Routine)
*
* Reads in the files under the specified src-path-key.
*
\*****************************************************************************/
BOOL cdf_ReadFiles(
    LPCTSTR  lpszSrcPathKey,
    LPCTSTR  lpszSrcFiles,
    PCDFINFO pCdfInfo)
{
    FILETIME  ftFileTime;
    PFILEITEM pFileItem;
    LPTSTR    lpszPath;
    LPTSTR    lpszFiles;
    LPTSTR    lpszFile;
    LPTSTR    lpszStr;
    BOOL      bRet = FALSE;


    // For the specified SrcKeyPath, read in the list of files
    // associated with the path.
    //
    lpszFiles = cdf_GetSection(lpszSrcPathKey, FALSE, pCdfInfo->lpszCdfFile);

    if (lpszFiles) {

        // Get the path-value associated with the SrcPathKey.
        //
        if (lpszPath = cdf_GetValue(lpszSrcFiles, lpszSrcPathKey, pCdfInfo->lpszCdfFile)) {

            lpszFile = lpszFiles;

            while (*lpszFile) {

                // If the first-character doesn't specify a string-type
                // then we can add it directly.  Otherwise, we're going
                // to have to get the file referenced by the string.
                //
                if (lpszFile[0] != TEXT('%')) {

                    // Store the path and filename in the list.
                    //
                    pFileItem = itm_Add(lpszFile, lpszPath, pCdfInfo);
                    //
                    // Fail if we have run out of memory
                    //
                    if (!pFileItem)
                    {
                        goto ReadFileError;
                    }


                    // Read in file timestamp from .cdf.
                    //
                    if (GetPrivateProfileStruct(g_szTimeStamps,
                                                lpszFile,
                                                &ftFileTime,
                                                sizeof(FILETIME),
                                                pCdfInfo->lpszCdfFile)) {
                        // Store the timestamp.
                        //
                        itm_SetTime(pFileItem, ftFileTime);

                        lpszFile = cdf_NextStr(lpszFile);

                    } else {

                        goto ReadFileError;
                    }

                } else {

                    // Handle %filename% names (localizable strings)
                    // If the filename is delimited by two percent (%)
                    // signs,it is not a literal, but needs to be
                    // looked up [Strings] section of the .cdf file.
                    //
                    // Replace the % on the end of the string
                    // with a null char, then move past the end-char.
                    //
                    lpszFile[lstrlen(lpszFile) - 1] = TEXT('\0');
                    lpszFile++;


                    lpszStr = cdf_GetValue(g_szStrings,
                                           lpszFile,
                                           pCdfInfo->lpszCdfFile);

                    if (lpszStr) {

                        pFileItem = itm_Add(lpszStr, lpszPath, pCdfInfo);
                        
                        //
                        // Fail if we have run out of memory
                        //
                        if (!pFileItem)
                        {
                            genGFree(lpszStr, genGSize(lpszStr));
                            goto ReadFileError;
                        }

                        // Read in file timestamp from .cdf
                        //
                        GetPrivateProfileStruct(g_szTimeStamps,
                                                lpszFile,
                                                &ftFileTime,
                                                sizeof(FILETIME),
                                                pCdfInfo->lpszCdfFile);

                        genGFree(lpszStr, genGSize(lpszStr));

                        itm_SetTime(pFileItem, ftFileTime);


                        // We add 2 + len of string, because we put in an
                        // extra null to replace the % char
                        //
                        lpszFile = cdf_NextStr(lpszFile) + 1;

                    } else {

                        goto ReadFileError;
                    }
                }
            }

            bRet = TRUE;

ReadFileError:

            genGFree(lpszPath, genGSize(lpszPath));
        }

        genGFree(lpszFiles, genGSize(lpszFiles));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_ReadFileList (Local Routine)
*
* Reads in the file-list from the CDF-File.
*
\*****************************************************************************/
BOOL cdf_ReadFileList(
    PCDFINFO pCdfInfo)
{
    LPTSTR lpszSrcFiles;
    LPTSTR lpszSrcPaths;
    LPTSTR lpszPathKey;
    BOOL   bRet = FALSE;


    // Initialize the head of the list.
    //
    itm_InitList(pCdfInfo);


    // Get source files section of .cdf file
    //
    lpszSrcFiles = cdf_GetValue(g_szOptions,
                                g_szSourceFiles,
                                pCdfInfo->lpszCdfFile);

    if (lpszSrcFiles) {

        // Read in the entire SourceFiles section (as a list of keys).
        //
        lpszSrcPaths = cdf_GetSection(lpszSrcFiles,
                                      TRUE,
                                      pCdfInfo->lpszCdfFile);

        if (lpszPathKey = lpszSrcPaths) {

            // Each section name has a path associated with it.
            // For each section name, read in and add all the
            // files to the list
            //
            while (*lpszPathKey) {

                if (cdf_ReadFiles(lpszPathKey, lpszSrcFiles, pCdfInfo) == FALSE)
                    goto ReadListExit;

                lpszPathKey = cdf_NextStr(lpszPathKey);
            }

            bRet = TRUE;

ReadListExit:

            genGFree(lpszSrcPaths, genGSize(lpszSrcPaths));
        }

        genGFree(lpszSrcFiles, genGSize(lpszSrcFiles));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_AddCATFile (Local Routine)
*
* This is called by cdf_GetFileList for each file being added to the cdf.
* It uses the Catalog File Admin APIs to determine if the driver file was installed
* with an associated catalog file.  If a corresponding catalog file (or files)
* is found, the catalog filename (or filenames), along with its timestamp,
* is added to the cdf file list.
*
\*****************************************************************************/
BOOL cdf_AddCATFile(LPTSTR lpszFile, LPCDFINFO pCdfInfo ) {

    HCATADMIN       hCatAdmin = pCdfInfo->hCatAdmin;
    HCATINFO        hCatInfo = NULL;
    CATALOG_INFO    CatInfo;
    BYTE *          pbHash;
    DWORD           dwBytes;
    WIN32_FIND_DATA ffd;
    PFILEITEM       pFileItem;
    HANDLE          hFind, hFile;
    LPTSTR          pFullPath, pPath, pName;

    // Find the catalog file associated with this file.
    // If we can't find one, that's OK, it's not an error, just a file
    // with no associated .cat file.  The user can decide on the client-end
    // whether or not he wants to install without the verification a .cat file
    // would provide...
    //
    if (INVALID_HANDLE_VALUE != (HANDLE)hCatAdmin) {

        hFind = FindFirstFile(lpszFile, &ffd);

        if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

            FindClose(hFind);

            // Open the file in order to hash it.
            //
            if (INVALID_HANDLE_VALUE != (hFile = CreateFile(lpszFile,
                                                            GENERIC_READ,
                                                            FILE_SHARE_READ,
                                                            NULL,
                                                            OPEN_EXISTING,
                                                            FILE_ATTRIBUTE_NORMAL,
                                                            NULL))) {

                // Determine how many bytes we need for the hash
                //
                dwBytes = 0;
                pbHash = NULL;
                CryptCATAdminCalcHashFromFileHandle(hFile, &dwBytes, pbHash, 0);

                if (NULL != (pbHash = (BYTE *)genGAlloc(dwBytes))) {

                    // Compute the hash for this file
                    //
                    if (CryptCATAdminCalcHashFromFileHandle(hFile, &dwBytes, pbHash, 0)) {

                        // Get the catalog file(s) associated with this file hash
                        //
                        hCatInfo = NULL;

                        do {

                            hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, dwBytes, 0, &hCatInfo);

                            if (NULL != hCatInfo) {

                                // Split the cat name into file and path here
                                //
                                if (CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, NULL)) {

                                    if (NULL != (pFullPath = genTCFromWC(CatInfo.wszCatalogFile))) {

                                        if (NULL != (pPath = cdf_GetDirectoryWithSlash(pFullPath))) {

                                            if (NULL != (pName = cdf_GetName(pFullPath))) {

                                                // Make sure the file is not already in the cdf, so
                                                // IExpress doesn't give out (see BUG: explanation in cdf_GetFileList() )
                                                //
                                                if (NULL == itm_Find(pName, pCdfInfo, FALSE)) {
                                                    // Add the catalog file and timestamp

                                                    pFileItem = itm_Add(pName, pPath, pCdfInfo);

                                                    if (pFileItem)
                                                    {
                                                        itm_SetTime(pFileItem, ffd.ftLastWriteTime);
                                                    }                                                    
                                                }

                                                genGFree(pName, genGSize(pName) );
                                            }

                                            genGFree(pPath, genGSize(pPath) );
                                        }

                                        genGFree(pFullPath, genGSize(pFullPath) );
                                    }

                                }

                            }

                        } while (NULL != hCatInfo);

                    }

                    genGFree(pbHash, dwBytes);
                }

                CloseHandle(hFile);
            }
        }
    }

    return TRUE;
}


/*****************************************************************************\
* cdf_GetFileList (Local Routine)
*
* This is a callback function passed to infEnumItems()
* It reads in the list of files from the INF object, and reads
* the filetimes from the disk and adds these to the list also.
*
\*****************************************************************************/
BOOL CALLBACK cdf_GetFileList(
    LPCTSTR lpszName,
    LPCTSTR lpszPath,
    BOOL    bInf,
    LPVOID  lpData)
{
    PCDFINFO        pCdfInfo = (PCDFINFO)lpData;
    HANDLE          hFind;
    PFILEITEM       pFileItem;
    LPTSTR          lpszFile;
    LPTSTR          lpszPtr;
    WIN32_FIND_DATA FindFileData;
    BOOL            bRet = FALSE;

    // Build fully qualified file name.
    //
    if (lpszFile = genBuildFileName(lpszPath, lpszName, NULL)) {

        hFind = FindFirstFile(lpszFile, &FindFileData);

        if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

            FindClose(hFind);

            // IExpress fails when it encounters the
            // same filename twice.  To work-around this,
            // we will prevent the inclusion of the second
            // file.  We will match the name-only.
            //
            if (itm_Find(lpszName, pCdfInfo, FALSE) == NULL) {

                // Add the item to the list of CDF-Files.  We
                // store the path-name with the trailing '\'
                // because the CDF format requires such.
                //
                lpszPtr = genFindRChar(lpszFile, TEXT('\\'));

                // Is filename of right format?
                //
                if ( lpszPtr != NULL ) {

                    *(++lpszPtr) = TEXT('\0');
                    pFileItem = itm_Add(lpszName, lpszFile, pCdfInfo);


                    // Set the item-time. This should only fail if we couldn't allocate memory
                    //
                    if (pFileItem != NULL)  {
                        itm_SetTime(pFileItem, FindFileData.ftLastWriteTime);
                        bRet = TRUE;
                    }
                }
                else
                    SetLastError(ERROR_INVALID_PARAMETER);
            }
            else
                bRet = TRUE;    // Item already exits, so TRUE
        }

        genGFree(lpszFile, genGSize(lpszFile));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_CheckFiles (Local Routine)
*
* This is a callback function passed to infEnumItems()
* It checks each filename to see if it is in the .cdf list,
* and if it is up to date.
*
\*****************************************************************************/
BOOL CALLBACK cdf_CheckFiles(
    LPCTSTR lpszName,
    LPCTSTR lpszPath,
    BOOL    bInfFile,
    LPVOID  lpData)
{
    PCDFINFO        pCdfInfo = (PCDFINFO)lpData;
    HANDLE          hFind;
    PFILEITEM       pFileItem;
    LPTSTR          lpszFile;
    LPTSTR          lpszPtr;
    WIN32_FIND_DATA FindFileData;
    LONG            lCompare;
    BOOL            bRet = FALSE;


    // Build fully qualified filename.
    //
    if (lpszFile = genBuildFileName(lpszPath, lpszName, NULL)) {

        // Locate the item, and see if the dates are out-of-sync.
        //
        if (pFileItem = itm_Find(lpszFile, pCdfInfo, TRUE)) {

            hFind = FindFirstFile(lpszFile, &FindFileData);

            if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

                FindClose(hFind);


                // Compare the file-times.
                //
                lCompare = CompareFileTime(&FindFileData.ftLastWriteTime,
                                           &pFileItem->ftLastModify);


                // Skip over INF files since we are generating
                // these in the INF object.
                //
                if (bInfFile || (lCompare == 0))
                    bRet = TRUE;
            }
        }

        genGFree(lpszFile, genGSize(lpszFile));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_get_datfile
*
* Returns the then name of the dat-file.  The name built incorporates
* the sharename to distinguish it from other dat-files in the directory.
* any other files.
*
* <path>\<Share ChkSum>.dat
*
\*****************************************************************************/
LPTSTR cdf_get_datfile(
    LPCTSTR lpszDstPath,
    LPCTSTR lpszShrName)
{
    TCHAR szName[MIN_CDF_BUFFER];

    // Build the name using the checksum.
    //
    StringCchPrintf(szName, COUNTOF(szName), g_szDatName, genChkSum(lpszShrName));

    return genBuildFileName(lpszDstPath, szName, g_szDotDat);
}


/*****************************************************************************\
* cdf_IsDatCurrent (Local Routine)
*
* Checks the port-name in the dat-file for match.  If they do not, then we
* need to return FALSE to proceed with a new cab-generation.
*
\*****************************************************************************/
BOOL cdf_IsDatCurrent(
    PCDFINFO pCdfInfo)
{
    LPCTSTR lpszPrtName;
    LPCTSTR lpszDstPath;
    LPCTSTR lpszShrName;
    LPTSTR  lpszDatFile;
    LPTSTR  lpszDat;
    LPTSTR  lpszPtr;
    LPTSTR  lpszEnd;
    DWORD   cbSize;
    DWORD   cbRd;
    HANDLE  hFile;
    BOOL    bRet = FALSE;


    // Get the information from the INF-object so we can determine the
    // age of the dat-file.
    //
    lpszDstPath = infGetDstPath(pCdfInfo->hInf);
    lpszPrtName = infGetPrtName(pCdfInfo->hInf);
    lpszShrName = infGetShareName(pCdfInfo->hInf);


    // Build the dat-file-name and open for reading.
    //
    if (lpszDatFile = cdf_get_datfile(lpszDstPath, lpszShrName)) {

        hFile = gen_OpenFileRead(lpszDatFile);

        if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

            cbSize = GetFileSize(hFile, NULL);

            if (lpszDat = (LPTSTR)genGAlloc(cbSize)) {

                if (ReadFile(hFile, lpszDat, cbSize, &cbRd, NULL)) {

                    lpszPtr = lpszDat;

                    while (lpszPtr = genFindChar(lpszPtr, TEXT('/'))) {

                        if (*(++lpszPtr) == TEXT('r')) {

                            lpszPtr++;  // space
                            lpszPtr++;  // quote

                            if (lpszEnd = genFindChar(++lpszPtr, TEXT('\"'))) {

                                *lpszEnd = TEXT('\0');

                                if (lstrcmpi(lpszPtr, lpszPrtName) == 0)
                                    bRet = TRUE;

                                *lpszEnd = TEXT('\"');
                            }

                            break;
                        }


                        // Position pointer to the next flag.
                        //
                        lpszPtr = genFindChar(lpszPtr, TEXT('\n'));
                    }
                }

                genGFree(lpszDat, cbSize);
            }

            CloseHandle(hFile);
        }

        genGFree(lpszDatFile, genGSize(lpszDatFile));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_IsUpToDate (Local Routine)
*
* Determines if the CDF is up-to-date, or needs to be regenerated for
* this printer
*
\*****************************************************************************/
BOOL cdf_IsUpToDate(
    PCDFINFO pCdfInfo)
{
    BOOL bCurrent = FALSE;


    if (genUpdIPAddr()) {

        if (cdf_IsDatCurrent(pCdfInfo)) {

            // Read filelist into CdfInfo structure from .cdf file
            //
            if (cdf_ReadFileList(pCdfInfo)) {

                // Check files in .inf file to see if .cdf is still valid.
                //
                if (infEnumItems(pCdfInfo->hInf, cdf_CheckFiles, (LPVOID)pCdfInfo))
                    bCurrent = TRUE;
            }
        }
    }

    return bCurrent;
}


/*****************************************************************************\
* cdf_EnumICM (Local Routine)
*
* Callback to enumerate all ICM profiles in the BIN-File.  We only need to
* add these profiles to our list of CDF-Files that we package up.
*
\*****************************************************************************/
BOOL CALLBACK cdf_EnumICM(
    LPCTSTR lpszPath,
    LPCTSTR lpszFile,
    LPVOID  lpParm)
{
    return cdf_GetFileList(lpszFile, lpszPath, FALSE, lpParm);
}


/*****************************************************************************\
* cdf_WriteSourceFilesSection (Local Routine)
*
*
\*****************************************************************************/
BOOL cdf_WriteSourceFilesSection(
    PCDFINFO   pCdfInfo,
    LPSRCFILES psfList)
{
    TCHAR szSection[STD_CDF_BUFFER];
    int   idx;
    BOOL  bRet;


    for (idx = 0, bRet = TRUE; psfList; psfList = psfList->pNext) {

        // Build the section name (i.e. SourceFilesX).
        //
        bRet = SUCCEEDED(StringCchPrintf(szSection, COUNTOF(szSection), TEXT("%s%i"), g_szSourceFiles, idx++));

        // Write the source file section name in the [SourceFiles]
        // section.
        //
        if (bRet)
        {
            bRet = cdf_WriteSourceFiles(pCdfInfo->lpszCdfFile,
                                        szSection,
                                        psfList->lpszPath);
        }

        // Write out the [SourceFilesX] section.
        //
        if (bRet) {

            bRet = WritePrivateProfileSection(szSection,
                                              psfList->lpszFiles,
                                              pCdfInfo->lpszCdfFile);
        }
    }

    return bRet;
}


/*****************************************************************************\
* cdf_WriteBinFile (Local Routine)
*
* Writes the .BIN file.
*
\*****************************************************************************/
BOOL cdf_WriteBinFile(
    PCDFINFO pCdfInfo,
    LPCTSTR  lpszDstPath,
    LPCTSTR  lpszDstName)
{
    LPCTSTR lpszFriendlyName;
    LPTSTR  lpszBinFile;
    LPTSTR  lpszBinName;
    HANDLE  hPrinter;
    DWORD   dwCliInfo;
    BOOL    bRet = FALSE;


    if (lpszBinFile = genBuildFileName(lpszDstPath, lpszDstName, g_szDotBin)) {

        if (lpszBinName = genFindRChar(lpszBinFile, TEXT('\\'))) {

            // Increment to the next character for the name.
            //
            lpszBinName++;


            // Retrieve the printer-handle and proceed
            // to write the information to the BIN-File.
            //
            if (lpszFriendlyName = infGetFriendlyName(pCdfInfo->hInf)) {

                if (OpenPrinter((LPTSTR)lpszFriendlyName, &hPrinter, NULL)) {

                    dwCliInfo = infGetCliInfo(pCdfInfo->hInf);

                    // Call the routine to generate the BIN-File.
                    //
                    if (webWritePrinterInfo(hPrinter, lpszBinFile)) {

                        // Add the bin-file to the list of CDF-Files.
                        // Then add ICM-profiles to our list.
                        //
                        if (cdf_GetFileList(lpszBinName, lpszDstPath, FALSE, (LPVOID)pCdfInfo)) {

                            bRet = webEnumPrinterInfo(hPrinter,
                                                      dwCliInfo,
                                                      WEB_ENUM_ICM,
                                                      (FARPROC)cdf_EnumICM,
                                                      (LPVOID)pCdfInfo);
                        }
                    }


                    // Close the printer.
                    //
                    ClosePrinter(hPrinter);
                }
            }
        }

        genGFree(lpszBinFile, genGSize(lpszBinFile));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_WriteCdfCmd (Local Routine)
*
* Writes the .DAT file.
*
\*****************************************************************************/
BOOL cdf_WriteCdfCmd(
    PCDFINFO pCdfInfo,
    LPCTSTR  lpszUncName,
    LPCTSTR  lpszDstPath,
    LPCTSTR  lpszDstName)
{
    HANDLE  hFile;
    LPWSTR  lpszCmd;
    LPTSTR  lpszTmp;
    LPTSTR  lpszBinName;
    LPTSTR  lpszDatFile;
    LPTSTR  lpszDatTmp;
    LPTSTR  lpszFrnName;
    LPCTSTR lpszDrvName;
    LPCTSTR lpszPrtName;
    LPCTSTR lpszInfName;
    LPCTSTR lpszShrName;
    DWORD   dwWr;
    DWORD   cchSize;
    BOOL    bRet = FALSE;


    // Retrive the destination-file info.  These strings have
    // already been validated by the INF object.
    //
    lpszDrvName = infGetDrvName(pCdfInfo->hInf);
    lpszPrtName = infGetPrtName(pCdfInfo->hInf);
    lpszInfName = infGetInfName(pCdfInfo->hInf);
    lpszShrName = infGetShareName(pCdfInfo->hInf);


    // Build the dat-file.
    //
    if (lpszDatFile = cdf_get_datfile(lpszDstPath, lpszShrName)) {

        // This is a temporary duplicate of the (lpszDatFile) that
        // will be written to the cdf-command.  This is necessary so
        // that the client can have a static-name to use when the
        // cab is expanded.
        //
        if (lpszDatTmp = genBuildFileName(lpszDstPath, g_szDatFile, NULL)) {

            if (lpszBinName = genBuildFileName(NULL, lpszDstName, g_szDotBin)) {

                if (lpszFrnName = cdf_BuildFriendlyName(pCdfInfo)) {

                    // Write out the devmode.  If the DEVMODE-file (BIN) was
                    // written correctly, then we will go ahead and generate the
                    // dat-command-file.
                    //
                    if (cdf_WriteBinFile(pCdfInfo, lpszDstPath, lpszDstName)) {

                        cchSize= lstrlen(lpszFrnName)  +
                                 lstrlen(lpszInfName)  +
                                 lstrlen(lpszPrtName)  +
                                 lstrlen(lpszDrvName)  +
                                 lstrlen(lpszUncName)  +
                                 lstrlen(lpszBinName)  +
                                 lstrlen(g_szDatCmd)   +
                                 sizeof(WCHAR);

                        if (lpszTmp = (LPTSTR)genGAlloc(cchSize * sizeof(TCHAR))) {

                            // Build the Data-command.
                            //
                            StringCchPrintf(lpszTmp,
                                            cchSize, 
                                            g_szDatCmd,
                                            lpszFrnName,
                                            lpszInfName,
                                            lpszPrtName,
                                            lpszDrvName,
                                            lpszUncName,
                                            lpszBinName);


                            // Open the file for writing.
                            //
                            hFile = gen_OpenFileWrite(lpszDatFile);

                            if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

                                // This is here to assure the file written
                                // is in byte-format.  Otherwise, our strings
                                // written to the file would be in unicode
                                // format.
                                //
                                if (lpszCmd = genGAllocStr(lpszTmp)) {
                                    DWORD cbSize;

                                    cbSize = (DWORD)SIGNATURE_UNICODE;
                                    WriteFile(hFile, &cbSize, sizeof(WORD), &dwWr, NULL);

                                    cbSize = genGSize(lpszCmd);
                                    WriteFile(hFile, lpszCmd, cbSize, &dwWr, NULL);

                                    genGFree(lpszCmd, genGSize(lpszCmd));
                                }


                                CloseHandle(hFile);


                                // Make a copy of the file to a static name
                                // that will be used in the cdf/cab file.
                                //
                                CopyFile(lpszDatFile, lpszDatTmp, FALSE);


                                // Add the DAT-File to the list of CDF-Files.  Use
                                // the temporary file so that it is a static name
                                // as opposed to our check-sum generated file.
                                //
                                bRet = cdf_GetFileList(g_szDatFile,
                                                       lpszDstPath,
                                                       FALSE,
                                                       (LPVOID)pCdfInfo);
                            }

                            genGFree(lpszTmp, genGSize(lpszTmp));
                        }
                    }

                    genGFree(lpszFrnName, genGSize(lpszFrnName));
                }

                genGFree(lpszBinName, genGSize(lpszBinName));
            }

            genGFree(lpszDatTmp, genGSize(lpszDatTmp));
        }

        genGFree(lpszDatFile, genGSize(lpszDatFile));
    }

    return bRet;
}


/******************************************************************************
** cdf_GenerateSourceFiles (local routine)
**
** Find cases where the source and installed file names are diferent, copy the
** installed file to the cabs directory and rename it to the original target file
** name.
**
*******************************************************************************/
BOOL cdf_GenerateSourceFiles(
    HANDLE   hInf,
    LPCTSTR  lpszDstDir) {

    LPINFINFO       lpInf    = (LPINFINFO)hInf;
    BOOL            bRet     = lpInf != NULL;

    if (bRet) {
        DWORD           dwItems  = lpInf->lpInfItems->dwCount;
        LPINFITEMINFO   lpII     = lpInf->lpInfItems;

        for (DWORD idx = 0; idx < dwItems && bRet; idx++) {
            // We check to see if the file exists as advertised, if it does then we don't
            // change anything, otherwise, we search the system and windows directories to
            // find it, if it exists, we change the path accordingly
            LPTSTR      lpszSource = lpII->aItems[idx].szSource;

            if (*lpszSource) {      // There was a source name, we know it is different
                                    // from the target
                LPTSTR      lpszFile      = genBuildFileName( lpII->aItems[idx].szPath, lpII->aItems[idx].szName, NULL);
                LPTSTR      lpszDestFile  = genBuildFileName( lpszDstDir, lpszSource, NULL);

                if (lpszFile && lpszDestFile) {
                    StringCchCopy( lpII->aItems[idx].szPath, COUNTOF(lpII->aItems[idx].szPath), lpszDstDir);
                    StringCchCopy( lpII->aItems[idx].szName, COUNTOF(lpII->aItems[idx].szName), lpszSource);

                    bRet = CopyFile( lpszFile, lpszDestFile, FALSE);
                } else
                    bRet = FALSE;

                if (lpszFile)
                    genGFree(lpszFile, genGSize(lpszFile));

                if (lpszDestFile)
                    genGFree(lpszDestFile, genGSize(lpszDestFile) );
            }
        }
    }
    return bRet;
}



/*****************************************************************************\
* cdf_WriteFilesSection (Local Routine)
*
* Writes the dynamic file information.
*
\*****************************************************************************/
BOOL cdf_WriteFilesSection(
    PCDFINFO pCdfInfo)
{
    TCHAR      szFileX[MIN_CDF_BUFFER];
    LPCTSTR    lpszDstName;
    LPCTSTR    lpszDstPath;
    LPTSTR     lpszUncName;
    LPTSTR     lpszTmp;
    LPTSTR     lpszItem;
    DWORD      cchSize;
    int        idx;
    int        idxFile;
    PFILEITEM  pFileItem;
    LPSRCFILES psfList;
    LPSRCFILES psfItem;
    BOOL       bRet = FALSE;


    static CONST TCHAR s_szFmt0[] = TEXT("\"%s\\%s.webpnp\"");
    static CONST TCHAR s_szFmt1[] = TEXT("\"%s\"");


    if (lpszUncName = cdf_GetUncName(pCdfInfo)) {

        // Retreive the necessary strings from the INF object.  These
        // should already be validated as existing.  Otherwise, the creation
        // of the INF object would've failed.
        //
        lpszDstName = infGetDstName(pCdfInfo->hInf);
        lpszDstPath = infGetDstPath(pCdfInfo->hInf);


        // Build the TargetName and write to the CDF.
        //
        cchSize= lstrlen(lpszDstPath) +
                 lstrlen(lpszDstName) +
                 lstrlen(s_szFmt0)    +
                 1;

        if (lpszTmp = (LPTSTR)genGAlloc(cchSize * sizeof(TCHAR))) {
            StringCchPrintf(lpszTmp, cchSize, s_szFmt0, lpszDstPath, lpszDstName);
            bRet = cdf_WriteStrings(pCdfInfo->lpszCdfFile, g_szTargetName, lpszTmp);
            genGFree(lpszTmp, genGSize(lpszTmp));
        }


        // Now build cdf-install command; Write it to the CDF.
        //
        cchSize = lstrlen(lpszDstName) + lstrlen(g_szSedCmd) + 1;

        if (bRet && (lpszTmp = (LPTSTR)genGAlloc(cchSize * sizeof(TCHAR)))) {
            StringCchPrintf(lpszTmp, cchSize, g_szSedCmd, lpszDstName);
            bRet = cdf_WriteStrings(pCdfInfo->lpszCdfFile, g_szAppLaunched, lpszTmp);
            genGFree(lpszTmp, genGSize(lpszTmp));
        }


        // Read in all files and filetimes from .inf file (inf object)
        // Initialize the list.
        //
        itm_DeleteAll(pCdfInfo);
        itm_InitList(pCdfInfo);


        // Add all the files enumerated by the inf object.
        // Note: This enumeration includes the inf file itself, so
        // no need to make a special case for it.
        //
        if (bRet)
            bRet = cdf_GenerateSourceFiles( pCdfInfo->hInf, lpszDstPath );

        if (bRet) {
             if (infEnumItems(pCdfInfo->hInf, cdf_GetFileList, (LPVOID)pCdfInfo)) {


                // Generate the command-line for the URL rundll interface.
                //
                bRet = cdf_WriteCdfCmd(pCdfInfo,
                                       lpszUncName,
                                       lpszDstPath,
                                       lpszDstName);


                // Initialize the pointers/indexes that are used
                // to track our section information.
                //
                idxFile   = 0;
                pFileItem = itm_GetFirst(pCdfInfo);
                psfList   = NULL;


                // If the enumeration succeeded and we have files in the
                // list to process, then proceed to build our sections.
                //
                while (bRet && pFileItem) {

                    // Build our FILEx string.
                    //
                    StringCchPrintf(szFileX, COUNTOF(szFileX), TEXT("FILE%i"), idxFile++);


                    // Write out the quoted-item.
                    //
                    lpszItem = itm_GetString(pFileItem, FI_COL_FILENAME);

                    cchSize = lstrlen(lpszItem) + lstrlen(s_szFmt1) + 1;

                    if (lpszTmp = (LPTSTR)genGAlloc(cchSize * sizeof(TCHAR))) {
                        StringCchPrintf(lpszTmp, cchSize, s_szFmt1, lpszItem);
                        bRet = cdf_WriteStrings(pCdfInfo->lpszCdfFile, szFileX, lpszTmp);
                        genGFree(lpszTmp, genGSize(lpszTmp));
                    }


                    // Add timestamp to [TimeStamps] section for this file.
                    //
                    if (bRet) {

                        bRet = cdf_WriteTimeStamps(pCdfInfo->lpszCdfFile,
                                                   szFileX,
                                                   pFileItem);
                    }


                    // Look for existence of section (path).  If it exists,
                    // add the file to the section.  Otherwise, create a
                    // new section and add the file.
                    //
                    if (bRet) {

                        lpszItem = itm_GetString(pFileItem, FI_COL_PATH);

                        if ((psfItem = cdf_SFLFind(psfList, lpszItem)) == NULL) {

                            if (psfItem = cdf_SFLAdd(psfList, lpszItem)) {

                                psfList = psfItem;

                            } else {

                                bRet = FALSE;
                            }
                        }
                     }

                    // Add the file to the appropriate section.
                    //
                    if (bRet)
                        bRet = cdf_SFLAddFile(psfItem, szFileX);

                    // Get next file-item.
                    //
                    pFileItem = itm_GetNext(pFileItem);

                }

                // If all went OK in the enumeration, then we can write
                // the sections to the CDF file.
                //


                if (bRet)
                    bRet = cdf_WriteSourceFilesSection(pCdfInfo, psfList);

                    // Free up the Source-Files-List.
                    //
                cdf_SFLFree(psfList);


            } else
                bRet = FALSE;

        }
        genGFree(lpszUncName, genGSize(lpszUncName));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_WriteVersionSection (Local Routine)
*
* Writes the [Version] section in the CDF file.
*
\*****************************************************************************/
BOOL cdf_WriteVersionSection(
    PCDFINFO pCdfInfo)
{
    UINT uCount;
    UINT idx;
    BOOL bRet;

    static struct {

        LPCTSTR lpszKey;
        LPCTSTR lpszStr;

    } aszVer[] = {

        g_szClass     , g_szIExpress,
        g_szSEDVersion, g_szSEDVersionNumber
    };


    // Write out [Version] values.
    //
    uCount = sizeof(aszVer) / sizeof(aszVer[0]);

    for (idx = 0, bRet = TRUE; (idx < uCount) && bRet; idx++) {

        bRet = WritePrivateProfileString(g_szVersionSect,
                                         aszVer[idx].lpszKey,
                                         aszVer[idx].lpszStr,
                                         pCdfInfo->lpszCdfFile);
    }

    return bRet;
}


/*****************************************************************************\
* cdf_WriteOptionsSection (Local Routine)
*
* Writess the [Options] section in the CDF file.
*
\*****************************************************************************/
BOOL cdf_WriteOptionsSection(
    PCDFINFO pCdfInfo)
{
    UINT uCount;
    UINT idx;
    BOOL bRet;

    static struct {

        LPCTSTR lpszKey;
        LPCTSTR lpszStr;

    } aszOpt[] = {

        g_szPackagePurpose    , g_szCreateCAB,
        g_szExtractorStub     , g_szNone,
        g_szShowWindow        , g_sz0,
        g_szUseLongFileName   , g_sz1,
        g_szHideAnimate       , g_sz1,
        g_szRebootMode        , g_szNoReboot,
        g_szCompressionQuantum, g_szCompressionQuantVal,
        g_szTargetName        , g_szTargetNameSection,
        g_szAppLaunched       , g_szAppLaunchedSection,
        g_szSourceFiles       , g_szSourceFiles,
        g_szPostInstallCmd    , g_szNone,
        g_szCompressionType   , g_szCompressTypeVal,
        g_szCompressionMemory , g_szCompressionValue
    };


    // Write out [Options] values.
    //
    uCount = sizeof(aszOpt) / sizeof(aszOpt[0]);

    for (idx = 0, bRet = TRUE; (idx < uCount) && bRet; idx++) {

        bRet = WritePrivateProfileString(g_szOptions,
                                         aszOpt[idx].lpszKey,
                                         aszOpt[idx].lpszStr,
                                         pCdfInfo->lpszCdfFile);
    }


    return bRet;
}


/*****************************************************************************\
* cdf_Generate
*
* Creates a CDF file and writes it to disk.
*
\*****************************************************************************/
BOOL cdf_Generate(
    PCDFINFO pCdfInfo)
{
    if (cdf_WriteVersionSection(pCdfInfo) &&
        cdf_WriteOptionsSection(pCdfInfo) &&
        cdf_WriteFilesSection(pCdfInfo)) {

        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* cdfCreate
*
* Creates a CDF object.
*
* Parameters
* ----------
*   hinf - Handle to a INF object.  The CDF will inherit information from
*          the INF.
*
\*****************************************************************************/
HANDLE cdfCreate(
    HANDLE hinf,
    BOOL   bSecure)
{
    PCDFINFO pCdfInfo;


    if (pCdfInfo = (PCDFINFO)genGAlloc(sizeof(CDFINFO))) {

        // Initialize object-variables.
        //
        pCdfInfo->hInf    = hinf;
        pCdfInfo->bSecure = bSecure;

        return (HANDLE) pCdfInfo;
    }

    return NULL;
}


/*****************************************************************************\
* cdfProcess
*
* Process the CDF object.
*
\*****************************************************************************/
BOOL cdfProcess(
    HANDLE hcdf)
{
    HANDLE   hFile;
    PCDFINFO pCdfInfo;
    DWORD    dwErr;

    if (pCdfInfo = (PCDFINFO)hcdf) {

        if (pCdfInfo->lpszCdfFile = cdf_GetCdfFile(pCdfInfo)) {

            // Check for existence of .cdf file
            //
            hFile = gen_OpenFileRead(pCdfInfo->lpszCdfFile);

            if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

                // If we DO have a .cdf for this printer/architecture,
                // check if it is up to date.
                //
                CloseHandle(hFile);


                // If the .cdf we have is still up to
                // date, we are done.
                //
                if (cdf_IsUpToDate(pCdfInfo)) {

                    return TRUE;

                } else {

                    // Delete the old .cdf if it exists
                    //
                    DeleteFile(pCdfInfo->lpszCdfFile);

CdfGenerate:
                    // Generate a new one.
                    //
                    if (cdf_Generate(pCdfInfo))
                        return TRUE;
                }

            } else {

                dwErr = GetLastError();


                // Force an update of our machine ip-addr.  Usually,
                // this is called in the cdf_IsUpToDat() to verify
                // the machine hasn't changed ip-addresses.
                //
                genUpdIPAddr();


                // If we don't have a CDF already, generate one now.
                //
                if (dwErr == ERROR_FILE_NOT_FOUND)
                    goto CdfGenerate;
            }
        }

        cdfSetError(pCdfInfo,GetLastError());
    }

    return FALSE;
}


/*****************************************************************************\
* cdfDestroy
*
* Destroys the CDF object.
*
\*****************************************************************************/
BOOL cdfDestroy(
    HANDLE hcdf)
{
    PCDFINFO pCdfInfo;
    BOOL     bFree = FALSE;


    if (pCdfInfo = (PCDFINFO)hcdf) {

        // Free up any allocated objects.
        //
        if (pCdfInfo->lpszCdfFile)
            genGFree(pCdfInfo->lpszCdfFile, genGSize(pCdfInfo->lpszCdfFile));

        // Walk the list and free the file-item information.
        //
        itm_DeleteAll(pCdfInfo);

        bFree = genGFree(pCdfInfo, sizeof(CDFINFO));
    }

    return bFree;
}


/*****************************************************************************\
* cdfGetName
*
* Returns the name of the CDF file.  This will not include any path
* information.  This routine derives the filename from the stored full-path
* name in the CDF object.
*
\*****************************************************************************/
LPCTSTR cdfGetName(
    HANDLE hcdf)
{
    PCDFINFO pCdfInfo;
    LPCTSTR  lpszName = NULL;


    if (pCdfInfo = (PCDFINFO)hcdf) {

        if (lpszName = genFindRChar(pCdfInfo->lpszCdfFile, TEXT('\\')))
            lpszName++;
    }

    return lpszName;
}


/*****************************************************************************\
* cdfGetModTime
*
* Returns the time the CDF file was last modified.
*
\*****************************************************************************/
BOOL cdfGetModTime(
    HANDLE     hcdf,
    LPFILETIME lpftMod)
{
    HANDLE   hFile;
    PCDFINFO pCdfInfo;
    BOOL     bRet = FALSE;


    // Fill in struct-info.
    //
    lpftMod->dwLowDateTime  = 0;
    lpftMod->dwHighDateTime = 0;


    // Check the pointer for validity.
    //
    if (pCdfInfo = (PCDFINFO)hcdf) {

        // File should exist at this time, since cdfCreate should always
        // create the file.  Return false (error) if can't open file.
        //
        hFile = gen_OpenFileRead(pCdfInfo->lpszCdfFile);

        if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

            // Get the file creation time.
            //
            bRet = GetFileTime(hFile, NULL, NULL, lpftMod);

            CloseHandle(hFile);
        }
    }

    return bRet;
}

/*************************************************************************************
** cdfCleanUpSourceFiles
**
** This runs through all of the files that we returned from the inf file and in the
** case where there was a source we see if it is in the PrtCabs directory, if it is
** we delete it
**
*************************************************************************************/
VOID cdfCleanUpSourceFiles(
    HANDLE      hInf) {

    LPINFINFO       lpInf    = (LPINFINFO)hInf;

    if (lpInf) {
        DWORD           dwItems     = lpInf->lpInfItems->dwCount;
        LPINFITEMINFO   lpII        = lpInf->lpInfItems;
        LPCTSTR          lpszDstPath = infGetDstPath(hInf);
        // This can't be NULL or we wouldn't have allocated the INF structure

        if (*lpszDstPath) {  // Might not have been set though
            for (DWORD idx = 0; idx < dwItems; idx++) {
                // We check to see if the file exists as advertised, if it does then we don't
                // change anything, otherwise, we search the system and windows directories to
                // find it, if it exists, we change the path accordingly
                LPTSTR      lpszSource = lpII->aItems[idx].szSource;

                if (*lpszSource) {  // If there was a source file different to the target
                    LPTSTR      lpszName    = lpII->aItems[idx].szName;

                    if (!lstrcmp(lpszName,lpszSource)) { // If we renamed the target to the source
                        LPTSTR      lpszPath    = lpII->aItems[idx].szPath;

                        if (!lstrcmp(lpszPath,lpszDstPath)) { // If we set the path on the source
                            LPTSTR lpszFile = (LPTSTR)genBuildFileName(lpszPath, lpszName, NULL);

                            if (lpszFile) {
                                WIN32_FIND_DATA FindFileData;
                                HANDLE hFind = FindFirstFile(lpszFile, &FindFileData);

                                if (hFind && (hFind != INVALID_HANDLE_VALUE)) {
                                    FindClose(hFind);
                                    DeleteFile(lpszFile);
                                }

                                genGFree(lpszFile, genGSize(lpszFile));
                            }   // This is cleanup code, no point in failing it
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\gencdf.h ===
/*****************************************************************************\
* MODULE: gencdf.h
*
* This is the main header for the CDF generation module.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 HWP-Guys    Created.
*
\*****************************************************************************/

#define STD_CDF_BUFFER        256
#define MIN_CDF_BUFFER         16

#define CDF_SECTION_BLOCK    4096
#define CDF_SRCFILE_BLOCK    1024
#define CDF_SECTION_LIMIT       8


// Source-Files Structure.  This is used to track files
// by section.
//
typedef struct _SRCFILES {

    LPTSTR           lpszPath;
    LPTSTR           lpszFiles;
    DWORD            cbMax;
    DWORD            cbSize;
    struct _SRCFILES *pNext;

} SRCFILES;
typedef SRCFILES      *PSRCFILES;
typedef SRCFILES NEAR *NPSRCFILES;
typedef SRCFILES FAR  *LPSRCFILES;


// Element-Array idenifiers for FILEITEM
//
#define FI_MAX_ITEMS    2
#define FI_COL_FILENAME 0
#define FI_COL_PATH     1
#define FI_COL_LAST     1


// File-Item Structure.
//
typedef struct _FILEITEM {

    LPTSTR           aszCols[FI_MAX_ITEMS]; // Filename and Path.
    FILETIME         ftLastModify;          // Filetime stamp.
    struct _FILEITEM *pNext;                // Pointer to next File-Item.

} FILEITEM;
typedef FILEITEM      *PFILEITEM;
typedef FILEITEM NEAR *NPFILEITEM;
typedef FILEITEM FAR  *LPFILEITEM;


// CDF Object Structure.
//
typedef struct _CDFINFO {

    HANDLE    hInf;                  // Handle to current inf object
    DWORD     dwError;               // Error if CDF processing fails
    LPTSTR    lpszCdfFile;           // Full path-name to cdf-file.
    PFILEITEM pTop;                  // List of files to include in the .cdf
    HCATADMIN hCatAdmin;             // Context handle for catalog admin APIs
    BOOL      bSecure;

} CDFINFO;
typedef CDFINFO      *PCDFINFO;
typedef CDFINFO NEAR *NPCDFINFO;
typedef CDFINFO FAR  *LPCDFINFO;


// Interface Objects to CDF.
//
HANDLE cdfCreate(
    HANDLE hinf,
    BOOL   bSecure);

VOID cdfCleanUpSourceFiles(
    HANDLE hInf);

BOOL cdfProcess(
    HANDLE hcdf);

BOOL cdfDestroy(
    HANDLE hcdf);

LPCTSTR cdfGetName(
    HANDLE hcdf);

BOOL cdfGetModTime(
    HANDLE     hcdf,
    LPFILETIME lpftMod);

/***************************************\
* cdfGetError
\***************************************/
__inline DWORD cdfGetError(
    HANDLE hsed)
{
    return (hsed ? (DWORD)((PCDFINFO)hsed)->dwError : ERROR_SUCCESS);
}

/***************************************\
* cdfSetError
\***************************************/
__inline VOID cdfSetError(
    PCDFINFO  hsed,
    DWORD     dwError )
{
    hsed->dwError = dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\geninf.cxx ===
/*****************************************************************************\
* MODULE: geninf.c
*
* The module contains routines for generating a setup INF file.
*
*
* Needed Work
* -----------
* 1) look at reducing the item-list size to contiguous buffers.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 HWP-Guys    Created.
*
\*****************************************************************************/

#include "pch.h"

/******************************************************************************
** Defines
******************************************************************************/

/******************************************************************************
** Define      - INF_CAT_INCREMENT
** Description - The increment in size between cat file increments
******************************************************************************/
#if (!defined(INF_CAT_INCREMENT))
   #define INF_CAT_INCREMENT   16
#endif

/*****************************************************************************\
* inf_NextStr (Local Routine)
*
* Proceeds to the next string in a section-list.
*
\*****************************************************************************/
_inline LPTSTR inf_NextStr(
    LPTSTR lpszStr)
{
    return (lpszStr + (lstrlen(lpszStr) + 1));
}


/*****************************************************************************\
* inf_WriteInfSct (Local Routine)
*
* Writes a section to the 9x-generated-inf-file.
*
\*****************************************************************************/
_inline BOOL inf_WriteInfSct(
    HANDLE hFile,
    LPCSTR lpszSct)
{
    DWORD cbWr;

    return WriteFile(hFile, (LPBYTE)lpszSct, lstrlenA(lpszSct), &cbWr, NULL);
}


/*****************************************************************************\
* inf_GetInfMfgKey (Local Routine)
*
* Returns the first word of the drvname which is used to denote mfg-section.
*
\*****************************************************************************/
LPSTR inf_GetInfMfgKey(
    LPCTSTR lpszDrvName)
{
    LPTSTR lpszTmp;
    LPSTR  lpszMfg = NULL;


    if (lpszTmp = genFindChar((LPTSTR)lpszDrvName, TEXT(' '))) {

        *lpszTmp = TEXT('\0');

        lpszMfg = genMBFromTC(lpszDrvName);

        *lpszTmp = TEXT(' ');

    } else {

        lpszMfg = genMBFromTC(lpszDrvName);
    }

    return lpszMfg;
}


/*****************************************************************************\
* inf_WriteInfMfg (Local Routine)
*
* Writes the manufacturer section.
*
\*****************************************************************************/
_inline BOOL inf_WriteInfMfg(
    HANDLE  hFile,
    LPCTSTR lpszDrvName)
{
    DWORD  cbWr;
    LPSTR  lpszMfg;
    LPSTR  lpszBuf;
    DWORD  cbSize;
    BOOL   bRet = FALSE;


    if (lpszMfg = inf_GetInfMfgKey(lpszDrvName)) {

        cbSize = lstrlenA(g_szInfSctMfg) + lstrlenA(lpszMfg) + 1;

        if (lpszBuf = (LPSTR)genGAlloc(cbSize)) {

            if (SUCCEEDED(StringCbPrintfA(lpszBuf, cbSize, g_szInfSctMfg, lpszMfg)))
            {
                bRet = WriteFile(hFile, lpszBuf, lstrlenA(lpszBuf), &cbWr, NULL);
            }

            genGFree(lpszBuf, cbSize);
        }

        genGFree(lpszMfg, genGSize(lpszMfg));
    }

    return bRet;
}


/*****************************************************************************\
* inf_WriteInfDrv (Local Routine)
*
* Writes the driver-section.
*
\*****************************************************************************/
_inline BOOL inf_WriteInfDrv(
    HANDLE  hFile,
    LPCTSTR lpszDrvName,
    LPCTSTR lpszDrvPath)
{
    DWORD  cbWr;
    LPTSTR lpszTmp;
    LPSTR  lpszName;
    LPSTR  lpszFile;
    LPSTR  lpszMfg;
    LPSTR  lpszBuf;
    DWORD  cbSize;
    BOOL   bRet = FALSE;


    if (lpszMfg = inf_GetInfMfgKey(lpszDrvName)) {

        if (lpszTmp = genFindRChar((LPTSTR)lpszDrvPath, TEXT('\\'))) {

            if (lpszFile = genMBFromTC(++lpszTmp)) {

                if (lpszName = genMBFromTC(lpszDrvName)) {

                    cbSize = lstrlenA(g_szInfSctDrv) +
                             lstrlenA(lpszName)      +
                             lstrlenA(lpszFile)      +
                             lstrlenA(lpszMfg)       +
                             1;

                    if (lpszBuf = (LPSTR)genGAlloc(cbSize)) {

                        if (SUCCEEDED(StringCbPrintfA(lpszBuf, cbSize, g_szInfSctDrv, lpszMfg, lpszName, lpszFile)))
                        {
                            bRet = WriteFile(hFile, lpszBuf, lstrlenA(lpszBuf), &cbWr, NULL);
                        }

                        genGFree(lpszBuf, cbSize);
                    }

                    genGFree(lpszName, genGSize(lpszName));
                }

                genGFree(lpszFile, genGSize(lpszFile));
            }
        }

        genGFree(lpszMfg, genGSize(lpszMfg));
    }

    return bRet;
}


/*****************************************************************************\
* inf_WriteInfIns (Local Routine)
*
* Writes the install-section.
*
\*****************************************************************************/
_inline BOOL inf_WriteInfIns(
    HANDLE  hFile,
    LPCTSTR lpszDrvPath)
{
    DWORD  cbWr;
    LPTSTR lpszTmp;
    LPSTR  lpszFile;
    LPSTR  lpszBuf;
    DWORD  cbSize;
    BOOL   bRet = FALSE;



    if (lpszTmp = genFindRChar((LPTSTR)lpszDrvPath, TEXT('\\'))) {

        if (lpszFile = genMBFromTC(++lpszTmp)) {

            cbSize = lstrlenA(g_szInfSctIns) +
                     lstrlenA(lpszFile)      +
                     1;

            if (lpszBuf = (LPSTR)genGAlloc(cbSize)) {

                if (SUCCEEDED(StringCbPrintfA(lpszBuf, cbSize, g_szInfSctIns, lpszFile)))
                {
                    bRet = WriteFile(hFile, lpszBuf, lstrlenA(lpszBuf), &cbWr, NULL);
                }

                genGFree(lpszBuf, cbSize);
            }

            genGFree(lpszFile, genGSize(lpszFile));
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_WrintInfDta (Local Routine)
*
* Writes the data-section.
*
\*****************************************************************************/
_inline BOOL inf_WriteInfDta(
    HANDLE hFile,
    LPTSTR lpszDtaFile,
    LPTSTR lpszHlpFile)
{
    DWORD  cbWr;
    LPTSTR lpszDta;
    LPTSTR lpszHlp;
    LPSTR  lpszIns;
    LPSTR  lpszDtaName;
    LPSTR  lpszHlpName;
    DWORD  cbSize;
    BOOL   bRet = FALSE;


    if (lpszDta = genFindRChar(lpszDtaFile, TEXT('\\'))) {

        if (lpszHlp = genFindRChar(lpszHlpFile, TEXT('\\'))) {

            if (lpszDtaName = genMBFromTC(++lpszDta)) {

                if (lpszHlpName = genMBFromTC(++lpszHlp)) {

                    cbSize = lstrlenA(g_szInfSctIns) +
                             lstrlenA(lpszDtaName)   +
                             lstrlenA(lpszHlpName)   +
                             1;


                    if (lpszIns = (LPSTR)genGAlloc(cbSize)) {

                        if (SUCCEEDED(StringCbPrintfA(lpszIns, cbSize, g_szInfSctDta, lpszDtaName, lpszHlpName)))
                        {
                            bRet = WriteFile(hFile, lpszIns, lstrlenA(lpszIns), &cbWr, NULL);
                        }

                        genGFree(lpszIns, genGSize(lpszIns));
                    }

                    genGFree(lpszHlpName, genGSize(lpszHlpName));
                }

                genGFree(lpszDtaName, genGSize(lpszDtaName));
            }
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_WriteInfFiles (Local Routine)
*
* Writes the file-list section.
*
\*****************************************************************************/
BOOL inf_WriteInfFiles(
    HANDLE hFile,
    LPTSTR lpaszFiles)
{
    LPTSTR lpszPtr;
    LPTSTR lpszFile;
    LPSTR  lpszItm;
    DWORD  cbWr;
    CHAR   szBuf[255];
    BOOL   bRet = FALSE;


    // Write out the CopyFiles Section.  This will take the
    // dependent files list and alter it to delminate the
    // strings with commas.
    //
    if ((lpszPtr = lpaszFiles) && *lpszPtr) {

        WriteFile(hFile, g_szInfSctFil, lstrlenA(g_szInfSctFil), &cbWr, NULL);

        while (*lpszPtr) {

            if (lpszFile = genFindRChar(lpszPtr, TEXT('\\'))) {

                if (lpszItm = genMBFromTC(++lpszFile)) {

                    if (SUCCEEDED(StringCchPrintfA(szBuf, COUNTOF(szBuf), "%s\r\n", lpszItm)))
                    {
                        WriteFile(hFile, szBuf, lstrlenA(szBuf), &cbWr, NULL);

                        bRet = TRUE;
                    }

                    genGFree(lpszItm, genGSize(lpszItm));
                }
            }

            lpszPtr = inf_NextStr(lpszPtr);
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_WriteInfSDF (Local Routine)
*
* Writes the file-list section.
*
\*****************************************************************************/
BOOL inf_WriteInfSDF(
    HANDLE  hFile,
    LPCTSTR lpaszFiles)
{
    LPTSTR lpszPtr;
    LPTSTR lpszFile;
    LPSTR  lpszItm;
    DWORD  cbWr;
    CHAR   szBuf[255];
    BOOL   bRet = FALSE;


    // Write out the CopyFiles Section.  This will take the
    // dependent files list and alter it to delminate the
    // strings with commas.
    //
    if ((lpszPtr = (LPTSTR)lpaszFiles) && *lpszPtr) {

        WriteFile(hFile, g_szInfSctSDF, lstrlenA(g_szInfSctSDF), &cbWr, NULL);

        while (*lpszPtr) {

            if (lpszFile = genFindRChar(lpszPtr, TEXT('\\'))) {

                if (lpszItm = genMBFromTC(++lpszFile)) {

                    if (SUCCEEDED(StringCchPrintfA(szBuf, COUNTOF(szBuf), "%hs = 1\r\n", lpszItm)))
                    {
                        WriteFile(hFile, szBuf, lstrlenA(szBuf), &cbWr, NULL);

                        bRet = TRUE;
                    }

                    genGFree(lpszItm, genGSize(lpszItm));
                }
            }

            lpszPtr = inf_NextStr(lpszPtr);
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_BuildW9XInf (Local Routine)
*
*
\*****************************************************************************/
LPTSTR inf_BuildW9XInf(
    LPINFINFO       lpInf,
    LPCTSTR         lpszDrvName,
    LPDRIVER_INFO_3 lpdi3)
{
    LPTSTR lpszInfFile;
    HANDLE hFile;
    LPTSTR lpszInfName = NULL;


    if (lpszInfFile = genBuildFileName(lpInf->lpszDstPath, lpInf->lpszDstName, g_szDotInf)) {

        hFile = CreateFile(lpszInfFile,
                           GENERIC_READ | GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);


        if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

            inf_WriteInfSct(hFile, (LPCSTR)g_szInfSctVer);
            inf_WriteInfMfg(hFile, lpszDrvName);
            inf_WriteInfDrv(hFile, lpszDrvName, (LPCTSTR)lpdi3->pDriverPath);
            inf_WriteInfIns(hFile, (LPCTSTR)lpdi3->pDriverPath);
            inf_WriteInfDta(hFile, lpdi3->pDataFile, lpdi3->pHelpFile);
            inf_WriteInfSct(hFile, (LPSTR)g_szInfSctSDN);
            inf_WriteInfSDF(hFile, (LPCTSTR)lpdi3->pDependentFiles);
            inf_WriteInfFiles(hFile, lpdi3->pDependentFiles);
            inf_WriteInfSct(hFile, g_szInfSctStr);

            lpszInfName = lpszInfFile;

            CloseHandle(hFile);

        } else {
            infSetError(lpInf,GetLastError());
            genGFree(lpszInfFile, genGSize(lpszInfFile));
        }
    }

    return lpszInfName;
}


/*****************************************************************************\
* inf_GetW9XInfo (Local Routine)
*
* Retrieves the files (drivers) for a 9x client.  This essentially takes the
* files and calls a routine to build an INF that the client will use to
* install the drivers.
*
\*****************************************************************************/
LPDRIVER_INFO_3 inf_GetW9XInfo(
    LPINFINFO lpInf,
    LPTSTR*   ppszDrvName)
{
    HANDLE          hPrinter;
    DWORD           cbBuf;
    DWORD           cbNeed;
    LPDRIVER_INFO_1 lpdi1;
    LPDRIVER_INFO_3 lpdi3 = NULL;


    *ppszDrvName = NULL;


    if (OpenPrinter(lpInf->lpszFrnName, &hPrinter, NULL)) {

        // First let's see how big our buffer will need to
        // be in order to hold the printer-driver-name-information.
        //
        cbBuf = 0;
        GetPrinterDriver(hPrinter, (LPTSTR)g_szEnvW9X, 1, NULL, 0, &cbBuf);


        // Allocate storage for holding the driver-info structure.
        //
        if (cbBuf && (lpdi1 = (LPDRIVER_INFO_1)genGAlloc(cbBuf))) {

            if (GetPrinterDriver(hPrinter, (LPTSTR)g_szEnvW9X, 1, (LPBYTE)lpdi1, cbBuf, &cbNeed)) {

                // Get size to hold the printer-driver-files-information.
                //
                cbBuf = 0;
                GetPrinterDriver(hPrinter, (LPTSTR)g_szEnvW9X, 3, NULL, 0, &cbBuf);


                if (cbBuf && (lpdi3 = (LPDRIVER_INFO_3)genGAlloc(cbBuf))) {

                    if (GetPrinterDriver(hPrinter, (LPTSTR)g_szEnvW9X, 3, (LPBYTE)lpdi3, cbBuf, &cbNeed)) {

                        *ppszDrvName = genGAllocStr(lpdi1->pName);

                    } else {

                        genGFree(lpdi3, genGSize(lpdi3));
                        lpdi3 = NULL;
                    }
                }
            }

            genGFree(lpdi1, genGSize(lpdi1));
        }

        ClosePrinter(hPrinter);
    }

    if (lpdi3 == NULL)
       infSetError(lpInf,GetLastError());

    return lpdi3;
}


/*****************************************************************************\
* inf_GetW9XInf (Local Routine)
*
*
\*****************************************************************************/
LPTSTR inf_GetW9XInf(
    LPINFINFO lpInf)
{
    LPDRIVER_INFO_3 lpdi3;
    LPTSTR          lpszDrvName;
    LPTSTR          lpszInfFile = NULL;


    if (lpdi3 = inf_GetW9XInfo(lpInf, &lpszDrvName)) {

        lpszInfFile = inf_BuildW9XInf(lpInf, lpszDrvName, lpdi3);

        genGFree(lpszDrvName, genGSize(lpszDrvName));
        genGFree(lpdi3, genGSize(lpdi3));
    }

    return lpszInfFile;
}


/*****************************************************************************\
* inf_GetIdx (Local Routine)
*
* Quick wrapper which returns the line in the INF file where the section/key
* resides.
*
\*****************************************************************************/
_inline BOOL inf_GetIdx(
    LPCTSTR     lpszSct,
    LPCTSTR     lpszKey,
    HINF        hInfObj,
    PINFCONTEXT pic)
{
    return SetupFindFirstLine(hInfObj, lpszSct, lpszKey, pic);
}


/*****************************************************************************\
* inf_GetInfInfoFileName (Local Routine)
*
* Retreive the filename from the INF-INFO index.
*
\*****************************************************************************/
LPTSTR inf_GetInfInfoFileName(
    PSP_INF_INFORMATION pii,
    DWORD               idx)
{
    DWORD  cbSize, dwBufferSize;
    LPTSTR lpszInfFile;


    if (SetupQueryInfFileInformation(pii, idx, NULL, 0, &cbSize)) {

        dwBufferSize = (cbSize + 1) * sizeof(TCHAR);

        if (lpszInfFile = (LPTSTR)genGAlloc(dwBufferSize)) {

            if (SetupQueryInfFileInformation(pii, idx, lpszInfFile, cbSize, NULL))
                return lpszInfFile;

            genGFree(lpszInfFile, genGSize(lpszInfFile));
        }
    }

    return NULL;
}


/*****************************************************************************\
* inf_GetInfInfo (Local Routine)
*
* Returns a pointer to an INF-INFO struct.
*
\*****************************************************************************/
PSP_INF_INFORMATION inf_GetInfInfo(
    HINF hInfObj)
{
    DWORD               cbSize;
    BOOL                bRet;
    PSP_INF_INFORMATION pii;


    cbSize = 0;
    bRet = SetupGetInfInformation(hInfObj,
                                  INFINFO_INF_SPEC_IS_HINF,
                                  NULL,
                                  0,
                                  &cbSize);

    if (bRet && cbSize && (pii = (PSP_INF_INFORMATION)genGAlloc(cbSize))) {

        bRet = SetupGetInfInformation(hInfObj,
                                      INFINFO_INF_SPEC_IS_HINF,
                                      pii,
                                      cbSize,
                                      NULL);

        if (bRet)
            return pii;

        genGFree(pii, genGSize(pii));
    }

    return NULL;
}


/*****************************************************************************\
* inf_AddItem (Local Routine)
*
* Add an INF file-item to the list.  If adding the new item exceeds the
* available space, then reallocate the memory and return a pointer to the
* new block.
*
\*****************************************************************************/
LPINFITEMINFO inf_AddItem(
    LPINFITEMINFO lpII,
    LPCTSTR       lpszItmName,
    LPCTSTR       lpszItmPath,
    BOOL          bInfFile)
{
    DWORD         idx;
    DWORD         dwOldSize;
    DWORD         dwNewSize;
    LPINFITEMINFO lpNewII;


    idx = lpII->dwCount++;

    if ((lpII->dwCount % INF_ITEM_BLOCK) == 0) {

        dwOldSize = genGSize(lpII);
        dwNewSize = dwOldSize + (sizeof(INFITEM) * INF_ITEM_BLOCK);


        // If we can't realloc the memory, then we are going to free up
        // our existing block and return NULL.  In our implementation, if
        // we can't add items, we need to fail-out.
        //
        lpNewII = (LPINFITEMINFO)genGRealloc(lpII, dwOldSize, dwNewSize);

        if (lpNewII == NULL) {

            genGFree(lpII, genGSize(lpII));

            DBGMSG(DBG_ERROR, ("inf_AddItem : Out of memory"));

            return NULL;
        }

        lpII = lpNewII;
    }


    // Add the item to the list.  The (szOrd) parameter is
    // filled in during the writing of the source-disk-files
    // section.  The Ord indicates which directory the file
    // is located in the LAYOUT.INF.
    //
    lpII->aItems[idx].bInf = bInfFile;
    StringCchCopy(lpII->aItems[idx].szName, COUNTOF(lpII->aItems[idx].szName), lpszItmName);
    StringCchCopy(lpII->aItems[idx].szPath, COUNTOF(lpII->aItems[idx].szPath), lpszItmPath);
    // Set the SOURCE name to NULL by default, if we find a source that has a different name
    // to the target, we'll set it to the original name
    lpII->aItems[idx].szSource[0] = _TEXT('\0');

    return lpII;
}


/*****************************************************************************\
* inf_GetTextLine (Local Routine)
*
* Quick wrapper which returns the text-value of the line specified in the
* inf-object.
*
\*****************************************************************************/
LPTSTR inf_GetTextLine(
    HINF        hInfObj,
    PINFCONTEXT pic)
{
    BOOL   bOK;
    DWORD  cchSize;
    LPTSTR lpszTxt;


    cchSize = 0;
    if (SetupGetLineText(pic, hInfObj, NULL, NULL, NULL, 0, &cchSize)) {

        if (cchSize) {

            if (lpszTxt = (LPTSTR)genGAlloc(cchSize * sizeof(TCHAR))) {

                bOK = SetupGetLineText(pic,
                                       hInfObj,
                                       NULL,
                                       NULL,
                                       lpszTxt,
                                       cchSize,
                                       NULL);

                if (bOK)
                    return lpszTxt;

                genGFree(lpszTxt, cchSize * sizeof(TCHAR));
            }
        }
    }

    return NULL;
}


/*****************************************************************************\
* inf_GetText (Local Routine)
*
* Quick wrapper which returns the text-value of the line specified in the
* inf-object.  This only returns the first string if the line contains
* a field-list.
*
\*****************************************************************************/
LPTSTR inf_GetText(
    HINF        hInfObj,
    PINFCONTEXT pic)
{
    DWORD  cchSize;
    LPTSTR lpszTxt;


    cchSize = 0;
    if (SetupGetStringField(pic, 1, NULL, 0, &cchSize)) {

        if (cchSize) {

            if (lpszTxt = (LPTSTR)genGAlloc(cchSize * sizeof(TCHAR))) {

                if (SetupGetStringField(pic, 1, lpszTxt, cchSize, NULL))
                    return lpszTxt;

                genGFree(lpszTxt, cchSize * sizeof(TCHAR));
            }
        }
    }

    return NULL;
}

/******************************************************************************************
** inf_ScanSection (local routine)
**
** Run through all of the members of a section that match a particular Key (possibly NULL)
** Supply the callback routine we receive with the MultiString that we get from scanning
** the section.
******************************************************************************************/
BOOL inf_ScanSection(HINF        hInf,        // The handle to the inf file we are searching
                     LPCTSTR     lpszSection, // The section name we are scanning from
                     LPCTSTR     lpszKey,     // The key to search the sections for
                     LPVOID      pCookie,     // The data about the inf that we have picked up
                     INFSCANPROC pFn          // The enumeration function
                     ) {
    ASSERT(pFn);

    DWORD       dwFieldSize     = MAX_PATH;
    LPTSTR      pmszFields      = (LPTSTR)genGAlloc(sizeof(TCHAR)*dwFieldSize);
    INFCONTEXT  Context;         // This is the search context we use
    BOOL        bRet            = pmszFields && SetupFindFirstLine(hInf, lpszSection, lpszKey , &Context);
    BOOL        bScan           = bRet;

    while(bScan) {
        DWORD dwRequiredSize;

        // Get the Scan Line from the context
        bScan = SetupGetMultiSzField( &Context, 1, pmszFields, dwFieldSize, &dwRequiredSize);

        if (!bScan && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            LPTSTR pmszTempFields  =  (LPTSTR)genGRealloc( pmszFields,
                                                           sizeof(TCHAR) * dwFieldSize,
                                                           sizeof(TCHAR) * dwRequiredSize );

            if (pmszTempFields) {
                pmszFields = pmszTempFields;
                dwFieldSize = dwRequiredSize;

                bRet = bScan = SetupGetMultiSzField( &Context, 1, pmszFields, dwFieldSize, &dwRequiredSize );
            } else
            bRet = bScan = FALSE;
        }

       // We find all the lpszKey Keys and then Pass the Fields through to the Enum Function

        if (bScan)
            bScan = bRet = (*pFn)( hInf, pmszFields, pCookie);

        if (bScan)
            bScan = SetupFindNextMatchLine( &Context, lpszKey, &Context );
    }

    if (pmszFields)
        genGFree( pmszFields, dwFieldSize * sizeof(TCHAR) );

    return bRet;
}


/******************************************************************************
** Structure - ENUMMFGS
**
** This structure is used to pass info up to the enumerator function
** (inf_EnumMfgSections) and return the install sections
*******************************************************************************/
typedef struct _EnumMfgs {
    LPCTSTR     lpszDrv;            // The driver to find
    LPTSTR      lpszIns;            // The install section in which it is found

    inline _EnumMfgs(LPCTSTR lpszDrv) : lpszDrv(lpszDrv), lpszIns(NULL) {}
} ENUMMFGS;

typedef ENUMMFGS *PENUMMFGS;


/******************************************************************************
** inf_EnumMfgSections
**
** This functions is called for every manufacturer install section in an inf
** file (there may be more than one). For each one it checks to see whether the
** required driver is inside the install section. If it is, it sets the return
** string to the install section for the driver. (Subsequent calls will be ignored).
******************************************************************************/
BOOL inf_EnumMfgSections(HINF hInf, LPCTSTR lpMfgSec, LPVOID pCookie) {
    ASSERT(pCookie);                    // Should not be NULL

    PENUMMFGS pMfgs = (PENUMMFGS)pCookie;

    if (lpMfgSec && pMfgs->lpszIns == NULL) {  // No matching driver has been found yet
        INFCONTEXT  Context;           // This context is used to get the install section

        if ( inf_GetIdx( lpMfgSec, pMfgs->lpszDrv, hInf, &Context) ) {

            pMfgs->lpszIns = inf_GetText( hInf, &Context );

        }
    }

    return TRUE;
}


/*****************************************************************************\
* inf_GetInsVal (Local Routine)
*
* Looks for the line indicated by section/key, and returns the text-string
* for this line.  This also returns an index to the line in the inf-file.
*
\*****************************************************************************/
LPTSTR inf_GetInsVal(
    LPCTSTR     lpszMfg,
    LPCTSTR     lpszDrv,
    HINF        hInfObj)
{
    ENUMMFGS EnumMfgs(lpszDrv);
    LPTSTR   lpszIns = NULL;

    if (inf_ScanSection( hInfObj, g_szMfgName, lpszMfg, (LPVOID)&EnumMfgs, inf_EnumMfgSections) )
        lpszIns = EnumMfgs.lpszIns;

    return lpszIns;
}


/*****************************************************************************\
* inf_RealSect (Local Routine)
*
* Looks for the real-section-mapping.  Some sections could be [.platform]
* specific, so we should be able to take in the section-name and
* create a real key.
*
\*****************************************************************************/
LPTSTR inf_GetRealSect(
    LPINFINFO   lpInf,
    LPCTSTR     lpszKey)
{
    BOOL   bRet;
    DWORD  cchSize;
    LPTSTR lpszSect;


    if (SetupSetPlatformPathOverride(genStrCliOverride(lpInf->idxPlt))) {

        cchSize = 0;
        bRet = SetupDiGetActualSectionToInstall(lpInf->hInfObj,
                                                lpszKey,
                                                NULL,
                                                0,
                                                &cchSize,
                                                NULL);

        if (bRet && cchSize) {

            if (lpszSect = (LPTSTR)genGAlloc(cchSize * sizeof(TCHAR))) {

                bRet = SetupDiGetActualSectionToInstall(lpInf->hInfObj,
                                                        lpszKey,
                                                        lpszSect,
                                                        cchSize,
                                                        NULL,
                                                        NULL);

                if (bRet) {

                    SetupSetPlatformPathOverride(NULL);
                    return lpszSect;
                }

                genGFree(lpszSect, genGSize(lpszSect));
            }
        }

        SetupSetPlatformPathOverride(NULL);
    }

    return NULL;
}


/*****************************************************************************\
* inf_GetInfFile (Local Routine)
*
* Return the name of the inf-file.  This looks for the inf-file with the
* identified (lpszSection)...if NULL is specified, the first (main) inf
* file is returned.
*
\*****************************************************************************/
LPTSTR inf_GetInfFile(
    HINF    hInfObj,
    LPCTSTR lpszSct)
{
    PSP_INF_INFORMATION pii;
    INFCONTEXT          ic;
    LPTSTR              lpszInfFile = NULL;


    if (lpszSct) {

        if (inf_GetIdx(lpszSct, NULL, hInfObj, &ic))
            lpszInfFile = inf_GetInfFile(ic.CurrentInf, NULL);

    } else {

        if (pii = inf_GetInfInfo(hInfObj)) {

            lpszInfFile = inf_GetInfInfoFileName(pii, 0);

            genGFree(pii, genGSize(pii));
        }
    }

    return lpszInfFile;
}


/*****************************************************************************\
* inf_GetLayoutFile (Local Routine)
*
* Return the name of the Layout file.
*
\*****************************************************************************/
LPTSTR inf_GetLayoutFile(
    HINF    hInf )
{
    LPTSTR              lpszLayoutFile = NULL;
    INFCONTEXT INFContext;
    PINFCONTEXT pINFContext = &INFContext;
    DWORD dwBufferNeeded;

    // To get the source directories correct, we need to load all included INFs
    //  separately. THen use their associated layout files.
    if ( SetupFindFirstLine(  hInf, TEXT( "Version" ), TEXT( "LayoutFile" ), &INFContext ) )
    {
       // Find each INF and load it & it's LAYOUT files
       DWORD dwINFs = SetupGetFieldCount( &INFContext );

       if ( SetupGetStringField(  &INFContext, 1, NULL, 0, &dwBufferNeeded ) )
       {
          if (lpszLayoutFile = (LPTSTR)genGAlloc( ( dwBufferNeeded * sizeof(TCHAR) ) )) {
             if ( SetupGetStringField(  &INFContext, 1, lpszLayoutFile, dwBufferNeeded, &dwBufferNeeded ) )
                return lpszLayoutFile;


             genGFree(lpszLayoutFile, genGSize(lpszLayoutFile));
          }  // Allocated pszINFName
       }  // Got the Field from the INF Line
    }  // Found a Layout File

    return NULL;
}


/*****************************************************************************\
* inf_GetSrcInf  (Local Routine)
*
* Get the name of the src inf file given the printer friendly name.  This
* will return a name without the full-path to the inf-directory.
*
\*****************************************************************************/
LPTSTR inf_GetSrcInf(
    LPINFINFO lpInf)
{
    LPTSTR lpszRet = NULL;

    HMODULE       hLib;
    PSETUPCREATE  pSCreate;
    PSETUPDESTROY pSDelete;
    PSETUPGET     pSGet;
    LPWSTR        lpszF;
    HDEVINFO      hDevInfo;
    WCHAR         szTmp[MAX_PATH];
    DWORD         cbSize = MAX_PATH * sizeof(TCHAR);
    BOOL          bGet;


    if (genIsWin9X(lpInf->idxPlt)) {

        lpszRet = inf_GetW9XInf(lpInf);

    } else {

        if (hLib = LoadLibraryFromSystem32(g_szNtPrintDll)) {

            if (pSCreate = (PSETUPCREATE)GetProcAddress(hLib, g_szSetupCreate)) {

                if (pSGet = (PSETUPGET)GetProcAddress(hLib, g_szSetupGet)) {

                    if (pSDelete = (PSETUPDESTROY)GetProcAddress(hLib, g_szSetupDestroy)) {

                        if (hDevInfo = (*pSCreate)(NULL)) {

#ifdef UNICODE
                            bGet = (*pSGet)(hDevInfo, lpInf->lpszFrnName, szTmp, &cbSize);

                            if (bGet)
                                lpszRet = genGAllocStr(szTmp);
                            else
                                infSetError(lpInf,GetLastError());

#else
                            if (lpszF = genWCFromMB(lpInf->lpszFrnName)) {

                                bGet = (*pSGet)(hDevInfo, lpszF, szTmp, &cbSize);

                                if (bGet)
                                    lpszRet = genMBFromWC(szTmp);

                                genGFree(lpszF, genGSize(lpszF));
                            }
#endif

                            (*pSDelete)(hDevInfo);
                        }
                    }
                }
            }

            FreeLibrary(hLib);
        }
    }


    return lpszRet;
}

/*****************************************************************************\
* inf_CopyAndRenameInf (Local Routine)
*
* Opens the inf (the installed, possibly renamed inf), and queries setup for the
* original name.  Copies the inf to our dest directory, renaming it to the
* original name, if we have one.  Also saves the orignal file info so that we
* can rename the .cat file to the original name later.
*
\*****************************************************************************/
LPTSTR inf_CopyAndRenameInf(
    LPINFINFO   lpInf,
    LPTSTR      lpszSrcInf,
    LPTSTR      lpszSrcInfName) {

    HINF hInf;
    PSP_INF_INFORMATION pii;
    LPTSTR lpszDstInf = NULL;
    LPTSTR lpszDstName;
    DWORD  dwErr;

    // If this is a Win9x cab then simply return the passed in name
    if (genIsWin9X(lpInf->idxPlt)) {
        lpszDstInf = genGAllocStr(lpszSrcInf);
    } else {
        // Open the main-inf file.
        //
        hInf = SetupOpenInfFile(lpszSrcInf,
                                g_szPrinterClass,
                                INF_STYLE_WIN4,
                                (PUINT)&dwErr);
        if ( hInf != INVALID_HANDLE_VALUE ) {

            if (pii = inf_GetInfInfo(hInf)) {

                // Set the dst name to default to the src name, just in case we don't
                // succeed in getting original file info from setup.
                // If we don't get original file info, we DON'T bail out, because even though
                // the verification will fail on the client, the user will be prompted as to whether
                // to install the unverified driver files, which is what we want - the user will
                // still be able to print.
                //
                lpszDstName = lpszSrcInfName;

                // Ask setupapi for the original names of the .inf and .cat file
                //
                lpInf->OriginalFileInfo.cbSize = sizeof(SP_ORIGINAL_FILE_INFO);
                lpInf->OriginalFileInfo.OriginalInfName[0] = TEXT('\0');
                lpInf->OriginalFileInfo.OriginalCatalogName[0] = TEXT('\0');
                if (SetupQueryInfOriginalFileInformation(pii, 0, NULL, &(lpInf->OriginalFileInfo))) {
                    lpszDstName = (LPTSTR)&(lpInf->OriginalFileInfo.OriginalInfName);
                }

                // Build full-path to inf-file destination.  This will be our
                // new inf-file in the .\cabinets directory.
                //
                lpszDstInf = genBuildFileName(lpInf->lpszDstPath,
                                              lpszDstName,
                                              NULL);
                if (lpszDstInf) {

                    // Make a copy of our inf to the destination-directory, which will
                    // effectively rename it if we were successful in getting original file info.
                    //
                    if ( !CopyFile(lpszSrcInf, lpszDstInf, FALSE) )
                    {
                       infSetError(lpInf,GetLastError());
                       genGFree(lpszDstInf, genGSize(lpszDstInf));
                       lpszDstInf = NULL;
                    }
                } else {
                    infSetError(lpInf,GetLastError());
                    lpszDstInf = NULL;
                }

                genGFree(pii, genGSize(pii));
            } // if (pii = ...)
            else
                infSetError(lpInf,GetLastError());

            SetupCloseInfFile(hInf);
            hInf = NULL;

        } // if (hInf)
        else
            infSetError(lpInf,GetLastError());
    }

    return lpszDstInf;
}


/*****************************************************************************\
* inf_GetInfObj (Local Routine)
*
* Get the INF file object handle.  This utilizes fields from the lpInf
* structure (lpszDstDir, lpszFriendly).
*
\*****************************************************************************/
HINF inf_GetInfObj(
    LPINFINFO lpInf)
{

    DWORD  dwErr;
    LPTSTR lpszLayName;
    LPTSTR lpszInfName;
    LPTSTR lpszDstInf;
    LPTSTR lpszSrcInf;
    LPTSTR lpszLayFile;
    LPTSTR lpszLaySrc;
    LPTSTR lpszTmp;
    HINF   hInf = INVALID_HANDLE_VALUE;

    // Get main INF file and make a copy to our destination.
    //
    if (lpszTmp = inf_GetSrcInf(lpInf)) {

        // Save our inf-filename.
        //
        if (lpszSrcInf = genGAllocStr(lpszTmp)) {

            // Split up the SrcInf file to path and name.
            //
            lpszInfName    = genFindRChar(lpszTmp, TEXT('\\'));

            if (lpszInfName != NULL) {

                *lpszInfName++ = TEXT('\0');

                if (lpszDstInf = inf_CopyAndRenameInf(lpInf, lpszSrcInf, lpszInfName)) {

                    // Open the main-inf file.
                    //
                    hInf = SetupOpenInfFile(lpszDstInf,
                                            g_szPrinterClass,
                                            INF_STYLE_WIN4,
                                            (PUINT)&dwErr);

                    if ( hInf == INVALID_HANDLE_VALUE )
                        infSetError(lpInf,GetLastError());

                    genGFree(lpszDstInf, genGSize(lpszDstInf));
                } // if (lpszDstInf)

            }  // if (lpszInfName != NULL)
            else
                infSetError(lpInf, ERROR_PATH_NOT_FOUND);

            genGFree(lpszSrcInf, genGSize(lpszSrcInf));
        } // if (lpszSrcInf)
        else
            infSetError(lpInf,GetLastError());

        genGFree(lpszTmp, genGSize(lpszTmp));
    } // if (lpszTmp)

    return hInf;
}


/*****************************************************************************\
* inf_GetInsLine (Local Routine)
*
* Returns the install-line to install.
*
\*****************************************************************************/
LPTSTR inf_GetInsLine(
    LPINFINFO lpInf,
    LPCTSTR   lpszMfgName)
{
    LPTSTR     lpszSct;
    BOOL       bRet;
    DWORD      cchSize;
    LPTSTR     lpszIns = NULL;


    // Retrieve the install-section (raw).
    //
    lpszSct = inf_GetInsVal(lpszMfgName, lpInf->lpszDrvName, lpInf->hInfObj);

    if (lpszSct) {

        // Set the platform override so that we may be specify
        // architecture section to install.
        //
        SetupSetPlatformPathOverride(genStrCliOverride(lpInf->idxPlt));


        // Determine the size necessary to hold the install-section
        // string.
        //
        cchSize = 0;
        SetupDiGetActualSectionToInstall(lpInf->hInfObj,
                                         lpszSct,
                                         NULL,
                                         0,
                                         &cchSize,
                                         NULL);


        // Get the true install section string.
        //
        if (cchSize && (lpszIns = (LPTSTR)genGAlloc(cchSize * sizeof(TCHAR)))) {

            bRet = SetupDiGetActualSectionToInstall(lpInf->hInfObj,
                                                   lpszSct,
                                                   lpszIns,
                                                   cchSize,
                                                   NULL,
                                                   NULL);


            // If we failed, for some reason, then
            // return NULL.
            //
            if (bRet == FALSE) {

                genGFree(lpszIns, genGSize(lpszIns));
                lpszIns = NULL;
            }
        }

        SetupSetPlatformPathOverride(NULL);

        genGFree(lpszSct, genGSize(lpszSct));
    }

    return lpszIns;
}


/*****************************************************************************\
* inf_GetInfName (Local Routine)
*
* Returns the name of an inf-file.
*
\*****************************************************************************/
LPTSTR inf_GetInfName(
    LPINFINFO lpInf)
{
    PSP_INF_INFORMATION pii;
    LPTSTR              lpszFile;
    LPTSTR              lpszPtr;
    LPTSTR              lpszName = NULL;


    if (lpszFile = inf_GetInfFile(lpInf->hInfObj, NULL)) {

        // Seperate the path and file info.
        //
        if (lpszPtr = genFindRChar(lpszFile, TEXT('\\')))
            lpszName = genGAllocStr(lpszPtr + 1);

        genGFree(lpszFile, genGSize(lpszFile));
    }

    return lpszName;
}


/*****************************************************************************\
* inf_IsDrvSupported (Local Routine)
*
* Returns whether the driver-version is supported for the client-version.
*
\*****************************************************************************/
BOOL inf_IsDrvSupported(
    DWORD idxVerCli,
    DWORD idxVerSpl)
{
    BOOL bSupported = FALSE;


    // If the client is less than NT 4.0, then we can't support any
    // drivers that are kernel-mode.
    //
    if ((idxVerCli < IDX_SPLVER_2) && (idxVerSpl >= IDX_SPLVER_2)) {

        bSupported = FALSE;

    } else {

        // Determine if the requesting client can handle the
        // driver-version installed for this printer.  Typically,
        // we can support drivers if they're within one major-version
        // from each other.
        //
        if (abs((int)idxVerCli - (int)idxVerSpl) <= 1)
            bSupported = TRUE;
    }


    return bSupported;
}


/*****************************************************************************\
* inf_GetDrvPath (Local Routine)
*
* Returns a string representing the requested driverpath.
*
\*****************************************************************************/
LPTSTR inf_GetDrvPath(
    LPCTSTR lpszDrvName,
    DWORD   idxPlt,
    DWORD   idxVer)
{
    BOOL    bGet;
    DWORD   cbNeed;
    DWORD   cbSize;
    LPCTSTR lpszEnv;
    LPTSTR  lpszPath = NULL;
    LPDRIVER_INFO_2 lpdi;
    LPDRIVER_INFO_2 lpdiItem;
    DWORD           cRet;
    DWORD           idx;
    BOOL            bMatch = FALSE;
    DWORD           idxSpl;
    LPTSTR          lpszEnd;

    if (lpszEnv = genStrCliEnvironment(idxPlt)) {

        cbSize = 0;
        EnumPrinterDrivers(NULL,
                           (LPTSTR)lpszEnv,
                           2,
                           NULL,
                           0,
                           &cbSize,
                           &cRet);

        if (cbSize && (lpdi = (LPDRIVER_INFO_2)genGAlloc(cbSize))) {

            cRet = 0;
            bGet = EnumPrinterDrivers(NULL,
                                      (LPTSTR)lpszEnv,
                                      2,
                                      (LPBYTE)lpdi,
                                      cbSize,
                                      &cbNeed,
                                      &cRet);

            if (bGet && cRet) {

                // The goal here is to search for the driver-version
                // that matches the printer-name, then look to see if
                // this version will work on the requested client.  Typically,
                // clients can support driver-versions that are (n) to (n-1)
                //
                for (idx = 0; idx < cRet; idx++) {

                    lpdiItem = (lpdi + idx);


                    // Potential match?
                    //
                    if (lstrcmpi(lpdiItem->pName, lpszDrvName) == 0) {

                        if (lpszPath = genGAllocStr(lpdiItem->pDriverPath)) {

                            if (lpszEnd = genFindRChar(lpszPath, TEXT('\\'))) {

                                *lpszEnd = TEXT('\0');
                                bMatch   = FALSE;


                                // Find the version-directory-string.
                                //
                                if (lpszEnd = genFindRChar(lpszPath, TEXT('\\'))) {

                                    // Get the index for the driver-version.
                                    //
                                    if ((idxSpl = genIdxFromStrVersion(lpszEnd)) != IDX_UNKNOWN) {

                                        bMatch = inf_IsDrvSupported(idxVer, idxSpl);
                                    }
                                }
                            }


                            // If we're not a supported driver for the
                            // client, then don't use this path.
                            //
                            if (bMatch == FALSE) {

                                genGFree(lpszPath, genGSize(lpszPath));
                                lpszPath = NULL;

                                continue;
                            }
                        }

                        break;
                    }
                }

                // Chek top see if we found a compatible driver
                if ( (idx == cRet) && (bMatch == FALSE) )
                   // We went though the whole list without finding a match
                   SetLastError(ERROR_DRIVER_NOT_FOUND);
            }

            genGFree(lpdi, cbSize);
        }
        else if ( cbSize == 0 )
            SetLastError(ERROR_DRIVER_NOT_FOUND);
    }

    return lpszPath;
}


/*****************************************************************************\
* inf_GetPrcPath (Local Routine)
*
* Returns a string representing the print-processor path.
*
\*****************************************************************************/
LPTSTR inf_GetPrcPath(
    DWORD idxPlt)
{
    BOOL    bGet;
    DWORD   cbNeed;
    DWORD   cbSize;
    LPCTSTR lpszEnv;
    LPTSTR  lpszPath;


    if (lpszEnv = genStrCliEnvironment(idxPlt)) {

        // Get the required size for storing the full-directory name.
        //
        cbSize = 0;
        GetPrintProcessorDirectory(NULL, (LPTSTR)lpszEnv, 1, NULL, 0, &cbSize);


        // Allocate buffer for holding the string.
        //
        if (cbSize && (lpszPath = (LPTSTR)genGAlloc(cbSize))) {

            bGet = GetPrintProcessorDirectory(NULL,
                                              (LPTSTR)lpszEnv,
                                              1,
                                              (LPBYTE)lpszPath,
                                              cbSize,
                                              &cbNeed);

            if (bGet)
                return lpszPath;

            genGFree(lpszPath, cbSize);
        }
    }

    return NULL;
}


/*****************************************************************************\
* inf_GetIcmPath (Local Routine)
*
* Returns a string representing the ICM color path.
*
\*****************************************************************************/
LPTSTR inf_GetIcmPath(
    DWORD idxPlt)
{
    DWORD  cbSize;
    LPTSTR lpszPath;


    // Get the required size for storing the full-directory name.
    //
    cbSize = 0;
    GetColorDirectory(NULL, NULL, &cbSize);


    // Allocate buffer for holding the string.
    //
    if (cbSize && (lpszPath = (LPTSTR)genGAlloc(cbSize))) {

        if (GetColorDirectory(NULL, lpszPath, &cbSize))
            return lpszPath;

        genGFree(lpszPath, cbSize);
    }

    return NULL;
}


/*****************************************************************************\
* inf_GetSysPath (Local Routine)
*
* Returns a string representing the system directory.
*
\*****************************************************************************/
LPTSTR inf_GetSysPath(
    DWORD idxPlt)
{
    DWORD  cbSize;
    LPTSTR lpszPath;


    cbSize = (MAX_PATH * sizeof(TCHAR));


    // Allocate buffer for holding the string.
    //
    if (lpszPath = (LPTSTR)genGAlloc(cbSize)) {

        if (GetSystemDirectory(lpszPath, MAX_PATH))
            return lpszPath;

        genGFree(lpszPath, cbSize);
    }

    return NULL;
}


/*****************************************************************************\
* inf_AllocStrings (Local Routine)
*
* Initializes the fields relating to the string-fields.
*
\*****************************************************************************/
BOOL inf_AllocStrings(
    LPINFINFO    lpInf,
    LPINFGENPARM lpParm)
{

    // Initialize the driver-name field.
    //
    if (lpInf->lpszDrvPath = inf_GetDrvPath(lpParm->lpszDrvName, lpInf->idxPlt, lpInf->idxVer)) {

        if (lpInf->lpszDrvName = genGAllocStr(lpParm->lpszDrvName)) {

            if (lpInf->lpszDstName = genGAllocStr(lpParm->lpszDstName)) {

                if (lpInf->lpszDstPath = genGAllocStr(lpParm->lpszDstPath)) {

                    if (lpInf->lpszPrtName = genGAllocStr(lpParm->lpszPortName)) {

                        if (lpInf->lpszShrName = genGAllocStr(lpParm->lpszShareName)) {

                            if (lpInf->lpszFrnName = genGAllocStr(lpParm->lpszFriendlyName))
                                return TRUE;

                            genGFree(lpInf->lpszShrName, genGSize(lpInf->lpszShrName));
                        }

                        genGFree(lpInf->lpszPrtName, genGSize(lpInf->lpszPrtName));
                    }

                    genGFree(lpInf->lpszDstPath, genGSize(lpInf->lpszDstPath));
                }

                genGFree(lpInf->lpszDstName, genGSize(lpInf->lpszDstName));
            }

            genGFree(lpInf->lpszDrvName, genGSize(lpInf->lpszDrvName));
        }

        genGFree(lpInf->lpszDrvPath, genGSize(lpInf->lpszDrvPath));
    }

    return FALSE;
}


/*****************************************************************************\
* inf_AddInfFile (Local Routine)
*
* Adds the inf-file to the list.  If this fails, then the (lpII) object
* is deleted.  This keeps this consistent with the inf_AddItem() routine.
*
\*****************************************************************************/
LPINFITEMINFO inf_AddInfFile(
    LPINFINFO     lpInf,
    LPINFITEMINFO lpII)
{
    LPTSTR        lpszInfFile;
    LPTSTR        lpszFile;
    LPINFITEMINFO lpIIRet = NULL;


    if (lpszInfFile = inf_GetInfFile(lpInf->hInfObj, NULL)) {

        // Seperate the path and file info, and add to the list.
        //
        if (lpszFile = genFindRChar(lpszInfFile, TEXT('\\'))) {

            *lpszFile = TEXT('\0');
            lpIIRet = inf_AddItem(lpII, ++lpszFile, lpszInfFile, TRUE);

        }

        genGFree(lpszInfFile, genGSize(lpszInfFile));
    }

    return lpIIRet;
}




/*****************************************************************************\
* inf_AddCATToCountArray (Local Routine)
*
* Takes a CAT filename, and adds it to our count array (if a new one), or increments
* the count if it already is in our array.
*
\*****************************************************************************/
BOOL inf_AddCATToCountArray(LPWSTR          lpszCATName,
                            LPCATCOUNTARRAY lpCatCountArray) {

    BOOL bReturn = TRUE;
    BOOL bFound = FALSE;
    UINT i;

    // Alloc or realloc for more memory if needed.  We alloc INF_CAT_INCREMENT items at a time, as needed.
    //
    // When we start there is no Next Available item defined
    if (!lpCatCountArray->uNextAvailable) {
        if (lpCatCountArray->lpArray = (LPCATCOUNT)genGAlloc(sizeof(CATCOUNT) * INF_CAT_INCREMENT) ) {
            lpCatCountArray->uNextAvailable = INF_CAT_INCREMENT;
            lpCatCountArray->uItems         = 0;
        }
        else goto CATCOUNTFAIL;
    }

    // See if we have already encountered this CAT file name.  If so, increment the count
    // for this CAT.  If not, add this CAT to our array.
    //
    for (i=0; i < lpCatCountArray->uItems; i++) {
        if (!lstrcmp(lpszCATName, lpCatCountArray->lpArray[i].lpszCATName)) {
            lpCatCountArray->lpArray[i].uCount++;
            bFound = TRUE;
            break;
        }
    }

    if (!bFound) {
        // We might need to reallocate the array, we need to do this if the new position
        // becomes equal to the next available item
        UINT uItem = lpCatCountArray->uItems;

        if (uItem >= lpCatCountArray->uNextAvailable) {
            LPCATCOUNT  lpNewArray = (LPCATCOUNT)genGRealloc((LPVOID)lpCatCountArray->lpArray,
                                                                    sizeof(CATCOUNT) * lpCatCountArray->uNextAvailable,
                                                                    sizeof(CATCOUNT) * (uItem + INF_CAT_INCREMENT) );
            if (lpNewArray) {
                lpCatCountArray->lpArray = lpNewArray;
                lpCatCountArray->uNextAvailable = uItem + INF_CAT_INCREMENT;
            }
            else goto CATCOUNTFAIL;
        }

        lpCatCountArray->lpArray[uItem].uCount = 1;
        lpCatCountArray->lpArray[uItem].lpszCATName = genGAllocWStr(lpszCATName);

        if (lpCatCountArray->lpArray[uItem].lpszCATName)
            lpCatCountArray->uItems = uItem + 1;
        else goto CATCOUNTFAIL;

    }

    return TRUE;

CATCOUNTFAIL:

    return FALSE;

}


/******************************************************************************
* inf_IsIndividuallySigned (Local Routine)
*
* Returns TRUE if a driver file is individually signed
*
*******************************************************************************/
BOOL inf_IsIndividuallySigned(
    LPCTSTR lpszDriverFileName) {

    GUID                gSubject;
    SIP_DISPATCH_INFO   SipDispatch;
    SIP_SUBJECTINFO     SubjectInfo;
    DWORD               cbData          = 0;
    BOOL                bRet            = FALSE;
    DWORD               dwEncodingType  = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

    ASSERT(lpszDriverFileName);

    if (!CryptSIPRetrieveSubjectGuid(  // This GUID is used for passing to CryptSIPLoad
            lpszDriverFileName,        // which verifies the sig on the file
            NULL,
            &gSubject)) goto Failure;

    ZeroMemory( &SipDispatch, sizeof(SipDispatch) );
    SipDispatch.cbSize = sizeof(SipDispatch);

    if (!CryptSIPLoad(
            &gSubject,
            0,
            &SipDispatch)) goto Failure;

    // Now that we have the SIP Dispatch, fill out the subject info

    ZeroMemory( &SubjectInfo,  sizeof(SubjectInfo) );
    SubjectInfo.cbSize         = sizeof(SubjectInfo);
    SubjectInfo.pgSubjectType  = (GUID *)&gSubject;
    SubjectInfo.hFile          = INVALID_HANDLE_VALUE;
    SubjectInfo.pwsFileName    = lpszDriverFileName;
    SubjectInfo.dwEncodingType = dwEncodingType;

    if (!SipDispatch.pfGet(
            &SubjectInfo,
            &dwEncodingType,
            0,
            &cbData,
            NULL)) goto Failure;

    if (cbData != 0) bRet = TRUE;

Failure:

    return bRet;

}


/*****************************************************************************\
* inf_CATCountProc (Local Routine)
*
* Callback used to count up all references to CAT files by the driver files.
*
\*****************************************************************************/
BOOL CALLBACK inf_CATCountProc(LPCTSTR lpszName,
                               LPCTSTR lpszPath,
                               BOOL bInf,
                               LPVOID  lpData) {


    BOOL bReturn = TRUE;
    LPCATCOUNTARRAY lpCatCountArray = (LPCATCOUNTARRAY)(lpData);
    HCATADMIN       hCatAdmin = lpCatCountArray->hCatAdmin;
    LPTSTR          lpszDriverFileName;

    HCATINFO        hCatInfo = NULL;
    HCATINFO        hCatInfoPrev = NULL;
    CATALOG_INFO    CatalogInfo;
    BYTE *          pbHash;
    DWORD           dwBytes;
    WIN32_FIND_DATA ffd;
    PFILEITEM       pFileItem;
    HANDLE          hFind, hFile;
    LPTSTR          pFullPath, pPath, pName;

    // Find the catalog file associated with this file.
    // If we can't find one, that's OK, it's not an error, just a file
    // with no associated .cat file.  The user can decide on the client-end
    // whether or not he wants to install without the verification a .cat file
    // would provide...
    //

    if (INVALID_HANDLE_VALUE != (HANDLE)hCatAdmin) {

        if (lpszDriverFileName = genBuildFileName(lpszPath, lpszName, NULL)) {

            hFind = FindFirstFile(lpszDriverFileName, &ffd);

            if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

                FindClose(hFind);

                // The first thing we need to determine is whether the file is individually
                // signed, if it is we don't look for a cat and up the individually signed
                // count

                if ( inf_IsIndividuallySigned(lpszDriverFileName) ) {
                        lpCatCountArray->dwIndivSigned++;
                    }  else {

                    // Open the file in order to hash it.
                    //
                    if (INVALID_HANDLE_VALUE != (hFile = CreateFile(lpszDriverFileName,
                                                                    GENERIC_READ,
                                                                    FILE_SHARE_READ,
                                                                    NULL,
                                                                    OPEN_EXISTING,
                                                                    FILE_ATTRIBUTE_NORMAL,
                                                                    NULL))) {

                        // Determine how many bytes we need for the hash
                        //
                        dwBytes = 0;
                        pbHash = NULL;
                        CryptCATAdminCalcHashFromFileHandle(hFile, &dwBytes, pbHash, 0);

                        if (NULL != (pbHash = (BYTE *)genGAlloc(dwBytes))) {

                            // Compute the hash for this file
                            //
                            if (CryptCATAdminCalcHashFromFileHandle(hFile, &dwBytes, pbHash, 0)) {

                                // Get the catalog file(s) associated with this file hash
                                //
                                hCatInfo = NULL;

                                do {

                                    hCatInfoPrev = hCatInfo;
                                    hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, dwBytes, 0, &hCatInfoPrev);

                                    if (NULL != hCatInfo) {

                                        CatalogInfo.cbStruct = sizeof(CATALOG_INFO);

                                        if (CryptCATCatalogInfoFromContext(hCatInfo, &CatalogInfo, 0)) {

                                           if (!inf_AddCATToCountArray(CatalogInfo.wszCatalogFile, lpCatCountArray)) {

                                              bReturn = FALSE;
                                              hCatInfo = NULL;  // fail out of loop
                                           }
                                        }
                                    }

                                } while (NULL != hCatInfo);

                            } // if (CryptCATAdminCalcHashFromFileHandle(hFile, &dwBytes, pbHash, 0)) {

                            genGFree(pbHash, dwBytes);

                        } // if (NULL != (pbHash = (BYTE *)genGAlloc(dwBytes))) {

                        CloseHandle(hFile);

                    }  // if (INVALID_HANDLE_VALUE != (hFile = CreateFile(lpszDriverFileName,

                } // if ( inf_IsIndividuallySigned(hFile, lpszDriverFileName) )

            } // if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

            genGFree(lpszDriverFileName, genGSize(lpszDriverFileName));

        } // if (lpszDriverFileName = genBuildFileName(lpszPath, lpszName, NULL)) {

    }   // if (INVALID_HANDLE_VALUE != (HANDLE)hCatAdmin) {

    return bReturn;
}



/*****************************************************************************\
* inf_AddCATFile (Local Routine)
*
* Adds the cat-file to the list (if any).
*
\*****************************************************************************/
BOOL inf_AddCATFile(
    LPINFINFO     lpInf) {

    LPTSTR        lpszInfFile;
    LPTSTR        lpszFile;
    LPTSTR        lpszDstCAT;
    LPTSTR        lpszDstName;
    LPTSTR        lpszInstalledCATFileName;
    LPINFITEMINFO lpIIRet;

    // We initialize return to TRUE because we want to NOT fail out of the cab generation process
    // at this point, even if we fail to find a CAT file.  This will at least still return the driver cab
    // package to the client and let the user accept or decline the package when it fails to
    // verify.
    //
    BOOL bReturn = TRUE;
    CATCOUNTARRAY CatCountArray;

    CatCountArray.dwIndivSigned = 0;  // The number of individually signed files
    CatCountArray.uItems = 0;
    CatCountArray.uNextAvailable = 0;
    CatCountArray.lpArray = NULL;

    // Initialize the catalog admin context handle
    //
    if (FALSE == CryptCATAdminAcquireContext(&(CatCountArray.hCatAdmin), NULL, 0)) {
        CatCountArray.hCatAdmin = (HCATADMIN)INVALID_HANDLE_VALUE;
        infSetError(lpInf,GetLastError());
        return FALSE;
    }

    // Enumerate all the items in the inf.  The enumeration callback (inf_CATCountProc)
    // will count the number of references for each unique CAT file that is referenced by
    // one of our driver files.  We will add to the CAB file, the CAT file that is referenced
    // the most times by the driver files - this CAT file SHOULD be referenced by ALL of the
    // driver files, or there is no point in adding the CAT to the CAB, since the driver verification
    // will fail on the client if not all files are verified by the CAT.
    //
    if (infEnumItems((HANDLE)lpInf, inf_CATCountProc, (LPVOID)&CatCountArray )) {

        if (CatCountArray.uItems > 0) {

            UINT uIndex;

            // Search our CAT file array to find the CAT file that was referenced more than the others.
            // This is the CAT file we want to package into the CAB.
            //
            UINT uIndexOfMostCommonCAT = 0;
            for (uIndex=0; uIndex < CatCountArray.uItems; uIndex++) {
                if (CatCountArray.lpArray[uIndexOfMostCommonCAT].uCount < CatCountArray.lpArray[uIndex].uCount)
                    uIndexOfMostCommonCAT = uIndex;
            }

            // Make sure that every file referenced this CAT file - if they all didn't,
            // then it will fail verification on client - so no sense in sending the CAT
            // to the CAB package
            //
            if (CatCountArray.lpArray[uIndexOfMostCommonCAT].uCount + CatCountArray.dwIndivSigned
                    >= (lpInf->lpInfItems->dwCount)) {

                lpszInstalledCATFileName = CatCountArray.lpArray[uIndexOfMostCommonCAT].lpszCATName;

                // If we have an original .cat file name, use it for the dest name,
                // otherwise, just use the current (installed) name
                //
                if (lpInf->OriginalFileInfo.OriginalCatalogName[0] != TEXT('\0')) {
                    lpszDstName = (LPTSTR)&(lpInf->OriginalFileInfo.OriginalCatalogName);
                }
                else {
                    // Find the filename portion of the current (installed) .cat file name.
                    lpszDstName = genFindRChar(lpszInstalledCATFileName, TEXT('\\'));
                    lpszDstName++;
                }

                if (lpszDstCAT = genBuildFileName(lpInf->lpszDstPath,
                                                  lpszDstName,
                                                  NULL)) {

                    // Copy the CAT file into our directory, renaming it to the original name.
                    //
                    if ( CopyFile(lpszInstalledCATFileName, lpszDstCAT, FALSE) )
                    {
                       // Add this (renamed) file to our file list to be added to the cab.
                       //
                       lpIIRet = inf_AddItem(lpInf->lpInfItems, lpszDstName, lpInf->lpszDstPath, TRUE);
                       if (lpIIRet == NULL) {
                           infSetError(lpInf,GetLastError());
                           bReturn = FALSE;
                       }

                       lpInf->lpInfItems = lpIIRet;
                    }
                    else
                    {
                       infSetError(lpInf,GetLastError());
                       genGFree(lpInf->lpInfItems, genGSize(lpInf->lpInfItems));
                       lpInf->lpInfItems = NULL;
                       bReturn = FALSE;
                    }
                    genGFree(lpszDstCAT, genGSize(lpszDstCAT));
                }
            }
        }
        else {
            DBGMSG(DBG_INFO, ("geninf: No CAT Files found for driver package.\n"));
        }
    }

    // Free all our CAT array items here
    //

    if (CatCountArray.lpArray) {

        UINT uItem = 0;
        for (uItem = 0; uItem < CatCountArray.uItems; uItem++) {
            genGFree(CatCountArray.lpArray[uItem].lpszCATName, genGSize(CatCountArray.lpArray[uItem].lpszCATName));
        }

        genGFree(CatCountArray.lpArray, genGSize(CatCountArray.lpArray));
    }

    // Release the Catalog Admin context handle, if we have one
    //
    if (INVALID_HANDLE_VALUE != (HANDLE)(CatCountArray.hCatAdmin)) {
        CryptCATAdminReleaseContext(CatCountArray.hCatAdmin, 0);
    }

    return bReturn;
}


/*****************************************************************************\
* inf_SetDefDirIds (Local Routine)
*
* Sets the Default DRID values for the setup-process.
*
\*****************************************************************************/
BOOL inf_SetDefDirIds(
    LPINFINFO lpInf)
{
    LPTSTR lpszDrv;
    LPTSTR lpszPrc;
    LPTSTR lpszSys;
    LPTSTR lpszIcm;
    BOOL   bRet = FALSE;


    if (lpszDrv = lpInf->lpszDrvPath) {

        if (lpszPrc = inf_GetPrcPath(lpInf->idxPlt)) {

            if (lpszSys = inf_GetSysPath(lpInf->idxPlt)) {

                if (lpszIcm = inf_GetIcmPath(lpInf->idxPlt)) {

                    if (SetupSetDirectoryId(lpInf->hInfObj, INF_DRV_DRID, lpszDrv) &&
                        SetupSetDirectoryId(lpInf->hInfObj, INF_PRC_DRID, lpszPrc) &&
                        SetupSetDirectoryId(lpInf->hInfObj, INF_SYS_DRID, lpszSys) &&
                        SetupSetDirectoryId(lpInf->hInfObj, INF_ICM_DRID, lpszIcm)) {

                        bRet = TRUE;
                    }

                    genGFree(lpszIcm, genGSize(lpszIcm));
                }

                genGFree(lpszSys, genGSize(lpszSys));
            }

            genGFree(lpszPrc, genGSize(lpszPrc));
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_SetDirIds (Local Routine)
*
* Sets the DRID values for the setup-process.
*
\*****************************************************************************/
BOOL inf_SetDirIds(
    LPINFINFO lpInf)
{
    INFCONTEXT ic;
    DWORD      idx;
    DWORD      dwCount;
    WORD       wEnvCli;
    WORD       wEnvSrv;
    DWORD      dwDRID;
    LPTSTR     lpszDir;
    BOOL       bRet = FALSE;



    // Initialize the default directories for DRID values.
    //
    inf_SetDefDirIds(lpInf);


    // Look through the INF-File for any overriding DRID values and
    // set these.
    //
    if ((dwCount = SetupGetLineCount(lpInf->hInfObj, g_szDestDirs)) != (DWORD)-1) {

        for (idx = 0, bRet = TRUE; (idx < dwCount) && bRet; idx++) {

            if (bRet = SetupGetLineByIndex(lpInf->hInfObj, g_szDestDirs, idx, &ic)) {

                if (bRet = SetupGetIntField(&ic, 1, (PINT)&dwDRID)) {

                    if (dwDRID < DIRID_USER)
                        continue;

                    switch (dwDRID) {

                    case INF_DRV_DRID:
                        bRet = SetupSetDirectoryId(lpInf->hInfObj, dwDRID, lpInf->lpszDrvPath);
                        continue;

                    case INF_PRC_DRID:
                        wEnvCli = genValCliArchitecture(lpInf->idxPlt);
                        wEnvSrv = genValSvrArchitecture();

                        if (wEnvCli == wEnvSrv) {

                            lpszDir = inf_GetPrcPath(lpInf->idxPlt);

                        } else {

                            lpszDir = genGAllocStr(g_szSkipDir);
                        }
                        break;

                    case INF_SYS_DRID:
                        wEnvCli = genValCliArchitecture(lpInf->idxPlt);
                        wEnvSrv = genValSvrArchitecture();

                        if (wEnvCli == wEnvSrv) {

                            lpszDir = inf_GetSysPath(lpInf->idxPlt);

                        } else {

                            lpszDir = genGAllocStr(g_szSkipDir);
                        }
                        break;

                    case INF_ICM_DRID:
                        lpszDir = inf_GetIcmPath(lpInf->idxPlt);
                        break;

                    default:
                        lpszDir = genGAllocStr(g_szSkipDir);
                    }


                    if (lpszDir) {

                        bRet = SetupSetDirectoryId(lpInf->hInfObj, dwDRID, lpszDir);

                        genGFree(lpszDir, genGSize(lpszDir));

                    } else {

                        bRet = FALSE;
                    }
                }
            }
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_ScanFiles (Local Routine)
*
* Callback routine which returns the items in a copyfiles list.
*
\*****************************************************************************/
UINT CALLBACK inf_ScanFiles(
    LPVOID lpCtxt,
    UINT   uNotify,
    UINT_PTR   Parm1,
    UINT_PTR   Parm2)
{
    LPINFSCAN lpScan;
    LPTSTR    lpszPath;
    LPTSTR    lpszFile;


    if ((lpScan = (LPINFSCAN)lpCtxt) && (lpszPath = (LPTSTR)Parm1)) {

        if (lpszFile = genFindRChar(lpszPath, TEXT('\\'))) {

            *lpszFile = TEXT('\0');


            // If this is a skip-dir item then do not add to our
            // list.  This can happen for files that are not stored
            // in platform-specific directories.  For example, files
            // stored in the SYSTEM32 directory have no architecture
            // counter-part.  We do not want to download the incorrect
            // file for a different architecture.
            //
            if (lstrcmpi(lpszPath, g_szSkipDir) != 0) {

                lpScan->lpII = inf_AddItem(lpScan->lpII, lpszFile + 1, lpszPath, FALSE);

            }

            *lpszFile = TEXT('\\');

            return (lpScan->lpII ? 0 : 1);
        }
    }

    return 1;
}


/*****************************************************************************\
* inf_BuildW9XList (Local Routine)
*
* This enumerates the W9X dependent files and adds them to our list.
*
\*****************************************************************************/
LPINFITEMINFO inf_BuildW9XList(
    LPINFINFO lpInf,
    LPINFSCAN lpis)
{
    LPDRIVER_INFO_3 lpdi3;
    LPTSTR          lpszDrvName;
    LPTSTR          lpszItm;
    BOOL            bRet = FALSE;


    if (lpdi3 = inf_GetW9XInfo(lpInf, &lpszDrvName)) {

        if (lpszItm = lpdi3->pDependentFiles) {

            bRet = TRUE;

            while (*lpszItm) {

                if (inf_ScanFiles(lpis, 0, (UINT_PTR)lpszItm, 0) != 0)
                    break;

                lpszItm = inf_NextStr(lpszItm);
            }
        }

        genGFree(lpszDrvName, genGSize(lpszDrvName));
        genGFree(lpdi3, genGSize(lpdi3));
    }


    if (bRet == FALSE) {
        genGFree(lpis->lpII, genGSize(lpis->lpII));
        lpis->lpII = NULL;
    }

    return lpis->lpII;
}



/*******************************************************************************************
** inf_ScanSourceTarget  (local routine)
**
** Get the source and target, and then run through all the inf files if there is a source
** and find the target file that matches and add the source to the database
**
*******************************************************************************************/
BOOL CALLBACK inf_ScanSourceTarget(HINF      hInf,
                                   LPCTSTR   pmszFields,
                                   LPVOID    pCookie) {
    ASSERT(pmszFields);   // Should never be NULL, we allocate it
    ASSERT(pCookie);      // Should never be NULL, we pass it in after check

    LPINFSCAN       lpis      = (LPINFSCAN)pCookie;
    LPINFITEMINFO   lpII      = lpis->lpII;
    LPCTSTR         szTarget  = pmszFields;
    BOOL            bRet      = lpII != NULL;

    if (*szTarget && bRet) {   // There is a target file (non NULL)
        LPCTSTR szSource = &pmszFields[ lstrlen(szTarget) + 1 ];

        if (*szSource) {
            DWORD         dwIdx;
            DWORD         dwCount;

            // We don't need to do anything if source and target name are the same, even
            // if they are expressly listed in the inf file

            if ( lstrcmpi ( szTarget, szSource) ) {
                dwCount = lpII->dwCount;

                for(dwIdx = 0; dwIdx < dwCount; ++dwIdx) {
                    if (!lstrcmpi( lpII->aItems[dwIdx].szName, szTarget))
                        // Targets match, write the source file name into the structure
                        StringCchCopy( lpII->aItems[dwIdx].szSource, COUNTOF(lpII->aItems[dwIdx].szSource), szSource);
                }
            }
        }
    }

    return bRet;
}

/******************************************************************************************
** inf_ScanCopyFields (local routine)
**
** Run through the Copy Fields supplied by inf_ScanSection and Scan through those sections
** for Source and Destination Pairs
**
******************************************************************************************/
BOOL CALLBACK inf_ScanCopyFields(HINF hInf, LPCTSTR pmszFields, LPVOID pCookie) {
    ASSERT(pmszFields);

    BOOL bRet = TRUE;

    while(*pmszFields && bRet) {
        if (*pmszFields != TEXT('@'))   // Check for an individual file install
            bRet = inf_ScanSection( hInf, pmszFields, NULL, pCookie, inf_ScanSourceTarget);

        pmszFields += lstrlen(pmszFields) + 1;
    }

    return bRet;
}




/*****************************************************************************\
* inf_BuildWNTList (Local Routine)
*
* This builds our list from the NT scan-file-queue of an inf-parser.
*
\*****************************************************************************/
LPINFITEMINFO inf_BuildWNTList(
    LPINFINFO lpInf,
    LPCTSTR   lpszMfgName,
    LPINFSCAN lpis)
{
    LPTSTR   lpszIns;
    HSPFILEQ hFQ;
    DWORD    dwRet;
    BOOL     bRet = FALSE;


    if (lpszIns = inf_GetInsLine(lpInf, lpszMfgName)) {

        SetupSetPlatformPathOverride(genStrCliOverride(lpInf->idxPlt));

        hFQ = SetupOpenFileQueue();
        if (hFQ != INVALID_HANDLE_VALUE) {

            inf_SetDirIds(lpInf);

            bRet = SetupInstallFilesFromInfSection(lpInf->hInfObj,
                                                   NULL,
                                                   hFQ,
                                                   lpszIns,
                                                   NULL,
                                                   0);

            if (bRet) {
                // Setup the user-defined data passed to the
                // enum-callback.
                //
                dwRet = 0;
                bRet = SetupScanFileQueue(hFQ,
                                          SPQ_SCAN_USE_CALLBACK,
                                          0,
                                          inf_ScanFiles,
                                          (LPVOID)lpis,
                                          &dwRet);
            }

            SetupCloseFileQueue(hFQ);

            // Now that we have all of the files, we run through the inf file to see what the
            // original file names where. If they are different, we insert them into
            // the inf file

            if (bRet)
                bRet = inf_ScanSection(lpInf->hInfObj,
                                      lpszIns,
                                      g_szCopyFiles,
                                      (PVOID)lpis,
                                      inf_ScanCopyFields
                                      );
        }

        SetupSetPlatformPathOverride(NULL);

        genGFree(lpszIns, genGSize(lpszIns));
    }

    if (bRet == FALSE) {
        genGFree(lpis->lpII, genGSize(lpis->lpII));
        lpis->lpII = NULL;
    }


    return lpis->lpII;
}


/*****************************************************************************\
* inf_GetItemList (Local Routine)
*
* Get the items from the INF file and build our array of files from this
* search.  This does quite a bit of work.
*
\*****************************************************************************/
LPINFITEMINFO inf_GetItemList(
    LPINFINFO lpInf,
    LPCTSTR   lpszMfgName)
{
    INFSCAN is;
    DWORD   cbSize;
    BOOL    bRet;


    // Initialize a default-block to contain our inf-items.
    //
    cbSize = sizeof(INFITEMINFO) + (sizeof(INFITEM) * INF_ITEM_BLOCK);


    // Setup a structure which will be utilized by either the
    // setup-scan-file-queue, or our own routine to process W9X
    // items.
    //
    if (is.lpII = (LPINFITEMINFO)genGAlloc(cbSize)) {

        is.lpInf = lpInf;

        // Add the inf-files to the list.
        //
        if (is.lpII = inf_AddInfFile(lpInf, is.lpII)) {

            if (genIsWin9X(lpInf->idxPlt)) {

                is.lpII = inf_BuildW9XList(lpInf, &is);

            } else {

                is.lpII = inf_BuildWNTList(lpInf, lpszMfgName, &is);
            }
        }
    }

    return is.lpII;
}

/*****************************************************************************\
* inf_GetSection (Local Routine)
*
* Allocate a buffer which stores either all section-names or the list of
* items specified by (lpszSection) in an INF file.  Currently, we attempt
* a realloc if the buffer is not big enough.
*
\*****************************************************************************/
LPTSTR inf_GetSection(
    LPINFINFO lpInf,
    LPCTSTR   lpszSct)
{
    LPTSTR lpszInfFile;
    DWORD  dwCnt;
    DWORD  cch;
    DWORD  dwSize;
    DWORD  dwLimit;
    LPTSTR lpszNames = NULL;


    // Get the inf-file-name whith contains the specified section.
    //
    if (lpszInfFile = inf_GetInfFile(lpInf->hInfObj, lpszSct)) {

        dwSize  = 0;
        dwLimit = 0;

        while (dwLimit < INF_SECTION_LIMIT) {

            // We'll start this allocation with an assumed max-size.  Upon
            // successive tries, this buffer is increased each time by the
            // original buffer allocation.
            //
            dwSize += (INF_SECTION_BLOCK * sizeof(TCHAR));
            dwLimit++;


            // Alloc the buffer and attempt to get the names.
            //
            if (lpszNames = (LPTSTR)genGAlloc(dwSize)) {

                // If a section-name is profided, use that.  Otherwise,
                // enumerate all section-names.
                //
                cch = dwSize / sizeof(TCHAR);

                if (lpszSct) {

                    dwCnt = GetPrivateProfileSection(lpszSct,
                                                     lpszNames,
                                                     cch,
                                                     lpszInfFile);

                } else {

                    dwCnt = GetPrivateProfileSectionNames(lpszNames,
                                                          cch,
                                                          lpszInfFile);
                }


                // If the call says the buffer was OK, then we can
                // assume the names are retrieved.  According to spec's,
                // if the return-count is equal to size-2, then buffer
                // isn't quite big-enough (two NULL chars).
                //
                if (dwCnt < (cch - 2))
                    goto GetSectDone;


                genGFree(lpszNames, dwSize);
                lpszNames = NULL;
            }
        }

GetSectDone:

        SPLASSERT((dwLimit < INF_SECTION_LIMIT));

        genGFree(lpszInfFile, genGSize(lpszInfFile));
    }

    return lpszNames;
}


/*****************************************************************************\
* inf_GetMfgName (Local Routine)
*
* Get the manufacture-name from the driver-name.  Some drivers do not really
* begin with the manufacture-name.  These will have to be special-cased
* to determine their cooresponding manufacturer-name.
*
\*****************************************************************************/
LPTSTR inf_GetMfgNameExe(
    LPINFINFO lpInf)
{
    INFCONTEXT ic;
    BOOL       bFind;
    LPTSTR     lpszNames;
    LPTSTR     lpszDrvCpy;
    LPTSTR     lpszPtr;
    LPTSTR     lpszMfgName = NULL;


    // Make a copy for us to muck with.
    //
    if (lpszDrvCpy = genGAllocStr(lpInf->lpszDrvName)) {

        // Let's assume the best-case and the model-name's first word
        // is the Manufacturer.  All we need in this case is to find
        // the first <space> in the driver-name.
        //
        // Find the first word to use in locating the manufacturer.
        //
        if (lpszPtr = genFindChar(lpszDrvCpy, TEXT(' ')))
            *lpszPtr = TEXT('\0');



        // Take the first-word and try to get a manufacture out
        // of it.
        //
        if (lpszMfgName = genGAllocStr(lpszDrvCpy)) {

            // Look for the module-name in the manufacturers section.  This
            // will return us an index into the inf-file.
            //
            bFind = inf_GetIdx(lpszMfgName,
                               lpInf->lpszDrvName,
                               lpInf->hInfObj,
                               &ic);


            // If the model-manufacturer lookup failed, then we
            // need to look at other model-manufacturer mappings.
            //
            if (bFind == FALSE) {

                // Free the existing string used for this test.  Since,
                // we could conceptually come up with another manufacturer
                // name for this model.
                //
                genGFree(lpszMfgName, genGSize(lpszMfgName));
                lpszMfgName = NULL;


                // Since we were not able to find the model-name through
                // conventional means, we are going to look through every
                // section-name in the Inf for the model-name.
                //
                if (lpszNames = inf_GetSection(lpInf, NULL)) {

                    lpszPtr = lpszNames;

                    while (*lpszPtr != TEXT('\0')) {

                        bFind = inf_GetIdx(lpszPtr,
                                           lpInf->lpszDrvName,
                                           lpInf->hInfObj,
                                           &ic);

                        // See if we found a match.  If so, break out
                        // of our loop.
                        //
                        if (bFind) {
                            lpszMfgName = genGAllocStr(lpszPtr);
                            break;
                        }


                        // Goto the next section.
                        //
                        lpszPtr = inf_NextStr(lpszPtr);
                    }

                    genGFree(lpszNames, genGSize(lpszNames));
                }
            }
        }

        genGFree(lpszDrvCpy, genGSize(lpszDrvCpy));
    }

    return lpszMfgName;
}



/*****************************************************************************\
* inf_GetMfgName (Local Routine)
*
* Get the manufacture-name from the driver-name.  Some drivers do not really
* begin with the manufacture-name.  These will have to be special-cased
* to determine their cooresponding manufacturer-name.
*
\*****************************************************************************/
LPTSTR inf_GetMfgName(
    LPINFINFO lpInf)
{
    HANDLE hPrinter;
    LPTSTR lpszMfgName = NULL;


    if (OpenPrinter(lpInf->lpszFrnName, &hPrinter, NULL)) {
        DWORD    cbNeeded = 0;
        LPTSTR   lpszClientEnvironment = (LPTSTR)genStrCliEnvironment(lpInf->idxPlt);

        GetPrinterDriver( hPrinter,
                          lpszClientEnvironment,
                          6,
                          NULL,
                          0,
                          &cbNeeded
                          );

        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {
            LPBYTE pData;
            DWORD  dwSize = cbNeeded;

            if ( pData = (LPBYTE) genGAlloc(cbNeeded) ) {
                if (GetPrinterDriver( hPrinter,
                                      lpszClientEnvironment,
                                      6,
                                      pData,
                                      dwSize,
                                      &cbNeeded) ) {
                    PDRIVER_INFO_6 pDriverInfo = (PDRIVER_INFO_6) pData;

                    if (pDriverInfo->pszMfgName)
                        lpszMfgName = genGAllocStr(pDriverInfo->pszMfgName);
                        else
                        SetLastError(ERROR_BAD_ENVIRONMENT);

                }
                genGFree( pData, dwSize );
            }
        }

        ClosePrinter(hPrinter);
    }

    if (NULL == lpszMfgName)
        lpszMfgName = inf_GetMfgNameExe(lpInf);

    return lpszMfgName;
}


/*****************************************************************************\
* inf_BuildItems (Local Routine)
*
* This routine builds a file-list of items that the INF setup requires.
*
\*****************************************************************************/
LPINFITEMINFO inf_BuildItems(
    LPINFINFO lpInf)
{
    LPTSTR        lpszMfgName;
    LPINFITEMINFO lpItems = NULL;


    // Get the manufacturer-name that we will be dealing with.  If
    // we can't find the matching name that cooresponds with our driver,
    // then no need to proceed.
    //
    if (lpszMfgName = inf_GetMfgName(lpInf)) {

        // Build the item-list.  If successful, then rewrite our new
        // inf-files for a flat-install.
        //
        lpItems = inf_GetItemList(lpInf, lpszMfgName);

        genGFree(lpszMfgName, genGSize(lpszMfgName));
    }

    return lpItems;
}


/*****************************************************************************\
* infCreate
*
* Creates an INF object.
*
\*****************************************************************************/
HANDLE infCreate(
    LPINFGENPARM lpParm)
{
    LPINFINFO lpInf;


    if (lpInf = (LPINFINFO)genGAlloc(sizeof(INFINFO))) {

        lpInf->dwCliInfo = lpParm->dwCliInfo;
        lpInf->idxPlt    = lpParm->idxPlt;
        lpInf->idxVer    = lpParm->idxVer;

        // Allocate our parameter-strings.
        //
        if ( inf_AllocStrings(lpInf, lpParm) )
             return (HANDLE)lpInf;

        // Since the allocate Strings failed free up the Object
        genGFree(lpInf, sizeof(INFINFO));
    }

    return NULL;
}

/*****************************************************************************\
* infProcess
*
* Uses INF object to prepare for CAB.
*
\*****************************************************************************/
BOOL infProcess(
    HANDLE hInf)
{

    LPINFINFO lpInf = (LPINFINFO) hInf;

    // Create handle to setup-inf-object.  This requires
    // strings in lpInf to be allocated and correct.
    //
    lpInf->hInfObj = inf_GetInfObj(lpInf);
    if ( lpInf->hInfObj != INVALID_HANDLE_VALUE )  {

        // Retrieve the inf-name from the inf-object.
        //
        if (lpInf->lpszInfName = inf_GetInfName(lpInf)) {

            // Build our file object-list.
            //
            if (lpInf->lpInfItems = inf_BuildItems(lpInf)) {

                // Next, use the item list to determine the cat file and add it
                // to the list.  This can't be done any earlier (like in inf_BuildItems() )
                // because it uses the infEnumItems callback, and so it relies on the
                // item list being setup already.
                //
                if (genIsWin9X(lpInf->idxPlt)) {

                    // Do something different here for 9X?
                    // The server isn't caching the CAT files for 9X drivers, so
                    // we don't have access to them anyway.
                    //
                    return TRUE;
                }
                else {
                    if (inf_AddCATFile(lpInf)) {
                        return TRUE;
                    }
                }
            }
        }

        // Some Type of failure...
        infSetError(lpInf,GetLastError());
    }

    return FALSE;
}

/*****************************************************************************\
* infDestroy
*
* Destroys the INF object and all resources allocated on its behalf.
*
\*****************************************************************************/
BOOL infDestroy(
    HANDLE hInf)
{
    LPINFINFO lpInf;
    BOOL      bFree = FALSE;


    if (lpInf = (LPINFINFO)hInf) {

        if (lpInf->hInfObj != INVALID_HANDLE_VALUE)
            SetupCloseInfFile(lpInf->hInfObj);

        if (lpInf->lpszInfName)
            genGFree(lpInf->lpszInfName, genGSize(lpInf->lpszInfName));

        if (lpInf->lpszFrnName)
            genGFree(lpInf->lpszFrnName, genGSize(lpInf->lpszFrnName));

        if (lpInf->lpszDrvName)
            genGFree(lpInf->lpszDrvName, genGSize(lpInf->lpszDrvName));

        if (lpInf->lpszDrvPath)
            genGFree(lpInf->lpszDrvPath, genGSize(lpInf->lpszDrvPath));

        if (lpInf->lpszDstName)
            genGFree(lpInf->lpszDstName, genGSize(lpInf->lpszDstName));

        if (lpInf->lpszDstPath)
            genGFree(lpInf->lpszDstPath, genGSize(lpInf->lpszDstPath));

        if (lpInf->lpszPrtName)
            genGFree(lpInf->lpszPrtName, genGSize(lpInf->lpszPrtName));

        if (lpInf->lpszShrName)
            genGFree(lpInf->lpszShrName, genGSize(lpInf->lpszShrName));

        if (lpInf->lpInfItems)
            genGFree(lpInf->lpInfItems, genGSize(lpInf->lpInfItems));

        bFree = genGFree(lpInf, sizeof(INFINFO));
    }

    return bFree;
}


/*****************************************************************************\
* infEnumItems
*
* Enumerates the file-items in the INF object.  Enumeration will stop if the
* user-callback returns FALSE.  Otherwise, it will exhaust all files in the
* list.
*
\*****************************************************************************/
BOOL infEnumItems(
    HANDLE      hInf,
    INFENUMPROC pfnEnum,
    LPVOID      lpvData)
{
    LPINFINFO     lpInf;
    LPINFITEMINFO lpII;
    DWORD         dwItems;
    DWORD         idx;
    BOOL          bRet = FALSE;


    if ((lpInf = (LPINFINFO)hInf) && (dwItems = lpInf->lpInfItems->dwCount)) {

        for (idx = 0, lpII = lpInf->lpInfItems; idx < dwItems; idx++) {

            bRet = (*pfnEnum)(lpII->aItems[idx].szName,
                              lpII->aItems[idx].szPath,
                              lpII->aItems[idx].bInf,
                              lpvData);

            if (bRet == FALSE)
                return FALSE;
        }
    }

    return bRet;
}


/*****************************************************************************\
* infGetEnvArch
*
* Returns the platform/environment type identifier.
*
\*****************************************************************************/
WORD infGetEnvArch(
    HANDLE hInf)
{
    LPINFINFO lpInf;
    WORD      wType = PROCESSOR_ARCHITECTURE_UNKNOWN;


    if (lpInf = (LPINFINFO)hInf)
        wType = genValCliArchitecture(lpInf->idxPlt);

    return wType;
}


/*****************************************************************************\
* infGetEnvArchCurr
*
* Returns the platform/environment type for the current-architecture.
*
\*****************************************************************************/
WORD infGetEnvArchCurr(
    HANDLE hInf)
{
    return genValSvrArchitecture();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\genmem.cxx ===
/*****************************************************************************\
* MODULE: genmem.c
*
*   This module contains memory-management wrapper routines.  These provide
*   debugging checks if needed.
*
*   The blocks allocated with these routines include two DWORD entrys for
*   marking the head and tail of the allocation block.  This is structured as
*   follows:
*
*         DWORD              cbSize             DWORD
*      -------------------------------------------------
*     | Block Size |  ...Alocated Memory...  | DEADBEEF |
*      -------------------------------------------------
*                  ^
*                  |
*                   Allocations return this pointer.
*
*   routines
*   --------
*   genGAlloc
*   genGFree
*   genGRealloc
*   genGAllocStr
*   genGCopy
*   genGSize
*
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   22-Nov-1996 <chriswil> created.
*
\*****************************************************************************/

#include "pch.h"

#ifdef DEBUG

/*****************************************************************************\
* mem_validate
*
*   Checks the block of memory for any overwrites or size mismatches.
*
\*****************************************************************************/
LPVOID gen_validate(
    PDWORD_PTR lpMem,
    DWORD   cbSize)
{
    DWORD   cbNew;
    PDWORD_PTR lpTail;
    PDWORD_PTR lpHead;
    LPVOID  lpRet = NULL;


    // Bad thing if a null-pointer is passed in.
    //
    if (lpMem != NULL) {

        // Reset the block to the true position.
        //
        lpHead = --lpMem;


        // Calculate the "real" size of our allocated block and round it
        // up to an even number of DWORD_PTR s.
        //
        cbNew = cbSize + (2 * sizeof(DWORD_PTR));

        if (cbNew & 7)
            cbNew += sizeof(DWORD_PTR) - (cbNew & 7);


        // Get the tail location.
        //
        lpTail = (DWORD_PTR)((LPBYTE)lpHead + cbNew - sizeof(DWORD_PTR));


        // Compare the values that memAlloc stored at the beginning
        // and end of the block
        //
        SPLASSERT(*lpHead == cbSize);
        SPLASSERT(*lpTail == DEADBEEF);

        lpRet = (LPVOID)lpHead;
        } else {

        DBGMSG(DBG_ERROR, ("gen_validate: Bad Pointer"));
    }

    return lpRet;
}

#else

/*****************************************************************************\
* gen_validate (Non-Debug)
*
*   On non-debug builds, we will just return the head ptr.
*
\*****************************************************************************/
_inline LPVOID gen_validate(
    PDWORD_PTR lpMem,
    DWORD   cbSize)
{
    if (lpMem) {

        lpMem--;

        return (LPVOID)lpMem;
    }

    return NULL;
}

#endif

/*****************************************************************************\
* genGAlloc
*
*   Allocates a global-memory block.  This allocation also includes a header
*   block which contains block-information.  This allows for the tracking
*   of overwrites.
*
\*****************************************************************************/
LPVOID genGAlloc(
    DWORD cbSize)
{
    PDWORD_PTR lpMem;
    DWORD   cbNew;


    // Give us a little room for debugging info and make sure that our
    // size in bytes results in a whole number of DWORDs.
    //
    cbNew = cbSize + (2 * sizeof(DWORD_PTR));


    // DWORD_PTR align the memory so that we can track the correct amount
    // of dword-allocations.
    //
    if (cbNew & 7)
        cbNew += sizeof(DWORD_PTR) - (cbNew & 7);


    // Attempt to allocate the memory.
    //
    if ((lpMem = (PDWORD_PTR)GlobalAlloc(GPTR, cbNew)) == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }


    // Set up extra tracking information -- region size at the front
    // and an easily distinguishable constant at the back to help
    // us detect overwrites.
    //
    *lpMem = cbSize;
    *(PDWORD_PTR)((LPBYTE)lpMem + cbNew - sizeof(DWORD_PTR)) = DEADBEEF;

    return (LPVOID)(lpMem + 1);
}


/*****************************************************************************\
* genGFree
*
*   Free the memory allocated from genGAlloc.  Validate the memory to see
*   if any bad-overwrites occured.
*
\*****************************************************************************/
BOOL genGFree(
    LPVOID lpMem,
    DWORD  cbSize)
{
    LPVOID lpHead;
    BOOL   bRet = FALSE;


    // Try to at least make sure it's our memory and that no pointers have
    // gone astray in it.
    //
    if (lpHead = gen_validate((PDWORD_PTR)lpMem, cbSize))
        bRet = (GlobalFree(lpHead) == NULL);

    return bRet;
}


/*****************************************************************************\
* genGRealloc
*
*   Reallocate the memory block.  This allocates a new block, then copies
*   the information to the new-memory.  The old one is freed.
*
\*****************************************************************************/
PVOID genGRealloc(
    LPVOID lpMem,
    DWORD  cbOldSize,
    DWORD  cbNewSize)
{
    LPVOID lpNew;

    if (lpNew = (LPVOID)genGAlloc(cbNewSize)) {

        memcpy(lpNew, lpMem, cbOldSize);

        genGFree(lpMem, cbOldSize);
    }

    return lpNew;
}


/*****************************************************************************\
* genGAllocWStr
*
* Allocate and store a UNICODE string.
*
\*****************************************************************************/
LPWSTR genGAllocWStr(
    LPCWSTR lpwszStr)
{
    LPWSTR lpwszMem;
    DWORD  len;

    if (lpwszStr == NULL)
       return NULL;

    len = lstrlen(lpwszStr) + 1;
    if (lpwszMem = (LPWSTR)genGAlloc(len * sizeof(WCHAR)))
       StringCchCopyW(lpwszMem, len, lpwszStr);

    return lpwszMem;

}


/*****************************************************************************\
* genGAllocStr
*
*   Allocate and store a string.
*
\*****************************************************************************/
LPTSTR genGAllocStr(
    LPCTSTR lpszStr)
{
    LPTSTR lpszMem;
    DWORD  len;

    if (lpszStr == NULL)
       return NULL;

    len = lstrlen(lpszStr) + 1;
    if (lpszMem = (LPTSTR)genGAlloc(len * sizeof(TCHAR)))
       StringCchCopy(lpszMem, len, lpszStr);

    return lpszMem;
}


/*****************************************************************************\
* genGCopy
*
*   Makes a copy of the memory pointed to by (lpSrc), and returns a new
*   allocated block.
*
\*****************************************************************************/
LPVOID genGCopy(
    LPVOID lpSrc)
{
    DWORD  cbSize;
    LPVOID lpCpy = NULL;


    if ((lpSrc != NULL) && (cbSize = genGSize(lpSrc))) {

        if (lpCpy = genGAlloc(cbSize))
            memcpy(lpCpy, lpSrc, cbSize);
    }

    return lpCpy;
}


/*****************************************************************************\
* genGSize
*
*   Returns the size of the block alloced by genGAlloc().
*
\*****************************************************************************/
DWORD genGSize(
    LPVOID lpMem)
{
    PDWORD_PTR lpHead;

    if (lpHead = (PDWORD_PTR)lpMem)
        return (DWORD) *(--lpHead);

    return 0;
}

/*****************************************************************************\
*
* These function are for linking with spllib.
*
\*****************************************************************************/
EXTERN_C
LPVOID
DllAllocSplMem(
    DWORD cb
    )
{
    return LocalAlloc(LPTR, cb);
}

EXTERN_C
BOOL
DllFreeSplMem(
   LPVOID pMem
   )
{
    LocalFree(pMem);

    return TRUE;
}


EXTERN_C
BOOL
DllFreeSplStr(
   LPWSTR lpStr
   )
{
    LocalFree(lpStr);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\geninf.h ===
/*****************************************************************************\
* MODULE: geninf.h
*
* This is the main header for the INF generation module.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 HWP-Guys    Created.
*
\*****************************************************************************/

#define INF_SECTION_BLOCK  4096     // Used as a block-size for section gets.
#define INF_SECTION_LIMIT     8     // Limit of section blocks to allocate.
#define INF_ITEM_BLOCK       16     // Number of items/per alloc-block.
#define INF_MAX_BUFFER      512     // Maximum size buffer.
#define INF_MIN_BUFFER       64     // Minimum size buffer.

#define INF_DRV_DRID      66000     // Setup dir-id for Driver-directory.
#define INF_PRC_DRID      66001     // Setup dir-id for Processor-directory.
#define INF_SYS_DRID      66002     // Setup dir-id for System-directory.
#define INF_ICM_DRID      66003     // Setup dir-id for Color-directory.


typedef BOOL (CALLBACK* INFENUMPROC)(LPCTSTR, LPCTSTR, BOOL, LPVOID);
typedef BOOL (CALLBACK* INFSCANPROC)(HINF, LPCTSTR, LPVOID);

typedef HANDLE (WINAPI* PSETUPCREATE)(LPVOID);
typedef BOOL   (WINAPI* PSETUPDESTROY)(LPVOID);
typedef BOOL   (WINAPI* PSETUPGET)(HANDLE, LPCWSTR, LPCWSTR, LPVOID);



// Parameter Structure for infCreate().
//
typedef struct _INFGENPARM {

    LPCTSTR lpszFriendlyName;       // Friendly-name for printer.
    LPCTSTR lpszShareName;          // Share-name of printer.
    LPCTSTR lpszPortName;           // Name of output-port.
    DWORD   idxPlt;                 // Client platform index.
    DWORD   idxVer;                 // Client version index.
    DWORD   dwCliInfo;              // Client Information.
    LPCTSTR lpszDrvName;            // Driver-name.
    LPCTSTR lpszDstName;            // Name of target-file.
    LPCTSTR lpszDstPath;            // Dest-directory to place target files.

} INFGENPARM;
typedef INFGENPARM      *PINFGENPARM;
typedef INFGENPARM NEAR *NPINFGENPARM;
typedef INFGENPARM FAR  *LPINFGENPARM;


// INF File-Item.
//
typedef struct _INFITEM {

    TCHAR  szName[INF_MIN_BUFFER];   // Name of file-item.
    TCHAR  szSource[INF_MIN_BUFFER]; // Original Name of file-item
    TCHAR  szPath[MAX_PATH];         // Path of file-item.
    TCHAR  szOrd[INF_MIN_BUFFER];    // Ordinal value of winntdir section.
    BOOL   bInf;                     // Specifies if this is an inf-file-item.
  } INFITEM;

typedef INFITEM      *PINFITEM;
typedef INFITEM NEAR *NPINFITEM;
typedef INFITEM FAR  *LPINFITEM;


// INF Item-Obj-Header
//
typedef struct _INFITEMINFO {

    DWORD   dwCount;                // Count of file-items in inf-build.
    INFITEM aItems[1];              // Contiguous array of file-items.

} INFITEMINFO;
typedef INFITEMINFO      *PINFITEMINFO;
typedef INFITEMINFO NEAR *NPINFITEMINFO;
typedef INFITEMINFO FAR  *LPINFITEMINFO;


// INF Object/Methods.
//
typedef struct _INFINFO {
    DWORD                   idxPlt;           // architecture/Environment index.
    DWORD                   idxVer;           // version index.
    DWORD                   dwCliInfo;        // Client Information.
    DWORD                   dwError;          // Error if INF processing fails
    HINF                    hInfObj;          // handle to an INF file object.
    LPTSTR                  lpszInfName;      // name of main inf file.
    LPTSTR                  lpszFrnName;      // friendly name of printer.
    LPTSTR                  lpszDrvName;      // name of driver.
    LPTSTR                  lpszDrvPath;      // windows driver directory.
    LPTSTR                  lpszDstName;      // name of destination file.
    LPTSTR                  lpszDstPath;      // output directory for destination file.
    LPTSTR                  lpszPrtName;      // name of output port.
    LPTSTR                  lpszShrName;      // share name of printer.
    LPINFITEMINFO           lpInfItems;       // object array of file-items.
    SP_ORIGINAL_FILE_INFO   OriginalFileInfo; // orignal name of .inf and .cat file for this inf

} INFINFO;
typedef INFINFO      *PINFINFO;
typedef INFINFO NEAR *NPINFINFO;
typedef INFINFO FAR  *LPINFINFO;


// INF Scan Structure.
//
typedef struct _INFSCAN {

    LPINFINFO     lpInf;
    LPINFITEMINFO lpII;

} INFSCAN;

typedef INFSCAN      *PINFSCAN;
typedef INFSCAN NEAR *NPINFSCAN;
typedef INFSCAN FAR  *LPINFSCAN;


// CATCOUNT and CATCOUNTARRAY structures used for determining
// the CAT file to use.
//
typedef struct _CATCOUNT {
    LPWSTR    lpszCATName;
    UINT      uCount;
} CATCOUNT, *LPCATCOUNT;

typedef struct _CATCOUNTARRAY {
    DWORD      dwIndivSigned;       // Individually signed file count
    UINT       uItems;
    UINT       uNextAvailable;
    HCATADMIN  hCatAdmin;
    LPCATCOUNT lpArray;
} CATCOUNTARRAY, *LPCATCOUNTARRAY;

HANDLE infCreate(
    LPINFGENPARM lpInf);

BOOL infProcess(
    HANDLE hInf);

BOOL infDestroy(
    HANDLE hInf);

BOOL infEnumItems(
    HANDLE      hInf,
    INFENUMPROC pfnEnum,
    LPVOID      lpvData);

WORD infGetEnvArch(
    HANDLE hInf);

WORD infGetEnvArchCurr(
    HANDLE hInf);



/***************************************\
* infGetInfName
\***************************************/
__inline LPCTSTR infGetInfName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszInfName : NULL);
}


/***************************************\
* infGetDrvName
\***************************************/
__inline LPCTSTR infGetDrvName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszDrvName : NULL);
}


/***************************************\
* infGetPrtName
\***************************************/
__inline LPCTSTR infGetPrtName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszPrtName : NULL);
}


/***************************************\
* infGetDstName
\***************************************/
__inline LPCTSTR infGetDstName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszDstName : NULL);
}


/***************************************\
* infGetDstPath
\***************************************/
__inline LPCTSTR infGetDstPath(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszDstPath : NULL);
}


/***************************************\
* infGetFriendlyName
\***************************************/
__inline LPCTSTR infGetFriendlyName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszFrnName : NULL);
}


/***************************************\
* infGetShareName
\***************************************/
__inline LPCTSTR infGetShareName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszShrName : NULL);
}

/***************************************\
* infGetCliInfo
\***************************************/
__inline DWORD infGetCliInfo(
    HANDLE hInf)
{
    return (hInf ? (DWORD)((LPINFINFO)hInf)->dwCliInfo : 0);
}

/***************************************\
* infGetError
\***************************************/
__inline DWORD infGetError(
    HANDLE hInf)
{
    return (hInf ? (DWORD)((LPINFINFO)hInf)->dwError : ERROR_SUCCESS);
}

/***************************************\
* infSetError
\***************************************/
__inline VOID infSetError(
    LPINFINFO hInf,
    DWORD     dwError )
{
    hInf->dwError = dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\genutil.h ===
/*****************************************************************************\
* MODULE: genutil.h
*
*   This is the header module for genutil.c.  This contains useful utility
*   routines shared across the gen* file.s
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   22-Nov-1996 <chriswil> created.
*
\*****************************************************************************/

#define PRT_LEV_2 2


LPTSTR genGetCurDir(VOID);
LPTSTR genGetWinDir(VOID);
LPTSTR genBuildFileName(LPCTSTR, LPCTSTR, LPCTSTR);
LPTSTR genFindCharDiff(LPTSTR, LPTSTR);
LPTSTR genFindChar(LPTSTR, TCHAR);
LPTSTR genFindRChar(LPTSTR, TCHAR);
LPWSTR genWCFromMB(LPCSTR);
LPTSTR genTCFromMB(LPCSTR);
LPTSTR genTCFromWC(LPCWSTR);
LPSTR  genMBFromWC(LPCWSTR);
LPSTR  genMBFromTC(LPCTSTR);
LPTSTR genItoA(int);
BOOL   genUpdIPAddr(VOID);
LPTSTR genFrnName(LPCTSTR);
WORD   genChkSum(LPCTSTR);


#define IDX_X86     ((DWORD) 0)
#define IDX_W9X     ((DWORD) 1)
#define IDX_I64     ((DWORD) 2)
#define IDX_AMD64   ((DWORD) 3)
#define IDX_UNKNOWN ((DWORD)-1)

#define IDX_SPLVER_0 ((DWORD)0)
#define IDX_SPLVER_2 ((DWORD)1)
#define IDX_SPLVER_3 ((DWORD)2)


typedef struct _PLTINFO {

    LPCTSTR lpszCab;  // Name of cab platform.
    LPCTSTR lpszEnv;  // Environment string.
    LPCTSTR lpszPlt;  // Platform override string.
    WORD    wArch;    // Integer representation of platform-type.

} PLTINFO;
typedef PLTINFO      *PPLTINFO;
typedef PLTINFO NEAR *NPPLTINFO;
typedef PLTINFO FAR  *LPPLTINFO;

BOOL    genIsWin9X(DWORD);
DWORD   genIdxCliPlatform(DWORD);
LPCTSTR genStrCliCab(DWORD);
LPCTSTR genStrCliEnvironment(DWORD);
LPCTSTR genStrCliOverride(DWORD);
WORD    genValCliArchitecture(DWORD);
DWORD   genIdxCliVersion(DWORD);
LPCTSTR genStrCliVersion(DWORD);
DWORD   genIdxFromStrVersion(LPCTSTR);
WORD    genValSvrArchitecture(VOID);

/***************************************\
* genIsWin9X
\***************************************/
__inline BOOL genIsWin9X(
    DWORD idxPlt)
{
    return (idxPlt == IDX_W9X);
}

/***************************************\
* genWCtoMB
\***************************************/
__inline DWORD genWCtoMB(
    LPSTR   lpszMB,
    LPCWSTR lpszWC,
    DWORD   cbSize)
{
    cbSize = (DWORD)WideCharToMultiByte(CP_ACP,
                                        0,
                                        lpszWC,
                                        -1,
                                        lpszMB,
                                        (int)cbSize,
                                        NULL,
                                        NULL);

    return cbSize;
}


/***************************************\
* genMBtoWC
\***************************************/
__inline DWORD genMBtoWC(
    LPWSTR lpszWC,
    LPCSTR lpszMB,
    DWORD  cbSize)
{
    cbSize = (DWORD)MultiByteToWideChar(CP_ACP,
                                        MB_PRECOMPOSED,
                                        lpszMB,
                                        -1,
                                        lpszWC,
                                        (int)(cbSize / sizeof(WCHAR)));

    return (cbSize * sizeof(WCHAR));
}


/***************************************\
* gen_OpenFileRead
\***************************************/
__inline HANDLE gen_OpenFileRead(
    LPCTSTR lpszName)
{
    return CreateFile(lpszName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
}


/***************************************\
* gen_OpenFileWrite
\***************************************/
__inline HANDLE gen_OpenFileWrite(
    LPCTSTR lpszName)
{
    return CreateFile(lpszName,
                      GENERIC_WRITE,
                      0,
                      NULL,
                      CREATE_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
}


/***************************************\
* gen_OpenDirectory
\***************************************/
__inline HANDLE gen_OpenDirectory(
    LPCTSTR lpszDir)
{
    return CreateFile(lpszDir,
                      0,
                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                      NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\genutil.cxx ===
/*****************************************************************************\
* MODULE: genutil.c
*
* Various common routines used throughout the gen* files.
*
*   routines
*   --------
*   genGetCurDir
*   genGetWinDir
*   genBuildFileName
*   genFindChar
*   genFindCharDiff
*   genFindRChar
*   genWCFromMB
*   genMBFromWC
*   genItoA
*
*   genIsWin9X
*   genIdxCliPlatform
*   genStrCliCab
*   genStrCliEnvironment
*   genStrCliOverride
*   genValCliArchitecture
*   genIdxCliVersion
*   genStrCliVersion
*   genValSvrArchitecture
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   22-Nov-1996 <chriswil> created.
*
\*****************************************************************************/

#include "pch.h"

/*****************************************************************************\
* genGetCurDir
*
* Returns string indicating current-directory.
*
\*****************************************************************************/
LPTSTR genGetCurDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;


    cbSize = GetCurrentDirectory(0, NULL);

    if (cbSize && (lpszDir = (LPTSTR)genGAlloc((cbSize * sizeof(TCHAR)))))
        GetCurrentDirectory(cbSize, lpszDir);

    return lpszDir;
}


/*****************************************************************************\
* genGetWinDir
*
* Returns string indicating the windows-directory.
*
\*****************************************************************************/
LPTSTR genGetWinDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;


    cbSize = GetWindowsDirectory(NULL, 0);

    if (cbSize && (lpszDir = (LPTSTR)genGAlloc((cbSize * sizeof(TCHAR)))))
        GetWindowsDirectory(lpszDir, cbSize);

    return lpszDir;
}


/*****************************************************************************\
* genBuildFileName
*
* Takes path, name, extension strings and builds a fully-qualified
* string representing the file.  This can also be used to build other
* names.
*
\*****************************************************************************/
LPTSTR genBuildFileName(
    LPCTSTR lpszPath,
    LPCTSTR lpszName,
    LPCTSTR lpszExt)
{
    DWORD  cch;
    LPTSTR lpszFull;
    HRESULT hr = S_OK;


    // Calculate the size necessary to hold the full-path filename.
    //
    cch  = lstrlen(g_szBkSlash);
    cch += (lpszPath ? lstrlen(lpszPath) : 0);
    cch += (lpszName ? lstrlen(lpszName) : 0);
    cch += (lpszExt  ? lstrlen(lpszExt)  : 0);


    if (lpszFull = (LPTSTR)genGAlloc(((cch + 1) * sizeof(TCHAR)))) {

        if (lpszPath) {

            if (lpszExt)
                hr = StringCchPrintf(lpszFull, cch+1, TEXT("%s\\%s%s"), lpszPath, lpszName, lpszExt);
            else
                hr = StringCchPrintf(lpszFull, cch+1, TEXT("%s\\%s"), lpszPath, lpszName);

        } else {

            if (lpszExt)
                hr = StringCchPrintf(lpszFull, cch+1, TEXT("%s%s"), lpszName, lpszExt);
            else
                hr = StringCchPrintf(lpszFull, cch+1, TEXT("%s"), lpszName);
        }

        if (FAILED(hr))
        {
            genGFree(lpszFull, genGSize(lpszFull));
            lpszFull = NULL;
        }
    }

    return lpszFull;
}


/*****************************************************************************\
* genFindCharDiff
*
* This routine returns a pointer to the location in DST, where the characters
* cease to match.
*
\*****************************************************************************/
LPTSTR genFindCharDiff(
    LPTSTR lpszDst,
    LPTSTR lpszSrc)
{
    LPTSTR lpszCS;
    LPTSTR lpszCD;


    CharLower(lpszSrc);
    CharLower(lpszDst);


    lpszCS = lpszSrc;
    lpszCD = lpszDst;

    while (*lpszCS == *lpszCD) {
        lpszCD++;
        lpszCS++;
    }

    return (*lpszCD ? lpszCD : NULL);
}


/*****************************************************************************\
* genFindChar
*
* Searches for the first occurence of (cch) in a string.
*
\*****************************************************************************/
LPTSTR genFindChar(
    LPTSTR lpszStr,
    TCHAR  cch)
{
    if (lpszStr) {

        while ((*lpszStr != cch) && (*lpszStr != TEXT('\0')))
            lpszStr++;

        if (((cch != TEXT('\0')) && (*lpszStr != TEXT('\0'))) || (cch == TEXT('\0')))
            return lpszStr;
    }

    return NULL;
}


/*****************************************************************************\
* genFindRChar
*
* Searches for the first occurence of (cch) in a string in reverse order.
*
\*****************************************************************************/
LPTSTR genFindRChar(
    LPTSTR lpszStr,
    TCHAR  cch)
{
    int nLimit;

    if (nLimit = lstrlen(lpszStr)) {

        lpszStr += nLimit;

        while ((*lpszStr != cch) && nLimit--)
            lpszStr--;

        if (nLimit >= 0)
            return lpszStr;
    }

    return NULL;
}


/*****************************************************************************\
* genWCFromMB
*
* This routine returns a buffer of wide-character representation of a
* ansi string.  The caller is responsible for freeing this pointer returned
* by this function.
*
\*****************************************************************************/
LPWSTR genWCFromMB(
    LPCSTR lpszStr)
{
    DWORD  cbSize;
    LPWSTR lpwszBuf = NULL;


    cbSize = genMBtoWC(NULL, lpszStr, 0);

    if (cbSize && (lpwszBuf = (LPWSTR)genGAlloc(cbSize)))
        genMBtoWC(lpwszBuf, lpszStr, cbSize);

    return lpwszBuf;
}


/*****************************************************************************\
* genTCFromMB
*
* This routine returns a buffer of tchar representation of a
* ansi string.  The caller is responsible for freeing this pointer returned
* by this function.
*
\*****************************************************************************/
LPTSTR genTCFromMB(
    LPCSTR lpszStr)
{

#ifdef UNICODE

    return genWCFromMB(lpszStr);

#else

    return genGAllocStr(lpszStr);

#endif
}

/*****************************************************************************\
* genTCFromWC
*
* This routine returns a buffer of tchar representation of a
* wide string.  The caller is responsible for freeing this pointer returned
* by this function.
*
\*****************************************************************************/
LPTSTR genTCFromWC(
    LPCWSTR lpszwStr)
{

#ifdef UNICODE
    
    return genGAllocStr(lpszwStr);

#else

    return genMBFromWC(lpszwStr);
    
#endif
}


/*****************************************************************************\
* genMBFromWC
*
* This routine returns a buffer of byte-character representation of a
* wide-char string.  The caller is responsible for freeing this pointer
* returned by this function.
*
\*****************************************************************************/
LPSTR genMBFromWC(
    LPCWSTR lpwszStr)
{
    DWORD cbSize;
    LPSTR lpszBuf = NULL;


    cbSize = genWCtoMB(NULL, lpwszStr, 0);

    if (cbSize && (lpszBuf = (LPSTR)genGAlloc(cbSize)))
        genWCtoMB(lpszBuf, lpwszStr, cbSize);

    return lpszBuf;
}


/*****************************************************************************\
* genMBFromTC
*
* This routine returns a buffer of byte-character representation of a
* tchar string.  The caller is responsible for freeing this pointer
* returned by this function.
*
\*****************************************************************************/
LPSTR genMBFromTC(
    LPCTSTR lpszStr)
{

#ifdef UNICODE

    return genMBFromWC(lpszStr);

#else

    return genGAllocStr(lpszStr);

#endif

}


/*****************************************************************************\
* genItoA
*
* Convert integer to string.
*
\*****************************************************************************/
LPTSTR genItoA(
    int nVal)
{
    LPTSTR lpszVal;

    if (lpszVal = (LPTSTR)genGAlloc(INF_MIN_BUFFER))
    {
        if (FAILED(StringCbPrintf(lpszVal, INF_MIN_BUFFER, TEXT("%d"), nVal)))
        {
            genGFree(lpszVal, genGSize(lpszVal));
            lpszVal = NULL;
        }
    }

    return lpszVal;
}


/*****************************************************************************\
* Client Platform Table.
*
* This table describes the various platforms/architectures.  By refering
* to the index into the table, various platform information can be
* obtained.
*
* Members are as follows:
* a) CAB string.  Used to denote the architecture in the cab-name.
* b) Environment string.  Used to denote printer-environment.
* c) Platform string.  Used for path override in setup api's.
* d) Architecture value.  Used to denote platform of client.
*
\*****************************************************************************/
static PLTINFO s_PltTable[] = {

    g_szCabX86, g_szEnvX86, g_szPltX86, PROCESSOR_ARCHITECTURE_INTEL,   // IDX_X86
    g_szCabW9X, g_szEnvW9X, g_szPltW9X, PROCESSOR_ARCHITECTURE_INTEL,   // IDX_W9X
    g_szCabI64, g_szEnvI64, g_szPltI64, PROCESSOR_ARCHITECTURE_IA64,    // IDX_I64
    g_szCabAMD64, g_szEnvAMD64, g_szPltAMD64, PROCESSOR_ARCHITECTURE_AMD64 // IDX_AMD64
};


/*****************************************************************************\
* Client Version Table.
*
* This table describes the spooler-versions which the client can request
* drivers for.
*
\*****************************************************************************/
static LPCTSTR s_VerTable[] = {

    TEXT("\\0"),    // Win9x       - IDX_SPLVER_0
    TEXT("\\2"),    // Win NT 4.0  - IDX_SPLVER_2
    TEXT("\\3")     // Win NT 5.0  - IDX_SPLVER_3
};


/*****************************************************************************\
* genIdxCliPlatform
*
* This routine returns a platform-index into the s_PltTable.  The caller
* can use this index to refer to platform specific information about the
* client.
*
\*****************************************************************************/
DWORD genIdxCliPlatform(
    DWORD dwCliInfo)
{
    DWORD idx;
    DWORD cEnv;
    WORD  wArch;


    // If the platform is win9X, then set the index appropriately.  Otherwise,
    // continue on to determine the correct architecture for the NT case.
    //
    if (webGetOSPlatform(dwCliInfo) == VER_PLATFORM_WIN32_WINDOWS)
        return IDX_W9X;


    // Otherwise, the client is an NT platform.
    //
    cEnv  = sizeof(s_PltTable) / sizeof(s_PltTable[0]);
    wArch = webGetOSArch(dwCliInfo);


    // Look for matching client-info for the NT case.  The architecture
    // values will match up in this case.
    //
    for (idx = 0; idx < cEnv; idx++) {

        if (wArch == s_PltTable[idx].wArch)
            return idx;
    }

    return IDX_UNKNOWN;

}

/*****************************************************************************\
* genStrCliCab
*
* This routine returns a static-string representing the client-cabname.
*
\*****************************************************************************/
LPCTSTR genStrCliCab(
    DWORD idxPlt)
{
    return (idxPlt < (sizeof(s_PltTable) / sizeof(s_PltTable[0])) ? s_PltTable[idxPlt].lpszCab : NULL);
}


/*****************************************************************************\
* genStrCliEnvironment
*
* This routine returns a static-string representing the client-platform.  This
* string is used by the spooler API calls to specify environment.
*
\*****************************************************************************/
LPCTSTR genStrCliEnvironment(
    DWORD idxPlt)
{
    return (idxPlt < (sizeof(s_PltTable) / sizeof(s_PltTable[0])) ? s_PltTable[idxPlt].lpszEnv : NULL);
}


/*****************************************************************************\
* genStrCliOverride
*
* This routines returns a static-string representing the client-path-override
* for the setup API.
*
\*****************************************************************************/
LPCTSTR genStrCliOverride(
    DWORD idxPlt)
{
    return (idxPlt < (sizeof(s_PltTable) / sizeof(s_PltTable[0])) ? s_PltTable[idxPlt].lpszPlt : NULL);
}


/*****************************************************************************\
* genValCliArchitecture
*
* Returns the architecture platform of the client.
*
\*****************************************************************************/
WORD genValCliArchitecture(
    DWORD idxPlt)
{
    return (idxPlt < (sizeof(s_PltTable) / sizeof(s_PltTable[0])) ? s_PltTable[idxPlt].wArch : PROCESSOR_ARCHITECTURE_UNKNOWN);
}


/*****************************************************************************\
* genValSvrArchitecture
*
* Returns the architecture platform of the server.  The current architecture
* running this dll.
*
\*****************************************************************************/
WORD genValSvrArchitecture(VOID)
{
    DWORD idxEnv;

#if defined(_X86_)

    idxEnv = IDX_X86;

#elif defined(_AMD64_)

    idxEnv = IDX_AMD64;

#elif defined(_IA64_)

    idxEnv = IDX_I64;
    
#endif

    return genValCliArchitecture(idxEnv);
}


/*****************************************************************************\
* genIdxCliVersion
*
* This routine returns an index into the s_VerTable.  The caller can refer
* to this index for the client-version information.
*
\*****************************************************************************/
DWORD genIdxCliVersion(
    DWORD dwCliInfo)
{
    DWORD dwPlt = webGetOSPlatform(dwCliInfo);
    DWORD dwMaj = webGetOSMajorVer(dwCliInfo);
    DWORD dwMin = webGetOSMinorVer(dwCliInfo);


    if (dwMaj == 5)
        return IDX_SPLVER_3;

    if ((dwMaj == 4) && (dwPlt == VER_PLATFORM_WIN32_NT))
        return IDX_SPLVER_2;

    if ((dwMaj == 4) && (dwPlt == VER_PLATFORM_WIN32_WINDOWS))
        return IDX_SPLVER_0;

    return IDX_UNKNOWN;
}


/*****************************************************************************\
* genStrCliVersion
*
* Returns a string representing the spooler-version directory.  This is
* the relative directory off the system32\spool\drivers\*\ path that contains
* the drivers.
*
\*****************************************************************************/
LPCTSTR genStrCliVersion(
    DWORD idxVer)
{
    return (idxVer < (sizeof(s_VerTable) / sizeof(s_VerTable[0])) ? s_VerTable[idxVer] : NULL);
}


/*****************************************************************************\
* genIdxFromStrVersion
*
* Returns an index that matches the client-version-string.
*
\*****************************************************************************/
DWORD genIdxFromStrVersion(
    LPCTSTR lpszVer)
{
    DWORD idx;
    DWORD cVer;


    cVer  = sizeof(s_VerTable) / sizeof(s_VerTable[0]);

    for (idx = 0; idx < cVer; idx++) {

        if (lstrcmpi(lpszVer, s_VerTable[idx]) == 0)
            return idx;
    }

    return IDX_UNKNOWN;
}


/*****************************************************************************\
* genUpdIPAddr
*
* Updates the registry with the current IP-Addr of this machine.  If there
* is already an entry in the registry and it's different than the one
* currently established for the machine, then we return FALSE, and update
* the entry.
*
\*****************************************************************************/
BOOL genUpdIPAddr(VOID)
{
    HKEY    hKey;
    LRESULT lRet;
    LPSTR   lpszCmp;
    DWORD   cbData;
    DWORD   dwIpCmp;
    DWORD   dwIpReg;
    DWORD   dwVal;
    BOOL    bRet = TRUE;


    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        g_szPrtReg,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey);

    if (lRet == ERROR_SUCCESS) {

        if (lpszCmp = genMBFromWC(g_szHttpServerName)) {

            // Get the IP-Addr associated with this machine.
            //
            dwIpCmp = GetIPAddr(lpszCmp);


            // Setup our registry-information so get/set a value.
            //
            dwVal  = REG_DWORD;
            cbData = sizeof(DWORD);


            // Get what we already have stored there.  If no value exists,
            // the write it out.
            //
            lRet = RegQueryValueEx(hKey,
                                   g_szIpAddr,
                                   NULL,
                                   &dwVal,
                                   (LPBYTE)&dwIpReg,
                                   &cbData);

            if ((lRet != ERROR_SUCCESS) || (dwIpReg != dwIpCmp)) {

                bRet = FALSE;

                RegSetValueEx(hKey,
                              g_szIpAddr,
                              0,
                              REG_DWORD,
                              (LPBYTE)&dwIpCmp,
                              cbData);
            }

            genGFree(lpszCmp, genGSize(lpszCmp));
        }

        RegCloseKey(hKey);
    }

    return bRet;
}


/*****************************************************************************\
* genFrnName
*
* Returns a cluster-capable friendly-name.
*
\*****************************************************************************/
LPTSTR genFrnName(
    LPCTSTR lpszFrnName)
{
    DWORD  cbSize;
    LPTSTR lpszName = NULL;


    // Calc size for friendly-name.
    //
    cbSize = lstrlen(lpszFrnName) + lstrlen(g_szPrintServerName) + 6;


    // Build it.
    //
    if (lpszName = (LPTSTR)genGAlloc(cbSize * sizeof(TCHAR)))
    {
        if (FAILED(StringCchPrintf(lpszName, cbSize, TEXT("\\\\%s\\%s"), g_szPrintServerName, lpszFrnName)))
        {
            genGFree(lpszName, genGSize(lpszName));
            lpszName = NULL;
        }
    }

    return lpszName;
}


/*****************************************************************************\
* genChkSum (Local Routine)
*
* This routine checksums a string into a WORD value.
*
\*****************************************************************************/

#define CRC_HI(wHi) (((wHi << 1) | (wHi & 0x8000)) ? 0x0001 : 0)
#define CRC_LO(wLo) (((wLo >> 1) | (wLo & 0x0001)) ? 0x8000 : 0)

WORD genChkSum(
    LPCTSTR lpszStr)
{
    WORD  wMask;
    DWORD idx;
    DWORD cLoop;
    DWORD cbStr;
    WORD  wHi     = 0;
    WORD  wLo     = 0;
    WORD  wChkSum = 0;


    if (lpszStr && (cbStr = lstrlen(lpszStr))) {

        // Loop through the bytes (in WORD increments).  This is an
        // optimized method in cyclying through bits.
        //
        cLoop = (cbStr / sizeof(WORD));

        for (idx = 0, wLo = 0, wHi = 0, wChkSum = 0; idx < cLoop; idx++) {

            wChkSum += *(((PWORD)lpszStr) + idx);

            wHi = CRC_HI(wHi) ^ wChkSum;
            wLo = CRC_LO(wLo) ^ wChkSum;
        }


        // If there's any extra bytes left over, then include that
        // in the checksum.  Mask off any bytes that should be
        // excluded from the checksum.
        //
        if (cbStr & 3) {

            wMask = ((WORD)-1 >> ((sizeof(WORD) - (cbStr & 3)) * 8));

            wChkSum += ((*((PWORD)lpszStr + cLoop)) & wMask);

            wHi = CRC_HI(wHi) ^ wChkSum;
            wLo = CRC_LO(wLo) ^ wChkSum;
        }
    }

    return (wChkSum + wHi + wLo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\genmem.h ===
/*****************************************************************************\
* MODULE: genmem.h
*
*   This is the header module for mem.c.  This contains valuable memory
*   management wrappers.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   22-Nov-1996 <chriswil> created.
*
\*****************************************************************************/

// Identifier at the end of the memory-block to check when
// verifying memory-overwrites.
//
#define DEADBEEF 0xdeadbeef


// Memory Routines.
//
LPVOID genGAlloc(DWORD);
BOOL   genGFree(LPVOID, DWORD);
LPVOID genGRealloc(LPVOID, DWORD, DWORD);
LPWSTR genGAllocWStr(LPCWSTR);
LPTSTR genGAllocStr(LPCTSTR);
LPVOID genGCopy(LPVOID);
DWORD  genGSize(LPVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\genglobl.cxx ===
/*****************************************************************************\
* MODULE: genglobl.c
*
* The module contains global-vars for generation routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 <chriswil>  Created.
*
\*****************************************************************************/

#include "pch.h"

// Synchonization section.  We only allow one cab-generation at a time.
//
CRITICAL_SECTION g_csGenCab;


// Command-Line Strings.
//
CONST TCHAR g_szCabCmd[] = TEXT("\"%s\\system32\\iexpress.exe\" /Q /N /S %s");
CONST TCHAR g_szSedCmd[] = TEXT("wpnpinst.exe @%s.webpnp");
CONST TCHAR g_szDatCmd[] = TEXT("/if\n/x\n/b \"%s\"\n/f \"%s\"\n/r \"%s\"\n/m \"%s\"\n/n \"%s\"\n/a \"%s\" /q\n");


// Executable Names.
//
CONST TCHAR g_szNtPrintDll[] = TEXT("ntprint.dll");
CONST TCHAR g_szCabName[]    = TEXT("%04X%s%d");
CONST TCHAR g_szDatName[]    = TEXT("%04X");
CONST TCHAR g_szDatFile[]    = TEXT("cab_ipp.dat");


// File-Extension Strings.
//
CONST TCHAR g_szDotCab[] = TEXT(".cab");
CONST TCHAR g_szDotInf[] = TEXT(".inf");
CONST TCHAR g_szDotSed[] = TEXT(".sed");
CONST TCHAR g_szDotDat[] = TEXT(".dat");
CONST TCHAR g_szDotBin[] = TEXT(".bin");
CONST TCHAR g_szDotIpp[] = TEXT(".webpnp");
CONST TCHAR g_szDotCat[] = TEXT(".cat");


// Cab, Environment and Platform-Override strings.  These strings
// are built into a table in (genutil.cxx) which describes the various
// architectures and version info.
//
CONST TCHAR g_szCabX86[] = TEXT("X86");
CONST TCHAR g_szCabW9X[] = TEXT("W9X");
CONST TCHAR g_szCabI64[] = TEXT("I64");
CONST TCHAR g_szCabAMD64[] = TEXT("AMD64");

CONST TCHAR g_szEnvX86[] = TEXT("Windows NT x86");
CONST TCHAR g_szEnvW9X[] = TEXT("Windows 4.0");
CONST TCHAR g_szEnvI64[] = TEXT("Windows IA64");
CONST TCHAR g_szEnvAMD64[] = TEXT("Windows AMD64");

CONST TCHAR g_szPltX86[] = TEXT("i386");
CONST TCHAR g_szPltW9X[] = TEXT("i386");
CONST TCHAR g_szPltI64[] = TEXT("ia64");
CONST TCHAR g_szPltAMD64[] = TEXT("amd64");


// Registry Strings.
//
CONST TCHAR g_szPrtReg[]        = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Printers");
CONST TCHAR g_szIpAddr[]        = TEXT("IpAddr");
CONST TCHAR g_szPnpData[]       = TEXT("PnpData");
CONST TCHAR g_szMfgName[]       = TEXT("Manufacturer");
CONST TCHAR g_szPrtCabs[]       = TEXT("PrtCabs");
CONST TCHAR g_szPrtDir[]        = TEXT("/Printers");

// Metabase String for path to check for virtual roots
//

CONST TCHAR g_szMetabasePath[]  = TEXT("LM/W3SVC/1/ROOT/PRINTERS");


// NTPRINT Function-Pointers.  These are used in GetProcAddress().
// Therefore, require they be CHAR types.
//
CONST CHAR g_szSetupCreate[]  = "PSetupCreatePrinterDeviceInfoList";
CONST CHAR g_szSetupDestroy[] = "PSetupDestroyPrinterDeviceInfoList";
CONST CHAR g_szSetupGet[]     = "PSetupGetDriverInfForPrinter";


// Common Strings.
//
CONST TCHAR g_szEmptyStr[]    = TEXT("");
CONST TCHAR g_szBkSlash[]     = TEXT("\\");
CONST TCHAR g_szVersionSect[] = TEXT("Version");


// INF-File Strings.
//
CONST TCHAR g_szSkipDir[]        = TEXT("A:\\__Skip__");
CONST TCHAR g_szDestDirs[]       = TEXT("DestinationDirs");
CONST TCHAR g_szPrinterClass[]   = TEXT("Printer");
CONST TCHAR g_szCopyFiles[]      = TEXT("CopyFiles");
CONST TCHAR g_szLayoutKey[]      = TEXT("LayoutFile");
CONST TCHAR g_szWinDirSect[]     = TEXT("WinntDirectories");
CONST TCHAR g_szSrcDskFileSect[] = TEXT("SourceDisksFiles");


// SED-File Strings.
//
CONST TCHAR g_szIExpress[]           = TEXT("IExpress");
CONST TCHAR g_szPackagePurpose[]     = TEXT("PackagePurpose");
CONST TCHAR g_szCreateCAB[]          = TEXT("CreateCAB");
CONST TCHAR g_szPostInstallCmd[]     = TEXT("PostInstallCmd");
CONST TCHAR g_szCompressionMemory[]  = TEXT("CompressionMemory");
CONST TCHAR g_szCompressionValue[]   = TEXT("19");
CONST TCHAR g_szCompressionType[]    = TEXT("CompressionType");
CONST TCHAR g_szCompressTypeVal[]    = TEXT("LZX");
CONST TCHAR g_szCompressionQuantum[] = TEXT("Quantum");
CONST TCHAR g_szCompressionQuantVal[]= TEXT("7");
CONST TCHAR g_szNone[]               = TEXT("<None>");
CONST TCHAR g_szClass[]              = TEXT("Class");
CONST TCHAR g_szSEDVersion[]         = TEXT("SEDVersion");
CONST TCHAR g_szOptions[]            = TEXT("Options");
CONST TCHAR g_szShowWindow[]         = TEXT("ShowInstallProgramWindow");
CONST TCHAR g_szUseLongFileName[]    = TEXT("UseLongFileName");
CONST TCHAR g_szHideAnimate[]        = TEXT("HideExtractAnimation");
CONST TCHAR g_szRebootMode[]         = TEXT("RebootMode");
CONST TCHAR g_szExtractorStub[]      = TEXT("ExtractorStub");
CONST TCHAR g_szSourceFiles[]        = TEXT("SourceFiles");
CONST TCHAR g_szStrings[]            = TEXT("Strings");
CONST TCHAR g_szTimeStamps[]         = TEXT("TimeStamps");
CONST TCHAR g_szSEDVersionNumber[]   = TEXT("2.0");
CONST TCHAR g_sz1[]                  = TEXT("1");
CONST TCHAR g_sz0[]                  = TEXT("0");
CONST TCHAR g_szNoReboot[]           = TEXT("N");
CONST TCHAR g_szTargetName[]         = TEXT("TargetName");
CONST TCHAR g_szAppLaunched[]        = TEXT("AppLaunched");
CONST TCHAR g_szTargetNameSection[]  = TEXT("%TargetName%");
CONST TCHAR g_szAppLaunchedSection[] = TEXT("%AppLaunched%");


CONST CHAR g_szInfSctVer[] = "[Version]\r\n"                                           \
                             "Signature = \"$CHICAGO$\"\r\n"                           \
                             "Class = Printer\r\n"                                     \
                             "InfVersion = 1.0.1\r\n"                                  \
                             "Provider = %MS%\r\n";

CONST CHAR g_szInfSctMfg[] = "\r\n[Manufacturer]\r\n" \
                             "%%MS%% = %hs\r\n";

CONST CHAR g_szInfSctDrv[] = "\r\n[%hs]\r\n"                   \
                             "\"%hs\" = %hs, InetPrinter\r\n";

CONST CHAR g_szInfSctIns[] = "\r\n[%hs]\r\n"                    \
                             "CopyFiles = FileList\r\n"         \
                             "DataSection = InetDriverData\r\n";

CONST CHAR g_szInfSctFil[] = "\r\n[FileList]\r\n";

CONST CHAR g_szInfSctDta[] = "\r\n[InetDriverData]\r\n" \
                             "DataFile = %hs\r\n"       \
                             "HelpFile = %hs\r\n";                              \

CONST CHAR g_szInfSctStr[] = "\r\n[Strings]\r\n" \
                             "MS = \"Inet\"\r\n"    \
                             "DISK1 = \"Disk1\"\r\n";

CONST CHAR g_szInfSctSDN[] = "\r\n[SourceDisksNames]\r\n"  \
                             "1 = %DISK1%,, 0000-0000\r\n";

CONST CHAR g_szInfSctSDF[] = "\r\n[SourceDisksFiles]\r\n";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\globals.cxx ===
/***************************************************************************
FILE                            globals.cpp

MODULE                          Printers ISAPI DLL

PURPOSE                         Windows HTML printer UI over WWW/HTTP

DESCRIBED IN

HISTORY     01/16/96 eriksn     Created based on ISAPI sample DLL
            03/05/97 weihaic    More feature added

****************************************************************************/

#include "pch.h"
#include "printers.h"

// Global Variables; once per process

// Critical section for job spooling info
CRITICAL_SECTION SplCritSect = {0, 0, 0, 0, 0, 0};
// Critical section for maintaining the loaded tag processor list
CRITICAL_SECTION TagCritSect = {0, 0, 0, 0, 0, 0};


// Debugging Environment (SPLLIB).
//
#ifdef DEBUG
MODULE_DEBUG_INIT(DBG_ERROR | DBG_WARN | DBG_TRACE, DBG_ERROR);
#else
MODULE_DEBUG_INIT(DBG_ERROR | DBG_WARN | DBG_TRACE, 0);
#endif

// Query map relates a query string to what it does.
const QUERY_MAP rgQueryMap[] =
{
    TEXT ("IPP"),                      CMD_IPP,
    TEXT ("CreateExe"),                CMD_CreateExe,
};
const int iNumQueryMap = ARRAY_COUNT(rgQueryMap);

//
// g_szHttpServerName is the server name in HTTP request
//
TCHAR       g_szHttpServerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];

//
// g_szPrintServerName is the server name used in OpenPrinter
// If the web server is behind a firewall the PrintServerName
// will be different from HttpServerName because the public network
// address is different from the private network address
//
TCHAR       g_szPrintServerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];

HINSTANCE   g_hInstance = NULL;

// TEXT ("PrintersFolder") is not a localizable string
LPTSTR      g_szPrintersFolder  = TEXT ("PrintersFolder");
LPTSTR      g_szPrinters        = TEXT ("Printers");
LPTSTR      g_szRemotePortAdmin = TEXT ("RemotePortAdmin");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\genglobl.h ===
/*****************************************************************************\
* MODULE: genglobl.h
*
* This is the main header for genglobl file.  Global variables for the
* generation routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 <chriswil>  Created.
*
\*****************************************************************************/

#define SIGNATURE_UNICODE ((WORD)0xFEFF)


// Synchonization section.  We only allow one cab-generation at a time.
//
extern CRITICAL_SECTION g_csGenCab;


// Command-Line Strings.
//
extern CONST TCHAR g_szCabCmd[];
extern CONST TCHAR g_szSedCmd[];
extern CONST TCHAR g_szDatCmd[];


// Executable Names.
//
extern CONST TCHAR g_szNtPrintDll[];
extern CONST TCHAR g_szCabName[];
extern CONST TCHAR g_szDatName[];
extern CONST TCHAR g_szDatFile[];


// File-Extension Strings.
//
extern CONST TCHAR g_szDotCab[];
extern CONST TCHAR g_szDotInf[];
extern CONST TCHAR g_szDotSed[];
extern CONST TCHAR g_szDotDat[];
extern CONST TCHAR g_szDotBin[];
extern CONST TCHAR g_szDotIpp[];
extern CONST TCHAR g_szDotCat[];


// Cab, Environment and Platform-Override strings.
//
extern CONST TCHAR g_szCabX86[];
extern CONST TCHAR g_szCabW9X[];
extern CONST TCHAR g_szCabI64[];
extern CONST TCHAR g_szCabAMD64[];

extern CONST TCHAR g_szEnvX86[];
extern CONST TCHAR g_szEnvW9X[];
extern CONST TCHAR g_szEnvI64[];
extern CONST TCHAR g_szEnvAMD64[];

extern CONST TCHAR g_szPltX86[];
extern CONST TCHAR g_szPltW9X[];
extern CONST TCHAR g_szPltI64[];
extern CONST TCHAR g_szPltAMD64[];


// Registry Strings.
//
extern CONST TCHAR g_szPrtReg[];
extern CONST TCHAR g_szIpAddr[];
extern CONST TCHAR g_szPnpData[];
extern CONST TCHAR g_szMfgName[];
extern CONST TCHAR g_szPrtCabs[];
extern CONST TCHAR g_szPrtDir[];

// Metabase paths
//
extern CONST TCHAR g_szMetabasePath[];

// NTPRINT Function-Pointers.  These are used in GetProcAddress().
// Therefore, require they be CHAR types.
//
extern CONST CHAR g_szSetupCreate[];
extern CONST CHAR g_szSetupDestroy[];
extern CONST CHAR g_szSetupGet[];


// Common Strings.
//
extern CONST TCHAR g_szEmptyStr[];
extern CONST TCHAR g_szBkSlash[];
extern CONST TCHAR g_szVersionSect[];


// INF-File Strings.
//
extern CONST TCHAR g_szSkipDir[];
extern CONST TCHAR g_szDestDirs[];
extern CONST TCHAR g_szPrinterClass[];
extern CONST TCHAR g_szCopyFiles[];
extern CONST TCHAR g_szLayoutKey[];
extern CONST TCHAR g_szWinDirSect[];
extern CONST TCHAR g_szSrcDskFileSect[];


// SED-File Strings.
//
extern CONST TCHAR g_szIExpress[];
extern CONST TCHAR g_szPackagePurpose[];
extern CONST TCHAR g_szCreateCAB[];
extern CONST TCHAR g_szPostInstallCmd[];
extern CONST TCHAR g_szCompressionMemory[];
extern CONST TCHAR g_szCompressionValue[];
extern CONST TCHAR g_szCompressionType[];
extern CONST TCHAR g_szCompressTypeVal[];
extern CONST TCHAR g_szCompressionQuantum[];
extern CONST TCHAR g_szCompressionQuantVal[];
extern CONST TCHAR g_szNone[];
extern CONST TCHAR g_szClass[];
extern CONST TCHAR g_szSEDVersion[];
extern CONST TCHAR g_szOptions[];
extern CONST TCHAR g_szShowWindow[];
extern CONST TCHAR g_szUseLongFileName[];
extern CONST TCHAR g_szHideAnimate[];
extern CONST TCHAR g_szRebootMode[];
extern CONST TCHAR g_szExtractorStub[];
extern CONST TCHAR g_szSourceFiles[];
extern CONST TCHAR g_szStrings[];
extern CONST TCHAR g_szTimeStamps[];
extern CONST TCHAR g_szSEDVersionNumber[];
extern CONST TCHAR g_sz1[];
extern CONST TCHAR g_sz0[];
extern CONST TCHAR g_szNoReboot[];
extern CONST TCHAR g_szTargetName[];
extern CONST TCHAR g_szAppLaunched[];
extern CONST TCHAR g_szTargetNameSection[];
extern CONST TCHAR g_szAppLaunchedSection[];


// Inf Generater Strings.
//
extern CONST CHAR g_szInfSctVer[];
extern CONST CHAR g_szInfSctMfg[];
extern CONST CHAR g_szInfSctDrv[];
extern CONST CHAR g_szInfSctIns[];
extern CONST CHAR g_szInfSctFil[];
extern CONST CHAR g_szInfSctDta[];
extern CONST CHAR g_szInfSctStr[];
extern CONST CHAR g_szInfSctSDN[];
extern CONST CHAR g_szInfSctSDF[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\globals.h ===
/********
*
*  Copyright (c) 1995  Microsoft Corporation
*
*
*  Module Name  : globals.h
*
*  Abstract :
*
*     This module contains  the structure definitions and prototypes for the
*     version 1.0 HTTP Printers Server Extension.
*
******************/

//
// Notes:
//   TEXT (".printer"), TEXT ("/scripts"), TEXT ("PrintersFolder") hardcoded
//   ReadRegistry needs implementation


#ifndef _GLOBALS_H
#define _GLOBALS_H

// Debugging Environment (SPLLIB.LIB)
//
#define MODULE "msw3prt:"

// Define local error code
#define ERROR_DRIVER_NOT_FOUND 5500
#define ERROR_SERVER_DISK_FULL 5512


// URL strings for links
#define  URL_PREFIX             TEXT ("http://%s")             // g_szComputerName

#define  URL_PRINTER            TEXT ("/printers/%s/.printer") // pPageInfo->pPrinterInfo->pShareName
#define  URL_PRINTER_LINK       TEXT ("/%s")                   // pPageInfo->pPrinterInfo->pShareName
#define  URL_FOLDER             TEXT ("/%s/")                  // g_szPrinters

#define  URLS_JOBINFO           TEXT ("?ShowJobInfo&%d")       // dwJobID
#define  URLS_JOBCONTROL        TEXT ("?JobControl&%d&")       // dwJobID, append P,R,C,S

//
//
#define PROCESSOR_ARCHITECTURE_UNSUPPORTED   0xFFFE


// Buffer size for HTML format buffer and size to flush after

#define BUFSIZE   2047
#define FLUSHSIZE 1792

#define STRBUFSIZE  256   // For string resources and our path


#define MAX_Q_ARG 32       // Maximum number of query arguments




// This contains all relevant info for this specific connection
typedef struct
{

    //
    // Group the structure fields in 4*DWORD groups so it can be easily found in the debugger dump.
    //

    // Transient info that is regenerated each session
    EXTENSION_CONTROL_BLOCK *pECB;              // Struct from ISAPI interface
    LPTSTR                  lpszMethod;         // Unicode correspondece of the data member in pECB
    LPTSTR                  lpszQueryString;
    LPTSTR                  lpszPathInfo;

    LPTSTR                  lpszPathTranslated;

    UINT                    iQueryCommand;          // CMD_something
    int                     iNumQueryArgs;          // Yep, number of query arguments

    BOOL                    fQueryArgIsNum[MAX_Q_ARG];  // TRUE if arg is a number
    UINT_PTR                QueryArgValue[MAX_Q_ARG];   // number or pointer to string

    DWORD                   dwError;                // Error message ID set in action tags
    TCHAR                   szStringBuf[STRBUFSIZE];  // For string resources

} ALLINFO, *PALLINFO;

// Contains information opened for the printer page, if any.
typedef struct
{
    LPTSTR              pszFriendlyName;    // Friendly name from Windows (!JobData && !JobClose)
    PPRINTER_INFO_2     pPrinterInfo;       // NULL if JobData or JobClose
    HANDLE              hPrinter;           // NULL if JobData or JobClose

} PRINTERPAGEINFO, *PPRINTERPAGEINFO;



// Query string command identifiers
enum
{
    CMD_Invalid,
    CMD_IPP,
    CMD_Install,
    CMD_CreateExe,
    CMD_WebUI
};

// Supported Architectures ids.
typedef enum _ARCHITECTURE {
    ARCHITECTURE_X86,
    ARCHITECTURE_ALPHA
} ARCHITECTURE;

// Relates status values to status strings (job or printer status)
typedef struct
{
    DWORD   dwStatus;           // Status code (ie, PRINTER_STATUS_PAUSED)
    UINT    iShortStringID;     // Short string (ie, TEXT ("Paused"))
    UINT    iLongStringID;      // Long string(ie, TEXT ("The printer is paused."))

} STAT_STRING_MAP, *PSTAT_STRING_MAP;

// Structure to relate query string command to command ID
typedef struct
{
    LPTSTR   pszCommand;
    UINT    iCommandID;
} QUERY_MAP, *PQUERY_MAP;

// Inline functions and macros

#define ARRAY_COUNT(x) (sizeof(x) / sizeof(x[0]))

//
// utils
//
BOOL FreeStr( LPCTSTR );
LPTSTR AllocStr( LPCTSTR );


// from Spool.CPP
DWORD SplIppJob(WORD wReq, PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);

// Variables in globals.cpp
extern        CRITICAL_SECTION      SplCritSect;
extern        CRITICAL_SECTION      TagCritSect;

extern  const QUERY_MAP             rgQueryMap[];
extern  const int                   iNumQueryMap;

extern        TCHAR                 g_szHttpServerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
extern        TCHAR                 g_szPrintServerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];

extern        HINSTANCE             g_hInstance;
extern        LPTSTR                g_szPrintersFolder;
extern        LPTSTR                g_szPrinters;
extern        LPTSTR                g_szRemotePortAdmin;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\inetio.h ===
/*****************************************************************************\
* MODULE: inetinfo.h
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*     04/14/97 weihaic      Pull declaration from global.h
*
\*****************************************************************************/

#ifndef INETIO_H
#define INETIO_H

INT AnsiToUnicodeString(LPSTR pAnsi, LPWSTR pUnicode, UINT StringLength );
INT UnicodeToAnsiString(LPWSTR pUnicode, LPSTR pAnsi, UINT StringLength);
LPWSTR AllocateUnicodeString(LPSTR  pAnsiString );

BOOL htmlSendHeader(PALLINFO pAllInfo, LPTSTR lpszHeader, LPTSTR lpszContent);

BOOL IsClientSameAsServer(EXTENSION_CONTROL_BLOCK *pECB);
BOOL IsClientHttpProvider (PALLINFO pAllInfo);
BOOL htmlSendRedirect(PALLINFO pAllInfo, LPTSTR lpszURL);

LPTSTR EncodeFriendlyName (LPCTSTR lpText);
LPTSTR DecodeFriendlyName (LPTSTR lpText);

DWORD ProcessErrorMessage (PALLINFO pAllInfo, DWORD dwError = ERROR_SUCCESS);
unsigned long GetIPAddr(LPSTR lpszName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\inetio.cxx ===
/*****************************************************************************\
* MODULE: inetinfo.cxx
*
*
* PURPOSE:  Handles the data pumping to the client via IIS
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*     01/16/96 eriksn     Created based on ISAPI sample DLL
*     07/15/96 babakj     Moved to a separate file
*     05/12/97 weihaic    ASP template support
*
\*****************************************************************************/

#include "pch.h"
#include "printers.h"


static char c_szRemoteHost[]      = "REMOTE_HOST";
static char c_szServerName[]      = "SERVER_NAME";


/* AnsiToUnicodeString
 *
 * Parameters:
 *
 *     pAnsi - A valid source ANSI string.
 *
 *     pUnicode - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source ANSI string.
 *         If 0 , the string is assumed to be
 *         null-terminated.
 *
 * Return:
 *
 *     The return value from MultiByteToWideChar, the number of
 *         wide characters returned.
 *
 *
 */
INT AnsiToUnicodeString( LPSTR pAnsi, LPWSTR pUnicode, UINT StringLength )
{
    INT iReturn;

    if( StringLength == 0 )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


/* UnicodeToAnsiString
 *
 * Parameters:
 *
 *     pUnicode - A valid source Unicode string.
 *
 *     pANSI - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source Unicode string.
 *         If 0 , the string is assumed to be
 *         null-terminated.
 *
 *
 * Notes:
 *      Added the #ifdef DBCS directive for MS-KK, if compiled
 *      with DBCS enabled, we will allocate twice the size of the
 *      buffer including the null terminator to take care of double
 *      byte character strings - KrishnaG
 *
 *      pUnicode is truncated to StringLength characters.
 *
 * Return:
 *
 *     The return value from WideCharToMultiByte, the number of
 *         multi-byte characters returned.
 *
 *
 */
INT
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR  pAnsi,
    UINT   StringLength)
{
    LPSTR pTempBuf = NULL;
    DWORD dwTempSize = 0;
    INT   rc = 0;

    if( !StringLength  ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //
    if( pAnsi == (LPSTR)pUnicode )
    {
        // Allocate enough memory anyway (in case of the far easten language
        // the conversion needs that much
        dwTempSize = ((1 + StringLength) * 2);
        pTempBuf = (LPSTR) LocalAlloc( LPTR, dwTempSize );

        if (!pTempBuf) {
            return 0;
        }

        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength * 2,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        StringCbCopyA( pAnsi, dwTempSize, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}

LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
)
{
    LPWSTR  pUnicodeString;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR) LocalAlloc(LPTR, strlen(pAnsiString) * sizeof(WCHAR) +
                                          sizeof(WCHAR));

    if (pUnicodeString)
        AnsiToUnicodeString(pAnsiString, pUnicodeString, 0);

    return pUnicodeString;
}


//======================================================================
//                  HTML HELPER FUNCTIONS
//======================================================================

/********************************************************************************

Name:
    htmlSendRedirect

Description:

    Send a redirect to the client to let the client request the server again

Arguments:

    pAllInfo:   Pointer to the ALLINFO structure
    lpszURL:    The redirect URL. It is the unicode version of the URL.
                Its content will be modified!!!

Return Value:
    TRUE  if succeed, FASE otherwise.

********************************************************************************/

BOOL htmlSendRedirect(PALLINFO pAllInfo, LPTSTR lpszURL)
{
    DWORD   dwLen;


    if (lpszURL && (dwLen = UnicodeToAnsiString (lpszURL, (LPSTR) lpszURL, NULL))) {
        return pAllInfo->pECB->ServerSupportFunction(pAllInfo->pECB->ConnID,
                                                     HSE_REQ_SEND_URL_REDIRECT_RESP,
                                                     (LPVOID) lpszURL,
                                                     &dwLen,
                                                     NULL);
    }
    else
        return FALSE;
}

unsigned long GetIPAddr (LPSTR lpName)
{
    struct hostent * hp;
    struct sockaddr_in dest,from;

    if (! (hp = gethostbyname(lpName))) {
        return inet_addr(lpName);
    }

    memcpy (&(dest.sin_addr),hp->h_addr,hp->h_length);
    return dest.sin_addr.S_un.S_addr;
}


/********************************************************************************

Name:
    EncodeFriendlyName

Description:

    Encode the friendly name to avoid special characters

Arguments:

    lpText:     the normal text string

Return Value:

    Pointer to the HTML string. The caller is responsible to free the pointer.
    NULL is returned if no enougth memory
********************************************************************************/
LPTSTR EncodeFriendlyName (LPCTSTR lpText)
{
    DWORD   dwLen;
    LPTSTR  lpHTMLStr       = NULL;

    dwLen = 0;
    if (!EncodePrinterName (lpText, NULL, &dwLen) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (lpHTMLStr = (LPTSTR) LocalAlloc (LPTR, dwLen * sizeof (TCHAR))) &&
        EncodePrinterName (lpText, lpHTMLStr, &dwLen))
        return lpHTMLStr;
    else {
        LocalFree (lpHTMLStr);
        return NULL;
    }
}

/********************************************************************************

Name:
    DecodeFriendlyName

Description:

    Decode the frienly name to get rid of %xx pattern.

Arguments:

    lpText:     the encoded printer friendly name

Return Value:

    Pointer to the decoded friendly name.

********************************************************************************/
LPTSTR DecodeFriendlyName (LPTSTR lpStr)
{
    LPTSTR   lpParsedStr = lpStr;
    LPTSTR   lpUnparsedStr = lpStr;
    TCHAR    d1, d2;

    if (!lpStr) return lpStr;

    while (*lpUnparsedStr) {
        switch (*lpUnparsedStr) {
        case '~':
            // To take care the case when the DecodeString ends with %
            if (! (d1 = *++lpUnparsedStr) || (! (d2 = *++lpUnparsedStr)))
                break;
            lpUnparsedStr++;
            *lpParsedStr++ = AscToHex (d1) * 16 + AscToHex (d2);
            break;
        default:
            *lpParsedStr++ = *lpUnparsedStr++;
        }
    }
    *lpParsedStr = NULL;
    return lpStr;
}

BOOL IsClientHttpProvider (PALLINFO pAllInfo)
{
    EXTENSION_CONTROL_BLOCK *pECB;
    DWORD   dwVersion = 0;
    char    buf[64];
    DWORD   dwSize = sizeof (buf);
    // This string is copied from ../inetpp/globals.c
    const   char c_szUserAgent[]     = "Internet Print Provider";

    pECB = pAllInfo->pECB;


    // Check the UserAgent variable at first to see the IE version
    if (pECB->GetServerVariable (pECB->ConnID, "HTTP_USER_AGENT", buf, &dwSize))
        return !strcmp (buf, c_szUserAgent);
    else
        return FALSE;
}

BOOL htmlSendHeader(PALLINFO pAllInfo, LPTSTR lpszHeader, LPTSTR lpszContent)
{
    LPSTR lpszAnsiHeader = NULL;
    LPSTR lpszAnsiContent = NULL;
    BOOL  bRet = FALSE;
    DWORD dwSize = 0;

    if (!lpszHeader || !lpszContent) {
        goto Cleanup;
    }

    lpszAnsiHeader =  (LPSTR) LocalAlloc (LPTR, (1 + lstrlen (lpszHeader)) * sizeof (TCHAR));
    if (lpszContent)
        lpszAnsiContent = (LPSTR) LocalAlloc (LPTR, (1 + lstrlen (lpszContent)) * sizeof (TCHAR));

    if (!lpszAnsiHeader || !lpszAnsiContent) {
        goto Cleanup;
    }

    // Make sure the conversion routines actually converted some characters
    //
    dwSize = UnicodeToAnsiString(lpszHeader,  lpszAnsiHeader, 0);
    if (dwSize > 0)
    {
        dwSize = UnicodeToAnsiString(lpszContent, lpszAnsiContent, 0);

        if (dwSize > 0)
        {
            bRet = pAllInfo->pECB->ServerSupportFunction(pAllInfo->pECB->ConnID,
                                                         HSE_REQ_SEND_RESPONSE_HEADER,
                                                         (LPVOID) lpszAnsiHeader,
                                                         &dwSize,
                                                         (LPDWORD) lpszAnsiContent);
        }
    }

Cleanup:
    LocalFree (lpszAnsiHeader);
    LocalFree (lpszAnsiContent);

    return bRet;

}

BOOL htmlSend500Header(PALLINFO pAllInfo, DWORD dwError)
{
    TCHAR   szStatusPattern [] = TEXT ("500 %d");
    LPTSTR  lpszHeader = NULL;
    DWORD   bRet = FALSE;
    DWORD   dwSize = 0;
    LPTSTR  pszErrorContent = GetString(pAllInfo, IDS_ERROR_500CONTENT);

    dwSize = sizeof (szStatusPattern) + (sizeof (TCHAR) * 40);
    if (! (lpszHeader = (LPTSTR) LocalAlloc (LPTR, dwSize)))
        goto Cleanup;
    else
    {
        StringCbPrintf(lpszHeader, dwSize, szStatusPattern, dwError);
        bRet = htmlSendHeader(pAllInfo, lpszHeader, pszErrorContent);
    }

    Cleanup:
    if (lpszHeader) {
        LocalFree (lpszHeader);
    }

    return bRet;

}

/********************************************************************************

Name:
    ProcessErrorMessage

Description:

    Do the authentication if the error is Permission denied, show the error
    meesage otherwise

Arguments:

    pAllInfo:                   Pointer to the infor struction
    dwError(optional):          Error code, if not provided, dwError in
                                the pAllInfo is used

Return Value:

    HSE_STATUS_SUCCESS if ok.

********************************************************************************/
DWORD ProcessErrorMessage (PALLINFO pAllInfo, DWORD dwError)
{
    DWORD dwRet = HSE_STATUS_ERROR;

    if (!pAllInfo) {
        return dwRet;
    }

    if (dwError != ERROR_SUCCESS)
        pAllInfo->dwError = dwError;

    SetLastError (pAllInfo->dwError);

    if (pAllInfo->dwError == ERROR_ACCESS_DENIED ||
        pAllInfo->dwError == ERROR_INVALID_OWNER)  {
        if (AuthenticateUser(pAllInfo))
            dwRet = HSE_STATUS_SUCCESS;
    } else {
       if (htmlSend500Header(pAllInfo, dwError))
           dwRet = HSE_STATUS_SUCCESS;
    }

    return dwRet;

}

LPTSTR AllocStr( LPCTSTR pStr )
{

    LPTSTR pMem = NULL;
    DWORD  cbStr;

    if( !pStr )
        return NULL;

    cbStr = lstrlen( pStr )*sizeof(TCHAR) + sizeof(TCHAR);

    if( pMem = (LPTSTR)LocalAlloc( LPTR, cbStr ))
        StringCbCopy( pMem, cbStr, pStr );

    return pMem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\msw3prt.h ===
/*****************************************************************************\
* MODULE: msw3prt.h
*
* The module contains routines to implement the ISAPI interface.
*
* PURPOSE       Windows HTTP/HTML printer interface
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*     02/04/97 weihaic    Create the header file
*
\*****************************************************************************/

#ifndef _MSW3PRT_H
#define _MSW3PRT_H

LPTSTR GetString(PALLINFO pAllInfo, UINT iStringID);
BOOL IsSecureReq(EXTENSION_CONTROL_BLOCK *pECB);

BOOL IsUserAnonymous(EXTENSION_CONTROL_BLOCK *pECB);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\msw3prt.cxx ===
/*****************************************************************************\
* MODULE: msw3prt.cxx
*
* The module contains routines to implement the ISAPI interface.
*
* PURPOSE       Windows HTTP/HTML printer interface
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*     01/16/96 eriksn     Created based on ISAPI sample DLL
*     07/15/96 babakj     Ported to NT
*     02/04/97 weihaic    Enabled Unicode mode
*
\*****************************************************************************/

#include "pch.h"

/*****************************************************************************\
* GetClientInfo
*
* Returns a DWORD representation of the client architecture/ver information.
*
\*****************************************************************************/
DWORD GetClientInfo(
                   PALLINFO pAllInfo)
{
    DWORD dwCliInfo = 0;
    LPSTR lpszPtr;


    if (pAllInfo->pECB->cbAvailable)
    {
        //
        // First Allocate a new buffer on the heap to hold the input string
        //
        lpszPtr = (LPSTR) LocalAlloc(LPTR, (pAllInfo->pECB->cbAvailable+1));

        if (lpszPtr)
        {
            //
            // Copy the memory over and then null terminate past the message
            //
            memcpy( lpszPtr, pAllInfo->pECB->lpbData, pAllInfo->pECB->cbAvailable);
            lpszPtr[pAllInfo->pECB->cbAvailable] = 0x00;

            while (*lpszPtr && (*lpszPtr != '='))
                lpszPtr++;

            if (*lpszPtr)
                dwCliInfo = atoi(++lpszPtr);

            LocalFree(lpszPtr);
        }
    }
    else
    {
        if (lpszPtr = pAllInfo->pECB->lpszQueryString)
        {
            while (*lpszPtr && (*lpszPtr != '&'))
                lpszPtr++;

            if (*lpszPtr)
                dwCliInfo = atoi(++lpszPtr);
        }
    }

    return dwCliInfo;
}


/*****************************************************************************\
* GetIppReq
*
* Returns the request-type of the IPP-stream.
*
\*****************************************************************************/
WORD GetIppReq(
    PALLINFO pAllInfo)
{
    LPWORD  pwPtr;
    WORD    wValue = 0;

    if (pAllInfo->pECB->cbAvailable >= sizeof(DWORD)) {

        if (pwPtr = (LPWORD)pAllInfo->pECB->lpbData) {

            CopyMemory (&wValue, pwPtr + 1, sizeof (WORD));

            return ntohs(wValue);
        }
    }

    return 0;
}


/*****************************************************************************\
* IsSecureReq
*
* Returns whether the request comes from a secure https channel.
*
\*****************************************************************************/
BOOL IsSecureReq(
    EXTENSION_CONTROL_BLOCK *pECB)
{
    BOOL  bRet;
    DWORD cbBuf;
    CHAR  szBuf[10];

    cbBuf = 10;
    bRet = pECB->GetServerVariable(pECB->ConnID,
                                   "HTTPS",
                                   &szBuf,
                                   &cbBuf);

    if (bRet && (cbBuf <= 4)) {

        if (lstrcmpiA(szBuf, "on") == 0)
            return TRUE;
    }

    return FALSE;
}



/*****************************************************************************\
* GetPrinterName
*
* Get the printer name from the path
*
\*****************************************************************************/
LPTSTR GetPrinterName (LPTSTR lpszPathInfo)
{
    // The only format we support is "/printers/ShareName|Encoded Printer Name/.printer"

    static  TCHAR szPrinter[] = TEXT ("/.printer");
    static  TCHAR szPrinters[] = TEXT ("/printers/");

    LPTSTR  lpPtr           = NULL;
    LPTSTR  lpPathInfo      = NULL;
    LPTSTR  lpPrinterName   = NULL;
    LPTSTR  lpSuffix        = NULL;
    DWORD   dwLen;

    // Make a copy of lpszPathInfo
    if (! (lpPathInfo = lpPtr = AllocStr (lpszPathInfo)))
        return  NULL;

    // Verify the prefix
    if (_tcsnicmp (lpPathInfo, szPrinters, COUNTOF (szPrinters) - 1)) {
        goto Cleanup;
    }
    lpPathInfo += COUNTOF (szPrinters) - 1;

    dwLen = lstrlen (lpPathInfo);
    // Compare the length of the printer name with .printer suffix
    if (dwLen <= COUNTOF (szPrinter) - 1) {
        goto Cleanup;
    }

    lpSuffix = lpPathInfo + dwLen - COUNTOF (szPrinter) + 1;
    //lpszStr should point to .printer

    // Verify the suffix.
    if (lstrcmpi(lpSuffix, szPrinter)) {
        goto Cleanup;
    }

    *lpSuffix = TEXT('\0');   // Terminate string

    lpPrinterName = AllocStr (lpPathInfo);

Cleanup:

    LocalFree(lpPtr);
    return lpPrinterName;
}

/*****************************************************************************\
* DllMain
*
*
\*****************************************************************************/
BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD fdwReason,
   LPVOID lpvReserved)
{
    BOOL bRet = TRUE;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hinstDLL;

        // Init debug support in spllib.lib
        bSplLibInit( NULL );

        __try {
            InitializeCriticalSection(&SplCritSect);
            InitializeCriticalSection(&TagCritSect);

            // Initialize the CAB generation crit-sect for web-pnp.
            //
            InitCABCrit();
        }
        __except (1) {
            bRet = FALSE;
            SetLastError (ERROR_INVALID_HANDLE);
        }

        if (bRet) {
            // Initializa the sleeper, which is used to cleanup the pritner jobs
            InitSleeper ();

            // We don't care about fdwReason==DLL_THREAD_ATTACH or _DETACH
            DisableThreadLibraryCalls(hinstDLL);

            srand( (UINT)time( NULL ) );
        }

    }

    if (fdwReason == DLL_PROCESS_DETACH)
    {
        // Terminate the additional cleanup thread
        ExitSleeper ();

        DeleteCriticalSection(&SplCritSect);
        DeleteCriticalSection(&TagCritSect);

        // Free our web-pnp crit-sect.
        //
        FreeCABCrit();

        // Free debug support in spllib.lib
        vSplLibFree();
    }

    // Do any other required initialize/deinitialize here.
    return bRet;
}


/*****************************************************************************\
* GetExtensionVersion
*
* Required ISAPI export function.
*
\*****************************************************************************/
BOOL WINAPI GetExtensionVersion(
    HSE_VERSION_INFO *pVer)
{
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    TCHAR szBuf[HSE_MAX_EXT_DLL_NAME_LEN+1];
    szBuf[0] = TEXT('\0');
    LoadString(g_hInstance, IDS_ISAPI_DESCRIPTION, szBuf, sizeof(szBuf) / sizeof (TCHAR));


    // Convert szBuf to ANSI
    if (UnicodeToAnsiString (szBuf, (LPSTR) szBuf, NULL)) {
        lstrcpynA( pVer->lpszExtensionDesc, (LPSTR) szBuf,
                   HSE_MAX_EXT_DLL_NAME_LEN );

        return TRUE;
    }
    else
        return FALSE;
} // GetExtensionVersion()


/*****************************************************************************\
* GetServerName
*
* Get the server name and convert it to the unicode string.
*
\*****************************************************************************/
BOOL GetServerName (EXTENSION_CONTROL_BLOCK *pECB)

{
    static  char c_szServerName[]      = "SERVER_NAME";
    DWORD   dwSize;
    char    szAnsiHttpServerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    BOOL    bRet = FALSE;
    DWORD   dwClusterState;
    BOOL    bCluster = FALSE;

    dwSize = sizeof(szAnsiHttpServerName);
    if (pECB->GetServerVariable (pECB->ConnID, c_szServerName, szAnsiHttpServerName, &dwSize)) {

        AnsiToUnicodeString(szAnsiHttpServerName, g_szHttpServerName, 0);
        // Now, the computer name becomes the server name. In case of the intranet, it is the computer
        // name, in case of internet, it is either the IP address or the DNS name

        if (!lstrcmpi (g_szHttpServerName, TEXT ("localhost")) ||
            !lstrcmpi (g_szHttpServerName, TEXT ("127.0.0.1"))) {

            dwSize = ARRAY_COUNT (g_szHttpServerName);

            bRet = GetComputerName(  g_szHttpServerName, &dwSize);
        }
        else
            bRet = TRUE;
    }


    if (bRet) {

        bRet = FALSE;

        // Now let's get the printer server name

        //
        // Check if we are running in a cluster node
        //
        if ((GetNodeClusterState (NULL, &dwClusterState) == ERROR_SUCCESS) &&
            (dwClusterState == ClusterStateRunning)) {

            bCluster = TRUE;
        }

        //
        // If we are running in the cluster mode, we have to use the ServerName referred in the HTTP header.
        // Otherwise, we can use the computer name directly.
        //

        // Get size in Charaters of the buffer
        dwSize = ARRAY_COUNT (g_szPrintServerName);
        if (bCluster)
        {
            if (SUCCEEDED( StringCchCopy (g_szPrintServerName, dwSize, g_szHttpServerName)))
               bRet = TRUE;
        }
        else
        {
            bRet = GetComputerName(  g_szPrintServerName, &dwSize);
        }

    }

    return bRet;
}


/*****************************************************************************\
* ParseQueryString
*
* ParseQueryString converts the query string into a sequence of arguments.
*  The main command is converted to a command ID. Subsequent arguments are
*   converted to strings or DWORDs.
*
* Format:  Command & Arg1 & Arg2 & Arg3 ...
*   Each arg is either a number or a string in quotes.
*
* returns FALSE if the query string exists but is invalid
*
\*****************************************************************************/
BOOL ParseQueryString(PALLINFO pAllInfo)
{
    LPTSTR  pszQueryString, pszTmp, pszTmp2, pszTmp3;
    int     iNumArgs = 0;

    pszQueryString = pAllInfo->lpszQueryString;

    if ( !pszQueryString || (*pszQueryString == 0) )
    {
        // Check if the method is post
        if ( !lstrcmp (pAllInfo->lpszMethod, TEXT ("POST")) )
        {
            // also check here for content-type application/ipp ???
            //
            pAllInfo->iQueryCommand = CMD_IPP;  // can we use the NULL cmd ???
        }
        else
        {
            pAllInfo->iQueryCommand = CMD_WebUI;  // redirect to webui
        }

        return TRUE;
    }

    // Get a copy of the string to do surgery on it in this routine and save pieces of it as other info.
    // Save it too so it can be freed later.
    pszQueryString = AllocStr ( pszQueryString );

    if ( pszQueryString != NULL )
    {
        // We will find and replace the first '&' with NULL. This is to isolate the first
        // piece of the query string and examine it.
        // pszQueryString then points to this first piece (command), pszTmp to the rest.
        if ( pszTmp = _tcschr( pszQueryString, TEXT('&')) )
        {
            *pszTmp = TEXT('\0');
            pszTmp++;
        }

        // Search for main command
        pAllInfo->iQueryCommand = CMD_Invalid;

        // If we had {WinPrint.PrinterCommandURL}?/myfile.htm&bla1&bla2&bla3.....
        // or {WinPrint.PrinterCommandURL}?/bla1/bla2/.../blaN/myfile.htm&aaa&bbb&ccc...
        // then pszQueryString is pointing to a NULL we inserted in place of '/', so it is OK.
        // So just attempt to find a iQueryCommand only if pszQueryString is pointing to a non-NULL char.
        if ( *pszQueryString )
        {

            for ( int i=0; i<iNumQueryMap; i++ )
            {
                if ( !lstrcmpi(rgQueryMap[i].pszCommand, pszQueryString) )
                {
                    pAllInfo->iQueryCommand = rgQueryMap[i].iCommandID;
                    break;
                }
            }

            if ( pAllInfo->iQueryCommand == CMD_Invalid )
            {
                LocalFree( pszQueryString );
                return FALSE;       // No command found. Bad query string.
            }
        }

        // At this point we continue with pszTmp for the arguments.

        // We take at most MAX_Q_ARG arguments to avoid memory corruption
        while ( (NULL != pszTmp) && (*pszTmp) && iNumArgs < MAX_Q_ARG )
        {
            pszTmp2 = pszTmp;
            pszTmp = _tcschr( pszTmp, TEXT('&'));
            if ( pszTmp != NULL )
            {
                *pszTmp = 0;
                pszTmp ++;
            }
            if ( *pszTmp2 >= TEXT('0') && *pszTmp2 <= TEXT('9') )
            {
                // DWORD integer value
                pAllInfo->fQueryArgIsNum[iNumArgs] = TRUE;
                pAllInfo->QueryArgValue[iNumArgs] = (DWORD)_ttoi(pszTmp2);
            }
            else
            {
                // Pointer to string
                pAllInfo->fQueryArgIsNum[iNumArgs] = FALSE;
                pAllInfo->QueryArgValue[iNumArgs] = (UINT_PTR)pszTmp2;
            }
            iNumArgs ++;
        }

        pAllInfo->iNumQueryArgs = iNumArgs;

        DBGMSG(DBG_INFO, ("ParseQueryString: %d query arguments\r\n", iNumArgs));

        LocalFree( pszQueryString );
        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* CreateExe
*
*
\*****************************************************************************/
DWORD CreateExe(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo, DWORD dwCliInfo)
{
    LPTSTR          lpPortName      = NULL;
    LPTSTR          lpExeName       = NULL;
    LPTSTR          lpFriendlyName  = NULL;
    DWORD           dwRet           = HSE_STATUS_ERROR ;
    DWORD           dwLen           = 0;
    DWORD           dwFNBytes       = 0;
    DWORD           dwLastError     = ERROR_INVALID_DATA;
    BOOL            bSecure         = IsSecureReq (pAllInfo->pECB);

    GetWebpnpUrl (g_szHttpServerName, pPageInfo->pPrinterInfo->pShareName, NULL, bSecure, NULL, &dwLen);
    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER)
        goto Cleanup;

    if (! (lpPortName = (LPTSTR)LocalAlloc(LPTR, dwLen * sizeof (*lpPortName))))
        goto Cleanup;

    if (!GetWebpnpUrl (g_szHttpServerName, pPageInfo->pPrinterInfo->pShareName, NULL, bSecure, lpPortName, &dwLen))
        goto Cleanup;

    lpExeName = (LPTSTR)LocalAlloc(LPTR, MAX_PATH * sizeof (*lpExeName));
    if (!lpExeName)
        goto Cleanup;

    dwFNBytes = (lstrlen(pPageInfo->pszFriendlyName)+1) * sizeof (*lpFriendlyName);
    lpFriendlyName = (LPTSTR)LocalAlloc(LPTR, dwFNBytes);
    if (!lpFriendlyName)
        goto Cleanup;

    if (FAILED( StringCbCopy(lpFriendlyName, dwFNBytes, pPageInfo->pszFriendlyName)))
        goto Cleanup;

    dwRet = GenerateCAB(lpFriendlyName,
                        lpPortName,
                        dwCliInfo,
                        lpExeName,
                        IsSecureReq(pAllInfo->pECB));

    if (dwRet == HSE_STATUS_SUCCESS) {
        LPTSTR lpEncodedExeName = EncodeString (lpExeName, TRUE);

        if (!lpEncodedExeName) {
            dwRet = HSE_STATUS_ERROR;
            goto Cleanup;
        }
        htmlSendRedirect (pAllInfo, lpEncodedExeName);
        LocalFree (lpEncodedExeName);
    }
    else {
        dwLastError = GetLastError ();

        if (dwLastError == ERROR_FILE_NOT_FOUND) {
            dwLastError = ERROR_DRIVER_NOT_FOUND;
        }

        if (dwLastError == ERROR_DISK_FULL) {
            dwLastError = ERROR_SERVER_DISK_FULL;
        }
    }

Cleanup:

    LocalFree(lpPortName);
    LocalFree(lpExeName);
    LocalFree(lpFriendlyName);

    if (dwRet !=  HSE_STATUS_SUCCESS)
        return ProcessErrorMessage (pAllInfo, dwLastError);
    else
        return dwRet;
}

/*****************************************************************************\
* ProcessRequest
*
* Process the incoming request
*
\*****************************************************************************/
DWORD ProcessRequest(PALLINFO pAllInfo, LPTSTR lpszPrinterName)
{
    DWORD            dwRet              = HSE_STATUS_ERROR;
    PPRINTER_INFO_2  pPrinterInfo       = NULL;
    HANDLE           hPrinter           = NULL;
    DWORD            iQueryCommand;
    LPTSTR           lpszFriendlyName;
    DWORD            dwCliInfo;
    WORD             wIppReq            = 0;
    LPTSTR           pszDecodedName     = NULL;
    DWORD            dwSize             = 0;
    PRINTER_DEFAULTS pd                 = {NULL, NULL, PRINTER_ACCESS_USE};
    LPTSTR           lpszWebUIUrl       = NULL;
    LPTSTR           pszOpenName        = NULL;
    LPTSTR           pszTmpName         = NULL;

    iQueryCommand = pAllInfo->iQueryCommand;

    DBGMSG(DBG_INFO, ("ShowPrinterPage for printer \"%ws\"\n", lpszPrinterName));

    // Open the printer and get printer info level 2.
    DecodePrinterName (lpszPrinterName, NULL, &dwSize);

    if (! (pszDecodedName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwSize)))
        return ProcessErrorMessage (pAllInfo, GetLastError ());

    if (!DecodePrinterName (lpszPrinterName, pszDecodedName, &dwSize)) {
        dwRet = ProcessErrorMessage (pAllInfo, GetLastError ());
        goto Cleanup;
    }

    if (*pszDecodedName != TEXT ('\\') )
    {
        dwSize = sizeof(TCHAR) * (lstrlen (pszDecodedName) + lstrlen (g_szPrintServerName) + 4 );

        // There is no server name before the printer name, append the server name
        if (! (pszOpenName = pszTmpName = (LPTSTR) LocalAlloc (LPTR, dwSize)))
            goto Cleanup;

        StringCbCopy (pszOpenName, dwSize, TEXT ("\\\\"));
        StringCbCat (pszOpenName, dwSize, g_szPrintServerName);
        StringCbCat (pszOpenName, dwSize, TEXT ("\\"));
        StringCbCat (pszOpenName, dwSize, pszDecodedName);

    }
    else {
        pszOpenName = pszDecodedName;
    }

    if (! OpenPrinter(pszOpenName, &hPrinter, &pd)) {
        dwRet = ProcessErrorMessage (pAllInfo, GetLastError ());
        goto Cleanup;
    }

    // Get a PRINTER_INFO_2 structure filled up
    dwSize = 0;
    GetPrinter(hPrinter, 2, NULL, 0, &dwSize);
    if ((GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
        (NULL == (pPrinterInfo = (PPRINTER_INFO_2)LocalAlloc(LPTR, dwSize))) ||
        (!GetPrinter(hPrinter, 2, (byte *)pPrinterInfo, dwSize, &dwSize))) {
        dwRet = ProcessErrorMessage (pAllInfo, GetLastError ());
        goto Cleanup;
    }

    if (! (pPrinterInfo->Attributes & PRINTER_ATTRIBUTE_SHARED)) {
        // If the printer is not shared, return access denied
        dwRet = ProcessErrorMessage (pAllInfo, ERROR_ACCESS_DENIED);
        goto Cleanup;
    }

    // Find printer friendly name.
    // If we opened with UNC path we need to remove server name
    if (pPrinterInfo->pPrinterName) {
        lpszFriendlyName = _tcsrchr (pPrinterInfo->pPrinterName, TEXT('\\'));
        if (lpszFriendlyName)
            lpszFriendlyName ++;
        else
            lpszFriendlyName = pPrinterInfo->pPrinterName;
    }

    // We've got an open printer and some printer info. Ready to go.
    // Fill in structure of info for whatever function we call
    PRINTERPAGEINFO ppi;
    ZeroMemory(&ppi, sizeof(ppi));

    ppi.pszFriendlyName = lpszFriendlyName;
    ppi.pPrinterInfo    = pPrinterInfo;
    ppi.hPrinter        = hPrinter;

        // Do appropriate action based on query string
    switch (iQueryCommand) {
    case CMD_WebUI:
        // Construct a URL to redirect
        dwSize = 0;
        if (GetWebUIUrl (NULL,  pszDecodedName,  lpszWebUIUrl, &dwSize))
            goto Cleanup;

        if (GetLastError () != ERROR_INSUFFICIENT_BUFFER)
            goto Cleanup;

        if (!(lpszWebUIUrl = (LPTSTR)LocalAlloc(LPTR, dwSize * sizeof (TCHAR))))
            goto Cleanup;

        if (! GetWebUIUrl (NULL,  pszDecodedName,  lpszWebUIUrl, &dwSize))
            goto Cleanup;

        dwRet = htmlSendRedirect (pAllInfo, lpszWebUIUrl);

        break;

    case CMD_IPP:

        if (wIppReq = GetIppReq(pAllInfo)) {

            dwRet = SplIppJob(wIppReq, pAllInfo, &ppi);

        } else {

            DBGMSG(DBG_WARN, ("ShowPrinterPage: Warn : Invalid IPP Stream.\n"));

            if (IsClientHttpProvider (pAllInfo)){
                // To improve the perfomance for the internet provider by returning something really quick
                LPTSTR  pszContent = GetString(pAllInfo, IDS_ERROR_200CONTENT);
                htmlSendHeader (pAllInfo, TEXT ("200 OK"), pszContent);
                dwRet = HSE_STATUS_SUCCESS;
            }

            if (INVALID_HANDLE_VALUE != hPrinter)
                ClosePrinter(hPrinter);

            break;
        }

        break;

    case CMD_CreateExe:

        DBGMSG(DBG_TRACE, ("Calling CreateExe.\n"));

        if (dwCliInfo = GetClientInfo(pAllInfo)) {

            dwRet = CreateExe(pAllInfo, &ppi, dwCliInfo);

        } else {

            dwRet = ProcessErrorMessage (pAllInfo, ERROR_NOT_SUPPORTED);
            goto Cleanup;
        }
        break;

    default:
        dwRet = ProcessErrorMessage (pAllInfo, ERROR_INVALID_PRINTER_COMMAND);
        break;
    }


Cleanup:
    // Clean up our stuff

    if (dwRet != HSE_STATUS_ERROR)
        pAllInfo->pECB->dwHttpStatusCode=200; // 200 OK

    LocalFree (lpszWebUIUrl);

    LocalFree (pszDecodedName);
    LocalFree (pszTmpName);
    LocalFree (pPrinterInfo);

    // For any commands other than CMD_IPP commands, we can close the
    // printer-handle.  Otherwise, we rely on the Spool*() routines
    // to handle this for us after we're done reading and processing
    // the entire print-job.
    //
    if (hPrinter && (iQueryCommand != CMD_IPP))
        ClosePrinter(hPrinter);

    return dwRet;

}

/*****************************************************************************\
* GetString
*
*
\*****************************************************************************/
LPTSTR GetString(PALLINFO pAllInfo, UINT iStringID)
{
    LPTSTR lpszBuf = pAllInfo->szStringBuf;

    lpszBuf[0] = TEXT('\0');
    LoadString(g_hInstance, iStringID, lpszBuf, STRBUFSIZE);
    SPLASSERT(lpszBuf[0] != TEXT('\0'));

    return lpszBuf;
}

/*****************************************************************************\
* HttpExtensionProc
*
* Main entrypoint for HTML generation.
*
\*****************************************************************************/
DWORD WINAPI HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK *pECB)
{
    DWORD       dwRet = HSE_STATUS_ERROR;
    PALLINFO    pAllInfo = NULL;     // This structure contains all relevant info for this connection
    LPTSTR      pPrinterName = NULL;

    // Assume failure
    if(!pECB) return HSE_STATUS_ERROR;

    pECB->dwHttpStatusCode = HTTP_STATUS_NOT_SUPPORTED;

    // Get the server name and convert it to the unicode string.
    if (!GetServerName (pECB))
        return HSE_STATUS_ERROR;

    if (!(pAllInfo = (PALLINFO) LocalAlloc (LPTR, sizeof (ALLINFO))))
        return HSE_STATUS_ERROR;

    // Initialize pAllInfo
    ZeroMemory(pAllInfo, sizeof(ALLINFO));

    pAllInfo->pECB = pECB;

    // Convert the ANSI string in ECB to Unicode
    // weihaic
    // pAllInfo->lpszQueryString = AllocateUnicodeString(DecodeStringA (pECB->lpszQueryString));
    // We can not decode now becuase the decoded string will bring troubles in parsing
    //
    pAllInfo->lpszQueryString    = AllocateUnicodeString(pECB->lpszQueryString);
    pAllInfo->lpszMethod         = AllocateUnicodeString(pECB->lpszMethod);
    pAllInfo->lpszPathInfo       = AllocateUnicodeString(pECB->lpszPathInfo);
    pAllInfo->lpszPathTranslated = AllocateUnicodeString(pECB->lpszPathTranslated);

    if (!pAllInfo->lpszQueryString ||
        !pAllInfo->lpszMethod      ||
        !pAllInfo->lpszPathInfo    ||
        !pAllInfo->lpszPathTranslated ) {

        goto Cleanup;
    }

    // weihaic
    // The query string contain user entered text such as printer location
    // priner description, etc. These strings are case sensitive, so we
    // could not convert them to upper case at the very beginning
    // CharUpper (pAllInfo->lpszQueryString);
    //
    CharUpper (pAllInfo->lpszMethod);
    CharUpper (pAllInfo->lpszPathInfo);
    CharUpper (pAllInfo->lpszPathTranslated);


    if (! (pPrinterName = GetPrinterName (pAllInfo->lpszPathInfo))) {
        // This is a wrong URL, return error code
        dwRet = ProcessErrorMessage (pAllInfo, ERROR_INVALID_DATA);
        goto Cleanup;
    }

    if (! ParseQueryString (pAllInfo))
        goto Cleanup;


    dwRet = ProcessRequest (pAllInfo, pPrinterName);   // We always hit Cleanup anyway

Cleanup:

    LocalFree (pPrinterName);
    LocalFree (pAllInfo->lpszQueryString);
    LocalFree (pAllInfo->lpszMethod);
    LocalFree (pAllInfo->lpszPathInfo);
    LocalFree (pAllInfo->lpszPathTranslated);

    LocalFree (pAllInfo);

    return dwRet;
} // HttpExtensionProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\printers.h ===
/********
*
*  Copyright (c) 1996  Microsoft Corporation
*
*
*  Module Name  : printers.h
*
*  Abstract :
*
*     This module contains the prototypes for the msw3prt.cxx file for
*		HTTP Printers Server Extension.
*
******************/

#ifndef _PRINTERS_H
#define _PRINTERS_H

// Function prototypes

void    ReadRegistry(PALLINFO pAllInfo);
DWORD   ListSharedPrinters(PALLINFO pAllInfo);
DWORD   ShowPrinterPage(PALLINFO pAllInfo, LPTSTR lpszPrinterName);
DWORD   ShowRemotePortAdmin( PALLINFO pAllInfo, LPTSTR lpszMoitorName );
DWORD   UploadFileToPrinter(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);
DWORD   ParsePathInfo(PALLINFO pAllInfo);
DWORD   ShowDetails(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);
DWORD   ShowJobInfo(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);
void    htmlAddLinks(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo=NULL);
DWORD   CreateExe(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo, ARCHITECTURE Architecture);
DWORD   InstallExe(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);
DWORD   JobControl(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);
DWORD   PrinterControl(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);

BOOL    AuthenticateUser(PALLINFO pAllInfo);

void htmlStartHead(PALLINFO pAllInfo);
void htmlEndHead(PALLINFO pAllInfo);
void htmlStartBody(PALLINFO pAllInfo);
void htmlEndBody(PALLINFO pAllInfo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\pch.h ===
// Designed to allow automatic precompiled headers to do its thing

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <atlbase.h>    // ATL 2.1 support

#include <ntlsapi.h>    // Client Access Licensing
#include <httpext.h>
#include <wininet.h>
#include <spllib.hxx>

#include <icm.h>
#include <setupapi.h>
#include <splsetup.h>
#include <mscat.h>
#include <wincrypt.h>   // Support for individually signed files
#include <wintrust.h>

#include <clusapi.h>

#include <strsafe.h>

#include "genglobl.h"
#include "genmem.h"
#include "genutil.h"
#include "geninf.h"
#include "gencdf.h"
#include "gencab.h"


#include "time.h"
#include "resource.h"
#include "globals.h"
#include "msw3prt.h"
#include "inetio.h"
#include "sleeper.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by printers.rc
//
#define IDS_ISAPI_DESCRIPTION           1
#define IDS_USER                        15
#define IDS_COLOR                       50

#define IDS_INVALID_DOS_SHARE           70

#define IDS_ERROR_CPUNOTSUPPORTED       200
#define IDS_ERROR_501CONTENT            202
#define IDS_ERROR_500CONTENT            203
#define IDS_ERROR_200CONTENT            204

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\sleeper.h ===
/***********************************************************************
*
*  Copyright (c) 1997  Microsoft Corporation
*
*
*  Module Name  : sleeper.h
*
*  Abstract :
*
*     This module contains  the structure definitions and prototypes for the
*     sleeper class in HTTP Printers Server Extension.
*
******************/

#ifndef _SLEEPER_H
#define _SLEEPER_H

// The sleep wake up every 5 minutes
#define SLEEP_INTERVAL 300000

void InitSleeper (void);
void ExitSleeper (void);
void SleeperSchedule (HANDLE hQuitRequestEvent);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\sleeper.cxx ===
#include "pch.h"
#include "spool.h"

static BOOL    bInitialized;
static HANDLE  hQuitRequestEvent;

void InitSleeper (void)
{
    HANDLE  hThread;
    DWORD   dwThreadId;       // The thread id

    DBGMSG(DBG_INFO, ("Sleeper: Constructing..\r\n"));

    // Initialize member variables
    bInitialized = TRUE;
    hQuitRequestEvent = NULL;

    // These two events are used to synchronize the working thread and the main thread

    // The request event is set when the main thread plan to terminate the working thread.
    hQuitRequestEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (!hQuitRequestEvent)
        goto Cleanup;

    // Create a working thread
    hThread = CreateThread( NULL,0,
                            (LPTHREAD_START_ROUTINE) SleeperSchedule,
                            (LPVOID) hQuitRequestEvent,
                            0,
                            &dwThreadId );

    // Cleanup the handles
    if (!hThread) {
        goto Cleanup;
    }
    else {
        CloseHandle (hThread);
    }

    DBGMSG(DBG_INFO, ("Sleeper: Constructed\r\n"));
    return;

Cleanup:
    bInitialized = FALSE;

    if (hQuitRequestEvent) {
        CloseHandle (hQuitRequestEvent);
    }
}

void ExitSleeper ()
{
    DBGMSG(DBG_INFO, ("Sleeper: Destructing\r\n"));

    if (!bInitialized)
        return;

    DBGMSG(DBG_INFO, ("Sleeper: release event %x\r\n", hQuitRequestEvent));
    if (hQuitRequestEvent)
        SetEvent (hQuitRequestEvent);

    Sleep (1000);

    DBGMSG(DBG_INFO, ("Sleeper: Destructed\r\n"));
}

void SleeperSchedule (HANDLE hQuitRequestEvent)
{

    DBGMSG(DBG_INFO, ("Sleeper: Schedule\r\n"));
    DWORD dwStatus;

    while (1) {
        DBGMSG(DBG_INFO, ("Sleeper: Waiting for event %x\r\n", hQuitRequestEvent));

        dwStatus = WaitForSingleObject (hQuitRequestEvent, SLEEP_INTERVAL);

        DBGMSG(DBG_INFO, ("Sleeper: Wait returns %x\r\n", dwStatus));
        switch (dwStatus) {
        case WAIT_TIMEOUT:
            //Time out, continue working
            CleanupOldJob ();
            break;
        default:
            // quit if it is either WAIT_OBJECT_0 or any other events
            DBGMSG(DBG_INFO, ("Sleeper: The working thread quit\r\n"));
            CloseHandle (hQuitRequestEvent);
            ExitThread (0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\spool.cxx ===
/***************************************************************************
FILE                            spool.cpp

MODULE                          Printers ISAPI DLL

PURPOSE                         Spool Print Jobs

DESCRIBED IN

HISTORY     01/16/96 ccteng     Stub
            02/14/97 weihaic
            11/11/97 sylvan     IPP PrintJobRequest
            11/20/97 chriswil   Asynchronous read rewrite
****************************************************************************/

#include "pch.h"
#include "spool.h"
#include "printers.h"


#ifndef HSE_REQ_ASYNC_READ_CLIENT
#define HSE_REQ_ASYNC_READ_CLIENT ((DWORD)1010)
#endif

PINIJOB pIniFirstJob = NULL;

/*****************************************************************************
 * EnterSplSem
 * LeaveSplSem
 *
 *****************************************************************************/
#define EnterSplSem()    EnterCriticalSection(&SplCritSect)
#define LeaveSplSem()    LeaveCriticalSection(&SplCritSect)


/*****************************************************************************
 * Spl_StrSize (Local Routine)
 *
 * Returns the size (in bytes) of the string (includes null-terminator).
 *
 *****************************************************************************/
inline DWORD Spl_StrSize(
    LPCTSTR lpszStr)
{
    return (lpszStr ? ((lstrlen(lpszStr) + 1) * sizeof(TCHAR)) : 0);
}


/*****************************************************************************
 * Spl_CallSSF (Local Routine)
 *
 * Calls the ISAPI ServerSupportFunction
 *
 *****************************************************************************/
inline BOOL Spl_CallSSF(
    LPEXTENSION_CONTROL_BLOCK pECB,
    DWORD                     dwCmd,
    LPVOID                    lpvBuf,
    LPDWORD                   lpdwBuf,
    LPDWORD                   lpdwType)
{
    return pECB->ServerSupportFunction(pECB->ConnID, dwCmd, lpvBuf, lpdwBuf, lpdwType);
}


/*****************************************************************************
 * Spl_SetAsyncCB (Local Routine)
 *
 * Calls the ISAPI ServerSupportFunction to set an asynchronous callback.
 *
 *****************************************************************************/
inline BOOL Spl_SetAsyncCB(
    LPEXTENSION_CONTROL_BLOCK pECB,
    LPVOID                    pfnCallback,
    LPDWORD                   lpdwCtx)
{
    return pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_IO_COMPLETION, pfnCallback, NULL, lpdwCtx);
}


/*****************************************************************************
 * Spl_ReadClient (Local Routine)
 *
 * Calls the ISAPI ServerSupportFunction to do an asynchronous read.
 *
 *****************************************************************************/
inline BOOL Spl_ReadClient(
    LPEXTENSION_CONTROL_BLOCK pECB,
    LPVOID                    lpvBuf,
    DWORD                     cbBuf)
{
    DWORD dwType = HSE_IO_ASYNC;

    return pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_ASYNC_READ_CLIENT, lpvBuf, &cbBuf, &dwType);
}


/*****************************************************************************
 * Spl_WriteClient (Local Routine)
 *
 * Calls the ISAPI WriteClient to do a write.
 *
 *****************************************************************************/
inline BOOL Spl_WriteClient(
    LPEXTENSION_CONTROL_BLOCK pECB,
    LPVOID                    lpvBuf,
    DWORD                     cbBuf)
{
    return pECB->WriteClient(pECB->ConnID, lpvBuf, &cbBuf, (DWORD)NULL);
}


/*****************************************************************************
 * Spl_EndSession (Local Routine)
 *
 * Calls the ISAPI ServerSupportFunction to end our session.
 *
 *****************************************************************************/
inline BOOL Spl_EndSession(
    LPEXTENSION_CONTROL_BLOCK pECB)
{
    DWORD dwStatus = HSE_STATUS_SUCCESS;
    return pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_DONE_WITH_SESSION, &dwStatus, NULL, NULL);
}


/*****************************************************************************
 * Spl_WriteJob (Local Routine)
 *
 * Writes the byte-stream for a print-job.
 *
 *****************************************************************************/
BOOL Spl_WriteJob(
    DWORD  dwJobId,
    LPBYTE lpbData,
    DWORD  cbBytes)
{
    DWORD cbLeft;
    DWORD cbWritten;
    BOOL  fRet = TRUE;


    for (cbLeft = cbBytes; (cbLeft > 0) && fRet; ) {

        if (fRet = WriteJob(dwJobId, lpbData, cbBytes, &cbWritten)) {

            lpbData += cbWritten;
            cbLeft  -= cbWritten;

        } else {

            DBGMSG(DBG_WARN, ("Spl_WriteJob() call failed.\r\n"));
            break;
        }
    }

    return fRet;
}


/*****************************************************************************
 * Spl_AllocPrtUri (Local Routine)
 *
 * Returns a PrinterURI string.
 *
 *****************************************************************************/
LPTSTR Spl_AllocPrtUri(
    LPCTSTR lpszShare,
    LPDWORD lpcbUri,
    BOOL    bSecure)
{

    DWORD  cch;
    DWORD  cbSize;
    LPTSTR lpszUri;


    // Get the size necessary to hold the printer-uri.
    //
    *lpcbUri = 0;
    cch      = 0;

    GetWebpnpUrl(g_szHttpServerName, lpszShare, NULL, bSecure, NULL, &cch);

    if (cch && (lpszUri = (LPTSTR)AllocSplMem(sizeof(TCHAR) * cch))) {

        if (GetWebpnpUrl(g_szHttpServerName, lpszShare, NULL, bSecure, lpszUri, &cch)) {

            *lpcbUri = cch * sizeof(TCHAR);

            return lpszUri;
        }

        FreeSplMem(lpszUri, cch * sizeof(TCHAR));
    }

    return NULL;
}


/*****************************************************************************
 * Spl_AllocJobUri (Local Routine)
 *
 * Returns a JobURI string.
 *
 *****************************************************************************/
LPTSTR Spl_AllocJobUri(
    LPCTSTR lpszShare,
    DWORD   idJob,
    LPDWORD lpcbUri,
    BOOL    bBase,
    BOOL    bSecure)
{
    LPTSTR lpszPrt;
    DWORD  cbSize;
    DWORD  cbPrt;
    DWORD  cch;
    LPTSTR lpszUri = NULL;

    static CONST TCHAR s_szFmt1[] = TEXT("%s?IPP&JobId=%d");
    static CONST TCHAR s_szFmt2[] = TEXT("%s?IPP&JobId=");


    // Set our return-count to zero.
    //
    *lpcbUri = 0;


    // Get the printer-uri, and append a job-id to the end
    // as our job-uri.
    //
    cbPrt = 0;
    if (lpszPrt = Spl_AllocPrtUri(lpszShare, &cbPrt, bSecure)) {

        cbSize = cbPrt + sizeof(s_szFmt1) + 40;

        if (lpszUri = (LPTSTR)AllocSplMem(cbSize)) {

            if (bBase)
                StringCbPrintf(lpszUri, cbSize, s_szFmt2, lpszPrt);
            else
                StringCbPrintf(lpszUri, cbSize, s_szFmt1, lpszPrt, idJob);

            *lpcbUri = cbSize;
        }

        FreeSplMem(lpszPrt, cbPrt);
    }

    return lpszUri;
}


/*****************************************************************************
 * Spl_GetJI2 (Local Routine)
 *
 * Returns a JOB_INFO_2 struct.
 *
 *****************************************************************************/
LPJOB_INFO_2 Spl_GetJI2(
    HANDLE  hPrinter,
    DWORD   idJob,
    LPDWORD lpcbSize)
{
    DWORD        cbSize;
    DWORD        dwLE;
    LPJOB_INFO_2 pji2 = NULL;


    // Clear return-size.
    //
    *lpcbSize = 0;


    // Get the size necessary for the job.
    //
    cbSize = 0;
    GetJob(hPrinter, idJob, 2, NULL, 0, &cbSize);


    // Get the job-information.
    //
    if (cbSize && (pji2 = (LPJOB_INFO_2)AllocSplMem(cbSize))) {

        if (GetJob(hPrinter, idJob, 2, (LPBYTE)pji2, cbSize, &cbSize)) {

            *lpcbSize = cbSize;

        } else {

            dwLE = GetLastError();

            FreeSplMem(pji2, cbSize);
            pji2 = NULL;
        }

    } else {

        dwLE = GetLastError();
    }


    if (pji2 == NULL)
        SetLastError(dwLE);

    return pji2;
}


/*****************************************************************************
 * Spl_AllocAsync
 *
 * Allocate a spool-async-read structure.  This is basically a structure
 * that we use to track where we are in the asynchronous read processing.
 *
 * Parameter/Field descriptions
 * ----------------------------
 * wReq      - IPP Request identifier.
 *
 * hPrinter  - handle to printer.  We are in charge of closing this when
 *             we're done processing the asynchronous reads.
 *
 * lpszShare - share-name of printer.  This is necessary when we respond
 *             back to the client when done processing the job.
 *
 * cbTotal   - Total number of bytes to expect in job.
 *
 * cbRead    - Current bytes read during async read.
 *
 * cbBuf     - Size of read-buffer.
 *
 * lpbRet    - Return-Buffer dependent upon IPP Request identifier.
 *
 *****************************************************************************/
LPSPLASYNC Spl_AllocAsync(
    WORD    wReq,
    HANDLE  hPrinter,
    LPCTSTR lpszShare,
    DWORD   cbTotal)
{
    LPSPLASYNC pAsync;


    if (pAsync = (LPSPLASYNC)AllocSplMem(sizeof(SPLASYNC))) {

        if (pAsync->hIpp = WebIppRcvOpen(wReq)) {

            if (pAsync->lpbBuf = (LPBYTE)AllocSplMem(SPL_ASYNC_BUF)) {

                if (pAsync->lpszShare = AllocSplStr(lpszShare)) {

                    pAsync->wReq     = wReq;
                    pAsync->hPrinter = hPrinter;
                    pAsync->cbTotal  = cbTotal;
                    pAsync->cbRead   = 0;
                    pAsync->cbBuf    = SPL_ASYNC_BUF;
                    pAsync->lpbRet   = NULL;

                    return pAsync;
                }

                FreeSplMem(pAsync->lpbBuf, SPL_ASYNC_BUF);
            }

            WebIppRcvClose(pAsync->hIpp);
        }

        FreeSplMem(pAsync, sizeof(SPLASYNC));
    }

    DBGMSG(DBG_ERROR, ("Spl_AllocAsync() : Out of Memory\r\n"));

    SetLastError(ERROR_OUTOFMEMORY);

    return NULL;
}


/*****************************************************************************
 * Spl_FreeAsync
 *
 * Free our asynchronous read structure.  This also closes our printer
 * handle that was setup prior to the beginning of the job.
 *
 *****************************************************************************/
BOOL Spl_FreeAsync(
    LPSPLASYNC pAsync)
{
    LPIPPRET_JOB pj;


    // Close the printer-handle.  We do this here as oppose to in
    // (msw3prt.cxx), since if we had performed asynchronous reads
    // we would need to leave the scope the HttpExtensionProc() call.
    //
    // NOTE: CloseJob() closes the printer-handle.  Only in the case
    //       where we were not able to open a job should we close it
    //       here.
    //
    pj = (LPIPPRET_JOB)pAsync->lpbRet;

    if ((pAsync->wReq == IPP_REQ_PRINTJOB) && pj && pj->bRet) {

        CloseJob((DWORD)pj->bRet);

    } else {

        ClosePrinter(pAsync->hPrinter);
    }


    // Free up our Ipp-handle, and all resources allocated.
    //
    if (pAsync->lpbBuf)
        FreeSplMem(pAsync->lpbBuf, pAsync->cbBuf);

    if (pAsync->lpszShare)
        FreeSplStr(pAsync->lpszShare);

    if (pAsync->lpbRet)
        WebIppFreeMem(pAsync->lpbRet);

    if (pAsync->hIpp)
        WebIppRcvClose(pAsync->hIpp);

    FreeSplMem(pAsync, sizeof(SPLASYNC));

    return TRUE;
}


/*****************************************************************************
 * Spl_OpenPrn (Local Routine)
 *
 * Opens a printer-handle with administrator rights.
 *
 *****************************************************************************/
HANDLE Spl_OpenPrn(
    HANDLE hPrinter)
{
    PPRINTER_INFO_1  ppi;
    PRINTER_DEFAULTS pa;
    DWORD            cbSize;
    HANDLE           hPrn = NULL;


    cbSize = 0;
    GetPrinter(hPrinter, 1, NULL, 0, &cbSize);

    if (cbSize && (ppi = (PPRINTER_INFO_1)AllocSplMem(cbSize))) {

        if (GetPrinter(hPrinter, 1, (LPBYTE)ppi, cbSize, &cbSize)) {

            // Since the OpenPrinter call in msw3prt.cxx has been
            // opened with the share-name, the (pName) field of this
            // call will already have the server-name prepended to the
            // friendly-name.  We do not need to do any further work
            // on the friendly-name to accomodate clustering.  If in the
            // future the OpenPrinter() specifies the friendly-name over
            // the share-name, then this routine will need to call
            // genFrnName() to convert the friendly to <server>\friendly.
            //
            ZeroMemory(&pa, sizeof(PRINTER_DEFAULTS));
            pa.DesiredAccess = PRINTER_ALL_ACCESS;

            OpenPrinter(ppi->pName, &hPrn, &pa);
        }

        FreeSplMem(ppi, cbSize);
    }

    return hPrn;
}

/*****************************************************************************
** Spl_AllocSplMemFn (Local Routine)
**
** The WebIppPackJI2 call takes an allocator, however AllocSplMem is a #define
** if we are not using a debug library, so in this case, we have to create
** a small stub function ourselves.
**
*****************************************************************************/
#ifdef DEBUG
    #define Spl_AllocSplMemFn  AllocSplMem
#else
LPVOID Spl_AllocSplMemFn(DWORD cb) {
    return LocalAlloc(LPTR, cb);
}
#endif // #ifdef DEBUG

/*****************************************************************************
 * Spl_CreateJobInfo2 (Local Routine)
 *
 * This creates a JobInfo2 structure from the various printer details that have
 * been passed in to us.
 *
 *****************************************************************************/
LPJOB_INFO_2 Spl_CreateJobInfo2(
    IN  PIPPREQ_PRTJOB  ppj,            // This provides some info that is useful for constructing
                                        // our own JOB_INFO_2 if necessary
    IN  PINIJOB         pInijob,        // This is also used for constructing a JOB_INFO_2
    OUT LPDWORD         lpcbSize
    ) {
    ASSERT(ppj);                        // This should never be NULL if this code path is reached
    ASSERT(lpcbSize);
    ASSERT(*lpcbSize == 0);             // This should be passed in zero


    LPJOB_INFO_2  pji2 = NULL;          // The packed and allocated JI2

    if (pInijob) {                      // This could conceivably be NULL
        DWORD            cbNeeded = 0;

        GetPrinter( pInijob->hPrinter, 2, NULL, 0, &cbNeeded );

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER && cbNeeded) {
            LPPRINTER_INFO_2 ppi2;          // The printer info to fill out
            DWORD            cbNextNeeded;

            ppi2 = (LPPRINTER_INFO_2)AllocSplMem( cbNeeded );

            if (ppi2 && GetPrinter( pInijob->hPrinter, 2, (LPBYTE)ppi2, cbNeeded, &cbNextNeeded) ) {
                JOB_INFO_2    ji2;                  // The ji2 we will fill out, a properly packed one will
                                                    // be returned
                ZeroMemory( &ji2, sizeof(ji2) );

                ji2.JobId               = pInijob->JobId;
                ji2.pPrinterName        = ppi2->pPrinterName;
                ji2.pMachineName        = ppi2->pServerName;
                ji2.pUserName           = ppj->pUserName;
                ji2.pNotifyName         = ppj->pUserName;
                ji2.pDocument           = ppj->pDocument;
                ji2.pDatatype           = ppi2->pDatatype;
                ji2.pPrintProcessor     = ppi2->pPrintProcessor;
                ji2.pParameters         = ppi2->pParameters;
                ji2.pDriverName         = ppi2->pDriverName;
                ji2.Status              = pInijob->dwStatus;
                ji2.Priority            = ppi2->Priority;
                ji2.StartTime           = pInijob->dwStartTime;
                ji2.UntilTime           = pInijob->dwStartTime;
                GetSystemTime (&ji2.Submitted);

                pji2 = WebIppPackJI2(&ji2, lpcbSize, Spl_AllocSplMemFn);
            }

            if (ppi2)
                FreeSplMem( ppi2, cbNeeded );

        }
    }

    return pji2;
}



/*****************************************************************************
 * Spl_ConfirmJob (Local Routine)
 *
 * This confirms that a Job has been printed if it returns a JOB_INFO_2 if
 * this is possible. GSNW printers can return an ERROR_PRINT_CANCELLED for the
 * first GetJob call and then fail on the second call. In this case we need to
 * build a shell JOB_INFO_2 with whatever data we can find and return it. We pass
 * this in to WebIppCreateJobRet which packs the correct strings and returns a
 * Legitimate JOB_INFO_2 structure.
 *
 *****************************************************************************/
LPJOB_INFO_2 Spl_ConfirmJob(
    IN  HANDLE          hPrinter,       // This is the printer handle we are using
    IN  DWORD           idJob,          // This is the job id given to us by StartDocPrinter
    OUT LPDWORD         lpcbSize,       // This is the size of the allocated block
    IN  PIPPREQ_PRTJOB  ppj,            // This provides some info that is useful for constructing
                                        // our own JOB_INFO_2 if necessary
    IN  PINIJOB         pInijob         // This is also used for constructing a JOB_INFO_2
    )
{
    DWORD        cbSize;
    DWORD        dwLE;
    LPJOB_INFO_2 pji2 = NULL;


    ASSERT(lpcbSize);
    // Clear return-size.
    //
    *lpcbSize = 0;

    // Get the size necessary for the job.
    //
    cbSize = 0;
    GetJob(hPrinter, idJob, 2, NULL, 0, &cbSize);

    dwLE = GetLastError();

    switch(dwLE) {
    case ERROR_INSUFFICIENT_BUFFER:
        // Get the job-information.
        //
        if (cbSize && (pji2 = (LPJOB_INFO_2)AllocSplMem(cbSize))) {

            if (GetJob(hPrinter, idJob, 2, (LPBYTE)pji2, cbSize, &cbSize)) {

                *lpcbSize = cbSize;

            } else {

                dwLE = GetLastError();

                FreeSplMem(pji2, cbSize);
                pji2 = NULL;
            }

        } else {

            dwLE = GetLastError();
        }

        break;

    case ERROR_PRINT_CANCELLED:
        // This is special-cased for GSNW masq printers where the job cannot
        // be retrieved from the Server, but we do not want to fail the EndDocPrinter
        // call
        if (pji2 = Spl_CreateJobInfo2( ppj, pInijob, lpcbSize) )
            SetLastError(dwLE = ERROR_SUCCESS);

        break;

    case ERROR_SUCCESS:
        dwLE = ERROR_INVALID_PARAMETER;

        break;
    }

    if (pji2 == NULL)
        SetLastError(dwLE);

    return pji2;
}



/*****************************************************************************
 * Spl_IppJobDataPrt (Local Routine)
 *
 * Handles the IPP_REQ_PRINTJOB request.
 *
 *****************************************************************************/
BOOL Spl_IppJobDataPrt(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPCTSTR                   lpszShare,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE                    lpbDta,
    DWORD                     cbDta,
    LPBYTE*                   lplpbRet)
{
    PIPPREQ_PRTJOB ppj;
    JOB_INFO_IPP   ipp;
    DWORD          cbUri;
    DWORD          cbPrn;
    DWORD          cbJI2;
    WORD           wError;
    DWORD          idJob = 0;
    LPJOB_INFO_2   pji2  = NULL;
    BOOL           bRet  = FALSE;


    if (ppj = (PIPPREQ_PRTJOB)lpbHdr) {

        // Initialize job-information.
        //
        ZeroMemory(&ipp, sizeof(JOB_INFO_IPP));


        // See if we're only to validate the job.
        //
        if (ppj->bValidate) {

            // NOTE: We'll return only a success for now until
            //       we can build a table of validation criteria.
            //
            //       30-Jul-1998 : ChrisWil
            //
            wError = IPPRSP_SUCCESS;
            idJob  = (DWORD)TRUE;

        } else {

            // Start the job.
            //
            PINIJOB pInijob;

            if (idJob = OpenJob(pECB, hPrinter, ppj, cbHdr, &pInijob)) {

                if (pji2 = Spl_ConfirmJob(hPrinter, idJob, &cbJI2, ppj, pInijob)) {

                    wError      = IPPRSP_SUCCESS;
                    ipp.pJobUri = Spl_AllocJobUri(lpszShare, idJob, &cbUri, FALSE, IsSecureReq(pECB));
                    ipp.pPrnUri = Spl_AllocPrtUri(lpszShare, &cbPrn, IsSecureReq(pECB));

                } else {

                    wError = WebIppLeToRsp(GetLastError());
                }

                // Delete the pIniJob (if it has been allocated)

                if (pInijob)
                    FreeSplMem( pInijob, sizeof(INIJOB) );
            } else {

                wError = WebIppLeToRsp(GetLastError());
            }
        }


        // Build the return structure.
        //
        *lplpbRet = (LPBYTE)WebIppCreateJobRet(wError,
                                               (BOOL)idJob,
                                               ppj->bValidate,
                                               pji2,
                                               &ipp);

        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);

        if (pji2)
            FreeSplMem(pji2, cbJI2);

        if (ipp.pJobUri)
            FreeSplMem(ipp.pJobUri, cbUri);

        if (ipp.pPrnUri)
            FreeSplMem(ipp.pPrnUri, cbPrn);


        // If we failed to get a job-id, then we need to
        // return with no further processing.
        //
        if (idJob == 0)
            return FALSE;

        bRet = TRUE;

    } else {

        // If we had no header, then we are processing stream data
        // for the job.  In this case we would have already been through
        // the code-path above where the job-id was set as our return
        // code.
        //
        if (*lplpbRet)
            idJob = (DWORD)((PIPPRET_JOB)*lplpbRet)->bRet;
    }


    // If we were able to get a data-stream, then we
    // need to process that in the write.  If we are chunking
    // data and the lpbHdr is NULL, then the (lpdwJobId) is
    // passed in as input to this routine to be used in chunk
    // writes.
    //
    if (lpbDta)
        bRet = Spl_WriteJob(idJob, lpbDta, cbDta);

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobDataSet (Local Routine)
 *
 * Handles the SetJob requests.
 *
 *****************************************************************************/
BOOL Spl_IppJobDataSet(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    PIPPREQ_SETJOB psj;
    JOB_INFO_2     ji2;
    WORD           wError;
    BOOL           bRet = FALSE;


    if (psj = (PIPPREQ_SETJOB)lpbHdr) {

        // Initialize job-information.
        //
        ZeroMemory(&ji2, sizeof(JOB_INFO_2));


        // Perform the SetJob command.
        //
        bRet = SetJob(hPrinter, psj->idJob, 0, NULL, psj->dwCmd);


        // Get LastError for return to the client.
        //
        wError = (bRet ? IPPRSP_SUCCESS : WebIppLeToRsp(GetLastError()));


        // Return the SetJobRet structure.
        //
        *lplpbRet = (LPBYTE)WebIppCreateJobRet(wError, bRet, FALSE, &ji2, NULL);


        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobDataAth (Local Routine)
 *
 * Handles the Authentication request.
 *
 *****************************************************************************/
BOOL Spl_IppJobDataAth(
    LPEXTENSION_CONTROL_BLOCK pECB,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    PIPPREQ_AUTH pfa;
    WORD         wError;
    BOOL         bRet = FALSE;


    if (pfa = (PIPPREQ_AUTH)lpbHdr) {

        // Call authentication check.
        //
        bRet = !IsUserAnonymous(pECB);


        // Get LastError for return to the client.
        //
        wError = (bRet ? IPPRSP_SUCCESS : IPPRSP_ERROR_401);


        // Return the SetJobRet structure.
        //
        *lplpbRet = (LPBYTE)WebIppCreateAuthRet(wError, bRet);


        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobDataEnu (Local Routine)
 *
 * Handles the IPP_REQ_ENUJOB request.  This returns a complete enumeration
 * of jobs.  It is up to the client to determine which job they are
 * interested in (if they're only interested in one-job).
 *
 *****************************************************************************/
BOOL Spl_IppJobDataEnu(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPCTSTR                   lpszShare,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    LPIPPREQ_ENUJOB pgj;
    LPIPPJI2        lpIppJi2;
    LPTSTR          lpszJobBase;
    LPJOB_INFO_2    lpji2;
    DWORD           cbJobs;
    DWORD           cJobs;
    DWORD           cbNeed;
    DWORD           cNeed;
    DWORD           cbUri;
    WORD            wError;
    BOOL            bRet = FALSE;


    if (pgj = (LPIPPREQ_ENUJOB)lpbHdr) {

        // Initialize IPP return variables.
        //
        cbJobs = 0;
        cJobs  = 0;
        lpji2  = NULL;


        // Get the size necessary to hold the enumerated jobs.  We
        // will return JOB_INFO_2, since that has the most information.
        //
        cbNeed = 0;
        bRet = EnumJobs(hPrinter, 0, pgj->cJobs, 2, NULL, 0, &cbNeed, &cNeed);


        // If we have jobs to enumerate, then grab them.
        //
        if (cbNeed && (lpji2 = (LPJOB_INFO_2)AllocSplMem(cbNeed))) {

            bRet = EnumJobs(hPrinter,
                            0,
                            pgj->cJobs,
                            2,
                            (LPBYTE)lpji2,
                            cbNeed,
                            &cbJobs,
                            &cJobs);

            DBGMSG(DBG_INFO,("Spl_IppJobDataEnu(): cJobs(%d), cbJobs(%d)\r\n", cJobs, cbJobs));
        }

        wError = (bRet ? IPPRSP_SUCCESS : WebIppLeToRsp(GetLastError()));


        // Convert the enumerated-jobs to an IPPJI2 structure.  This
        // allows us to pass information that is not part of a JOB_INFO_2.
        //
        lpszJobBase = Spl_AllocJobUri(lpszShare, 0, &cbUri, TRUE, IsSecureReq (pECB));

        lpIppJi2 = WebIppCvtJI2toIPPJI2(lpszJobBase, &cbJobs, cJobs, lpji2);

        if (lpszJobBase)
            FreeSplMem(lpszJobBase, cbUri);


        // Return the EnuJobRet structure as an IPP stream.
        //
        *lplpbRet = (LPBYTE)WebIppCreateEnuJobRet(wError,
                                                  bRet,
                                                  cbJobs,
                                                  cJobs,
                                                  lpIppJi2);


        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);

        if (lpIppJi2)
            WebIppFreeMem(lpIppJi2);

        if (lpji2)
            FreeSplMem(lpji2, cbNeed);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobDataGet (Local Routine)
 *
 * Handles the IPP_REQ_GETJOB request. This returns the information for a single
 * job.
 *
 *****************************************************************************/
BOOL Spl_IppJobDataGet(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPCTSTR                   lpszShare,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    PIPPREQ_GETJOB pgj;
    LPJOB_INFO_2   pji2;
    JOB_INFO_IPP   ipp;
    DWORD          cbUri;
    DWORD          cbPrn;
    WORD           wError;
    DWORD          cbJI2;
    BOOL           bRet   = FALSE;


    if (pgj = (PIPPREQ_GETJOB)lpbHdr) {

        // Initialize job-information.
        //
        ZeroMemory(&ipp, sizeof(JOB_INFO_IPP));


        if (pji2 = Spl_GetJI2(hPrinter, pgj->idJob, &cbJI2)) {

            wError      = IPPRSP_SUCCESS;
            ipp.pJobUri = Spl_AllocJobUri(lpszShare, pgj->idJob, &cbUri, FALSE, IsSecureReq(pECB));
            ipp.pPrnUri = Spl_AllocPrtUri(lpszShare, &cbPrn, IsSecureReq(pECB));

        } else {

            wError = WebIppLeToRsp(GetLastError());
        }


        // Set the return value.
        //
        *lplpbRet = (LPBYTE)WebIppCreateJobRet(wError, bRet, FALSE, pji2, &ipp);


        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);

        if (pji2)
            FreeSplMem(pji2, cbJI2);

        if (ipp.pJobUri)
            FreeSplMem(ipp.pJobUri, cbUri);

        if (ipp.pPrnUri)
            FreeSplMem(ipp.pPrnUri, cbPrn);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppPrnDataGet (Local Routine)
 *
 * Handles the IPP_REQ_GETPRN request.
 *
 *****************************************************************************/
BOOL Spl_IppPrnDataGet(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPCTSTR                   lpszShare,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    LPIPPREQ_GETPRN  pgp;
    LPPRINTER_INFO_2 lppi2;
    PRINTER_INFO_IPP ipp;
    DWORD            cbSize;
    DWORD            cbUri;
    WORD             wError;
    BOOL             bRet = FALSE;


    if (pgp = (LPIPPREQ_GETPRN)lpbHdr) {

        // Initialize the default information.
        //
        ZeroMemory(&ipp, sizeof(PRINTER_INFO_IPP));
        ipp.pPrnUri = Spl_AllocPrtUri(lpszShare, &cbUri, IsSecureReq(pECB));


        // Get PRINTER_INFO_2 information.
        //
        cbSize = 0;
        GetPrinter(hPrinter, 2, NULL, 0, &cbSize);

        if (lppi2 = (LPPRINTER_INFO_2)AllocSplMem(cbSize)) {
            bRet = GetPrinter(hPrinter, 2, (LPBYTE)lppi2, cbSize, &cbSize);
            if (!bRet) {        // lppi2 might be full of garbage, so free it and pass NULL
                FreeSplMem( lppi2, cbSize );
                lppi2 = NULL;
            }
        }

        // Grab last-error if call failed.
        //
        wError = (bRet ? IPPRSP_SUCCESS : WebIppLeToRsp(GetLastError()));


        // Return the printer-structure.
        //
        *lplpbRet = (LPBYTE)WebIppCreatePrnRet(wError, bRet, lppi2, &ipp);


        // Free allocated resources.
        //
        if (lppi2)
            FreeSplMem(lppi2, cbSize);

        if (ipp.pPrnUri)
            FreeSplMem(ipp.pPrnUri, cbUri);

        WebIppFreeMem(lpbHdr);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppPrnDataSet (Local Routine)
 *
 * Handles SetPrinter Requests.
 *
 *****************************************************************************/
BOOL Spl_IppPrnDataSet(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    PIPPREQ_SETPRN psp;
    PRINTER_INFO_2 pi2;
    HANDLE         hPrn;
    WORD           wError;
    BOOL           bRet = FALSE;


    if (psp = (PIPPREQ_SETPRN)lpbHdr) {

        // Initialize default information.
        //
        ZeroMemory(&pi2, sizeof(PRINTER_INFO_2));


        // Open the printer with admin-priviledges to get
        // the printer information.
        //
        if (hPrn = Spl_OpenPrn(hPrinter)) {

            // Set the job for SetPrinter.
            //
            if ((bRet = SetPrinter(hPrn, 0, NULL, psp->dwCmd)) == FALSE)
                wError = WebIppLeToRsp(GetLastError());
            else
                wError = IPPRSP_SUCCESS;

            ClosePrinter(hPrn);

        } else {

            wError = WebIppLeToRsp(GetLastError());
        }


        // Return the printer-information structure.
        //
        *lplpbRet = (LPBYTE)WebIppCreatePrnRet(wError, bRet, &pi2, NULL);


        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobData (Local Routine)
 *
 * Processes ipp stream data.  This returns a structure specific to the
 * type of request.
 *
 *****************************************************************************/
BOOL Spl_IppJobData(
    LPEXTENSION_CONTROL_BLOCK pECB,
    WORD                      wReq,
    HANDLE                    hPrinter,
    LPCTSTR                   lpszShare,
    HANDLE                    hIpp,
    LPBYTE                    lpbBuf,
    DWORD                     cbBuf,
    LPBYTE*                   lplpbRet)
{
    DWORD  dwIpp;
    LPBYTE lpbHdr;
    DWORD  cbHdr;
    LPBYTE lpbDta;
    DWORD  cbDta;
    BOOL   bRet = FALSE;


    // Convert the stream.
    //
    dwIpp = WebIppRcvData(hIpp, lpbBuf, cbBuf, &lpbHdr, &cbHdr, &lpbDta, &cbDta);


    // See how to process it.
    //
    switch (dwIpp) {

    case WEBIPP_OK:

        switch (wReq) {

        case IPP_REQ_FORCEAUTH:
            bRet = Spl_IppJobDataAth(pECB, lpbHdr, cbHdr, lplpbRet);
            break;

        case IPP_REQ_PRINTJOB:
        case IPP_REQ_VALIDATEJOB:
            bRet = Spl_IppJobDataPrt(pECB,
                                     hPrinter,
                                     lpszShare,
                                     lpbHdr,
                                     cbHdr,
                                     lpbDta,
                                     cbDta,
                                     lplpbRet);
            break;

        case IPP_REQ_CANCELJOB:
        case IPP_REQ_PAUSEJOB:
        case IPP_REQ_RESUMEJOB:
        case IPP_REQ_RESTARTJOB:
            bRet = Spl_IppJobDataSet(pECB, hPrinter, lpbHdr, cbHdr, lplpbRet);
            break;

        case IPP_REQ_ENUJOB:
            bRet = Spl_IppJobDataEnu(pECB, hPrinter, lpszShare, lpbHdr, cbHdr, lplpbRet);
            break;

        case IPP_REQ_GETJOB:
            bRet = Spl_IppJobDataGet(pECB, hPrinter, lpszShare, lpbHdr, cbHdr, lplpbRet);
            break;

        case IPP_REQ_GETPRN:
            bRet = Spl_IppPrnDataGet(pECB, hPrinter, lpszShare, lpbHdr, cbHdr, lplpbRet);
            break;

        case IPP_REQ_PAUSEPRN:
        case IPP_REQ_RESUMEPRN:
        case IPP_REQ_CANCELPRN:
            bRet = Spl_IppPrnDataSet(pECB, hPrinter, lpbHdr, cbHdr, lplpbRet);
            break;
        }
        break;

    case WEBIPP_MOREDATA:

        // More processing.  Do nothing here.
        //
        *lplpbRet = NULL;
        bRet      = TRUE;
        break;

    case WEBIPP_NOMEMORY:
        DBGMSG(DBG_WARN, ("Spl_IppJobData() failed (%d)\r\n", dwIpp));

        *lplpbRet = NULL;
        bRet      = FALSE;
        break;

    case WEBIPP_BADHANDLE:
        *lplpbRet = (LPBYTE)WebIppCreateBadRet(IPPRSP_ERROR_500, FALSE);
        bRet      = FALSE;
        break;

    default:
    case WEBIPP_FAIL:
        *lplpbRet = (LPBYTE)WebIppCreateBadRet(WebIppGetError(hIpp), FALSE);
        bRet      = TRUE;
        break;
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobRsp
 *
 * Sends back a job-response in IPP format.
 *
 *****************************************************************************/
BOOL Spl_IppJobRsp(
   LPEXTENSION_CONTROL_BLOCK pECB,
   WORD                      wReq,
   LPREQINFO                 lpri,
   LPBYTE                    lpbRet)
{
    LPBYTE lpIpp;
    DWORD  cbIpp;
    DWORD  cbHdr;
    DWORD  dwIpp;
    DWORD  cch;
    LPCSTR lpszErr;
    CHAR   szHdr[1024];
    BOOL   bRet = FALSE;

    static CONST CHAR s_szErr400[] = "400 Failed Response";
    static CONST CHAR s_szErr401[] = "401 Authentication Required";
    static CONST CHAR s_szHtpHdr[] = "Content-Type: application/ipp\r\nContent-Length: %d\r\n\r\n";


    if (lpbRet) {

        // Convert to an IPP-Buffer from the return-buffer structure.  For
        // failure cases, the last-error is initialized in the (lpbRet)
        // structure so that the appropriate stream can be generated.
        //
        dwIpp = WebIppSndData((IPP_RESPONSE | wReq),
                              lpri,
                              lpbRet,
                              *((LPDWORD)lpbRet),
                              &lpIpp,
                              &cbIpp);

        if (dwIpp == WEBIPP_OK) {

            // If we had an access-denied, then we will need to include
            // error 401.  This will force the client to prompt for
            // validation.
            //
            if (((LPIPPRET_ALL)lpbRet)->dwLastError == ERROR_ACCESS_DENIED)
                lpszErr = s_szErr401;
            else
                lpszErr = NULL;


            // Build header information.
            //
            StringCbPrintfA( szHdr, sizeof(szHdr), s_szHtpHdr, cbIpp);
            cch = lstrlenA(szHdr);


            // First we send a standard SEND_RESPONSE_HEADER w/our
            // content-type ServerSupportFunction only handles szText,
            // ANSI ??? see URL:
            //
            //   http://www.microsoft.com/WIN32DEV/APIEXT/ISAPIREF.HTM
            //
            // see include httpfilt.h
            //
            Spl_CallSSF(pECB,
                        HSE_REQ_SEND_RESPONSE_HEADER,
                        (LPVOID)lpszErr,
                        (LPDWORD)&cch,
                        (LPDWORD)szHdr);


            // For binary data we use WriteClient.
            //
            bRet = Spl_WriteClient(pECB, lpIpp, cbIpp);

            WebIppFreeMem(lpIpp);

        } else {

            DBGMSG(DBG_WARN, ("Warn: WebIppSndData failed (%d)", dwIpp));
        }
    }


    // Send an HTTP error header if we had big problems...
    //
    if (bRet == FALSE) {

        cch = lstrlenA(s_szErr400);

        Spl_CallSSF(pECB,
                    HSE_REQ_SEND_RESPONSE_HEADER,
                    (LPVOID)s_szErr400,
                    (LPDWORD)&cch,
                    (LPDWORD)NULL);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobAsyncCB
 *
 * Process the asynchronous reads.  This is called by a random ISAPI thread.
 *
 *****************************************************************************/
VOID Spl_IppJobAsyncCB(
    LPEXTENSION_CONTROL_BLOCK pECB,
    PVOID                     pInfo,
    DWORD                     cbIO,
    DWORD                     dwError)
{
    LPSPLASYNC pAsync;
    REQINFO    ri;
    BOOL       bRet;


    if (pAsync = (LPSPLASYNC)pInfo) {

        if ((dwError == 0) && cbIO) {

            // Process the return from the IPP-Receive.  This will
            // process the bytes to the job.
            //
            bRet = Spl_IppJobData(pECB,
                                  pAsync->wReq,
                                  pAsync->hPrinter,
                                  pAsync->lpszShare,
                                  pAsync->hIpp,
                                  pAsync->lpbBuf,
                                  cbIO,
                                  &pAsync->lpbRet);


            // Read another chunk if we haven't read it all yet..
            //
            pAsync->cbRead += cbIO;


            // If an error occured, or we reached the end of our reads,
            // then we need to bail out of the asynchronous callback.
            //
            if ((bRet == FALSE) || (pAsync->cbRead >= pAsync->cbTotal)) {

                goto SplCBDone;
            }


            // Read another chunk.
            //
            Spl_ReadClient(pECB, pAsync->lpbBuf, pAsync->cbBuf);

        } else {

            DBGMSG(DBG_WARN, ("Spl_IppJobAsyncCB() : Called with error or zero-bytes\r\n"));

            bRet = (pAsync->cbRead >= pAsync->cbTotal);

SplCBDone:

            // Send our response-header.
            //
            WebIppGetReqInfo(pAsync->hIpp, &ri);

            Spl_IppJobRsp(pECB, pAsync->wReq, &ri, pAsync->lpbRet);

            Spl_FreeAsync(pAsync);

            Spl_EndSession(pECB);
        }

    } else {

        DBGMSG(DBG_ERROR, ("Spl_IppJobAsyncCB() : No Context Value\r\n"));

        Spl_EndSession(pECB);
    }
}


/*****************************************************************************
 * Spl_IppJobAsync
 *
 * This routine processes the job as an asynchronous read.
 * It is only called once, the rest of the packets are handled by the async call back.
 *
 * How IIS's Async reads work:
 *  1) ISAPI's HTTPExtensionProc gets called for the first chunk of data as usual.
 *  2) In that call:
 *       - The ISAPI sets up a context, allocs a buffer and registers a call back for
 *         async reads.
 *       - Consumes the first chunk of the data.
 *       - Calls ServerSupportFunction( HSE_REQ_ASYNC_READ_CLIENT...) passing the buffer
 *           for IIS to write to. This call returns immediately with no data. When
 *           IIS has got more data from the client, it writes it to the ISAPI's buffer, then
 *           calls the call back passing the context handle that points to the buffer.
 *  3) The call back consumes the data, then calls ServerSupportFunction(
 *      HSE_REQ_ASYNC_READ_CLIENT) again to repeat the cycle. IIS calls the call back
 *      once per ISAPI's call to ServerSupportFunction( HSE_REQ_ASYNC_READ_CLIENT ).
 *
 *****************************************************************************/
DWORD Spl_IppJobAsync(
    LPEXTENSION_CONTROL_BLOCK pECB,
    WORD                      wReq,
    LPCTSTR                   lpszShare,
    HANDLE                    hPrinter)
{
    LPSPLASYNC pAsync;
    REQINFO    ri;
    BOOL       bRet = FALSE;
    BOOL       bSuccess = FALSE;

    // Allocate our structure that contains our state
    // info during asynchronous reads.
    //
    if (pAsync = Spl_AllocAsync(wReq, hPrinter, lpszShare, pECB->cbTotalBytes)) {

        // Set our asynchronous callback.  Specify our (pAsync) structure
        // as the context which is passed to each callback.
        //
        if (Spl_SetAsyncCB(pECB, (LPVOID)Spl_IppJobAsyncCB, (LPDWORD)pAsync)) {

            // Process our first buffer.  Our first chunk will utilize
            // what's already in the ECB-structure.  For other chunks,
            // we will specify our own buffer.
            //
            bSuccess = Spl_IppJobData(pECB,
                                  wReq,
                                  pAsync->hPrinter,
                                  pAsync->lpszShare,
                                  pAsync->hIpp,
                                  pECB->lpbData,
                                  pECB->cbAvailable,
                                  &pAsync->lpbRet);

            if (bSuccess) {

                // Increment our read-count for the bytes we've
                // just processed.
                //
                pAsync->cbRead += pECB->cbAvailable;


                // Do our first asynchronous read.  Return if all is
                // successful.
                //
                if (Spl_ReadClient(pECB, pAsync->lpbBuf, pAsync->cbBuf))
                    return HSE_STATUS_PENDING;
            }

            WebIppGetReqInfo(pAsync->hIpp, &ri);

            Spl_IppJobRsp(pECB, wReq, &ri, pAsync->lpbRet);

            Spl_EndSession(pECB);

            bRet = TRUE;  // We must return HSE_STATUS_PENDING if we call
                          // HSE_REQ_DONE_WITH_SESSION
        }


        // Free our async-structure.  This indirectly frees the
        // return buffer as well.
        //
        Spl_FreeAsync(pAsync);

    } else {

        ClosePrinter(hPrinter);
    }

    return (bRet ? HSE_STATUS_PENDING : HSE_STATUS_ERROR);
}


/*****************************************************************************
 * Spl_IppJobSync
 *
 * This routine processes the job as a synchronous-read.  This implies that
 * our entire job made it in one-post, and thus doesn't need to perform
 * any reads.
 *
 *****************************************************************************/
DWORD Spl_IppJobSync(
    LPEXTENSION_CONTROL_BLOCK pECB,
    WORD                      wReq,
    LPCTSTR                   lpszShare,
    HANDLE                    hPrinter)
{
    HANDLE       hIpp;
    LPIPPRET_JOB pj;
    REQINFO      ri;
    LPBYTE       lpbRet = NULL;
    BOOL         bRet   = FALSE;


    // Initialize request structure.
    //
    ZeroMemory(&ri, sizeof(REQINFO));
    ri.idReq     = 0;
    ri.cpReq     = CP_UTF8;
    ri.pwlUns    = NULL;
    ri.bFidelity = FALSE;

    ri.fReq[0] = IPP_REQALL;
    ri.fReq[1] = IPP_REQALL;

    // Open an IPP-Receive channel and call the routine to process
    // the job.
    //
    if (hIpp = WebIppRcvOpen(wReq)) {

        bRet = Spl_IppJobData(pECB,
                              wReq,
                              hPrinter,
                              lpszShare,
                              hIpp,
                              pECB->lpbData,
                              pECB->cbAvailable,
                              &lpbRet);

        WebIppGetReqInfo(hIpp, &ri);
    }


    // Send the job-response back to the client.  If we weren't able
    // to open an IPP-Receive handle, or our job-processing failed,
    // then our error is FALSE.
    //
    bRet = Spl_IppJobRsp(pECB, wReq, &ri, lpbRet);


    // Free up the receive-handle only after the response.  We need to
    // insure the integrity of the unsupported-list-handle.
    //
    if (hIpp)
        WebIppRcvClose(hIpp);


    // Close the printer-handle.  We do this here as oppose to in
    // (msw3prt.cxx), since if we had performed asynchronous reads
    // we would need to leave the scope the HttpExtensionProc() call.
    //
    // NOTE: CloseJob() closes the printer-handle.  Only in the case
    //       where we were not able to open a job should we close it
    //       here.
    //
    pj = (LPIPPRET_JOB)lpbRet;

    if((wReq == IPP_REQ_PRINTJOB) && pj && pj->bRet) {

        CloseJob((DWORD)pj->bRet);

    } else {

        ClosePrinter(hPrinter);
    }


    // Free our return-structure.
    //
    if (lpbRet)
        WebIppFreeMem(lpbRet);

    return (bRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR);
}


/*****************************************************************************
 * SplIppJob
 *
 * Process the IPP Job Request.
 *
 * Get the print-job.  If we can't handle the entire post within this
 * scope, then we setup for asynchronous reads.
 *
 *****************************************************************************/
DWORD SplIppJob(
    WORD             wReq,
    PALLINFO         pAllInfo,
    PPRINTERPAGEINFO pPageInfo)
{
    DWORD dwRet;


    // If our bytes aren't contained in one-chunk, then
    // we need to start an asynchronous read.
    //
    // Otherwise, if our available amounts to the total-bytes
    // of the job, then we can process the entire command sychronousely.
    //
    if (pAllInfo->pECB->cbAvailable < pAllInfo->pECB->cbTotalBytes) {

        dwRet = Spl_IppJobAsync(pAllInfo->pECB,
                                wReq,
                                pPageInfo->pPrinterInfo->pShareName,
                                pPageInfo->hPrinter);
    } else {

        dwRet = Spl_IppJobSync(pAllInfo->pECB,
                               wReq,
                               pPageInfo->pPrinterInfo->pShareName,
                               pPageInfo->hPrinter);
    }

    return dwRet;
}


/*****************************************************************************
 * OpenJob
 *
 * Starts a job.  This creates a new spool-job-entry, the returns a jobid.
 *
 *
 *****************************************************************************/
DWORD OpenJob(
    IN  LPEXTENSION_CONTROL_BLOCK pECB,
    IN  HANDLE                    hPrinter,
    IN  PIPPREQ_PRTJOB            pipr,
    IN  DWORD                     dwSize,
    OUT PINIJOB                   *ppCopyIniJob)
{
    PINIJOB   pIniJob;
    DWORD     JobId = 0;
    LS_HANDLE hLicense;


    if ((NULL == hPrinter) || (NULL == pipr) || (dwSize < sizeof(IPPREQ_PRTJOB)))
        return 0;


    if( RequestLicense( &hLicense, pECB )) {    // Enforce the Client Access Licensing

        if (pIniJob = (PINIJOB)AllocSplMem(sizeof(INIJOB))) {

            DWORD      dwNeeded;
            DOC_INFO_1 di = {0, 0, 0};

            ZeroMemory( pIniJob, sizeof(INIJOB) );  // This ensures that unset fields are NULL

            pIniJob->signature = IJ_SIGNATURE;
            pIniJob->cb        = sizeof(INIJOB);
            pIniJob->hLicense  = hLicense;


            di.pDocName = pipr->pDocument;


            if (JobId = StartDocPrinter(hPrinter, 1, (LPBYTE)&di)) {

                // we successfully add a job to spooler
                //
                pIniJob->JobId = JobId;

                // keep the hPrinter until CloseJob
                //
                pIniJob->hPrinter = hPrinter;

                pIniJob->dwStartTime = GetCurrentMinute();
                pIniJob->dwStatus    = JOB_READY;
                pIniJob->pECB        = pECB;


                if (ppCopyIniJob)
                // Allocate and copy the new ppIniJob structure out, some of the elements
                // will be null
                    if (*ppCopyIniJob = (PINIJOB)AllocSplMem( sizeof(INIJOB) ) )
                        CopyMemory( *ppCopyIniJob, pIniJob, sizeof(INIJOB) );

                AddJobEntry(pIniJob);

            } else {

                // StartDocPrinter Failed
                //
                DBGMSG(DBG_WARN, ("StartDocPrinter Failed %d\n", GetLastError()));

                FreeSplMem(pIniJob, pIniJob->cb);

                FreeLicense( hLicense );
            }
        }
        else   // if alloc failed
            FreeLicense( hLicense );

    } else {         // if failed to update a license


        // Spl_IppJobRsp() will check for this and send down
        // proper error to the client.
        //
        SetLastError( ERROR_LICENSE_QUOTA_EXCEEDED );
    }


#ifdef DEBUG

    if (JobId)
        DBGMSG(DBG_INFO,("OpenJob : succeed, JobID == %d\r\n", JobId));
    else
        DBGMSG(DBG_WARN,("OpenJob : failed!\r\n"));
#endif

    // what is this for in the failure case ???
    //
    // AuthenticateUser(pAllInfo);
    //


    return JobId;
}


/*****************************************************************************
 * WriteJob
 *
 * Write the job.
 *
 *****************************************************************************/
BOOL WriteJob(
    DWORD   JobId,
    LPBYTE  pBuf,
    DWORD   dwSize,
    LPDWORD pWritten)
{
    PINIJOB pIniJob;
    BOOL    bRet = FALSE;

    if (pIniJob = FindJob(JobId, JOB_BUSY))
    {
        bRet = WritePrinter(pIniJob->hPrinter, pBuf, dwSize, pWritten);
        pIniJob->dwStatus = JOB_READY;
        return bRet;
    }

    return FALSE;
}


/*****************************************************************************
 * CloseJob
 *
 * Close job and remove from the list.
 *
 *****************************************************************************/
BOOL CloseJob(
    DWORD JobId)
{
    PINIJOB pIniJob;
    BOOL    ret = FALSE;

    if (pIniJob = FindJob(JobId, JOB_BUSY)) {

        ret = EndDocPrinter(pIniJob->hPrinter);

        ClosePrinter(pIniJob->hPrinter);

        DeleteJobEntry(pIniJob);

        // CleanupOldJob needs to do the same to take care of orphan Async jobs.
        FreeLicense( pIniJob->hLicense );

        FreeSplMem(pIniJob, pIniJob->cb);
    }

    return ret;
}


/*****************************************************************************
 * DeleteJob
 *
 * TBD : Unimplemented.
 *
 *****************************************************************************/
BOOL DeleteJob(
    DWORD JobId)
{
    return TRUE;
}


/*****************************************************************************
 * AddJobEntryToLinkList
 *
 * Add an entry from a double linked list
 *
 *****************************************************************************/

VOID AddJobEntryToLinkList(
    PINIJOB &pIniFirstJob,
    PINIJOB pIniJob)
{
    PINIJOB pIniJobTmp;

    pIniJob->pNext = NULL;
    pIniJob->pPrevious = NULL;

    if (!(pIniJobTmp = pIniFirstJob))
    {
        pIniFirstJob = pIniJob;
    }
    else
    {
        // add pIniJob to the end of the list

        for (; pIniJobTmp->pNext; pIniJobTmp = pIniJobTmp->pNext)
            ;

        pIniJob->pPrevious = pIniJobTmp;
        pIniJobTmp->pNext = pIniJob;
    }
}


/*****************************************************************************
 * DeleteJobEntryFromLinkList
 *
 * Delete an entry from a double linked list
 *
 *****************************************************************************/
VOID DeleteJobEntryFromLinkList(
    PINIJOB &pIniFirstJob,
    PINIJOB pIniJob)
{
    if (pIniJob->pPrevious)
        pIniJob->pPrevious->pNext = pIniJob->pNext;
    else
        // pIniJob must be the first job
        pIniFirstJob = pIniJob->pNext;

    if (pIniJob->pNext)
        pIniJob->pNext->pPrevious = pIniJob->pPrevious;
}

/*****************************************************************************
 * AddJobEntry
 *
 * I just use a simple double linked list for now.  Can be changed to
 * something else such as a hash table later, if desired.
 *
 *****************************************************************************/
VOID AddJobEntry(
    PINIJOB pIniJob)
{
    EnterSplSem();

    AddJobEntryToLinkList(pIniFirstJob, pIniJob);

    LeaveSplSem();
}


/*****************************************************************************
 * DeleteJobEntry
 *
 * Delete job from the job-list.
 *
 *****************************************************************************/
VOID DeleteJobEntry(
    PINIJOB pIniJob)
{
    EnterSplSem();

    DeleteJobEntryFromLinkList (pIniFirstJob, pIniJob);

    LeaveSplSem();
}



/*****************************************************************************
 *
 * FindJob
 *
 * Looks for job in the job-list and dwStatus
 *
 *****************************************************************************/
PINIJOB FindJob(
    DWORD JobId,
    DWORD dwStatus)
{
    PINIJOB pIniJob;

    EnterSplSem();

    // pIniJob will end up being NULL if a match is not found

    for (pIniJob = pIniFirstJob; pIniJob; pIniJob = pIniJob->pNext)
    {
        if (pIniJob->dwStatus == JOB_READY && pIniJob->JobId == JobId) {
            // found the match, break and return pIniJob
            // Set the status
            pIniJob->dwStatus = dwStatus;
            break;
        }
    }

    LeaveSplSem();

    return pIniJob;
}


/*****************************************************************************
 * CleanupOldJob
 *
 * This function is called by Sleeper->Work() about every 15 minutes to cleanup
 * the pending unclosed jobs due to the failure of the network or any other
 * possible reasons.
 *
 *****************************************************************************/
BOOL CleanupOldJob()
{
    DWORD           dwCurrentTime       = GetCurrentMinute();
    PINIJOB         pIniJob;
    PINIJOB         pIniTmpJob;
    PINIJOB         pIniFirstOldJob     = NULL;

    if (!pIniFirstJob) return TRUE;

    DBGMSG (DBG_WARN, ("Enter Cleanup...\r\n"));

    EnterSplSem();

    for (pIniJob = pIniFirstJob; pIniJob; pIniJob = pIniTmpJob) {
        pIniTmpJob = pIniJob->pNext;
        if (pIniJob->dwStatus == JOB_READY) {
            DWORD dwDiff = (1440 + dwCurrentTime - pIniJob->dwStartTime) % 1440;

            if (dwDiff > MAX_JOB_MINUTE) {
                DBGMSG (DBG_WARN, ("OldJob found %x\r\n", pIniJob->hPrinter));
                DeleteJobEntry (pIniJob);
                AddJobEntryToLinkList (pIniFirstOldJob, pIniJob);
            }
        }
    }

    LeaveSplSem();

    DWORD dwStatus =  HTTP_STATUS_REQUEST_TIMEOUT;

    // Delete the job outside the critical section
    for (pIniJob = pIniFirstOldJob; pIniJob; pIniJob = pIniTmpJob) {
        pIniTmpJob = pIniJob->pNext;
        EndDocPrinter(pIniJob->hPrinter);
        ClosePrinter(pIniJob->hPrinter);
        FreeLicense( pIniJob->hLicense );     // CleanupOldJob needs to do the same to take care of orphan Async jobs.


#ifdef ASYNC_READ_ENABLED

        // Disable it because we're not trying to manage the cleanup for
        // http sessions. If there is a session pending because we close
        // the job, the callback function (Spl_JobPrintCB)
        // will close the session itself.
        //
        pIniJob->pECB->ServerSupportFunction(pIniJob->pECB->ConnID,
                                             HSE_REQ_DONE_WITH_SESSION,
                                             &dwStatus,
                                             NULL,
                                             NULL);
#endif
        FreeSplMem(pIniJob, pIniJob->cb);
    }
    return TRUE;
}

/*****************************************************************************
 * GetCurrentMinute
 *
 * Get the current minute since midnight
 *
 *****************************************************************************/
DWORD GetCurrentMinute ()
{
    SYSTEMTIME CurTime;

    GetSystemTime (&CurTime);
    return CurTime.wHour * 60 + CurTime.wMinute;
}

#ifdef DEBUG

DWORD dwSplHeapSize = 0;

/*****************************************************************************
 * AllocSplMem (Helper)
 *
 * Routine Description:
 *
 *     This function will allocate local memory. It will possibly allocate extra
 *     memory and fill this with debugging information for the debugging version.
 *
 * Arguments:
 *
 *     cb - The amount of memory to allocate
 *
 * Return Value:
 *
 *     NON-NULL - A pointer to the allocated memory
 *
 *     FALSE/NULL - The operation failed. Extended error status is available
 *     using GetLastError.
 *
 *
 *****************************************************************************/
LPVOID AllocSplMem(
    DWORD cb)
{
    PDWORD  pMem;
    DWORD   cbNew;

    cbNew = cb+2*sizeof(DWORD);
    if (cbNew & 3)
        cbNew += sizeof(DWORD) - (cbNew & 3);

    pMem=(PDWORD)LocalAlloc(LPTR, cbNew);

    if (!pMem)
    {
        DBGMSG(DBG_ERROR, ("Memory Allocation failed for %d bytes\n", cbNew));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    *pMem=cb;
    *(PDWORD)((PBYTE)pMem+cbNew-sizeof(DWORD))=0xdeadbeef;

    dwSplHeapSize += cbNew;

    return (LPVOID)(pMem+1);
}


/*****************************************************************************
 * FreeSplMem (Helper)
 *
 *
 *****************************************************************************/
BOOL FreeSplMem(
    LPVOID pMem,
    DWORD  cb)
{
    DWORD   cbNew;
    LPDWORD pNewMem;

    if (!pMem)
        return FALSE;

    pNewMem = (LPDWORD)pMem;
    pNewMem--;

    cbNew = cb+2*sizeof(DWORD);
    if (cbNew & 3)
        cbNew += sizeof(DWORD) - (cbNew & 3);

    if (*pNewMem != cb) {
        DBGMSG(DBG_ERROR, ("Corrupt Memory Size in inetsrv-spool : %0lx %0lx != %0lx\n",
                           pNewMem, *pNewMem, cb));
        return FALSE;
    }

    if (*(LPDWORD)((LPBYTE)pNewMem + cbNew - sizeof(DWORD)) != 0xdeadbeef) {
        DBGMSG(DBG_ERROR, ("Memory Overrun in inetsrv-spool : %0lx\n", pNewMem));
        return FALSE;
    }

    LocalFree((LPVOID)pNewMem);

    dwSplHeapSize -= cbNew;

    return TRUE;
}

#endif // DEBUG


/*****************************************************************************
 * AllocSplStr (Helper)
 *
 * Routine Description:
 *
 *     This function will allocate enough local memory to store the specified
 *     string, and copy that string to the allocated memory
 *
 * Arguments:
 *
 *     pStr - Pointer to the string that needs to be allocated and stored
 *
 * Return Value:
 *
 *     NON-NULL - A pointer to the allocated memory containing the string
 *
 *     FALSE/NULL - The operation failed. Extended error status is available
 *     using GetLastError.
 *****************************************************************************/
LPTSTR AllocSplStr(
    LPCTSTR lpszStr)
{
    DWORD  cbSize;
    LPTSTR lpszCpy = NULL;


    if (cbSize = Spl_StrSize(lpszStr)) {

        if (lpszCpy = (LPTSTR)AllocSplMem(cbSize))
           StringCbCopy(lpszCpy, cbSize, lpszStr);
    }

    return lpszCpy;
}


/*****************************************************************************
 * FreeSplStr (Helper)
 *
 *
 *****************************************************************************/
#ifdef DEBUG
    #define FREE_PTR_TO_LONG(X) (X)
#else
    #define FREE_PTR_TO_LONG(X) (PtrToLong(X))
#endif

BOOL FreeSplStr(
   LPTSTR lpszStr)
{
   DWORD cbSize;

   cbSize = Spl_StrSize(lpszStr);

   return (BOOL)(lpszStr ? FREE_PTR_TO_LONG(FreeSplMem(lpszStr, cbSize)) : FALSE);
}


/*****************************************************************************
 * AuthenticateUser (Helper)
 *
 *
 *****************************************************************************/
BOOL AuthenticateUser(
    PALLINFO pAllInfo)
{
    // If we don't specify a header (szAuthHdr), and just submit a 401 error, IIS
    // would include (in the automatically generated header) what authenticaitons it is setup
    // to use (NTLM and/or Basic). So the client can pick the first one on the list and use it
    // (this is what IE does).
    //
    // Note: for NTLM to work, you need adirect socket connection. So it won't work across
    // firewalls (IIS admins are supposed to know this). Secure socket seems to do it though,
    // so for the new MS Proxy, it might be doable.
    //
    return Spl_CallSSF(pAllInfo->pECB,
                       HSE_REQ_SEND_RESPONSE_HEADER,
                       (LPVOID)"401 Authentication Required",
                       (LPDWORD)NULL,
                       (LPDWORD)NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\spool.h ===
/********
*
*  Copyright (c) 1996  Microsoft Corporation
*
*
*  Module Name  : spool.h
*
*  Abstract :
*
*     This module contains the prototypes for the spool.cpp file for
*		HTTP Printers Server Extension.
*
******************/

#ifndef _SPOOL_H
#define _SPOOL_H

// ----------------------------------------------------------------------
//
// GLOBAL EXTERNS
//
// ----------------------------------------------------------------------


// This structure defines the asynchronous-reads when processing large
// jobs.  This is used to track state-information during the job.
//
#define SPL_ASYNC_BUF  65535

typedef struct _SPLASYNC {

    WORD   wReq;        // Type of request processing.
    HANDLE hPrinter;    // Handle to printer.
    LPTSTR lpszShare;   // Sharename for printer (used in job-response).
    HANDLE hIpp;        // Handle to an Ipp-Stream-Processor.
    LPBYTE lpbBuf;      // Buffer which asynchronous reads are kept.
    DWORD  cbTotal;     // Total bytes to read for the job.
    DWORD  cbRead;      // Number of bytes accumulated during reads.
    DWORD  cbBuf;       // Size of our buffer (static size).
    LPBYTE lpbRet;      // Return-buffer based upon request.

} SPLASYNC, *PSPLASYNC, *LPSPLASYNC;



// ----------------------------------------------------------------------
//
// JOB FUNCTIONS
//
// ----------------------------------------------------------------------

// Structure for linked list we keep open job information in
typedef struct _INIJOB {
    DWORD       signature;
    DWORD       cb;
    struct _INIJOB  *pNext;
    struct _INIJOB  *pPrevious;

    DWORD       JobId;
    HANDLE      hPrinter;
    DWORD       dwFlags;
    DWORD       dwStatus;

    LS_HANDLE      hLicense;               // Client Access License Handle
    DWORD       dwStartTime;
    EXTENSION_CONTROL_BLOCK *pECB;              // Struct from ISAPI interface

} INIJOB, *PINIJOB;

#define IJ_SIGNATURE    0x494A  /* 'IJ' is the signature value */

#define MAX_JOB_MINUTE  15  // The maximum duration for a single job in spooler is 15 minutes


#define JOB_READY       0   // Job is ready for deleting or processing
#define JOB_BUSY        1   // Job is being processed by some thread

DWORD
OpenJob(
    IN  LPEXTENSION_CONTROL_BLOCK pECB,
    IN  HANDLE                    hPrinter,
    IN  PIPPREQ_PRTJOB            pipr,
    IN  DWORD                     dwSize,
    OUT PINIJOB                   *ppCopyIniJob = NULL
);

BOOL
WriteJob(
    DWORD JobId,
    LPBYTE pBuf,
    DWORD dwSize,
    LPDWORD pWritten
);

BOOL
CloseJob(
    DWORD JobId
);

BOOL
DeleteJob(
    DWORD JobId
);

VOID
AddJobEntry(
    PINIJOB     pIniJob
);

VOID
DeleteJobEntry(
    PINIJOB     pIniJob
);

PINIJOB
FindJob(
    DWORD JobId, DWORD dwStatus = JOB_READY
);

BOOL CleanupOldJob(void);
DWORD GetCurrentMinute (void);


// ----------------------------------------------------------------------
//
// Client Access Licensing FUNCTIONS
//
// ----------------------------------------------------------------------

BOOL RequestLicense(
    LS_HANDLE *phLicense,
    LPEXTENSION_CONTROL_BLOCK pECB
);

void FreeLicense(
    LS_HANDLE hLicense
);


// ----------------------------------------------------------------------
//
// Impersonation utilities
//
// ----------------------------------------------------------------------


HANDLE
RevertToPrinterSelf(
    VOID
);

BOOL
ImpersonatePrinterClient(
    HANDLE  hToken
);


// ----------------------------------------------------------------------
//
// HELPER FUNCTIONS
//
// ----------------------------------------------------------------------


#ifdef DEBUG

LPVOID
AllocSplMem(
    DWORD cb
);


BOOL
FreeSplMem(
   LPVOID pMem,
   DWORD  cb
);

#else

#define AllocSplMem(a)      LocalAlloc(LPTR, a)
#define FreeSplMem(a, b)    LocalFree(a)

#endif

LPTSTR
AllocSplStr(
    LPCTSTR lpStr
);

BOOL
FreeSplStr(
   LPTSTR lpStr
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\catalog.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    catalog.cxx

Abstract:

   This module provides all the public exported APIs relating to the
   catalog-based Spooler Apis for the Local Print Provider

       AddDriverCatalog

Author:

    Larry Zhu      (LZhu)    30-Mar-2001 Created

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "catalog.hxx"

#include <spapip.h>
#include "ssp.hxx"

/*++

Routine Name:

    LocalAddDriverCatalog

Routine Description:

    This routine implements the private print provider interface AddDriverCatalog.

Arguments:

    hPrinter              - This must be a server handle
    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    dwCatalogCopyFlags    - Catalog file copy flags

Return Value:

    A BOOL               - TRUE if success; FALSE otherwise, Call GetLastError()
                           to get the Error code

--*/
BOOL
LocalAddDriverCatalog(
    IN     HANDLE      hPrinter,
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     DWORD       dwCatalogCopyFlags
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = hPrinter && pvDriverInfCatInfo ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval = SplAddDriverCatalog(hPrinter,
                                      dwLevel,
                                      pvDriverInfCatInfo,
                                      dwCatalogCopyFlags) ? S_OK : GetLastErrorAsHResult();
    }

    if (FAILED(hRetval))
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return SUCCEEDED(hRetval);
}

/*++

Routine Name:

    SplAddDriverCatalog

Routine Description:

    This is the Spl call for AddDriverCatalog.

Arguments:

    hPrinter              - This must be a server handle
    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    dwCatalogCopyFlags    - Catalog file copy flags

Return Value:

    A BOOL               - TRUE if success; FALSE otherwise, Call GetLastError()
                           to get the Error code

--*/
BOOL
SplAddDriverCatalog(
    IN     HANDLE      hPrinter,
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     DWORD       dwCatalogCopyFlags
    )
{
    HRESULT hRetval = E_FAIL;
    SPOOL   *pSpool = reinterpret_cast<SPOOL*>(hPrinter);

    DBGMSG(DBG_TRACE, ("AddDriverCatalog\n"));

    hRetval = pSpool && (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) && pvDriverInfCatInfo ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        EnterSplSem();

        hRetval = ValidateSpoolHandle(pSpool, 0) ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            hRetval = ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                                           SERVER_ACCESS_ADMINISTER,
                                           NULL, NULL, pSpool->pIniSpooler) ? S_OK : GetLastErrorAsHResult();
        }

        if (SUCCEEDED(hRetval))
        {
            hRetval = InternalAddDriverCatalog(hPrinter,
                                               dwLevel,
                                               pvDriverInfCatInfo,
                                               dwCatalogCopyFlags) ? S_OK : GetLastErrorAsHResult();;
        }

        LeaveSplSem();
    }

    if (FAILED(hRetval))
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return SUCCEEDED(hRetval);
}

/*++

Routine Name:

    CatalogAppendUniqueTag

Routine Description:

    This routine makes the scratch directory unique w.r.t process id and thread
    id that executes this function.

Arguments:

    cchBuffer      - size of buffer in number of chars including the NULL
                     terminating character
    pszBuffer      - Points to the buffer


Return Value:

    An HRESULT

--*/
HRESULT
CatalogAppendUniqueTag(
    IN     UINT        cchBuffer,
    IN OUT PWSTR       pszBuffer
    )
{
    HRESULT hRetval = E_FAIL;
    DWORD   dwPID   = 0;
    DWORD   dwTID   = 0;
    DWORD   cchLen  = 0;

    hRetval = pszBuffer && cchBuffer ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        cchLen = wcslen(pszBuffer);
        dwPID = GetCurrentProcessId();
        dwTID = GetCurrentThreadId();

        if ((pszBuffer[cchLen - 1] != L'\\') && (cchLen + 1 < cchBuffer - 1))
        {
            pszBuffer[cchLen++] = L'\\';
            pszBuffer[cchLen]   = 0;
        }

        hRetval = cchBuffer > cchLen && SUCCEEDED(StringCchPrintf(pszBuffer + cchLen, cchBuffer - cchLen, L"%d_%d", dwPID, dwTID)) ? S_OK : HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogGetScratchDirectory

Routine Description:

    This routine returns the catalog scratch directory.

Arguments:

    hPrinter        - Server handle
    cchBuffer       - Size of buffer in number of chars including the NULL
                      character
    pszCatalogDir   - Points to the buffer


Return Value:

    An HRESULT

--*/
HRESULT
CatalogGetScratchDirectory(
    IN     HANDLE      hPrinter,
    IN     UINT        cchBuffer,
       OUT PWSTR       pszCatalogDir
    )
{
    HRESULT hRetval  = E_FAIL;
    DWORD   dwNeeded = 0;

    hRetval = hPrinter && cchBuffer && pszCatalogDir ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval = SplGetPrinterDriverDirectory(NULL,               // local machine
                                               LOCAL_ENVIRONMENT,
                                               1,
                                               reinterpret_cast<BYTE*>(pszCatalogDir),
                                               cchBuffer * sizeof(WCHAR),
                                               &dwNeeded,
                                               reinterpret_cast<SPOOL*>(hPrinter)->pIniSpooler) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = CatalogAppendUniqueTag(cchBuffer, pszCatalogDir);
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogCopyFile

Routine Description:

    This routine copies the catalog file to the scratch directory.

Arguments:

    pszSourcePath      - Source Path
    pszDestDir         - Destination directory
    pszFileName        - File name

Return Value:

    An HRESULT

--*/
HRESULT
CatalogCopyFile(
    IN     PCWSTR      pszSourcePath,
    IN     PCWSTR      pszDestDir,
    IN     PCWSTR      pszFileName
    )
{
    HRESULT hRetval          = E_FAIL;
    WCHAR   szPath[MAX_PATH] = {0};

    hRetval = pszSourcePath && pszDestDir && pszFileName ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval = SUCCEEDED(StringCchPrintf(szPath, COUNTOF(szPath), L"%s\\%s", pszDestDir, pszFileName)) ? S_OK : HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = CopyFile(pszSourcePath, szPath, FALSE) ? S_OK : GetLastErrorAsHResult();
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogCreateScratchDirectory

Routine Description:

    This routine creates the catalog scratch directory. If the scratch
    directory already exists, this routine does nothing

Arguments:

    pszScratchDir       - Scratch directory

Return Value:

    An HRESULT

--*/
HRESULT
CatalogCreateScratchDirectory(
    IN     PCWSTR      pszScratchDir
    )
{

    HRESULT hRetval = E_FAIL;

    hRetval = pszScratchDir ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval) && !DirectoryExists(const_cast<PWSTR>(pszScratchDir)))
    {
        hRetval = CreateDirectoryWithoutImpersonatingUser(const_cast<PWSTR>(pszScratchDir)) ? S_OK : GetLastErrorAsHResult();
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogCleanUpScratchDirectory

Routine Description:

    This routine cleans up the scratch directory and it does nothing when the
    scratch directory does not exist.

Arguments:

    pszScratchDir - Scratch Path

Return Value:

    An HRESULT

--*/
HRESULT
CatalogCleanUpScratchDirectory(
    IN     PCWSTR      pszScratchDir
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = pszScratchDir ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        (void)DeleteAllFilesAndDirectory(const_cast<PWSTR>(pszScratchDir),
                                         FALSE);
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogCopyFileToDir

Routine Description:

    This routine copy catalog files to a directory.

Arguments:

    pszPath               - Source Path
    pszDir                - Destination directory

Return Value:

    An HRESULT

--*/
CatalogCopyFileToDir(
    IN     PCWSTR      pszPath,
    IN     PCWSTR      pszDir
    )
{
    HRESULT hRetval     = E_FAIL;
    PCWSTR  pszFileName = NULL;

    hRetval = pszPath && pszDir ? S_OK : E_FAIL;

    if (SUCCEEDED(hRetval))
    {
        hRetval = GetFileNamePart(pszPath, &pszFileName);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = CatalogCopyFile(pszPath, pszDir, pszFileName);
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogCopyFilesByLevel

Routine Description:

    This routine copy catalog files to a scratch directory.

Arguments:

    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    pszScratchDirectory   - Catalog Scratch directory

Return Value:

    An HRESULT

--*/
HRESULT
CatalogCopyFilesByLevel(
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     PCWSTR      pszScratchDirectory
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = pvDriverInfCatInfo && pszScratchDirectory? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        switch (dwLevel)
        {
        case 1:

            hRetval = CatalogCopyFileToDir(reinterpret_cast<DRIVER_INFCAT_INFO_1*>(pvDriverInfCatInfo)->pszCatPath,
                                           pszScratchDirectory);

            break;

        case 2:

            hRetval = CatalogCopyFileToDir(reinterpret_cast<DRIVER_INFCAT_INFO_2*>(pvDriverInfCatInfo)->pszCatPath,
                                           pszScratchDirectory);

            if (SUCCEEDED(hRetval))
            {
                hRetval = CatalogCopyFileToDir(reinterpret_cast<DRIVER_INFCAT_INFO_2*>(pvDriverInfCatInfo)->pszInfPath,
                                               pszScratchDirectory);
            }

            break;

        default:

            hRetval = HRESULT_FROM_WIN32(ERROR_INVALID_LEVEL);

            break;
        }
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogInstallLevel1

Routine Description:

    This routine installs driver catalog using CrypoAPI for level 1.

Arguments:

    pDriverInfCatInfo1    - Points to a DRIVER_INFCAT_INFO_1 structure
    pszScratchDirectory   - Catalog Scratch directory

Return Value:

    An HRESULT

--*/
HRESULT
CatalogInstallLevel1(
    IN     DRIVER_INFCAT_INFO_1  *pDriverInfCatInfo1,
    IN     BOOL                  bUseOriginalCatName,
    IN     PCWSTR                pszCatalogScratchDirectory
    )
{
    HRESULT hRetval          = E_FAIL;
    WCHAR   szPath[MAX_PATH] = {0};
    PCWSTR  pszFileName      = NULL;

    TSSP    ssp;

    hRetval = pDriverInfCatInfo1 && pszCatalogScratchDirectory ? S_OK : E_FAIL;

    if (SUCCEEDED(hRetval))
    {
        hRetval = ssp.IsValid();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = GetFileNamePart(pDriverInfCatInfo1->pszCatPath, &pszFileName);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = pszFileName && SUCCEEDED(StringCchPrintf(szPath, COUNTOF(szPath), L"%s\\%s", pszCatalogScratchDirectory, pszFileName)) ? S_OK : HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = ssp.VerifyCatalog(szPath);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = ssp.AddCatalogDirect(szPath,
                                       bUseOriginalCatName ? pszFileName : pDriverInfCatInfo1->pszCatNameOnSystem);
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogInstallLevel2

Routine Description:

    This routine installs driver catalog using setup api for level 2.

Arguments:

    pDriverInfCatInfo2     - Points to a DRIVER_INFCAT_INFO_2 structure
    pszScratchDirectory   - Catalog Scratch directory

Return Value:

    An HRESULT

--*/
HRESULT
CatalogInstallLevel2(
    IN     DRIVER_INFCAT_INFO_2  *pDriverInfCatInfo2,
    IN     PCWSTR                pszCatalogScratchDirectory
    )
{
    HRESULT hRetval                = E_FAIL;
    WCHAR   szPath[MAX_PATH]       = {0};
    PCWSTR  pszFileName            = NULL;
    BOOL    bIsSetupNonInteractive = TRUE;

    hRetval = pDriverInfCatInfo2 && pszCatalogScratchDirectory ? S_OK : E_FAIL;

    if (SUCCEEDED(hRetval))
    {
        hRetval = GetFileNamePart(pDriverInfCatInfo2->pszInfPath, &pszFileName);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = pszFileName && SUCCEEDED(StringCchPrintf(szPath, COUNTOF(szPath), L"%s\\%s", pszCatalogScratchDirectory, pszFileName)) ? S_OK : HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = CatalogCopyOEMInf(szPath,
                                    pDriverInfCatInfo2->pszSrcLoc,
                                    pDriverInfCatInfo2->dwMediaType,
                                    pDriverInfCatInfo2->dwCopyStyle);
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogCopyOEMInf

Routine Description:

    This routine installs driver catalog using setup api for level 2.

Arguments:

    pszInfPath            - Inf Path
    pszSrcLoc             - Source location string
    dwMediaType           - Media type, aka whether is WU/URL, or disk location
    dwCopyStyle           - SetupCopyOEMInf CopyStyle

Return Value:

    An HRESULT

--*/
HRESULT
CatalogCopyOEMInf(
    IN     PCWSTR      pszInfPath,
    IN     PCWSTR      pszSrcLoc,      OPTIONAL
    IN     DWORD       dwMediaType,
    IN     DWORD       dwCopyStyle
    )
{
    HRESULT hRetval  = E_FAIL;
    HMODULE hLibrary = NULL;

    PFuncSetupCopyOEMInfW pfnSetupCopyOEMInfW = NULL;
    PFuncpSetupModifyGlobalFlags pfnpSetupModifyGlobalFlags = NULL;

    hRetval = pszInfPath ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hLibrary = LoadLibrary(L"setupapi.dll");
        hRetval = hLibrary ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        pfnSetupCopyOEMInfW = reinterpret_cast<PFuncSetupCopyOEMInfW>(GetProcAddress(hLibrary, "SetupCopyOEMInfW"));

        hRetval = pfnSetupCopyOEMInfW ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        pfnpSetupModifyGlobalFlags = reinterpret_cast<PFuncpSetupModifyGlobalFlags>(GetProcAddress(hLibrary, "pSetupModifyGlobalFlags"));

        hRetval = pfnpSetupModifyGlobalFlags ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        //
        //  Prohibit all UIs and pSetupModifyGlobalFlags can not fail
        //
        (void)pfnpSetupModifyGlobalFlags(PSPGF_NONINTERACTIVE, PSPGF_NONINTERACTIVE);

        hRetval = pfnSetupCopyOEMInfW(pszInfPath,
                                      pszSrcLoc,
                                      dwMediaType,
                                      dwCopyStyle,
                                      NULL, 0, 0, NULL) ? S_OK : GetLastErrorAsHResult();
    }

    if (hLibrary)
    {
        (void)FreeLibrary(hLibrary);
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogInstallByLevel

Routine Description:

    This routine installs driver catalog using CrypoAPI for level 1 and using
    setup api for level 2.

Arguments:

    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    dwCatalogCopyFlags    - Catalog file copy flags
    pszScratchDirectory   - Catalog Scratch directory

Return Value:

    An HRESULT

--*/
HRESULT
CatalogInstallByLevel(
    IN     DWORD      dwLevel,
    IN     VOID       *pvDriverInfCatInfo,
    IN     DWORD      dwCatalogCopyFlags,
    IN     PCWSTR     pszCatalogScratchDirectory
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = pvDriverInfCatInfo && pszCatalogScratchDirectory? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        switch (dwLevel)
        {
        case 1:

            hRetval = CatalogInstallLevel1(reinterpret_cast<DRIVER_INFCAT_INFO_1*>(pvDriverInfCatInfo),
                                           dwCatalogCopyFlags & APDC_USE_ORIGINAL_CAT_NAME,
                                           pszCatalogScratchDirectory);

            break;

        case 2:

            hRetval = CatalogInstallLevel2(reinterpret_cast<DRIVER_INFCAT_INFO_2*>(pvDriverInfCatInfo),
                                           pszCatalogScratchDirectory);

            break;

        default:

            hRetval = HRESULT_FROM_WIN32(ERROR_INVALID_LEVEL);

            break;
        }
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogInstall

Routine Description:

    This routine installs driver catalog.

Arguments:

    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    pszScratchDirectory   - Catalog Scratch directory
    dwCatalogCopyFlags    - Catalog file copy flags

Return Value:

    An HRESULT

--*/
HRESULT
CatalogInstall(
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     DWORD       dwCatalogCopyFlags,
    IN     PCWSTR      pszScratchDirectory
    )
{
    HRESULT hRetval = E_FAIL;
    HANDLE  hToken  = NULL;

    hRetval = pvDriverInfCatInfo && pszScratchDirectory? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval = CatalogCopyFilesByLevel(dwLevel, pvDriverInfCatInfo, pszScratchDirectory);
    }

    if (SUCCEEDED(hRetval))
    {
        hToken = RevertToPrinterSelf();

        hRetval = CatalogInstallByLevel(dwLevel, pvDriverInfCatInfo, dwCatalogCopyFlags, pszScratchDirectory);
    }

    if (hToken)
    {
        (void)ImpersonatePrinterClient(hToken);
    }

    return hRetval;
}

/*++

Routine Name:

    InternalAddDriverCatalog

Routine Description:

    This routine implements the private print provider interface AddDriverCatalog.

Arguments:

    hPrinter              - This must be a server handle
    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    dwCatalogCopyFlags    - Catalog file copy flags

Return Value:

    A BOOL                - TRUE if success; FALSE otherwise, Call GetLastError()
                            to get the Error code

--*/
BOOL
InternalAddDriverCatalog(
    IN     HANDLE      hPrinter,
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     DWORD       dwCatalogCopyFlags
    )
{
    HRESULT hRetval                             = E_FAIL;
    WCHAR   szCatalogScratchDirectory[MAX_PATH] = {0};

    hRetval = hPrinter && pvDriverInfCatInfo ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    //
    // When in system context, we may not have permission to read the catalog
    // file, so we copy it to a scratch directory while still in impersonation
    // context
    //
    if (SUCCEEDED(hRetval))
    {
        hRetval = CatalogGetScratchDirectory(hPrinter, COUNTOF(szCatalogScratchDirectory), szCatalogScratchDirectory);

        if (FAILED(hRetval) && ERROR_INSUFFICIENT_BUFFER == HRESULT_CODE(hRetval))
        {
            hRetval = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
        }
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = CatalogCreateScratchDirectory(szCatalogScratchDirectory);

        if (SUCCEEDED(hRetval))
        {
            hRetval = CatalogInstall(dwLevel, pvDriverInfCatInfo, dwCatalogCopyFlags, szCatalogScratchDirectory);
        }

        (void)CatalogCleanUpScratchDirectory(szCatalogScratchDirectory);
    }

    if (FAILED(hRetval))
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return SUCCEEDED(hRetval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\addjob.c ===
/*++

Copyright (c) 1990-1994 Microsoft Corporation

Module Name:

    addjob.c


Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor. This module contains
    LocalSpl's implementation of the following spooler apis

    LocalAddJob
    LocalScheduleJob


Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Rewritten both apis -- Krishna Ganugapati (KrishnaG) 5-Apr-1994
    RapidPrint -- Matthew A Felton (mattfe) June 1994

--*/

#include <precomp.h>
#pragma hdrstop

#include "jobid.h"
#include "winsprlp.h"
#include "filepool.hxx"

VOID
AddJobEntry(
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob
);


BOOL
LocalAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PINIPRINTER pIniPrinter;
    PINIJOB     pIniJob;
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    DWORD       cb;
    WCHAR       szFileName[MAX_PATH];
    LPBYTE      pEnd;
    DWORD       LastError=0;
    LPADDJOB_INFO_1 pAddJob = (LPADDJOB_INFO_1)pData;
    DWORD       NextId;
    BOOL        bRemote = FALSE;
    DOC_INFO_1 DocInfo1;
    BOOL        bRet;
    DWORD       dwStatus = 0;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    LPWSTR      pMachineName = NULL;
    LPWSTR      pszSpoolFile = NULL;
    PMAPPED_JOB pMappedJob = NULL;
    SIZE_T      FileNameLength = 0;

    SplOutSem();

    switch( Level ){
    case 1:
        break;

    case 2:
    case 3:
        pMachineName = (LPWSTR)( ((PBYTE)pData) +
                                 (ULONG_PTR)((PADDJOB_INFO_2W)pData)->pData );

        //
        // Validate string.
        //
        if( pMachineName > (LPWSTR)( ((PBYTE)pData)+cbBuf )){
            SetLastError( ERROR_INVALID_LEVEL );
            return FALSE;
        }

        //
        // Ensure NULL termination.
        //
        *(PWCHAR)(((ULONG_PTR)(pData + cbBuf - sizeof( WCHAR ))&~1)) = 0;
        break;

    default:
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

   //
   // memset docinfo
   //

   memset((LPBYTE)&DocInfo1, 0, sizeof(DOC_INFO_1));

   //
   // Figure out whether the job is a remote or local job
   //
   {
       HRESULT hRes = CheckLocalCall();

       if (hRes == S_FALSE)
       {
           bRemote = TRUE;
       }
       else if (hRes != S_OK)
       {
           SetLastError(SCODE_CODE(hRes));
           return FALSE;
       }
   }

   //
   // Get the name of the user
   //

   if (bRemote) {
       DocInfo1.pDocName = szRemoteDoc;
   } else{
       DocInfo1.pDocName = szLocalDoc;
   }


   EnterSplSem();

   //
   // We should not be calling addjob on a Job Handle.
   //
   if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER | PRINTER_HANDLE_JOB )) {
       LeaveSplSem();
       return(FALSE);
   }

   //
   // We're interested if this is a remote call (not if it was opened
   // via \\server\remote).  The server process does this.
   //
   if (pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL) {
       LeaveSplSem();
       SetLastError(ERROR_INVALID_PARAMETER);
       return(FALSE);
   }

   if (pSpool->TypeofHandle & PRINTER_HANDLE_PORT) {
       if (pSpool->pIniPort->Status & PP_MONITOR) {
           LeaveSplSem();
           SetLastError(ERROR_INVALID_PARAMETER);
           return(FALSE);
       } else {

           //
           // If we had level == 2 (passing in the computer name), then
           // convert back down to level 1 for old print providers.
           // We don't need to fix up the structure since level 1 and 2
           // are identical; it's just that level 2 is an in-out buffer.
           //
           //
           if (Level == 2 || Level == 3) {
               Level = 1;
           }

           //
           // This is the "Local Printer masquerading as a Remote  Printer"
           //
           LeaveSplSem();
           bRet = AddJob(pSpool->hPort, Level,  pData, cbBuf, pcbNeeded);

           if(bRet)
           {
               EnterSplSem();
               pSpool->Status |= SPOOL_STATUS_ADDJOB;
               LeaveSplSem();
           }

           return(bRet);
       }
   }

   pIniPrinter = pSpool->pIniPrinter;

   SPLASSERT(pIniPrinter);

   if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) {
       LeaveSplSem();
       SetLastError(ERROR_INVALID_ACCESS);
       return(FALSE);
   }

   //
   // Disallow EMF if PRINTER_ATTRIBUTE_RAW_ONLY is set.
   //
   if( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_RAW_ONLY ){

       LPWSTR pszDatatype = pSpool->pDatatype ?
                                pSpool->pDatatype :
                                pIniPrinter->pDatatype;

       if( !ValidRawDatatype( pszDatatype )){
           LeaveSplSem();
           SetLastError( ERROR_INVALID_DATATYPE );
           return FALSE;
       }
   }

   NextId = GetNextId( pIniPrinter->pIniSpooler->hJobIdMap );

   GetFullNameFromId(pIniPrinter, NextId, TRUE, szFileName, COUNTOF(szFileName), pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL);
   cb = wcslen(szFileName)*sizeof(WCHAR) + sizeof(WCHAR) +
            sizeof(ADDJOB_INFO_1);

   *pcbNeeded = cb;
   if (cb > cbBuf) {

       // Freeup the JobId.
       vMarkOff( pIniPrinter->pIniSpooler->hJobIdMap, NextId);
       LeaveSplSem();
       SetLastError(ERROR_INSUFFICIENT_BUFFER);
       return(FALSE);
   }

   //
   // WMI Trace Event
   //
   LeaveSplSem();

   LogWmiTraceEvent(NextId, EVENT_TRACE_TYPE_SPL_SPOOLJOB, NULL);

   EnterSplSem();

   SplInSem();


   dwStatus = JOB_SPOOLING | JOB_TYPE_ADDJOB;
   if (Level == 2 || Level ==3) {
       dwStatus |= JOB_DOWNLEVEL;
   }
   if ((pIniJob = CreateJobEntry(pSpool,
                                 1,
                                 (LPBYTE)&DocInfo1,
                                 NextId,
                                 bRemote,
                                 dwStatus,
                                 pMachineName)) == NULL) {

       //
       // Free up the JobId.
       //
       vMarkOff( pIniPrinter->pIniSpooler->hJobIdMap, NextId);
       DBGMSG(DBG_WARNING,("Error: CreateJobEntry failed in LocalAddJob\n"));
       LeaveSplSem();
       return(FALSE);
   }

   //
   // Level 3 is called only by RDR/SRV. For details see LocalScheduleJob
   //
   pIniJob->AddJobLevel = Level;

   pIniPrinter->cSpooling++;
   if (pIniPrinter->cSpooling > pIniPrinter->cMaxSpooling) {
       pIniPrinter->cMaxSpooling = pIniPrinter->cSpooling;
   }

   AddJobEntry(pIniPrinter, pIniJob);

   pEnd = (LPBYTE)pAddJob+cbBuf;

   FileNameLength = (wcslen(szFileName) + 1)*sizeof(WCHAR);

   pEnd -= FileNameLength;
   WORD_ALIGN_DOWN(pEnd);

   //
   // This is OK because we have already checked that the buffer is long enough
   // to contain this string. Completely reworking this function now is too risky.
   //
   StringCchCopy((LPWSTR)pEnd, FileNameLength, szFileName);
   pAddJob->Path = (LPWSTR)pEnd;
   pAddJob->JobId = pIniJob->JobId;

   //
   // Now we want to add the job into the spools list of current jobs.
   // This is so that the spool file can be deleted correctly at the end
   // of the job, even if we have aborted.
   //
   pMappedJob = AllocSplMem(sizeof(MAPPED_JOB));

   pszSpoolFile = AllocSplMem(MAX_PATH * sizeof( WCHAR ));

   if (pMappedJob && pszSpoolFile)
   {
       BOOL bDuplicate = FALSE;
       DWORD TempJobId = pIniJob->JobId;
       PMAPPED_JOB pTempMappedJob;

       StringCchCopy(pszSpoolFile, MAX_PATH, szFileName);

       //
       // Run through the list and make sure we have no duplicates.
       // It is not at all obvious why this would ever be the case.
       //
       for (pTempMappedJob = pSpool->pMappedJob;
            pTempMappedJob;
            pTempMappedJob = pTempMappedJob->pNext) {

            if (pTempMappedJob->JobId == TempJobId) {

                //
                // Set the mapped job to record that it was added with AddJob.
                //
                pTempMappedJob->fStatus |=  kMappedJobAddJob;

                bDuplicate = TRUE;
                break;
           }
       }

       //
       // No duplicates, add this job to the linked list.
       //
       if (!bDuplicate) {

           pMappedJob->pszSpoolFile = pszSpoolFile;
           pMappedJob->fStatus = kMappedJobAddJob;
           pMappedJob->JobId = TempJobId;
           pMappedJob->pNext = pSpool->pMappedJob;
           pSpool->pMappedJob = pMappedJob;

       } else {

           FreeSplMem(pszSpoolFile);
           FreeSplMem(pMappedJob);
       }

   }
   else
   {
       FreeSplMem(pMappedJob);
       FreeSplMem(pszSpoolFile);
   }

   //
   //
   // Storing pIniJob in pSpool is bogus since you can call AddJob multiple
   // times.  We should have a linked list here.  If the client calls AddJob
   // two times then closes the handle (no ScheduleJob), then only the last
   // job is rundown and eliminated.
   //
   // This bug has been here since 3.1, and probably isn't worth fixing.
   //
   pSpool->pIniJob = pIniJob;
   pSpool->Status |= SPOOL_STATUS_ADDJOB;

   SetPrinterChange(pSpool->pIniPrinter,
                    pIniJob,
                    NVAddJob,
                    PRINTER_CHANGE_ADD_JOB | PRINTER_CHANGE_SET_PRINTER,
                    pSpool->pIniSpooler );

   //
   //  If necessary Start Downlevel Size Detection thread
   //

   CheckSizeDetectionThread();

   LeaveSplSem();
   SplOutSem();
   return TRUE;
}

BOOL
LocalScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId)

/*++

Routine Description:


Arguments:


Returns:

--*/
{
    PSPOOL  pSpool=(PSPOOL)hPrinter;
    WCHAR szFileName[MAX_PATH];
    PINIJOB pIniJob;
    DWORD   Position;
    DWORD   LastError = FALSE;
    HANDLE  hPort;
    BOOL    bRet;
    NOTIFYVECTOR NotifyVector;
    WIN32_FILE_ATTRIBUTE_DATA FileAttributeData;
    PMAPPED_JOB pMappedJob = NULL;

    COPYNV(NotifyVector, NVJobStatus);

    //
    // WMI Trace Event.
    //
    LogWmiTraceEvent(JobId, EVENT_TRACE_TYPE_SPL_TRACKTHREAD, NULL);

    SplOutSem();
    EnterSplSem();

    //
    // We should not be calling schedulejob on a Job Handle.
    //
    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER | PRINTER_HANDLE_JOB )) {
        LeaveSplSem();
        return (FALSE);
    }

    if (pSpool->Status & SPOOL_STATUS_STARTDOC) {
        SetLastError(ERROR_SPL_NO_ADDJOB);
        LeaveSplSem();
        return(FALSE);
    }

    if (pSpool->TypeofHandle & PRINTER_HANDLE_PORT) {
        if (pSpool->pIniPort->Status & PP_MONITOR) {
            SetLastError(ERROR_INVALID_ACCESS);
            LeaveSplSem();
            return(FALSE);
        }

        //
        // This is the "Local Printer masquerading as the Network Printer"
        //
        hPort = pSpool->hPort;
        LeaveSplSem();
        bRet = ScheduleJob(hPort, JobId);
        return(bRet);
    }

    if ((pIniJob = FindJob(pSpool->pIniPrinter, JobId, &Position)) == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        LeaveSplSem();
        return(FALSE);

    }

    if (pIniJob->Status & JOB_SCHEDULE_JOB) {

        DBGMSG(DBG_WARNING, ("ScheduleJob: job 0x%x (id = %d) already scheduled\n",
                             pIniJob, pIniJob->JobId));

        SetLastError(ERROR_INVALID_PARAMETER);
        LeaveSplSem();
        return FALSE;
    }

    if (!(pIniJob->Status & JOB_TYPE_ADDJOB)) {

        DBGMSG(DBG_WARNING, ("ScheduleJob: job 0x%x (id = %d) no addjob\n",
                             pIniJob, pIniJob->JobId));

        SetLastError(ERROR_SPL_NO_ADDJOB);
        LeaveSplSem();
        return(FALSE);
    }

    //
    // Check to see whether this job was added with AddJob in the past on this
    // handle, if it was, then we can go ahead and schedule it. If it was not,
    // then we fail with Access denied.
    //
    for(pMappedJob = pSpool->pMappedJob; pMappedJob; pMappedJob = pMappedJob->pNext) {

        //
        // If we found the job on the same handle, clear the Addjob bit.
        //
        if (pMappedJob->JobId == JobId) {
            pMappedJob->fStatus &= ~kMappedJobAddJob;
            break;
        }
    }

    if (!pMappedJob) {
        SetLastError(ERROR_ACCESS_DENIED);
        LeaveSplSem();
        return FALSE;
    }

    InterlockedOr((LONG*)&(pIniJob->Status), JOB_SCHEDULE_JOB);

    if (pIniJob->Status  & JOB_SPOOLING) {
        InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_SPOOLING);
        pIniJob->pIniPrinter->cSpooling--;
    }

    if ( pIniJob->Status & JOB_TIMEOUT ) {
        InterlockedAnd((LONG*)&(pIniJob->Status), ~(JOB_TIMEOUT | JOB_ABANDON));
        FreeSplStr(pIniJob->pStatus);
        pIniJob->pStatus = NULL;
    }

    SplInSem();

    //
    // Despooling whilst spooling requires us to wake the writing
    // thread if it is waiting.
    //
    if ( pIniJob->WaitForWrite != NULL )
        SetEvent(pIniJob->WaitForWrite);

    //
    // Release any thread waiting on SeekPrinter for this job.
    //
    SeekPrinterSetEvent(pIniJob, NULL, TRUE);

    SPLASSERT(pIniJob->cRef != 0);

    DECJOBREF(pIniJob);

    DBGMSG(DBG_TRACE, ("ScheduleJob:cRef = %d\n", pIniJob->cRef));

    //
    // FP Change
    // For File pools, we know the Filename of the spool file, so
    // we can just copy it in.
    //
    if ( pIniJob->pszSplFileName )
    {
        StringCchCopy(szFileName, COUNTOF(szFileName), pIniJob->pszSplFileName);
    }
    else
    {
        GetFullNameFromId(pSpool->pIniPrinter, pIniJob->JobId, TRUE, szFileName, COUNTOF(szFileName), FALSE);
    }

    bRet = GetFileAttributesEx(szFileName,
                               GetFileExInfoStandard,
                               &FileAttributeData);

    //
    // According to MSDN: The ScheduleJob function checks for a valid spool file.
    // If there is an invalid spool file, or if it is empty, ScheduleJob deletes
    // both the spool file and the corresponding print job entry in the print spooler.
    //
    // The RDR/SRV will call AddJob even if the caller of CreateFile did noy request
    // WRITE access. This will cause us at add a job, but nobody will ever write to
    // the spooler file. In this case, we delete the job. For this reason we have
    // level 3 for AddJob. Level 3 is meant to be used only by RDR/SRV.
    //
    if (!bRet ||
        !(FileAttributeData.nFileSizeLow || FileAttributeData.nFileSizeHigh) && pIniJob->AddJobLevel == 3) {

        DBGMSG(DBG_WARNING, ("Could not GetFileAttributesEx %ws in ScheduleJob or file size is 0\n", szFileName));

        DeleteJob(pIniJob, BROADCAST);
        pSpool->pIniJob = NULL;
        pSpool->Status &= ~SPOOL_STATUS_ADDJOB;
        LeaveSplSem();

        //
        // If we deleted the job because the spool file was empty and the job came via RDR/SRV
        // In this case we return success.
        //
        if (bRet)
        {
            return TRUE;
        }

        //
        // We delete the job because the spool is not found
        //
        SetLastError(ERROR_SPOOL_FILE_NOT_FOUND);
        return(FALSE);
    }

    //
    // Do not accept spool files larger than 4GB
    //
    if (FileAttributeData.nFileSizeHigh && !ValidRawDatatype(pIniJob->pDatatype))
    {
        DeleteJob(pIniJob, BROADCAST);
        pSpool->pIniJob = NULL;
        pSpool->Status &= ~SPOOL_STATUS_ADDJOB;
        LeaveSplSem();

        SetLastError(ERROR_ARITHMETIC_OVERFLOW);
        return FALSE;
    }

    //
    // If size changed, we must update our size
    // and potentially notify people.
    //
    if (pIniJob->Size != FileAttributeData.nFileSizeLow) {
        ADDNV(NotifyVector, NVSpoolJob);
        pIniJob->Size = FileAttributeData.nFileSizeLow;
    }

    WriteShadowJob(pIniJob, FALSE);

    if (pIniJob->Status & JOB_PENDING_DELETION) {

        DBGMSG(DBG_TRACE, ("LocalScheduleJob: Deleting Job because its pending deletion\n"));
        DeleteJob(pIniJob, BROADCAST);

    } else {

        CHECK_SCHEDULER();

        SetPrinterChange(pIniJob->pIniPrinter,
                         pIniJob,
                         NotifyVector,
                         PRINTER_CHANGE_SET_JOB,
                         pIniJob->pIniPrinter->pIniSpooler );
    }

    pSpool->pIniJob = NULL;

    pSpool->Status &= ~SPOOL_STATUS_ADDJOB;

    LeaveSplSem();
    SplOutSem();
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\change.c ===
/*++

Copyright (c) 1993 - 1995  Microsoft Corporation

Abstract:

    This module provides the exported API WaitForPrinterChange,
    and the support functions internal to the local spooler.

Author:

    Andrew Bell (AndrewBe) March 1993

Revision History:

--*/


#include<precomp.h>


typedef struct _NOTIFY_FIELD_TABLE {
    WORD Field;
    WORD Table;
    WORD Offset;
} NOTIFY_FIELD_TYPE, *PNOTIFY_FIELD_TYPE;

//
// Translation table from PRINTER_NOTIFY_FIELD_* to bit vector
//
NOTIFY_FIELD_TYPE NotifyFieldTypePrinter[] = {
#define DEFINE(field, x, y, table, offset) \
    { PRINTER_NOTIFY_FIELD_##field, table, OFFSETOF(INIPRINTER, offset) },
#include <ntfyprn.h>
#undef DEFINE
    { 0, 0, 0 }
};

NOTIFY_FIELD_TYPE NotifyFieldTypeJob[] = {
#define DEFINE(field, x, y, table, offset) \
    { JOB_NOTIFY_FIELD_##field, table, OFFSETOF(INIJOB, offset) },
#include <ntfyjob.h>
#undef DEFINE
    { 0, 0, 0 }
};

typedef struct _NOTIFY_RAW_DATA {
    PVOID pvData;
    DWORD dwId;
} NOTIFY_RAW_DATA, *PNOTIFY_RAW_DATA;

//
// Currently we assume that the number of PRINTER_NOTIFY_FIELD_* elements
// will fit in one DWORD vector (32 bits).  If this is ever false,
// we need to re-write this code.
//
PNOTIFY_FIELD_TYPE apNotifyFieldTypes[NOTIFY_TYPE_MAX] = {
    NotifyFieldTypePrinter,
    NotifyFieldTypeJob
};

DWORD adwNotifyFieldOffsets[NOTIFY_TYPE_MAX] = {
    I_PRINTER_END,
    I_JOB_END
};

#define NOTIFY_FIELD_TOTAL (I_PRINTER_END + I_JOB_END)


//
// Common NotifyVectors used in the system.
// NV*
//
NOTIFYVECTOR NVPrinterStatus = {
    BIT(I_PRINTER_STATUS), // | BIT(I_PRINTER_STATUS_STRING),
    BIT_NONE
};

NOTIFYVECTOR NVPrinterSD = {
    BIT(I_PRINTER_SECURITY_DESCRIPTOR),
    BIT_NONE
};

NOTIFYVECTOR NVJobStatus = {
    BIT_NONE,
    BIT(I_JOB_STATUS)
};

NOTIFYVECTOR NVJobStatusAndString = {
    BIT_NONE,
    BIT(I_JOB_STATUS) | BIT(I_JOB_STATUS_STRING)
};

NOTIFYVECTOR NVJobStatusString = {
    BIT_NONE,
    BIT(I_JOB_STATUS_STRING)
};

NOTIFYVECTOR NVPurge = {
    BIT(I_PRINTER_STATUS),
    BIT_NONE,
};

NOTIFYVECTOR NVDeletedJob = {
    BIT(I_PRINTER_CJOBS),
    BIT(I_JOB_STATUS)
};

NOTIFYVECTOR NVAddJob = {
    BIT(I_PRINTER_CJOBS),
    BIT_ALL
};

NOTIFYVECTOR NVPrinterAll = {
    BIT_ALL,
    BIT_NONE
};

NOTIFYVECTOR NVSpoolJob = {
    BIT_NONE,
    BIT(I_JOB_TOTAL_BYTES) | BIT(I_JOB_TOTAL_PAGES)
};

NOTIFYVECTOR NVWriteJob = {
    BIT_NONE,
    BIT(I_JOB_BYTES_PRINTED) | BIT(I_JOB_PAGES_PRINTED)
};

NOTIFYVECTOR NVJobPrinted = {
    BIT_NONE,
    BIT(I_JOB_BYTES_PRINTED) | BIT(I_JOB_PAGES_PRINTED) | BIT(I_JOB_STATUS)
};


//
// Forward prototypes.
//
ESTATUS
ValidateStartNotify(
    PSPOOL pSpool,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PINIPRINTER* ppIniPrinter);

BOOL
SetSpoolChange(
    PSPOOL pSpool,
    PNOTIFY_RAW_DATA pNotifyRawData,
    PDWORD pdwNotifyVectors,
    DWORD  Flags);

BOOL
SetupNotifyOptions(
    PSPOOL pSpool,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions);

VOID
NotifyInfoTypes(
    PSPOOL pSpool,
    PNOTIFY_RAW_DATA pNotifyRawData,
    PDWORD pdwNotifyVectors,
    DWORD ChangeFlags);

BOOL
RefreshBuildInfoData(
    PSPOOL pSpool,
    PPRINTER_NOTIFY_INFO pInfo,
    UINT cInfo,
    WORD Type,
    PNOTIFY_RAW_DATA pNotifyRawData);



DWORD
LocalWaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   fdwFilterFlags)

/*++

Routine Description:

    This API may be called by an application if it wants to know
    when the status of a printer or print server changes.
    Valid events to wait for are defined by the PRINTER_CHANGE_* manifests.

Arguments:

    hPrinter - A printer handle returned by OpenPrinter.
               This may correspond to either a printer or a server.

    fdwFilterFlags - One or more PRINTER_CHANGE_* values combined.
               The function will return if any of these changes occurs.

Return Value:

    Non-zero: A mask containing the change which occurred.

    Zero: Either an error occurred or the handle (hPrinter) was closed
          by another thread.  In the latter case GetLastError returns
          ERROR_INVALID_HANDLE.

    When a call is made to WaitForPrinterChange, we create an event in the
    SPOOL structure pointed to by the handle, to enable signaling between
    the thread causing the printer change and the thread waiting for it.

    When a change occurs, e.g. StartDocPrinter, the function SetPrinterChange
    is called, which traverses the linked list of handles pointed to by
    the PRINTERINI structure associated with that printer, and also any
    open handles on the server, then signals any events which it finds
    which has reuested to be informed if this change takes place.

    If there is no thread currently waiting, the change flag is maintained,
    so that later calls to WaitForPrinterChange can return immediately.
    This ensures that changes which occur between calls will not be lost.

--*/


{
    PSPOOL          pSpool = (PSPOOL)hPrinter;
    PINIPRINTER     pIniPrinter = NULL; /* Remains NULL for server */
    DWORD           rc = 0;
    DWORD           ChangeFlags = 0;
    HANDLE          ChangeEvent = 0;
    DWORD           TimeoutFlags = 0;
#if DBG
    static DWORD    Count = 0;
#endif

    DBGMSG(DBG_NOTIFY,
           ("WaitForPrinterChange( %08x, %08x )\n", hPrinter, fdwFilterFlags));

    EnterSplSem();

    switch (ValidateStartNotify(pSpool,
                                fdwFilterFlags,
                                0,
                                NULL,
                                &pIniPrinter)) {
    case STATUS_PORT:

        DBGMSG(DBG_NOTIFY, ("Port with no monitor: Calling WaitForPrinterChange\n"));
        LeaveSplSem();

        return WaitForPrinterChange(pSpool->hPort, fdwFilterFlags);

    case STATUS_FAIL:

        LeaveSplSem();
        return 0;

    case STATUS_VALID:
        break;
    }

    DBGMSG(DBG_NOTIFY, ("WaitForPrinterChange %08x on %ws:\n%d caller%s waiting\n",
                        fdwFilterFlags,
                        pIniPrinter ? pIniPrinter->pName : pSpool->pIniSpooler->pMachineName,
                        Count, Count == 1 ? "" : "s"));

    //
    // There may already have been a change since we last called:
    //
    if ((pSpool->ChangeFlags == PRINTER_CHANGE_CLOSE_PRINTER) ||
        (pSpool->ChangeFlags & fdwFilterFlags)) {

        if (pSpool->ChangeFlags == PRINTER_CHANGE_CLOSE_PRINTER)
            ChangeFlags = 0;
        else
            ChangeFlags = pSpool->ChangeFlags;

        DBGMSG(DBG_NOTIFY, ("No need to wait: Printer change %08x detected on %ws:\n%d remaining caller%s\n",
                            (ChangeFlags & fdwFilterFlags),
                            pIniPrinter ? pIniPrinter->pName : pSpool->pIniSpooler->pMachineName,
                            Count, Count == 1 ? "" : "s"));

        pSpool->ChangeFlags = 0;

        LeaveSplSem();
        return (ChangeFlags & fdwFilterFlags);
    }

    ChangeEvent = CreateEvent(NULL,
                              EVENT_RESET_AUTOMATIC,
                              EVENT_INITIAL_STATE_NOT_SIGNALED,
                              NULL);

    if ( !ChangeEvent ) {

        DBGMSG( DBG_WARNING, ("CreateEvent( ChangeEvent ) failed: Error %d\n", GetLastError()));

        LeaveSplSem();
        return 0;
    }

    DBGMSG(DBG_NOTIFY, ("ChangeEvent == %x\n", ChangeEvent));

    //
    // SetSpoolChange checks that pSpool->ChangeEvent is non-null
    // to decide whether to call SetEvent().
    //
    pSpool->WaitFlags = fdwFilterFlags;
    pSpool->ChangeEvent = ChangeEvent;
    pSpool->pChangeFlags = &ChangeFlags;
    pSpool->Status |= SPOOL_STATUS_NOTIFY;

    LeaveSplSem();


    DBGMSG( DBG_NOTIFY,
            ( "WaitForPrinterChange: Calling WaitForSingleObject( %x )\n",
              pSpool->ChangeEvent ));

    rc = WaitForSingleObject(pSpool->ChangeEvent,
                             PRINTER_CHANGE_TIMEOUT_VALUE);

    DBGMSG( DBG_NOTIFY,
            ( "WaitForPrinterChange: WaitForSingleObject( %x ) returned\n",
              pSpool->ChangeEvent ));

    EnterSplSem();

    pSpool->Status &= ~SPOOL_STATUS_NOTIFY;
    pSpool->ChangeEvent = NULL;
    pSpool->pChangeFlags = NULL;

    if (rc == WAIT_TIMEOUT) {

        DBGMSG(DBG_INFO, ("WaitForPrinterChange on %ws timed out after %d minutes\n",
                          pIniPrinter ? pIniPrinter->pName : pSpool->pIniSpooler->pMachineName,
                          (PRINTER_CHANGE_TIMEOUT_VALUE / 60000)));

        ChangeFlags |= fdwFilterFlags;
        TimeoutFlags = PRINTER_CHANGE_TIMEOUT;
    }

    if (ChangeFlags == PRINTER_CHANGE_CLOSE_PRINTER) {

        ChangeFlags = 0;
        SetLastError(ERROR_INVALID_HANDLE);
    }

    DBGMSG(DBG_NOTIFY, ("Printer change %08x detected on %ws:\n%d remaining caller%s\n",
                        ((ChangeFlags & fdwFilterFlags) | TimeoutFlags),
                        pIniPrinter ? pIniPrinter->pName : pSpool->pIniSpooler->pMachineName,
                        Count, Count == 1 ? "" : "s"));

    if (ChangeEvent && !CloseHandle(ChangeEvent)) {

        DBGMSG(DBG_WARNING, ("CloseHandle( %x ) failed: Error %d\n",
                             ChangeEvent, GetLastError()));
    }

    //
    // If the pSpool is pending deletion, we must free it here.
    //
    if (pSpool->eStatus & STATUS_PENDING_DELETION) {

        FreeSplMem(pSpool);
    }

    LeaveSplSem();

    return ((ChangeFlags & fdwFilterFlags) | TimeoutFlags);
}

BOOL
SetSpoolClosingChange(
    PSPOOL pSpool)

/*++

Routine Description:

    A print handle is closing; trigger a notification.

Arguments:

Return Value:

--*/

{
    return SetSpoolChange(pSpool,
                          NULL,
                          NULL,
                          PRINTER_CHANGE_CLOSE_PRINTER);
}

BOOL
SetSpoolChange(
    PSPOOL pSpool,
    PNOTIFY_RAW_DATA pNotifyRawData,
    PDWORD pdwNotifyVectors,
    DWORD  Flags)

/*++

Routine Description:

    Sets the event for notification or calls ReplyPrinterChangeNotification.
    This is called by SetPrinterChange for every open handle on a printer
    and the local server.

    It should also be called when an individual handle is closed.

    Assumes we're INSIDE the spooler critical section

Arguments:

    pSpool -- Specifies handle that changed.

    pIniJob -- Used if there is a watch on job information.

    pdwNotifyVectors -- Specifies what things have changed.

    Flags -- WaitForPrinterChange flags.

Return Value:

--*/

{
    DWORD  ChangeFlags;

    SplInSem();

    if( Flags == PRINTER_CHANGE_CLOSE_PRINTER ) {

        ChangeFlags = PRINTER_CHANGE_CLOSE_PRINTER;

    } else {

        ChangeFlags = ( pSpool->ChangeFlags | Flags ) & pSpool->WaitFlags;
    }

    //
    // If we have STATUS_VALID set
    // then we are using the new FFPCN code.
    //

    if ( pSpool->eStatus & STATUS_VALID ) {

        NotifyInfoTypes(pSpool,
                        pNotifyRawData,
                        pdwNotifyVectors,
                        ChangeFlags);

    }

    if ( ChangeFlags ) {

        pSpool->ChangeFlags = 0;

        if ( pSpool->pChangeFlags ) {

            *pSpool->pChangeFlags = ChangeFlags;

            DBGMSG( DBG_NOTIFY, ( "SetSpoolChange: Calling SetEvent( %x )\n", pSpool->ChangeEvent ));

            SetEvent(pSpool->ChangeEvent);

            DBGMSG( DBG_NOTIFY, ( "SetSpoolChange: SetEvent( %x ) returned\n", pSpool->ChangeEvent ));

            pSpool->pChangeFlags = NULL;
        }
    }

    return TRUE;
}

/*++

Routine Name:

    PrinterNotificationVisible

Routine Description:

    This checks to see whether the given printer handle uses the new printer
    change notifications, it then checks to see whether the given printer is
    a TS printer and then checks to see whether this printer is visible to the
    user who opened the printer handle. This need only be called for server
    handles since the fact that the user was able to open the printer handle
    implies that it is visible to this.

Arguments:

    pIniPrinter - NULL, or a valid pointer to the INIPRINTER for the printer
                  on which the change occurred.
    pSpool      - The printer handle which we are testing for access.

Return Value:

    TRUE if the printer notification should be delivered, FALSE if the printer
    change notification should not be delivered.

--*/
BOOL
PrinterNotificationVisible(
    IN      PINIPRINTER     pIniPrinter         OPTIONAL,
    IN      PSPOOL          pSpool
    )
{
    BOOL    bRet = TRUE;

    //
    // If the pSpool handle is a new notification handle and we have a printer
    // and it is a TS printer and we can't show it, then return FALSE otherwise
    // the notification can be sent.
    //
    if (pSpool->eStatus & STATUS_VALID &&
        pIniPrinter &&
        (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_TS) &&
        pSpool->hClientToken &&
        !ShowThisPrinter(pIniPrinter, pSpool->hClientToken))
    {
        bRet = FALSE;
    }

    return bRet;
}

/*++

Routine Name:

    SetPrinterChange

Routine Description:

    Calls SetSpoolChange for every open handle for the server
    and printer, if specified.

Arguments:

    pIniPrinter - NULL, or a valid pointer to the INIPRINTER for the printer
                  on which the change occurred.

    Flags - PRINTER_CHANGE_* constant indicating what happened.


    Note: we pass a pointer to pPrinterNotifyInfo to SetSpoolChange.
    If one call needs it, it will check this parm, then create it if
    necessary.  This way it is retrieved only once.

Return Value:

--*/
BOOL
SetPrinterChange(
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob,
    PDWORD      pdwNotifyVectors,
    DWORD       Flags,
    PINISPOOLER pIniSpooler)
{
    NOTIFY_RAW_DATA aNotifyRawData[NOTIFY_TYPE_MAX];
    PSPOOL pSpool;
    PINIPRINTER mypIniPrinter;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    SplInSem();

    if ( pIniSpooler->SpoolerFlags & SPL_PRINTER_CHANGES ) {

        aNotifyRawData[0].pvData = pIniPrinter;
        aNotifyRawData[0].dwId =   pIniPrinter ? pIniPrinter->dwUniqueSessionID : 0;

        aNotifyRawData[1].pvData = pIniJob;
        aNotifyRawData[1].dwId = pIniJob ? pIniJob->JobId : 0;

        if ( pIniPrinter ) {

            SPLASSERT( ( pIniPrinter->signature == IP_SIGNATURE ) &&
                       ( pIniPrinter->pIniSpooler == pIniSpooler ));

            DBGMSG(DBG_NOTIFY, ("SetPrinterChange %ws; Flags: %08x\n",
                                pIniPrinter->pName, Flags));

            for (pSpool = pIniPrinter->pSpool; pSpool; pSpool = pSpool->pNext) {

                SetSpoolChange( pSpool,
                                aNotifyRawData,
                                pdwNotifyVectors,
                                Flags );
            }

        } else {

            //  WorkStation Caching requires a time stamp change
            //  any time cached data changes

            if ( Flags & ( PRINTER_CHANGE_FORM | PRINTER_CHANGE_ADD_PRINTER_DRIVER ) ) {

                for ( mypIniPrinter = pIniSpooler->pIniPrinter;
                      mypIniPrinter != NULL ;
                      mypIniPrinter = mypIniPrinter->pNext ) {

                    UpdatePrinterIni ( mypIniPrinter, CHANGEID_ONLY );
                }
            }
        }

        if ( pSpool = pIniSpooler->pSpool ) {

            DBGMSG( DBG_NOTIFY, ("SetPrinterChange %ws; Flags: %08x\n",
                                  pIniSpooler->pMachineName, Flags));

            for ( ; pSpool; pSpool = pSpool->pNext) {

                //
                // Only send the notification to the user if the printer is visible.
                //
                if (PrinterNotificationVisible(pIniPrinter, pSpool)) {

                    SetSpoolChange( pSpool,
                                    aNotifyRawData,
                                    pdwNotifyVectors,
                                    Flags );
                }
            }
        }
    }

    return TRUE;
}


BOOL
LocalFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PVOID pvReserved1)
{
    PINIPRINTER pIniPrinter = NULL;
    PSPOOL pSpool = (PSPOOL)hPrinter;

    EnterSplSem();

    switch (ValidateStartNotify(pSpool,
                                fdwFilterFlags,
                                fdwOptions,
                                pPrinterNotifyOptions,
                                &pIniPrinter)) {
    case STATUS_PORT:

        DBGMSG(DBG_NOTIFY, ("LFFPCN: Port nomon 0x%x\n", pSpool));
        pSpool->eStatus |= STATUS_PORT;

        LeaveSplSem();

        *pfdwStatus = 0;

        return ProvidorFindFirstPrinterChangeNotification(pSpool->hPort,
                                                          fdwFilterFlags,
                                                          fdwOptions,
                                                          hNotify,
                                                          pPrinterNotifyOptions,
                                                          pvReserved1);
    case STATUS_FAIL:

        DBGMSG(DBG_WARNING, ("ValidateStartNotify failed!\n"));
        LeaveSplSem();
        return FALSE;

    case STATUS_VALID:
        break;
    }

    //
    // Get any other handle state we need into this notification handle. This 
    // operation is guaranteed to be stateless.
    // 
    if (!GetClientTokenForNotification(pSpool)) {
        return FALSE;
    }

    pSpool->eStatus = STATUS_NULL;

    if (pPrinterNotifyOptions) {

        if (!SetupNotifyOptions(pSpool, pPrinterNotifyOptions)) {

            DBGMSG(DBG_WARNING, ("SetupNotifyOptions failed!\n"));
            LeaveSplSem();

            return FALSE;
        }
    }

    //
    // Setup notification
    //
    DBGMSG(DBG_NOTIFY, ("LFFPCN: Port has monitor: Setup 0x%x\n", pSpool));

    pSpool->WaitFlags = fdwFilterFlags;
    pSpool->hNotify = hNotify;
    pSpool->eStatus |= STATUS_VALID;

    pSpool->Status |= SPOOL_STATUS_NOTIFY;

    LeaveSplSem();

    *pfdwStatus = PRINTER_NOTIFY_STATUS_ENDPOINT;

    return TRUE;
}

BOOL
LocalFindClosePrinterChangeNotification(
    HANDLE hPrinter)
{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    BOOL bReturn = FALSE;


    if (ValidateSpoolHandle(pSpool, 0)) {

        EnterSplSem();

        //
        // If it's the port case (false connect) we pass the close
        // request to the right providor.
        // Otherwise, close ourselves.
        //
        if (pSpool->eStatus & STATUS_PORT) {

            DBGMSG(DBG_TRACE, ("LFCPCN: Port nomon 0x%x\n", pSpool));

            LeaveSplSem();

            bReturn = ProvidorFindClosePrinterChangeNotification(pSpool->hPort);

        } else {

            if (pSpool->eStatus & STATUS_VALID) {

                DBGMSG(DBG_TRACE, ("LFCPCN: Close notify 0x%x\n", pSpool));

                pSpool->WaitFlags = 0;
                pSpool->eStatus = STATUS_NULL;

                pSpool->Status &= ~SPOOL_STATUS_NOTIFY;

                bReturn = TRUE;

            } else {

                DBGMSG(DBG_WARNING, ("LFCPCN: Invalid handle 0x%x\n", pSpool));
                SetLastError(ERROR_INVALID_PARAMETER);
            }

            LeaveSplSem();
        }
    }

    return bReturn;
}


ESTATUS
ValidateStartNotify(
    PSPOOL pSpool,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PINIPRINTER* ppIniPrinter)

/*++

Routine Description:

    Validates the pSpool and Flags for notifications.

Arguments:

    pSpool - pSpool to validate

    fdwFilterFlags - Flags to validate

    fdwOptions - Options to validate

    pPrinterNotifyOptions

    ppIniPrinter - returned pIniPrinter; valid only STATUS_VALID

Return Value:

    EWAITSTATUS

--*/

{
    PINIPORT pIniPort;

    if (ValidateSpoolHandle(pSpool, 0)) {

        if ( pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER ) {

            *ppIniPrinter = pSpool->pIniPrinter;

        } else if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {

            *ppIniPrinter = NULL;

        } else if ((pSpool->TypeofHandle & PRINTER_HANDLE_PORT) &&
                   (pIniPort = pSpool->pIniPort) &&
                   (pIniPort->signature == IPO_SIGNATURE) &&
                   !(pSpool->pIniPort->Status & PP_MONITOR)) {

            if (pSpool->hPort == INVALID_PORT_HANDLE) {

                DBGMSG(DBG_WARNING, ("WaitForPrinterChange called for invalid port handle.  Setting last error to %d\n",
                                     pSpool->OpenPortError));

                SetLastError(pSpool->OpenPortError);
                return STATUS_FAIL;
            }

            return STATUS_PORT;

        } else {

            DBGMSG(DBG_WARNING, ("The handle is invalid\n"));
            SetLastError(ERROR_INVALID_HANDLE);
            return STATUS_FAIL;
        }
    } else {

        *ppIniPrinter = NULL;
    }

    //
    // Allow only one wait on each handle.
    //
    if( pSpool->Status & SPOOL_STATUS_NOTIFY ) {

        DBGMSG(DBG_WARNING, ("There is already a thread waiting on this handle\n"));
        SetLastError(ERROR_ALREADY_WAITING);

        return STATUS_FAIL;
    }

    if (!(fdwFilterFlags & PRINTER_CHANGE_VALID) && !pPrinterNotifyOptions) {

        DBGMSG(DBG_WARNING, ("The wait flags specified are invalid\n"));

        SetLastError(ERROR_INVALID_PARAMETER);
        return STATUS_FAIL;
    }

    return STATUS_VALID;
}

//-------------------------------------------------------------------

VOID
GetInfoData(
    PSPOOL pSpool,
    PNOTIFY_RAW_DATA pNotifyRawData,
    PNOTIFY_FIELD_TYPE pNotifyFieldType,
    PPRINTER_NOTIFY_INFO_DATA pData,
    PBYTE* ppBuffer)

/*++

Routine Description:

    Based on the type and field, find and add the information.

Arguments:

Return Value:

--*/

{
    static LPWSTR szNULL = L"";
    DWORD cbData = 0;
    DWORD cbNeeded = 0;

    union {
        DWORD dwData;
        PDWORD pdwData;
        PWSTR pszData;
        PVOID pvData;
        PINIJOB pIniJob;
        PINIPORT pIniPort;
        PDEVMODE pDevMode;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;
        PINIPRINTER pIniPrinter;

        PWSTR* ppszData;
        PINIPORT* ppIniPort;
        PINIPRINTER* ppIniPrinter;
        PINIDRIVER* ppIniDriver;
        PINIPRINTPROC* ppIniPrintProc;
        LPDEVMODE* ppDevMode;
        PSECURITY_DESCRIPTOR* ppSecurityDescriptor;
    } Var;

    Var.pvData = (PBYTE)pNotifyRawData->pvData + pNotifyFieldType->Offset;
    *ppBuffer = NULL;

    //
    // Determine space needed, and convert Data from an offset into the
    // actual data.
    //
    switch (pNotifyFieldType->Table) {
    case TABLE_JOB_POSITION:

        FindJob(Var.pIniJob->pIniPrinter,
                Var.pIniJob->JobId,
                &Var.dwData);
        goto DoDWord;

    case TABLE_JOB_STATUS:

        Var.dwData = MapJobStatus(MAP_READABLE, *Var.pdwData);
        goto DoDWord;

    case TABLE_DWORD:

        Var.dwData = *Var.pdwData;
        goto DoDWord;

    case TABLE_DEVMODE:

        Var.pDevMode = *Var.ppDevMode;

        if (Var.pDevMode) {

            cbData = Var.pDevMode->dmSize + Var.pDevMode->dmDriverExtra;

        } else {

            cbData = 0;
        }

        break;

    case TABLE_SECURITYDESCRIPTOR:

        Var.pSecurityDescriptor = *Var.ppSecurityDescriptor;
        cbData = GetSecurityDescriptorLength(Var.pSecurityDescriptor);
        break;

    case TABLE_STRING:

        Var.pszData = *Var.ppszData;
        goto DoString;

    case TABLE_TIME:

        //
        // Var already points to the SystemTime.
        //
        cbData = sizeof(SYSTEMTIME);
        break;

    case TABLE_PRINTPROC:

        Var.pszData = (*Var.ppIniPrintProc)->pName;
        goto DoString;

    case TABLE_JOB_PRINTERNAME:

        Var.pszData = (*Var.ppIniPrinter)->pName;
        goto DoString;

    case TABLE_JOB_PORT:

        Var.pIniPort = *Var.ppIniPort;

        //
        // Only if the job has been scheduled will pIniJob->pIniPort be
        // valid.  If it is NULL, then just call DoString which will
        // return a NULL string.
        //
        if (Var.pIniPort) {

            Var.pszData = Var.pIniPort->pName;
        }
        goto DoString;

    case TABLE_DRIVER:

        Var.pszData = (*Var.ppIniDriver)->pName;
        goto DoString;

    case TABLE_PRINTER_SERVERNAME:

        Var.pszData = pSpool->pFullMachineName;
        goto DoString;

    case TABLE_PRINTER_STATUS:

        Var.dwData = MapPrinterStatus(MAP_READABLE, Var.pIniPrinter->Status) |
                     Var.pIniPrinter->PortStatus;
        goto DoDWord;

    case TABLE_PRINTER_PORT:

        // Get required printer port size
        cbNeeded = 0;
        GetPrinterPorts(Var.pIniPrinter, 0, &cbNeeded);

        *ppBuffer = AllocSplMem(cbNeeded);

        if (*ppBuffer)
            GetPrinterPorts(Var.pIniPrinter, (LPWSTR) *ppBuffer, &cbNeeded);

        Var.pszData = (LPWSTR) *ppBuffer;

        goto DoString;

    case TABLE_NULLSTRING:

        Var.pszData = NULL;
        goto DoString;

    case TABLE_ZERO:

        Var.dwData = 0;
        goto DoDWord;

    default:
        SPLASSERT(FALSE);
        break;
    }

    pData->NotifyData.Data.pBuf = Var.pvData;
    pData->NotifyData.Data.cbBuf = cbData;

    return;


DoDWord:
    pData->NotifyData.adwData[0] = Var.dwData;
    pData->NotifyData.adwData[1] = 0;
    return;

DoString:
    if (Var.pszData) {

        //
        // Calculate string length.
        //
        pData->NotifyData.Data.cbBuf = (wcslen(Var.pszData)+1) *
                                        sizeof(Var.pszData[0]);

        pData->NotifyData.Data.pBuf = Var.pszData;

    } else {

        //
        // Use NULL string.
        //
        pData->NotifyData.Data.cbBuf = sizeof(Var.pszData[0]);
        pData->NotifyData.Data.pBuf  = szNULL;
    }
    return;
}





//-------------------------------------------------------------------



VOID
NotifyInfoTypes(
    PSPOOL pSpool,
    PNOTIFY_RAW_DATA pNotifyRawData,
    PDWORD pdwNotifyVectors,
    DWORD ChangeFlags)

/*++

Routine Description:

    Sends notification info (possibly with PRINTER_NOTIFY_INFO) to
    the router.

Arguments:

    pSpool -- Handle the notification is occurring on.

    pNotifyRawData -- Array of size NOTIFY_TYPE_MAX that has the
                      offset structure can be used against + id.

    pdwNotifyVectors -- Identifies what's changing (# elements
                        is also NOTIFY_TYPE_MAX).

                        NULL if no changes needed.

    ChangeFlags -- Old style change flags.

Return Value:

--*/

{
    PNOTIFY_FIELD_TYPE pNotifyFieldType;
    PRINTER_NOTIFY_INFO_DATA Data;
    PBYTE pBuffer;
    BOOL bReturn;

    DWORD i,j;
    DWORD dwMask;

    //
    // If we are not valid, OR
    //    we have no notify vectors, OR
    //    we have no RAW data OR
    //    our vectors don't match what change
    // then
    //    If no ChangeFlags return
    //    DoReply and avoid any Partials.
    //
    if (!(pSpool->eStatus & STATUS_INFO) ||
        !pdwNotifyVectors ||
        !pNotifyRawData ||
        (!(pdwNotifyVectors[0] & pSpool->adwNotifyVectors[0] ||
            pdwNotifyVectors[1] & pSpool->adwNotifyVectors[1]))) {

        if (!ChangeFlags)
            return;

        goto DoReply;
    }

    //
    // HACK: Special case NVPurge so that it causes a discard.
    // (We don't want to send all those notifications.)
    //
    if (pdwNotifyVectors == NVPurge) {

        PartialReplyPrinterChangeNotification(pSpool->hNotify, NULL);
        goto DoReply;
    }

    for (i=0; i< NOTIFY_TYPE_MAX; i++, pdwNotifyVectors++) {

        dwMask = 0x1;

        SPLASSERT(adwNotifyFieldOffsets[i] < sizeof(DWORD)*8);

        for (j=0; j< adwNotifyFieldOffsets[i]; j++, dwMask <<= 1) {

            //
            // If we have a change we are interested in,
            // PartialReply.
            //
            if (dwMask & *pdwNotifyVectors & pSpool->adwNotifyVectors[i]) {

                pNotifyFieldType = &apNotifyFieldTypes[i][j];

                GetInfoData(pSpool,
                            &pNotifyRawData[i],
                            pNotifyFieldType,
                            &Data,
                            &pBuffer);

                Data.Type = (WORD)i;
                Data.Field = pNotifyFieldType->Field;
                Data.Reserved = 0;
                Data.Id = pNotifyRawData[i].dwId;

                //
                // If the partial reply failed, then we will be refreshing
                // soon, so exit now.
                //
                bReturn = PartialReplyPrinterChangeNotification(
                              pSpool->hNotify,
                              &Data);

                if (pBuffer) {
                    FreeSplMem(pBuffer);
                }

                if (!bReturn) {

                    DBGMSG(DBG_TRACE, ("PartialReplyPCN %x failed: %d!\n",
                                       pSpool->hNotify,
                                       GetLastError()));
                    goto DoReply;
                }
            }
        }
    }

DoReply:

    //
    // A full reply is needed to kick off the notification.
    //
    ReplyPrinterChangeNotification(pSpool->hNotify,
                                   ChangeFlags,
                                   NULL,
                                   NULL);
}

BOOL
RefreshBuildInfoData(
    PSPOOL pSpool,
    PPRINTER_NOTIFY_INFO pInfo,
    UINT cInfo,
    WORD Type,
    PNOTIFY_RAW_DATA pNotifyRawData)

/*++

Routine Description:

    Sends notification info (possibly with PRINTER_NOTIFY_INFO) to
    the router.

Arguments:

    pSpool -- Handle the notification is occurring on.

    pInfo -- Array of structure to receive new info.

    cInfo -- Number of structures in array pInfo.

    Type -- Indicates type of notification: job or printer.

    pNotifyRawData -- Array of size NOTIFY_TYPE_MAX that has the
                      offset structure can be used against + id.

Return Value:

--*/

{
    PRINTER_NOTIFY_INFO_DATA Data;
    DWORD cbData;
    PNOTIFY_FIELD_TYPE pNotifyFieldType;
    PBYTE pBuffer;
    BOOL bReturn;

    DWORD j;
    DWORD dwMask;

    dwMask = 0x1;

    SPLASSERT(adwNotifyFieldOffsets[Type] < sizeof(DWORD)*8);

    for (j=0; j< adwNotifyFieldOffsets[Type]; j++, dwMask <<= 1) {

        //
        // If we have a change we are interested in,
        // add it.
        //
        if (dwMask & pSpool->adwNotifyVectors[Type]) {

            //
            // Check if we have enough space.
            //
            if (pInfo->Count >= cInfo) {
                SPLASSERT(pInfo->Count < cInfo);
                return FALSE;
            }

            pNotifyFieldType = &apNotifyFieldTypes[Type][j];

            GetInfoData(pSpool,
                        pNotifyRawData,
                        pNotifyFieldType,
                        &Data,
                        &pBuffer);

            Data.Type = Type;
            Data.Field = pNotifyFieldType->Field;
            Data.Reserved = 0;
            Data.Id = pNotifyRawData->dwId;

            bReturn = AppendPrinterNotifyInfoData(pInfo, &Data, 0);

            if (pBuffer)
                FreeSplMem(pBuffer);

            if (!bReturn) {

                DBGMSG(DBG_WARNING, ("AppendPrinterNotifyInfoData failed: %d!\n",
                                     GetLastError()));
                return FALSE;
            }
        }
    }
    return TRUE;
}


//-------------------------------------------------------------------

BOOL
SetupNotifyVector(
    PDWORD pdwNotifyVectors,
    PPRINTER_NOTIFY_OPTIONS_TYPE pType)

/*++

Routine Description:

    Setup the notification vector based on pPrinterNotifyType.
    We assume that the size of pPrinterNotifyType has been validated
    (so that it fits within the containing structure).  We only
    need to verify that the Count falls within its stated Size.

Arguments:

    pdwNotifyVectors - Structure to fill in.

    pType - Source information.

Return Value:

    TRUE = success,
    FALSE = failure.

--*/

{
    PNOTIFY_FIELD_TYPE pNotifyFieldType;
    PWORD pFields;
    DWORD i, j;
    DWORD Count;
    BOOL bReturn = FALSE;

    __try {

        if( pType ){

            Count = pType->Count;
            pFields = pType->pFields;

            if (pType->Type >= NOTIFY_TYPE_MAX) {

                DBGMSG(DBG_WARN, ("SetupNotifyVector: type %d field %d not found!\n",
                                     pType->Type, *pFields));
            } else {

                for (i=0; i < Count; i++, pFields++) {

                    if (*pFields >= adwNotifyFieldOffsets[pType->Type]) {

                        DBGMSG(DBG_WARN, ("SetupNotifyVector: type %d field %d not found!\n",
                                             pType->Type, *pFields));

                        break;
                    }

                    SPLASSERT(apNotifyFieldTypes[pType->Type][*pFields].Table != TABLE_SPECIAL);
                    SPLASSERT(apNotifyFieldTypes[pType->Type][*pFields].Field == *pFields);
                    SPLASSERT(*pFields < 32);

                    //
                    // Found index j, set this bit in our array.
                    //
                    pdwNotifyVectors[pType->Type] |= (1 << *pFields);
                }

                if( i == Count ){
                    bReturn = TRUE;
                }
            }
        }
    } __except( EXCEPTION_EXECUTE_HANDLER ){
    }


    return bReturn;
}

BOOL
SetupNotifyOptions(
    PSPOOL pSpool,
    PPRINTER_NOTIFY_OPTIONS pOptions)

/*++

Routine Description:

    Initializes pSpool->adwNotifyVectors.

Arguments:

    pSpool - Spool handle to setup the notification against.

    pOptions - Options that specify the notification.

Return Value:

    TRUE - Success, FALSE - FAILURE

    LastError set.

--*/

{
    DWORD i;
    BOOL bAccessGranted = TRUE;

    SplInSem();

    ZeroMemory(pSpool->adwNotifyVectors, sizeof(pSpool->adwNotifyVectors));

    //
    // Traverse Options structure.
    //
    for (i = 0; i < pOptions->Count; i++) {

        if (!SetupNotifyVector(pSpool->adwNotifyVectors,
                               &pOptions->pTypes[i])){

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    //
    // Now check if we have sufficient privilege to setup the notification.
    //

    //
    // Check if we are looking for the security descriptor on
    // a printer.  If so, we need READ_CONTROL or ACCESS_SYSTEM_SECURITY
    // enabled.
    //
    if( pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE] &
        BIT(I_PRINTER_SECURITY_DESCRIPTOR )){

        if( !AreAnyAccessesGranted( pSpool->GrantedAccess,
                                    READ_CONTROL | ACCESS_SYSTEM_SECURITY )){
            bAccessGranted = FALSE;
        }
    }

    if( pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE] &
        ~BIT(I_PRINTER_SECURITY_DESCRIPTOR )){

        if( pSpool->TypeofHandle & PRINTER_HANDLE_SERVER ){

            //
            // There does not appear to be a check for EnumPrinters.
            //
            // This seems odd since you there is a security check on a
            // GetPrinter call, but there is none on EnumPrinters (aside
            // from enumerating share printers only for remote non-admins).
            //

        } else {

            //
            // This matches the check in SplGetPrinter: we need to
            // have PRINTER_ACCESS_USE to read the non-security information.
            //
            if( !AccessGranted( SPOOLER_OBJECT_PRINTER,
                                PRINTER_ACCESS_USE,
                                pSpool )){

                bAccessGranted = FALSE;
            }
        }
    }

    if( !bAccessGranted ){

        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }

    pSpool->eStatus |= STATUS_INFO;

    return TRUE;
}

UINT
PopCount(
    DWORD dwValue)
{
    UINT i;
    UINT cPopCount = 0;

    for(i=0; i< sizeof(dwValue)*8; i++) {

        if (dwValue & (1<<i))
            cPopCount++;
    }

    return cPopCount;
}


BOOL
LocalRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PPRINTER_NOTIFY_OPTIONS pOptions,
    PPRINTER_NOTIFY_INFO* ppInfo)

/*++

Routine Description:

    Refreshes data in the case of overflows.

Arguments:

Return Value:

--*/

{
    PINIJOB pIniJob;
    PINIPRINTER pIniPrinter;
    DWORD cPrinters;
    PSPOOL pSpool = (PSPOOL)hPrinter;
    PDWORD pdwNotifyVectors = pSpool->adwNotifyVectors;
    UINT cInfo = 0;
    PPRINTER_NOTIFY_INFO pInfo = NULL;
    NOTIFY_RAW_DATA NotifyRawData;

    EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, 0 ) ||
        !(pSpool->eStatus & STATUS_INFO)) {

        SetLastError( ERROR_INVALID_HANDLE );
        goto Fail;
    }

    //
    // New bits added, can't compare directly against PRINTER_HANDLE_SERVER.
    //
    if( pSpool->TypeofHandle & PRINTER_HANDLE_SERVER ){

        //
        // If the call is a remote one, and the user is not an admin, then
        // we don't want to show unshared printers.
        //
        BOOL bHideUnshared = (pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL)  &&
                             !(pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_ADMIN);


        for (cPrinters = 0, pIniPrinter = pSpool->pIniSpooler->pIniPrinter;
            pIniPrinter;
            pIniPrinter=pIniPrinter->pNext ) {

            if ((!(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) &&
                 bHideUnshared)
                || !ShowThisPrinter(pIniPrinter, NULL)
                ) {

                continue;
            }

            cPrinters++;
        }

        cInfo += PopCount(pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE]) *
                 cPrinters;

        //
        // Traverse all printers and create info.
        //
        pInfo = RouterAllocPrinterNotifyInfo(cInfo);

        if (!pInfo)
            goto Fail;

        if (pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE]) {

            for (pIniPrinter = pSpool->pIniSpooler->pIniPrinter;
                pIniPrinter;
                pIniPrinter=pIniPrinter->pNext) {

                //
                // Do not send notification for non-shared printers for remote
                // users who are not admins
                //
                if ((!(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) &&
                     bHideUnshared )
                    || !ShowThisPrinter(pIniPrinter, NULL)
                    ) {

                    continue;
                }



                NotifyRawData.pvData = pIniPrinter;
                NotifyRawData.dwId = pIniPrinter->dwUniqueSessionID;

                if (!RefreshBuildInfoData(pSpool,
                                          pInfo,
                                          cInfo,
                                          PRINTER_NOTIFY_TYPE,
                                          &NotifyRawData)) {

                    goto Fail;
                }
            }
        }
    } else {

        //
        // Calculate size of buffer needed.
        //
        if (pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE]) {

            //
            // Setup printer info.
            //
            cInfo += PopCount(pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE]);
        }

        if (pSpool->adwNotifyVectors[JOB_NOTIFY_TYPE]) {

            cInfo += PopCount(pSpool->adwNotifyVectors[JOB_NOTIFY_TYPE]) *
                              pSpool->pIniPrinter->cJobs;
        }

        //
        // Traverse all jobs and create info.
        //
        pInfo = RouterAllocPrinterNotifyInfo(cInfo);

        if (!pInfo)
            goto Fail;

        if (pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE]) {

            NotifyRawData.pvData = pSpool->pIniPrinter;
            NotifyRawData.dwId = pSpool->pIniPrinter->dwUniqueSessionID;

            if (!RefreshBuildInfoData(pSpool,
                                      pInfo,
                                      cInfo,
                                      PRINTER_NOTIFY_TYPE,
                                      &NotifyRawData)) {

                goto Fail;
            }
        }

        if (pSpool->adwNotifyVectors[JOB_NOTIFY_TYPE]) {

            for (pIniJob = pSpool->pIniPrinter->pIniFirstJob;
                pIniJob;
                pIniJob = pIniJob->pIniNextJob) {

                //
                // Hide Chained Jobs
                //

                if (!(pIniJob->Status & JOB_HIDDEN )) {

                    NotifyRawData.pvData = pIniJob;
                    NotifyRawData.dwId = pIniJob->JobId;

                    if (!RefreshBuildInfoData(pSpool,
                                              pInfo,
                                              cInfo,
                                              JOB_NOTIFY_TYPE,
                                              &NotifyRawData)) {

                        goto Fail;
                    }
                }
            }
        }
    }

    SPLASSERT(cInfo >= pInfo->Count);
    LeaveSplSem();

    *ppInfo = pInfo;
    return TRUE;

Fail:

    SPLASSERT(!pInfo || cInfo >= pInfo->Count);
    LeaveSplSem();

    *ppInfo = NULL;
    if (pInfo) {
        RouterFreePrinterNotifyInfo(pInfo);
    }
    return FALSE;
}

/*++

Routine Name:

    GetClientTokenForNotification

Routine Description:

    Populate the client handle with the callers token if this is a server handle 
    (printer handles have implicitely been access checked by virtue of the fact
    that you could open it).

Arguments:

    pSpool      -   The printer handle that we are populating with the token
                    information

Return Value:

    TRUE if we could in fact return the token.

--*/
BOOL 
GetClientTokenForNotification(
    IN  OUT SPOOL               *pSpool
    )
{
    BOOL    bRet = TRUE;

    if (!pSpool) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        
        bRet = FALSE;
    }
   
    if (bRet) 
    {
        //
        // If this is a printer handle, then we need to get the client token handle
        // 
        if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) 
        {
            //
            // Only get the new client token if we don't have one already.
            // 
            if (!pSpool->hClientToken) 
            {
                bRet = GetTokenHandle(&pSpool->hClientToken);
            }
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\clusport.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved

Module Name:

    Downlevel cluster port support.

Abstract:

    Supports mixing and matching downlevel and uplevel language
    and monitor ports.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop


/********************************************************************

    Downlevel Port Monitor (Dp)

    Dp support is used when we have an uplevel language monitor
    and downlevel port monitor.  We pass a stub function vector
    to the LM and set the hMonitor to the downlevel pIniMonitor.

    When we get called, we can dereference the hMonitor to call the
    real downlevel monitor.

********************************************************************/


BOOL
DpEnumPorts(
    HANDLE  hMonitor,
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnEnumPorts( pName,
                                              Level,
                                              pPorts,
                                              cbBuf,
                                              pcbNeeded,
                                              pcReturned );
}

BOOL
DpOpenPort(
    HANDLE  hMonitor,
    LPWSTR  pName,
    PHANDLE pHandle
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnOpenPort( pName, pHandle );
}

BOOL
DpOpenPortEx(
    HANDLE  hMonitor,
    LPWSTR  pPortName,
    LPWSTR  pPrinterName,
    PHANDLE pHandle,
    struct _MONITOR FAR *pMonitor
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnOpenPortEx( pPortName,
                                               pPrinterName,
                                               pHandle,
                                               pMonitor );
}

BOOL
DpAddPort(
    HANDLE   hMonitor,
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pMonitorName
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnAddPort( pName,
                                            hWnd,
                                            pMonitorName );
}

BOOL
DpAddPortEx(
    HANDLE   hMonitor,
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnAddPortEx( pName,
                                              Level,
                                              pBuffer,
                                              pMonitorName );
}

BOOL
DpConfigurePort(
    HANDLE  hMonitor,
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnConfigurePort( pName,
                                                  hWnd,
                                                  pPortName );
}

BOOL
DpDeletePort(
    HANDLE  hMonitor,
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnDeletePort( pName,
                                               hWnd,
                                               pPortName );
}

BOOL
DpXcvOpenPort(
    HANDLE  hMonitor,
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnXcvOpenPort( pszObject,
                                                GrantedAccess,
                                                phXcv );
}


/********************************************************************

    Downlevel Language Monitor (Dl)

    Dl support is used when we have a downlevel language monitor
    and uplevel port monitor.

    This is very messy, since the language monitor is given the
    ports function vector directly, and we don't have any extra
    handles to pass around state information.

    Instead, we overload the name string yet again.  The port name
    is converted to:

        {NormalPortName},{pIniMonitorHex}

        LPT1:,a53588

    We then strip off the two trailing hex numbers and pass LPT1:
    back.

********************************************************************/

BOOL
GetDlPointers(
    IN      LPCWSTR         pszName,
        OUT LPWSTR          pszNameNew,
        OUT PINIMONITOR     *ppIniMonitor,
    IN      DWORD           cchBufferSize
    )

/*++

Routine Description:

    Hack function to take a pszName and convert it to a new name
    string with two additional parameters: hMonitor and pMonitor2

Arguments:

    pszName - Hacked up name overloaded with pIniMonitor.

    pszNameNew - Receives "real" shorter name of the port.

    ppIniMonitor - Receives cracked pIniMonitor.

Return Value:

--*/

{
    BOOL bReturn = FALSE;
    LPCWSTR p;
    LPCWSTR p1 = NULL;

    for( p = pszName; p = wcschr( p, TEXT( ',' )); ){
        p1 = p;
        ++p;
    }

    if( p1 ){

        StringCchCopy(pszNameNew, cchBufferSize, pszName );
        pszNameNew[p1-pszName] = 0;

        ++p1;

        *ppIniMonitor = (PINIMONITOR)atox( p1 );

        __try {

            bReturn = ( (*ppIniMonitor)->signature == IMO_SIGNATURE );

        } except( EXCEPTION_EXECUTE_HANDLER ){

        }

        if( bReturn ){
            return TRUE;
        }
    }

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
CreateDlName(
    IN      LPCWSTR         pszName,
    IN      PINIMONITOR     pIniMonitor,
    IN  OUT PWSTR           pszNameNew,
    IN      SIZE_T          cchNameNew
    )

/*++

Routine Description:

    Create a downlevel name that can be parsed by GetDlPointers.

Arguments:

    pszName - Name of port.  The newly created name must be < MAX_PATH,
        and since we need to append one hex values (4 characters) plus
        one comma, we need to verify that the string length has at least
        5 characters left.

    pIniMonitor - Monitor structure of the uplevel port monitor.

Return Value:

    TRUE - Success

    FALSE - Failure, due to too long port name length.

--*/

{
    return BoolFromHResult(StringCchPrintf(pszNameNew, cchNameNew, TEXT( "%s,%p" ), pszName, pIniMonitor));
}


FARPROC gafpMonitor2Stub[] = {
    (FARPROC) &DpEnumPorts,
    (FARPROC) &DpOpenPort,
    NULL,               // OpenPortEx
    NULL,               // StartDocPort
    NULL,               // WritePort
    NULL,               // ReadPort
    NULL,               // EndDocPort
    NULL,               // ClosePort
    (FARPROC) &DpAddPort,
    (FARPROC) &DpAddPortEx,
    (FARPROC) &DpConfigurePort,
    (FARPROC) &DpDeletePort,
    NULL,
    NULL,
    (FARPROC) &DpXcvOpenPort,
    NULL,               // XcvDataPortW
    NULL,               // XcvClosePortW
    NULL                // Shutdown
};



BOOL
DlEnumPorts(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnEnumPorts( pIniMonitor->hMonitor,
                                                   szName,
                                                   Level,
                                                   pPorts,
                                                   cbBuf,
                                                   pcbNeeded,
                                                   pcReturned );
    }
    return FALSE;
}

BOOL
DlOpenPort(
    LPWSTR  pName,
    PHANDLE pHandle
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnOpenPort( pIniMonitor->hMonitor,
                                                  szName,
                                                  pHandle );
    }
    return FALSE;
}

BOOL
DlOpenPortEx(
    LPWSTR  pPortName,
    LPWSTR  pPrinterName,
    PHANDLE pHandle,
    struct _MONITOR FAR *pMonitor
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
DlAddPort(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pMonitorName
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnAddPort( pIniMonitor->hMonitor,
                                                 szName,
                                                 hWnd,
                                                 pMonitorName );
    }
    return FALSE;
}

BOOL
DlAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnAddPortEx( pIniMonitor->hMonitor,
                                                   pName,
                                                   Level,
                                                   pBuffer,
                                                   pMonitorName );
    }
    return FALSE;
}

BOOL
DlConfigurePort(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnConfigurePort( pIniMonitor->hMonitor,
                                                       szName,
                                                       hWnd,
                                                       pPortName );
    }
    return FALSE;
}

BOOL
DlDeletePort(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnDeletePort( pIniMonitor->hMonitor,
                                                    szName,
                                                    hWnd,
                                                    pPortName );
    }
    return FALSE;
}

FARPROC gafpDlStub[] = {
    (FARPROC) &DlEnumPorts,
    (FARPROC) &DlOpenPort,
    (FARPROC) &DlOpenPortEx,
    NULL,               // StartDocPort
    NULL,               // WritePort
    NULL,               // ReadPort
    NULL,               // EndDocPort
    NULL,               // ClosePort
    (FARPROC) &DlAddPort,
    (FARPROC) &DlAddPortEx,
    (FARPROC) &DlConfigurePort,
    (FARPROC) &DlDeletePort,
    NULL,
    NULL,
};


VOID
InitializeUMonitor(
    PINIMONITOR pIniMonitor
    )

/*++

Routine Description:

    Initialize an uplevel port monitor for downlevel support.  When a
    downlevel language monitor is used with an uplevel port monitor,
    we need to setup stubs since the language monitor calls the port
    monitor interfaces directly.

    We create a downlevel function vector with patched entries and pass
    it to the language monitor.  The LM is passed in a formatted name
    that has both the port name and also the pIniMonitor encoded in the
    string.

Arguments:

    pIniMonitor - Monitor to initialize.

Return Value:

--*/

{
    FARPROC *pfpSrc;
    FARPROC *pfpDest;
    FARPROC *pfpStub;
    INT i;

    //
    // Create the downlevel port monitor interface.  This is
    // used when we have a downlevel language monitor with an
    // uplevel port monitor.
    //
    CopyMemory((LPBYTE)&pIniMonitor->Monitor, (LPBYTE)&pIniMonitor->Monitor2.pfnEnumPorts, sizeof( pIniMonitor->Monitor ));

    for( i=0,
         pfpSrc = (FARPROC*)&pIniMonitor->Monitor2.pfnEnumPorts,
         pfpDest = (FARPROC*)&pIniMonitor->Monitor,
         pfpStub = gafpDlStub;

         i < sizeof( pIniMonitor->Monitor )/sizeof( *pfpDest );

         ++i, ++pfpDest, ++pfpStub, ++pfpSrc ){

        *pfpDest = *pfpStub ?
                       *pfpStub :
                       *pfpSrc;
    }
}


/********************************************************************

    Initialize a Downlevel language or port monitor.

********************************************************************/

//
// List of monitor functions for downlevel (3.51) monitors.  Instead
// of receiving a function vector, the spooler has to call GetProcAddress
// on each of these functions.  The order of these ports must be in the
// same format as the pMonitor2 structure.
//

LPCSTR aszMonitorFunction[] = {
    "EnumPortsW",
    "OpenPort",
    NULL,
    "StartDocPort",
    "WritePort",
    "ReadPort",
    "EndDocPort",
    "ClosePort",
    "AddPortW",
    "AddPortExW",
    "ConfigurePortW",
    "DeletePortW",
    NULL,
    NULL,
    "XcvOpenPortW",
    "XcvDataPortW",
    "XcvClosePortW"
};


PINIMONITOR
InitializeDMonitor(
    PINIMONITOR pIniMonitor,
    LPWSTR pszRegistryRoot
    )

/*++

Routine Description:

    Initialize downlevel monitor.

Arguments:

    pIniMonitor - Partially created pIniMonitor that needs to be initialized
        with functions.

Return Value:

    NULL - Initialization failed, but possibly because monitor could not
        initialize.  Still add monitor to spooler datastructures.

    (PINIMONITOR)-1 - Failed.

--*/

{
    BOOL        (*pfnInitialize)(LPWSTR) = NULL;
    BOOL        (*pfnInitializeMonitorEx)(LPWSTR, LPMONITOR) = NULL;
    LPMONITOREX (*pfnInitializePrintMonitor)(LPWSTR) = NULL;
    LPMONITOREX pMonEx;
    DWORD cbDpMonitor;

    PINIMONITOR pReturnValue = (PINIMONITOR)-1;

    //
    // Try calling the entry points in the following order:
    //     InitializePrintMonitor,
    //     InitializeMonitorEx,
    //     InitializeMonitor
    //
    (FARPROC)pfnInitializePrintMonitor = GetProcAddress(
                                             pIniMonitor->hModule,
                                             "InitializePrintMonitor" );
    if( !pfnInitializePrintMonitor ){

        (FARPROC)pfnInitializeMonitorEx = GetProcAddress(
                                              pIniMonitor->hModule,
                                              "InitializeMonitorEx" );

        if( !pfnInitializeMonitorEx ){

            (FARPROC)pfnInitialize = GetProcAddress(
                                         pIniMonitor->hModule,
                                         "InitializeMonitor" );
        }
    }

    if ( !pfnInitializePrintMonitor &&
         !pfnInitializeMonitorEx    &&
         !pfnInitialize ) {

        DBGMSG( DBG_WARNING,
                ( "InitializeDLPrintMonitor %ws GetProcAddress failed %d\n",
                  pszRegistryRoot,
                  GetLastError()));
    } else {

        BOOL bSuccess = FALSE;

        LeaveSplSem();

        if( pfnInitializePrintMonitor ) {

            pMonEx = (*pfnInitializePrintMonitor)(pszRegistryRoot);

            if( pMonEx ){

                bSuccess = TRUE;
                cbDpMonitor = pMonEx->dwMonitorSize;
                CopyMemory((LPBYTE)&pIniMonitor->Monitor,
                           (LPBYTE)&pMonEx->Monitor,
                           min(pMonEx->dwMonitorSize, sizeof(MONITOR)));
            }

        } else if ( pfnInitializeMonitorEx ) {

            bSuccess = (*pfnInitializeMonitorEx)( pszRegistryRoot,
                                                  &pIniMonitor->Monitor );
            cbDpMonitor = sizeof(MONITOR);

        } else {

            INT i;
            FARPROC* pfp;

            bSuccess = (BOOL)((*pfnInitialize)(pszRegistryRoot));
            cbDpMonitor = sizeof(MONITOR);

            for( i=0, pfp=(FARPROC*)&pIniMonitor->Monitor;
                i< COUNTOF( aszMonitorFunction );
                ++i, ++pfp ){

                if( aszMonitorFunction[i] ){

                    *pfp = GetProcAddress( pIniMonitor->hModule,
                                           aszMonitorFunction[i] );
                }
            }
        }

        EnterSplSem();

        if( bSuccess ){

            INT i;
            INT iMax;
            FARPROC* pfpSrc;
            FARPROC* pfpDest;
            FARPROC* pfpStub;

            //
            // Store away the pIniMonitor as the handle returned from the monitor.
            // When we call the stub, it will cast it back to a pIniMonitor then
            // use it to get to pIniMonitor->Monitor.fn.
            //
            pIniMonitor->hMonitor = (HANDLE)pIniMonitor;

            //
            // New size of the stub Monitor2 structure is the size of the
            // downlevel monitor, plus the extra DWORD for Monitor2.cbSize.
            //
            pIniMonitor->Monitor2.cbSize = min( cbDpMonitor + sizeof( DWORD ),
                                                sizeof( MONITOR2 ));

            //
            // The number of stub pointers we want to copy is the size of
            // the struct, minus the extra DWORD that we added above.
            //
            iMax = (pIniMonitor->Monitor2.cbSize - sizeof( DWORD )) / sizeof( pfpSrc );

            //
            // We have copied the monitor entrypoints into the downlevel Monitor
            // structure.  Now we must run through the uplevel vector and fill
            // it in with the stubs.
            //
            for( i=0,
                 pfpSrc = (FARPROC*)&pIniMonitor->Monitor,
                 pfpDest = (FARPROC*)&pIniMonitor->Monitor2.pfnEnumPorts,
                 pfpStub = (FARPROC*)gafpMonitor2Stub;

                 i< iMax;

                 ++i, ++pfpSrc, ++pfpDest, ++pfpStub ){

                if( *pfpSrc ){

                    //
                    // Stubs aren't needed for all routines.  Only use them
                    // when they are needed; in other cases, just use the
                    // regular one.
                    //
                    *pfpDest = *pfpStub ?
                                   *pfpStub :
                                   *pfpSrc;
                }
            }

            //
            // Success, return the original pIniMonitor.
            //
            pReturnValue = pIniMonitor;

        } else {

            DBGMSG( DBG_WARNING,
                    ( "InitializeDLPrintMonitor %ws Init failed %d\n",
                      pszRegistryRoot,
                      GetLastError()));

            //
            // Some old (before NT 4.0) monitors may not initialize until
            // reboot.
            //
            if( pfnInitialize ){
                pReturnValue = NULL;
            }
        }
    }

    return pReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\aspapp\ipp_res.inc ===
<%
'------------------------------------------------------------
'
' Microsoft Internet Printing Project
'
' Copyright (c) Microsoft Corporation. All rights reserved.
'
'------------------------------------------------------------


Const PROGID_CLIENT_HELPER  = "OlePrn.PrinterURL"
Const PROGID_SNMP           = "OlePrn.OleSNMP"
Const PROGID_HELPER         = "OlePrn.AspHelp"
Const PROGID_CONVERTER      = "OlePrn.OleCvt"

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\clusreg.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Cluster registry apis.

Abstract:

    Determines whether ClusterReg or Reg apis should be used.

    The printer information is stored in the registry.  When we access
    local printers, we hit the local registry; when we access cluster
    printers, we hit the cluster registry.

Author:

    Albert Ting (AlbertT) 8-Oct-96

Environment:

    User Mode -Win32

Revision History:

    Felix Maxa (amaxa) 18-Jun-2000
       Added ClusterGetResourceID
             ClusterGetResourceDriveLetter

--*/

#include "precomp.h"
#pragma hdrstop

#include <clusapi.h>
#include "clusspl.h"

enum
{
    kDriveLetterStringSize = 3,
    kGuidStringSize        = 40
};


/********************************************************************

    Globals.

********************************************************************/

typedef struct _CLUSAPI {

    HCLUSTER
    (*pfnOpenCluster)(
        IN LPCWSTR lpszClusterName
        );

    BOOL
    (*pfnCloseCluster)(
        IN HCLUSTER hCluster
        );

    HRESOURCE
    (*pfnOpenClusterResource)(
        IN HCLUSTER hCluster,
        IN LPCWSTR lpszResourceName
        );

    BOOL
    (*pfnCloseClusterResource)(
        IN HRESOURCE hResource
        );

    HKEY
    (*pfnGetClusterKey)(
        IN HCLUSTER hCluster,
        IN REGSAM   samDesired
        );

    HKEY
    (*pfnGetClusterResourceKey)(
        IN HRESOURCE hResource,
        IN REGSAM samDesired
        );

    LONG
    (*pfnClusterRegCreateKey)(
        IN HKEY hKey,
        IN LPCWSTR lpszSubKey,
        IN DWORD dwOptions,
        IN REGSAM samDesired,
        IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        OUT PHKEY phkResult,
        OUT OPTIONAL LPDWORD lpdwDisposition
        );

    LONG
    (*pfnClusterRegOpenKey)(
        IN HKEY hKey,
        IN LPCWSTR lpszSubKey,
        IN REGSAM samDesired,
        OUT PHKEY phkResult
        );

    LONG
    (*pfnClusterRegDeleteKey)(
        IN HKEY hKey,
        IN LPCWSTR lpszSubKey
        );

    LONG
    (*pfnClusterRegCloseKey)(
        IN HKEY hKey
        );

    LONG
    (*pfnClusterRegEnumKey)(
        IN HKEY hKey,
        IN DWORD dwIndex,
        OUT LPWSTR lpszName,
        IN OUT LPDWORD lpcbName,
        OUT PFILETIME lpftLastWriteTime
        );

    DWORD
    (*pfnClusterRegSetValue)(
        IN HKEY hKey,
        IN LPCWSTR lpszValueName,
        IN DWORD dwType,
        IN CONST BYTE* lpData,
        IN DWORD cbData
        );

    DWORD
    (*pfnClusterRegDeleteValue)(
        IN HKEY hKey,
        IN LPCWSTR lpszValueName
        );

    LONG
    (*pfnClusterRegQueryValue)(
        IN HKEY hKey,
        IN LPCWSTR lpszValueName,
        OUT LPDWORD lpValueType,
        OUT LPBYTE lpData,
        IN OUT LPDWORD lpcbData
        );

    DWORD
    (*pfnClusterRegEnumValue)(
        IN HKEY hKey,
        IN DWORD dwIndex,
        OUT LPWSTR lpszValueName,
        IN OUT LPDWORD lpcbValueName,
        OUT LPDWORD lpType,
        OUT LPBYTE lpData,
        IN OUT LPDWORD lpcbData
        );

    LONG
    (*pfnClusterRegQueryInfoKey)(
        HKEY hKey,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime
        );

    DWORD
    (*pfnClusterResourceControl)(
        HRESOURCE hResource,
        HNODE     hHostNode,
        DWORD     dwControlCode,
        LPVOID    lpInBuffer,
        DWORD     cbInBufferSize,
        LPVOID    lpOutBuffer,
        DWORD     cbOutBufferSize,
        LPDWORD   lpcbBytesReturned
        );

} CLUSAPI, *PCLUSAPI;

CLUSAPI ClusApi;

LPCSTR aszClusApi[] = {
    "OpenCluster",
    "CloseCluster",
    "OpenClusterResource",
    "CloseClusterResource",
    "GetClusterKey",
    "GetClusterResourceKey",
    "ClusterRegCreateKey",
    "ClusterRegOpenKey",
    "ClusterRegDeleteKey",
    "ClusterRegCloseKey",
    "ClusterRegEnumKey",
    "ClusterRegSetValue",
    "ClusterRegDeleteValue",
    "ClusterRegQueryValue",
    "ClusterRegEnumValue",
    "ClusterRegQueryInfoKey",
    "ClusterResourceControl"
};

/********************************************************************

    OpenCluster
    CloseCluster

    OpenClusterResource
    CloseClusterResource
    GetClusterResourceKey

    ClusterRegCreateKey
    ClusterRegOpenKey
    ClusterRegDeleteKey
    ClusterRegCloseKey
    ClusterRegEnumKey

    ClusterRegSetValue
    ClusterRegDeleteValue
    ClusterRegQueryValue
    ClusterRegEnumValue
    ClusterRegQueryInfoKey

********************************************************************/

BOOL
LoadClusterFunctions(
    VOID
    )

/*++

Routine Description:

    Load ClusApi functions.  Must be called before any cluster api
    is used.

Arguments:

Return Value:

    TRUE - Success

    FALSE - Fail

--*/

{
    HANDLE hLibrary;
    UINT i;
    FARPROC* pFarProc = (FARPROC*)&ClusApi;

    //
    // Size of string table and structure are identical.
    //
    SPLASSERT( COUNTOF( aszClusApi ) == sizeof( ClusApi )/sizeof( FARPROC ));

    if( ClusApi.pfnOpenCluster ){
        return TRUE;
    }

    i = SetErrorMode(SEM_FAILCRITICALERRORS);
    hLibrary = LoadLibrary(TEXT("clusapi.dll"));
    SetErrorMode(i);
    if( !hLibrary ){
        goto Fail;
    }

    for( i=0; i< COUNTOF( aszClusApi ); ++i, ++pFarProc) {

        *pFarProc = GetProcAddress( hLibrary, aszClusApi[i] );
        if( !*pFarProc ){

            DBGMSG( DBG_WARN,
                    ( "LoadClusterFunctions: Loading function %hs failed %d\n",
                      aszClusApi[i], GetLastError( )));
            goto Fail;
        }
    }

    return TRUE;

Fail:

    if( hLibrary ){
        FreeLibrary( hLibrary );
    }

    ClusApi.pfnOpenCluster = NULL;
    return FALSE;
}

HKEY
OpenClusterParameterKey(
    IN LPCTSTR pszResource
    )

/*++

Routine Description:

    Based on a resource string, open the cluster key with FULL access.

Arguments:

    pszResource - Name of the resource key.

Return Value:

    HKEY - Success.  Key must be closed with

    NULL - Failure.  LastError set.

--*/

{
    HCLUSTER hCluster;
    HRESOURCE hResource = NULL;
    HKEY hKeyResource = NULL;
    HKEY hKey = NULL;
    DWORD Status;
    DWORD dwDisposition;

    if( !LoadClusterFunctions( )){
        return NULL;
    }

    hCluster = ClusApi.pfnOpenCluster( NULL );

    if( !hCluster ){

        DBGMSG( DBG_WARN,
                ( "OpenClusterResourceKey: failed to open cluster %d\n",
                  GetLastError() ));
        goto Fail;
    }

    hResource = ClusApi.pfnOpenClusterResource( hCluster, pszResource );

    if( !hResource ){
        DBGMSG( DBG_WARN,
                ( "OpenClusterResourceKey: failed to open resource "TSTR" %d\n",
                  pszResource, GetLastError() ));
        goto Fail;
    }

    hKeyResource = ClusApi.pfnGetClusterResourceKey( hResource,
                                                     KEY_READ | KEY_WRITE | DELETE);

    if( !hKeyResource ){
        DBGMSG( DBG_WARN,
                ( "OpenClusterResourceKey: failed to open resource key %d\n",
                  GetLastError() ));
        goto Fail;
    }



    if((Status = ClusApi.pfnClusterRegOpenKey( hKeyResource,
                                               szParameters,
                                               KEY_CREATE_SUB_KEY | KEY_ALL_ACCESS,
                                               &hKey )) == ERROR_FILE_NOT_FOUND)
    {
        Status = ClusApi.pfnClusterRegCreateKey( hKeyResource,
                                                 szParameters,
                                                 0,
                                                 KEY_ALL_ACCESS,
                                                 NULL,
                                                 &hKey,
                                                 &dwDisposition );
    }

    if( Status != ERROR_SUCCESS ){

        SetLastError( Status );
        hKey = NULL;
        DBGMSG( DBG_WARN,
                ( "OpenClusterResourceKey: failed to create resource key %d\n",
                  Status ));
    }

Fail:

    if( hKeyResource ){
        ClusApi.pfnClusterRegCloseKey( hKeyResource );
    }

    if( hResource ){
        ClusApi.pfnCloseClusterResource( hResource );
    }

    if( hCluster ){
        ClusApi.pfnCloseCluster( hCluster );
    }

    return hKey;
}


/********************************************************************

    SplReg*Key functions:

    Used for printer registry access.

********************************************************************/

LONG
SplRegCreateKey(
    IN     HKEY hKey,
    IN     LPCTSTR pszSubKey,
    IN     DWORD dwOptions,
    IN     REGSAM samDesired,
    IN     PSECURITY_ATTRIBUTES pSecurityAttributes,
       OUT PHKEY phkResult,
       OUT PDWORD pdwDisposition,
    IN     PINISPOOLER pIniSpooler OPTIONAL
    )
{
    DWORD dwDisposition;
    DWORD Status;

    if( !pdwDisposition ){
        pdwDisposition = &dwDisposition;
    }

    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG )
    {

        if( !LoadClusterFunctions( ))
        {
            return GetLastError();
        }


        if((Status = ClusApi.pfnClusterRegOpenKey( hKey,
                                         pszSubKey,
                                         KEY_CREATE_SUB_KEY | samDesired,
                                         phkResult)) == ERROR_FILE_NOT_FOUND)
        {
            Status = ClusApi.pfnClusterRegCreateKey( hKey,
                                                     pszSubKey,
                                                     dwOptions,
                                                     samDesired,
                                                     pSecurityAttributes,
                                                     phkResult,
                                                     &dwDisposition );
        }
    }

    else
    {
        Status = RegCreateKeyEx( hKey,
                                 pszSubKey,
                                 0,
                                 NULL,
                                 dwOptions,
                                 samDesired,
                                 pSecurityAttributes,
                                 phkResult,
                                 &dwDisposition );
    }
    return(Status);
}

LONG
SplRegOpenKey(
    IN     HKEY hKey,
    IN     LPCTSTR pszSubKey,
    IN     REGSAM samDesired,
       OUT PHKEY phkResult,
    IN     PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegOpenKey( hKey,
                                             pszSubKey,
                                             samDesired,
                                             phkResult );
    }

    return RegOpenKeyEx( hKey,
                         pszSubKey,
                         0,
                         samDesired,
                         phkResult );
}

LONG
SplRegCloseKey(
    IN HKEY hKey,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegCloseKey( hKey );
    }

    return RegCloseKey( hKey );
}

LONG
SplRegDeleteKey(
    IN HKEY hKey,
    IN LPCTSTR pszSubKey,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegDeleteKey( hKey, pszSubKey );
    }

    return RegDeleteKey( hKey, pszSubKey );
}

LONG
SplRegEnumKey(
    IN     HKEY hKey,
    IN     DWORD dwIndex,
    IN     LPTSTR pszName,
    IN OUT PDWORD pcchName,
       OUT PFILETIME pft,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    FILETIME ft;

    if( !pft ){
        pft = &ft;
    }

    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegEnumKey( hKey,
                                             dwIndex,
                                             pszName,
                                             pcchName,
                                             pft );
    }

    return RegEnumKeyEx( hKey,
                         dwIndex,
                         pszName,
                         pcchName,
                         NULL,
                         NULL,
                         NULL,
                         pft );
}

LONG
SplRegSetValue(
    IN HKEY hKey,
    IN LPCTSTR pszValue,
    IN DWORD dwType,
    IN const BYTE* pData,
    IN DWORD cbData,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }

        //
        // ClusterRegSetValue doesn't like NULL pointers.
        //
        if( cbData == 0 ){
            pData = (PBYTE)&cbData;
        }
        return ClusApi.pfnClusterRegSetValue( hKey,
                                              pszValue,
                                              dwType,
                                              pData,
                                              cbData );
    }

    return RegSetValueEx( hKey,
                          pszValue,
                          0,
                          dwType,
                          pData,
                          cbData );
}

LONG
SplRegDeleteValue(
    IN HKEY hKey,
    IN LPCTSTR pszValue,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegDeleteValue( hKey, pszValue );
    }

    return RegDeleteValue( hKey, pszValue );
}

LONG
SplRegQueryValue(
    IN     HKEY hKey,
    IN     LPCTSTR pszValue,
       OUT PDWORD pType, OPTIONAL
       OUT PBYTE pData,
    IN OUT PDWORD pcbData,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegQueryValue( hKey,
                                                pszValue,
                                                pType,
                                                pData,
                                                pcbData );
    }

    return RegQueryValueEx( hKey,
                            pszValue,
                            NULL,
                            pType,
                            pData,
                            pcbData );
}

LONG
SplRegEnumValue(
    IN     HKEY hKey,
    IN     DWORD dwIndex,
       OUT LPTSTR pszValue,
    IN OUT PDWORD pcbValue,
       OUT PDWORD pType, OPTIONAL
       OUT PBYTE pData,
    IN OUT PDWORD pcbData,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegEnumValue( hKey,
                                               dwIndex,
                                               pszValue,
                                               pcbValue,
                                               pType,
                                               pData,
                                               pcbData );
    }

    return RegEnumValue( hKey,
                         dwIndex,
                         pszValue,
                         pcbValue,
                         NULL,
                         pType,
                         pData,
                         pcbData );
}



LONG
SplRegQueryInfoKey(
    HKEY hKey,
    PDWORD pcSubKeys,
    PDWORD pcbKey,
    PDWORD pcValues,
    PDWORD pcbValue,
    PDWORD pcbData,
    PDWORD pcbSecurityDescriptor,
    PFILETIME pftLastWriteTime,
    PINISPOOLER pIniSpooler
    )
{
    LONG rc;

    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        rc = ClusApi.pfnClusterRegQueryInfoKey( hKey,
                                                pcSubKeys,
                                                pcbKey,
                                                pcValues,
                                                pcbValue,
                                                pcbData,
                                                pcbSecurityDescriptor,
                                                pftLastWriteTime);
    } else {

        rc = RegQueryInfoKey( hKey,           // Key
                              NULL,           // lpClass
                              NULL,           // lpcbClass
                              NULL,           // lpReserved
                              pcSubKeys,      // lpcSubKeys
                              pcbKey,         // lpcbMaxSubKeyLen
                              NULL,           // lpcbMaxClassLen
                              pcValues,       // lpcValues
                              pcbValue,       // lpcbMaxValueNameLen
                              pcbData,        // lpcbMaxValueLen
                              pcbSecurityDescriptor, // lpcbSecurityDescriptor
                              pftLastWriteTime       // lpftLastWriteTime
                              );
    }

    if( pcbValue ){
        *pcbValue = ( *pcbValue + 1 ) * sizeof(WCHAR);
    }

    return rc;
}


/*++

Routine Name:

    ClusterGetResourceDriveLetter

Routine Description:

    Gets the dependent disk for a cluster resource
    (a cluster spooler resource)

Arguments:

    pszResource            - spooler resource name
    ppszClusResDriveLetter - pointer that will get the pointer to string
                             Must be freed by caller using FreeSplMem()

Return Value:

    Win32 error code

--*/
DWORD
ClusterGetResourceDriveLetter(
    IN     LPCWSTR  pszResource,
       OUT LPWSTR  *ppszClusResDriveLetter
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszResource && ppszClusResDriveLetter)
    {
        HCLUSTER    hCluster   = NULL;
        HRESOURCE   hRes       = NULL;
        LPCWSTR     pszDllName = L"resutils.dll";
        HMODULE     hModule    = NULL;
        typedef DWORD (WINAPI *PFNFINDDISK)(HCLUSTER, HRESOURCE, LPWSTR, LPDWORD);
        PFNFINDDISK pfnFindDisk;

        //
        // Don't leave the out var uninitialized
        //
        *ppszClusResDriveLetter = NULL;

        if (LoadClusterFunctions() &&
            (hCluster    = ClusApi.pfnOpenCluster(NULL)) &&
            (hRes        = ClusApi.pfnOpenClusterResource(hCluster, pszResource)) &&
            (hModule     = LoadLibrary(pszDllName)) &&
            (pfnFindDisk = (PFNFINDDISK)GetProcAddress(hModule, "ResUtilFindDependentDiskResourceDriveLetter")))
        {
            //
            // We make a guess for how large the buffer must be. We may not have to call
            // the resutil function twice. Driver letter + colon + NULL = 3
            //
            DWORD cchDriveLetter = kDriveLetterStringSize;

            dwError = ERROR_NOT_ENOUGH_MEMORY;

            if (*ppszClusResDriveLetter = AllocSplMem(cchDriveLetter * sizeof(WCHAR)))
            {
                dwError = pfnFindDisk(hCluster, hRes, *ppszClusResDriveLetter, &cchDriveLetter);

                //
                // Reallocate buffer if it was not sufficient
                //
                if (dwError == ERROR_MORE_DATA)
                {
                    FreeSplMem(*ppszClusResDriveLetter);

                    dwError = ERROR_NOT_ENOUGH_MEMORY;

                    if (*ppszClusResDriveLetter = AllocSplMem(cchDriveLetter * sizeof(WCHAR)))
                    {
                        dwError = pfnFindDisk(hCluster, hRes, *ppszClusResDriveLetter, &cchDriveLetter);
                    }
                }

                if (dwError != ERROR_SUCCESS)
                {
                    //
                    // Clean up in case of failure
                    //
                    FreeSplMem(*ppszClusResDriveLetter);
                    *ppszClusResDriveLetter = NULL;
                }
            }
        }
        else
        {
            dwError = GetLastError();
        }

        if (hCluster)
        {
            ClusApi.pfnCloseCluster(hCluster);
        }

        if (hRes)
        {
            ClusApi.pfnCloseClusterResource(hRes);
        }

        if (hModule)
        {
            FreeLibrary(hModule);
        }
    }

    DBGMSG(DBG_CLUSTER, ("ClusterGetResourceDriveLetter returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name:

    ClusterGetResourceID

Routine Description:

    Gets the resource id (guid) for a specified cluster resource.

Arguments:

    pszResource   - spooler resource name
    ppszClusResID - pointer that will get the pointer to string
                    Must be freed by caller using FreeSplMem()

Return Value:

    Win32 error code

--*/
DWORD
ClusterGetResourceID(
    IN  LPCWSTR  pszResource,
    OUT LPWSTR  *ppszClusResID
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszResource && ppszClusResID)
    {
        HCLUSTER  hCluster = NULL;
        HRESOURCE hRes     = NULL;

        *ppszClusResID = NULL;

        if (LoadClusterFunctions() &&
           (hCluster = ClusApi.pfnOpenCluster(NULL)) &&
           (hRes     = ClusApi.pfnOpenClusterResource(hCluster, pszResource)))
        {
            //
            // The resource ID is a GUID. We make a gues for its size, maybe we
            // get around calling the function ClusterResourceControl twice.
            //
            DWORD cbIDString = kGuidStringSize * sizeof(WCHAR);

            dwError = ERROR_NOT_ENOUGH_MEMORY;

            if (*ppszClusResID = AllocSplMem(cbIDString))
            {
                dwError = ClusApi.pfnClusterResourceControl(hRes,
                                                            NULL,
                                                            CLUSCTL_RESOURCE_GET_ID,
                                                            NULL,
                                                            0,
                                                            *ppszClusResID,
                                                            cbIDString,
                                                            &cbIDString);
                //
                // Reallocate buffer if it was not sufficiently large
                //
                if (dwError == ERROR_MORE_DATA)
                {
                    FreeSplMem(*ppszClusResID);

                    dwError = ERROR_NOT_ENOUGH_MEMORY;

                    if (*ppszClusResID = AllocSplMem(cbIDString ))
                    {
                        dwError = ClusApi.pfnClusterResourceControl(hRes,
                                                                    NULL,
                                                                    CLUSCTL_RESOURCE_GET_ID,
                                                                    NULL,
                                                                    0,
                                                                    *ppszClusResID,
                                                                    cbIDString,
                                                                    &cbIDString);
                    }
                }

                if (dwError != ERROR_SUCCESS)
                {
                    //
                    // Clean up in case of failure
                    //
                    FreeSplMem(*ppszClusResID);
                    *ppszClusResID = NULL;
                }
            }
        }
        else
        {
            dwError = GetLastError();
        }

        if (hRes)
        {
            ClusApi.pfnCloseClusterResource(hRes);
        }

        if (hCluster)
        {
            ClusApi.pfnCloseCluster(hCluster);
        }
    }

    DBGMSG(DBG_CLUSTER, ("ClusterGetResourceID returns Win32 error %u\n", dwError));

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\clusspl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusspl.c

Abstract:

    Cluster code support.

Author:

    Albert Ting (AlbertT) 6-Oct-96

Revision History:

--*/

#ifndef _CLUSTER_H
#define _CLUSTER_H

#ifdef __cplusplus
extern "C" {
#endif


typedef struct _CLUSTER {
    DWORD       signature;
    HANDLE      hSpooler;
} CLUSTER, *PCLUSTER;

#define CLS_SIGNATURE 0x636c73  // CLS

BOOL
ShutdownSpooler(
    HANDLE hSpooler
    );

VOID
ShutdownMonitors(
    PINISPOOLER pIniSpooler
    );

BOOL
InitializeShared(
    PINISPOOLER pIniSpooler
    );

VOID
DeleteShared(
    PINISPOOLER pIniSpooler
    );


/********************************************************************

    Cluster registry access.

********************************************************************/

HKEY
OpenClusterParameterKey(
    IN LPCTSTR pszResource
    );

LONG
SplRegCreateKey(
    IN     HKEY hKey,
    IN     LPCTSTR pszSubKey,
    IN     DWORD dwOptions,
    IN     REGSAM samDesired,
    IN     PSECURITY_ATTRIBUTES pSecurityAttirbutes,
       OUT PHKEY phkResult,
       OUT PDWORD pdwDisposition,
    IN     PINISPOOLER pIniSpooler
    );

LONG
SplRegOpenKey(
    IN     HKEY hKey,
    IN     LPCTSTR pszSubKey,
    IN     REGSAM samDesired,
       OUT PHKEY phkResult,
    IN     PINISPOOLER pIniSpooler
    );

LONG
SplRegCloseKey(
    IN HKEY hKey,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegDeleteKey(
    IN HKEY hKey,
    IN LPCTSTR pszSubKey,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegEnumKey(
    IN     HKEY hKey,
    IN     DWORD dwIndex,
       OUT LPTSTR pszName,
    IN OUT PDWORD pcchName,
       OUT PFILETIME pftLastWriteTime,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegQueryInfoKey(
    HKEY hKey,
    PDWORD pcSubKeys, OPTIONAL
    PDWORD pcbKey, OPTIONAL
    PDWORD pcValues, OPTIONAL
    PDWORD pcbValue, OPTIONAL
    PDWORD pcbData, OPTIONAL
    PDWORD pcbSecurityDescriptor, OPTIONAL
    PFILETIME pftLastWriteTime, OPTIONAL
    PINISPOOLER pIniSpooler
    );

LONG
SplRegSetValue(
    IN HKEY hKey,
    IN LPCTSTR pszValue,
    IN DWORD dwType,
    IN const BYTE* pData,
    IN DWORD cbData,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegDeleteValue(
    IN HKEY hKey,
    IN LPCTSTR pszValue,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegEnumValue(
    IN     HKEY hKey,
    IN     DWORD dwIndex,
       OUT LPTSTR pszValue,
    IN OUT PDWORD pcbValue,
       OUT PDWORD pType, OPTIONAL
       OUT PBYTE pData,
    IN OUT PDWORD pcbData,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegQueryValue(
    IN     HKEY hKey,
    IN     LPCTSTR pszValue,
       OUT PDWORD pType, OPTIONAL
       OUT PBYTE pData,
    IN OUT PDWORD pcbData,
    IN PINISPOOLER pIniSpooler
    );


/********************************************************************

    Misc changes

********************************************************************/


LPTSTR
pszGetPrinterName(
    PINIPRINTER pIniPrinter,
    BOOL bFull,
    LPCTSTR pszToken OPTIONAL
    );

BOOL
CreateDlName(
    IN      LPCWSTR         pszName,
    IN      PINIMONITOR     pIniMonitor,
    IN  OUT PWSTR           pszNameNew,
    IN      SIZE_T          cchNameNew
    );

PINIMONITOR
InitializeDMonitor(
    PINIMONITOR pIniMonitor,
    LPWSTR pszRegistryRoot
    );

VOID
InitializeUMonitor(
    PINIMONITOR pIniMonitor
    );

//
// Clustering support.
//

BOOL
SplClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
);

BOOL
SplClusterSplClose(
    HANDLE hSpooler
);

BOOL
SplClusterSplIsAlive(
    HANDLE hSpooler
);

DWORD
ClusterGetResourceDriveLetter(
    IN  LPCWSTR  pszResource,
    OUT LPWSTR  *ppszClusResDriveLetter
    );

DWORD
ClusterGetResourceID(
    IN  LPCWSTR  pszResource,
    OUT LPWSTR  *ppszClusResID
    );

#ifdef __cplusplus
}
#endif

#endif // ifdef _CLUSTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\config.h ===
/*++

Copyright (c) 1990 - 1997 Microsoft Corporation

Module Name:

    config.h

Abstract:

    Header file for multiple hardware profile support

Author:

    Muhunthan Sivapragasam  (MuhuntS)   30-Apr-97

Revision History:

--*/

#include    <setupapi.h>
#include    <initguid.h>

typedef
(WINAPI * pfSetupDiDestroyDeviceInfoList)(
    IN HDEVINFO DeviceInfoSet
    );

typedef
HDEVINFO
(WINAPI * pfSetupDiGetClassDevs)(
    IN LPGUID ClassGuid,  OPTIONAL
    IN PCSTR  Enumerator, OPTIONAL
    IN HWND   hwndParent, OPTIONAL
    IN DWORD  Flags
    );

typedef
BOOL
(WINAPI * pfSetupDiRemoveDevice)(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );

typedef
BOOL
(WINAPI * pfSetupDiOpenDeviceInfo)(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCWSTR           DeviceInstanceId,
    IN  HWND             hwndParent,       OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
    );

typedef struct  _SETUPAPI_INFO {

    HMODULE     hSetupApi;

    pfSetupDiDestroyDeviceInfoList      pfnDestroyDeviceInfoList;
    pfSetupDiGetClassDevs               pfnGetClassDevs;
    pfSetupDiRemoveDevice               pfnRemoveDevice;
    pfSetupDiOpenDeviceInfo             pfnOpenDeviceInfo;
} SETUPAPI_INFO, *PSETUPAPI_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\clusspl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusspl.c

Abstract:

    Cluster code support.

Author:

    Albert Ting (AlbertT) 1-Oct-96

Revision History:
    Khaled Sedky (Khaleds) 6-Jan-1996

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

extern PWCHAR ipszRegistryMonitors;
extern PWCHAR ipszRegistryEnvironments;
extern PWCHAR ipszRegistryEventLog;
extern PWCHAR ipszRegistryProviders;
extern PWCHAR ipszEventLogMsgFile;
extern PWCHAR ipszRegistryForms;
extern PWCHAR ipszDriversShareName;

/********************************************************************

    Prototypes

********************************************************************/

BOOL
ReallocNameList(
    IN     LPCTSTR pszName,
    IN OUT PDWORD pdwCount,
    IN OUT LPTSTR **pppszNames
    );


DWORD
AddLongNamesToShortNames(
    PCTSTR   pszNames,
    PWSTR   *ppszLongNames
);

/********************************************************************

    SplCluster functions.

********************************************************************/


BOOL
SplClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phCluster,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    )

/*++

Routine Description:

    Open a new cluster resource.

Arguments:

    pszServer - Name of the server to open--we recognize only the
        local machine (NULL, or \\server).

    pszResource - Name of resource to open.

    phCluster - Receives cluster handle.  NULL on failure.

    pszName - Name that the cluster must recognize.  Comma delimited.

    pszAddress - Address the cluster must recognize.  Comma delimited.

Return Value:

    Note: this really returns a DWORD--winsplp.h should be fixed.

    ROUTER_UNKNOWN - Unknown pszServer.
    ROUTER_SUCCESS - Successfully created.

--*/

{
    DWORD dwReturn = ROUTER_STOP_ROUTING;
    SPOOLER_INFO_2 SpoolerInfo2 = {0};
    HANDLE hSpooler = NULL;
    PCLUSTER pCluster = NULL;
    TCHAR szServer[MAX_PATH];
    PTCHAR pcMark;
    PWSTR   pszAllNames = NULL;
    DWORD Status;

    *phCluster = NULL;

    if( !MyName( (LPTSTR)pszServer, pLocalIniSpooler )){
        return ROUTER_UNKNOWN;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pLocalIniSpooler )) {

        return ROUTER_STOP_ROUTING;
    }

    //
    // Create the spooler.
    //
    if(!pszName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        return ROUTER_STOP_ROUTING;
    }

    if ((Status = StatusFromHResult(AllowRemoteCalls())) != ERROR_SUCCESS)
    {   
        SetLastError(Status);

        return ROUTER_STOP_ROUTING;
    }

    szServer[0] = szServer[1] = TEXT( '\\' );
    StringCchCopy(&szServer[2], COUNTOF( szServer ) - 2, pszName);

    //
    // Nuke trailing comma if we have one (we might have multiple names).
    //
    pcMark = wcschr( szServer, TEXT( ',' ));
    if( pcMark ){
        *pcMark = 0;
    }

    //
    // Add in the DNS names for all the provided Server names
    //
    if (AddLongNamesToShortNames(pszName, &pszAllNames) != ERROR_SUCCESS) {
        DBGMSG( DBG_WARN, ( "SplClusterSplOpen: SplCreateSpooler failed %d\n", GetLastError( )));
        goto Done;
    }

    //
    // Open the resource dll for parameter information: pDir.
    //
    //
    // In Granite, we needed to create a share path \\GroupName\print$ instead
    // of just print$, since we needed to use the GroupName, not the
    // NodeName since clients would have to reauthenticate (it's the same
    // physical machine, but it's a different name).  However, in NT 5.0,
    // we always use the name that the user passed in so we're ok.
    //
    SpoolerInfo2.pszDriversShare         = ipszDriversShareName;

    SpoolerInfo2.pDir                    = NULL;
    SpoolerInfo2.pDefaultSpoolDir        = NULL;

    SpoolerInfo2.pszRegistryMonitors     = ipszRegistryMonitors;
    SpoolerInfo2.pszRegistryEnvironments = ipszRegistryEnvironments;
    SpoolerInfo2.pszRegistryEventLog     = ipszRegistryEventLog;
    SpoolerInfo2.pszRegistryProviders    = ipszRegistryProviders;
    SpoolerInfo2.pszEventLogMsgFile      = ipszEventLogMsgFile;
    SpoolerInfo2.pszRegistryForms        = ipszRegistryForms;

    SpoolerInfo2.pszResource = (LPTSTR)pszResource;
    SpoolerInfo2.pszName     = (LPTSTR)pszAllNames;
    SpoolerInfo2.pszAddress  = (LPTSTR)pszAddress;

    SpoolerInfo2.pszEventLogMsgFile = L"%SystemRoot%\\System32\\LocalSpl.dll";
    SpoolerInfo2.SpoolerFlags = SPL_PRINTER_CHANGES                       |
                                SPL_LOG_EVENTS                            |
                                SPL_SECURITY_CHECK                        |
                                SPL_OPEN_CREATE_PORTS                     |
                                SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION   |
                                SPL_REMOTE_HANDLE_CHECK                   |
                                SPL_PRINTER_DRIVER_EVENT                  |
                                SPL_SERVER_THREAD                         |
                                SPL_PRINT                                 |
#ifndef CLS_TEST
                                SPL_CLUSTER_REG                           |
#endif
                                SPL_TYPE_CLUSTER                          |
                                SPL_TYPE_LOCAL;

    SpoolerInfo2.pfnReadRegistryExtra    = NULL;
    SpoolerInfo2.pfnWriteRegistryExtra   = NULL;
    SpoolerInfo2.pszClusResDriveLetter   = NULL;
    SpoolerInfo2.pszClusResID            = NULL;

    if ((Status = ClusterGetResourceDriveLetter(SpoolerInfo2.pszResource,
                                                &SpoolerInfo2.pszClusResDriveLetter)) != ERROR_SUCCESS ||
        (Status = ClusterGetResourceID(SpoolerInfo2.pszResource,
                                       &SpoolerInfo2.pszClusResID)) != ERROR_SUCCESS)
    {
        SetLastError( Status );
        goto Done;
    }

    DBGMSG( DBG_TRACE,
            ( "SplClusterSplOpen: Called "TSTR", "TSTR", "TSTR"\n",
              pszResource, pszName, pszAddress ));

    hSpooler = SplCreateSpooler( szServer,
                                 2,
                                 (LPBYTE)&SpoolerInfo2,
                                 NULL );

    if( hSpooler == INVALID_HANDLE_VALUE ){

        DBGMSG( DBG_WARN,
                ( "SplClusterSplOpen: SplCreateSpooler failed %d\n",
                  GetLastError( )));

        goto Done;
    }

    pCluster = (PCLUSTER)AllocSplMem( sizeof( CLUSTER ));

    if( pCluster ){

        pCluster->signature = CLS_SIGNATURE;
        pCluster->hSpooler = hSpooler;

        *phCluster = (HANDLE)pCluster;
        dwReturn = ROUTER_SUCCESS;
    }

    //
    // Reshareout the printers.
    //
    FinalInitAfterRouterInitComplete(
        0,
        (PINISPOOLER)hSpooler
        );

    CHECK_SCHEDULER();

Done:

    //
    // On failure, cleanup everything.
    //

    FreeSplMem(pszAllNames);
    FreeSplMem(SpoolerInfo2.pszClusResDriveLetter);
    FreeSplMem(SpoolerInfo2.pszClusResID);

    if( dwReturn != ROUTER_SUCCESS ){

        if( hSpooler && hSpooler != INVALID_HANDLE_VALUE ){

            ShutdownSpooler( hSpooler );
        }
        FreeSplMem( *phCluster );
    }

    return dwReturn;
}

BOOL
SplClusterSplClose(
    HANDLE hCluster
    )

/*++

Routine Description:

    Shut down a cluster.

Arguments:

    hCluster - Cluster to close.

Return Value:

    TRUE - Success

    FALSE - Failed, LastError set.

--*/

{
    BOOL bStatus;
    PCLUSTER pCluster = (PCLUSTER)hCluster;

    DBGMSG( DBG_TRACE, ( "SplClusterSplClose: Called close\n" ));

    //
    // Close the spooler
    //

    DBGMSG( DBG_TRACE, ( "SplClusterSplClose: close %x\n", hCluster ));

    SPLASSERT( pCluster->signature == CLS_SIGNATURE );

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pCluster->hSpooler )) {

        return ROUTER_STOP_ROUTING;
    }

    ShutdownSpooler( pCluster->hSpooler );

    //
    // Atttempt to delete the spooler.  This is reference counted so
    // it may take a while to complete.  We do this before we close the
    // spooler, because deleting the spooler requires a reference
    // to it.  Once we close the handle, we don't have access to it.
    // (It may be deleted during the close call if it was the last
    // reference and it was marked pending deletion).
    //
    EnterSplSem();
    SplDeleteSpooler( pCluster->hSpooler );
    LeaveSplSem();

    SplCloseSpooler( pCluster->hSpooler );

    FreeSplMem( hCluster );

    return TRUE;
}

BOOL
SplClusterSplIsAlive(
    HANDLE hCluster
    )
{
    DBGMSG( DBG_TRACE, ( "SplClusterSplIsAlive: Called IsAlive\n" ));

    EnterSplSem();
    LeaveSplSem();

    return TRUE;
}



/********************************************************************

    Internal support routines.

********************************************************************/


BOOL
ShutdownSpooler(
    HANDLE hSpooler
    )

/*++

Routine Description:

    Cleanly shuts down a PINISPOOLER

Arguments:

    hSpooler - Spooler to shut down.

Return Value:

--*/


{
    PINISPOOLER pIniSpooler = (PINISPOOLER)hSpooler;
    PINISPOOLER pCurrentIniSpooler;
    PINIPRINTER pIniPrinter;
    PINIPRINTER pIniPrinterNext;
    HANDLE hEvent;
    BOOL bStatus = FALSE;
    PSPOOL pSpool;
    PINIPORT pIniPort;

    SPLASSERT( hSpooler );
    DBGMSG( DBG_TRACE, ( "ShutdownSpooler: called %x\n", hSpooler ));

    EnterSplSem();

    //
    // First set the spooler offline so no more jobs get scheduled.
    //
    pIniSpooler->SpoolerFlags |= SPL_OFFLINE;

    //
    // If there are jobs printing, wait until they are completed.
    //
    if( pIniSpooler->cFullPrintingJobs ){

        hEvent = CreateEvent(NULL,
                             EVENT_RESET_AUTOMATIC,
                             EVENT_INITIAL_STATE_NOT_SIGNALED,
                             NULL);

        if( !hEvent ){
            pIniSpooler->SpoolerFlags &= ~SPL_OFFLINE;
            goto DoneLeave;
        }

        pIniSpooler->hEventNoPrintingJobs = hEvent;

        LeaveSplSem();
        WaitForSingleObject( hEvent, pIniSpooler->dwJobCompletionTimeout );
        EnterSplSem();
    }

    //
    // No printing jobs anymore.  Disable updating shadow job/printer
    // updates and stop logging/notifications.
    //
    pIniSpooler->SpoolerFlags |= SPL_NO_UPDATE_JOBSHD |
                                 SPL_NO_UPDATE_PRINTERINI;
    pIniSpooler->SpoolerFlags &= ~( SPL_LOG_EVENTS |
                                    SPL_PRINTER_CHANGES );

    //
    // Zombie all spool handles.
    //
    for( pSpool = pIniSpooler->pSpool; pSpool; pSpool = pSpool->pNext ){
        pSpool->Status |= SPOOL_STATUS_ZOMBIE;

        //
        // !! LATER !!
        //
        // Close notifications so that the client refreshes.
        //
    }

    for( pIniPrinter = pIniSpooler->pIniPrinter;
         pIniPrinter;
         pIniPrinter = pIniPrinterNext ){

        //
        // Purge and delete all printers.  This will clean up the memory
        // but leave everything intact since we've requested that the
        // changes aren't persistant (SPL_NO_UPDATE flags).
        //

        pIniPrinter->cRef++;
        PurgePrinter( pIniPrinter );
        SPLASSERT( pIniPrinter->cRef );
        pIniPrinter->cRef--;
        pIniPrinterNext = pIniPrinter->pNext;

        InternalDeletePrinter( pIniPrinter );
    }

    //
    // Even if a job was paused, the purge printer will have deleted
    // it.  Since we set SPL_NO_UPDATE_JOBSHD this job will get restarted
    // on the other node.
    //
    // We still want to wait until this job finshes, however, otherwise
    // the port will be in a bad state.
    //
    if( pIniSpooler->cFullPrintingJobs ){

        LeaveSplSem();
        WaitForSingleObject( pIniSpooler->hEventNoPrintingJobs, INFINITE );
        EnterSplSem();
    }

    for( pIniPrinter = pIniSpooler->pIniPrinter;
         pIniPrinter;
         pIniPrinter = pIniPrinterNext ){

        //
        // Zombie print handles.
        //
        for( pSpool = pIniPrinter->pSpool; pSpool; pSpool = pSpool->pNext ){
            pSpool->Status |= SPOOL_STATUS_ZOMBIE;

            //
            // !! LATER !!
            //
            // Close notifications so that the client refreshes.
            //
        }
    }


    if( pIniSpooler->hEventNoPrintingJobs ){

        CloseHandle( pIniSpooler->hEventNoPrintingJobs );
        pIniSpooler->hEventNoPrintingJobs = NULL;
    }

    //
    // N.B. Spooling jobs get nuked when the rundown occurs.
    //

    //
    // Leave it linked on the spooler.  When there are no more jobs, the
    // port thread relies on the scheduler thread to kill it, so we
    // can't remove the pIniSpooler from the master list.
    //
    bStatus = TRUE;

DoneLeave:

    LeaveSplSem();

    return bStatus;
}


PINISPOOLER
FindSpooler(
    LPCTSTR pszMachine,
    DWORD SpoolerFlags
    )

/*++

Routine Description:

    Look for a spooler based on machine name and type.

Arguments:

    pszMachineName - "\\Machine" formatted string.

    SpoolerFlags - The spooler matches only if it has at least one
        of the SPL_TYPE bits on specified by SpoolerFlags.

Return Value:

    PINISPOOLER - Match.

    NULL - no Match.

--*/

{
    PINISPOOLER pIniSpooler;

    if( !pszMachine ){
        return NULL;
    }

    SplInSem();

    //
    // Search clustered spoolers first, since we don't want to
    // since using the tcpip address will match pLocalIniSpooler.
    //
    for( pIniSpooler = pLocalIniSpooler->pIniNextSpooler;
         pIniSpooler;
         pIniSpooler = pIniSpooler->pIniNextSpooler ){

        //
        // Verify flags and ensure not pending deletion.
        //
        if( (pIniSpooler->SpoolerFlags & SpoolerFlags & SPL_TYPE ) &&
            !(pIniSpooler->SpoolerFlags & SPL_PENDING_DELETION )){

            //
            // Verify the name.
            //
            if( MyName( (LPTSTR)pszMachine, pIniSpooler )){
                break;
            }
        }
    }

    //
    // Check Localspl.
    //
    //
    // Verify flags.
    //
    if( !pIniSpooler && pLocalIniSpooler &&
        ( pLocalIniSpooler->SpoolerFlags & SpoolerFlags & SPL_TYPE )){

        //
        // Verify the name.
        //
        if( MyName( (LPTSTR)pszMachine, pLocalIniSpooler )){
            pIniSpooler = pLocalIniSpooler;
        }
    }

    return pIniSpooler;
}

BOOL
InitializeShared(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Initialize the shared component of the pIniSpooler.

    When a SPL_TYPE_LOCAL printer is created, we use the shared
    resources from the pLocalIniSpooler.  However, this is not
    reference counted.  When pLocalIniSpooler is deleted, the
    shared resources are too.

Arguments:

    pIniSpooler - Object->pShared to initialize.

Return Value:

    TRUE - Success

    FALSE - Failed, LastError set.

--*/

{
    SPLASSERT( pIniSpooler->SpoolerFlags );

    //
    // If it's SPL_TYPE_LOCAL, it should use the shared resources, unless
    // this is the first one and we haven't set them up yet.
    //
    if(( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ) && pLocalIniSpooler ){

        //
        // Use the shared one.
        //
        pIniSpooler->pShared = pLocalIniSpooler->pShared;

    } else {

       PSHARED pShared = (PSHARED)AllocSplMem( sizeof( SHARED ));

       if( !pShared ){
           return FALSE;
       }

       pIniSpooler->pShared = pShared;
    }

    return TRUE;
}

VOID
DeleteShared(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Cleanup after the InitializeShared call.

    Note: pShared is not a reference counted structure.  If it is not
    shared, then we immediately free it.  If it is shared, we assume
    that it's owned by pLocalIniSpooler only.  Also, this implies that
    pLocalIniSpooler is always deleted last.

Arguments:

    pIniSpooler - Object->pShared to Cleanup.

Return Value:

--*/

{
    //
    // Free if it's not shared.
    //
    if( pIniSpooler == pLocalIniSpooler ||
        !(pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL )){

        FreeSplMem( pIniSpooler->pShared );
        pIniSpooler->pShared = NULL;
    }
}

VOID
ShutdownMonitors(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Shutdown all the monitors and free pIniMonitor functions.

Arguments:

    pIniSpooler - Spooler to shut down.

Return Value:

--*/

{
    PINIMONITOR pIniMonitor;
    PINIMONITOR pIniMonitorNext;
    PINIPORT pIniPort;
    PINIPORT pIniPortNext;

    SplInSem();

    //
    // Every monitor must have a shutdown function.  They must only mark
    // themselves pending deletion--they must not wait for resources to
    // close.
    //
    for( pIniMonitor = pIniSpooler->pIniMonitor;
         pIniMonitor;
         pIniMonitor = pIniMonitorNext ){

        pIniMonitorNext = pIniMonitor->pNext;

        LeaveSplSem();
        SplOutSem();

        DBGMSG( DBG_TRACE,
                ( "ShutdownMonitors: closing %x %x on %x\n",
                  pIniMonitor, pIniMonitor->hMonitor, pIniSpooler ));

        (*pIniMonitor->Monitor2.pfnShutdown)( pIniMonitor->hMonitor );

        EnterSplSem();
    }
}

PINISPOOLER
FindSpoolerByNameIncRef(
    LPTSTR pName,
    LPCTSTR *ppszLocalName OPTIONAL
    )

/*++

Routine Description:

    Searches for a spooler by name and increments the refcount if one
    is found.

    NOTE: The callee is responsible for calling FindSpoolerByNameDecRef()
    if the retur nvalue is non-NULL.

Arguments:

    pName - Name to search on.

    ppszLocalName - Returns local name (optional).

Return Value:

    PINISPOOLER - IncRef'd pIniSpooler
    NULL

--*/

{
    PINISPOOLER pIniSpooler;

    if (!IsThreadInSem(GetCurrentThreadId()))
    {
        //
        // At this time we do not know if the server name in pName refers to our local
        // machine. We are trying to add the server name to the name cache. The name
        // cache functions decide if the name refers to the local machine and if positive,
        // add an entry for it in the cache.
        //
        CacheAddName(pName);
    }

    EnterSplSem();

    pIniSpooler = FindSpoolerByName( pName, ppszLocalName );
    if( pIniSpooler ){
        INCSPOOLERREF( pIniSpooler );
    }

    LeaveSplSem();

    return pIniSpooler;
}

VOID
FindSpoolerByNameDecRef(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Matching call to FindSpoolerByNameIncRef.

Arguments:

    pIniSpooler - Spooler to derement; can be NULL.

Return Value:

--*/

{
    EnterSplSem();

    if( pIniSpooler ){
        DECSPOOLERREF( pIniSpooler );
    }
    LeaveSplSem();
}


PINISPOOLER
FindSpoolerByName(
    LPTSTR pszName,
    LPCTSTR *ppszLocalName OPTIONAL
    )

/*++

Routine Description:

    Search for the right pIniSpooler based on name.

Arguments:

    pszName - Name, either a server or printer.  This string is
        modified then restored.

    ppszLocalName - Optional; receives local name of the printer.
        If pszName is a remote name (e.g., "\\server\Printer"),
        then *ppszLocalName receives the local name (e.g., "Printer").
        This is a pointer into pszName.  If pszName is a local name,
        then ppszLocalName points to pszName.

Return Value:

    PINISPOOLER pIniSpooler found.
    NULL not found.

--*/

{
    PINISPOOLER pIniSpooler = NULL;
    PTCHAR pcMark = NULL;

    SplInSem();

    if( ppszLocalName ){
        *ppszLocalName = pszName;
    }

    //
    // Search for right spooler.
    //
    if( !pszName ){
        return pLocalIniSpooler;
    }


    //
    // If it's in the format \\server\printer or \\server,
    // then we need to look for various spoolers.  If it doesn't
    // start with \\, then it's always on the local machine.
    //
    if( pszName[0] == L'\\' &&
        pszName[1] == L'\\' ){

        if( pcMark = wcschr( &pszName[2], L'\\' )){
            *pcMark = 0;
        }

        EnterSplSem();
        pIniSpooler = FindSpooler( pszName, SPL_TYPE_LOCAL );
        LeaveSplSem();

        if( pcMark ){
            *pcMark = L'\\';

            if( ppszLocalName ){
                *ppszLocalName = pcMark + 1;
            }
        }

    } else {

        pIniSpooler = pLocalIniSpooler;
    }

    return pIniSpooler;
}

HRESULT
BuildIPArrayFromCommaList(
    LPTSTR   pszCommaList,
    LPWSTR **pppszNames,
    DWORD   *pcNames
    )

/*++

Routine Description:

    Add to the list of other names from a comma delimited list.

Arguments:

    pszCommaList - List of names to add.  This string is modifed and
        restored.

    pppszNames   - pointer where to treturn the pointer to array of strings
    pcNames      - number of strings in *ppszNames

Return Value:

--*/

{
    HRESULT hRetval = E_INVALIDARG;

    if (pszCommaList && pcNames && pppszNames)
    {
        UINT   cchLen;
        LPTSTR pcMark;

        hRetval     = S_OK;
        *pcNames    = 0;
        *pppszNames = NULL;

        while (pszCommaList && *pszCommaList)
        {
            //
            // Skip commas.
            //
            if (*pszCommaList == TEXT(','))
            {
                ++pszCommaList;
                continue;
            }

            //
            // We have a name.  Search for comma.
            //
            pcMark = wcschr( pszCommaList, TEXT( ',' ));

            //
            // If we found a comma, then delimit it.  Note that we're changing
            // the input buffer, but we'll restore it later.  Can have bad
            // effects if the buffer is not writable or accessed by other threads.
            //
            if( pcMark )
            {
                *pcMark = 0;
            }

            hRetval = ReallocNameList(pszCommaList, pcNames, pppszNames) ? S_OK : E_OUTOFMEMORY;

            if( pcMark )
            {
                *pcMark = TEXT( ',' );
                ++pcMark;
            }

            //
            // Skip past this name.
            //
            pszCommaList = pcMark;
        }
    }

    return hRetval;
}

BOOL
ReallocNameList(
    IN     LPCTSTR pszName,
    IN OUT PDWORD pdwCount,
    IN OUT LPTSTR **pppszNames
    )

/*++

Routine Description:

    Adds new name to vector of strings.

Arguments:

    pszName - New name to add.

    pdwCount - Count of names.  On successful exit, incremented by 1.

    pppszNames - Pointer to address of string vector.  This is freed and
        reallocated to hold a new name.

Return Value:

    TRUE - Success.  *pdwCount and *pppszNames updated.

    FALSE - Failed.  Nothing changd.

--*/

{
    LPTSTR pszNameBuf = AllocSplStr( (LPTSTR)pszName );
    LPTSTR *ppszNamesBuf = AllocSplMem(( *pdwCount + 1 ) * sizeof( LPTSTR ));

    if( !pszNameBuf || !ppszNamesBuf ){
        goto Fail;
    }

    //
    // Copy the name and existing pointers.
    //
    CopyMemory(ppszNamesBuf, *pppszNames, *pdwCount * sizeof(LPTSTR));

    //
    // Update the vector and increment the count.
    //
    ppszNamesBuf[ *pdwCount ] = pszNameBuf;
    ++(*pdwCount);

    //
    // Free the old pointer buffer and use the new one.
    //
    FreeSplMem( *pppszNames );
    *pppszNames = ppszNamesBuf;

    return TRUE;

Fail:

    FreeSplStr( pszNameBuf );
    FreeSplMem( ppszNamesBuf );

    return FALSE;
}

LPTSTR
pszGetPrinterName(
    PINIPRINTER pIniPrinter,
    BOOL bFull,
    LPCTSTR pszToken OPTIONAL
    )
{
    INT cchLen;
    LPTSTR pszPrinterName;

    cchLen = lstrlen( pIniPrinter->pName ) +
             lstrlen( pIniPrinter->pIniSpooler->pMachineName ) + 2;

    if( pszToken ){

        cchLen += lstrlen( pszToken ) + 1;
    }

    pszPrinterName = AllocSplMem( cchLen * sizeof( pszPrinterName[0] ));

    if( pszPrinterName ){

        if( pszToken ){

            if( bFull ){
                StringCchPrintf(pszPrinterName,
                                cchLen,
                                L"%s\\%s,%s",
                                pIniPrinter->pIniSpooler->pMachineName,
                                pIniPrinter->pName,
                                pszToken);
            } else {

                StringCchPrintf(pszPrinterName,
                                cchLen,
                                L"%s,%s",
                                pIniPrinter->pName,
                                pszToken);
            }
        } else {

            if( bFull ){
                StringCchPrintf(pszPrinterName,
                                cchLen,
                                L"%s\\%s",
                                pIniPrinter->pIniSpooler->pMachineName,
                                pIniPrinter->pName );
            } else {

                StringCchCopy(pszPrinterName, cchLen, pIniPrinter->pName );
            }
        }

        SPLASSERT( lstrlen( pszPrinterName ) < cchLen );
    }

    return pszPrinterName;
}


VOID
DeleteSpoolerCheck(
    PINISPOOLER pIniSpooler
    )
{
    SplInSem();

    if( pIniSpooler->cRef == 0 &&
        ( pIniSpooler->SpoolerFlags & SPL_PENDING_DELETION )){

        SplDeleteSpooler( pIniSpooler );
    }
}

DWORD
AddLongNamesToShortNames(
    PCTSTR   pszShortNameDelimIn,
    PWSTR   *ppszAllNames
)
/*++

Routine Description:

    Add a list of comma delimited dns (long) names to a given list of comma delimited short names.

Arguments:

    pszShortNameDelimIn - Input list of comma delimited short names

    ppszAllNames - Output list of short plus long names, comma delimited.

Return Value:

--*/
{
    PSTRINGS    pLongName = NULL;
    PSTRINGS    pShortName = NULL;
    PWSTR        pszLongNameDelim = NULL;
    PWSTR        pszShortNameDelim = NULL;
    DWORD        dwRet = ERROR_SUCCESS;

    *ppszAllNames = NULL;

    // Clean up redundant delimiters, if any
    pszShortNameDelim = FixDelim(pszShortNameDelimIn, L',');
    if (!pszShortNameDelim) {
        dwRet = GetLastError();
        goto error;
    }

    if (!*pszShortNameDelim) {
        *ppszAllNames = AllocSplStr((PWSTR) pszShortNameDelim);

    } else {

        // Convert comma separated short names to array of names
        pShortName = DelimString2Array(pszShortNameDelim, L',');
        if (!pShortName) {
            dwRet = GetLastError();
            goto error;
        }

        // Get long name array from short names
        pLongName = ShortNameArray2LongNameArray(pShortName);
        if (!pLongName) {
            dwRet = GetLastError();
            goto error;
        }

        // Convert long name array to comma separated string
        pszLongNameDelim = Array2DelimString(pLongName, L',');
        if (pszLongNameDelim) {
            DWORD cchAllNames = 0;

            cchAllNames = wcslen(pszLongNameDelim) + wcslen(pszShortNameDelim) + 2;

            // Concatenate short & long name arrays
            *ppszAllNames = (PWSTR) AllocSplMem(cchAllNames*sizeof(WCHAR));
            if (!*ppszAllNames) {
                dwRet = GetLastError();
                goto error;
            }

            StringCchPrintf(*ppszAllNames, cchAllNames, L"%s,%s", pszShortNameDelim, pszLongNameDelim);

        } else {
            *ppszAllNames = AllocSplStr((PWSTR) pszShortNameDelim);
        }
    }

error:

    FreeStringArray(pShortName);
    FreeStringArray(pLongName);
    FreeSplMem(pszLongNameDelim);
    FreeSplMem(pszShortNameDelim);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\config.c ===
/*++

Copyright (c) 1996 - 1998  Microsoft Corporation

Module Name:

    config.c

Abstract:

    Routines to do multiple hardware profile support for printing

Author:

    Muhunthan Sivapragasam (MuhuntS) 07-Nov-96 (Rewrite from Win95)

Revision History:


--*/

#include    <precomp.h>
#include    "config.h"
#include    "clusspl.h"
#include    <devguid.h>

#define     CM_REGSITRY_CONFIG      0x00000200

WCHAR   cszPnPKey[]             = L"PnPData";
WCHAR   cszPrinter[]            = L"Printer";
WCHAR   cszPrinterOnLine[]      = L"PrinterOnLine";
WCHAR   cszDeviceInstanceId[]   = L"DeviceInstanceId";

WCHAR   cszRegistryConfig[]     = L"System\\CurrentControlSet\\Hardware Profiles\\";



BOOL
LoadSetupApiDll(
    PSETUPAPI_INFO  pSetupInfo
    )
{
    UINT    uOldErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    pSetupInfo->hSetupApi = LoadLibrary(L"setupapi");
    SetErrorMode(uOldErrMode);


    if ( !pSetupInfo->hSetupApi )
        return FALSE;

    (FARPROC) pSetupInfo->pfnDestroyDeviceInfoList
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiDestroyDeviceInfoList");

    (FARPROC) pSetupInfo->pfnGetClassDevs
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiGetClassDevsA");

    (FARPROC) pSetupInfo->pfnRemoveDevice
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiRemoveDevice");

    (FARPROC) pSetupInfo->pfnOpenDeviceInfo
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiOpenDeviceInfoW");

    if ( !pSetupInfo->pfnDestroyDeviceInfoList      ||
         !pSetupInfo->pfnGetClassDevs               ||
         !pSetupInfo->pfnRemoveDevice               ||
         !pSetupInfo->pfnOpenDeviceInfo ) {

        FreeLibrary(pSetupInfo->hSetupApi);
        pSetupInfo->hSetupApi = NULL;
        return FALSE;
    }

    return TRUE;
}



BOOL
DeletePrinterDevNode(
    LPWSTR  pszDeviceInstanceId
    )
{
    BOOL                bRet = FALSE;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA     DevData;
    SETUPAPI_INFO       SetupInfo;
    HANDLE              UserToken;

    if ( !LoadSetupApiDll(&SetupInfo) )
        return FALSE;

    UserToken = RevertToPrinterSelf();

    hDevInfo = SetupInfo.pfnGetClassDevs((LPGUID)&GUID_DEVCLASS_PRINTER,
                                         NULL,
                                         INVALID_HANDLE_VALUE,
                                         0);

    if ( hDevInfo == INVALID_HANDLE_VALUE )
        goto Cleanup;

    DevData.cbSize = sizeof(DevData);
    if ( SetupInfo.pfnOpenDeviceInfo(hDevInfo,
                                     pszDeviceInstanceId,
                                     INVALID_HANDLE_VALUE,
                                     0,
                                     &DevData) ) {

        bRet = SetupInfo.pfnRemoveDevice(hDevInfo, &DevData);
    }

Cleanup:

    if ( hDevInfo != INVALID_HANDLE_VALUE )
        SetupInfo.pfnDestroyDeviceInfoList(hDevInfo);

    if (!ImpersonatePrinterClient(UserToken))
    {
        DBGMSG(DBG_ERROR, ("DeletePrinterDevNode: ImpersonatePrinterClient Failed. Error %d\n", GetLastError()));
    }

    FreeLibrary(SetupInfo.hSetupApi);

    return bRet;
}


LPWSTR
GetPrinterDeviceInstanceId(
    PINIPRINTER     pIniPrinter
    )
{
    WCHAR   buf[MAX_PATH];
    DWORD   dwType, cbNeeded, dwReturn;
    HKEY    hKey = NULL;
    LPWSTR  pszDeviceInstanceId = NULL;

    SplInSem();
    cbNeeded = sizeof(buf);

    if ( ERROR_SUCCESS == OpenPrinterKey(pIniPrinter,
                                         KEY_READ,
                                         &hKey,
                                         cszPnPKey,
                                         TRUE)                          &&
         ERROR_SUCCESS == SplRegQueryValue(hKey,
                                           cszDeviceInstanceId,
                                           &dwType,
                                           (LPBYTE)buf,
                                           &cbNeeded,
                                           pIniPrinter->pIniSpooler)    &&
         dwType == REG_SZ ) {

        pszDeviceInstanceId = AllocSplStr(buf);
    }

    if ( hKey )
        SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);

    return pszDeviceInstanceId;
}


BOOL
DeleteIniPrinterDevNode(
    PINIPRINTER     pIniPrinter
    )
{
    BOOL    bRet = FALSE;
    LPWSTR  pszStr = GetPrinterDeviceInstanceId(pIniPrinter);

    if ( pszStr ) {

        bRet = DeletePrinterDevNode(pszStr);
        FreeSplStr(pszStr);
    }

    return bRet;
}


VOID
SplConfigChange(
    )
{
    PINIPRINTER     pIniPrinter     = NULL;
    BOOL            bCheckScheduler = FALSE;
    HKEY            hConfig         = NULL;
    HKEY            hKey;
    DWORD           dwOnline, dwType, cbNeeded;

    EnterSplSem();

    //
    // If we have no printers which are offline then we would not have
    // created the key at all
    //
    if ( RegCreateKeyEx(HKEY_CURRENT_CONFIG,
                        ipszRegistryPrinters,
                        0,
                        NULL,
                        0,
                        KEY_READ,
                        NULL,
                        &hConfig,
                        NULL) )
        goto Cleanup;

    for ( pIniPrinter = pLocalIniSpooler->pIniPrinter ;
          pIniPrinter ;
          pIniPrinter = pIniPrinter->pNext ) {

        //
        // Don't consider printers that have invalid ports, these must always
        // stay offline until this is resolved. If the user explicitely turns
        // the port online, that is up to them.
        //
        UINT    i = 0;

        //
        // If pIniPrinter->ppIniPorts is NULL, cPorts would be zero.
        //
        for(i = 0; i < pIniPrinter->cPorts; i++) {

            if (pIniPrinter->ppIniPorts[i]->Status & PP_PLACEHOLDER) {
                break;
            }
        }

        //
        // If we reached the end of the list, none of the ports were
        // placeholders. If we didn't go onto the next one.
        //
        if (i < pIniPrinter->cPorts) {

            continue;
        }

        if ( RegOpenKeyEx(hConfig,
                          pIniPrinter->pName,
                          0,
                          KEY_READ,
                          &hKey) )
            continue; // to next printer

        cbNeeded = sizeof(dwOnline);
        if ( ERROR_SUCCESS == SplRegQueryValue(hKey,
                                               cszPrinterOnLine,
                                               &dwType,
                                               (LPBYTE)&dwOnline,
                                               &cbNeeded,
                                               NULL) ) {
            if ( dwOnline ) {

                //
                // If any printers which are offline in current config
                // become online in the new config then we need to trigger
                // the scheduler
                //
                if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE ) {

                    pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_WORK_OFFLINE;
                    bCheckScheduler = TRUE;
                }

            } else {

                pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_WORK_OFFLINE;
            }
        }

        RegCloseKey(hKey);
    }

    if ( bCheckScheduler )
        CHECK_SCHEDULER();

Cleanup:
    LeaveSplSem();

    if ( hConfig )
        RegCloseKey(hConfig);
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DeletePrinterInAllConfigs

Routine Description:

    Deletes a pIniPrinter from all the hardware profiles.

Arguments:

    pIniPrinter - Printer to delete.

Return Value:

    BOOL, TRUE = success, FALSE = FAILUER

Last Error:

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

BOOL
DeletePrinterInAllConfigs(
    PINIPRINTER pIniPrinter
    )
{
    HKEY hConfig;
    WCHAR szSubKey[2 * MAX_PATH];
    DWORD Config;
    DWORD Size;
    DWORD Status;

    SplInSem();

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          cszRegistryConfig,
                          0,
                          KEY_READ | KEY_WRITE | DELETE,
                          &hConfig);

    if (Status != ERROR_SUCCESS)
    {
        DBGMSG(DBG_WARN, ("DeletePrinterInAllConfigs: RegOpenKey failed %d\n", Status));
    }
    else
    {
        DWORD RegPrintersLen = wcslen(ipszRegistryPrinters);
        for (Config = 0;

             Size = (DWORD)(COUNTOF(szSubKey) - ( RegPrintersLen + wcslen(pIniPrinter->pName) +2)) ,
             (Status = RegEnumKeyEx(hConfig,
                                    Config,
                                    szSubKey,
                                    &Size,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL)) == ERROR_SUCCESS;

             ++Config)
        {
            StrNCatBuff(szSubKey, COUNTOF(szSubKey), L"\\", ipszRegistryPrinters, L"\\", pIniPrinter->pName, NULL);

            Status = RegDeleteKey(hConfig, szSubKey);

            if (Status != ERROR_SUCCESS &&
                Status != ERROR_FILE_NOT_FOUND)
            {
                DBGMSG( DBG_WARN, ("DeletePrinterInAllConfigs: RegDeleteKey failed %d\n", Status));
            }
        }

        if (Status != ERROR_NO_MORE_ITEMS)
        {
            DBGMSG(DBG_WARN, ("DeletePrinterInAllConfigs: RegEnumKey failed %d\n", Status));
        }

        RegCloseKey(hConfig);
    }

    return TRUE;
}


BOOL
WritePrinterOnlineStatusInCurrentConfig(
    PINIPRINTER     pIniPrinter
    )
{
    HKEY                hKey = NULL;
    DWORD               dwOnline, dwReturn;
    WCHAR               szKey[2 * MAX_PATH];
    HANDLE              hToken;

    SplInSem();

    hToken = RevertToPrinterSelf();

    StrNCatBuff(szKey, COUNTOF(szKey), ipszRegistryPrinters, L"\\", pIniPrinter->pName, NULL);

    dwOnline = (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE)
                            ? 0 : 1;

    dwReturn = RegCreateKeyEx(HKEY_CURRENT_CONFIG,
                              szKey,
                              0,
                              NULL,
                              0,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              NULL);

    if ( dwReturn == ERROR_SUCCESS )
        dwReturn = RegSetValueEx(hKey,
                                 cszPrinterOnLine,
                                 0,
                                 REG_DWORD,
                                 (LPBYTE)&dwOnline,
                                 sizeof(DWORD));

    if ( hKey )
        RegCloseKey(hKey);

    ImpersonatePrinterClient(hToken);

    return dwReturn == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\copyfile.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    copyfile.c

Abstract:

    InternalCopyFile - Copies a file retaining time and attributes

Author:

    Matthew A Felton

Revision History:

    Matthew Felton (mattfe) 27 March 1995

--*/


#include <precomp.h>

#define FILE_SHARE_EXCLUSIVE 0
#define BUFFER_SIZE     4096

BOOL
InternalCopyFile(
    HANDLE  hSourceFile,
    PWIN32_FIND_DATA pSourceFileData,
    LPWSTR  lpNewFileName,
    BOOL    bFailIfExists
    )

/*++

Routine Description:


Arguments:

    hSourceFile - SourceFile Handle

    pSourceFileData - Pointer to WIN32_FIND_DATA for the source file

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    bFailIfExists - Supplies a flag that indicates how this operation is
        to proceed if the specified new file already exists.  A value of
        TRUE specifies that this call is to fail.  A value of FALSE
        causes the call to the function to succeed whether or not the
        specified new file exists.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    DWORD       dwSourceFileAttributes;
    BOOL        bReturnValue = FALSE;
    HANDLE      hTargetFile = INVALID_HANDLE_VALUE;
    DWORD       dwLowFileSize, dwHighFileSize;
    LPVOID      pBuffer;
    DWORD       cbBufferSize = BUFFER_SIZE;
    DWORD       cbBytesRead;
    DWORD       cbBytesWritten;
    DWORD       dwSourceFilePointer;

    DWORD       dwTargetFileAttributes;

    SPLASSERT( hSourceFile != NULL &&
               hSourceFile != INVALID_HANDLE_VALUE &&
               pSourceFileData != NULL &&
               lpNewFileName != NULL );


#if DBG
    //  <<<<< DEBUG ONLY >>>>>>
    //
    //  ASSERTION Check Source File Pointer is Zero.
    //
    dwSourceFilePointer = SetFilePointer( hSourceFile, 0, NULL, FILE_CURRENT );
    if ( dwSourceFilePointer != 0xffffffff ) {
        SPLASSERT( dwSourceFilePointer == 0 );
    }
#endif // DBG


    //
    //  Alloc I/O Buffer
    //


    pBuffer = AllocSplMem( BUFFER_SIZE );
    if ( pBuffer == NULL )
        goto    InternalCopyFileExit;


    //
    //  Create TagetFile with same File Attributes except for READ ONLY attribute
    //  which must be cleared.
    //
    dwTargetFileAttributes = pSourceFileData->dwFileAttributes & ~FILE_ATTRIBUTE_READONLY;
    if (pSourceFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
    {
        //
        // Clear the READ ONLY attribute if the corresponding source file attribute
        // is set. In fact at that point we don't know if the target file exists and
        // that is the reason to ignore the value returned by SetFileAttributes.
        // The file shouldn't exist on Whistler because of the dwTargetFileAttributes
        // value where the READ ONLY flag is cleared. There are slim chances to be there 
        // if the machine was upgraded from W2K ( where the bug still exists) if on that 
        // machine the driver was ever installed. 
        //
        SetFileAttributes( lpNewFileName, dwTargetFileAttributes );
    }

    hTargetFile = CreateFile( lpNewFileName,
                               GENERIC_WRITE,
                               FILE_SHARE_EXCLUSIVE,
                               NULL,
                               bFailIfExists ? CREATE_NEW : CREATE_ALWAYS,
                               dwTargetFileAttributes | FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL );

    if ( hTargetFile != INVALID_HANDLE_VALUE ) {

        //
        //  Copy The Data
        //

        while (( bReturnValue = ReadFile( hSourceFile, pBuffer, cbBufferSize, &cbBytesRead, NULL )) &&
                 cbBytesRead != 0 ) {

            //
            //  Add Code to Build CheckSum Here
            //

            bReturnValue = WriteFile( hTargetFile, pBuffer, cbBytesRead, &cbBytesWritten, NULL );

            if ( bReturnValue  == FALSE  ||
                 cbBytesWritten != cbBytesRead ) {

                bReturnValue = FALSE;
                break;
            }
        }



        if ( bReturnValue ) {

            //
            // Set TargetFile Times to be the same as the Source File
            //

            bReturnValue = SetFileTime( hTargetFile,
                                        &pSourceFileData->ftCreationTime,
                                        &pSourceFileData->ftLastAccessTime,
                                        &pSourceFileData->ftLastWriteTime );

            //
            //  Verify that the file size is correct.
            //

            if ( bReturnValue ) {

                dwLowFileSize = GetFileSize( hTargetFile, &dwHighFileSize );

                if ( dwLowFileSize != pSourceFileData->nFileSizeLow ||
                     dwHighFileSize != pSourceFileData->nFileSizeHigh ) {

                    DBGMSG(DBG_ERROR,
                           ("InternalCopyFile: sizes do not match for %ws: (%d %d) and (%d %d)",
                            lpNewFileName,
                            pSourceFileData->nFileSizeHigh,
                            pSourceFileData->nFileSizeLow,
                            dwHighFileSize,
                            dwLowFileSize));
                    bReturnValue = FALSE;
                    SetLastError(ERROR_FILE_INVALID);
                }
            }

            //
            //  Add Code here to Verify the CheckSum is correct.
            //

        }

        CloseHandle( hTargetFile );
    }

    FreeSplMem( pBuffer );

InternalCopyFileExit:

    if ( !bReturnValue ) {
        DBGMSG( DBG_WARN, ("InternalCopyFile hSourceFile %x %ws error %d\n", hSourceFile, lpNewFileName, GetLastError() ));
        SPLASSERT( GetLastError() != ERROR_SUCCESS );
    }

    return  bReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\copyreg.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    copyreg.c

Abstract:

    This module provides functions to copy registry keys

Author:

    Krishna Ganugapati (KrishnaG) 20-Apr-1994

Notes:
    List of functions include

    CopyValues
    CopyRegistryKeys

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

VOID
CopyValues(
    HKEY hSourceKey,
    HKEY hDestKey,
    PINISPOOLER pIniSpooler
    )
/*++
   Description: This function copies all the values from hSourceKey to hDestKey.
   hSourceKey should be opened with KEY_READ and hDestKey should be opened with
   KEY_WRITE.

   Returns: VOID
--*/
{
    DWORD iCount = 0;
    WCHAR szValueString[MAX_PATH];
    DWORD dwSizeValueString;
    DWORD dwType = 0;
    PBYTE pData;

    DWORD cbData = 1024;
    DWORD dwSizeData;

    SplRegQueryInfoKey( hSourceKey,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     &cbData,
                     NULL,
                     NULL,
                     pIniSpooler );

    pData = (PBYTE)AllocSplMem( cbData );

    if( pData ){

        dwSizeValueString = COUNTOF(szValueString);
        dwSizeData = cbData;

        while ((SplRegEnumValue(hSourceKey,
                            iCount,
                            szValueString,
                            &dwSizeValueString,
                            &dwType,
                            pData,
                            &dwSizeData,
                            pIniSpooler
                            )) == ERROR_SUCCESS ) {

            SplRegSetValue( hDestKey,
                           szValueString,
                           dwType,
                           pData,
                           dwSizeData, pIniSpooler);

            dwSizeValueString = COUNTOF(szValueString);
            dwType = 0;
            dwSizeData = cbData;
            iCount++;
        }

        FreeSplMem( pData );
    }
}


BOOL
CopyRegistryKeys(
    HKEY hSourceParentKey,
    LPWSTR szSourceKey,
    HKEY hDestParentKey,
    LPWSTR szDestKey,
    PINISPOOLER pIniSpooler
    )
/*++
    Description:This function recursively copies the szSourceKey to szDestKey. hSourceParentKey
    is the parent key of szSourceKey and hDestParentKey is the parent key of szDestKey.

    Returns: TRUE if the function succeeds; FALSE on failure.

--*/
{
    DWORD dwRet;
    DWORD iCount;
    HKEY hSourceKey, hDestKey;
    WCHAR lpszName[MAX_PATH];
    DWORD dwSize;

    dwRet = SplRegOpenKey(hSourceParentKey,
                         szSourceKey, KEY_READ, &hSourceKey, pIniSpooler);

    if (dwRet != ERROR_SUCCESS) {
        return(FALSE);
    }

    dwRet = SplRegCreateKey(hDestParentKey,
                            szDestKey, 0, KEY_WRITE, NULL, &hDestKey, NULL, pIniSpooler);

    if (dwRet != ERROR_SUCCESS) {
        SplRegCloseKey(hSourceKey, pIniSpooler);
        return(FALSE);
    }

    iCount = 0;

    memset(lpszName, 0, sizeof(WCHAR)*COUNTOF(lpszName));

    dwSize = COUNTOF(lpszName);

    while((SplRegEnumKey(hSourceKey, iCount, lpszName,
                    &dwSize,NULL,pIniSpooler)) == ERROR_SUCCESS) {

        CopyRegistryKeys( hSourceKey,
                          lpszName,
                          hDestKey,
                          lpszName,
                          pIniSpooler );

        memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);

        dwSize =  COUNTOF(lpszName);

        iCount++;
    }

    CopyValues(hSourceKey, hDestKey, pIniSpooler);

    SplRegCloseKey(hSourceKey, pIniSpooler);
    SplRegCloseKey(hDestKey, pIniSpooler);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\aspapp\ipp_adsi.inc ===
<%
'------------------------------------------------------------
'
' Microsoft Internet Printing Project
'
' Copyright (c) Microsoft Corporation. All rights reserved.
'
'------------------------------------------------------------
%>

<%
Const ADSI_PRINTER_NAME = 1
Const ADSI_PRINTER_LOCATION = 2
Const ADSI_PRINTER_COMMENT = 3
Const ADSI_PRINTER_MODEL = 4
Const ADSI_PRINTER_STATUS = 5
Const ADSI_PRINTER_JOBS = 6
Const ADSI_PRINTER_SHARE = 7
Const ADSI_PRINTER_ACCESS = 8
Const ADSI_PRINTER_ATTRIBUTES = 8

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\devqury.c ===
/*++

Copyright (c) 1994 - 1996  Microsoft Corporation

Module Name:

    devqury.c

Abstract:

    This module provides all the scheduling services for the Local Spooler

Author:

    Krishna Ganugapati (KrishnaG) 15-June-1994

Revision History:


--*/

#include <precomp.h>

BOOL    (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
BOOL    (*pfnClosePrinter)(HANDLE);
BOOL    (*pfnDevQueryPrint)(HANDLE, LPDEVMODE, DWORD *, LPWSTR, DWORD);
BOOL    (*pfnPrinterEvent)(LPWSTR, INT, DWORD, LPARAM, DWORD *);
LONG    (*pfnDocumentProperties)(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODE, DWORD);

BOOL
InitializeWinSpoolDrv(
    VOID
    )
{
    fnWinSpoolDrv    fnList;

    if (!SplInitializeWinSpoolDrv(&fnList)) {
        return FALSE;
    }

    pfnOpenPrinter   =  fnList.pfnOpenPrinter;
    pfnClosePrinter  =  fnList.pfnClosePrinter;
    pfnDevQueryPrint =  fnList.pfnDevQueryPrint;
    pfnPrinterEvent  =  fnList.pfnPrinterEvent;
    pfnDocumentProperties  =  fnList.pfnDocumentProperties;

    return TRUE;
}

BOOL
CallDevQueryPrint(
    LPWSTR    pPrinterName,
    LPDEVMODE pDevMode,
    LPWSTR    ErrorString,
    DWORD     dwErrorString,
    DWORD     dwPrinterFlags,
    DWORD     dwJobFlags
    )
{

    HANDLE hPrinter;
    DWORD  dwResID=0;

    //
    // Do not process for Direct printing
    // If a job is submitted as direct, then
    // ignore the devquery print stuff
    //

    if ( dwJobFlags ) {

        return TRUE;
    }

    if (!pDevMode) {

        return TRUE;
    }

    if  (dwPrinterFlags && pfnOpenPrinter && pfnDevQueryPrint && pfnClosePrinter) {

        if ( (*pfnOpenPrinter)(pPrinterName, &hPrinter, NULL) ) {

             (*pfnDevQueryPrint)(hPrinter, pDevMode, &dwResID, ErrorString, dwErrorString);
             (*pfnClosePrinter)(hPrinter);
        }
    }

    return(dwResID == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\data.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    data.c

Abstract:

    Generates globals used for marshalling spooler data structures.
    Actual definitions in spl\inc.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include <precomp.h>

#define PRINTER_STRINGS
#define JOB_STRINGS
#define DRIVER_STRINGS
#define ADDJOB_STRINGS
#define FORM_STRINGS
#define PORT_STRINGS
#define PRINTPROCESSOR_STRINGS
#define MONITOR_STRINGS
#define DOCINFO_STRINGS

#include <stddef.h>
#include <data.h>

DWORD IniDriverOffsets[]={offsetof(INIDRIVER, pName),
                          offsetof(INIDRIVER, pDriverFile),
                          offsetof(INIDRIVER, pConfigFile),
                          offsetof(INIDRIVER, pDataFile),
                          offsetof(INIDRIVER, pHelpFile),
                          offsetof(INIDRIVER, pDependentFiles),
                          offsetof(INIDRIVER, pMonitorName),
                          offsetof(INIDRIVER, pDefaultDataType),
                          offsetof(INIDRIVER, pszzPreviousNames),
                          offsetof(INIDRIVER, pszMfgName),
                          offsetof(INIDRIVER, pszOEMUrl),
                          offsetof(INIDRIVER, pszHardwareID),
                          offsetof(INIDRIVER, pszProvider),
                          0xFFFFFFFF};

DWORD IniPrinterOffsets[]={offsetof(INIPRINTER, pName),
                           offsetof(INIPRINTER, pShareName),
                           offsetof(INIPRINTER, pDatatype),
                           offsetof(INIPRINTER, pParameters),
                           offsetof(INIPRINTER, pComment),
                           offsetof(INIPRINTER, pDevMode),
                           offsetof(INIPRINTER, pSepFile),
                           offsetof(INIPRINTER, pLocation),
                           offsetof(INIPRINTER, pSpoolDir),
                           offsetof(INIPRINTER, ppIniPorts),
                           offsetof(INIPRINTER, pszObjectGUID),
                           offsetof(INIPRINTER, pszDN),
                           offsetof(INIPRINTER, pszCN),
                           0xFFFFFFFF};

DWORD IniSpoolerOffsets[]={offsetof(INISPOOLER, pMachineName),
                           offsetof(INISPOOLER, pDir),
                           offsetof(INISPOOLER, pDefaultSpoolDir),
                           offsetof(INISPOOLER, pszRegistryMonitors),
                           offsetof(INISPOOLER, pszRegistryEnvironments),
                           offsetof(INISPOOLER, pszRegistryEventLog),
                           offsetof(INISPOOLER, pszRegistryProviders),
                           offsetof(INISPOOLER, pszEventLogMsgFile),
                           offsetof(INISPOOLER, pszDriversShare),
                           offsetof(INISPOOLER, pszRegistryForms),
                           offsetof(INISPOOLER, pszClusterSID),
                           offsetof(INISPOOLER, pszClusResDriveLetter),
                           offsetof(INISPOOLER, pszClusResID),
                           offsetof(INISPOOLER, pszFullMachineName),
                           0xFFFFFFFF};

DWORD IniEnvironmentOffsets[] = {offsetof(INIENVIRONMENT, pDirectory),
                                 0xFFFFFFFF};

DWORD IniPrintProcOffsets[] = { offsetof(INIPRINTPROC, pDatatypes),
                                0xFFFFFFFF};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\ds.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

    This module provides functionality for ADs within spooler

Author:

    Steve Wilson (NT) December 1996

Revision History:

--*/


#include <precomp.h>
#pragma hdrstop

#include "ds.hxx"

#define LOG_EVENT_ERROR_BUFFER_SIZE     11
#define PPM_FACTOR                      48
#define LOTS_OF_FORMS                   300     // This is a little more than twice the number of built-in forms

extern BOOL gbInDomain;
extern BOOL gdwLogDsEvents;

extern "C" HANDLE    ghDsUpdateThread;
extern "C" DWORD     gdwDsUpdateThreadId;

extern "C" BOOL (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
extern "C" BOOL (*pfnClosePrinter)(HANDLE);

extern "C" DWORD
SetPrinterDs(
    HANDLE          hPrinter,
    DWORD           dwAction,
    BOOL            bSynchronous
)
{
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    HRESULT         hr;
    HANDLE          hToken = NULL;
    PWSTR           pszObjectGUID, pszCN, pszDN;
    DWORD           DsKeyUpdate, Attributes;
    BOOL            DoChange = FALSE;
    NOTIFYVECTOR    NotifyVector;

    SplInSem();

    if (!gbInDomain)
        return ERROR_DS_UNAVAILABLE;
    //
    // Don't allow masquerading printer publishing
    //
    if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR))
        return ERROR_INVALID_PARAMETER;

    hToken = RevertToPrinterSelf(); // All DS accesses are done by LocalSystem account

    //
    // If any of these change we'll update the registry entry
    //
    DsKeyUpdate = pIniPrinter->DsKeyUpdate;
    pszObjectGUID = pIniPrinter->pszObjectGUID;
    pszCN = pIniPrinter->pszCN;
    pszDN = pIniPrinter->pszDN;
    Attributes = pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED;
    
    //
    // Attribute states desired state, not current state
    //
    switch (dwAction) {
        case DSPRINT_UPDATE:
            if (!(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED)) {
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND);

            } else if (bSynchronous) {
                //
                // We are in the background thread.
                //
                if (pIniPrinter->DsKeyUpdate) {
                    INCPRINTERREF(pIniPrinter);
                    LeaveSplSem();
                    hr = DsPrinterPublish(hPrinter);
                    EnterSplSem();
                    DECPRINTERREF(pIniPrinter);
                } else {
                    hr = ERROR_SUCCESS;
                }
            } else {
                //
                // Here we are in the foreground thread.
                //
                if (pIniPrinter->DsKeyUpdateForeground) {
                    pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_PUBLISHED;
                    pIniPrinter->dwAction = DSPRINT_PUBLISH;
                    hr = ERROR_IO_PENDING;
                } else {
                    hr = ERROR_SUCCESS;
                }
            }
            break;

        case DSPRINT_PUBLISH:
            if (!(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) &&
                  PrinterPublishProhibited()) {
                //
                // There is a policy against publishing printers from this machine.
                //
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, ERROR_ACCESS_DENIED);

            } else {
                if (bSynchronous) {
                    INCPRINTERREF(pIniPrinter);
                    LeaveSplSem();
                    hr = DsPrinterPublish(hPrinter);
                    EnterSplSem();
                    DECPRINTERREF(pIniPrinter);
                } else {
                    //
                    // This is a Pending Unpublish state
                    //
                    if (!(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) && pIniPrinter->pszObjectGUID)
                        pIniPrinter->dwAction = DSPRINT_REPUBLISH;
                    else
                        pIniPrinter->dwAction = DSPRINT_PUBLISH;

                    pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_PUBLISHED;
                    hr = ERROR_IO_PENDING;
                }
            }
            break;

        case DSPRINT_REPUBLISH:
            if (PrinterPublishProhibited()) {
                //
                // There is a policy against publishing printers from this machine.
                //
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, ERROR_ACCESS_DENIED);

            } else {
                //
                // Synchronous mode is from background thread and it should only call Publish/Unpublish
                //
                if (bSynchronous) {
                    hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);
                    SPLASSERT(FALSE);
                } else {
                    pIniPrinter->dwAction = DSPRINT_REPUBLISH;
                    pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_PUBLISHED;
                    hr = ERROR_IO_PENDING;
                }
            }
            break;

        case DSPRINT_UNPUBLISH:
            if (bSynchronous) {
                INCPRINTERREF(pIniPrinter);
                LeaveSplSem();
                hr = DsPrinterUnpublish(hPrinter);
                EnterSplSem();
                DECPRINTERREF(pIniPrinter);
            } else {
                pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_PUBLISHED;
                pIniPrinter->dwAction = DSPRINT_UNPUBLISH;
                hr = ERROR_IO_PENDING;
            }
            break;

        default:
            hr = ERROR_INVALID_PARAMETER;
            break;
    }

    //
    // Update Registry and set notifications
    //
    if (pszCN != pIniPrinter->pszCN ||
        pszDN != pIniPrinter->pszDN ||
        pszObjectGUID != pIniPrinter->pszObjectGUID ||
        DsKeyUpdate != pIniPrinter->DsKeyUpdate ||
        Attributes != (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED)) {

        ZERONV(NotifyVector);

        if (pszObjectGUID != pIniPrinter->pszObjectGUID) {
            NotifyVector[PRINTER_NOTIFY_TYPE] |= BIT(I_PRINTER_OBJECT_GUID);
            DoChange = TRUE;
        }
        if (Attributes != (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED)) {
            NotifyVector[PRINTER_NOTIFY_TYPE] |= BIT(I_PRINTER_ATTRIBUTES);
            DoChange = TRUE;
        }
        if (DoChange) {
            UpdatePrinterIni(pIniPrinter, UPDATE_CHANGEID);
            SetPrinterChange(pIniPrinter,
                             NULL,
                             NotifyVector,
                             PRINTER_CHANGE_SET_PRINTER,
                             pIniPrinter->pIniSpooler);

        } else if (DsKeyUpdate != pIniPrinter->DsKeyUpdate) {
            UpdatePrinterIni(pIniPrinter, UPDATE_DS_ONLY);
        }
    }

    SplInSem();

    if (hr == ERROR_IO_PENDING && !bSynchronous)
        SpawnDsUpdate(1);

    if (hToken)
        ImpersonatePrinterClient(hToken);

    return (DWORD) hr;
}


HRESULT
DsPrinterPublish(
    HANDLE  hPrinter
)
{
    HRESULT         hr;
    PSPOOL          pSpool       = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter  = pSpool->pIniPrinter;
    WCHAR           ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    BOOL            bUpdating = !!pIniPrinter->pszObjectGUID;
    DWORD           dwDsKeyUpdate;

    SplOutSem();

#if DBG
    EnterSplSem();
    DBGMSG( DBG_EXEC, ("DsPrinterPublish: %ws\n", pIniPrinter->pName));
    LeaveSplSem();
#endif

    //
    // On first publish update all keys and tell the driver to write its non-devcap properties
    //
    if (!bUpdating) {
        //
        // We execute this on the background thread and hence donot need any
        // to be in the critical section.
        //
        pIniPrinter->DsKeyUpdate |= DS_KEY_PUBLISH | DS_KEY_SPOOLER | DS_KEY_DRIVER | DS_KEY_USER;
    }

    //
    // Update DS properties
    //
    dwDsKeyUpdate = pIniPrinter->DsKeyUpdate & (DS_KEY_SPOOLER | DS_KEY_DRIVER | DS_KEY_USER);
    hr = DsPrinterUpdate(hPrinter);
    BAIL_ON_FAILURE(hr);
    DBGMSG( DBG_EXEC, ("PublishDsUpdate: Printer Updated\n" ) );

error:

    if (SUCCEEDED(hr)) {
        //
        // Only write a success event if something changed
        //
        if (dwDsKeyUpdate != pIniPrinter->DsKeyUpdate) {
            SplLogEvent( pIniPrinter->pIniSpooler,
                         gdwLogDsEvents & LOG_INFO,
                         bUpdating ? MSG_PRINTER_UPDATED
                                   : MSG_PRINTER_PUBLISHED,
                         FALSE,
                         pIniPrinter->pszCN,
                         pIniPrinter->pszDN,
                         NULL );
        }
    } else if (pIniPrinter->pszCN && pIniPrinter->pszDN) {
        StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%x", hr);

        SplLogEvent( pIniPrinter->pIniSpooler,
                     gdwLogDsEvents & LOG_ERROR,
                     MSG_PRINTER_NOT_PUBLISHED,
                     FALSE,
                     pIniPrinter->pszCN,
                     pIniPrinter->pszDN,
                     ErrorBuffer,
                     NULL );
    }

    if (pIniPrinter->DsKeyUpdate)
        hr = ERROR_IO_PENDING;

    return hr;
}


HRESULT
DsPrinterUpdate(
    HANDLE  hPrinter
)
{
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    HRESULT         hr = S_OK;
    DWORD           dwResult;
    BOOL            bImpersonating = FALSE;
    IADs            *pADs = NULL;

    SplOutSem();


    if(!(pIniPrinter->DsKeyUpdate & (DS_KEY_SPOOLER | DS_KEY_DRIVER | DS_KEY_USER))) {
        pIniPrinter->DsKeyUpdate = 0;
    }
    //
    // If we aren't truly published yet, be sure to publish mandatory properties first!
    //
    if (!pIniPrinter->pszObjectGUID) {
        //
        // Fail if we're on a cluster but couldn't get the Cluster SID
        // The Cluster SID is required later in AddClusterAce
        //
        if ((pIniPrinter->pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG) &&
            !pIniPrinter->pIniSpooler->pszClusterSID) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_CLUSTER_NO_SECURITY_CONTEXT);
            BAIL_ON_FAILURE(hr);
        }
        //
        // Get or Create printQueue object
        //
        hr = GetPrintQueue(hPrinter, &pADs);
        BAIL_ON_FAILURE(hr);

        hr = PublishMandatoryProperties(hPrinter, pADs);
        BAIL_ON_FAILURE(hr);

    } else {
        //
        // If we are a Cluster, impersonate the Cluster User
        //
        if (pIniPrinter->pIniSpooler->hClusterToken != INVALID_HANDLE_VALUE) {
            // Impersonate the client
            if (!ImpersonatePrinterClient(pIniPrinter->pIniSpooler->hClusterToken)) {
                dwResult = GetLastError();
                DBGMSG(DBG_WARNING,("DsPrinterPublish FAILED: %d\n", dwResult));
                hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
                BAIL_ON_FAILURE(hr);
            }
            bImpersonating = TRUE;
        }
        //
        // Get or Create printQueue object
        //
        hr = GetPrintQueue(hPrinter, &pADs);
        BAIL_ON_FAILURE(hr);
    }

    //
    // Update User - updates from Registry
    //
    // CopyRegistry2Ds for DS_KEY_USER values must
    // be called in the first place since there could be duplicate values
    // that might overwrite properties contained by either
    // DS_KEY_SPOOLER or DS_KEY_DRIVER.
    // Ignore the return value since publishing of DS_KEY_USER values
    // is not critical
    //
    if (pIniPrinter->DsKeyUpdate & DS_KEY_USER) {
        CopyRegistry2Ds(hPrinter, DS_KEY_USER, pADs);
    }

    // Update Spooler - updates from Registry
    if (pIniPrinter->DsKeyUpdate & DS_KEY_SPOOLER) {
        hr = CopyRegistry2Ds(hPrinter, DS_KEY_SPOOLER, pADs);
        BAIL_ON_FAILURE(hr);
    }

    //
    // Update Driver - updates from Registry
    //
    if (pIniPrinter->DsKeyUpdate & DS_KEY_DRIVER) {
        hr = CopyRegistry2Ds(hPrinter, DS_KEY_DRIVER, pADs);
        //
        // Ignore missing key
        //
        if (HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND)
            hr = S_OK;

        BAIL_ON_FAILURE(hr);
    }


error:

    if (pADs)
        pADs->Release();

    if (bImpersonating)
        pIniPrinter->pIniSpooler->hClusterToken = RevertToPrinterSelf();

    return hr;
}


HRESULT
DsDeletePQObject(
    HANDLE  hPrinter
)
{
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    IADsContainer   *pADsContainer    = NULL;
    IADs            *pADs = NULL;
    HRESULT         hr = E_FAIL;
    WCHAR           ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    BOOL            bImpersonating = FALSE;
    DWORD           dwError;

    //
    // This routine is called when AddClusterAce failed. Even if we faild deleteing the object,
    // we really want to clean up the pIniPrinter structure so that we prevent the case where
    // the object stays forever in pending un/publishing.
    // That's because the other cluster node fails to delete/update it
    // since the printQueue object doesn't have the cluster user ace added. Pruner also fails to delete it
    // since the PrintQueue's GUID matches the pIniPrinter's GUID.
    //
    SplOutSem();

    hr = GetPrintQueueContainer(hPrinter, &pADsContainer, &pADs);
    BAIL_ON_FAILURE(hr);

    //
    // Delete Printer Object
    //
    hr = pADsContainer->Delete(SPLDS_PRINTER_CLASS, pIniPrinter->pszCN);
    DBGMSG(DBG_EXEC,("DsPrinterUnpublish FAILED: %x, %ws\n", hr, pIniPrinter->pszCN));
    BAIL_ON_FAILURE(hr);

error:

    if (pADs)
        pADs->Release();

    if (pADsContainer)
        pADsContainer->Release();

    pIniPrinter->DsKeyUpdate = 0;

    FreeSplStr(pIniPrinter->pszObjectGUID);
    pIniPrinter->pszObjectGUID = NULL;

    FreeSplStr(pIniPrinter->pszCN);
    pIniPrinter->pszCN = NULL;

    FreeSplStr(pIniPrinter->pszDN);
    pIniPrinter->pszDN = NULL;

    return hr;
}

HRESULT
DsPrinterUnpublish(
    HANDLE  hPrinter
)
{
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    IADsContainer   *pADsContainer    = NULL;
    IADs            *pADs = NULL;
    HRESULT         hr = E_FAIL;
    WCHAR           ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    BOOL            bImpersonating = FALSE;
    DWORD           dwError;

    SplOutSem();
    //
    // If we are a Cluster, impersonate the Cluster User
    //
    if (pIniPrinter->pIniSpooler->hClusterToken != INVALID_HANDLE_VALUE) {
        //
        // Impersonate the client
        //
        if (!ImpersonatePrinterClient(pIniPrinter->pIniSpooler->hClusterToken)) {
            dwError = GetLastError();
            DBGMSG(DBG_WARNING,("DsPrinterUnpublish FAILED: %d\n", dwError));
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwError);
            goto error;
        }
        bImpersonating = TRUE;
    }

    hr = GetPrintQueueContainer(hPrinter, &pADsContainer, &pADs);
    BAIL_ON_FAILURE(hr);

    //
    // Delete Printer Object
    //
    hr = pADsContainer->Delete(SPLDS_PRINTER_CLASS, pIniPrinter->pszCN);
    DBGMSG(DBG_EXEC,("DsPrinterUnpublish FAILED: %x, %ws\n", hr, pIniPrinter->pszCN));
    BAIL_ON_FAILURE(hr);


error:

    if (bImpersonating)
        pIniPrinter->pIniSpooler->hClusterToken = RevertToPrinterSelf();

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) ||
        HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND ||
        HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND) {
        hr = S_OK;
        SplLogEvent(  pIniPrinter->pIniSpooler,
                      gdwLogDsEvents & LOG_INFO,
                      MSG_MISSING_PRINTER_UNPUBLISHED,
                      FALSE,
                      pIniPrinter->pName,
                      NULL );

    } else if (SUCCEEDED(hr)) {
            SplLogEvent(  pIniPrinter->pIniSpooler,
                          gdwLogDsEvents & LOG_INFO,
                          MSG_PRINTER_UNPUBLISHED,
                          FALSE,
                          pIniPrinter->pszCN,
                          pIniPrinter->pszDN,
                          NULL );

    } else if(pIniPrinter->pszCN && pIniPrinter->pszDN) {
        StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%x", hr);

        SplLogEvent(  pIniPrinter->pIniSpooler,
                      gdwLogDsEvents & LOG_ERROR,
                      MSG_CANT_DELETE_PRINTQUEUE,
                      FALSE,
                      pIniPrinter->pszCN,
                      pIniPrinter->pszDN,
                      ErrorBuffer,
                      NULL );
    }


    if (SUCCEEDED(hr)) {
        pIniPrinter->DsKeyUpdate = 0;

        FreeSplStr(pIniPrinter->pszObjectGUID);
        pIniPrinter->pszObjectGUID = NULL;

        FreeSplStr(pIniPrinter->pszCN);
        pIniPrinter->pszCN = NULL;

        FreeSplStr(pIniPrinter->pszDN);
        pIniPrinter->pszDN = NULL;

    } else {
        pIniPrinter->DsKeyUpdate = DS_KEY_UNPUBLISH;
    }

    if (pADs)
        pADs->Release();

    if (pADsContainer)
        pADsContainer->Release();

    if (pIniPrinter->DsKeyUpdate)
        hr = ERROR_IO_PENDING;

    return hr;
}

LPCWSTR
MapDSFlag2DSKey(
    DWORD   Flag
)
{
    DWORD   idx;
    LPCWSTR pKey = NULL;

    struct DSEntry
    {
        DWORD       Flag;
        LPCWSTR     pKey;
    };

    static DSEntry DSKeys [] = {
    {DS_KEY_SPOOLER ,   SPLDS_SPOOLER_KEY},
    {DS_KEY_DRIVER  ,   SPLDS_DRIVER_KEY},
    {DS_KEY_USER    ,   SPLDS_USER_KEY},
    {0              ,   NULL},
    };

    for (idx = 0; DSKeys[idx].pKey; idx++) {
        if(DSKeys[idx].Flag & Flag) {
            pKey = DSKeys[idx].pKey;
        }
    }
    return pKey;
}

HRESULT
CopyRegistry2Ds(
    HANDLE          hPrinter,
    DWORD           Flag,
    IADs            *pADs
)
{
    HRESULT     hr = ERROR_SUCCESS;
    DWORD       i;
    DWORD       dwLDAPError;
    DWORD       cbEnumValues = 0;
    PPRINTER_ENUM_VALUES pEnumValues = NULL;
    DWORD       nEnumValues;
    DWORD       dwResult;
    WCHAR       ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    BSTR        bstrADsPath = NULL;
    PINIPRINTER pIniPrinter = ((PSPOOL)hPrinter)->pIniPrinter;
    LPCWSTR     pKey = MapDSFlag2DSKey(Flag);


#if DBG
    EnterSplSem();
    DBGMSG(DBG_EXEC, ("Mass Publish %ws", ((PSPOOL)hPrinter)->pIniPrinter->pName));
    LeaveSplSem();
#endif
    
    //
    // Enumerate and Publish Key
    //
    dwResult = SplEnumPrinterDataEx(    hPrinter,
                                        pKey,
                                        (LPBYTE) pEnumValues,
                                        cbEnumValues,
                                        &cbEnumValues,
                                        &nEnumValues
                                     );

    if (dwResult != ERROR_MORE_DATA) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        if( HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND && Flag != DS_KEY_SPOOLER) {
            goto IgnoreError;
        }
        else {
            goto error;
        }
    }

    if (!(pEnumValues = (PPRINTER_ENUM_VALUES) AllocSplMem(cbEnumValues))) {
        DBGMSG(DBG_EXEC,("CopyRegistry2Ds EnumPrinterDataEx FAILED: %d\n", GetLastError()));
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwResult = SplEnumPrinterDataEx(    hPrinter,
                                        pKey,
                                        (LPBYTE) pEnumValues,
                                        cbEnumValues,
                                        &cbEnumValues,
                                        &nEnumValues
                                     );
    if (dwResult != ERROR_SUCCESS) {
        DBGMSG(DBG_EXEC,("CopyRegistry2Ds 2nd EnumPrinterDataEx FAILED: %d\n", GetLastError()));
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        if( HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND && Flag != DS_KEY_SPOOLER) {
            goto IgnoreError;
        }
        else {
            goto error;
        }
    }

    //
    // Mass publish
    //
    for (i = 0 ; i < nEnumValues ; ++i) {

        hr = PublishDsData( pADs,
                            pEnumValues[i].pValueName,
                            pEnumValues[i].dwType,
                            (PBYTE) pEnumValues[i].pData);
        //
        // Don't bail out on failure to put a specific property
        //
        if (FAILED(hr)) {
            if (pEnumValues[i].pValueName) {
                DBGMSG(DBG_EXEC, ("Put property failed: %x, %ws\n", hr, pEnumValues[i].pValueName));
            } else {
                DBGMSG(DBG_EXEC, ("Put property failed: %x\n", hr));
            }
        } else {
            DBGMSG(DBG_EXEC, ("Put %ws succeeded\n", pEnumValues[i].pValueName));
        }
    }

    hr = pADs->SetInfo();
    //
    // Mass publishing failed, now try Setting on every Put
    //
    if (SUCCEEDED(hr)) {

        DBGMSG( DBG_EXEC, ("Mass Publishing Succeeded for %ws\n", pKey) );

    } else {

        if (HRESULT_CODE(hr) == ERROR_EXTENDED_ERROR)
            ADsGetLastError(&dwLDAPError, NULL, 0, NULL, 0);
        else
            dwLDAPError = hr;

        DBGMSG( DBG_EXEC, ("Mass Publishing FAILED for %ws: %x\n", pKey, dwLDAPError) );

        // Now we have to try SetInfo/GetInfo on every Put.
        // If the DS lacks a spooler property, then the spooler will never
        // be able to publish any properties.  Also, we'll fail if duplicate
        // strings exist in REG_MULTISZ attributes.
        // Maybe it is better to publish what we can,
        // but this requires calling SetInfo() for every property, which defeats the cache.
        // Alternatively, we could try doing the single SetInfo once and if that fails, resort
        // to the SetInfo on every Put.
        // Additionally, when SetInfo fails it is necessary to call GetInfo on that property
        // in order to clear the cache's update flag for the property.  When SetInfo fails
        // it does not clear the update flag: the update flag is only cleared when SetInfo
        // succeeds.  Not calling GetInfo will result in SetInfo() errors on all subsequent
        // attempts to publish a property.

        //
        // Refresh the cache
        //
        hr = pADs->GetInfo();
        BAIL_ON_FAILURE(hr);


        for (i = 0 ; i < nEnumValues ; ++i) {

            hr = PublishDsData( pADs,
                                pEnumValues[i].pValueName,
                                pEnumValues[i].dwType,
                                (PBYTE) pEnumValues[i].pData);
            //
            // Don't bail out on failure to put a specific property
            //
            if (FAILED(hr)) {
                if (pEnumValues[i].pValueName) {
                    DBGMSG(DBG_EXEC, ("Put property failed: %x, %ws\n", hr, pEnumValues[i].pValueName));
                } else {
                    DBGMSG(DBG_EXEC, ("Put property failed: %x\n", hr));
                }

                StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%x", hr);
                hr = pADs->get_ADsPath(&bstrADsPath);
                if (SUCCEEDED(hr)) {
                    SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                                  gdwLogDsEvents & LOG_WARNING,
                                  MSG_CANT_PUBLISH_PROPERTY,
                                  FALSE,
                                  pEnumValues[i].pValueName ? pEnumValues[i].pValueName : L"NULLName",
                                  bstrADsPath,
                                  ErrorBuffer,
                                  NULL );
                    SysFreeString(bstrADsPath);
                }
            } else {
                DBGMSG(DBG_EXEC, ("Put2 %ws succeeded\n", pEnumValues[i].pValueName));
            }


            hr = pADs->SetInfo();
            if (FAILED(hr)) {

                if (HRESULT_CODE(hr) == ERROR_EXTENDED_ERROR)
                    ADsGetLastError(&dwLDAPError, NULL, 0, NULL, 0);

                if (pEnumValues[i].dwType == REG_SZ)
                    DBGMSG(DBG_EXEC, ("PUBLISH FAILED: %ws, \"%ws\", %x\n", pEnumValues[i].pValueName,
                                                                         (LPWSTR) pEnumValues[i].pData,
                                                                         dwLDAPError));
                else
                    DBGMSG(DBG_EXEC, ("PUBLISH FAILED: %ws, %x\n", pEnumValues[i].pValueName, dwLDAPError));

                StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%x", hr);
                hr = pADs->get_ADsPath(&bstrADsPath);
                if (SUCCEEDED(hr)) {
                    SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                                  gdwLogDsEvents & LOG_WARNING,
                                  MSG_CANT_PUBLISH_PROPERTY,
                                  FALSE,
                                  pEnumValues[i].pValueName ? pEnumValues[i].pValueName : L"NULLName",
                                  bstrADsPath,
                                  ErrorBuffer,
                                  NULL );
                    SysFreeString(bstrADsPath);
                }
                //
                // reset cache update flag
                // If this fails, there's nothing more that can be done except throw our hands up
                // in despair.  If this fails, no spooler properties will ever be published.
                //
                hr = pADs->GetInfo();
                BAIL_ON_FAILURE(hr);
            }
            else {
                DBGMSG( DBG_EXEC, ("Published: %ws\n", pEnumValues[i].pValueName) );
            }
        }
    }

IgnoreError:

    EnterSplSem();
    pIniPrinter->DsKeyUpdate &= ~Flag;

    if(!(pIniPrinter->DsKeyUpdate & (DS_KEY_SPOOLER | DS_KEY_DRIVER | DS_KEY_USER))) {
        pIniPrinter->DsKeyUpdate = 0;
    }
    LeaveSplSem();

error:

    FreeSplMem(pEnumValues);

    return hr;
}



HRESULT
PublishDsData(
    IADs   *pADs,
    LPWSTR pValue,
    DWORD  dwType,
    PBYTE  pData
)
{
    HRESULT hr;
    BOOL    bCreated = FALSE;

    switch (dwType) {
        case REG_SZ:
            hr = put_BSTR_Property(pADs, pValue, (LPWSTR) pData);
            break;

        case REG_MULTI_SZ:
            hr = put_MULTISZ_Property(pADs, pValue, (LPWSTR) pData);
            break;

        case REG_DWORD:
            hr = put_DWORD_Property(pADs, pValue, (DWORD *) pData);
            break;

        case REG_BINARY:
            hr = put_BOOL_Property(pADs, pValue, (BOOL *) pData);
            break;
    }

    return hr;
}


HRESULT
PublishMandatoryProperties(
    HANDLE  hPrinter,
    IADs    *pADs
)
{
    PSPOOL      pSpool = (PSPOOL) hPrinter;
    PINIPRINTER pIniPrinter = pSpool->pIniPrinter;
    HRESULT     hr, hrAce;
    WCHAR       ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];

#if DBG
    EnterSplSem();
    DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: %ws\n", pIniPrinter->pName));
    LeaveSplSem();
#endif

    //
    // Since we are calling outside the Critical Section we set param 3 (bInSem) to false.
    //
    hr = SetMandatoryProperties(hPrinter, pADs, FALSE);

    DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: SMP result %d\n", hr));
    BAIL_ON_FAILURE(hr);

    hr = pADs->SetInfo();

    if (FAILED(hr)) {

        DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: SetInfo failed %d\n", hr));

        StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%x", hr);
        SplLogEvent(  pSpool->pIniSpooler,
                      gdwLogDsEvents & LOG_ERROR,
                      MSG_CANT_PUBLISH_MANDATORY_PROPERTIES,
                      FALSE,
                      pIniPrinter->pszCN,
                      pIniPrinter->pszDN,
                      ErrorBuffer,
                      NULL );
        //
        // If SetInfo returns ERROR_BUSY it means the object already exists.
        // We should have avoided this conflict when we created the CN because
        // we check for conflicts and generate a random name.  Nonetheless, an
        // object could have appeared between the time we generated the CN and this SetInfo,
        // so failing here will let us try again and we'll generate a new name if we clear the
        // current one.
        //
        if (HRESULT_CODE(hr) == ERROR_BUSY) {
            FreeSplMem(pIniPrinter->pszCN);
            pIniPrinter->pszCN = NULL;
            FreeSplMem(pIniPrinter->pszDN);
            pIniPrinter->pszDN = NULL;
        }

        BAIL_ON_FAILURE(hr);
    }

    //
    // Get & Set ACE if we're a cluster. For clusters, we publish data in DS impersonating the cluster user.
    // 
    //
    hrAce = AddClusterAce(pSpool, pADs);

    //
    // Get & store GUID
    //
    hr = GetGUID(pADs, &pIniPrinter->pszObjectGUID);

    //
    // Keep the first failure, if present
    //
    if (FAILED(hrAce)) {
        hr = hrAce;
        StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%x", hrAce);
        SplLogEvent(  pSpool->pIniSpooler,
                      gdwLogDsEvents & LOG_ERROR,
                      MSG_CANT_ADD_CLUSTER_ACE,
                      FALSE,
                      pIniPrinter->pszCN,
                      pIniPrinter->pszDN,
                      ErrorBuffer,
                      NULL );
        DsDeletePQObject(hPrinter);
        DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: AddClusterAce failed %d\n", hr));
        BAIL_ON_FAILURE(hr);
    }

    //
    // Unpublish if we can't add the cluster ace or get the GUID
    // If we can't get the GUID, unpublishing will fail, but internal flags
    // will be set correctly and pruner will delete the orphan
    //
    if (FAILED(hr)){
        DsPrinterUnpublish(hPrinter);
        DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: GetGuid failed %d\n", hr));
        BAIL_ON_FAILURE(hr);

    } else {
        DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: GetGuid success %ws\n",
                          pIniPrinter->pszObjectGUID));
    }

error:

    if (FAILED(hr)) {
        pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_PUBLISHED;
    }

    return hr;
}


HRESULT
SetMandatoryProperties(
    HANDLE  hPrinter,
    IADs    *pADs,
    BOOL    bInSem
)
{
    PSPOOL              pSpool = (PSPOOL) hPrinter;
    PINIPRINTER         pIniPrinter = pSpool->pIniPrinter;
    WCHAR               szBuffer[MAX_UNC_PRINTER_NAME + 1];
    DWORD               dwResult;
    DWORD               dwTemp;
    HRESULT             hr;
    PWSTR               pszServerName = NULL;


    //
    // Get FQDN of this machine
    // If we are calling from within the critical section we need to leave it
    // before making the network call.
    //
    if (bInSem) {
        SplInSem();

        LPWSTR szMachineName = AllocSplStr(pIniPrinter->pIniSpooler->pMachineName);

        dwResult = szMachineName ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;
        if (dwResult == ERROR_SUCCESS) {
            LeaveSplSem();
            SplOutSem();

            hr = GetDNSMachineName(szMachineName + 2, &pszServerName);

            FreeSplStr(szMachineName);
            EnterSplSem();
        }
        else {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        }
    }
    else {
        hr = GetDNSMachineName(pIniPrinter->pIniSpooler->pMachineName + 2, &pszServerName);
    }
    BAIL_ON_FAILURE(hr);

    //
    // UNC Printer Name
    // Build the UNC Printer Path
    //
    dwResult = StrNCatBuff(szBuffer, COUNTOF(szBuffer), L"\\\\", pszServerName, L"\\", pIniPrinter->pName, NULL);

    if (dwResult == ERROR_SUCCESS)
    {
        dwResult = SplSetPrinterDataEx(hPrinter,
                                       SPLDS_SPOOLER_KEY,
                                       SPLDS_UNC_NAME,
                                       REG_SZ,
                                       (PBYTE)szBuffer,
                                       (wcslen(szBuffer) + 1)*sizeof *szBuffer);
    }

    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        BAIL_ON_FAILURE(hr);
    }

    if (pADs) {
        hr = PublishDsData( pADs,
                            SPLDS_UNC_NAME,
                            REG_SZ,
                            (PBYTE) szBuffer);
        BAIL_ON_FAILURE(hr);
    }

    //
    // versionNumber
    //
    dwTemp = DS_PRINTQUEUE_VERSION_WIN2000;
    dwResult = SplSetPrinterDataEx(
                        hPrinter,
                        SPLDS_SPOOLER_KEY,
                        SPLDS_VERSION_NUMBER,
                        REG_DWORD,
                        (PBYTE) &dwTemp,
                        sizeof dwTemp);
    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        BAIL_ON_FAILURE(hr);
    }

    if (pADs) {
        hr = PublishDsData( pADs,
                            SPLDS_VERSION_NUMBER,
                            REG_DWORD,
                            (PBYTE) &dwTemp);
        BAIL_ON_FAILURE(hr);
    }

    //
    // ServerName (without \\)
    //
    dwResult = SplSetPrinterDataEx( hPrinter,
                                    SPLDS_SPOOLER_KEY,
                                    SPLDS_SERVER_NAME,
                                    REG_SZ,
                                    (PBYTE) pszServerName,
                                    (wcslen(pszServerName) + 1)*sizeof(WCHAR));
    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        BAIL_ON_FAILURE(hr);
    }

    if (pADs) {
        hr = PublishDsData( pADs,
                            SPLDS_SERVER_NAME,
                            REG_SZ,
                            (PBYTE) pszServerName);
        BAIL_ON_FAILURE(hr);
    }

    //
    // ShortServerName (without \\)
    //
    dwResult = SplSetPrinterDataEx( hPrinter,
                                    SPLDS_SPOOLER_KEY,
                                    SPLDS_SHORT_SERVER_NAME,
                                    REG_SZ,
                                    (PBYTE) (pIniPrinter->pIniSpooler->pMachineName + 2),
                                    (wcslen(pIniPrinter->pIniSpooler->pMachineName + 2) + 1)*sizeof(WCHAR));
    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        BAIL_ON_FAILURE(hr);
    }

    if (pADs) {
        hr = PublishDsData( pADs,
                            SPLDS_SHORT_SERVER_NAME,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pIniSpooler->pMachineName + 2);
        BAIL_ON_FAILURE(hr);
    }

    //
    // printerName
    //
    dwResult = SplSetPrinterDataEx(
                        hPrinter,
                        SPLDS_SPOOLER_KEY,
                        SPLDS_PRINTER_NAME,
                        REG_SZ,
                        (PBYTE) pIniPrinter->pName,
                        pIniPrinter->pName ?
                        (wcslen(pIniPrinter->pName) + 1)*sizeof *pIniPrinter->pName : 0);
    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        BAIL_ON_FAILURE(hr);
    }

    if (pADs) {
        hr = PublishDsData( pADs,
                            SPLDS_PRINTER_NAME,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pName);
        BAIL_ON_FAILURE(hr);
    }


error:

    FreeSplStr(pszServerName);

    return hr;
}


VOID
UpdateDsSpoolerKey(
    HANDLE  hPrinter,
    DWORD   dwVector
)
{
    PSPOOL      pSpool = (PSPOOL) hPrinter;
    PINIPRINTER pIniPrinter = pSpool->pIniPrinter;
    DWORD       i, cchMultiSz, dwTemp;
    LPWSTR      pString = NULL, pStr;
    DWORD       dwResult = ERROR_SUCCESS;
    BOOL        bSet = FALSE;
    BYTE        Byte;
    PWSTR       pszUrl = NULL;

    SplInSem();

    //
    // UpdateDsSpoolerKey - writes IniPrinter to registry
    //
    // Reg Value: Description
    //
    if (dwVector & BIT(I_PRINTER_COMMENT)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_DESCRIPTION,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pComment,
                            pIniPrinter->pComment ?
                            (wcslen(pIniPrinter->pComment) + 1)*sizeof *pIniPrinter->pComment : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: Description, %x\n", dwResult) );
#endif
    }

    //
    // Reg Value: Driver-Name
    //
    if (dwVector & BIT(I_PRINTER_DRIVER_NAME)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_DRIVER_NAME,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pIniDriver->pName,
                            pIniPrinter->pIniDriver->pName ?
                            (wcslen(pIniPrinter->pIniDriver->pName) + 1)*sizeof *pIniPrinter->pIniDriver->pName : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: DriverName, %x\n", dwResult) );
#endif
    }

    //
    // Reg Value: Location
    //
    if (dwVector & BIT(I_PRINTER_LOCATION)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_LOCATION,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pLocation,
                            pIniPrinter->pLocation ?
                            (wcslen(pIniPrinter->pLocation) + 1)*sizeof *pIniPrinter->pLocation : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: Location, %x\n", dwResult) );
#endif
    }

    //
    // Reg Value: portName
    //
    if (dwVector & BIT(I_PRINTER_PORT_NAME)) {

        SIZE_T cchMultiSzCopy = 0;

        for(i = cchMultiSz = 0 ; i < pIniPrinter->cPorts ; ++i)
            cchMultiSz += wcslen(pIniPrinter->ppIniPorts[i]->pName) + 1;

        cchMultiSz++;   // final NULL of MULTI_SZ

        if (!(pString = (LPWSTR) AllocSplMem(cchMultiSz * sizeof(WCHAR)))) {
            dwResult = GetLastError();
            goto error;
        }

        cchMultiSzCopy = cchMultiSz;

        for(i = 0, pStr = pString ; i < pIniPrinter->cPorts ; ++i) {
            StrCchCopyMultipleStr(pStr, cchMultiSzCopy, pIniPrinter->ppIniPorts[i]->pName, &pStr, &cchMultiSzCopy);
        }

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PORT_NAME,
                            REG_MULTI_SZ,
                            (PBYTE) pString,
                            cchMultiSz * sizeof(WCHAR));

        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: PortName, %x\n", dwResult) );
#endif
    }

    //
    // Reg Value: startTime
    //
    if (dwVector & BIT(I_PRINTER_START_TIME)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_START_TIME,
                            REG_DWORD,
                            (PBYTE) &pIniPrinter->StartTime,
                            sizeof pIniPrinter->StartTime);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: StartTime, %x\n", dwResult) );
#endif
    }

    //
    // Reg Value: endTime
    //
    if (dwVector & BIT(I_PRINTER_UNTIL_TIME)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_END_TIME,
                            REG_DWORD,
                            (PBYTE) &pIniPrinter->UntilTime,
                            sizeof pIniPrinter->UntilTime);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: EndTime, %x\n", dwResult) );
#endif
    }

    //
    // Reg Value: printerName
    //
    if (dwVector & BIT(I_PRINTER_PRINTER_NAME)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINTER_NAME,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pName,
                            pIniPrinter->pName ?
                            (wcslen(pIniPrinter->pName) + 1)*sizeof *pIniPrinter->pName : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: PrinterName, %x\n", dwResult) );
#endif
    }

    //
    // Reg Value: keepPrintedJobs
    //
    if (dwVector & BIT(I_PRINTER_ATTRIBUTES)) {
        Byte = (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS) ? 1 : 0;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_KEEP_PRINTED_JOBS,
                            REG_BINARY,
                            &Byte,
                            sizeof Byte);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: KeepPrintedJobs, %x\n", dwResult) );
#endif
    }

    //
    // Reg Value: printSeparatorFile
    //
    if (dwVector & BIT(I_PRINTER_SEPFILE)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_SEPARATOR_FILE,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pSepFile,
                            pIniPrinter->pSepFile ?
                            (wcslen(pIniPrinter->pSepFile) + 1)*sizeof *pIniPrinter->pSepFile : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: SeparatorFile, %x\n", dwResult) );
#endif
    }

    //
    // Reg Value: printShareName
    //
    if (dwVector & BIT(I_PRINTER_SHARE_NAME)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_SHARE_NAME,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pShareName,
                            pIniPrinter->pShareName ?
                            (wcslen(pIniPrinter->pShareName) + 1)*sizeof *pIniPrinter->pShareName : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: ShareName, %x\n", dwResult) );
#endif
    }
    //
    // Reg Value: printSpooling
    //
    if (dwVector & BIT(I_PRINTER_ATTRIBUTES)) {
        if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) {
            pStr = L"PrintDirect";
        } else if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST) {
            pStr = L"PrintAfterSpooled";
        } else {
            pStr = L"PrintWhileSpooling";
        }

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_SPOOLING,
                            REG_SZ,
                            (PBYTE) pStr,
                            (wcslen(pStr) + 1)*sizeof *pStr);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: PrintSpooling, %x\n", dwResult) );
#endif
    }
    //
    //Reg Value: priority
    //
    if (dwVector & BIT(I_PRINTER_PRIORITY)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRIORITY,
                            REG_DWORD,
                            (PBYTE) &pIniPrinter->Priority,
                            sizeof pIniPrinter->Priority);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: Priority, %x\n", dwResult) );
#endif
    }

    //
    // Non-Info2 properties
    //
    if (bSet) {
        //
        // Since we are calling from inside the Critical Section we set param 3 (bInSem) to TRUE
        //
        SetMandatoryProperties(hPrinter, NULL, TRUE);
        //
        // Reg Value: URL
        //
        if (pszUrl = GetPrinterUrl(pSpool)) {
            dwResult = SplSetPrinterDataEx(
                                hPrinter,
                                SPLDS_SPOOLER_KEY,
                                SPLDS_URL,
                                REG_SZ,
                                (PBYTE) pszUrl,
                                (wcslen(pszUrl) + 1)*sizeof *pszUrl);
#if DBG
            if (dwResult != ERROR_SUCCESS)
                DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: URL, %x\n", dwResult) );
#endif
        }
        //
        // Reg Value:Immortal
        //
        dwResult = ImmortalPolicy();
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_FLAGS,
                            REG_DWORD,
                            (PBYTE) &dwResult,
                            sizeof(dwResult));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: Immortal, %x\n", dwResult) );
#endif
    }


error:

    FreeSplMem(pszUrl);
    FreeSplMem(pString);
}



VOID
UpdateDsDriverKey(
    HANDLE hPrinter
)
{
    PSPOOL      pSpool = (PSPOOL) hPrinter;
    PINIPRINTER pIniPrinter = pSpool->pIniPrinter;
    DWORD       i, cbBytes;
    WCHAR       szBuffer[33];       
    LPWSTR      pString, pStr;
    BOOL        bResult;
    DWORD       dwResult;
    BYTE        Byte;
    LPWSTR      pOutput = NULL, pTemp = NULL, pTemp1 = NULL;
    DWORD       cOutputBytes, cTempBytes;
    POINTS      point;
    DWORD       dwServerMajorVersion, dwServerMinorVersion;
    DWORD       cbNeeded;
    HANDLE      hModule = FALSE;
    PDEVCAP     pDevCap;
    PSPLDEVCAP  pSplDevCaps;
    HANDLE      hDevCapPrinter = NULL;
    WCHAR       pPrinterName[MAX_UNC_PRINTER_NAME];
    WCHAR       Buf[100];
    BOOL        bInSplSem = TRUE;
    DWORD       dwTemp, dwPrintRate, dwPrintRateUnit, dwPrintPPM;

    //
    // DeviceCapability properties
    //
    SplInSem();

    DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: %ws\n", pIniPrinter->pName));

    pOutput = (LPWSTR) AllocSplMem(cOutputBytes = 200);
    if (!pOutput)
        goto error;


    pTemp = (LPWSTR) AllocSplMem(cTempBytes = 200);
    if (!pTemp)
        goto error;

    //
    // Get & Load Driver
    //
    PINIENVIRONMENT pIniEnvironment;

    pIniEnvironment = FindEnvironment(szEnvironment, pSpool->pIniSpooler);

    if (pIniEnvironment) {

        WCHAR       szConfigFile[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
        PINIVERSION pIniVersion;

        pIniVersion = FindVersionForDriver(pIniEnvironment, pIniPrinter->pIniDriver);
        if (!pIniVersion)
            goto error;

        if( !(i = GetDriverVersionDirectory(szConfigFile,
                                            (DWORD)(COUNTOF(szConfigFile) - wcslen(pIniPrinter->pIniDriver->pConfigFile) - 1),
                                            pSpool->pIniSpooler,
                                            pIniEnvironment,
                                            pIniVersion,
                                            pIniPrinter->pIniDriver,
                                            NULL)) ) {
            goto error;
        }

        if (!BoolFromStatus(StrNCatBuff(&szConfigFile[i], COUNTOF(szConfigFile) - i, L"\\", pIniPrinter->pIniDriver->pConfigFile, NULL))) {

            goto error;
        }

        if (!(hModule = LoadLibrary(szConfigFile))) {
            goto error;
        }

        if (!(pDevCap = reinterpret_cast<PDEVCAP>(GetProcAddress(hModule, "DrvDeviceCapabilities")))) {
            goto error;
        }

        pSplDevCaps = reinterpret_cast<PSPLDEVCAP>(GetProcAddress(hModule, (LPCSTR) MAKELPARAM(254, 0)));

    } else {
        goto error;
    }


    DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: driver found\n"));

    INCPRINTERREF(pIniPrinter);
    //
    // We need to use UNC format so we go to the right pIniSpooler.
    // For instance, we won't find the printer if it's in the cluster pIniSpooler and we don't use
    // the virtual cluster name (\\server\printer).
    //
    if ((dwTemp = StrNCatBuff(pPrinterName,
                              MAX_UNC_PRINTER_NAME,
                              pIniPrinter->pIniSpooler->pMachineName,
                              L"\\",
                              pIniPrinter->pName,
                              L",LocalsplOnly",
                              NULL)) != ERROR_SUCCESS)
    {
        SetLastError(dwTemp);
        goto error;
    }

    LeaveSplSem();
    bInSplSem = FALSE;

    if (!(*pfnOpenPrinter)(pPrinterName, &hDevCapPrinter, NULL)) {
        dwResult = GetLastError();
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: OpenPrinter failed %d\n",
                           dwResult));

        goto error;
    }

    //
    // DS property: printBinNames
    //
    if (!DevCapMultiSz( hPrinter,
                        hDevCapPrinter,
                        pDevCap,
                        NULL,
                        pPrinterName,
                        DC_BINNAMES,
                        24,
                        SPLDS_PRINT_BIN_NAMES)) {
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_BINNAMES failed %d\n", GetLastError()));
    }

    //
    // DS property: printCollate (awaiting DC_COLLATE)
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_COLLATE,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_COLLATE,
                            REG_BINARY,
                            (PBYTE) &dwResult,
                            sizeof(BYTE));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Collate, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_COLLATE failed %d\n", GetLastError()));
    }

    //
    // DS property: printColor
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_COLORDEVICE,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult == GDI_ERROR) {

        //
        // Try alternative method
        //
        dwResult = ThisIsAColorPrinter(pIniPrinter->pName);
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_COLORDEVICE failed %d\n", GetLastError()));
    }

    dwResult = SplSetPrinterDataEx(
                        hPrinter,
                        SPLDS_DRIVER_KEY,
                        SPLDS_PRINT_COLOR,
                        REG_BINARY,
                        (PBYTE) &dwResult,
                        sizeof(BYTE));
#if DBG
    if (dwResult != ERROR_SUCCESS)
        DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Color, %x\n", dwResult) );
#endif
    
    //
    // DS property: printDuplexSupported
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_DUPLEX,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {
        dwResult = !!dwResult;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_DUPLEX_SUPPORTED,
                            REG_BINARY,
                            (PBYTE) &dwResult,
                            sizeof(BYTE));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Duplex, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_DUPLEX failed %d\n", GetLastError()));
    }

    //
    // DS property: printStaplingSupported
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_STAPLE,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_STAPLING_SUPPORTED,
                            REG_BINARY,
                            (PBYTE) &dwResult,
                            sizeof(BYTE));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Duplex, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_STAPLE failed %d\n", GetLastError()));
    }

    //
    // DS property: printMaxXExtent & printMaxYExtent
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_MAXEXTENT,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        *((DWORD *) &point) = dwResult;

        dwTemp = (DWORD) point.x;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_MAX_X_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: MaxXExtent, %x\n", dwResult) );
#endif

        dwTemp = (DWORD) point.y;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_MAX_Y_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: MaxYExtent, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_MAXEXTENT failed %d\n", GetLastError()));
    }

    //
    // DS property: printMinXExtent & printMinYExtent
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_MINEXTENT,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        *((DWORD *) &point) = dwResult;

        dwTemp = (DWORD) point.x;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_MIN_X_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: MinXExtent, %x\n", dwResult) );
#endif

        dwTemp = (DWORD) point.y;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_MIN_Y_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: MinYExtent, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_MINEXTENT failed %d\n", GetLastError()));
    }
    
    //
    // DS property: printMediaSupported - Not part of printQueue, but is in Schema
    //
    if (!DevCapMultiSz( hPrinter,
                        hDevCapPrinter,
                        pDevCap,
                        pSplDevCaps,
                        pPrinterName,
                        DC_PAPERNAMES,
                        64,
                        SPLDS_PRINT_MEDIA_SUPPORTED)) {
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_PAPERNAMES failed %d\n", GetLastError()));
    }

    //
    // DS property: printMediaReady
    //
    if (!DevCapMultiSz( hPrinter,
                        hDevCapPrinter,
                        pDevCap,
                        pSplDevCaps,
                        pPrinterName,
                        DC_MEDIAREADY,
                        64,
                        SPLDS_PRINT_MEDIA_READY)) {
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_MEDIAREADY failed %d\n", GetLastError()));
    }

    //
    // DS property: printNumberUp
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_NUP,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_NUMBER_UP,
                            REG_DWORD,
                            (PBYTE) &dwResult,
                            sizeof(DWORD));

#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: NumberUp, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_NUP failed %d\n", GetLastError()));
    }

    //
    // DS property: printMemory
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_PRINTERMEM,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_MEMORY,
                            REG_DWORD,
                            (PBYTE) &dwResult,
                            sizeof(DWORD));

#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: printMemory, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_PRINTERMEM failed %d\n", GetLastError()));
    }

    //
    // DS property: printOrientationsSupported
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_ORIENTATION,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        SIZE_T cchRemaining = COUNTOF(Buf);

        if (dwResult == 90 || dwResult == 270) {
            StrCchCopyMultipleStr(Buf, COUNTOF(Buf), L"PORTRAIT", &pStr, &cchRemaining);
            StrCchCopyMultipleStr(pStr, cchRemaining, L"LANDSCAPE", &pStr, &cchRemaining);
        }
        else {
            StrCchCopyMultipleStr(Buf, COUNTOF(Buf), L"PORTRAIT", &pStr, &cchRemaining);
        }

        if (cchRemaining)
        {
            *pStr++ = L'\0';

            dwResult = SplSetPrinterDataEx(
                                hPrinter,
                                SPLDS_DRIVER_KEY,
                                SPLDS_PRINT_ORIENTATIONS_SUPPORTED,
                                REG_MULTI_SZ,
                                (PBYTE) Buf,
                                (DWORD) ((ULONG_PTR) pStr - (ULONG_PTR) Buf));

        }
        else
        {
            dwResult = ERROR_INSUFFICIENT_BUFFER;
        }

#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Orientations, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_ORIENTATION failed %d\n", GetLastError()));
    }

    //
    // DS property: printMaxResolutionSupported
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_ENUMRESOLUTIONS,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        if (cOutputBytes < dwResult*2*sizeof(DWORD)) {
            if(!(pTemp1 = (LPWSTR) ReallocSplMem(pOutput, 0, cOutputBytes = dwResult*2*sizeof(DWORD))))
                goto error;
            pOutput = pTemp1;
        }

        _try {
            dwResult = (*pDevCap)(  hDevCapPrinter,
                                    pPrinterName,
                                    DC_ENUMRESOLUTIONS,
                                    pOutput,
                                    NULL);
        } _except(1) {
            SetLastError(GetExceptionCode());
            dwResult = GDI_ERROR;
        }
        if (dwResult != GDI_ERROR && dwResult > 0) {

            //
            // Find the maximum resolution: we have dwResult*2 resolutions to check
            //
            _try {
                for(i = dwTemp = 0 ; i < dwResult*2 ; ++i) {
                    if (((DWORD *) pOutput)[i] > dwTemp)
                        dwTemp = ((DWORD *) pOutput)[i];
                }

                dwResult = SplSetPrinterDataEx(
                                    hPrinter,
                                    SPLDS_DRIVER_KEY,
                                    SPLDS_PRINT_MAX_RESOLUTION_SUPPORTED,
                                    REG_DWORD,
                                    (PBYTE) &dwTemp,
                                    sizeof(DWORD));
            } _except(1) {
                SetLastError(dwResult = GetExceptionCode());
            }

#if DBG
            if (dwResult != ERROR_SUCCESS)
                DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Resolution, %x\n", dwResult) );
#endif
        }
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_ENUMRESOLUTIONS failed %d\n", GetLastError()));
    }


    //
    // DS property: printLanguage
    //
    if (!DevCapMultiSz( hPrinter,
                        hDevCapPrinter,
                        pDevCap,
                        NULL,
                        pPrinterName,
                        DC_PERSONALITY,
                        32,
                        SPLDS_PRINT_LANGUAGE)) {
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_PERSONALITY failed %d\n", GetLastError()));
    }

    //
    // DS property: printRate
    // NOTE: If PrintRate is 0, no value is published
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_PRINTRATE,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    dwPrintRate = dwResult ? dwResult : GDI_ERROR;
    if (dwPrintRate != GDI_ERROR) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_RATE,
                            REG_DWORD,
                            (PBYTE) &dwPrintRate,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: PrintRate, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_PRINTRATE failed %d\n", GetLastError()));
    }

    //
    // DS property: printRateUnit
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_PRINTRATEUNIT,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    dwPrintRateUnit = dwResult;

    //
    // If the capability isn't supported, set printRateUnit to empty string.
    //
    switch (dwPrintRateUnit) {
        case PRINTRATEUNIT_PPM:
            pStr = L"PagesPerMinute";
            break;

        case PRINTRATEUNIT_CPS:
            pStr = L"CharactersPerSecond";
            break;

        case PRINTRATEUNIT_LPM:
            pStr = L"LinesPerMinute";
            break;

        case PRINTRATEUNIT_IPM:
            pStr = L"InchesPerMinute";
            break;

        default:
            pStr = L"";
            break;
    }

    if (pStr) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_RATE_UNIT,
                            REG_SZ,
                            (PBYTE) pStr,
                            (wcslen(pStr) + 1)*sizeof *pStr);
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: PrintRateUnit, %x\n", dwResult) );
#endif
    } else {
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_PRINTRATEUNIT no unit %d\n", dwPrintRateUnit ));
    }

    //
    // printPagesPerMinute
    // DevCap returns 0 if there is no entry in GPD
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_PRINTRATEPPM,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }

    if (dwResult == GDI_ERROR)
        dwResult = 0;

    dwPrintPPM = dwResult;

    //
    // If dwPrintPPM == 0, then calculate PPM from PrintRate
    //
    if (dwPrintPPM == 0) {
        if (dwPrintRate == GDI_ERROR) {
            dwPrintPPM = GDI_ERROR;
        } else {
            switch (dwPrintRateUnit) {
                case PRINTRATEUNIT_PPM:
                    dwPrintPPM = dwPrintRate;
                    break;

                case PRINTRATEUNIT_CPS:
                case PRINTRATEUNIT_LPM:
                    dwPrintPPM = dwPrintRate/PPM_FACTOR;
                    if (dwPrintPPM == 0)
                        dwPrintPPM = 1;     // min PPM is 1
                    break;

                default:

                    DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: PRINTRATEUNIT not found %d\n",
                                       dwPrintRateUnit));
                    dwPrintPPM = GDI_ERROR;
                    break;
            }
        }
    }
    if (dwPrintPPM != GDI_ERROR) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_PAGES_PER_MINUTE,
                            REG_DWORD,
                            (PBYTE) &dwPrintPPM,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG(DBG_WARNING, ("UpdateDsDriverKey: PrintPagesPerMinute, %x\n", dwResult));
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: PPM failed %d\n", GetLastError()));
    }


    //
    // printDriverVersion
    //
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_VERSION,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_DRIVER_VERSION,
                            REG_DWORD,
                            (PBYTE) &dwResult,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Driver Version, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_VERSION failed %d\n", GetLastError()));
    }



error:

    if (hDevCapPrinter)
        (*pfnClosePrinter)(hDevCapPrinter);

    if (!bInSplSem) {
        EnterSplSem();
        DECPRINTERREF(pIniPrinter);
    }

    if (hModule)
        FreeLibrary(hModule);

    FreeSplMem(pOutput);
    FreeSplMem(pTemp);
}


BOOL
DevCapMultiSz(
    HANDLE      hPrinter,
    HANDLE      hDevCapPrinter,
    PDEVCAP     pDevCap,
    PSPLDEVCAP  pSplDevCap,
    PWSTR       pszPrinterName,
    WORD        fwCapability,
    DWORD       dwElementBytes,
    PWSTR       pszRegValue
)
/*++
Function Description:
    This function writes a multisz devcap string to the DsDriverKey registry

Parameters:
    hPrinter       - printer handle
    hDevCapPrinter - devcap handle
    pDevCap        - devcap function pointer
    pszPrinterName - name of the printer
    fwCapability - devcap capability entry
    dwElementBytes - length of each string element in the array returned by devcaps
    pszRegValue - name of the registry value to which the multisz string will be written

Return Values:
    BOOL - TRUE if successful, FALSE if not.  Call GetLastError to retrieve failure error.

--*/
{
    DWORD dwResult, cbBytes;
    PWSTR pszDevCapBuffer = NULL;
    PWSTR pszRegData = NULL;

    _try {
        dwResult = GDI_ERROR;
        if (pSplDevCap) {
            dwResult = (*pSplDevCap)(   hDevCapPrinter,
                                        pszPrinterName,
                                        fwCapability,
                                        NULL,
                                        0,
                                        NULL);
        } else {
        
            dwResult = (*pDevCap)(  hDevCapPrinter,
                                    pszPrinterName,
                                    fwCapability,
                                    NULL,
                                    NULL);
        }

        if (dwResult != GDI_ERROR) {

            //
            // DeviceCapabilities doesn't take a buffer size parameter, so if you get
            // printer properties on a hundred or so printers at the same time, you will
            // occasionally hit the case where win32 cache is deleting & adding forms in
            // RefreshFormsCache and DC_PAPERNAMES calls EnumForms and gets different
            // results.  The first call may return 3 forms and second returns 20.  So we
            // allocate a big buffer here so third party drivers don't AV.  For unidrv
            // we have a different interface that accepts a buffer size.
            //
            if (fwCapability == DC_PAPERNAMES || fwCapability == DC_MEDIAREADY) {

                //
                // If the driver dowsn't support the DeviceCapabilities that takes a buffer size, then
                // allocate a bigger buffer. 
                //
                dwResult += LOTS_OF_FORMS;
            }            

            cbBytes = dwResult*dwElementBytes*sizeof(WCHAR);

            pszDevCapBuffer = (PWSTR) AllocSplMem(cbBytes);

            if (pszDevCapBuffer) {
                dwResult = GDI_ERROR;
                if (pSplDevCap) {
                    dwResult = (*pSplDevCap)(   hDevCapPrinter,
                                                pszPrinterName,
                                                fwCapability,
                                                pszDevCapBuffer,
                                                cbBytes/sizeof(WCHAR),
                                                NULL);
                    
                } else {
                
                    dwResult = (*pDevCap)(  hDevCapPrinter,
                                            pszPrinterName,
                                            fwCapability,
                                            pszDevCapBuffer,
                                            NULL);
                }

                if (dwResult != GDI_ERROR) {
                    if (!(pszRegData = DevCapStrings2MultiSz(pszDevCapBuffer, dwResult, dwElementBytes, &cbBytes))) {
                        dwResult = GDI_ERROR;
                    }
                }
            } else {
                dwResult = GDI_ERROR;
            }
        }
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }

    if (dwResult != GDI_ERROR) {

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            pszRegValue,
                            REG_MULTI_SZ,
                            (PBYTE) pszRegData,
                            cbBytes);

        if (dwResult != ERROR_SUCCESS) {
            SetLastError(dwResult);
            dwResult = GDI_ERROR;
        }
    } else {

        WCHAR   szzNull[2];
        szzNull[0] = szzNull[1] = '\0';

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            pszRegValue,
                            REG_MULTI_SZ,
                            (PBYTE) szzNull,
                            2 * sizeof(WCHAR));
    }

    FreeSplStr(pszDevCapBuffer);
    FreeSplStr(pszRegData);

    return dwResult != GDI_ERROR;
}

extern "C" DWORD
RecreateDsKey(
    HANDLE  hPrinter,
    PWSTR   pszKey
)
{
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    PINIPRINTER pIniPrinter = pSpool->pIniPrinter;

    if (pSpool->pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL)
    {
        //
        // Clears existing published properties and recreates & republishes Registry key
        //
        SplOutSem();

        //
        // Clear all published Properties under Key
        //
        ClearDsKey(hPrinter, pszKey);

        //
        // Delete Key
        //
        EnterSplSem();
        SplDeletePrinterKey(hPrinter, pszKey);

        //
        // Recreate Key
        //
        if (!wcscmp(pszKey, SPLDS_DRIVER_KEY)) {
            UpdateDsDriverKey(hPrinter);
        }
        else if (!wcscmp(pszKey, SPLDS_SPOOLER_KEY)) {
            UpdateDsSpoolerKey(hPrinter, 0xffffffff);
        }

        //
        // Republish Key
        //
        SetPrinterDs(hPrinter, DSPRINT_UPDATE, FALSE);

        LeaveSplSem();
        SplOutSem();
    }

    return ERROR_SUCCESS;
}


// ClearDsKey: clears all properties in specified key

HRESULT
ClearDsKey(
    HANDLE hPrinter,
    PWSTR  pszKey
)
{
    HRESULT                 hr = ERROR_SUCCESS;
    DWORD                   i;
    DWORD                   cbEnumValues = 0;
    PPRINTER_ENUM_VALUES    pEnumValues = NULL;
    DWORD                   nEnumValues;
    DWORD                   dwResult;
    PSPOOL                  pSpool = (PSPOOL)hPrinter;
    PINIPRINTER             pIniPrinter = pSpool->pIniPrinter;
    IADs                    *pADs = NULL;
    HANDLE                  hToken = NULL;
    VARIANT                 var;


    SplOutSem();

    //
    // If we're not published, there's no DS key to clear, so just return success
    //
    if (!pIniPrinter->pszObjectGUID)
        return S_OK;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
        return hr;

    hToken = RevertToPrinterSelf(); // All DS accesses are done by LocalSystem account

    //
    // Enumerate and Publish Key
    //
    dwResult = SplEnumPrinterDataEx(    hPrinter,
                                        pszKey,
                                        NULL,
                                        0,
                                        &cbEnumValues,
                                        &nEnumValues
                                     );

    if (dwResult != ERROR_MORE_DATA) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        goto error;
    }

    if (!(pEnumValues = (PPRINTER_ENUM_VALUES) AllocSplMem(cbEnumValues))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwResult = SplEnumPrinterDataEx(    hPrinter,
                                        pszKey,
                                        (LPBYTE) pEnumValues,
                                        cbEnumValues,
                                        &cbEnumValues,
                                        &nEnumValues
                                     );
    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        goto error;
    }

    //
    // Get or Create printQueue object
    //
    hr = GetPrintQueue(hPrinter, &pADs);
    BAIL_ON_FAILURE(hr);

    //
    // Clear Published Properties
    //
    VariantInit(&var);

    for (i = 0 ; i < nEnumValues ; ++i) {

        hr = pADs->PutEx(
                ADS_PROPERTY_CLEAR,
                pEnumValues[i].pValueName,
                var
                );

#if DBG
        if (FAILED(hr))
            DBGMSG(DBG_EXEC, ("Failed to clear property: %ws\n", pEnumValues[i].pValueName));
#endif
    }

    hr = pADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    FreeSplMem(pEnumValues);

    if (hToken)
        ImpersonatePrinterClient(hToken);

    if (pADs) {
        pADs->Release();
    }

    CoUninitialize();

    return hr;
}



HRESULT
CreateAce(
    IADsAccessControlList   *pACL,
    BSTR                    pszTrustee,
    DWORD                   dwAccessMask
)
{
    IADsAccessControlEntry  *pACE = NULL;
    IDispatch               *pACEDispatch = NULL;
    HRESULT                 hr;

    //
    // Create ACE
    //
    hr = CoCreateInstance(  CLSID_AccessControlEntry,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IADsAccessControlEntry,
                            (void **) &pACE);
    BAIL_ON_FAILURE(hr);

    hr = pACE->put_AccessMask(dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pACE->put_AceType(ACCESS_ALLOWED_ACE_TYPE);
    BAIL_ON_FAILURE(hr);

    hr = pACE->put_AceFlags(0);
    BAIL_ON_FAILURE(hr);

    hr = pACE->put_Trustee(pszTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pACE->QueryInterface(IID_IDispatch, (void **) &pACEDispatch);
    BAIL_ON_FAILURE(hr);

    hr = pACL->AddAce(pACEDispatch);
    BAIL_ON_FAILURE(hr);

error:

    if (pACEDispatch)
        pACEDispatch->Release();

    if (pACE)
        pACE->Release();

    return hr;
}



HRESULT
AddClusterAce(
    PSPOOL  pSpool,
    IADs    *pADsPrintQueue
)
{
    PINIPRINTER                 pIniPrinter             = pSpool->pIniPrinter;
    IDispatch                   *pSDPrintQueueDispatch  = NULL;
    IADsSecurityDescriptor      *pSDPrintQueue          = NULL;
    IDispatch                   *pACLPrintQueueDispatch = NULL;
    IADsAccessControlList       *pACLPrintQueue         = NULL;
    HRESULT                     hr;

    //
    // If we don't have a GUID, then we're not a cluster and we don't need to add the ACE
    //
    if (!pIniPrinter->pIniSpooler->pszClusterSID)
        return S_OK;
    //
    // Get the PrintQueue Security Descriptor
    //
    hr = get_Dispatch_Property(pADsPrintQueue, L"nTSecurityDescriptor", &pSDPrintQueueDispatch);
    BAIL_ON_FAILURE(hr);

    hr = pSDPrintQueueDispatch->QueryInterface(IID_IADsSecurityDescriptor, (void **) &pSDPrintQueue);
    BAIL_ON_FAILURE(hr);

    //
    // Get DACL from the Security Descriptor
    //
    hr = pSDPrintQueue->get_DiscretionaryAcl(&pACLPrintQueueDispatch);
    BAIL_ON_FAILURE(hr);

    hr = pACLPrintQueueDispatch->QueryInterface(IID_IADsAccessControlList, (void **) &pACLPrintQueue);
    BAIL_ON_FAILURE(hr);

    hr = CreateAce(pACLPrintQueue, (BSTR) pIniPrinter->pIniSpooler->pszClusterSID, GENERIC_ALL);
    BAIL_ON_FAILURE(hr);

    //
    // Write the ACL back to the Security Descriptor
    //
    hr = pSDPrintQueue->put_DiscretionaryAcl(pACLPrintQueueDispatch);
    BAIL_ON_FAILURE(hr);

    //
    // Write the Security Descriptor back to the object
    //
    hr = put_Dispatch_Property(pADsPrintQueue, L"nTSecurityDescriptor", pSDPrintQueueDispatch);
    BAIL_ON_FAILURE(hr);

    hr = pADsPrintQueue->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    if (pACLPrintQueueDispatch)
        pACLPrintQueueDispatch->Release();

    if (pACLPrintQueue)
        pACLPrintQueue->Release();

    if (pSDPrintQueueDispatch)
        pSDPrintQueueDispatch->Release();

    if (pSDPrintQueue)
        pSDPrintQueue->Release();


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\aspapp\ipp_0000.inc ===
<%
'------------------------------------------------------------
'
' Microsoft Internet Printing Project
'
' Copyright (c) Microsoft Corporation. All rights reserved.
'
'------------------------------------------------------------
Const SNMP_ALERT_SEVERITY       = 0
Const SNMP_ALERT_INDEX          = 1
Const SNMP_ALERT_SUBUNIT        = 2
Const SNMP_ALERT_DESCRIPTION    = 3
Const SNMP_ALERT_CODE           = 4
Const SNMP_ALERT_TRAINING       = 5
Const SNMP_ALERT_ATTRIBUTES     = 5
Const SNMP_INTRAY_TYPE          = 0
Const SNMP_INTRAY_UNITS         = 1
Const SNMP_INTRAY_MAX           = 2
Const SNMP_INTRAY_CURRENT       = 3
Const SNMP_INTRAY_STATE         = 4
Const SNMP_INTRAY_MEDIA         = 5
Const SNMP_INTRAY_UNIT          = 6
Const SNMP_INTRAY_NAME          = 7
Const SNMP_INTRAY_ATTRIBUTES    = 7
Const SNMP_LIGHT_ON             = 0
Const SNMP_LIGHT_OFF            = 1
Const SNMP_LIGHT_COLOR          = 2
Const SNMP_LIGHT_DESCRIPTION    = 3
Const SNMP_LIGHT_ATTRIBUTES     = 3

Function rgSNMPGetState(objSNMP, iDevice)
    Dim rgFetchList, rgState, StrDevice, rgFetchValue, hrPrintDetectedState

    On Error Resume Next
    Err.Clear
    StrDevice = CStr(iDevice)
    rgFetchList = Array("25.3.2.1.5." & StrDevice, "25.3.5.1.1." & StrDevice)

    hrPrintDetectedState = objSNMP.GetAsByte ("25.3.5.1.2." & StrDevice)
    If Err Then Exit Function

    rgFetchValue = objSNMP.GetList(rgFetchList)
    If Err Then Exit Function

    rgState = Array (rgFetchValue(0), rgFetchValue(1), hrPrintDetectedState)
    If Err Then Exit Function

    rgSNMPGetState = rgState
End Function

Function GetLastNode (strMib)
    Dim strTmp, j

    For j = 1 To Len (strMib)
        strTmp = Right (strMib, j)
        If Left (strTmp, 1) = "." Then
            GetLastNode = strTmp
            Exit Function
        End If
    Next
    GetLastNode = ""
End Function

Function rgSNMPGetAlerts(objSNMP, objHelper, iDevice, iAlerts)
    Dim rgTmp, rgAlerts()
    Dim i, StrDevice

    On Error Resume Next

    iAlerts = -1
    StrDevice = CStr(iDevice)
    rgTmp = objSNMP.GetTree("43.18.1.1.2." & StrDevice) 'alert severities
    If Err Then 'assume there is not alert table
        Err.Clear
        Exit Function
    End If

    If UBound(rgTmp, 2) >= 0 Then
        iAlerts = UBound(rgTmp, 2)

        ReDim rgAlerts(SNMP_ALERT_ATTRIBUTES, iAlerts)

        For i = 0 to iAlerts
            rgAlerts(SNMP_ALERT_INDEX, i) = i
            rgAlerts(SNMP_ALERT_SEVERITY, i) = rgTmp(1, i)
        Next

        'rgTmp = objSNMP.GetTree("43.18.1.1.3." & StrDevice)

        'If UBound(rgTmp,2)  = iAlerts Then
        '    For i = 0 to iAlerts
        '        rgAlerts(SNMP_ALERT_TRAINING, i) = rgTmp(1, i)
        '    Next
        'End If

        rgTmp = objSNMP.GetTree("43.18.1.1.4." & StrDevice)

        If UBound(rgTmp,2)  = iAlerts Then
            For i = 0 to iAlerts
                rgAlerts(SNMP_ALERT_SUBUNIT, i) = rgTmp(1, i)
            Next
        End If

        rgTmp = objSNMP.GetTree("43.18.1.1.5." & StrDevice)

        If UBound(rgTmp,2)  = iAlerts Then
            For i = 0 to iAlerts
                rgAlerts(SNMP_ALERT_INDEX, i) = rgTmp(1, i)
            Next
        End If

        rgTmp = objSNMP.GetTree("43.18.1.1.7." & StrDevice)

        If UBound(rgTmp,2)  = iAlerts Then
            For i = 0 to iAlerts
                rgAlerts(SNMP_ALERT_CODE, i) = rgTmp(1, i)
            Next

            For i = 0 to iAlerts
                If rgTmp(1,i) = 1 Then 'Other Error
                    rgAlerts(SNMP_ALERT_DESCRIPTION, i) = objSNMP.Get ("43.18.1.1.8." & StrDevice & GetLastNode (rgTmp (0, i)))
                    If rgAlerts(SNMP_ALERT_DESCRIPTION, i) = "" Then
                        rgAlerts(SNMP_ALERT_DESCRIPTION, i) = objHelper.MibErrorDscp (rgTmp(1, i))
                    End If
                Else
                    rgAlerts(SNMP_ALERT_DESCRIPTION, i) = objHelper.MibErrorDscp (rgTmp(1, i))
                    If rgAlerts(SNMP_ALERT_DESCRIPTION, i) = "" Then
                        rgAlerts(SNMP_ALERT_DESCRIPTION, i) = objSNMP.Get ("43.18.1.1.8." & StrDevice & GetLastNode (rgTmp (0, i)))
                    End If
                End If
            Next

        End If

        rgSNMPGetAlerts = rgAlerts
    End If
End Function

Function rgSNMPGetInputTrays(objSNMP, iDevice, iTrays)
    Dim rgWork, iFetch, StrDevice, i, rgTrays()
    Dim j
    Dim rgFetchOid(7)

    On Error Resume Next
    Err.Clear

    StrDevice = CStr(iDevice)
    rgFetchOid(0) = "43.8.2.1.2." & StrDevice      'type
    rgFetchOid(1) = "43.8.2.1.8." & StrDevice      'units
    rgFetchOid(2) = "43.8.2.1.9." & StrDevice      'max
    rgFetchOid(3) = "43.8.2.1.10." & StrDevice     'current
    rgFetchOid(4) = "43.8.2.1.11." & StrDevice     'state
    rgFetchOid(5) = "43.8.2.1.12." & StrDevice     'media
    rgFetchOid(6) = "43.8.2.1.13." & StrDevice     'input unit
    rgFetchOid(7) = "43.8.2.1.18." & StrDevice     'trayname



    rgWork = objSNMP.GetTree(rgFetchOid(0))
    If Err Then Exit Function
    iTrays = UBound(rgWork, 2)


    If iTrays >= 0 Then
        ReDim rgTrays(SNMP_INTRAY_ATTRIBUTES, iTrays)

        For j = 0 To 7
            If j <> 0 Then
                rgWork = objSNMP.GetTree(rgFetchOid(j))
                If Err Then Exit Function
            End If

            For i = 0 To UBound(rgWork, 2)
                rgTrays(j, i) = rgWork(1, i)
            Next
        Next

        rgSNMPGetInputTrays = rgTrays

    End If
End Function

Function strAppendStr (strBody, strTail)
    Dim L_Comma_Text

    L_Comma_Text = ", "

    If strBody = "" Then
        strAppendStr = strTail
    Else
        strAppendStr = strBody & L_Comma_Text & strTail
    End If
End Function

Function strSNMPStatus(rgState)
    Dim strHTML
    Dim str1, str2, strSubject
    Dim bDisplay
    Dim L_DeviceStatus_Text
    Dim L_UpRunning_Text, L_Warning_Text, L_Tested_Text, L_UnAvailable_Text
    Dim L_IdleState_Text, L_Printing_Text, L_WarmingUp_Text
    Const strIndent = "&nbsp;"

    L_DeviceStatus_Text  = "<B>Status:</b> "
    L_UpRunning_Text     = "<font color = red>Up and Running</font>"
    L_Warning_Text       = "<font color = red>Functioning but has one or more warnings</font>"
    L_Tested_Text        = "<font color = red>Being tested</font>"
    L_UnAvailable_Text   = "<font color = red>Unavailable for any use</font>"
    L_IdleState_Text     = "<p>In an idle state</p>"
    L_Printing_Text      = " Printing documents "
    L_WarmingUp_Text     = " Warming up "

    strHTML = "<table><tr><td>" & strIndent & "</td><td>" & DEF_FONT_TAG

    Select Case rgState(1)
        Case 4
            str2 = L_Printing_Text
        Case 5
            str2 = L_WarmingUp_Text
        Case Else
            str2 = ""
    End Select

    If str2 <> "" Then
        strHTML = strHTML & " - " & str2
    End If

    bDisplay = TRUE
    Select Case rgState(0)
        Case 2
            str1 = L_UpRunning_Text
        Case 3
            str1 = L_Warning_Text
        Case 4
            str1 = L_Tested_Text
        Case 5
            str1 = L_UnAvailable_Text
        Case Else
            bDisplay = FALSE
    End Select
    If bDisplay Then
        strHTML = strHTML & str1
    End If

    strHTML = strHTML & "</font></td></tr>"

    If (rgState(0) = 3 Or rgState(0) = 5) Then
        Dim lErrState, lMask, lNumMsg
        Dim L_ErrMsg_Text(7)
        Const L_DetectedWarn_Text = "<b>Warnings:</b> "
        Const L_DetectedErr_Text  = "<b>Errors:</b> "

        L_ErrMsg_Text(0) = "service requested"
        L_ErrMsg_Text(1) = "offline"
        L_ErrMsg_Text(2) = "paper jammed"
        L_ErrMsg_Text(3) = "door open"
        L_ErrMsg_Text(4) = "no toner"
        L_ErrMsg_Text(5) = "toner low"
        L_ErrMsg_Text(6) = "out of paper"
        L_ErrMsg_Text(7) = "low paper"

        lErrState = CInt (rgState(2))

        str1 = ""
        lMask = 1
        lNumMsg = 0
        For i = 0 To 7
            If lErrState And lMask Then
                str1 = strAppendStr (str1, L_ErrMsg_Text(i))
                lNumMsg = lNumMsg + 1
            End If
            lMask = lMask * 2
        Next

        If lNumMsg > 0 Then
            strHTML = strHTML & "<tr><td>" & strIndent & "</td><td>" & DEF_FONT_TAG
            If rgState(0) = 3 Then
                strHTML = strHTML & L_DetectedWarn_Text
            Else
                strHTML = strHTML & L_DetectedErr_Text
            End If

            strHTML = strHTML & str1 & "</font></td></tr>"
        End If
    End If

    strHTML = strHTML & "</table>"

    strSNMPStatus = strHTML

End Function

Function rgSNMPConsole(objSNMP, iDevice, iRow, iColumn, rgConText, strLang)

Const prtConsoleLocalization = "43.5.1.1.10."
Const prtConsoleNumberOfDisplayLines = "43.5.1.1.11."
Const prtConsoleNumberOfDisplayChars = "43.5.1.1.12."
Const prtConsoleDisplayBufferText = "43.16.5.1.2."
Const prtLocalizationLanguage = "43.7.1.1.3."

    Dim StrDevice, i, rgOidList, rgConsole

    StrDevice = CStr(iDevice)
    rgSNMPConsole = False
    rgConText = ""

    rgOidList = Array(prtConsoleLocalization & StrDevice, prtConsoleNumberOfDisplayLines & StrDevice, prtConsoleNumberOfDisplayChars & StrDevice)
    rgConsole = objSNMP.GetList(rgOidList)
    If Err.Number <> 0 Then Exit Function

    iRow = rgConsole(1)
    iColumn = rgConsole(2)

    if iRow <> 0 Then

        ReDim rgConTextOidList(iRow - 1)
        For i = 0 To iRow - 1
            rgConTextOidList(i) = prtConsoleDisplayBufferText & StrDevice & "." & CStr(i + 1)
        Next

        rgConText = objSNMP.GetList(rgConTextOidList)
        If Err.Number <> 0 Then Exit Function

        strLang = objSNMP.Get (prtLocalizationLanguage & StrDevice & "." & rgConsole(0))
        If Err.Number <> 0 Then Exit Function
    End If

    rgSNMPConsole = True

End Function


Function rgSNMPLights(objSNMP, iDevice, iLights)
    Dim rgWork
    Dim rgFetchOid(4)
    Dim StrDevice

    StrDevice = CStr(iDevice)
	
    On Error Resume Next
    rgFetchOid(0) = "43.17.6.1.2." & StrDevice & "."
    rgFetchOid(1) = "43.17.6.1.3." & StrDevice & "."
    rgFetchOid(2) = "43.17.6.1.4." & StrDevice & "."
    rgFetchOid(3) = "43.17.6.1.5." & StrDevice & "."

    rgWork = objSNMP.GetTree(rgFetchOid(0))
    If Err Then Exit Function

    iLights = UBound(rgWork, 2)

    If iLights >= 0 Then
        Dim i, j
        ReDim rgLights(SNMP_LIGHT_ATTRIBUTES, iLights)

        For j = 0 To 3
            If j <> 0 Then
                rgWork = objSNMP.GetTree(rgFetchOid(j))
                If Err Then Exit Function
            End If

            For i = 0 To UBound(rgWork, 2)
                rgLights(j, i) = rgWork(1, i)
            Next
        Next

        rgSNMPLights = rgLights

    End If

End Function
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\drvupgrd.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    drvupgrd.c

Abstract:

    When the system is upgraded from one release to another printer drivers
    (e.g. RASDD ) wants to upgrade is PrinterDriverData to match the new mini driver.

    Setup from NT 4.0 on do this by calling EnumPrinterDriver and then AddPrinterDriver
    for each printer driver that we have installed.

    We call DrvUpgrade each time a printer driver is upgraded.

    For Example, pre NT 3.51 RASDD used to store its regstiry PrinterDriverData
    based on internal indexes into the mini drivers, which was not valid beween
    different updates of the mini driver, so before 3.51 it was by luck if there
    were problems in retriving the settings.   With 3.51 RASDD will convert these
    indexes back to meaningful key names ( like Memory ) so hopefully in future
    we don't have an upgrade problem.

    Note also that other than upgrade time ( which happens once ) DrvUpgrade needs to
    be called on Point and Print whenever a Driver file gets updated.  See Driver.C
    for details.   Or anyone updates a printer driver by calling AddPrinterDriver.

Author:

    Matthew A Felton ( MattFe ) March 11 1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"
#include <winddiui.h>


BOOL
UpdateUpgradeInfoStruct(
    LPBYTE pDriverUpgradeInfo,
    DWORD  dwLevel,
    LPWSTR pPrinterNameWithToken,
    LPWSTR pOldDriverDir,
    LPBYTE pDriverInfo
)

/*++
Function Description: This function fills in the Upgrade_Info struct with the
                      other parameters

Parameters: pDriverUpgradeInfo    -- pointer Upgrade_Info_* struct
            dwLevel               -- Upgrade_Info level
            pPrinterNameWithToken -- printer name
            pOldDriverDir         -- Directory containing the old driver files
            pDriverInfo           -- pointer to driver_info_4 struct

Return Values: TRUE for sucesss;
               FALSE otherwise
--*/

{
    BOOL  bReturn = TRUE;

    PDRIVER_UPGRADE_INFO_1 pDrvUpgInfo1;
    PDRIVER_UPGRADE_INFO_2 pDrvUpgInfo2;
    PDRIVER_INFO_4         pDriver4;

    switch (dwLevel) {
    case 1:

        pDrvUpgInfo1 = (PDRIVER_UPGRADE_INFO_1) pDriverUpgradeInfo;

        pDrvUpgInfo1->pPrinterName = pPrinterNameWithToken;
        pDrvUpgInfo1->pOldDriverDirectory = pOldDriverDir;

        break;

    case 2:

        if (pDriver4 = (PDRIVER_INFO_4) pDriverInfo) {

            pDrvUpgInfo2 = (PDRIVER_UPGRADE_INFO_2) pDriverUpgradeInfo;

            pDrvUpgInfo2->pPrinterName = pPrinterNameWithToken;
            pDrvUpgInfo2->pOldDriverDirectory = pOldDriverDir;
            pDrvUpgInfo2->cVersion = pDriver4->cVersion;
            pDrvUpgInfo2->pName = pDriver4->pName;
            pDrvUpgInfo2->pEnvironment = pDriver4->pEnvironment;
            pDrvUpgInfo2->pDriverPath = pDriver4->pDriverPath;
            pDrvUpgInfo2->pDataFile = pDriver4->pDataFile;
            pDrvUpgInfo2->pConfigFile = pDriver4->pConfigFile;
            pDrvUpgInfo2->pHelpFile = pDriver4->pHelpFile;
            pDrvUpgInfo2->pDependentFiles = pDriver4->pDependentFiles;
            pDrvUpgInfo2->pMonitorName = pDriver4->pMonitorName;
            pDrvUpgInfo2->pDefaultDataType = pDriver4->pDefaultDataType;
            pDrvUpgInfo2->pszzPreviousNames = pDriver4->pszzPreviousNames;

        } else {

            bReturn = FALSE;
        }

        break;

    default:

        bReturn = FALSE;
        break;
    }

    return bReturn;
}

BOOL
bIsNewFile(
    LPWSTR              pDriverFile,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount
)
/*++
Function Description: This function checks to see if a driver file was updated

Parameters: pDriverFile         -- driver file
            pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
            dwFileCount         -- number of files in file set

Return Values: TRUE for sucesss;
               FALSE otherwise
--*/
{
    DWORD   dwIndex;
    LPCWSTR psz;
    BOOL    bRet = FALSE;
    //
    // Must have some files.
    //
    SPLASSERT( dwFileCount );

    //
    // Search for pDriverFile in  ppFileNames array
    //
    for ( dwIndex = 0; dwIndex < dwFileCount ; ++dwIndex ) {

        if( pInternalDriverFiles[dwIndex].pFileName ) {

            //
            // Find the filename portion of a path
            //
            psz = FindFileName(pInternalDriverFiles[dwIndex].pFileName );

            if( psz ){

                if( !lstrcmpi(pDriverFile, psz) ){

                    //
                    // Check if the file was updated
                    //
                    bRet = pInternalDriverFiles[dwIndex].bUpdated;
                    break;
                }

            }
        }
    }

    return bRet;

}

BOOL
DriversShareFiles(
    PINIDRIVER          pIniDriver1,
    PINIDRIVER          pIniDriver2,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount
)
/*++
Function Description: Determines if the drivers have common files and
                      if the common files were updated

Parameters:  pIniDriver1         -- driver #1
             pIniDriver2         -- driver #2
             pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
             dwFileCount         -- number of files in file set
             pUpdateStatusBitMap -- map of bits that tells what files in the file set were actually updated

Return Values: TRUE if files are shared;
               FALSE otherwise
--*/
{
    LPWSTR  pStr1, pStr2;

    if (!pIniDriver1 || !pIniDriver2) {
        return FALSE;
    }

    if (pIniDriver1->cVersion != pIniDriver2->cVersion) {
        return FALSE;
    }

    //
    // Compare the file names and if they were updated
    //

    if (pIniDriver1->pDriverFile && pIniDriver2->pDriverFile &&
        !lstrcmpi(pIniDriver1->pDriverFile, pIniDriver2->pDriverFile) &&
        bIsNewFile(pIniDriver1->pDriverFile, pInternalDriverFiles, dwFileCount)) {

        return TRUE;
    }

    if (pIniDriver1->pConfigFile && pIniDriver2->pConfigFile &&
        !lstrcmpi(pIniDriver1->pConfigFile, pIniDriver2->pConfigFile) &&
        bIsNewFile(pIniDriver1->pConfigFile, pInternalDriverFiles, dwFileCount)) {

        return TRUE;
    }

    if (pIniDriver1->pHelpFile && pIniDriver2->pHelpFile &&
        !lstrcmpi(pIniDriver1->pHelpFile, pIniDriver2->pHelpFile) &&
        bIsNewFile(pIniDriver1->pHelpFile, pInternalDriverFiles, dwFileCount)) {

        return TRUE;
    }

    if (pIniDriver1->pDataFile && pIniDriver2->pDataFile &&
        !lstrcmpi(pIniDriver1->pDataFile, pIniDriver2->pDataFile) &&
        bIsNewFile(pIniDriver1->pDataFile, pInternalDriverFiles, dwFileCount)) {

        return TRUE;
    }

    // Compare each pair of files from the Dependent file list
    for (pStr1 = pIniDriver1->pDependentFiles;
         pStr1 && *pStr1;
         pStr1 += wcslen(pStr1) + 1) {

        for (pStr2 = pIniDriver2->pDependentFiles;
             pStr2 && *pStr2;
             pStr2 += wcslen(pStr2) + 1) {

            if (!lstrcmpi(pStr1, pStr2) &&
                bIsNewFile(pStr1, pInternalDriverFiles, dwFileCount)) {
                return TRUE;
            }
        }
    }

    return FALSE;
}


BOOL
ForEachPrinterCallDriverDrvUpgrade(
    PINISPOOLER         pIniSpooler,
    PINIDRIVER          pIniDriver,
    LPCWSTR             pOldDriverDir,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    LPBYTE              pDriverInfo
)
/*++

Routine Description:

    This routine is called at Spooler Initialization time if an upgrade is detected.

    It will loop through all printers and then call the Printer Drivers DrvUpgrade
    entry point giving it a chance to upgrade any configuration data ( PrinterDriverData )
    passing them a pointer to the old Drivers Directory.

    This routine also converts devmode to current version by calling the driver.
    If driver does not support devmode conversion we will NULL the devmode so
    that we do not have devmodes of different version in the system.

    SECURITY NOTE - This routine Stops impersonation, because the printer drivers UI dll
    needs to call SetPrinterData even if the user doesn't have permission to do it.
    That is because the driver upgrading the settings.


Arguments:

    pIniSpooler - Pointer to Spooler
    pIniVersion - Pointer to the version of driver added
    pOldDriverDir - Point to Directory where old driver files are stored.
    pInternalDriverFiles - array of INTERNAL_DRV_FILE structures
    dwFileCount - number of files in array
    pUpdateStatusBitMap - map of bits that tells what files in the file set were actually updated
    pDriverInfo - Driver Info buffer


Return Value:

    TRUE    - Success
    FALSE   - something major failed, like allocating memory.

--*/

{
    PINIPRINTER pIniPrinter = NULL;
    LPWSTR      pPrinterNameWithToken = NULL;
    DWORD       dwNeeded;
    DWORD       dwServerMajorVersion;
    DWORD       dwServerMinorVersion;
    BOOL        bInSem = TRUE;
    LPWSTR      pConfigFile = NULL;
    HMODULE     hModuleDriverUI = NULL;
    HANDLE      hPrinter = NULL;
    BOOL        (*pfnDrvUpgrade)() = NULL;
    BOOL        bReturnValue = FALSE;
    DRIVER_UPGRADE_INFO_1   DriverUpgradeInfo1;
    DRIVER_UPGRADE_INFO_2   DriverUpgradeInfo2;
    WCHAR       ErrorBuffer[ 11 ];
    HANDLE      hToken = INVALID_HANDLE_VALUE;
    LPDEVMODE   pNewDevMode = NULL;

try {

    SplInSem();

    SPLASSERT( ( pIniSpooler != NULL ) &&
               ( pIniSpooler->signature == ISP_SIGNATURE ));

    if (!pOldDriverDir && !pDriverInfo) {
        leave;
    }

    //
    //  Stop Impersonating User
    //  So drivers can call SetPrinterData even if the user is not admin.
    //

    hToken = RevertToPrinterSelf();


    //
    //  Loop Through All Printers. Skip the printers that use drivers that doesn't share files with
    //  the updated driver. Skip the printers that share files,but the files weren't updated.
    //

    for ( pIniPrinter = pIniSpooler->pIniPrinter ;
          pIniPrinter ;
          pIniPrinter = pIniPrinter->pNext ) {

        SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );
        SPLASSERT( pIniPrinter->pName != NULL );
        SplInSem();

        // Verify if DrvUpgradePrinter needs to be called on this printer
        if (!DriversShareFiles( pIniPrinter->pIniDriver,
                                pIniDriver,
                                pInternalDriverFiles,
                                dwFileCount)) {
            continue;
        }

        //
        // Cleanup from previous iteration
        //
        FreeSplStr( pPrinterNameWithToken );
        FreeSplStr(pConfigFile);
        FreeSplMem(pNewDevMode);

        pPrinterNameWithToken   = NULL;
        pConfigFile             = NULL;
        pNewDevMode             = NULL;

        //
        // If we download a driver of newer version we need to update
        // pIniPrinter->pIniDriver
        //
        pIniPrinter->pIniDriver = FindLocalDriver(pIniPrinter->pIniSpooler, pIniPrinter->pIniDriver->pName);
        if ( pIniPrinter->pIniDriver->pIniLangMonitor == NULL )
            pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;

        //  Prepare PrinterName to be passed to DrvUpgrade
        //  The name passed is "PrinterName, UpgradeToken"
        //  So that OpenPrinter can do an open without opening
        //  the port in the downlevel connection case.
        //  ( see openprn.c for details )

        pPrinterNameWithToken = pszGetPrinterName( pIniPrinter,
                                                   TRUE,
                                                   pszLocalOnlyToken );

        if ( pPrinterNameWithToken == NULL ) {

            DBGMSG( DBG_WARNING, ("FEPCDDU Failed to allocated ScratchBuffer %d\n", GetLastError() ));
            leave;
        }

        DBGMSG( DBG_TRACE, ("FEPCDDU PrinterNameWithToken %ws\n", pPrinterNameWithToken ));


        pConfigFile = GetConfigFilePath(pIniPrinter);

        if ( !pConfigFile ) {

            DBGMSG( DBG_WARNING, ("FEPCDDU failed SplGetPrinterDriverEx %d\n", GetLastError() ));
            leave;
        }

        INCPRINTERREF(pIniPrinter);

       LeaveSplSem();
       SplOutSem();
       bInSem = FALSE;

        //
        //  Load the UI DLL
        //

        hModuleDriverUI = LoadDriver(pConfigFile);

        if ( hModuleDriverUI == NULL ) {

            DBGMSG( DBG_WARNING, ("FEPCDDU failed LoadLibrary %ws error %d\n", pConfigFile, GetLastError() ));

            StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%d", GetLastError());

            SplLogEvent( pLocalIniSpooler,
                         LOG_ERROR,
                         MSG_DRIVER_FAILED_UPGRADE,
                         FALSE,
                         pPrinterNameWithToken,
                         pConfigFile,
                         ErrorBuffer,
                         NULL );

           SplOutSem();
           EnterSplSem();
           bInSem = TRUE;
           DECPRINTERREF( pIniPrinter );
            continue;
        }

        DBGMSG( DBG_TRACE, ("FEPCDDU successfully loaded %ws\n", pConfigFile ));


        //
        //  Call DrvUpgrade
        //
        pfnDrvUpgrade = (BOOL (*)())GetProcAddress( hModuleDriverUI, "DrvUpgradePrinter" );

        if ( pfnDrvUpgrade != NULL ) {

            try {

                SPLASSERT( pPrinterNameWithToken != NULL );

                SplOutSem();

                //
                //  Call Driver UI DrvUpgrade
                //
                if (UpdateUpgradeInfoStruct((LPBYTE) &DriverUpgradeInfo2, 2,
                                            pPrinterNameWithToken, (LPWSTR) pOldDriverDir,
                                            pDriverInfo)) {

                    bReturnValue = (*pfnDrvUpgrade)(2 , &DriverUpgradeInfo2);
                }

                if ( bReturnValue == FALSE ) {

                    UpdateUpgradeInfoStruct((LPBYTE) &DriverUpgradeInfo1, 1,
                                            pPrinterNameWithToken, (LPWSTR) pOldDriverDir,
                                            NULL);

                    bReturnValue = (*pfnDrvUpgrade)(1 , &DriverUpgradeInfo1);
                }

                if ( bReturnValue == FALSE ) {

                    DBGMSG( DBG_WARNING, ("FEPCDDU Driver returned FALSE, doesn't support level %d error %d\n", 1, GetLastError() ));

                    StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%d", GetLastError());

                    SplLogEvent(  pLocalIniSpooler,
                                  LOG_ERROR,
                                  MSG_DRIVER_FAILED_UPGRADE,
                                  FALSE,
                                  pPrinterNameWithToken,
                                  pConfigFile,
                                  ErrorBuffer,
                                  NULL );
                }

            } except(1) {

                SetLastError( GetExceptionCode() );
                DBGMSG( DBG_ERROR, ("FEPCDDU ExceptionCode %x Driver %ws Error %d\n", GetLastError(), pConfigFile, GetLastError() ));

                //
                // Despite the exception in this driver we'll continue to do all printers
                //
            }

        } else {

            //  Note this is non fatal, since a driver might not have a DrvUpgrade Entry Point.

            DBGMSG( DBG_TRACE, ("FEPCDDU failed GetProcAddress DrvUpgrade error %d\n", GetLastError() ));
        }


        SplOutSem();
        EnterSplSem();
        bInSem = TRUE;

        //
        //  Call ConvertDevMode -- On upgrading we will either convert devmode,
        //  or set to driver default, or NULL it. This way we can make sure
        //  we do not have any different version devmodes
        //

        pNewDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                       pIniPrinter->pDevMode,
                                                       pConfigFile,
                                                       pPrinterNameWithToken,
                                                       CURRENT_VERSION);

        SplInSem();

        FreeSplMem(pIniPrinter->pDevMode);

        pIniPrinter->pDevMode = (LPDEVMODE) pNewDevMode;
        if ( pNewDevMode ) {

            pIniPrinter->cbDevMode = ((LPDEVMODE)pNewDevMode)->dmSize
                                        + ((LPDEVMODE)pNewDevMode)->dmDriverExtra;

            SPLASSERT(pIniPrinter->cbDevMode);

        } else {

            StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%d", GetLastError());

            SplLogEvent(pLocalIniSpooler,
                        LOG_ERROR,
                        MSG_DRIVER_FAILED_UPGRADE,
                        TRUE,
                        pIniPrinter->pName,
                        pIniPrinter->pIniDriver->pName,
                        ErrorBuffer,
                        NULL);

            pIniPrinter->cbDevMode = 0;
        }

        pNewDevMode = NULL;

        SplInSem();
        if ( !UpdatePrinterIni(pIniPrinter, UPDATE_CHANGEID)) {

            DBGMSG(DBG_WARNING, ("FEPCDDU: UpdatePrinterIni failed with %d\n", GetLastError()));
        }

        //
        //  Clean Up - Free UI DLL
        //

        LeaveSplSem();
        SplOutSem();

        UnloadDriver( hModuleDriverUI );

        EnterSplSem();
        SplInSem();

        hModuleDriverUI = NULL;

        //
        //  End of Loop, Move to Next Printer
        //

        SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );

        DECPRINTERREF( pIniPrinter );
    }

    //
    //  Done
    //

    bReturnValue = TRUE;

    DBGMSG( DBG_TRACE, ("FEPCDDU - Success\n" ));



 } finally {

    //
    //  Clean Up
    //

    FreeSplStr(pConfigFile);
    FreeSplMem(pNewDevMode);
    FreeSplStr(pPrinterNameWithToken);

    if ( hModuleDriverUI != NULL )
        UnloadDriver( hModuleDriverUI );

    if ( !bInSem )
        EnterSplSem();

    if ( hToken != INVALID_HANDLE_VALUE )
        ImpersonatePrinterClient(hToken);

 }
    SplInSem();
    return bReturnValue;
}


BOOL
GetFileNamesFromDriverVersionInfo (
    IN  LPDRIVER_INFO_VERSION   pDriverInfo,
    OUT LPWSTR                  *ppszDriverPath,
    OUT LPWSTR                  *ppszConfigFile,
    OUT LPWSTR                  *ppszDataFile,
    OUT LPWSTR                  *ppszHelpFile
    )
/*++

Routine Name:

    GetFileNamesFromDriverVersionInfo

Routine Description:

    Get the name of Driver, Config, Data, Help file from an
    array of DRIVER_FILE_INFO structures.

Arguments:

    pDriverInfo - Pointer to LPDRIVER_INFO_VERSION buffer.
    ppszDriverPath - out pointer to driver file string
    ppszConfigFile - out pointer to config file string
    ppszDataFile - out pointer to data file string
    ppszHelpFile - out pointer to help file string

Return Value:

    TRUE if file pointers successfully returned.

--*/
{
    BOOL    bRetValue = FALSE;
    DWORD   dwIndex;

    if (pDriverInfo && pDriverInfo->pFileInfo)
    {
        bRetValue = TRUE;

        for (dwIndex = 0; dwIndex < pDriverInfo->dwFileCount; dwIndex++)
        {
            switch (pDriverInfo->pFileInfo[dwIndex].FileType)
            {
                case DRIVER_FILE:
                    if (ppszDriverPath)
                    {
                        *ppszDriverPath = MakePTR(pDriverInfo,
                                                  pDriverInfo->pFileInfo[dwIndex].FileNameOffset);
                    }
                    break;
                case CONFIG_FILE:
                    if (ppszConfigFile)
                    {
                        *ppszConfigFile = MakePTR(pDriverInfo,
                                                  pDriverInfo->pFileInfo[dwIndex].FileNameOffset);
                    }
                    break;
                case DATA_FILE:
                    if (ppszDataFile)
                    {
                        *ppszDataFile = MakePTR(pDriverInfo,
                                                pDriverInfo->pFileInfo[dwIndex].FileNameOffset);
                    }
                    break;
                case HELP_FILE:
                    if (ppszHelpFile)
                    {
                        *ppszHelpFile = MakePTR(pDriverInfo,
                                                pDriverInfo->pFileInfo[dwIndex].FileNameOffset);
                    }
                    break;
                case DEPENDENT_FILE:
                    break;
                default:
                    bRetValue = FALSE;
                    break;
            }
        }
    }

    return bRetValue;
}

BOOL
BuildDependentFilesFromDriverInfo (
    IN  LPDRIVER_INFO_VERSION pDriverInfo,
    OUT LPWSTR               *ppDependentFiles
)
/*++

Routine Name:

    BuildDependentFilesFromDriverInfo

Routine Description:

    Build a multisz string of driver dependent files from
    a DRIVER_INFO_VERSION structure.

Arguments:

    pDriverInfo      - pointer to  DRIVER_INFO_VERSION structure
    ppDependentFiles - pointer to allocated multi-sz string

Return Value:

    TRUE if SUCCESS

--*/
{
    BOOL    bRetValue = TRUE;
    DWORD   dwIndex;
    SIZE_T  Length = 0;
    LPWSTR  pszDllFile = NULL;

    if (ppDependentFiles && pDriverInfo && pDriverInfo->pFileInfo)
    {
        *ppDependentFiles = NULL;

        for (dwIndex = 0;
             bRetValue && dwIndex < pDriverInfo->dwFileCount;
             dwIndex++)
        {
            switch (pDriverInfo->pFileInfo[dwIndex].FileType)
            {
                case DRIVER_FILE:
                case CONFIG_FILE:
                case DATA_FILE:
                case HELP_FILE:
                    break;
                case DEPENDENT_FILE:
                {
                    Length += wcslen(MakePTR(pDriverInfo,
                                               pDriverInfo->pFileInfo[dwIndex].FileNameOffset)) + 1;
                    break;
                }
                default:
                {
                    bRetValue = FALSE;
                    break;
                }
            }
        }

        if (bRetValue && Length > 0)
        {
            Length++;
            Length *= sizeof(WCHAR);

            pszDllFile = (LPWSTR)AllocSplMem((DWORD)Length);

            if (pszDllFile)
            {
                *ppDependentFiles = pszDllFile;

                for (dwIndex = 0;
                     bRetValue && dwIndex < pDriverInfo->dwFileCount;
                     dwIndex++)
                {
                    switch (pDriverInfo->pFileInfo[dwIndex].FileType)
                    {
                        case DRIVER_FILE:
                        case CONFIG_FILE:
                        case DATA_FILE:
                        case HELP_FILE:
                            break;
                        case DEPENDENT_FILE:
                        {
                            StrCchCopyMultipleStr(pszDllFile,
                                                  Length,
                                                  MakePTR(pDriverInfo,pDriverInfo->pFileInfo[dwIndex].FileNameOffset),
                                                  &pszDllFile,
                                                  &Length);

                            break;
                        }
                        default:
                        {
                            bRetValue = FALSE;
                            break;
                        }
                    }
                }
            }
            else
            {
                bRetValue = FALSE;
            }
        }
    }

    if (bRetValue == FALSE && ppDependentFiles)
    {
        FreeSplMem(*ppDependentFiles);
        *ppDependentFiles = NULL;
    }

    return bRetValue;
}


BOOL
DriverAddedOrUpgraded (
    IN  PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN  DWORD               dwFileCount
    )
/*++

Routine Name:

    DriverAddedOrUpgraded

Routine Description:

    Checks the Internal driver file array to see if at least
    one driver file was updated. This is a performance optimization
    for calling DrvUpgradePrinter for ecah printer using the upgraded
    driver or a driver sharing files in common with upgraded driver
    (see ForEachPrinterCallDriverDrvUpgrade).

Arguments:

    pInternalDriverFiles - array of INTERNAL_DRV_FILE structures
    dwFileCount - number of files in array

Return Value:

    TRUE if driver files where added or upgraded.

--*/
{
    BOOL    bDriverAddedOrUpgraded = FALSE;
    DWORD   dwIndex;

    for (dwIndex = 0; dwIndex < dwFileCount; dwIndex++)
    {
        if (pInternalDriverFiles[dwIndex].bUpdated)
        {
            bDriverAddedOrUpgraded = TRUE;
            break;
        }
    }

    return bDriverAddedOrUpgraded;
}

VOID
CleanupInternalDriverInfo(
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               FileCount
    )
/*++

Routine Name:

    CleanupInternalDriverInfo

Routine Description:

    Frees array of INTERNAL_DRV_FILE.
    FileCount gives the element count in the array.

Arguments:

    pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
    FileCount           -- number of files in file set

Return Value:

    Nothing.

--*/
{
    DWORD dwIndex;

    if (pInternalDriverFiles)
    {
        for (dwIndex = 0; dwIndex < FileCount; dwIndex++)
        {
            FreeSplStr(pInternalDriverFiles[dwIndex].pFileName);

            if (pInternalDriverFiles[dwIndex].hFileHandle != INVALID_HANDLE_VALUE)
            {
                CloseHandle(pInternalDriverFiles[dwIndex].hFileHandle);
            }
        }

        FreeSplMem(pInternalDriverFiles);
    }
}

BOOL
GetDriverFileVersionsFromNames(
    IN  PINTERNAL_DRV_FILE    pInternalDriverFiles,
    IN  DWORD                 dwCount
    )
/*++

Routine Name:

    GetDriverFileVersionsFromNames

Routine Description:

    Fills the array of INTERNAL_DRV_FILE with driver minor version,
    by calling GetPrintDriverVersion for each file.
    The array already has the file names filled in.

Arguments:

    pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
    FileCount           -- number of files in file set

Return Value:

    TRUE if SUCCESS

--*/
{
    DWORD   Count, Size;
    BOOL    bReturnValue = TRUE;

    if (!pInternalDriverFiles || !dwCount)
    {
        bReturnValue = FALSE;
        SetLastError(ERROR_INVALID_DATA);
    }
    else
    {
        for (Count = 0 ; Count < dwCount ; ++Count)
        {
            if (IsEXEFile(pInternalDriverFiles[Count].pFileName))
            {
                if (!GetPrintDriverVersion(pInternalDriverFiles[Count].pFileName,
                                           NULL,
                                           &pInternalDriverFiles[Count].dwVersion))
                {
                    bReturnValue = FALSE;
                    break;
                }
            }
        }
    }

    return bReturnValue;
}

BOOL
GetDriverFileVersions(
    IN  LPDRIVER_INFO_VERSION pDriverVersion,
    IN  PINTERNAL_DRV_FILE    pInternalDriverFiles,
    IN  DWORD                 dwCount
    )
/*++

Routine Name:

    GetDriverFileVersions

Routine Description:

    Fills the array of INTERNAL_DRV_FILE with driver minor version
    stored in DRIVER_INFO_VERSION structure.

Arguments:

    pDriverVersion      - pointer to DRIVER_INFO_VERSION
    pInternalDriverFiles - pointer to array of INTERNAL_DRV_FILE
    dwCount             - number of elemnts in array

Return Value:

    TRUE if succeeded.

--*/
{
    DWORD   Count, Size;
    BOOL    bReturnValue = TRUE;
    DWORD   dwMajorVersion;

    if (!pDriverVersion ||
        !pDriverVersion->pFileInfo ||
        pDriverVersion->dwFileCount != dwCount)
    {
        bReturnValue = FALSE;
        SetLastError(ERROR_INVALID_DATA);
    }
    else
    {
        for (Count = 0; Count < pDriverVersion->dwFileCount; Count++)
        {
            pInternalDriverFiles[Count].dwVersion = pDriverVersion->pFileInfo[Count].FileVersion;
        }
    }

    return bReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\driver.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    driver.c

Abstract:

   This module provides all the public exported APIs relating to the
   Driver-based Spooler Apis for the Local Print Providor

   LocalAddPrinterDriver
   LocalDeletePrinterDriver
   SplGetPrinterDriver
   LocalGetPrinterDriverDirectory
   LocalEnumPrinterDriver

   Support Functions in driver.c

   CopyIniDriverToDriver            -- KrishnaG
   GetDriverInfoSize                -- KrishnaG
   DeleteDriverIni                  -- KrishnaG
   WriteDriverIni                   -- KrishnaG

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Felix Maxa (amaxa) 18-Jun-2000
    Modified registry functions to take pIniSpooler
    Added code to propagate drivers to the cluster disk

    Khaled Sedky (khaleds) 2 Feb 1999
    Modified CompleteDriverUpgrade to enable upgrading v.2 drivers to newer v.2 drivers

    Ramanathan Venkatapathy (RamanV) 14 Feb 1997
     Modified CreateVersionEntry,CreateDriverEntry, LocalDeletePrinterDriver,
      SplDeletePrinterDriver.
     Added Driver File RefCounting functions, DeletePrinterDriverEx functions.

    Muhunthan Sivapragasam (MuhuntS) 26 May 1995
    Changes to support DRIVER_INFO_3

    Matthew A Felton (MattFe) 27 June 1994
    pIniSpooler

    Matthew A Felton (MattFe) 23 Feb 1995
    CleanUp InternalAddPrinterDriver for win32spl use so it allows copying from non local
    directories.

    Matthew A Felton (MattFe) 23 Mar 1994
    Added DrvUpgradePrinter calls, changes required to AddPrinterDriver so to save old
    files.

--*/

#include <precomp.h>
#include <lm.h>
#include <offsets.h>
#include <wingdip.h>
#include "clusspl.h"


//
// Private Declarations
//
#define COMPATIBLE_SPOOLER_VERSION 2

//
// This definition is duplicated from oak\inc\winddi.h.
//
#define DRVQUERY_USERMODE 1

extern NET_API_STATUS (*pfnNetShareAdd)();
extern SHARE_INFO_2 PrintShareInfo;
extern NET_API_STATUS (*pfnNetShareSetInfo)();


#define MAX_DWORD_LENGTH 11

typedef struct _DRVFILE {
    struct _DRVFILE *pnext;
    LPCWSTR  pFileName;
}  DRVFILE, *PDRVFILE;

DWORD
CopyICMToClusterDisk(
    IN PINISPOOLER pIniSpooler
    );

DWORD
PropagateMonitorToCluster(
    IN LPCWSTR     pszName,
    IN LPCWSTR     pszDDLName,
    IN LPCWSTR     pszEnvName,
    IN LPCWSTR     pszEnvDir,
    IN PINISPOOLER pIniSpooler
    );

BOOL
CheckFilePlatform(
    IN  LPWSTR  pszFileName,
    IN  LPWSTR  pszEnvironment
    );

LPBYTE
CopyIniDriverToDriverInfo(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    LPBYTE  pEnd,
    LPWSTR  lpRemote,
    PINISPOOLER pIniSpooler
    );

LPBYTE
CopyIniDriverToDriverInfoVersion(
    IN  PINIENVIRONMENT pIniEnvironment,
    IN  PINIVERSION pIniVersion,
    IN  PINIDRIVER pIniDriver,
    IN  LPBYTE  pDriverInfo,
    IN  LPBYTE  pEnd,
    IN  LPWSTR  lpRemote,
    IN  PINISPOOLER pIniSpooler
    );

LPBYTE
CopyIniDriverFilesToDriverInfo(
    IN  LPDRIVER_INFO_VERSION   pDriverVersion,
    IN  PINIVERSION             pIniVersion,
    IN  PINIDRIVER              pIniDriver,
    IN  LPCWSTR                 pszDriverVersionDir,
    IN  LPBYTE                  pEnd
    );

LPBYTE
FillDriverInfo (
    IN  LPDRIVER_INFO_VERSION   pDriverFile,
    IN  DWORD                   Index,
    IN  PINIVERSION             pIniVersion,
    IN  LPCWSTR                 pszPrefix,
    IN  LPCWSTR                 pszFileName,
    IN  DRIVER_FILE_TYPE        FileType,
    IN  LPBYTE                  pEnd
    );

BOOL GetDriverFileCachedVersion(
     IN     PINIVERSION      pIniVersion,
     IN     LPCWSTR          pFileName,
     OUT    DWORD            *pFileVersion
    );

BOOL
DriverAddedOrUpgraded (
    IN  PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN  DWORD               dwFileCount
    );

BOOL
BuildDependentFilesFromDriverInfo (
    IN  LPDRIVER_INFO_VERSION pDriverInfo,
    OUT LPWSTR               *ppDependentFiles
    );

VOID
UpdateDriverFileVersion(
    IN  PINIVERSION             pIniVersion,
    IN  PINTERNAL_DRV_FILE      pInternalDriverFiles,
    IN  DWORD                   FileCount
    );

BOOL SaveDriverVersionForUpgrade(
    IN  HKEY                    hDriverKey,
    IN  PDRIVER_INFO_VERSION    pDriverVersion,
    IN  LPWSTR                  pName,
    IN  DWORD                   dwDriverMoved,
    IN  DWORD                   dwVersion
    );

DWORD
CopyFileToClusterDirectory (
    IN  PINISPOOLER         pIniSpooler,
    IN  PINIENVIRONMENT     pIniEnvironment,
    IN  PINIVERSION         pIniVersion,
    IN  PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN  DWORD               FileCount
    );

VOID
CleanupInternalDriverInfo(
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               FileCount
    );

BOOL
GetDriverFileVersionsFromNames(
    IN  PINTERNAL_DRV_FILE    pInternalDriverFiles,
    IN  DWORD                 dwCount
    );

BOOL
GetDriverFileVersions(
    IN  LPDRIVER_INFO_VERSION pDriverVersion,
    IN  PINTERNAL_DRV_FILE    pInternalDriverFiles,
    IN  DWORD                 dwCount
    );

BOOL
GetFileNamesFromDriverVersionInfo (
    IN  LPDRIVER_INFO_VERSION   pDriverInfo,
    OUT LPWSTR                  *ppszDriverPath,
    OUT LPWSTR                  *ppszConfigFile,
    OUT LPWSTR                  *ppszDataFile,
    OUT LPWSTR                  *ppszHelpFile
    );

BOOL
WaitRequiredForDriverUnload(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      BOOL                bDriverMoved,
        OUT LPBOOL              pbSuccess
    );

BOOL FilesUnloaded(
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR  pDriverFile,
    LPWSTR  pConfigFile,
    DWORD   dwDriverAttributes);

DWORD StringSizeInBytes(
    LPWSTR pString,
    BOOL   bMultiSz);

BOOL SaveParametersForUpgrade(
    LPWSTR pName,
    BOOL   bDriverMoved,
    DWORD  dwLevel,
    LPBYTE pDriverInfo,
    DWORD  dwVersion);

VOID CleanUpResources(
    LPWSTR              pKeyName,
    LPWSTR              pSplName,
    PDRIVER_INFO_6      pDriverInfo,
    PINTERNAL_DRV_FILE *pInternalDriverFiles,
    DWORD               dwFileCount);

BOOL RestoreParametersForUpgrade(
    HKEY     hUpgradeKey,
    DWORD    dwIndex,
    LPWSTR   *pKeyName,
    LPWSTR   *pSplName,
    LPDWORD  pdwLevel,
    LPDWORD  pdwDriverMoved,
    PDRIVER_INFO_6   *ppDriverInfo);

VOID CleanUpgradeDirectories();

VOID FreeDriverInfo6(
    PDRIVER_INFO_6   pDriver6
    );

BOOL RegGetValue(
    HKEY    hDriverKey,
    LPWSTR  pValueName,
    LPBYTE  *pValue
    );

BOOL
WriteDriverIni(
    PINIDRIVER      pIniDriver,
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER      pIniSpooler
    );

BOOL
DeleteDriverIni(
    PINIDRIVER      pIniDriver,
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
    );

BOOL
CreateVersionDirectory(
    PINIVERSION pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    BOOL bUpdate,
    PINISPOOLER pIniSpooler
    );

DWORD
GetDriverInfoSize(
    PINIDRIVER  pIniDriver,
    DWORD       Level,
    PINIVERSION pIniVersion,
    PINIENVIRONMENT  pIniEnvironment,
    LPWSTR      lpRemote,
    PINISPOOLER pIniSpooler
    );

BOOL
DeleteDriverVersionIni(
    PINIVERSION pIniVersion,
    PINIENVIRONMENT  pIniEnvironment,
    PINISPOOLER     pIniSpooler
    );

BOOL
WriteDriverVersionIni(
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
    );

PINIDRIVER
FindDriverEntry(
    PINIVERSION pIniVersion,
    LPWSTR pszName
    );

PINIDRIVER
CreateDriverEntry(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      DWORD               Level,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN      PINISPOOLER         pIniSpooler,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               FileCount,
    IN      DWORD               dwTempDir,
    IN      PINIDRIVER          pOldIniDriver
    );

BOOL
IsKMPD(
    LPWSTR  pDriverName
    );

VOID
CheckDriverAttributes(
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver
    );

BOOL
NotifyDriver(
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver,
    DWORD           dwDriverEvent,
    DWORD           dwParameter
    );

BOOL
AddTempDriver(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      BOOL                bDriverMoved
    );

BOOL
CompleteDriverUpgrade(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN      PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      DWORD               dwTempDir,
    IN      BOOL                bDriverMoved,
    IN      BOOL                bDriverFileMoved,
    IN      BOOL                bConfigFileMoved
    );

BOOL
FilesInUse(
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver
    );

BOOL
UpdateDriverFileRefCnt(
    PINIENVIRONMENT  pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver,
    LPCWSTR     pDirectory,
    DWORD       dwDeleteFlag,
    BOOL        bIncrementFlag
    );

PDRVREFCNT
IncrementFileRefCnt(
    PINIVERSION pIniVersion,
    LPCWSTR szFileName
    );

PDRVREFCNT
DecrementFileRefCnt(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver,
    LPCWSTR szFileName,
    LPCWSTR szDirectory,
    DWORD dwDeleteFlag
    );

VOID
RemovePendingUpgradeForDeletedDriver(
    LPWSTR      pDriverName,
    DWORD       dwVersion,
    PINISPOOLER pIniSpooler
    );

VOID
RemoveDriverTempFiles(
    PINISPOOLER  pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver
    );

VOID
DeleteDriverEntry(
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver
    );

PINIVERSION
CreateVersionEntry(
    PINIENVIRONMENT pIniEnvironment,
    DWORD dwVersion,
    PINISPOOLER pInispooler
    );

DWORD
GetEnvironmentScratchDirectory(
    LPWSTR   pDir,
    DWORD    MaxLength,
    PINIENVIRONMENT  pIniEnvironment,
    BOOL    Remote
    );

VOID
SetOldDateOnDriverFilesInScratchDirectory(
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               FileCount,
    PINISPOOLER         pIniSpooler
    );

BOOL
CopyFilesToFinalDirectory(
    PINISPOOLER         pIniSpooler,
    PINIENVIRONMENT     pIniEnvironment,
    PINIVERSION         pIniVersion,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    DWORD               dwFileCopyFlags,
    BOOL                bImpersonateOnCreate,
    LPBOOL              pbFilesMoved
    );

BOOL
CreateInternalDriverFileArray(
    IN  DWORD               Level,
    IN  LPBYTE              pDriverInfo,
    OUT PINTERNAL_DRV_FILE *pInternalDriverFiles,
    OUT LPDWORD             pFileCount,
    IN  BOOL                bUseScratchDir,
    IN  PINIENVIRONMENT     pIniEnvironment,
    IN  BOOL                bFileNamesOnly
    );

BOOL
CheckFileCopyOptions(
    PINIENVIRONMENT     pIniEnvironment,
    PINIVERSION         pIniVersion,
    PINIDRIVER          pIniDriver,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    DWORD               dwFileCopyFlags,
    LPBOOL              pbUpgrade
    );

/*++

Routine Name

    FindIndexInDrvFileInfo

Routine Description:

    Checks if a certain driver file is present in an DRIVER_FILE_INFO
    file set. The search is done by the type of the file. The index
    to the first occurence of the file is returned.

Arguments:

    pDrvFileInfo - pointer to DRIVER_FILE_INFO array
    cElements    - count of elements in pDrvFileInfo
    kFileType    - file type to search for
    pIndex       - on success contains the index of the found file in
                   the pDrvFileInfo array

Return Value:

    S_OK         - the file was found and pIndex is usable
    S_FALSE      - the file was not found, pIndex is not usable
    E_INVALIDARG - invalid arguments were passed in

--*/
HRESULT
FindIndexInDrvFileInfo(
    IN  DRIVER_FILE_INFO *pDrvFileInfo,
    IN  DWORD             cElements,
    IN  DRIVER_FILE_TYPE  kFileType,
    OUT DWORD            *pIndex
    )
{
    HRESULT hr = E_INVALIDARG;

    if (pDrvFileInfo && pIndex)
    {
        DWORD i;

        //
        // Not found
        //
        hr = S_FALSE;

        for (i = 0; i < cElements; i++)
        {
            if (pDrvFileInfo[i].FileType == kFileType)
            {
                *pIndex = i;

                hr = S_OK;

                break;
            }
        }
    }

    return hr;
}


BOOL
LocalStartSystemRestorePoint(
    IN      PCWSTR      pszDriverName,
        OUT HANDLE      *phRestorePoint
    );

/*++

Routine Name

    IsDriverInstalled

Routine Description:

    Checks if a certain driver is already installed.

Arguments:

    pDriver2    - pointer to DRIVER_INFO_2
    pIniSpooler - pointer to spooler structure

Return Value:

    TRUE  - driver is installed on the pIniSpooler
    FALSE - driver is not present in pIniSpooler

--*/
BOOL
IsDriverInstalled(
    DRIVER_INFO_2 *pDriver2,
    PINISPOOLER    pIniSpooler
    )
{
    BOOL bReturn  = FALSE;

    if (pIniSpooler &&
        pDriver2 &&
        pDriver2->pName)
    {
        PINIENVIRONMENT pIniEnv;
        PINIVERSION     pIniVer;

        EnterSplSem();

        if ((pIniEnv = FindEnvironment(pDriver2->pEnvironment && *pDriver2->pEnvironment ?
                                       pDriver2->pEnvironment : szEnvironment,
                                       pIniSpooler)) &&
            (pIniVer = FindVersionEntry(pIniEnv, pDriver2->cVersion)) &&
            FindDriverEntry(pIniVer, pDriver2->pName))
        {
            bReturn = TRUE;
        }

        LeaveSplSem();
    }

    DBGMSG(DBG_CLUSTER, ("IsDriverInstalled returns %u\n", bReturn));

    return bReturn;
}

BOOL
LocalAddPrinterDriver(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
    )
{
    return LocalAddPrinterDriverEx( pName,
                                    Level,
                                    pDriverInfo,
                                    APD_COPY_NEW_FILES );
}

BOOL
LocalAddPrinterDriverEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags
    )
{
    PINISPOOLER pIniSpooler;
    BOOL        bReturn = TRUE;

    if (Level == 7)
    {
        bReturn = FALSE;
        SetLastError(ERROR_INVALID_LEVEL);
    }
    else if (dwFileCopyFlags & APD_COPY_TO_ALL_SPOOLERS)
    {
        //
        // Mask flag otherwise SplAddPrinterDriverEx will be fail.
        // This flag is used by Windows Update to update all the
        // drivers for all the spoolers hosted by the local machine
        //
        dwFileCopyFlags = dwFileCopyFlags & ~APD_COPY_TO_ALL_SPOOLERS;

        for (pIniSpooler = pLocalIniSpooler;
             pIniSpooler && bReturn;
             pIniSpooler = pIniSpooler->pIniNextSpooler)
        {
            //
            // We do not want to add a driver to a pIniSpooler. We want to update
            // an existing driver. That is why we check if the driver is already
            // installed
            //
            if ((pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ||
                 pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) &&
                 IsDriverInstalled((DRIVER_INFO_2 *)pDriverInfo, pIniSpooler))
            {
                EnterSplSem();
                INCSPOOLERREF(pIniSpooler);
                LeaveSplSem();

                //
                // The 6th parameter indicates whether to use the scratch
                // directory (TRUE) or not (FALSE)
                //
                bReturn = SplAddPrinterDriverEx(pName,
                                                Level,
                                                pDriverInfo,
                                                dwFileCopyFlags,
                                                pIniSpooler,
                                                !(dwFileCopyFlags & APD_COPY_FROM_DIRECTORY),
                                                IMPERSONATE_USER);

                DBGMSG(DBG_CLUSTER, ("LocalAddPrinterDriverEx adding driver to "TSTR" bRet %u\n",
                                                            pIniSpooler->pMachineName, bReturn));

                EnterSplSem();
                DECSPOOLERREF(pIniSpooler);
                LeaveSplSem();
            }
        }
    }
    else
    {
        if (!(pIniSpooler = FindSpoolerByNameIncRef(pName, NULL)))
        {
            return ROUTER_UNKNOWN;
        }
        else
        {
            //
            // The 6th parameter indicates whether to use the scratch
            // directory (TRUE) or not (FALSE)
            //
            bReturn = SplAddPrinterDriverEx(pName,
                                            Level,
                                            pDriverInfo,
                                            dwFileCopyFlags,
                                            pIniSpooler,
                                            !(dwFileCopyFlags & APD_COPY_FROM_DIRECTORY),
                                            IMPERSONATE_USER);
        }

        FindSpoolerByNameDecRef(pIniSpooler);
    }

    return bReturn;
}

BOOL
SplAddPrinterDriverEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags,
    PINISPOOLER pIniSpooler,
    BOOL    bUseScratchDir,
    BOOL    bImpersonateOnCreate
    )
{
    PINISPOOLER pTempIniSpooler = pIniSpooler;

    //
    // At this time we do not know if the server name in pName refers to our local
    // machine. We are trying to add the server name to the name cache. The name
    // cache functions decide if the name refers to the local machine and if positive,
    // add an entry for it in the cache.
    //
    CacheAddName(pName);

    DBGMSG( DBG_TRACE, ("AddPrinterDriver\n"));

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    //  Right now all drivers are global ie they are shared between all IniSpoolers
    //  If we want to impersonate the user then lets validate against pLocalIniSpooler
    //  whilch causes all the security checking to happen, rather than using the passed
    //  in IniSpooler which might not.    See win32spl for detail of point and print.

    if ( bImpersonateOnCreate ) {

        pTempIniSpooler = pLocalIniSpooler;
    }

    if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                SERVER_ACCESS_ADMINISTER,
                                NULL, NULL, pTempIniSpooler)) {

        return FALSE;
    }

    return ( InternalAddPrinterDriverEx( pName,
                                         Level,
                                         pDriverInfo,
                                         dwFileCopyFlags,
                                         pIniSpooler,
                                         bUseScratchDir,
                                         bImpersonateOnCreate ) );

}

/*+

Description:

    This function creates a process for a driver to be installed in and launches an entry point
    from ntprint.dll to install the driver inside that process.  This install will take a driver info 7
    struct and do an inf based install with the information in that structure.

Arguments:

    pDriverInfo7 -- driver_info_7 structure

Returns:

    TRUE on success; FALSE otherwise
    The function sets the last error in case of failure

Notes:

    If the driver info pszInfName field is anything other than NULL, this call will fail.

--*/
BOOL
InternalINFInstallDriver(
    LPDRIVER_INFO_7 pDriverInfo7
)
{
    DWORD     Error          = ERROR_INVALID_PARAMETER;
    LPWSTR    pszPipe        = NULL;
    DWORD     dwCode         = ERROR_INVALID_PARAMETER;

    //
    // Passing with an inf name is not supported.
    //
    if (!pDriverInfo7->pszInfName )
    {
        LPWSTR  pszCmdString   = NULL;
        LPCWSTR pszRundllName  = L"rundll32.exe";
        LPCWSTR pszRundllArgs  = L"rundll32.exe ntprint.dll,ServerInstall ";
        LPWSTR  pszRundllPath  = NULL;

        Error = StrCatAlloc(&pszCmdString, pszRundllArgs, pDriverInfo7->pszDriverName, NULL);

        if(Error == ERROR_SUCCESS)
        {
            Error = StrCatSystemPath(pszRundllName, kSystemDir, &pszRundllPath);
        }

        if(Error == ERROR_SUCCESS)
        {
            Error = RunProcess(pszRundllPath, pszCmdString, INFINITE, &dwCode);
        }

        if(Error == ERROR_SUCCESS)
        {
            Error = dwCode;
        }

        if (pszCmdString)                  FreeSplMem(pszCmdString);
        if (pszRundllPath)                 FreeSplMem(pszRundllPath);
        if (pszPipe)                       FreeSplMem(pszPipe);
    }

    if (Error != ERROR_SUCCESS)
    {
        SetLastError(Error);
    }

    return Error == ERROR_SUCCESS;
}


BOOL
BuildTrueDependentFileField(
    LPWSTR              pDriverPath,
    LPWSTR              pDataFile,
    LPWSTR              pConfigFile,
    LPWSTR              pHelpFile,
    LPWSTR              pInputDependentFiles,
    LPWSTR             *ppDependentFiles
    )
{
    LPWSTR  psz, psz2;
    LPCWSTR pszFileNamePart;
    SIZE_T  Size;

    if ( !pInputDependentFiles )
        return TRUE;

    for ( psz = pInputDependentFiles, Size = 0 ;
          psz && *psz ; psz += wcslen(psz) + 1 ) {

        pszFileNamePart = FindFileName(psz);

        if( !pszFileNamePart ){
            break;
        }

        if ( wstrcmpEx(FindFileName(pDriverPath), pszFileNamePart, FALSE)   &&
             wstrcmpEx(FindFileName(pDataFile), pszFileNamePart, FALSE)     &&
             wstrcmpEx(FindFileName(pConfigFile), pszFileNamePart, FALSE)   &&
             wstrcmpEx(FindFileName(pHelpFile), pszFileNamePart, FALSE) ) {

            Size += wcslen(psz) + 1;
        }
    }

    if ( !Size )
        return TRUE;

    //
    // Increase the Size to accommodate the last \0
    //
    ++Size;

    *ppDependentFiles = AllocSplMem((DWORD)(Size*sizeof(WCHAR)));
    if ( !*ppDependentFiles )
        return FALSE;

    psz  = pInputDependentFiles;
    psz2 = *ppDependentFiles;
    while ( *psz ) {

        pszFileNamePart = FindFileName(psz);

        if( !pszFileNamePart ){
            break;
        }

        if ( wstrcmpEx(FindFileName(pDriverPath), pszFileNamePart, FALSE)   &&
             wstrcmpEx(FindFileName(pDataFile), pszFileNamePart, FALSE)     &&
             wstrcmpEx(FindFileName(pConfigFile), pszFileNamePart, FALSE)   &&
             wstrcmpEx(FindFileName(pHelpFile), pszFileNamePart, FALSE) ) {

            StrCchCopyMultipleStr(psz2, Size, psz, &psz2, &Size);
        }

        psz += wcslen(psz) + 1;
    }

    return TRUE;
}



DWORD
IsCompatibleDriver(
    LPWSTR  pszDriverName,
    LPWSTR  pszDeviceDriverPath,
    LPWSTR  pszEnvironment,
    DWORD   dwMajorVersion,
    DWORD   *pdwBlockingStatus
    )
/*++
Function Description: Call this function to prevent bad drivers from getting installed.
                      Check if driver is listed in printupg.inf (lists all known bad driver files ).
                      Since printupg.inf contains only driver name, this function should be called
                      only for verions 2 drivers.
                      Otherwise,it will treat a version 3 driver "DriverName" as bad,
                      if it is a bad version 2 driver.

Parameters: pszDriverName         -- driver name
            pszDeviceDriverPath   -- filename for the file that contains the device driver
            pszEnvironment        -- environment string for the driver such as "Windows NT x86"
            dwMajorVersion        -- major version of the driver
            pdwBlockingStatus     -- driver blocking status

Return Value: ERROR_SUCCESS if succeeded
              ERROR_INVALID_PARAMETER if invalid parameters
              GetLastError for any other errors

--*/
{
    WIN32_FIND_DATA              DeviceDriverData;
    pfPSetupIsCompatibleDriver   pfnPSetupIsCompatibleDriver;
    UINT                         uOldErrMode;
    HANDLE                       hFileExists         = INVALID_HANDLE_VALUE;
    HANDLE                       hLibrary            = NULL;
    DWORD                        LastError           = ERROR_SUCCESS;
    DWORD                        dwBlockingStatus    = BSP_PRINTER_DRIVER_OK;


    uOldErrMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    if( !pszDriverName  || !pszDeviceDriverPath  || !pszEnvironment  ||
        !*pszDriverName || !*pszDeviceDriverPath || !*pszEnvironment || !pdwBlockingStatus) {
        LastError = ERROR_INVALID_PARAMETER;
        goto End;
    }

    *pdwBlockingStatus    = BSP_PRINTER_DRIVER_OK;

    hFileExists = FindFirstFile( pszDeviceDriverPath, &DeviceDriverData );

    if (hFileExists == INVALID_HANDLE_VALUE) {
        LastError = GetLastError();
        goto End;
    }

    if( !(hLibrary = LoadLibrary( TEXT("ntprint.dll"))) ){
        LastError = GetLastError();
        goto End;
    }

    pfnPSetupIsCompatibleDriver = (pfPSetupIsCompatibleDriver)GetProcAddress( hLibrary, "PSetupIsCompatibleDriver" );

    if( !pfnPSetupIsCompatibleDriver){
        LastError = GetLastError();
        goto End;
    }

    //
    // NULL server name is OK since we know this is the local machine.
    // PSetupIsCompatibleDriver uses this to determine the blocking
    // level.
    //
    if ((pfnPSetupIsCompatibleDriver)( NULL,
                                         pszDriverName,
                                         pszDeviceDriverPath,
                                         pszEnvironment,
                                         dwMajorVersion,
                                         &DeviceDriverData.ftLastWriteTime,
                                         &dwBlockingStatus,
                                         NULL)) {
        *pdwBlockingStatus = dwBlockingStatus;
    } else {

        LastError = GetLastError();
    }


End:

    if( hFileExists != INVALID_HANDLE_VALUE ){
        FindClose(hFileExists);
    }

    if( hLibrary ){
        FreeLibrary( hLibrary );
    }

    SetErrorMode( uOldErrMode );

    return LastError;

}

BOOL
IsAnICMFile(
    LPCWSTR  pszFileName
    )

/*++
Function Description: Checks for ICM extension on the filename

Parameters:  pszFileName - file name

Return Values: TRUE for ICM files; FALSE otherwise
--*/

{
    DWORD   dwLen = wcslen(pszFileName);
    LPWSTR  psz   = (LPWSTR)pszFileName+dwLen-4;

    if ( dwLen > 3  &&
        ( !_wcsicmp(psz, L".ICM") || !_wcsicmp(psz, L".ICC")) )
        return TRUE;

    return FALSE;
}

BOOL
ValidateDriverInfo(
    IN  LPBYTE      pDriverInfo,
    IN  DWORD       Level,
    IN  DWORD       dwFileCopyFlags,
    IN  BOOL        bCopyFilesToClusterDisk,
    IN  PINISPOOLER pIniSpooler
    )
/*++

Routine Name:

    ValidateDriverInfo

Routine Description:

    Validates information contained in a buffer depending on level and
    file copy flags.

Arguments:

    pDriverInfo             - pointer to a buffer containing DRIVER_INFO_ data.
    Level                   - 2, 3 ,4 ,6 , 7, DRIVER_INFO_VERSION_LEVEL
    dwFileCopyFlags         - file copy flags
    bCopyFilesToClusterDisk - cluster flags
    pIniSpooler             - pointer to Spooler structure

Return Value:

    TRUE if the structure is valid.

--*/
{
    BOOL    bRetValue     = FALSE;
    DWORD   LastError     = ERROR_SUCCESS;
    LPWSTR  pszDriverName = NULL;
    LPWSTR  pszDriverPath = NULL;
    LPWSTR  pszConfigFile = NULL;
    LPWSTR  pszDataFile   = NULL;
    LPWSTR  pszEnvironment = NULL;
    LPWSTR  pszMonitorName = NULL;
    LPWSTR  pszDefaultDataType = NULL;
    DWORD   dwMajorVersion;

    PDRIVER_INFO_2  pDriver2 = NULL;
    PDRIVER_INFO_3  pDriver3 = NULL;
    PDRIVER_INFO_VERSION  pDriverVersion = NULL;

    PINIENVIRONMENT pIniEnvironment = NULL;
    PINIMONITOR pIniLangMonitor = NULL;

    try {

        if (!pDriverInfo)
        {
            LastError = ERROR_INVALID_PARAMETER;
            leave;
        }

        switch (Level)
        {
            case 2:
            {
                pDriver2        = (PDRIVER_INFO_2) pDriverInfo;
                pszDriverName   = pDriver2->pName;
                pszDriverPath   = pDriver2->pDriverPath;
                pszConfigFile   = pDriver2->pConfigFile;
                pszDataFile     = pDriver2->pDataFile;
                dwMajorVersion  = pDriver2->cVersion;

                if (pDriver2->pEnvironment && *pDriver2->pEnvironment)
                {
                    pszEnvironment = pDriver2->pEnvironment;
                }

                break;
            }
            case 3:
            case 4:
            case 6:
            {
                pDriver3            = (PDRIVER_INFO_3) pDriverInfo;
                pszDriverName       = pDriver3->pName;
                pszDriverPath       = pDriver3->pDriverPath;
                pszConfigFile       = pDriver3->pConfigFile;
                pszDataFile         = pDriver3->pDataFile;
                dwMajorVersion      = pDriver3->cVersion;
                pszMonitorName      = pDriver3->pMonitorName;
                pszDefaultDataType  = pDriver3->pDefaultDataType;

                if (pDriver3->pEnvironment && *pDriver3->pEnvironment)
                {
                    pszEnvironment = pDriver3->pEnvironment;
                }
                break;
            }

            case 7:
            {
                LPDRIVER_INFO_7 pDriverInfo7 = (LPDRIVER_INFO_7)pDriverInfo;

                if (!pDriverInfo7                               ||
                    pDriverInfo7->cbSize < sizeof(DRIVER_INFO_7)||
                    !pDriverInfo7->pszDriverName                ||
                    !*pDriverInfo7->pszDriverName               ||
                    wcslen(pDriverInfo7->pszDriverName) >= MAX_PATH)
                {
                     LastError = ERROR_INVALID_PARAMETER;
                }
                //
                // We don't want to do any more of the validation below, so leave.
                //
                leave;
                break;
            }
            case DRIVER_INFO_VERSION_LEVEL:
            {
                pDriverVersion = (LPDRIVER_INFO_VERSION)pDriverInfo;
                pszDriverName = pDriverVersion->pName;

                if (!GetFileNamesFromDriverVersionInfo(pDriverVersion,
                                                       &pszDriverPath,
                                                       &pszConfigFile,
                                                       &pszDataFile,
                                                       NULL))
                {
                    LastError = ERROR_INVALID_PARAMETER;
                    leave;
                }

                if (pDriverVersion->pEnvironment != NULL &&
                    *pDriverVersion->pEnvironment != L'\0')
                {
                    pszEnvironment = pDriverVersion->pEnvironment;
                }

                pszMonitorName      = pDriverVersion->pMonitorName;
                pszDefaultDataType  = pDriverVersion->pDefaultDataType;
                dwMajorVersion      = pDriverVersion->cVersion;
                pszDriverName       = pDriverVersion->pName;

                break;
            }
            default:
            {
                LastError = ERROR_INVALID_LEVEL;
                leave;
            }
        }

        //
        // Validate driver name, driver file, config file and data file.
        //
        if ( !pszDriverName || !*pszDriverName || wcslen(pszDriverName) >= MAX_PATH ||
             !pszDriverPath || !*pszDriverPath || wcslen(pszDriverPath) >= MAX_PATH ||
             !pszConfigFile || !*pszConfigFile || wcslen(pszConfigFile) >= MAX_PATH ||
             !pszDataFile   || !*pszDataFile   || wcslen(pszDataFile) >= MAX_PATH )
        {
            LastError = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // We don't use Scratch directory when this flag is set.
        // When APD_COPY_FROM_DIRECTORY is set, the temporay directory must
        // be on the local machine.
        // IsLocalFile checks is the file is on the same machine specified by
        // the passed in spooler.
        //
        if (dwFileCopyFlags & APD_COPY_FROM_DIRECTORY)
        {
            if (!IsLocalFile(pszDriverPath, pIniSpooler) ||
                !IsLocalFile(pszConfigFile, pIniSpooler))
            {
                LastError = ERROR_INVALID_PARAMETER;
                leave;
            }
        }

        //
        // Validate default data type (except for Win95 drivers)
        //
        if ( pszDefaultDataType &&
             *pszDefaultDataType &&
             _wcsicmp(pszEnvironment, szWin95Environment) &&
            !FindDatatype(NULL, pszDefaultDataType))
        {
           LastError = ERROR_INVALID_DATATYPE;
           leave;
        }

        //
        // Validate monitor name (except for Win95 drivers)
        //
        if ( pszMonitorName &&
             *pszMonitorName &&
             _wcsicmp(pszEnvironment, szWin95Environment))
        {
            //
            // Out driver is not a Win9x driver and it has a language monitor
            //
            if (pIniLangMonitor = FindMonitor(pszMonitorName, pLocalIniSpooler))
            {
                //
                // Check if our pIniSpooler is a cluster spooler and we need to copy the
                // language monitor file to disk. Note that FinEnvironment cannot fail.
                // The environment has been validated by now.
                //
                if (bCopyFilesToClusterDisk &&
                    (pIniEnvironment = FindEnvironment(pszEnvironment, pIniSpooler)))
                {
                    DBGMSG(DBG_CLUSTER, ("InternalAddPrinterDriverEx pIniLangMonitor = %x\n", pIniLangMonitor));

                    if ((LastError = PropagateMonitorToCluster(pIniLangMonitor->pName,
                                                               pIniLangMonitor->pMonitorDll,
                                                               pIniEnvironment->pName,
                                                               pIniEnvironment->pDirectory,
                                                               pIniSpooler)) != ERROR_SUCCESS)
                    {
                        //
                        // We failed to propagate the montior to the cluster disk. Fail the call
                        //
                        leave;
                    }
                }
             }
            else
            {
                 DBGMSG(DBG_CLUSTER, ("InternalAddPrinterDriverEx pIniLangMonitor = %x Not found\n", pIniLangMonitor));
                 LastError = ERROR_UNKNOWN_PRINT_MONITOR;
                 leave;
            }
        }

        //
        // Validate environment.
        //
        SPLASSERT(pszEnvironment != NULL);

        if (!FindEnvironment(pszEnvironment, pIniSpooler))
        {
            LastError = ERROR_INVALID_ENVIRONMENT;
            leave;
        }

    } finally {

        if (LastError != ERROR_SUCCESS)
        {
            SetLastError(LastError);
        }
        else
        {
            bRetValue = TRUE;
        }
    }

    return bRetValue;
}

BOOL
InternalAddPrinterDriverEx(
    LPWSTR      pName,
    DWORD       Level,
    LPBYTE      pDriverInfo,
    DWORD       dwFileCopyFlags,
    PINISPOOLER pIniSpooler,
    BOOL        bUseScratchDir,
    BOOL        bImpersonateOnCreate
    )
/*++
Function Description: This function adds/upgrades printer drivers. The new files may not be
                      used until the old drivers are unloaded. Thus the new functionality
                      associated with the new files may take a while to show up; either until
                      the DC count in the system goes to 0 or when the machine is rebooted.

Parameters: pName                -- driver name
            Level                -- level of driver_info struct
            pDriverInfo          -- driver_info buffer
            dwFileCopyFlags      -- file copy options
            pIniSpooler          -- pointer to INISPOOLER struct
            bUseScratchDir       -- flag indicating location of the driver files
            bImpersonateOnCreate -- flag for impersonating the client on creating and
                                     moving files

Return Value: TRUE on success; FALSE otherwise
--*/
{
    DWORD           LastError               = ERROR_SUCCESS;
    BOOL            bReturnValue            = FALSE;
    BOOL            bDriverMoved = FALSE, bNewIniDriverCreated = FALSE;
    LPWSTR          pEnvironment            = szEnvironment;
    PINTERNAL_DRV_FILE pInternalDriverFiles = NULL;
    DWORD           dwMajorVersion;

    PINIDRIVER      pIniDriver              = NULL;
    PINIENVIRONMENT pIniEnvironment;
    PINIVERSION     pIniVersion;
    LPWSTR          pszDriverPath;
    LPWSTR          pszDriverName;
    DWORD           dwBlockingStatus = BSP_PRINTER_DRIVER_OK;
    BOOL            bCopyFilesToClusterDisk;
    BOOL            bBadDriver = FALSE;
    HANDLE          hRestorePoint            = NULL;
    BOOL            bSetSystemRestorePoint   = FALSE;
    BOOL            bIsSystemRestorePointSet = FALSE;
    DWORD           FileCount                = 0;

    //
    // If the pIniSpooler where we add the driver is a cluster type spooler,
    // then besides its normal tasks, it also needs to propagte the driver
    // files to the cluster disk. Thus the driver files will be available
    // on each node where the cluster spooler fails over. SplAddPrinterDriverEx
    // is the function that calls this one. SplAddPrinterDriverEx can be called
    // in 2 types of context:
    // 1) The caller is cluster unaware and wants to add a driver. Then InternalAdd
    // PrinterDriverEX will propagate driver files to the cluster disk, if the
    // pIniSpooler happens to be of cluster type
    // 2) The caller of this function is SplCreateSpooler when pIniSpooler is a
    // cluster spooler. In this case that caller uses the files on the cluster
    // disk and calls the function to add the driver from the cluster disk to the
    // local node. The driver files will be installed on the local machine. They will
    // not be shared with the pLocalIniSpooler. We need the driver files locally.
    // We can't load them off the driver disk. Otherwise, on a fail over, apps
    // who loaded a driver file will get an in page error.
    // The following flag is used to distinguish the case 2). When SplCreateSpooler
    // is the caller of SplAddPrinterDriverEx, then we do not need to copy the files
    // to the disk. It would be redundant.
    //
    bCopyFilesToClusterDisk = pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER  &&
                              pIniSpooler->SpoolerFlags & SPL_PRINT         &&
                              !(dwFileCopyFlags & APD_DONT_COPY_FILES_TO_CLUSTER);

    //
    // We want to set a system restore point unless the installer has already told
    // us that the driver is signed. To really get this working properly, we would
    // have to redesign AddPrinterDriver to be signing aware. For now it is the
    // honor system (it is not obvious why an OEM installer would not want us to
    // check point here though).
    //
    bSetSystemRestorePoint = !bCopyFilesToClusterDisk && !(dwFileCopyFlags & APD_DONT_SET_CHECKPOINT);

    //
    // We mask APD_DONT_COPY_FILES_TO_CLUSTER. The subsequent uses of dwFilecopyFlags exptect it
    // to have a single bit set. They don't use it bitwise. They compare
    // dwords agains it. The same goes for APD_DRIVER_SIGNATURE_VALID.
    //
    dwFileCopyFlags = dwFileCopyFlags & ~(APD_DONT_COPY_FILES_TO_CLUSTER);

    DBGMSG(DBG_TRACE, ("InternalAddPrinterDriverEx( %x, %d, %x, %x)\n",
                       pName, Level, pDriverInfo, pIniSpooler));

    try {

        EnterSplSem();

        if (!MyName(pName, pIniSpooler) ||
            !ValidateDriverInfo(pDriverInfo,
                               Level,
                               dwFileCopyFlags,
                               bCopyFilesToClusterDisk,
                               pIniSpooler))
        {
            leave;
        }

        if (Level == 7)
        {
            //
            //  We can't be inside the semaphore to make this call.
            //
            LeaveSplSem();
            bReturnValue = InternalINFInstallDriver( (DRIVER_INFO_7*)pDriverInfo );
            EnterSplSem();
            leave;
        }

        pszDriverName = ((DRIVER_INFO_2*)pDriverInfo)->pName;

        pEnvironment = ((DRIVER_INFO_2*)pDriverInfo)->pEnvironment;

        //
        // If the driver hasn't gone through our class installer, then we want to
        // create a sysem restore point here. Since Level 7 drivers are by
        // definition signed, we can do this after the InternalINFInstallDriver.
        // Since check-pointing takes from 25-30 seconds, this must take place
        // outside the CS.
        //
        if (bSetSystemRestorePoint)
        {
            LeaveSplSem();
            bIsSystemRestorePointSet = LocalStartSystemRestorePoint(pszDriverName, &hRestorePoint);
            EnterSplSem();

            //
            // This only fails if something completely unexpected happens in
            // setting the checkpoint. Some skus don't support check points
            // in which case hRestorePoint will be NULL even though the function
            // succeeds.
            //
            if (!bIsSystemRestorePointSet)
            {
                leave;
            }
        }

        pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler );

        if (!CreateInternalDriverFileArray(Level,
                                           pDriverInfo,
                                           &pInternalDriverFiles,
                                           &FileCount,
                                           bUseScratchDir,
                                           pIniEnvironment,
                                           FALSE))
        {
            leave;
        }

        //
        //  For the driver and config files in the scratch directory do a version
        //  check else use the version passed in rather than calling
        //  GetPrintDriverVersion which will cause a LoadLibrary - possibly
        //  over the network.
        //  Same for CheckFilePlatform. We shouldn't hit the network for files
        //  in Scratch or temporary directory.
        //
        //
        if (bUseScratchDir || dwFileCopyFlags & APD_COPY_FROM_DIRECTORY)
        {
            if (!GetPrintDriverVersion(pInternalDriverFiles[0].pFileName,
                                       &dwMajorVersion,
                                       NULL))
            {
                leave;
            }
            else
            {
                //
                // ntprint.dll doesn't fill in cVersion. We need to set it correctly
                // just in case we need to call Save/RestoreParametersForUpgrade.
                // For this case we need to have a corect version since no more validation are done.
                //
                ((DRIVER_INFO_2*)pDriverInfo)->cVersion = dwMajorVersion;
            }


            if (!CheckFilePlatform(pInternalDriverFiles[0].pFileName, pEnvironment) ||
                !CheckFilePlatform(pInternalDriverFiles[1].pFileName, pEnvironment))
            {

                LastError = ERROR_EXE_MACHINE_TYPE_MISMATCH;
                leave;
            }

        }
        else
        {
            dwMajorVersion = ((DRIVER_INFO_2*)pDriverInfo)->cVersion;
        }

        LeaveSplSem();

        LastError = IsCompatibleDriver(pszDriverName,
                                       pInternalDriverFiles[0].pFileName,
                                       ((DRIVER_INFO_2*)pDriverInfo)->pEnvironment,
                                       dwMajorVersion,
                                       &dwBlockingStatus);

        EnterSplSem();

        if (LastError != ERROR_SUCCESS)
        {
            leave;
        }


        //
        // If the printer driver is blocked, we consider it a bad driver.
        //
        bBadDriver = (dwBlockingStatus & BSP_BLOCKING_LEVEL_MASK) == BSP_PRINTER_DRIVER_BLOCKED;
        if (bBadDriver)
        {
            LastError = ERROR_PRINTER_DRIVER_BLOCKED;
        }

        //
        // if the driver is not blocked and we are not instructed to install
        // warned driver, check for warned driver.
        //
        if(!bBadDriver && !(dwFileCopyFlags & APD_INSTALL_WARNED_DRIVER))
        {
            bBadDriver =  (dwBlockingStatus & BSP_BLOCKING_LEVEL_MASK) == BSP_PRINTER_DRIVER_WARNED;
            if (bBadDriver)
            {
                LastError = ERROR_PRINTER_DRIVER_WARNED;
            }
        }

        if (bBadDriver)
        {
            //
            // Win2k server does not recognize the new error code so we should
            // returns ERROR_UNKNOWN_PRINTER_DRIVER to get the right error
            // message on win2k and nt4.
            //
            // Client from Whistler or later will set
            // APD_RETURN_BLOCKING_STATUS_CODE before call AddPrinterDrver
            //
            if (!(dwFileCopyFlags & APD_RETURN_BLOCKING_STATUS_CODE))
            {
                LastError = ERROR_UNKNOWN_PRINTER_DRIVER;
            }

            SplLogEvent(pIniSpooler,
                        LOG_ERROR,
                        MSG_BAD_OEM_DRIVER,
                        TRUE,
                        pszDriverName,
                        NULL);
            leave;
        }

#ifdef _WIN64

        //
        // Disallow installation of WIN64 KMPD.
        //
        if (pEnvironment                                &&
            !_wcsicmp(LOCAL_ENVIRONMENT, pEnvironment)  &&
            IsKMPD(pInternalDriverFiles[0].pFileName))
        {
            LastError = ERROR_KM_DRIVER_BLOCKED;
            leave;
        }
#endif

        pIniVersion = FindVersionEntry( pIniEnvironment, dwMajorVersion );

        if (pIniVersion == NULL)
        {
            pIniVersion = CreateVersionEntry(pIniEnvironment,
                                             dwMajorVersion,
                                             pIniSpooler);

            if (pIniVersion == NULL)
            {
                leave;
            }

        }
        else
        {
            //
            // Version exists, try and create directory even if it
            // exists.  This is a slight performance hit, but since you
            // install drivers rarely, this is ok.  This fixes the problem
            // where the version directory is accidentally deleted.
            //
            if (!CreateVersionDirectory(pIniVersion,
                                        pIniEnvironment,
                                        FALSE,
                                        pIniSpooler))
            {
                leave;
            }
        }

        //
        // Check for existing driver
        //
        pIniDriver = FindDriverEntry(pIniVersion, pszDriverName);

        //
        // Clear this flag since subsequent calls doesn't check bitwise.
        //
        dwFileCopyFlags &= ~(APD_COPY_FROM_DIRECTORY | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT);

        if (!CheckFileCopyOptions(pIniEnvironment,
                                  pIniVersion,
                                  pIniDriver,
                                  pInternalDriverFiles,
                                  FileCount,
                                  dwFileCopyFlags,
                                  &bReturnValue))
        {
            //
            // We don't need to do anything because either the operation
            // failed (strict upgrade with older src files), or because
            // it's an upgrade and the dest is newer.  bReturnValue indicates
            // if the AddPrinterDriver call succeeds.
            //
            leave;
        }

        //
        // Copy files to the correct directories
        //
        if (!CopyFilesToFinalDirectory(pIniSpooler,
                                       pIniEnvironment,
                                       pIniVersion,
                                       pInternalDriverFiles,
                                       FileCount,
                                       dwFileCopyFlags,
                                       bImpersonateOnCreate,
                                       &bDriverMoved))
        {
            leave;
        }

        //
        // If pIniSpooler is a cluster spooler, then copy driver files to cluster disk
        // if the driver is not being installed from the cluster disk (as part of the
        // SplCreatespooler)
        //
        if (bCopyFilesToClusterDisk)
        {
            LastError = CopyFileToClusterDirectory(pIniSpooler,
                                                   pIniEnvironment,
                                                   pIniVersion,
                                                   pInternalDriverFiles,
                                                   FileCount);

            if (LastError == ERROR_SUCCESS)
            {
                //
                // Here we propagate the ICM profiles to the cluster disk
                //
                CopyICMFromLocalDiskToClusterDisk(pIniSpooler);
            }
            else
            {
                leave;
            }
        }

        //
        // Check if the drivers need to be unloaded
        // WaitRequiredForDriverUnload returns TRUE if the driver is loaded by Spooler process.
        // If not loaded by Spooler itself, the config file could be loaded by any client app.
        // In this case we move the loaded files in "Old" directory. When reload the confing file,
        // the client apps(WINSPOOL.DRV) will figure that the driver was upgraded and reload the dll.
        // See RefCntLoad and RefCntUnload in Winspool.drv. GDI32.DLL uses the same mechanism for
        // Driver file.
        //
        if (WaitRequiredForDriverUnload(pIniSpooler,
                                        pIniEnvironment,
                                        pIniVersion,
                                        pIniDriver,
                                        Level,
                                        pDriverInfo,
                                        dwFileCopyFlags,
                                        pInternalDriverFiles,
                                        FileCount,
                                        dwMajorVersion,
                                        bDriverMoved,
                                        &bReturnValue) &&
            bReturnValue)
        {
            if (pIniDriver)
            {
                //
                // Store information in the registry to complete the call later
                //
                bReturnValue = SaveParametersForUpgrade(pIniSpooler->pMachineName, bDriverMoved,
                                                        Level, pDriverInfo, dwMajorVersion);
                leave;

            }
            else
            {
                //
                // Add driver in a temp directory
                //
                bReturnValue = AddTempDriver(pIniSpooler,
                                             pIniEnvironment,
                                             pIniVersion,
                                             Level,
                                             pDriverInfo,
                                             dwFileCopyFlags,
                                             pInternalDriverFiles,
                                             FileCount,
                                             dwMajorVersion,
                                             bDriverMoved
                                             );

                leave;
            }
        }

    } finally {

        //
        // This code is only for clusters
        //
        if (bReturnValue && pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER)
        {
            SYSTEMTIME SysTime = {0};

            if (bCopyFilesToClusterDisk)
            {
                //
                // We are in the case where the add printer driver call comes from outside
                // the spooler. We need to get the local time and write the time stamp in the
                // locl regsitry and in the cluster database
                //
                GetLocalTime(&SysTime);

                //
                // Write timestamp to registry. Doesn't matter if any of them fails
                // The time stamp is for faster cluster spooler initialization
                //
                WriteTimeStamp(pIniSpooler->hckRoot,
                               SysTime,
                               pIniSpooler->pszRegistryEnvironments,
                               pIniEnvironment->pName,
                               szDriversKey,
                               pIniVersion->pName,
                               pszDriverName,
                               pIniSpooler);
            }
            else
            {
                //
                // We are in the case where the add printer driver call came from inside
                // the spooler (SplCreateSpooler). This is the case when our local node
                // doesn't already have the driver installed. We do not need to get a new
                // time stamp. (this would case the time stamp in the cluster db to be updated,
                // and then whenever we fail over the time stamps will be always different)
                // We just get the time stamp from the cluster db and update the local registry
                //
                ReadTimeStamp(pIniSpooler->hckRoot,
                              &SysTime,
                              pIniSpooler->pszRegistryEnvironments,
                              pIniEnvironment->pName,
                              szDriversKey,
                              pIniVersion->pName,
                              pszDriverName,
                              pIniSpooler);
            }

            WriteTimeStamp(HKEY_LOCAL_MACHINE,
                           SysTime,
                           ipszRegistryClusRepository,
                           pIniSpooler->pszClusResID,
                           pIniEnvironment->pName,
                           pIniVersion->pName,
                           pszDriverName,
                           NULL);
        }

        if (!bReturnValue && LastError == ERROR_SUCCESS)
        {
            LastError = GetLastError();

            //
            // We failed the call because bDriverMoved was FALSE and the driver was loaded
            //
            if(LastError == ERROR_SUCCESS && !bDriverMoved)
            {
                 LastError = ERROR_NO_SYSTEM_RESOURCES;
            }
        }

        if (bUseScratchDir && FileCount)
        {
            SetOldDateOnDriverFilesInScratchDirectory(pInternalDriverFiles,
                                                      FileCount,
                                                      pIniSpooler);
        }

        LeaveSplSem();

        if (FileCount)
        {
            CleanupInternalDriverInfo(pInternalDriverFiles, FileCount);
        }

        CleanUpgradeDirectories();

        //
        // End the system restore point once everything is done. Cancel it if the
        // function fails.
        //
        if (hRestorePoint)
        {
            (VOID)EndSystemRestorePoint(hRestorePoint, !bReturnValue);
        }

        if (!bReturnValue)
        {
            DBGMSG( DBG_WARNING, ("InternalAddPrinterDriver Failed %d\n", LastError ));
            SetLastError(LastError);
        }
    }

    return bReturnValue;
}

BOOL
AddTempDriver(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      BOOL                bDriverMoved
    )

/*++
Function Description: For new drivers which require driver files to be unloaded,
                      add the driver into a temp directory and mark it for upgrade on
                      reboot OR when the files are unloaded

Parameters:   pIniSpooler          -- pointer to INISPOOLER
              pIniEnvironment      -- pointer to INIENVIRONMENT
              pIniVersion          -- pointer to INVERSION
              dwLevel              -- driver_info level
              pDriverInfo          -- pointer to driver_info
              dwFileCopyFlags      -- File copy flags that make it to the spooler
              pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
              dwFileCount          -- number of files in file set
              dwVersion            -- driver version
              bDriverMoved         -- Were any files moved to the Old directory ?

Return Values: TRUE if the driver was added;
               FALSE otherwise
--*/

{
    BOOL     bReturn = FALSE;
    WCHAR    szVersionDir[MAX_PATH], szNewDir[MAX_PATH+5];
    WCHAR    szDriverFile[MAX_PATH], szOldFile[MAX_PATH], szNewFile[MAX_PATH];
    WCHAR    *pTempDir = NULL;
    DWORD    dwIndex, dwTempDir;
    HANDLE   hToken = NULL, hFile;
    LPWSTR   pFileName;

    hToken = RevertToPrinterSelf();

    //
    // get the version directory
    //
    // szVersionDir shouldn't be bigger than MAX_PATH - 5 since is used later
    // to build another file paths.
    //
    if((StrNCatBuff(szVersionDir,
                    MAX_PATH - 5,
                    pIniSpooler->pDir,
                    L"\\drivers\\",
                    pIniEnvironment->pDirectory,
                    L"\\",
                    pIniVersion->szDirectory,
                    NULL) != ERROR_SUCCESS))
    {
        goto CleanUp;
    }

    dwIndex = CreateNumberedTempDirectory((LPWSTR)szVersionDir, &pTempDir);

    if (dwIndex == -1) {
        goto CleanUp;
    }

    dwTempDir = dwIndex;

    StringCchPrintf(szNewDir, COUNTOF(szNewDir), L"%ws\\New", szVersionDir);

    //
    // copy the files into the temp directory and mark them for deletion on
    // reboot
    //
    for (dwIndex = 0; dwIndex < dwFileCount; dwIndex++) {

        pFileName = (LPWSTR) FindFileName(pInternalDriverFiles[dwIndex].pFileName);

        if((StrNCatBuff(szNewFile,MAX_PATH,szNewDir ,L"\\", pFileName, NULL) != ERROR_SUCCESS)        ||
           (StrNCatBuff(szOldFile,MAX_PATH,szVersionDir, L"\\", pFileName, NULL) != ERROR_SUCCESS)    ||
           (StrNCatBuff(szDriverFile,MAX_PATH,pTempDir, L"\\", pFileName, NULL) != ERROR_SUCCESS))
        {
             goto CleanUp;
        }

        hFile = CreateFile(szNewFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE) {

            CopyFile(szOldFile, szDriverFile, FALSE);

        } else {

            CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;

            CopyFile(szNewFile, szDriverFile, FALSE);
        }

        SplMoveFileEx(szDriverFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
    }

    //
    // Delete the directory on reboot
    //
    SplMoveFileEx(szNewDir, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);

    //
    // Update driver structures and make event call backs and
    // store information in the registry to complete the call later
    //
    bReturn = CompleteDriverUpgrade(pIniSpooler,
                                    pIniEnvironment,
                                    pIniVersion,
                                    NULL,
                                    dwLevel,
                                    pDriverInfo,
                                    dwFileCopyFlags,
                                    pInternalDriverFiles,
                                    dwFileCount,
                                    dwVersion,
                                    dwTempDir,
                                    bDriverMoved,
                                    TRUE,
                                    TRUE) &&

              SaveParametersForUpgrade(pIniSpooler->pMachineName,
                                       bDriverMoved,
                                       dwLevel,
                                       pDriverInfo,
                                       dwVersion);

CleanUp:

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    FreeSplMem(pTempDir);

    return bReturn;
}

BOOL
WaitRequiredForDriverUnload(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      BOOL                bDriverMoved,
        OUT LPBOOL              pbSuccess
    )
/*++
Function Description: Determine if the driver upgrade has to be defered till the
                      dlls can be unloaded. GDI and the client side of the spooler are
                      notified to continue the pending upgrade when the dll is unloaded.

Parameters:   pIniSpooler          -- pointer to INISPOOLER
              pIniEnvironment      -- pointer to INIENVIRONMENT
              pIniVersion          -- pointer to INVERSION
              pIniDriver           -- pointer to INIDRIVER
              dwLevel              -- driver_info level
              pDriverInfo          -- pointer to driver_info
              dwFileCopyFlags      -- copy flags for the driver.
              pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
              dwFileCount          -- number of files in file set
              dwVersion            -- driver version
              bDriverMoved         -- Were any files moved to the Old directory ?
              pbSuccess            -- pointer to Success flag

Return Values: TRUE if the driver was unloaded and upgraded;
               FALSE if the driver cant be unloaded
--*/

{
    BOOL           bUnloaded,bDriverFileMoved, bConfigFileMoved;
    LPWSTR         pDriverFile, pConfigFile;
    WCHAR          szDriverFile[MAX_PATH], szOldDir[MAX_PATH], szNewDir[MAX_PATH];
    WCHAR          szTempFile[MAX_PATH], szCurrDir[MAX_PATH], szConfigFile[MAX_PATH];
    HANDLE         hFile, hToken = NULL;
    DWORD          dwDriverAttributes = 0;

    hToken = RevertToPrinterSelf();

    *pbSuccess = FALSE;

    //
    // Set up Driver, Old and New directories
    //
    if((StrNCatBuff(szCurrDir,
                    MAX_PATH,
                    pIniSpooler->pDir,
                    L"\\drivers\\",
                    pIniEnvironment->pDirectory,
                    L"\\",
                    pIniVersion->szDirectory,
                    NULL) != ERROR_SUCCESS)         ||
       (StrNCatBuff(szOldDir,
                    MAX_PATH,
                    szCurrDir,
                    L"\\Old",
                    NULL) != ERROR_SUCCESS)         ||
       (StrNCatBuff(szNewDir,
                    MAX_PATH,
                    szCurrDir,
                    L"\\New",
                    NULL) != ERROR_SUCCESS)         ||
       (StrNCatBuff(szDriverFile,
                    MAX_PATH,
                    szCurrDir,
                    L"\\",
                    FindFileName(pInternalDriverFiles[0].pFileName),
                    NULL) != ERROR_SUCCESS)         ||
       (StrNCatBuff(szConfigFile,
                    MAX_PATH,
                    szCurrDir,
                    L"\\",
                    FindFileName(pInternalDriverFiles[1].pFileName),
                    NULL) != ERROR_SUCCESS)         ||
       (StrNCatBuff(szTempFile,
                    MAX_PATH,szNewDir,
                    L"\\",
                    FindFileName(pInternalDriverFiles[0].pFileName),
                    NULL) != ERROR_SUCCESS))
    {
         bUnloaded  = TRUE;
         goto CleanUp;
    }
    
    //
    // Check if the new driver file needs to be copied
    //
    hFile = CreateFile(szTempFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        pDriverFile = szDriverFile;

        if (pIniDriver) {
            dwDriverAttributes = pIniDriver->dwDriverAttributes;
        } else {
            dwDriverAttributes = IsKMPD(szDriverFile) ? DRIVER_KERNELMODE
                                                      : DRIVER_USERMODE;
        }
    } else {
        pDriverFile = NULL;
    }

    if((StrNCatBuff(szTempFile,
                    MAX_PATH,
                    szNewDir,
                    L"\\",
                    FindFileName(pInternalDriverFiles[1].pFileName), NULL)
                    != ERROR_SUCCESS))
    {
        bUnloaded  = TRUE;
        goto CleanUp;
    }

    //
    // Check if the new config file needs to be copied
    //
    hFile = CreateFile(szTempFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        pConfigFile = szConfigFile;
    } else {
        pConfigFile = NULL;
    }

    bUnloaded = FilesUnloaded(pIniEnvironment, pDriverFile, pConfigFile,
                              dwDriverAttributes);

    if (bUnloaded) {

        //
        // Move the driver files from New directory to Version directory
        // and from Version directory to Old directory if in use.
        //
        if (MoveNewDriverRelatedFiles(szNewDir,
                                      szCurrDir,
                                      szOldDir,
                                      pInternalDriverFiles,
                                      dwFileCount,
                                      &bDriverFileMoved,
                                      &bConfigFileMoved)) {

            //
            // Update driver structures and make event call backs.
            //
            *pbSuccess = CompleteDriverUpgrade(pIniSpooler,
                                               pIniEnvironment,
                                               pIniVersion,
                                               pIniDriver,
                                               dwLevel,
                                               pDriverInfo,
                                               dwFileCopyFlags,
                                               pInternalDriverFiles,
                                               dwFileCount,
                                               dwVersion,
                                               0,
                                               bDriverMoved,
                                               bDriverFileMoved,
                                               bConfigFileMoved
                                               );
        }
    }
    else {

        //
        // We care if the files are marked to be moved from New to Version directory only if the drivers are loaded
        // and we left the updated files in New directory. Then it is imperative MoveFileEx to have succeeded.
        // Fail the api call if bDriverMoved is FALSE;
        //
        *pbSuccess = bDriverMoved;
    }

CleanUp:

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }


    return (!bUnloaded);
}

BOOL FilesUnloaded(
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR  pDriverFile,
    LPWSTR  pConfigFile,
    DWORD   dwDriverAttributes)
{
    BOOL bReturn = TRUE;
    fnWinSpoolDrv fnList;

    //
    // Drivers belonging to other environments are not loaded.
    //
    if (!pIniEnvironment ||
        lstrcmpi(pIniEnvironment->pName, szEnvironment)) {

        return bReturn;
    }

    if (pDriverFile) {

        bReturn = GdiArtificialDecrementDriver(pDriverFile,
                                               dwDriverAttributes);
    }

    if (bReturn && pConfigFile && SplInitializeWinSpoolDrv(&fnList)) {

        bReturn = (* (fnList.pfnForceUnloadDriver))(pConfigFile);
    }

    return bReturn;
}

DWORD StringSizeInBytes(
    LPWSTR pString,
    BOOL   bMultiSz)

/*++
Function Description: Computes the number of bytes in the string

Parameters: pString   -- string pointer
            bMultiSz  -- flag for multi_sz strings

Return Values: number of bytes
--*/

{
    DWORD  dwReturn = 0, dwLength;

    if (!pString) {
        return dwReturn;
    }

    if (!bMultiSz) {

        dwReturn = (wcslen(pString) + 1) * sizeof(WCHAR);

    } else {

        while (dwLength = wcslen(pString)) {

             pString += (dwLength + 1);
             dwReturn += (dwLength + 1) * sizeof(WCHAR);
        }

        dwReturn += sizeof(WCHAR);
    }

    return dwReturn;
}

DWORD LocalRegSetValue(
    HKEY    hKey,
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pValueData)

/*++
Function Description:  This function is a wrapper around RegSetValueEx which puts in
                       NULL strings for NULL pointers.

Parameters:  hKey        -  handle to registry key
             pValueName  -  value name
             dwType      -  type of value data (REG_DWORD , REG_SZ ...)
             pValueData  -  data buffer

Return Values: Last error returned by RegSetValueEx
--*/

{
    DWORD   dwSize;
    WCHAR   pNull[2];
    LPBYTE  pData = pValueData;

    if (!pValueName) {
        return ERROR_SUCCESS;
    }

    pNull[0] = pNull[1] = L'\0';

    switch (dwType) {

    case REG_DWORD:
         dwSize = sizeof(DWORD);
         break;

    case REG_SZ:
         if (!pData) {
             pData = (LPBYTE) pNull;
             dwSize = sizeof(WCHAR);
         } else {
             dwSize = StringSizeInBytes((LPWSTR) pData, FALSE);
         }
         break;

    case REG_MULTI_SZ:
         if (!pData || !*pData) {
             pData = (LPBYTE) pNull;
             dwSize = 2 * sizeof(WCHAR);
         } else {
             dwSize = StringSizeInBytes((LPWSTR) pData, TRUE);
         }
         break;

    default:
         return ERROR_INVALID_PARAMETER;
    }

    return RegSetValueEx(hKey, pValueName, 0, dwType, pData, dwSize);
}

BOOL SaveParametersForUpgrade(
    LPWSTR pName,
    BOOL   bDriverMoved,
    DWORD  dwLevel,
    LPBYTE pDriverInfo,
    DWORD  dwVersion)

/*++
Function Description: Saves data for the driver upgrade which has to be
                      deferred till the new driver can be loaded

Parameters: pName         -- pIniSpooler->pName
            bDriverMoved  -- Were any of the old driver files moved?
            dwLevel       -- Driver_Info level
            pDriverInfo   -- Driver_Info pointer
            dwVersion     -- Driver version number

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    HANDLE         hToken = NULL;
    HKEY           hRootKey = NULL, hUpgradeKey = NULL, hVersionKey = NULL;
    HKEY           hDriverKey = NULL;
    DWORD          dwDriverMoved = (DWORD) bDriverMoved;
    BOOL           bReturn = FALSE;
    WCHAR          Buffer[MAX_PATH];
    PDRIVER_INFO_2 pDriver2;
    PDRIVER_INFO_3 pDriver3;
    PDRIVER_INFO_4 pDriver4;
    PDRIVER_INFO_6 pDriver6;

    pDriver2 = (PDRIVER_INFO_2) pDriverInfo;

    //
    // Stop impersonation for modifying the registry
    //
    hToken = RevertToPrinterSelf();

    //
    // Create the registry keys
    //
    if (!BoolFromHResult(StringCchPrintf(Buffer, COUNTOF(Buffer), L"Version-%d", dwVersion)) ||

        RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryRoot, 0, NULL, 0, KEY_WRITE, NULL, &hRootKey, NULL) ||

        RegCreateKeyEx(hRootKey, szPendingUpgrades, 0, NULL, 0, KEY_WRITE, NULL, &hUpgradeKey, NULL) ||

        RegCreateKeyEx(hUpgradeKey, Buffer, 0, NULL, 0, KEY_WRITE, NULL, &hVersionKey, NULL) ||

        RegCreateKeyEx(hVersionKey, pDriver2->pName, 0, NULL, 0, KEY_WRITE, NULL, &hDriverKey, NULL)) {

         goto CleanUp;
    }

    if (dwLevel == DRIVER_INFO_VERSION_LEVEL) {

        bReturn = SaveDriverVersionForUpgrade(hDriverKey, (PDRIVER_INFO_VERSION)pDriverInfo,
                                              pName, bDriverMoved, dwVersion);

        goto CleanUp;
    }

    //
    // Add the spooler name and driver info level.
    //
    if (LocalRegSetValue(hDriverKey, L"SplName", REG_SZ, (LPBYTE) pName) ||

        LocalRegSetValue(hDriverKey, L"Level",  REG_DWORD, (LPBYTE) &dwLevel) ||

        LocalRegSetValue(hDriverKey, L"DriverMoved", REG_DWORD, (LPBYTE) &dwDriverMoved)) {

         goto CleanUp;
    }

    //
    // Add Driver_Info_2 data.
    //
    if (LocalRegSetValue(hDriverKey, L"cVersion", REG_DWORD, (LPBYTE) &dwVersion) ||

        LocalRegSetValue(hDriverKey, L"pName", REG_SZ, (LPBYTE) pDriver2->pName) ||

        LocalRegSetValue(hDriverKey, L"pEnvironment", REG_SZ, (LPBYTE) pDriver2->pEnvironment) ||

        LocalRegSetValue(hDriverKey, L"pDriverPath", REG_SZ, (LPBYTE) pDriver2->pDriverPath) ||

        LocalRegSetValue(hDriverKey, L"pDataFile", REG_SZ, (LPBYTE) pDriver2->pDataFile) ||

        LocalRegSetValue(hDriverKey, L"pConfigFile", REG_SZ, (LPBYTE) pDriver2->pConfigFile)) {

         goto CleanUp;
    }

    if (dwLevel != 2) {

        pDriver3 = (PDRIVER_INFO_3) pDriverInfo;

        //
        // Add Driver_Info_3 data.
        //
        if (LocalRegSetValue(hDriverKey, L"pHelpFile", REG_SZ, (LPBYTE) pDriver3->pHelpFile) ||

            LocalRegSetValue(hDriverKey, L"pDependentFiles", REG_MULTI_SZ,
                             (LPBYTE) pDriver3->pDependentFiles) ||

            LocalRegSetValue(hDriverKey, L"pMonitorName", REG_SZ,
                             (LPBYTE) pDriver3->pMonitorName) ||

            LocalRegSetValue(hDriverKey, L"pDefaultDataType", REG_SZ,
                             (LPBYTE) pDriver3->pDefaultDataType)) {

             goto CleanUp;
        }

        if (dwLevel == 4 || dwLevel == 6) {

           pDriver4 = (PDRIVER_INFO_4) pDriverInfo;

           //
           // Add Driver_Info_4 data.
           //
           if (LocalRegSetValue(hDriverKey, L"pszzPreviousNames", REG_MULTI_SZ, (LPBYTE) pDriver4->pszzPreviousNames))
           {
               goto CleanUp;
           }
        }

        if (dwLevel == 6) {

           pDriver6 = (PDRIVER_INFO_6) pDriverInfo;

           //
           // Add Driver_Info6 data.
           //
           if (RegSetValueEx(hDriverKey, L"ftDriverDate", 0, REG_BINARY, (LPBYTE)&pDriver6->ftDriverDate, sizeof(FILETIME)) ||

               RegSetValueEx(hDriverKey, L"dwlDriverVersion", 0, REG_BINARY, (LPBYTE)&pDriver6->dwlDriverVersion, sizeof(DWORDLONG)) ||

               LocalRegSetValue(hDriverKey, L"pszMfgName", REG_SZ, (LPBYTE)pDriver6->pszMfgName)                        ||

               LocalRegSetValue(hDriverKey, L"pszOEMUrl", REG_SZ, (LPBYTE)pDriver6->pszOEMUrl)                          ||

               LocalRegSetValue(hDriverKey, L"pszHardwareID", REG_SZ, (LPBYTE)pDriver6->pszHardwareID)                  ||

               LocalRegSetValue(hDriverKey, L"pszProvider", REG_SZ, (LPBYTE)pDriver6->pszProvider)
              )
           {
               goto CleanUp;
           }
        }
    }

    bReturn = TRUE;

CleanUp:

    if (hDriverKey) {
        RegCloseKey(hDriverKey);
    }

    if (hVersionKey) {
        RegCloseKey(hVersionKey);
    }

    if (hUpgradeKey) {
        RegCloseKey(hUpgradeKey);
    }

    if (hRootKey) {
        RegCloseKey(hRootKey);
    }

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    return bReturn;
}


BOOL SaveDriverVersionForUpgrade(
    IN  HKEY                    hDriverKey,
    IN  PDRIVER_INFO_VERSION    pDriverVersion,
    IN  LPWSTR                  pName,
    IN  DWORD                   dwDriverMoved,
    IN  DWORD                   dwVersion
    )
/*++

Routine Name:

    SaveDriverVersionForUpgrade

Routine Description:

    Save a DRIVER_INFO_VERSION into registry for pending driver upgrade purposes.
    It is called by SaveParametersForUpgrade.
    For simplicity, it will save it in the same format DRIVER_INFO_6
    is saved in the registry.

Arguments:

    hDriverKey      - the registry key where to save data
    pDriverVersion  - pointer to DRIVER_INFO_VERSION structure
    pName           - driver name
    dwDriverMoved   - information about the way files where move between directories
    dwVersion       - driver version

Return Value:

    TRUE if success.

--*/
{

    BOOL    bRetValue = FALSE;
    DWORD   dwLevel = 6;
    PWSTR   pDllFiles = NULL;
    PWSTR   pszDriverPath, pszDataFile, pszConfigFile, pszHelpFile, pDependentFiles ;

    pszDriverPath = pszDataFile = pszConfigFile = pszHelpFile = NULL;


    if (!GetFileNamesFromDriverVersionInfo(pDriverVersion,
                                           &pszDriverPath,
                                           &pszConfigFile,
                                           &pszDataFile,
                                           &pszHelpFile))
    {
        goto CleanUp;
    }

    if (!BuildDependentFilesFromDriverInfo(pDriverVersion,
                                           &pDllFiles))
    {
        goto CleanUp;
    }


    if (LocalRegSetValue(hDriverKey, L"SplName", REG_SZ, (LPBYTE) pName)                            ||
        LocalRegSetValue(hDriverKey, L"Level", REG_DWORD, (LPBYTE) &dwLevel)                        ||
        LocalRegSetValue(hDriverKey, L"DriverMoved", REG_DWORD, (LPBYTE) &dwDriverMoved)            ||
        LocalRegSetValue(hDriverKey, L"Level",  REG_DWORD, (LPBYTE) &dwLevel)                       ||
        LocalRegSetValue(hDriverKey, L"cVersion", REG_DWORD, (LPBYTE) &dwVersion)                   ||
        LocalRegSetValue(hDriverKey, L"pName", REG_SZ, (LPBYTE) pDriverVersion->pName)              ||
        LocalRegSetValue(hDriverKey, L"pEnvironment", REG_SZ, (LPBYTE) pDriverVersion->pEnvironment)||
        LocalRegSetValue(hDriverKey, L"pDriverPath", REG_SZ, (LPBYTE) pszDriverPath)                ||
        LocalRegSetValue(hDriverKey, L"pDataFile", REG_SZ, (LPBYTE) pszDataFile)                    ||
        LocalRegSetValue(hDriverKey, L"pConfigFile", REG_SZ, (LPBYTE) pszConfigFile)                ||
        LocalRegSetValue(hDriverKey, L"pHelpFile", REG_SZ, (LPBYTE) pszHelpFile)                    ||
        LocalRegSetValue(hDriverKey, L"pDependentFiles", REG_MULTI_SZ, (LPBYTE) pDllFiles)          ||
        LocalRegSetValue(hDriverKey, L"pMonitorName", REG_SZ,
                        (LPBYTE) pDriverVersion->pMonitorName)                                      ||

        LocalRegSetValue(hDriverKey, L"pDefaultDataType", REG_SZ,
                        (LPBYTE) pDriverVersion->pDefaultDataType)                                  ||

        LocalRegSetValue(hDriverKey, L"pszzPreviousNames", REG_MULTI_SZ,
                        (LPBYTE) pDriverVersion->pszzPreviousNames)                                 ||

        RegSetValueEx(hDriverKey, L"ftDriverDate", 0, REG_BINARY,
                      (LPBYTE)&pDriverVersion->ftDriverDate, sizeof(FILETIME))                      ||

        RegSetValueEx(hDriverKey, L"dwlDriverVersion", 0, REG_BINARY,
                     (LPBYTE)&pDriverVersion->dwlDriverVersion, sizeof(DWORDLONG))                  ||

        LocalRegSetValue(hDriverKey, L"pszMfgName", REG_SZ,
                        (LPBYTE)pDriverVersion->pszMfgName)                                         ||

        LocalRegSetValue(hDriverKey, L"pszOEMUrl", REG_SZ,
                        (LPBYTE)pDriverVersion->pszOEMUrl)                                          ||

        LocalRegSetValue(hDriverKey, L"pszHardwareID", REG_SZ,
                        (LPBYTE)pDriverVersion->pszHardwareID)                                      ||

        LocalRegSetValue(hDriverKey, L"pszProvider", REG_SZ,
                        (LPBYTE)pDriverVersion->pszProvider))

    {
        goto CleanUp;
    }

    bRetValue = TRUE;

CleanUp:

    FreeSplMem(pDllFiles);

    return bRetValue;
}

BOOL
MoveNewDriverRelatedFiles(
    LPWSTR              pNewDir,
    LPWSTR              pCurrDir,
    LPWSTR              pOldDir,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    LPBOOL              pbDriverFileMoved,
    LPBOOL              pbConfigFileMoved)

/*++
Function Description:  Moves driver files in the New directory to the correct directory.

Parameters:  pNewDir         -- name of the New (source) directory
             pCurrDir        -- name of the destination directory
             pOldDir         -- name of the Old (temp) directory
             pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
             dwFileCount          -- number of files in file set
             pbDriverFileMoved -- flag to return if new driver file has been moved;
                                  We assume entry 0 for driver file in pInternalDriverFiles array
                                  pbDriverFileMoved should be NULL when this assumption is FALSE
                                  ( see SplCopyNumberOfFiles )
             pbConfigFileMoved -- flag to return if new config file has been moved;
                                  We assume entry 0 for config file in pInternalDriverFiles array
                                  pbConfigFileMoved should be NULL when this assumption is FALSE
                                  ( see SplCopyNumberOfFiles )

Return Values: NONE
--*/

{
    HANDLE  hFile;
    DWORD   dwIndex, dwBackupIndex;
    WCHAR   szDriverFile[MAX_PATH], szNewFile[MAX_PATH], szOldFile[MAX_PATH];
    WCHAR   *pszTempOldDirectory = NULL;
    LPWSTR  pFileName;
    BOOL    bRetValue = FALSE;
    BOOL    bFailedToMove = FALSE;

    if (pbDriverFileMoved)
    {
        *pbDriverFileMoved = FALSE;
    }

    if (pbConfigFileMoved)
    {
        *pbConfigFileMoved = FALSE;
    }

    if (CreateNumberedTempDirectory(pOldDir, &pszTempOldDirectory) != -1) {

        for (dwIndex = 0; dwIndex < dwFileCount; dwIndex++) {

            BOOL FileCopied = FALSE;

            pFileName = (LPWSTR) FindFileName(pInternalDriverFiles[dwIndex].pFileName);

            if((StrNCatBuff(szNewFile,MAX_PATH,pNewDir, L"\\", pFileName, NULL) == ERROR_SUCCESS) &&
               (StrNCatBuff(szDriverFile,MAX_PATH,pCurrDir, L"\\", pFileName, NULL) == ERROR_SUCCESS) &&
               (StrNCatBuff(szOldFile,MAX_PATH,pszTempOldDirectory, L"\\", pFileName, NULL) == ERROR_SUCCESS))
            {
                hFile = CreateFile(szNewFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL, NULL);

                if (hFile != INVALID_HANDLE_VALUE)
                {
                    CloseHandle(hFile);

                    if (!SplMoveFileEx(szDriverFile, szOldFile, MOVEFILE_REPLACE_EXISTING)) {

                        bFailedToMove = TRUE;
                        dwBackupIndex = dwIndex;
                        break;
                    }

                    if (!SplMoveFileEx(szNewFile, szDriverFile, MOVEFILE_REPLACE_EXISTING)) {

                        bFailedToMove = TRUE;
                        dwBackupIndex = dwIndex + 1;
                        break;
                    }

                    FileCopied = TRUE;
                    //
                    // We could come in here from a pending upgrade
                    //
                    pInternalDriverFiles[dwIndex].bUpdated = TRUE;
                }
            }

            switch (dwIndex)
            {
            case 0:
                if (pbDriverFileMoved)
                {
                    *pbDriverFileMoved = FileCopied;
                }
                break;
            case 1:
                if (pbConfigFileMoved)
                {
                    *pbConfigFileMoved = FileCopied;
                }
                break;
            }
        }

        if ( bFailedToMove ) {

            //
            // Restore the initial file set in version directory.
            // Old\N has the replaced files. Move them back to Version directory.
            //
            for (dwIndex = 0; dwIndex < dwBackupIndex; dwIndex++) {

                pFileName = (LPWSTR) FindFileName(pInternalDriverFiles[dwIndex].pFileName);

                if( (StrNCatBuff(szDriverFile,MAX_PATH,pCurrDir, L"\\", pFileName, NULL) == ERROR_SUCCESS) &&
                    (StrNCatBuff(szOldFile,MAX_PATH,pszTempOldDirectory, L"\\", pFileName, NULL) == ERROR_SUCCESS)) {

                    SplMoveFileEx(szOldFile, szDriverFile, MOVEFILE_REPLACE_EXISTING);
                }

                pInternalDriverFiles[dwIndex].bUpdated = FALSE;
            }

        } else {

            bRetValue = TRUE;
        }
    }

    FreeSplMem(pszTempOldDirectory);

    return bRetValue;
}

BOOL LocalDriverUnloadComplete(
    LPWSTR   pDriverFile)

/*++
Function Description: This function is called in response to some driver file
                      being unloaded. The spooler tries to complete driver upgrades
                      that were waiting for this file to unload.

Parameters: pDriverFile   -- Driver file which was unloaded

Return Values: TRUE
--*/
{
    HANDLE  hToken = NULL;

    hToken = RevertToPrinterSelf();

    PendingDriverUpgrades(pDriverFile);

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    return TRUE;
}

BOOL RestoreVersionKey(
    HKEY     hUpgradeKey,
    DWORD    dwIndex,
    HKEY     *phVersionKey)

/*++
Function Description: Gets the version key from the pending upgrade key

Parameters: hUpgradeKey    -- upgrade key
            dwIndex        -- version index
            phVersionKey   -- pointer to buffer for version key

Return Values: TRUE if version key is found
               FALSE otherwise
--*/

{
    WCHAR   pBuffer[MAX_PATH];
    DWORD   dwSize = MAX_PATH;

    *phVersionKey = NULL;

    if (RegEnumKeyEx(hUpgradeKey, dwIndex, pBuffer, &dwSize,
                     NULL, NULL, NULL, NULL)) {

        return FALSE;
    }

    if (RegCreateKeyEx(hUpgradeKey, pBuffer, 0,
                       NULL, 0, KEY_READ | DELETE, NULL, 
                       phVersionKey, NULL)) {

        return FALSE;
    }

    return TRUE;
}

VOID PendingDriverUpgrades(
    LPWSTR   pDriverFile)

/*++
Function Description: Loops thru the list of pending upgrades and completes them if
                      driver files have been unloaded. This function will try all the
                      drivers on spooler startup.

Parameters: pDriverFile  -- name of the file which was unloaded

Return Values: NONE
--*/

{
    DWORD    dwIndex, dwLevel, dwDriverMoved, dwFileCount, dwVersion, dwVersionIndex;
    LPWSTR   pKeyName, pSplName,pEnvironment;
    PINTERNAL_DRV_FILE pInternalDriverFiles = NULL;
    HKEY     hRootKey = NULL, hVersionKey = NULL, hUpgradeKey = NULL;
    WCHAR    szDir[MAX_PATH], szDriverFile[MAX_PATH], szConfigFile[MAX_PATH];
    BOOL     bSuccess;

    PDRIVER_INFO_6   pDriverInfo;
    PINISPOOLER      pIniSpooler;
    PINIENVIRONMENT  pIniEnvironment;
    PINIVERSION      pIniVersion;
    PINIDRIVER       pIniDriver;

    //
    // Struct for maintaining keynames to be deleted at the end.
    //
    struct StringList {
       struct StringList *pNext;
       LPWSTR  pKeyName;
       DWORD   dwVersionIndex;
    } *pStart, *pTemp;

    pStart = pTemp = NULL;

    EnterSplSem();

    //
    // Open the registry key.
    //
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryRoot, 0,
                       NULL, 0, KEY_READ | DELETE, NULL, &hRootKey, NULL) ||

        RegCreateKeyEx(hRootKey, szPendingUpgrades, 0,
                       NULL, 0, KEY_READ | DELETE, NULL, &hUpgradeKey, NULL)) {

         goto CleanUp;
    }

    //
    // Loop thru each version entry in the registry.
    //
    for (dwVersionIndex = 0, hVersionKey = NULL;

         RestoreVersionKey(hUpgradeKey, dwVersionIndex, &hVersionKey);

         RegCloseKey(hVersionKey), hVersionKey = NULL, ++dwVersionIndex) {
        
        //
        // Loop thru each driver upgrade.
        //
        for (dwIndex = 0, dwFileCount = 0, pInternalDriverFiles = NULL;

             RestoreParametersForUpgrade(hVersionKey,
                                         dwIndex,
                                         &pKeyName,
                                         &pSplName,
                                         &dwLevel,
                                         &dwDriverMoved,
                                         &pDriverInfo);

             CleanUpResources(pKeyName, pSplName, pDriverInfo,
                              &pInternalDriverFiles, dwFileCount),
             ++dwIndex, dwFileCount = 0, pInternalDriverFiles = NULL) {

            // 
            // The driver_info struct validity has been checked while updating
            // the registry.
            //
            // Set pIniSpooler to LocalIniSpooler
            //
            if (!(pIniSpooler = pLocalIniSpooler)) {
                continue;
            }

            //
            // Set pIniEnvironment.
            //
            pEnvironment = szEnvironment;
            if (pDriverInfo->pEnvironment && *(pDriverInfo->pEnvironment)) {
                pEnvironment = pDriverInfo->pEnvironment;
            }
            pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler);
            if (!pIniEnvironment) {
                continue;
            }

            //
            // Set pIniVersion.
            //
            dwVersion = pDriverInfo->cVersion;
            pIniVersion = FindVersionEntry(pIniEnvironment, dwVersion);
            if (!pIniVersion) {
                continue;
            }

            //
            // Set pIniDriver.
            //
            pIniDriver = FindDriverEntry(pIniVersion, pDriverInfo->pName);
            if (!pIniDriver) {
                continue;
            }

            //
            // Check for the file name which was unloaded
            //
            if (pDriverFile) {

               if((StrNCatBuff(szDir,
                               MAX_PATH,
                               pIniSpooler->pDir,
                               L"\\drivers\\",
                               pIniEnvironment->pDirectory,
                               L"\\",
                               pIniVersion->szDirectory,
                               NULL) != ERROR_SUCCESS)                  ||
                  (StrNCatBuff(szDriverFile,
                               MAX_PATH,
                               szDir,
                               L"\\",
                               FindFileName(pIniDriver->pDriverFile),
                               NULL) != ERROR_SUCCESS)                  ||
                  (StrNCatBuff(szConfigFile,
                               MAX_PATH,szDir,
                               L"\\",
                               FindFileName(pIniDriver->pConfigFile),
                               NULL) != ERROR_SUCCESS))
                   continue;

               if (_wcsicmp(pDriverFile, szDriverFile) &&
                   _wcsicmp(pDriverFile, szConfigFile))  {

                   continue;
               }
            }

            if (!CreateInternalDriverFileArray(dwLevel,
                                               (LPBYTE)pDriverInfo,
                                               &pInternalDriverFiles,
                                               &dwFileCount,
                                               FALSE,
                                               pIniEnvironment,
                                               TRUE))
            {
                continue;
            }

            if (!WaitRequiredForDriverUnload(pIniSpooler,
                                             pIniEnvironment,
                                             pIniVersion,
                                             pIniDriver,
                                             dwLevel,
                                             (LPBYTE) pDriverInfo,
                                             APD_STRICT_UPGRADE,
                                             pInternalDriverFiles,
                                             dwFileCount,
                                             dwVersion,
                                             (BOOL) dwDriverMoved,
                                             &bSuccess) &&
                bSuccess) {

                //
                // Upgrade has been completed, delete the registry key.
                //
                if (pKeyName && (pTemp = AllocSplMem(sizeof(struct StringList)))) {
                    pTemp->pKeyName = pKeyName;
                    pTemp->dwVersionIndex = dwVersionIndex;
                    pTemp->pNext = pStart;
                    pStart = pTemp;
                } else {
                    FreeSplMem(pKeyName);
                }

                pKeyName = NULL;
            }
        }
    }

    //
    // Delete the keys for driver that have completed the upgrade.
    //
    while (pTemp = pStart) {
        pStart = pTemp->pNext;

        hVersionKey = NULL;
        if (RestoreVersionKey(hUpgradeKey,
                              pTemp->dwVersionIndex,
                              &hVersionKey)) {

            RegDeleteKey(hVersionKey, pTemp->pKeyName);
            RegCloseKey(hVersionKey);
        }

        FreeSplMem(pTemp->pKeyName);
        FreeSplMem(pTemp);
    }

CleanUp:

    LeaveSplSem();

    if (hUpgradeKey) {
        RegCloseKey(hUpgradeKey);
    }
    if (hRootKey) {
        RegCloseKey(hRootKey);
    }

    CleanUpgradeDirectories();

    return;
}

VOID CleanUpResources(
    LPWSTR              pKeyName,
    LPWSTR              pSplName,
    PDRIVER_INFO_6      pDriverInfo,
    PINTERNAL_DRV_FILE *ppInternalDriverFiles,
    DWORD               dwFileCount)

/*++
Function Description: Frees resources allocated for driver upgrades

Parameters: pKeyName     -  registry key name
            pSplName     -  IniSpooler name
            pDriverInfo  -  driver info 4 pointer
            pInternalDriverFiles - array of INTERNAL_DRV_FILE structures
            dwFileCount          -- number of files in file set

Return Values: NONE
--*/

{
    if (pKeyName) {
        FreeSplStr(pKeyName);
    }
    if (pSplName) {
        FreeSplStr(pSplName);
    }

    FreeDriverInfo6(pDriverInfo);

    CleanupInternalDriverInfo(*ppInternalDriverFiles, dwFileCount);
    *ppInternalDriverFiles = NULL;

    return;
}

BOOL RestoreParametersForUpgrade(
    HKEY     hUpgradeKey,
    DWORD    dwIndex,
    LPWSTR   *pKeyName,
    LPWSTR   *pSplName,
    LPDWORD  pdwLevel,
    LPDWORD  pdwDriverMoved,
    PDRIVER_INFO_6   *ppDriverInfo)

/*++
Function Description: Retrieves the parameters for pending driver upgrades

Parameters: hUpgradeKey     -- Registry key containing the upgrade information
            dwIndex         -- Index to enumerate
            pKeyName        -- pointer to a string containing the key name
            pSplName        -- pIniSpooler->pName
            pdwLevel        -- pointer to the driver_info level
            pdwDriverMoved  -- pointer to the flag indicating if any of the old driver files
                               were moved.
            pDriverInfo     -- pointer to driver_info struct

Return Values: TRUE if some driver has to be upgraded and the
                       parameters can be retrieved;
               FALSE otherwise
--*/

{
    BOOL             bReturn = FALSE;
    LPWSTR           pDriverName = NULL;
    PDRIVER_INFO_6   pDriver6 = NULL;
    DWORD            dwError, dwSize, *pVersion;
    HKEY             hDriverKey = NULL;

    //
    // Initialize pSplName & pKeyName
    //
    *pSplName = NULL;
    *pKeyName = NULL;
    *ppDriverInfo = NULL;

    dwSize = MAX_PATH+1;
    if (!(pDriver6 = AllocSplMem(sizeof(DRIVER_INFO_6))) ||
        !(pDriverName = AllocSplMem(dwSize*sizeof (WCHAR)))) {
        goto CleanUp;
    }

    dwError = RegEnumKeyEx(hUpgradeKey, dwIndex, pDriverName, &dwSize,
                           NULL, NULL, NULL, NULL);

    if (dwError == ERROR_MORE_DATA) {
        //
        // Need a bigger buffer
        //
        FreeSplMem(pDriverName);

        //
        // Make room for last \0
        //
        dwSize++;   
        if (!(pDriverName = AllocSplMem(dwSize*sizeof (WCHAR)))) {
            
            goto CleanUp;
        }

        dwError = RegEnumKeyEx(hUpgradeKey, dwIndex, pDriverName, &dwSize,
                               NULL, NULL, NULL, NULL);
    }

    if (dwError) {
        goto CleanUp;
    }

    if (RegCreateKeyEx(hUpgradeKey, pDriverName,  0,
                       NULL, 0, KEY_READ, NULL, &hDriverKey, NULL) ||

        !RegGetValue(hDriverKey, L"Level", (LPBYTE *)&pdwLevel) ||

        !RegGetValue(hDriverKey, L"DriverMoved", (LPBYTE *)&pdwDriverMoved) ||

        !RegGetValue(hDriverKey, L"SplName", (LPBYTE *)&pSplName)) {

         goto CleanUp;
    }

    switch (*pdwLevel) {
    case 6:

       dwSize = sizeof(FILETIME);

       if (RegQueryValueEx( hDriverKey,
                            L"ftDriverDate",
                            NULL,
                            NULL,
                            (LPBYTE)&pDriver6->ftDriverDate,
                            &dwSize
                            )!=ERROR_SUCCESS) {
           goto CleanUp;
       }

       dwSize = sizeof(DWORDLONG);

       if (RegQueryValueEx( hDriverKey,
                            L"dwlDriverVersion",
                            NULL,
                            NULL,
                            (LPBYTE)&pDriver6->dwlDriverVersion,
                            &dwSize
                            )!=ERROR_SUCCESS){
           goto CleanUp;
       }

       if (!RegGetValue(hDriverKey, L"pszMfgName", (LPBYTE *)&pDriver6->pszMfgName)              ||

           !RegGetValue(hDriverKey, L"pszOEMUrl", (LPBYTE *)&pDriver6->pszOEMUrl)                ||

           !RegGetValue(hDriverKey, L"pszHardwareID", (LPBYTE *)&pDriver6->pszHardwareID)        ||

           !RegGetValue(hDriverKey, L"pszProvider", (LPBYTE *)&pDriver6->pszProvider)
          )
       {
           goto CleanUp;
       }

    case 4:

       if (!RegGetValue(hDriverKey, L"pszzPreviousNames",
                        (LPBYTE *)&pDriver6->pszzPreviousNames)) {
           goto CleanUp;
       }

    case 3:

       if (!RegGetValue(hDriverKey, L"pDefaultDataType",
                        (LPBYTE *)&pDriver6->pDefaultDataType) ||

           !RegGetValue(hDriverKey, L"pMonitorName",
                        (LPBYTE *)&pDriver6->pMonitorName)     ||

           !RegGetValue(hDriverKey, L"pDependentFiles",
                        (LPBYTE *)&pDriver6->pDependentFiles)  ||

           !RegGetValue(hDriverKey, L"pHelpFile",
                        (LPBYTE *)&pDriver6->pHelpFile)) {

           goto CleanUp;
       }

    case 2:

       pVersion = &pDriver6->cVersion;

       if (!RegGetValue(hDriverKey, L"pConfigFile",
                        (LPBYTE *)&pDriver6->pConfigFile)   ||

           !RegGetValue(hDriverKey, L"pDataFile",
                        (LPBYTE *)&pDriver6->pDataFile)     ||

           !RegGetValue(hDriverKey, L"pDriverPath",
                        (LPBYTE *)&pDriver6->pDriverPath)   ||

           !RegGetValue(hDriverKey, L"pName",
                        (LPBYTE *)&pDriver6->pName)         ||

           !RegGetValue(hDriverKey, L"pEnvironment",
                        (LPBYTE *)&pDriver6->pEnvironment)  ||

           !RegGetValue(hDriverKey, L"cVersion",
                        (LPBYTE *)&pVersion)) {

           goto CleanUp;
       }

       break;

    default:
       goto CleanUp;
    }

    *ppDriverInfo = pDriver6;
    *pKeyName = pDriverName;

    pDriver6    = NULL;
    pDriverName = NULL;

    bReturn = TRUE;

CleanUp:

    if (!bReturn) {
        FreeDriverInfo6(pDriver6);

        FreeSplMem(*pSplName);
        *pSplName = NULL;

        FreeSplMem(pDriverName);
    }

    if (hDriverKey) {
        RegCloseKey(hDriverKey);
    }

    return bReturn;
}

VOID FreeDriverInfo6(
    PDRIVER_INFO_6   pDriver6)

/*++
Function Description: Frees a driver_info_6 struct and the strings inside it.

Parameters: pDriver6  -- pointer to the driver_info_6 struct

Return Values: NONE
--*/

{
    if (!pDriver6) {
        return;
    }

    if (pDriver6->pName) {
        FreeSplMem(pDriver6->pName);
    }
    if (pDriver6->pEnvironment) {
        FreeSplMem(pDriver6->pEnvironment);
    }
    if (pDriver6->pDriverPath) {
        FreeSplMem(pDriver6->pDriverPath);
    }
    if (pDriver6->pConfigFile) {
        FreeSplMem(pDriver6->pConfigFile);
    }
    if (pDriver6->pHelpFile) {
        FreeSplMem(pDriver6->pHelpFile);
    }
    if (pDriver6->pDataFile) {
        FreeSplMem(pDriver6->pDataFile);
    }
    if (pDriver6->pDependentFiles) {
        FreeSplMem(pDriver6->pDependentFiles);
    }
    if (pDriver6->pMonitorName) {
        FreeSplMem(pDriver6->pMonitorName);
    }
    if (pDriver6->pDefaultDataType) {
        FreeSplMem(pDriver6->pDefaultDataType);
    }
    if (pDriver6->pszzPreviousNames) {
        FreeSplMem(pDriver6->pszzPreviousNames);
    }
    if (pDriver6->pszMfgName) {
        FreeSplMem(pDriver6->pszMfgName);
    }
    if (pDriver6->pszOEMUrl) {
        FreeSplMem(pDriver6->pszOEMUrl);
    }
    if (pDriver6->pszHardwareID) {
        FreeSplMem(pDriver6->pszHardwareID);
    }
    if (pDriver6->pszProvider) {
        FreeSplMem(pDriver6->pszProvider);
    }

    FreeSplMem(pDriver6);

    return;
}

BOOL RegGetValue(
    HKEY    hDriverKey,
    LPWSTR  pValueName,
    LPBYTE  *pValue)

/*++
Function Description: This function retrieves values from the registry. It allocates the
                      necessary buffers which should be freed later. The value types are
                      DWORD, SZ or MULTI_SZ.

Parameters: hDriverKey      -- handle to the registry key
            pValueName      -- name of the value to be queried
            pValue          -- pointer to pointer to store the result

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL   bReturn = FALSE;
    DWORD  dwError, dwSize = 0, dwType;
    LPBYTE pBuffer = NULL;

    dwError = RegQueryValueEx(hDriverKey, pValueName, NULL, NULL, NULL, &dwSize);

    if ((dwError == ERROR_SUCCESS) && (pBuffer = AllocSplMem(dwSize))) {

        if (dwError = RegQueryValueEx(hDriverKey, pValueName,
                                      NULL, &dwType, pBuffer, &dwSize)) {

            goto CleanUp;
        }

    } else {

        goto CleanUp;
    }

    if (dwType == REG_DWORD) {
        //
        // Store DWORD values directly in the location.
        //
        *((LPDWORD)*pValue) = *((LPDWORD)pBuffer);
        FreeSplMem(pBuffer);
        pBuffer = NULL;
    } else {
        //
        // Return pointers for strings and MultiSz strings.
        //
        *((LPBYTE *)pValue) = pBuffer;
    }

    bReturn = TRUE;

CleanUp:

    if (!bReturn && pBuffer) {
        FreeSplMem(pBuffer);
    }

    return bReturn;
}

DWORD GetDriverFileVersion(
     PINIVERSION      pIniVersion,
     LPWSTR           pFileName)

/*++
Function Description: Retrieves the version number of the file

Parameters:   pIniVersion  -- pointer to PINIVERSION
              pFileName    -- file name

Return Values: file version number
--*/

{
    PDRVREFCNT pdrc;
    DWORD      dwReturn = 0;

    SplInSem();

    if (!pIniVersion || !pFileName || !(*pFileName)) {
        return dwReturn;
    }

    for (pdrc = pIniVersion->pDrvRefCnt;
         pdrc;
         pdrc = pdrc->pNext) {

         if (lstrcmpi(pFileName,pdrc->szDrvFileName) == 0) {
             dwReturn = pdrc->dwVersion;
             break;
         }
    }

    return dwReturn;
}

BOOL GetDriverFileCachedVersion(
     IN     PINIVERSION      pIniVersion,
     IN     LPCWSTR          pFileName,
     OUT    DWORD            *pFileVersion
)
/*++

Routine Name:

    GetDriverFileCachedVersion

Routine Description:

    This routine returns a file's minor version.
    The file must be an executable( file name ended in .DLL or .EXE )
    pIniVersion keeps a linked list with information about all driver files.
    To avoid service start up delays, the entries in this list aren't initialized
    when Spooler starts. GetPrintDriverVersion loads the executable's data segment
    and this will increase Spooler initialization time.
    If the cache entry isn't initialized, call GetPrintDriverVersion and initialize it.
    Else, return cached information.
    When pIniVersion is NULL, just call GetPrintDriverVersion.

Arguments:

    pIniVersion - pointer to PINIVERSION structure. Can be NULL.
    pFileName   - file name
    pFileVersion - retrieve cached file version
    VersionType - specifies which version to return

Return Value:

    TRUE file version was successfully returned.

--*/
{
    PDRVREFCNT pdrc;
    BOOL       bRetValue = FALSE;
    BOOL       bFound = FALSE;

    SplInSem();

    if (pFileVersion && pFileName && *pFileName)
    {
        *pFileVersion = 0;
        //
        // Don't do anything for non-executable files
        //
        if (!IsEXEFile(pFileName))
        {
            bRetValue = TRUE;
        }
        else
        {
            //
            // If pIniVersion is NULL, then we cannot access cached information.
            // This code path was written for calls from SplCopyNumberOfFiles(files.c)
            //
            if (!pIniVersion)
            {
                bRetValue = GetPrintDriverVersion(pFileName,
                                                  NULL,
                                                  pFileVersion);
            }
            else
            {
                //
                // Search the entry in pIniVersion's list of files
                //
                for (pdrc = pIniVersion->pDrvRefCnt;
                     pdrc;
                     pdrc = pdrc->pNext)
                {
                     LPCWSTR     pFile = FindFileName(pFileName);

                     if (pFile && lstrcmpi(pFile, pdrc->szDrvFileName) == 0)
                     {
                         //
                         // Return cached information.
                         //
                         if(pdrc->bInitialized)
                         {
                             *pFileVersion  = pdrc->dwFileMinorVersion;
                             bRetValue      = TRUE;
                         }
                         else if (GetPrintDriverVersion(pFileName,
                                                        &pdrc->dwFileMajorVersion,
                                                        &pdrc->dwFileMinorVersion))
                         {
                            //
                            // Mark the entry as initialized so next time we don't have
                            // to do the work of calling GetPrintDriverVersion.
                            //
                            pdrc->bInitialized  = TRUE;
                            *pFileVersion       = pdrc->dwFileMinorVersion;
                            bRetValue           = TRUE;
                         }

                         //
                         // Break the loop when file found.
                         //
                         bFound = TRUE;
                         break;
                     }
                }
            }
        }
    }

    if (!bFound)
    {
        bRetValue = TRUE;
    }

    return bRetValue;
}

VOID IncrementFileVersion(
    PINIVERSION      pIniVersion,
    LPCWSTR           pFileName)

/*++
Function Description: Increments the version number of the file.

Parameters:   pIniVersion  -- pointer to PINIVERSION
              pFileName    -- file name

Return Values: NONE
--*/

{
    PDRVREFCNT pdrc;

    SplInSem();

    if (!pIniVersion || !pFileName || !(*pFileName)) {
        return;
    }

    for (pdrc = pIniVersion->pDrvRefCnt;
         pdrc;
         pdrc = pdrc->pNext) {

         if (lstrcmpi(pFileName,pdrc->szDrvFileName) == 0) {
             pdrc->dwVersion++;
             break;
         }
    }

    return;
}

BOOL
CompleteDriverUpgrade(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN      PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      DWORD               dwTempDir,
    IN      BOOL                bDriverMoved,
    IN      BOOL                bDriverFileMoved,
    IN      BOOL                bConfigFileMoved
    )
/*++
Function Description: This functions updates the INIDRIVER struct and calls DrvUpgradePrinter
                      and DrvDriverEvent. An event for adding printer drivers is logged.

Parameters:   pIniSpooler          -- pointer to INISPOOLER
              pIniEnvironment      -- pointer to INIENVIRONMENT
              pIniVersion          -- pointer to INIVERSION
              pIniDriver           -- pointer to INIDRIVER
              dwLevel              -- driver_info level
              pDriverInfo          -- pointer to driver_info
              dwFileCopyFlags      -- AddPrinterDriver file copy flags.
              pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
              dwFileCount          -- number of files in file set
              dwVersion            -- driver version
              dwTempDir            -- temp directory number for loaded drivers
              bDriverMoved         -- Were any files moved to the Old directory ?
              bDriverFileMoved     -- driver file moved ?
              bConfigFileMoved     -- config file moved ?

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    WCHAR    szDirectory[MAX_PATH];
    LPWSTR   pOldDir, pTemp, pEnvironment = szEnvironment;
    LPBYTE   pDriver4 = NULL, pUpgradeInfo2 = NULL;
    DWORD    cbBuf;

    PINIMONITOR  pIniLangMonitor = NULL;
    PINISPOOLER  pTempIniSpooler, pIniNextSpooler;
    PINIDRIVER   pTempIniDriver = NULL;
    PINIPRINTER  pFixUpIniPrinter;
    PINIVERSION  pTempIniVersion;
    LPDRIVER_INFO_4  pDrvInfo4 = NULL;
    BOOL         bUpdatePrinters = FALSE;

    //
    // Save the driver_info_4 struct for the old driver. This is passed to the
    // DrvUpgradePrinter call.
    //
    if (pIniDriver && bDriverMoved) {

        cbBuf = GetDriverInfoSize(pIniDriver, 4, pIniVersion, pIniEnvironment,
                                  NULL, pIniSpooler);

        if (pDriver4 = (LPBYTE) AllocSplMem(cbBuf)) {

            pUpgradeInfo2 = CopyIniDriverToDriverInfo(pIniEnvironment, pIniVersion,
                                                      pIniDriver, 4, pDriver4,
                                                      pDriver4 + cbBuf, NULL, pIniSpooler);
        }
    }
    //
    // Update or create the driver INI structure.
    //
    pIniDriver = CreateDriverEntry(pIniEnvironment,
                                   pIniVersion,
                                   dwLevel,
                                   pDriverInfo,
                                   dwFileCopyFlags,
                                   pIniSpooler,
                                   pInternalDriverFiles,
                                   dwFileCount,
                                   dwTempDir,
                                   pIniDriver);
    //
    // Fail the call if pIniDriver failed
    //
    if (pIniDriver == NULL) {
        return FALSE;
    }

    //
    // Increment version numbers
    //
    if (bDriverFileMoved) {
        IncrementFileVersion(pIniVersion, FindFileName(pInternalDriverFiles[0].pFileName));
    }
    if (bConfigFileMoved) {
        IncrementFileVersion(pIniVersion, FindFileName(pInternalDriverFiles[1].pFileName));
    }

    pDrvInfo4 = (LPDRIVER_INFO_4) pDriverInfo;

    if (pDrvInfo4->pEnvironment &&
        *pDrvInfo4->pEnvironment) {

        pEnvironment = pDrvInfo4->pEnvironment;
    }

    if ((dwLevel == 3 || dwLevel == 4 || dwLevel ==6) &&
        pDrvInfo4->pMonitorName &&
        *pDrvInfo4->pMonitorName &&
        _wcsicmp(pEnvironment, szWin95Environment)) {

        pIniLangMonitor = FindMonitor(pDrvInfo4->pMonitorName,
                                      pLocalIniSpooler);
    }

    if (pIniLangMonitor &&
        pIniDriver->pIniLangMonitor != pIniLangMonitor) {

        if (pIniDriver->pIniLangMonitor)
            pIniDriver->pIniLangMonitor->cRef--;

        if (pIniLangMonitor)
            pIniLangMonitor->cRef++;

        pIniDriver->pIniLangMonitor = pIniLangMonitor;
    }
    //
    // Increment cRefs for leaving SplSem
    //
    INCSPOOLERREF( pIniSpooler );
    INCDRIVERREF( pIniDriver );
    pIniEnvironment->cRef++;
    //
    // Call DrvDriverEvent in the Driver. Environment and version checks are
    // done inside NotifyDriver.
    NotifyDriver(pIniSpooler,
                 pIniEnvironment,
                 pIniVersion,
                 pIniDriver,
                 DRIVER_EVENT_INITIALIZE,
                 0);

    bUpdatePrinters = DriverAddedOrUpgraded(pInternalDriverFiles, dwFileCount);

    //
    // Call DrvUprgadePrinter if the driver added belongs to this version
    // and environment. And the pIniSpooler is not a cluster spooler
    //
    if (!(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) &&
        pThisEnvironment == pIniEnvironment) {
        //
        // Walk through all pIniSpoolers that print.
        //
        INCSPOOLERREF( pLocalIniSpooler );

        for( pTempIniSpooler = pLocalIniSpooler;
             pTempIniSpooler;
             pTempIniSpooler = pIniNextSpooler ){

            //
            // Do not touch the driver belonging to cluster spoolers. Cluster spoolers
            // handle thier drivers themselves
            //
             if (pTempIniSpooler->SpoolerFlags & SPL_PRINT && !(pTempIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER)){
                //
                // Walk all the printers and see if anyone is using this driver.
                //
                for ( pFixUpIniPrinter = pTempIniSpooler->pIniPrinter;
                      pFixUpIniPrinter != NULL;
                      pFixUpIniPrinter = pFixUpIniPrinter->pNext ) {
                    //
                    //  Does this Printer Have this driver ?
                    //
                    if ( lstrcmpi( pFixUpIniPrinter->pIniDriver->pName,
                                   pIniDriver->pName ) == STRINGS_ARE_EQUAL ) {

                        pTempIniDriver = FindCompatibleDriver( pIniEnvironment,
                                                               &pTempIniVersion,
                                                               pIniDriver->pName,
                                                               dwVersion,
                                                               FIND_COMPATIBLE_VERSION | DRIVER_UPGRADE);

                        SPLASSERT(pTempIniDriver != NULL);

                        //
                        // Does this Printer Has a Newer Driver it should be using ?
                        // Note: within the same version, pIniPrinter->pIniDriver
                        // does not change (the fields are updated in an upgrade,
                        // but the same pIniDriver is used).
                        //
                        // Version 2 is not compatible with anything else,
                        // so the pIniDrivers won't change in SUR.
                        //
                        if ( pTempIniDriver != pFixUpIniPrinter->pIniDriver ) {

                            DECDRIVERREF( pFixUpIniPrinter->pIniDriver );

                            pFixUpIniPrinter->pIniDriver = pTempIniDriver;

                            INCDRIVERREF( pFixUpIniPrinter->pIniDriver );
                        }
                    }
                }

                pOldDir = NULL;

                if ( !bDriverMoved ) {
                    //
                    // Use older version of the driver
                    //
                    pTempIniDriver = FindCompatibleDriver( pIniEnvironment,
                                                           &pTempIniVersion,
                                                           pIniDriver->pName,
                                                           (dwVersion>2)?(dwVersion - 1):dwVersion,
                                                           FIND_ANY_VERSION | DRIVER_UPGRADE);

                    if ( pTempIniDriver != NULL ) {

                        SPLASSERT( pTempIniVersion != NULL );


                        GetDriverVersionDirectory( szDirectory,
                                                   COUNTOF(szDirectory),
                                                   pIniSpooler,
                                                   pThisEnvironment,
                                                   pTempIniVersion,
                                                   pTempIniDriver,
                                                   NULL );

                        if ( DirectoryExists( szDirectory )) {

                            pOldDir = (LPWSTR) szDirectory;
                        }

                        cbBuf = GetDriverInfoSize(pTempIniDriver, 4, pTempIniVersion,
                                                  pIniEnvironment, NULL, pIniSpooler);

                        if (pDriver4 = (LPBYTE) AllocSplMem(cbBuf)) {

                            pUpgradeInfo2 = CopyIniDriverToDriverInfo(pIniEnvironment,
                                                                      pTempIniVersion,
                                                                      pTempIniDriver,
                                                                      4,
                                                                      pDriver4,
                                                                      pDriver4 + cbBuf,
                                                                      NULL,
                                                                      pIniSpooler);
                        }
                    }

                } else {

                    if((StrNCatBuff(szDirectory,
                                    MAX_PATH,
                                    pIniSpooler->pDir,
                                    L"\\drivers\\",
                                    pIniEnvironment->pDirectory,
                                    L"\\",
                                    pIniVersion->szDirectory,
                                    L"\\Old",
                                    NULL) == ERROR_SUCCESS))
                    {
                        pOldDir = (LPWSTR) szDirectory;
                    }
                    else
                    {
                       //
                       // Ignore error.  
                       //
                    }

                }

                INCDRIVERREF(pIniDriver);
                if( bUpdatePrinters) {
                    ForEachPrinterCallDriverDrvUpgrade(pTempIniSpooler,
                                                       pIniDriver,
                                                       pOldDir,
                                                       pInternalDriverFiles,
                                                       dwFileCount,
                                                       pUpgradeInfo2 ? pDriver4
                                                                     : NULL);
                }
                DECDRIVERREF(pIniDriver);
            }
            pIniNextSpooler = pTempIniSpooler->pIniNextSpooler;

            if ( pIniNextSpooler ) {
                INCSPOOLERREF( pIniNextSpooler );
            }
            DECSPOOLERREF( pTempIniSpooler );
        }
    }

    //
    // Perform driver upgrade if the pIniSpooler is a cluster spooler
    //
    if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
        !lstrcmpi(pIniEnvironment->pName, szEnvironment)) {

        DBGMSG(DBG_CLUSTER, ("CompleteDriverUpgrade searching for cluster spooler printers\n"));

        //
        // Walk all the printers and see if anyone is using this driver.
        //
        for ( pFixUpIniPrinter = pIniSpooler->pIniPrinter;
              pFixUpIniPrinter != NULL;
              pFixUpIniPrinter = pFixUpIniPrinter->pNext )
        {
            //
            //  Does this Printer Have this driver ?
            //
            if (lstrcmpi(pFixUpIniPrinter->pIniDriver->pName, pIniDriver->pName) == STRINGS_ARE_EQUAL)
            {
                pTempIniDriver = FindCompatibleDriver(pIniEnvironment,
                                                      &pTempIniVersion,
                                                      pIniDriver->pName,
                                                      dwVersion,
                                                      FIND_COMPATIBLE_VERSION | DRIVER_UPGRADE);

                SPLASSERT( pTempIniDriver != NULL );

                //
                // Does this Printer Has a Newer Driver it should be using ?
                // Note: within the same version, pIniPrinter->pIniDriver
                // does not change (the fields are updated in an upgrade,
                // but the same pIniDriver is used).
                //
                // Version 2 is not compatible with anything else,
                // so the pIniDrivers won't change in SUR.
                //

                if ( pTempIniDriver != pFixUpIniPrinter->pIniDriver )
                {
                    DECDRIVERREF( pFixUpIniPrinter->pIniDriver );

                    pFixUpIniPrinter->pIniDriver = pTempIniDriver;

                    INCDRIVERREF( pFixUpIniPrinter->pIniDriver );
                }
            }
        }

        pOldDir = NULL;

        if ( !bDriverMoved )
        {
            //
            // Use older version of the driver
            //
            pTempIniDriver = FindCompatibleDriver( pIniEnvironment,
                                                   &pTempIniVersion,
                                                   pIniDriver->pName,
                                                   (dwVersion>2)?(dwVersion - 1):dwVersion,
                                                   FIND_ANY_VERSION | DRIVER_UPGRADE);

            if ( pTempIniDriver != NULL )
            {
                SPLASSERT( pTempIniVersion != NULL );

                GetDriverVersionDirectory( szDirectory,
                                           COUNTOF(szDirectory),
                                           pIniSpooler,
                                           pIniEnvironment,
                                           pTempIniVersion,
                                           pTempIniDriver,
                                           NULL );

                if ( DirectoryExists( szDirectory ))
                {
                    pOldDir = (LPWSTR) szDirectory;
                }

                cbBuf = GetDriverInfoSize(pTempIniDriver, 4, pTempIniVersion, pIniEnvironment, NULL, pIniSpooler);

                if (pDriver4 = (LPBYTE) AllocSplMem(cbBuf))
                {
                    pUpgradeInfo2 = CopyIniDriverToDriverInfo(pIniEnvironment,
                                                              pTempIniVersion,
                                                              pTempIniDriver,
                                                              4,
                                                              pDriver4,
                                                              pDriver4 + cbBuf,
                                                              NULL,
                                                              pIniSpooler);
                }
            }
            else
            {
                if((StrNCatBuff(szDirectory,
                                MAX_PATH,
                                pIniSpooler->pDir,
                                L"\\drivers\\",
                                pIniEnvironment->pDirectory,
                                L"\\",
                                pIniVersion->szDirectory,
                                L"\\Old",
                                NULL) == ERROR_SUCCESS))
                {
                    pOldDir = (LPWSTR) szDirectory;
                }
            }

            INCDRIVERREF(pIniDriver);
            if( bUpdatePrinters)
            {
                ForEachPrinterCallDriverDrvUpgrade(pIniSpooler,
                                                   pIniDriver,
                                                   pOldDir,
                                                   pInternalDriverFiles,
                                                   dwFileCount,
                                                   pUpgradeInfo2 ? pDriver4 : NULL);
            }

            DECDRIVERREF(pIniDriver);
        }
    }



    if (pDriver4) {
        FreeSplMem(pDriver4);
        pDriver4 = NULL;
    }

    //
    //  Log Event - Successfully adding the printer driver.
    //
    //  Note we use pLocalIniSpooler here because drivers are currently
    //  global accross all spoolers and we always want it logged
    //
    pTemp = BuildFilesCopiedAsAString(pInternalDriverFiles, dwFileCount);

    SplLogEvent(pLocalIniSpooler,
                LOG_WARNING,
                MSG_DRIVER_ADDED,
                TRUE,
                pIniDriver->pName,
                pIniEnvironment->pName,
                pIniVersion->pName,
                pTemp,
                NULL);

    FreeSplMem(pTemp);
    //
    // Decrement cRefs after reentering SplSem
    //
    DECSPOOLERREF( pIniSpooler );
    DECDRIVERREF( pIniDriver );
    pIniEnvironment->cRef--;

    SetPrinterChange(NULL,
                     NULL,
                     NULL,
                     PRINTER_CHANGE_ADD_PRINTER_DRIVER,
                     pLocalIniSpooler );

    return TRUE;
}

VOID CleanUpgradeDirectories()

/*++
Function Description:  Deletes the Old and New directories if there are
                       no pending driver upgrades.

Parameters: NONE

Return Values: NONE
--*/

{
    DWORD            dwError, dwSize, dwVersionIndex;
    BOOL             bPendingUpgrade = FALSE;
    HKEY             hRootKey = NULL, hUpgradeKey = NULL, hVersionKey = NULL;
    WCHAR            pDriverDir[MAX_PATH], pCleanupDir[MAX_PATH];
    PINIENVIRONMENT  pIniEnvironment        = NULL;
    PINIENVIRONMENT  pIniEnvironmentNext    = NULL;
    PINISPOOLER      pIniSpooler            = NULL;
    PINISPOOLER      pIniSpoolerNext        = NULL;
    PINIVERSION      pIniVersion            = NULL;

    //
    // This should always be called outside the CS, check that we are OK.
    //
    SplOutSem();

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryRoot, 0,
                       NULL, 0, KEY_READ | DELETE, NULL, &hRootKey, NULL) ||

        RegCreateKeyEx(hRootKey, szPendingUpgrades, 0,
                       NULL, 0, KEY_READ | DELETE, NULL, &hUpgradeKey, NULL)) {

         goto CleanUp;
    }

    //
    // Loop thru the version entries
    //
    for (dwVersionIndex = 0, hVersionKey = NULL;

         RestoreVersionKey(hUpgradeKey, dwVersionIndex, &hVersionKey);

         RegCloseKey(hVersionKey), hVersionKey = NULL, ++dwVersionIndex) {

        // Search for pending upgrade keys
        dwSize = MAX_PATH;
        dwError = RegEnumKeyEx(hVersionKey, 0, pDriverDir, &dwSize,
                               NULL, NULL, NULL, NULL);

        if (dwError != ERROR_NO_MORE_ITEMS) {
            bPendingUpgrade = TRUE;
            break;
        }
    }

    EnterSplSem();

    // If there aren't any pending driver upgrades, delete the Old and
    // new directories and the files within.
    if ( pLocalIniSpooler) {

        INCSPOOLERREF(pLocalIniSpooler);

        for (pIniSpooler = pLocalIniSpooler;
             pIniSpooler;
             pIniSpooler = pIniSpoolerNext) {

            if (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ||
                pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) {

                //
                // This is a little bogus, since environment reference counts
                // aren't needed, but for consistency with the pIniSpooler code
                // and in case someone actually uses this. I have the ref count
                // correctly.
                //
                if (pIniSpooler->pIniEnvironment) {

                    pIniSpooler->pIniEnvironment->cRef++;
                }

                for (pIniEnvironment = pIniSpooler->pIniEnvironment;
                     pIniEnvironment;
                     pIniEnvironment = pIniEnvironmentNext) {

                    for (pIniVersion = pIniEnvironment->pIniVersion;
                         pIniVersion;
                         pIniVersion = pIniVersion->pNext) {

                        dwError = StrNCatBuff(pDriverDir,
                                              COUNTOF(pDriverDir),
                                              pIniSpooler->pDir,
                                              L"\\drivers\\",
                                              pIniEnvironment->pDirectory,
                                              L"\\",
                                              pIniVersion->szDirectory,
                                              NULL);

                        //
                        // The rest of these operations do not depend on private
                        // data held in the inispooler.
                        //
                        LeaveSplSem();

                        SplOutSem();

                        if (dwError == ERROR_SUCCESS) {

                            dwError = StrNCatBuff(pCleanupDir,
                                                  COUNTOF(pCleanupDir),
                                                  pDriverDir,
                                                  L"\\Old",
                                                  NULL);
                        }

                        if (dwError == ERROR_SUCCESS) {

                            DeleteDirectoryRecursively(pCleanupDir, FALSE);

                            dwError = StrNCatBuff(pCleanupDir,
                                                  COUNTOF(pCleanupDir),
                                                  pDriverDir,
                                                  L"\\New",
                                                  NULL);
                        }

                        if (dwError == ERROR_SUCCESS && !bPendingUpgrade) {

                            DeleteAllFilesAndDirectory(pCleanupDir, FALSE);
                        }

                        EnterSplSem();
                    }

                    SplInSem();

                    pIniEnvironmentNext = pIniEnvironment->pNext;

                    if (pIniEnvironmentNext) {

                        pIniEnvironmentNext->cRef++;
                    }

                    pIniEnvironment->cRef--;
                }
            }

            SplInSem();

            pIniSpoolerNext = pIniSpooler->pIniNextSpooler;

            if (pIniSpoolerNext) {

                INCSPOOLERREF(pIniSpoolerNext);
            }

            //
            // This can result in the pIniSpooler being deleted, which is why we have the stuff
            // with pIniSpooler next on the previous line.
            //
            DECSPOOLERREF(pIniSpooler);
        }
    }

    LeaveSplSem();

CleanUp:

    SplOutSem();

    if (hVersionKey) {
        RegCloseKey(hVersionKey);
    }

    if (hUpgradeKey) {
        RegCloseKey(hUpgradeKey);
    }

    if (hRootKey) {
        RegCloseKey(hRootKey);
    }
}

BOOL
CheckFileCopyOptions(
    PINIENVIRONMENT     pIniEnvironment,
    PINIVERSION         pIniVersion,
    PINIDRIVER          pIniDriver,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    DWORD               dwFileCopyFlags,
    LPBOOL              pbSucceeded
    )

/*++

Function Description:

    CheckFileCopyOptions examines the timestamps of the source and
    target files and determines if strict upgrade/downgrade can fail.

Parameters:

    pIniEnvironment      - pointer to a PINIENVIRONMENT structure
    pIniVersion          - pointer to a PINIVERSION structure
    pIniDriver           - pointer to the old INIDRIVER structure
    pInternalDriverFiles - array of INTERNAL_DRV_FILE structures
    dwFileCount          - number of files in file set
    dwFileCopyFlags      - file copying options.
    pbSucceeded          - flag to indicate the AddPrinterDriver call succeeded.

Return Values:

    TRUE - We need to copy any files.  *pbSucceeded is unchanged.

    FALSE - We don't need to copy, either because the entire call failed
        (e.g., strict upgrade but older source files), or because we don't
        need to do anything.  *pbSucceeded indicates if the API call should
        succeed (the latter case).

--*/

{
    BOOL            bReturn = FALSE, bInSem = TRUE, bSameMainDriverName = FALSE;
    LPWSTR          pDrvDestDir = NULL, pICMDestDir = NULL, pNewDestDir = NULL;
    LPWSTR          pTargetFileName = NULL, pFileName;
    DWORD           dwCount;
    WIN32_FIND_DATA DestFileData, SourceFileData;
    HANDLE          hFileExists;
    DWORD           TimeStampComparison;
    enum { Equal, Newer, Older } DriverComparison;
    DWORD           dwDriverVersion;


    if (!pbSucceeded) {
        goto CleanUp;
    }

    *pbSucceeded = FALSE;

    SplInSem();

    switch (dwFileCopyFlags) {

    case APD_COPY_ALL_FILES:
        //
        // Nothing to check
        //
        bReturn = TRUE;
        break;

    case APD_COPY_NEW_FILES:
        //
        // Check if the driver file sets are different
        //
        if (pIniDriver)
        {
            pFileName = wcsrchr(pInternalDriverFiles[0].pFileName, L'\\');
            if (pFileName && pIniDriver->pDriverFile &&
                !_wcsicmp(pFileName+1, pIniDriver->pDriverFile))
            {
                bSameMainDriverName = TRUE;
            }
        }

    case APD_STRICT_UPGRADE:
    case APD_STRICT_DOWNGRADE:
        //
        // Set up the destination directories
        //
        if (!(pDrvDestDir = AllocSplMem((INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1) * sizeof(WCHAR))) ||
            !(pTargetFileName = AllocSplMem((INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1) * sizeof(WCHAR)))) {

             goto CleanUp;
        }
        //
        // Regular driver directory
        //
        if( !GetEnvironmentScratchDirectory( pDrvDestDir, MAX_PATH, pIniEnvironment, FALSE ) ) {

            goto CleanUp;
        }

        if (!BoolFromHResult(StringCchCat(pDrvDestDir, INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1, L"\\")) ||
            !BoolFromHResult(StringCchCat(pDrvDestDir, INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1, pIniVersion->szDirectory))) {

            goto CleanUp;
        }

        //
        // New driver files directory where files may be stored temporarily
        //
        if (!BoolFromStatus(StrCatAlloc(&pNewDestDir, pDrvDestDir, L"\\New", NULL))) {

            goto CleanUp;
        }

        if (!wcscmp(pIniEnvironment->pName, szWin95Environment)) {

           if (!BoolFromStatus(StrCatAlloc(&pICMDestDir, pDrvDestDir, L"\\Color", NULL))){

               goto CleanUp;
           }
        }

        if (pIniDriver) {
            INCDRIVERREF(pIniDriver);
        }
        LeaveSplSem();
        bInSem = FALSE;
        //
        // Examine the timestamps for the source and the target files.
        //
        for (dwCount = 0; dwCount < dwFileCount; ++dwCount) {
            //
            // Get Source File Date & Time Stamp
            //
            hFileExists = FindFirstFile(pInternalDriverFiles[dwCount].pFileName, &SourceFileData );

            if (hFileExists == INVALID_HANDLE_VALUE) {
                goto CleanUp;
            } else {
                FindClose(hFileExists);
            }

            if (!(pFileName = wcsrchr(pInternalDriverFiles[dwCount].pFileName, L'\\'))) {
                goto CleanUp;
            }

            //
            // Skip past the backslash.
            //
            ++pFileName;

            if (pICMDestDir && IsAnICMFile(pInternalDriverFiles[dwCount].pFileName)) {

                //
                // Check in the Color Directory
                //
                StringCchPrintf(pTargetFileName, INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1, L"%ws\\%ws", pICMDestDir, pFileName);

                hFileExists = FindFirstFile(pTargetFileName, &DestFileData);

            } else {

                LPWSTR pszTestFileName;

                if ((dwCount == 0) && !bSameMainDriverName && pIniDriver) {

                    //
                    // We're processing the main driver file.  The server's
                    // file doesn't exist on the client, but the client does
                    // have a version of this driver.
                    //
                    // Instead of checking the server's file name on the
                    // client, we want to check the client's IniDriver->pDriver
                    // to see which is newer.
                    //
                    // For example, server has rasdd, while client has unidrv.
                    // Client does not have rasdd, so we would normally copy
                    // rasdd down to the client and change the DRIVER_INFO.
                    //
                    // Instead, we want to see if the server's unidrv is
                    // newer than the client's rasdd.  If so, then we
                    // need to upgrade.
                    //
                    // Even if the client did have a new unidrv (even a
                    // really new one), we still want to upgrade the
                    // client's DRIVER_INFO.
                    //
                    pszTestFileName = pIniDriver->pDriverFile;

                } else {

                    pszTestFileName = pFileName;
                }
                //
                // Check in the new directory first
                //
                StringCchPrintf(pTargetFileName, INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1, L"%ws\\%ws", pNewDestDir, pszTestFileName);

                hFileExists = FindFirstFile(pTargetFileName, &DestFileData);

                if (hFileExists == INVALID_HANDLE_VALUE) {
                    //
                    // Check in the regular driver directory
                    //
                    StringCchPrintf(pTargetFileName, INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1, L"%ws\\%ws", pDrvDestDir, pszTestFileName);

                    hFileExists = FindFirstFile(pTargetFileName, &DestFileData);
                }
            }

            if (hFileExists != INVALID_HANDLE_VALUE) {

               FindClose(hFileExists);

               EnterSplSem();
               if (pIniDriver) {
                   DECDRIVERREF(pIniDriver);
               }
               bInSem = TRUE;

               if (!GetDriverFileCachedVersion(pIniVersion, pTargetFileName, &dwDriverVersion)) {
                   SetLastError(ERROR_CAN_NOT_COMPLETE);
                   goto CleanUp;
               }

               if (pIniDriver) {
                   INCDRIVERREF(pIniDriver);
               }
               LeaveSplSem();
               bInSem = FALSE;

               DriverComparison = pInternalDriverFiles[dwCount].dwVersion == dwDriverVersion ?
                                      Equal :
                                      pInternalDriverFiles[dwCount].dwVersion > dwDriverVersion ?
                                          Newer :
                                          Older;

               if (DriverComparison == Equal) {

                   TimeStampComparison = CompareFileTime( &SourceFileData.ftLastWriteTime,
                                                          &DestFileData.ftLastWriteTime );

                   DriverComparison = TimeStampComparison == 1 ?
                                          Newer :
                                          TimeStampComparison == -1 ?
                                              Older :
                                              Equal;
               }

               switch (DriverComparison) {

               case Newer:
                  //
                  // Source file newer than the target. Strict downgrade will fail.
                  //
                  if (dwFileCopyFlags == APD_STRICT_DOWNGRADE) {
                      SetLastError(ERROR_CAN_NOT_COMPLETE);
                      goto CleanUp;
                  }
                  break;

               case Older:
                  //
                  // Target file newer than the source. Strict upgrade will fail.
                  //
                  if (dwFileCopyFlags == APD_STRICT_UPGRADE) {
                      SetLastError(ERROR_CAN_NOT_COMPLETE);
                      goto CleanUp;
                  } else {

                      //
                      // If we are doing a copy new files (non-strict upgrade),
                      // and the main driver files are different, and
                      // the driver is already installed, then we want to use
                      // the existing driver.
                      //
                      if ((dwFileCopyFlags == APD_COPY_NEW_FILES) &&
                          (dwCount == 0) && !bSameMainDriverName &&
                          pIniDriver)
                      {
                          *pbSucceeded = TRUE;
                          goto CleanUp;
                      }
                  }
                  break;

               default:
                  //
                  // file times are the same
                  //
                  break;
               }
            }
        }

        bReturn = TRUE;
        break;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        break;
    }

CleanUp:

    if (!bInSem) {
        EnterSplSem();
        if (pIniDriver) {
            DECDRIVERREF(pIniDriver);
        }
    }
    if (pDrvDestDir) {
        FreeSplMem(pDrvDestDir);
    }
    if (pTargetFileName) {
        FreeSplMem(pTargetFileName);
    }
    if (pICMDestDir) {
        FreeSplMem(pICMDestDir);
    }
    if (pNewDestDir) {
        FreeSplMem(pNewDestDir);
    }

    return bReturn;
}

BOOL
LocalDeletePrinterDriver(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName
    )
{

    BOOL bReturn;
    bReturn = LocalDeletePrinterDriverEx( pName,
                                          pEnvironment,
                                          pDriverName,
                                          0,
                                          0);

    return bReturn;
}

BOOL
LocalDeletePrinterDriverEx(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName,
    DWORD    dwDeleteFlag,
    DWORD    dwVersionNum
    )
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplDeletePrinterDriverEx( pName,
                                        pEnvironment,
                                        pDriverName,
                                        pIniSpooler,
                                        dwDeleteFlag,
                                        dwVersionNum);

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}

BOOL
SplDeletePrinterDriverEx(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName,
    PINISPOOLER pIniSpooler,
    DWORD    dwDeleteFlag,
    DWORD    dwVersionNum
    )
/*++

Function Description: Deletes specific or all versions of a printer driver. Removes unused
                      or all files associated with the driver.

Parameters: pName - name of the server. NULL implies local machine.
            pEnvironment - string containing the environment of the driver to be deleted.
                           NULL implies use local environment.
            pDriverName - string containing the name of the driver.
            pIniSpooler - Pointer to INISPOOLER struct.
            dwDeleteFlag - combination of DPD_DELETE_SPECIFIC_VERSION and
                            DPD_DELETE_UNUSED_FILES or DPD_DELETE_ALL_FILES. The defaults
                            are delete all versions and dont delete the files.
            dwVersionNum - version number (0-3) of the driver. Used only if dwDeleteFlag
                           contains DPD_DELETE_SPECIFIC_VERSION.

Return Values: TRUE if deleted.
               FALSE otherwise.

--*/
{
    PINIENVIRONMENT pIniEnvironment;
    PINIVERSION pIniVersion;
    PINIDRIVER  pIniDriver;
    BOOL        bRefCount = FALSE,bEnteredSplSem = FALSE,bReturn = TRUE;
    BOOL        bFileRefCount = FALSE;
    BOOL        bThisVersion,bSetPrinterChange = FALSE;
    BOOL        bFoundDriver = FALSE, bSpecificVersionDeleted = FALSE;
    LPWSTR      pIndex;
    WCHAR       szDirectory[MAX_PATH];
    HANDLE      hImpersonationToken;
    DWORD       dwRet;


    DBGMSG(DBG_TRACE, ("DeletePrinterDriverEx\n"));
    //
    // Check if the call is for the local machine.
    //
    if ( pName && *pName ) {
        if ( !MyName( pName, pIniSpooler )) {
            bReturn = FALSE;
            goto CleanUp;
        }
    }
    //
    // Invalid Input and Access Checks
    //
    if ( !pDriverName || !*pDriverName ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        bReturn = FALSE;
        goto CleanUp;
    }

    if (dwDeleteFlag & ~(DPD_DELETE_SPECIFIC_VERSION
                         | DPD_DELETE_ALL_FILES
                         | DPD_DELETE_UNUSED_FILES)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        bReturn = FALSE;
        goto CleanUp;
    }

    if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                SERVER_ACCESS_ADMINISTER,
                                NULL, NULL, pIniSpooler )) {
       bReturn = FALSE;
       goto CleanUp;
    }

   EnterSplSem();
   bEnteredSplSem = TRUE;

    pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler);

    if ( !pIniEnvironment ) {
        SetLastError(ERROR_INVALID_ENVIRONMENT);
        bReturn = FALSE;
        goto CleanUp;
    }
    pIniVersion = pIniEnvironment->pIniVersion;

    while ( pIniVersion ) {

        if ((pIniDriver = FindDriverEntry(pIniVersion, pDriverName))) {

            bFoundDriver = TRUE;
            //
            // bThisVersion indicates if this version is to be deleted.
            //
            bThisVersion = !(dwDeleteFlag & DPD_DELETE_SPECIFIC_VERSION) ||
                           (pIniVersion->cMajorVersion == dwVersionNum);

            if ((pIniDriver->cRef) && bThisVersion) {
               bRefCount = TRUE;
               break;
            }

            if (bThisVersion &&
                (dwDeleteFlag & DPD_DELETE_ALL_FILES) &&
                FilesInUse(pIniVersion,pIniDriver)) {

               bFileRefCount = TRUE;
               break;
            }
        }

        pIniVersion = pIniVersion->pNext;
    }

    if ( !bFoundDriver ) {
        SetLastError(ERROR_UNKNOWN_PRINTER_DRIVER);
        bReturn = FALSE;
        goto CleanUp;
    }

    if ( bRefCount ) {
        SetLastError( ERROR_PRINTER_DRIVER_IN_USE );
        bReturn = FALSE;
        goto CleanUp;
    }

    if ( bFileRefCount ) {
        //
        // New error code has to added.
        //
        SetLastError( ERROR_PRINTER_DRIVER_IN_USE );
        bReturn = FALSE;
        goto CleanUp;
    }

    pIniVersion = pIniEnvironment->pIniVersion;

    while ( pIniVersion && (!bSpecificVersionDeleted) ) {

       if ( !(dwDeleteFlag & DPD_DELETE_SPECIFIC_VERSION) ||
            (bSpecificVersionDeleted = (pIniVersion->cMajorVersion == dwVersionNum))) {

        if (( pIniDriver = FindDriverEntry( pIniVersion, pDriverName ))) {

            //
            // Remove pending driver upgrades for local environment
            //
            if (!lstrcmpi(pIniEnvironment->pName, szEnvironment)) {

                RemovePendingUpgradeForDeletedDriver(pDriverName,
                                                     pIniVersion->cMajorVersion,
                                                     pIniSpooler);

                RemoveDriverTempFiles(pIniSpooler, pIniEnvironment,
                                      pIniVersion, pIniDriver);
            }

            if ( !DeleteDriverIni( pIniDriver,
                                   pIniVersion,
                                   pIniEnvironment,
                                   pIniSpooler )) {

                DBGMSG( DBG_CLUSTER, ("Error - driverini not deleted %d\n", GetLastError()));
                bReturn = FALSE;
                goto CleanUp;
            }

            bSetPrinterChange = TRUE;
            hImpersonationToken = RevertToPrinterSelf();

            SPLASSERT(pIniSpooler->pDir!=NULL);

            dwRet = StrNCatBuff(szDirectory,
                                COUNTOF(szDirectory),
                                pIniSpooler->pDir,
                                L"\\drivers\\",
                                pIniEnvironment->pDirectory,
                                L"\\",
                                pIniVersion->szDirectory,
                                L"\\",
                                NULL);

            if (dwRet != ERROR_SUCCESS)
            {
                 if (hImpersonationToken)
                 {
                    ImpersonatePrinterClient(hImpersonationToken);
                 }
                bReturn = FALSE;
                SetLastError(dwRet);
                goto CleanUp;
            }

            //
            // Before we leave for the driver event. Mark this printer driver as
            // pending deletion. This prevents other calls from mistakenly using
            // this driver, even though it is about to be deleted. Drivers should
            // not expect to find any other information about the driver during this
            // call other than what they were presented with.
            //
            pIniDriver->dwDriverFlags |= PRINTER_DRIVER_PENDING_DELETION;

            //
            // Increment cRefs for leaving SplSem, this prevent SplDeletePrinterDriver
            // from being called twice.
            //
            INCSPOOLERREF( pIniSpooler );
            INCDRIVERREF( pIniDriver );
            pIniEnvironment->cRef++;

            // Call DrvDriverEvent in the Driver.
            NotifyDriver(pIniSpooler,
                         pIniEnvironment,
                         pIniVersion,
                         pIniDriver,
                         DRIVER_EVENT_DELETE,
                         dwDeleteFlag);

            //
            // Decrement cRefs after reentering SplSem
            //
            DECDRIVERREF( pIniDriver );
            DECSPOOLERREF( pIniSpooler );
            pIniEnvironment->cRef--;

            //
            // Update the file reference counts for the version of the driver that
            // has been deleted.
            //
            UpdateDriverFileRefCnt(pIniEnvironment,pIniVersion,pIniDriver,szDirectory,dwDeleteFlag,FALSE);

            if (hImpersonationToken) {
               ImpersonatePrinterClient(hImpersonationToken);
            }

            DeleteDriverEntry( pIniVersion, pIniDriver );
        }

       }

       pIniVersion = pIniVersion->pNext;
    }

    if (bSetPrinterChange) {
        SetPrinterChange( NULL,
                          NULL,
                          NULL,
                          PRINTER_CHANGE_DELETE_PRINTER_DRIVER,
                          pIniSpooler );
    }

CleanUp:

   if (bEnteredSplSem) {
      LeaveSplSem();
   }

   return bReturn;

}

VOID
RemoveDriverTempFiles(
    PINISPOOLER  pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver
    )

/*++
Function Description: Removes temp directory associated with the driver

Parameters: pIniSpooler       - pointer to INISPOOLER
            pIniEnvironment   - pointer to INIENVIRONMENT
            pIniVersion       - pointer to INIVERSION
            pIniDriver        - pointer to INIDRIVER

Return Values: NONE
--*/

{
    WCHAR   szDriverDir[MAX_PATH], szDriverFile[MAX_PATH];
    LPCWSTR  pszDriverFile, pszConfigFile;
    DWORD   DriverFileSize, ConfigFileSize, MaxFileSize;
    fnWinSpoolDrv fnList;

    pszDriverFile = FindFileName(pIniDriver->pDriverFile);
    pszConfigFile = FindFileName(pIniDriver->pConfigFile);

    DriverFileSize = pszDriverFile ? wcslen(pszDriverFile) : 0 ;

    ConfigFileSize = pszConfigFile ? wcslen(pszConfigFile) : 0 ;

    MaxFileSize = ConfigFileSize > DriverFileSize ?
                  ConfigFileSize :
                  DriverFileSize;


    if (pIniDriver->dwTempDir &&
        GetDriverVersionDirectory(szDriverDir,
                                  COUNTOF(szDriverDir) - MaxFileSize -1,
                                  pIniSpooler,
                                  pIniEnvironment,
                                  pIniVersion,
                                  pIniDriver,
                                  NULL))
    {
        // Unload the driver files if neccessary

        if( pszDriverFile &&
            StrNCatBuff (szDriverFile,
                        COUNTOF(szDriverFile),
                        szDriverDir,
                        L"\\",
                        pszDriverFile,
                        NULL) == ERROR_SUCCESS ) {

            GdiArtificialDecrementDriver(szDriverFile, pIniDriver->dwDriverAttributes);
        }



        if( pszConfigFile &&
            StrNCatBuff (szDriverFile,
                        COUNTOF(szDriverFile),
                        szDriverDir,
                        L"\\",
                        pszConfigFile,
                        NULL) == ERROR_SUCCESS ) {
            if (SplInitializeWinSpoolDrv(&fnList)) {
                (* (fnList.pfnForceUnloadDriver))(szDriverFile);
            }
        }
        // Delete the files and the directory
        DeleteAllFilesAndDirectory(szDriverDir, FALSE);

    }

    return;
}


VOID RemovePendingUpgradeForDeletedDriver(
    LPWSTR      pDriverName,
    DWORD       dwVersion,
    PINISPOOLER pIniSpooler
    )

/*++
Function Description: Removes pending upgrade keys for deleted drivers.

Parameters: pDriverName  - driver name (eg. HP LaserJet 5)
            dwVersion    - version number being deleted

Return Values: NONE
--*/

{
    HKEY    hRootKey = NULL, hUpgradeKey = NULL, hVersionKey = NULL;
    HANDLE  hToken = NULL;
    WCHAR   pDriver[MAX_PATH];
    BOOL    bAllocMem = FALSE;
    DWORD   dwSize;

    if (!pDriverName || !*pDriverName) {
        return;
    }

    hToken = RevertToPrinterSelf();

    DBGMSG(DBG_CLUSTER, ("RemovePendingUpgradeForDeletedDriver Driver "TSTR"\n", pDriverName));

    StringCchPrintf(pDriver, COUNTOF(pDriver), L"Version-%d", dwVersion);

    //
    // The local spooler and cluster spooler have different sets of drivers.
    // The root registry is different.
    //
    if (pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG)
    {
        hRootKey = pIniSpooler->hckRoot;
    }
    else
    {
        SplRegCreateKey(HKEY_LOCAL_MACHINE,
                        szRegistryRoot,
                        0,
                        KEY_READ | DELETE,
                        NULL,
                        &hRootKey,
                        NULL,
                        NULL);
    }

    if (hRootKey &&
        SplRegCreateKey(hRootKey,
                        szPendingUpgrades,
                        0,
                        KEY_READ | DELETE,
                        NULL,
                        &hUpgradeKey,
                        NULL,
                        pIniSpooler) == ERROR_SUCCESS &&
        SplRegCreateKey(hUpgradeKey,
                        pDriver,
                        0,
                        KEY_READ | DELETE,
                        NULL,
                        &hVersionKey,
                        NULL,
                        pIniSpooler) == ERROR_SUCCESS)
    {
        //
        // Delete driver subkey, if any (since reg apis are not case sensitive)
        //
        SplRegDeleteKey(hVersionKey, pDriverName, pIniSpooler);
    }

    if (hVersionKey) {
        SplRegCloseKey(hVersionKey, pIniSpooler);
    }

    if (hUpgradeKey) {
        SplRegCloseKey(hUpgradeKey, pIniSpooler);
    }

    //
    // Do not close the root key if the spooler is a cluster spooler
    //
    if (hRootKey && !(pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG)) {
        SplRegCloseKey(hRootKey, pIniSpooler);
    }

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    return;
}


BOOL
NotifyDriver(
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver,
    DWORD           dwDriverEvent,
    DWORD           dwParameter
    )
/*++
Function description: Calls DrvDriverEvent, to allow the driver to cleanup some of it's
                      private files. The function is called inside SplSem.

Parameters: pIniSpooler - pointer to INISPOOLER struct.
            pIniEnvironment - pointer to INIENVIRONMENT struct.
            pIniVersion - pointer to INIVERSION struct.
            pIniDriver - pointer to the INIDRIVER struct of the driver to be notified.
            dwDriverEvent - the type of Driver Event (delete | initialize)
            dwParameter - LPARAM to pass to DrvDriverEvent. Contains dwDeleteFlag for
                            DRIVER_EVENT_DELETE

Return Values: TRUE if DrvDriverEvent returns TRUE or if it need not be called.
               FALSE if DrvDriverEvent could not be called or if it returns FALSE.

--*/
{
    WCHAR       szDriverLib[MAX_PATH];
    FARPROC     pfnDrvDriverEvent;
    HINSTANCE   hDrvLib = NULL;
    LPBYTE      pDriverInfo = NULL;
    DWORD       cbBuf;
    BOOL        bReturn = FALSE;

    SplInSem();

    //
    // Check if the driver could have been used by the system. Version number should be
    // 2 or 3, Environment should match with the global szEnvironment.
    //
    if (((pIniVersion->cMajorVersion != SPOOLER_VERSION) &&
         (pIniVersion->cMajorVersion != COMPATIBLE_SPOOLER_VERSION)) ||
        lstrcmpi(pIniEnvironment->pName,szEnvironment)) {

        return TRUE;
    }

    //
    // Get the directory where the driver files are stored.
    //
    if( pIniDriver->pConfigFile &&
        GetDriverVersionDirectory(szDriverLib,
                                  (DWORD)(COUNTOF(szDriverLib) - wcslen(pIniDriver->pConfigFile) - 2),
                                  pIniSpooler, pIniEnvironment,
                                  pIniVersion, pIniDriver, NULL)) {


        if((StrNCatBuff(szDriverLib,
                       COUNTOF(szDriverLib),
                       szDriverLib,
                       L"\\",
                       pIniDriver->pConfigFile,
                       NULL) == ERROR_SUCCESS))
        {
             //
             // Load the driver dll for the version being deleted.
             //
             if (hDrvLib = LoadDriver(szDriverLib))
             {
                 if (pfnDrvDriverEvent = GetProcAddress(hDrvLib, "DrvDriverEvent")) {

                    //
                    // If the DrvDriverEvent is supported Copy pIniDriver Info into a
                    // DRIVER_INFO_3 struct and call the DrvDriverEvent Function.
                    //
                    cbBuf = GetDriverInfoSize( pIniDriver, 3, pIniVersion, pIniEnvironment,
                                                       NULL, pIniSpooler );

                    if (pDriverInfo = (LPBYTE) AllocSplMem(cbBuf)) {

                       if (CopyIniDriverToDriverInfo( pIniEnvironment,
                                                      pIniVersion,
                                                      pIniDriver,
                                                      3,
                                                      pDriverInfo,
                                                      pDriverInfo + cbBuf,
                                                      NULL,
                                                      pIniSpooler )) {

                           //
                           // Leave the semaphore before calling into the spooler
                           //
                           LeaveSplSem();
                           SplOutSem();


                           try {

                             bReturn = (BOOL) pfnDrvDriverEvent(dwDriverEvent,
                                                                3,
                                                                pDriverInfo,
                                                                (LPARAM) dwParameter);

                           } except(EXCEPTION_EXECUTE_HANDLER) {

                                 SetLastError( GetExceptionCode() );
                                 DBGMSG(DBG_ERROR,
                                        ("NotifyDriver ExceptionCode %x Driver %ws Error %d\n",
                                        GetLastError(), szDriverLib, GetLastError() ));
                                 bReturn = FALSE;
                           }
                           
                           EnterSplSem();
                       }
                    }
                 }
             }
        }
    }

    if (pDriverInfo) {
       FreeSplMem(pDriverInfo);
    }

    if (hDrvLib) {
        UnloadDriver(hDrvLib);
    }

    return bReturn;
}


PDRVREFCNT
DecrementFileRefCnt(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver,
    LPCWSTR pszFileName,
    LPCWSTR pszDirectory,
    DWORD dwDeleteFlag
    )
/*++

Function description: Decrements the driver file usage reference counts and deletes unused
                      files depending on dwDeleteFlag.

Paramaters:  pIniEnvironment - pointer to INIENVIRONMENT
             pIniVersion - pointer to INIVERSION struct. This struct contains the ref counts.
             pIniDriver - pointer to INIDRIVER
             szFileName - driver file name whose ref count is to be decremented.
             szDirectory - Directory where the files are located.
             dwDeleteFlag - unused files are deleted if this flag contains
                            DPD_DELETE_UNUSED_FILES or DPD_DELETE_ALL_FILES

Return Value: pointer to the DRVREFCNT which was decremented
              NULL if memory allocation fails.

--*/
{

    PDRVREFCNT pdrc,*pprev;
    LPWSTR     pszDelFile=NULL;
    WCHAR      szTempDir[MAX_PATH+5],szTempFile[MAX_PATH];
    DWORD      cbSize;
    PDRVREFCNT pReturn = NULL;

    SplInSem();

    pdrc = pIniVersion->pDrvRefCnt;
    pprev = &(pIniVersion->pDrvRefCnt);

    //
    // Go thru the list of ref count nodes in the Iniversion struct and find the node
    // corresponding to szFileName.
    //
    while (pdrc != NULL) {
       if (lstrcmpi(pszFileName,pdrc->szDrvFileName) == 0) {

         if (pdrc->refcount == 1 &&
             ((dwDeleteFlag & DPD_DELETE_UNUSED_FILES) ||
             (dwDeleteFlag & DPD_DELETE_ALL_FILES)) ) {

              //
              // Delete the file, the size is needed later when we pass the file
              // to be deleted.
              //
              cbSize = sizeof(pszDirectory[0])*(wcslen(pszDirectory)+1);
              cbSize += sizeof(pszFileName[0])*(wcslen(pszFileName)+1);

              if (!BoolFromStatus(StrCatAlloc(&pszDelFile, pszDirectory, pszFileName, NULL))) {

                  pReturn = NULL;
                  goto CleanUp;
              }

              if (pIniDriver) {

                 if (!lstrcmpi(pszFileName, pIniDriver->pDriverFile)) {

                     FilesUnloaded(pIniEnvironment, pszDelFile,
                                   NULL, pIniDriver->dwDriverAttributes);
                 }
                 else if (!lstrcmpi(pszFileName, pIniDriver->pConfigFile)) {

                     FilesUnloaded(pIniEnvironment, NULL,
                                   pszDelFile, pIniDriver->dwDriverAttributes);
                 }
              }

              //
              // We are about to delete a driver file. Delete the same file from
              // the cluster disk too (if applicable)
              //
              if (pIniEnvironment->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER)
              {
                  WCHAR szFilePath[MAX_PATH] = {0};

                  //
                  // If DeleteFile fails, there isn't much we can do about it.
                  // The file will remain on the cluster disk.
                  //
                  if (StrNCatBuff(szFilePath,
                                  MAX_PATH,
                                  pIniEnvironment->pIniSpooler->pszClusResDriveLetter,
                                  L"\\",
                                  szClusterDriverRoot,
                                  L"\\",
                                  pIniEnvironment->pDirectory,
                                  L"\\",
                                  pIniVersion->szDirectory,
                                  L"\\",
                                  pszFileName,
                                  NULL) == ERROR_SUCCESS &&
                      SplDeleteFile(szFilePath))
                  {
                      DBGMSG(DBG_CLUSTER, ("DecrementFilesRefCnt Deleted szFilePath "TSTR" from cluster\n", szFilePath));
                  }
              }

              if (!SplDeleteFile(pszDelFile)) {

                 //
                 // Move the file to a temp directory and delete on REBOOT.
                 // Create the temp directory and new tempfile.
                 //
                 StringCchCopy(szTempDir, COUNTOF(szTempDir), pszDirectory);
                 StringCchCat(szTempDir, COUNTOF(szTempDir), L"temp");

                 //
                 // CreateDirectory will fail, if szTempDir already
                 // exists. Since we don't check for any errors, subsequent functions
                 // may fail.
                 //
                 CreateDirectory(szTempDir,NULL);

                 GetTempFileName(szTempDir, pszFileName, 0, szTempFile);
                 SplMoveFileEx(pszDelFile, szTempFile, MOVEFILE_REPLACE_EXISTING);
                 SplMoveFileEx(szTempFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
              }

              *pprev = pdrc->pNext;
         }

         //
         // Decrement the ref cnt for the file.
         //
         if (pdrc->refcount > 0) pdrc->refcount--;
         pReturn = pdrc;
         break;

       }
       pprev = &(pdrc->pNext);
       pdrc = pdrc->pNext;
    }

CleanUp:

    if (pszDelFile) {
       FreeSplMem(pszDelFile);
    }
    return pReturn;
}


BOOL
SplGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    DWORD   dwDontCare;

    return SplGetPrinterDriverEx(hPrinter,
                                 pEnvironment,
                                 Level,
                                 pDriverInfo,
                                 cbBuf,
                                 pcbNeeded,
                                 0,
                                 0,
                                 &dwDontCare,
                                 &dwDontCare
                                 );
}

BOOL
LocalGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplGetPrinterDriverDirectory( pName,
                                            pEnvironment,
                                            Level,
                                            pDriverInfo,
                                            cbBuf,
                                            pcbNeeded,
                                            pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}

BOOL
SplGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    PINISPOOLER pIniSpooler
)
{
    DWORD       cb;
    WCHAR       string[MAX_PATH];
    BOOL        bRemote=FALSE;
    PINIENVIRONMENT pIniEnvironment;
    HANDLE      hImpersonationToken;
    DWORD       ParmError;
    SHARE_INFO_1501 ShareInfo1501;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PSHARE_INFO_2 pShareInfo = (PSHARE_INFO_2)pIniSpooler->pDriversShareInfo;

    DBGMSG( DBG_TRACE, ("GetPrinterDriverDirectory\n"));

    if ( pName && *pName ) {

        if ( !MyName( pName, pIniSpooler )) {

            return FALSE;

        } else {
            bRemote = TRUE;
        }
    }

    if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                SERVER_ACCESS_ENUMERATE,
                                NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    pIniEnvironment = FindEnvironment( pEnvironment, pIniSpooler );

    if ( !pIniEnvironment ) {

       LeaveSplSem();
        SetLastError( ERROR_INVALID_ENVIRONMENT );
        return FALSE;
    }

    //
    // Ensure that the directory exists
    //
    GetDriverDirectory( string, COUNTOF(string), pIniEnvironment, NULL, pIniSpooler );

    hImpersonationToken = RevertToPrinterSelf();

    CreateCompleteDirectory( string );

    if (hImpersonationToken && !ImpersonatePrinterClient( hImpersonationToken ))
    {
        LeaveSplSem();
        return FALSE;
    }

    cb = GetDriverDirectory( string, COUNTOF(string), pIniEnvironment, bRemote ? pName : NULL, pIniSpooler )
         * sizeof(WCHAR) + sizeof(WCHAR);

    *pcbNeeded = cb;

    LeaveSplSem();

    if (cb > cbBuf) {

       SetLastError( ERROR_INSUFFICIENT_BUFFER );
       return FALSE;
    }

    StringCbCopy((PWSTR)pDriverInfo, cbBuf, string);

    memset( &ShareInfo1501, 0, sizeof ShareInfo1501 );

    //
    // Also ensure the drivers share exists
    //
    if ( bRemote ) {

        NET_API_STATUS rc;

        if ( rc = (*pfnNetShareAdd)(NULL, 2, (LPBYTE)pIniSpooler->pDriversShareInfo, &ParmError )) {

            DBGMSG( DBG_WARNING, ("NetShareAdd failed: Error %d, Parm %d\n", rc, ParmError));
        }

        else if (pSecurityDescriptor = CreateDriversShareSecurityDescriptor( )) {

            ShareInfo1501.shi1501_security_descriptor = pSecurityDescriptor;

            if (rc = (*pfnNetShareSetInfo)(NULL, pShareInfo->shi2_netname, 1501,
                                           &ShareInfo1501, &ParmError)) {

                DBGMSG( DBG_WARNING, ("NetShareSetInfo failed: Error %d, Parm %d\n", rc, ParmError));

            }

            LocalFree(pSecurityDescriptor);
        }
    }

    return TRUE;
}

BOOL
LocalEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplEnumPrinterDrivers( pName, pEnvironment, Level, pDriverInfo,
                                     cbBuf, pcbNeeded, pcReturned,
                                     pIniSpooler);

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}

/*++

Routine Name

    FindDriverInList

Routine Description:

    Finds a certain driver in a list of drivers. None of the arguments
    can or will be null.

Arguments:
    pDriverList - array of DRIVER INFO 6 strucutres
    cDrivers    - number of drivers in the list
    pszName     - name of the driver we are looking for
    pszEnv      - environment of the driver we are looking for
    dwVersion   - version of the driver we are looking for

Return Value:

    valid pointer to driver info 6 structure if the driver is found
    NULL if the driver was not found

--*/
DRIVER_INFO_6*
FindDriverInList(
    DRIVER_INFO_6 *pDriverList,
    DWORD          cDrivers,
    LPCWSTR        pszName,
    LPCWSTR        pszEnv,
    DWORD          dwVersion
    )
{
    DWORD          uIndex;
    DRIVER_INFO_6 *pDrv6   = NULL;

    for (pDrv6 = pDriverList, uIndex = 0;
         pDrv6 && uIndex < cDrivers;
         pDrv6++, uIndex++)
    {
        if (!_wcsicmp(pDrv6->pName, pszName)       &&
            !_wcsicmp(pDrv6->pEnvironment, pszEnv) &&
            pDrv6->cVersion == dwVersion)
        {
            break;
        }
    }

    //
    // Check if driver was found
    //
    return uIndex == cDrivers ? NULL : pDrv6;
}

/*++

Routine Name

    GetBufferSizeForPrinterDrivers

Routine Description:

    Helper function for SplEnumAllClusterPrinterDrivers. Calculates the
    bytes needed to hold all printer driver strucutres on all the spoolers
    hosted by the spooler process. Note that we may ask for more bytes
    than we really need. This is beacuse we enumerate the drivers on the
    local  spooler and on cluster spoolers and we count duplicates again.
    In order to count the exact number of bytes needed, we would need to
    loop through the drivers and search each of them in all spoolers. This
    would be too slow.

Arguments:

    pszRemote   - NULL if the caller is local on the machine, a string otherwise

Return Value:

    Count of bytes needed to store all the drivers

--*/
DWORD
GetBufferSizeForPrinterDrivers(
    LPWSTR pszRemote
    )
{
    PINISPOOLER     pIniSpooler;
    PINIENVIRONMENT pIniEnvironment;
    PINIVERSION     pIniVersion;
    PINIDRIVER      pIniDriver;
    DWORD           cbNeeded = 0;

    SplInSem();

    for (pIniSpooler = pLocalIniSpooler;
         pIniSpooler;
         pIniSpooler = pIniSpooler->pIniNextSpooler)
    {
        //
        // We want either a pIniSpooler that is not a clusrer, or
        // a pIniSpooler that is a cluster spooler that is not
        // in pending deletion or offline. We could optimize this so it 
        // skips win32spl spoolers.
        //
        if (!(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) ||
            pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
            !(pIniSpooler->SpoolerFlags & SPL_PENDING_DELETION ||
              pIniSpooler->SpoolerFlags & SPL_OFFLINE))
        {
            for (pIniEnvironment = pIniSpooler->pIniEnvironment;
                 pIniEnvironment;
                 pIniEnvironment = pIniEnvironment->pNext)
            {
                for (pIniVersion = pIniEnvironment->pIniVersion;
                     pIniVersion;
                     pIniVersion = pIniVersion->pNext)
                {
                    for (pIniDriver = pIniVersion->pIniDriver;
                         pIniDriver;
                         pIniDriver = pIniDriver->pNext)
                    {
                        //
                        // Omit drivers that are currently in a pending deletion
                        // state.
                        //
                        if (!(pIniDriver->dwDriverFlags & PRINTER_DRIVER_PENDING_DELETION))
                        {
                            cbNeeded += GetDriverInfoSize(pIniDriver,
                                                          6,
                                                          pIniVersion,
                                                          pIniEnvironment,
                                                          pszRemote,
                                                          pIniSpooler);
                        }
                    }
                }
            }
        }
    }

    return cbNeeded;
}

/*++

Routine Name

    PackClusterPrinterDrivers

Routine Description:

    Helper function for SplEnumAllClusterPrinterDrivers. This function relies on
    its caller to validate the arguments. This function loops through all the
    drivers on all pIniSpooler and stores driver information in a buffer. There
    won't be duplicate drivers in the list. If 2 pIniSpooler have the same driver,
    then the oldest is enumerated.

Arguments:

    pszRemote   - NULL if the caller is local on the machine, a string otherwise
    pDriverBuf  - buffer to hold the strcutures
    cbBuf       - buffer size in bytes
    pcReturned  - number of structures returned

Return Value:

    Win32 error code

--*/
DWORD
PackClusterPrinterDrivers(
    LPWSTR          pszRemote,
    LPBYTE          pDriverBuf,
    DWORD           cbBuf,
    LPDWORD         pcReturned
    )
{
    PINIDRIVER      pIniDriver;
    PINIENVIRONMENT pIniEnvironment;
    PINIVERSION     pIniVersion;
    PINISPOOLER     pIniSpooler;
    DRIVER_INFO_6  *pListHead   = (DRIVER_INFO_6 *)pDriverBuf;
    LPBYTE          pEnd        = pDriverBuf + cbBuf;
    DWORD           dwError     = ERROR_SUCCESS;

    SplInSem();

    for (pIniSpooler = pLocalIniSpooler;
         pIniSpooler;
         pIniSpooler = pIniSpooler->pIniNextSpooler)
    {
        //
        // Either pIniSpooler is not a cluster, or it is a cluster and
        // it is not pending deletion or offline. We could optimize this so it 
        // skips win32spl spoolers.
        //
        if (!(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) ||
              pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
              !(pIniSpooler->SpoolerFlags & SPL_PENDING_DELETION ||
              pIniSpooler->SpoolerFlags & SPL_OFFLINE))
        {
            for (pIniEnvironment = pIniSpooler->pIniEnvironment;
                 pIniEnvironment;
                 pIniEnvironment = pIniEnvironment->pNext)
            {
                for (pIniVersion = pIniEnvironment->pIniVersion;
                     pIniVersion;
                     pIniVersion = pIniVersion->pNext)
                {
                    for (pIniDriver = pIniVersion->pIniDriver;
                         pIniDriver;
                         pIniDriver = pIniDriver->pNext)
                    {
                        //
                        // Make sure that we don't enumerate drivers that are pending deletion.
                        //
                        if (!(pIniDriver->dwDriverFlags & PRINTER_DRIVER_PENDING_DELETION))
                        {
                            DRIVER_INFO_6 *pDrv6 = NULL;

                            if (pDrv6 = FindDriverInList(pListHead,
                                                         *pcReturned,
                                                         pIniDriver->pName,
                                                         pIniEnvironment->pName,
                                                         pIniDriver->cVersion))

                            {
                                //
                                // The driver that we are currently enumerating is older than the
                                // driver that we have in the list. We need to update the driver
                                // time in the list. The list always has the oldest driver.
                                //
                                if (CompareFileTime(&pDrv6->ftDriverDate, &pIniDriver->ftDriverDate) > 0)
                                {
                                    pDrv6->ftDriverDate = pIniDriver->ftDriverDate;
                                }
                            }
                            else
                            {
                                //
                                // Add the driver to the driver list
                                //
                                if (pEnd = CopyIniDriverToDriverInfo(pIniEnvironment,
                                                                     pIniVersion,
                                                                     pIniDriver,
                                                                     6,
                                                                     pDriverBuf,
                                                                     pEnd,
                                                                     pszRemote,
                                                                     pIniSpooler))
                                {
                                    pDriverBuf += sizeof(DRIVER_INFO_6);

                                    (*pcReturned)++;
                                }
                                else
                                {
                                    //
                                    // Severe error occured
                                    //
                                    dwError = ERROR_INSUFFICIENT_BUFFER;

                                    goto CleanUp;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

CleanUp:

    return dwError;
}

/*++

Routine Name

    SplEnumAllClusterPrinterDrivers

Routine Description:

    Enumerates the driver on all the spoolers hosted by the spooler process.
    It does not enumerate duplicates. This function is a helper function
    for EnumPrinterDrivers, when the latter is called with "allcluster"
    environment. The only consumer for this is Windows Update. Windows
    update needs to update all the drivers on all the spoolers on a machine,
    and uses EnumPrinterDrivers with "allcluster" environment.

Arguments:

    pszRemote   - NULL if the caller is local on the machine, a string otherwise
    Level       - must be 6
    pDriverInfo - buffer to hold the strcutures
    cbBuf       - buffer size in bytes
    pcbNeeded   - pointer to receive the count of bytes needed
    pcReturned  - number of structures returned. Must be a valid pointer

Return Value:

    TRUE,  if getting the drivers was successful
    FALSE, otherwise. Use GetLastError for error code

--*/
BOOL
SplEnumAllClusterPrinterDrivers(
    LPWSTR  pszRemote,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DWORD  dwError = ERROR_INVALID_PARAMETER;

    if (pcbNeeded && pcReturned)
    {
        *pcReturned = 0;

        if (dwLevel == 6)
        {
            EnterSplSem();

            //
            // Calculate the bytes needed for our driver structures
            //
            *pcbNeeded = GetBufferSizeForPrinterDrivers(pszRemote);

            dwError = cbBuf < *pcbNeeded ? ERROR_INSUFFICIENT_BUFFER :
                                           PackClusterPrinterDrivers(pszRemote,
                                                                     pDriverInfo,
                                                                     cbBuf,
                                                                     pcReturned);

            LeaveSplSem();
        }
        else
        {
            dwError = ERROR_INVALID_LEVEL;
        }
    }

    SetLastError(dwError);

    return dwError == ERROR_SUCCESS;
}

BOOL
SplEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIDRIVER  pIniDriver;
    PINIVERSION pIniVersion;
    BOOL        bAllDrivers;
    DWORD       cb, cbStruct;
    LPBYTE      pEnd;
    LPWSTR      lpRemote = NULL;
    PINIENVIRONMENT pIniEnvironment;

    DBGMSG( DBG_TRACE, ("EnumPrinterDrivers\n"));

    if ( pName && *pName ) {

        if ( !MyName( pName, pIniSpooler )) {

            return FALSE;

        } else {

            lpRemote = pName;
        }
    }


    if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                SERVER_ACCESS_ENUMERATE,
                                NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    if (!_wcsicmp(pEnvironment, EPD_ALL_LOCAL_AND_CLUSTER))
    {
        return SplEnumAllClusterPrinterDrivers(lpRemote,
                                               Level,
                                               pDriverInfo,
                                               cbBuf,
                                               pcbNeeded,
                                               pcReturned);
    }

    switch (Level) {

    case 1:
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        cbStruct = sizeof(DRIVER_INFO_6);
        break;
    }

    *pcReturned=0;

    cb=0;

    bAllDrivers = !_wcsicmp(pEnvironment, L"All");

   EnterSplSem();

    if ( bAllDrivers )
        pIniEnvironment = pIniSpooler->pIniEnvironment;
    else
        pIniEnvironment = FindEnvironment( pEnvironment, pIniSpooler );

    if ( !pIniEnvironment ) {

       LeaveSplSem();
        SetLastError(ERROR_INVALID_ENVIRONMENT);
        return FALSE;
    }


    do {

        pIniVersion = pIniEnvironment->pIniVersion;

        while ( pIniVersion ) {

            pIniDriver = pIniVersion->pIniDriver;

            while ( pIniDriver ) {

                //
                // Don't consider drivers that are pending deletion for enumeration.
                //
                if (!(pIniDriver->dwDriverFlags & PRINTER_DRIVER_PENDING_DELETION))
                {
                    DBGMSG( DBG_TRACE, ("Driver found - %ws\n", pIniDriver->pName));

                    cb += GetDriverInfoSize( pIniDriver, Level, pIniVersion,
                                             pIniEnvironment, lpRemote, pIniSpooler );
                }

                pIniDriver = pIniDriver->pNext;
            }

            pIniVersion = pIniVersion->pNext;
        }

        if ( bAllDrivers )
            pIniEnvironment = pIniEnvironment->pNext;
        else
            break;
    } while ( pIniEnvironment );

    *pcbNeeded=cb;

    DBGMSG( DBG_TRACE, ("Required is %d and Available is %d\n", cb, cbBuf));

    if (cbBuf < cb) {

        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        LeaveSplSem();
        return FALSE;
    }


    DBGMSG( DBG_TRACE, ("Now copying contents into DRIVER_INFO structures\n"));

    if ( bAllDrivers )
        pIniEnvironment = pIniSpooler->pIniEnvironment;

    pEnd = pDriverInfo+cbBuf;

    do {

        pIniVersion = pIniEnvironment->pIniVersion;

        while ( pIniVersion ) {

            pIniDriver = pIniVersion->pIniDriver;

            while ( pIniDriver ) {

                //
                // Don't consider printer drivers that are pending deletion for
                // enumeration.
                //
                if (!(pIniDriver->dwDriverFlags & PRINTER_DRIVER_PENDING_DELETION))
                {

                    if (( pEnd = CopyIniDriverToDriverInfo( pIniEnvironment,
                                                            pIniVersion,
                                                            pIniDriver,
                                                            Level,
                                                            pDriverInfo,
                                                            pEnd,
                                                            lpRemote,
                                                            pIniSpooler )) == NULL){
                        LeaveSplSem();
                         return FALSE;
                    }

                    pDriverInfo += cbStruct;
                    (*pcReturned)++;
                }

                pIniDriver = pIniDriver->pNext;
            }

            pIniVersion = pIniVersion->pNext;
        }

        if ( bAllDrivers )
            pIniEnvironment = pIniEnvironment->pNext;
        else
            break;
    } while ( pIniEnvironment );

   LeaveSplSem();
    return TRUE;
}

DWORD
GetDriverInfoSize(
    PINIDRIVER  pIniDriver,
    DWORD       Level,
    PINIVERSION pIniVersion,
    PINIENVIRONMENT  pIniEnvironment,
    LPWSTR      lpRemote,
    PINISPOOLER pIniSpooler
)
{
    DWORD cbDir, cb=0, cchLen;
    WCHAR  string[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
    LPWSTR pStr;
    DWORD  cFiles = 0;

    switch (Level) {

    case 1:
        cb=sizeof(DRIVER_INFO_1) + wcslen(pIniDriver->pName)*sizeof(WCHAR) +
                                   sizeof(WCHAR);
        break;

    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case DRIVER_INFO_VERSION_LEVEL:

        cbDir = GetDriverVersionDirectory( string, COUNTOF(string), pIniSpooler, pIniEnvironment,
                                           pIniVersion, pIniDriver, lpRemote) + 1;

        SPLASSERT(pIniDriver->pDriverFile);
        cb+=wcslen(pIniDriver->pDriverFile) + 1 + cbDir;

        SPLASSERT(pIniDriver->pDataFile);
        cb+=wcslen(pIniDriver->pDataFile) + 1 + cbDir;

        SPLASSERT(pIniDriver->pConfigFile);
        cb+=wcslen(pIniDriver->pConfigFile) + 1 + cbDir;

        cb += wcslen( pIniDriver->pName ) + 1 + wcslen( pIniEnvironment->pName ) + 1;

        if ((Level == 2) || (Level == 5)) {

            //
            // For the strings in the struct
            //
            cb *= sizeof(WCHAR);
            if (Level == 2) {
                cb += sizeof( DRIVER_INFO_2 );
            } else { 
                //
                // Level 5
                //
                cb += sizeof( DRIVER_INFO_5 );
            }

        } else {    

            //
            // Level 3 or 4 or 6.
            //
            if ( pIniDriver->pHelpFile && *pIniDriver->pHelpFile )
                cb += wcslen(pIniDriver->pHelpFile) + cbDir + 1;

            if ( pIniDriver->pMonitorName && *pIniDriver->pMonitorName )
                cb += wcslen(pIniDriver->pMonitorName) + 1;

            if ( pIniDriver->pDefaultDataType && *pIniDriver->pDefaultDataType)
                cb += wcslen(pIniDriver->pDefaultDataType) + 1;

            if ( (pStr=pIniDriver->pDependentFiles) && *pStr ) {

                //
                // There are 4 distinctive files in the file set
                // (driver, data , config, help).
                //
                cFiles = 4;
                while ( *pStr ) {
                    cchLen = wcslen(pStr) + 1;
                    cb    += cchLen + cbDir;
                    pStr  += cchLen;
                    cFiles++;
                }
                //
                // Make room for final \0
                //
                ++cb; 
            }

            if ( (Level == 4 || Level == 6 || Level == DRIVER_INFO_VERSION_LEVEL) &&
                 (pStr = pIniDriver->pszzPreviousNames) &&
                 *pStr) {

                while ( *pStr ) {

                    cchLen  = wcslen(pStr) + 1;
                    cb     += cchLen;
                    pStr   += cchLen;
                }

                //
                // Make room for final \0
                //
                ++cb; 
            }

            if (Level==6 || Level == DRIVER_INFO_VERSION_LEVEL) {

                if (pIniDriver->pszMfgName && *pIniDriver->pszMfgName)
                    cb += wcslen(pIniDriver->pszMfgName) + 1;

                if (pIniDriver->pszOEMUrl && *pIniDriver->pszOEMUrl)
                   cb += wcslen(pIniDriver->pszOEMUrl) + 1;

                if (pIniDriver->pszHardwareID && *pIniDriver->pszHardwareID)
                   cb += wcslen(pIniDriver->pszHardwareID) + 1;

                if (pIniDriver->pszProvider && *pIniDriver->pszProvider)
                   cb += wcslen(pIniDriver->pszProvider) + 1;

            }

            cb *= sizeof(WCHAR);

            switch (Level) {
            case 3:
                cb += sizeof( DRIVER_INFO_3 );
                break;
            case 4:
                cb += sizeof( DRIVER_INFO_4 );
                break;
            case 6:
                cb += sizeof( DRIVER_INFO_6 );
                break;
            case DRIVER_INFO_VERSION_LEVEL:
                cb += sizeof( DRIVER_INFO_VERSION ) +
                      cFiles * sizeof(DRIVER_FILE_INFO) +
                      sizeof(ULONG_PTR);
                break;
            }
        }

        break;
    default:
        DBGMSG(DBG_ERROR,
                ("GetDriverInfoSize: level can not be %d", Level) );
        cb = 0;
        break;
    }

    return cb;
}



LPBYTE
CopyMultiSzFieldToDriverInfo(
    LPWSTR  pszz,
    LPBYTE  pEnd,
    LPWSTR  pszPrefix,
    DWORD   cchPrefix
    )
/*++

Routine Description:
    Copies a multi sz field from IniDriver to DriverInfo structure.
    If a pszPrefix is specified that is appended before each string.

Arguments:
    pszz        : entry in pIniDriver (this could be dependent files
                     ex. PSCRIPT.DLL\0QMS810.PPD\0PSCRPTUI.DLL\0PSPCRIPTUI.HLP\0PSTEST.TXT\0\0
                    or previous names
                     ex. OldName1\0OldName2\0\0 )
    pEnd        : end of buffer to which it needs to be copied
    pszPrefix   : Prefix to copy when copying to user buffer. For dependent
                  files this will be driver directory path
    cchPrefix   : length of prefix

Return Value:
    after copying where is the buffer end to copy next field

--*/
{
    LPWSTR  pStr1, pStr2;
    DWORD   cchSize, cchLen;

    if ( !pszz || !*pszz )
        return pEnd;

    pStr1   = pszz;
    cchSize = 0;

    while ( *pStr1 ) {

        cchLen = wcslen(pStr1) + 1;
        cchSize += cchPrefix + cchLen;
        pStr1 += cchLen;
    }

    //
    // Make room for the last \0.
    //
    ++cchSize;

    pEnd -= cchSize * sizeof(WCHAR);

    pStr1 = pszz;
    pStr2 = (LPWSTR) pEnd;

    //
    // Here, we assume that the buffer size has been validated up front. The
    // string copying routines are adding nothing here. We just use them
    // because we have to.
    //
    while ( *pStr1 ) {

        if ( pszPrefix ) {

            StringCchCopy(pStr2, cchPrefix + 1, pszPrefix);
            pStr2 += cchPrefix;
        }

        //
        // This should really be rewritten to make this function able to
        // validate buffer sizes before packing the strings. In practice,
        // the buffer is always checked by the spooler APIs first which
        // makes this safe.
        //
        cchLen  = wcslen(pStr1) + 1;

        CopyMemory(pStr2, pStr1, cchLen * sizeof(*pStr2));

        pStr2  += cchLen;
        pStr1  += cchLen;
    }

    *pStr2 = '\0';

    return pEnd;
}


LPBYTE
CopyIniDriverToDriverInfo(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    LPBYTE  pEnd,
    LPWSTR  lpRemote,
    PINISPOOLER pIniSpooler
)
/*++
Routine Description:
    This routine copies data from the IniDriver structure to
    an DRIVER_INFO_X structure.

Arguments:

    pIniEnvironment     pointer to the INIENVIRONMENT structure

    pIniVersion         pointer to the INIVERSION structure.

    pIniDriver          pointer to the INIDRIVER structure.

    Level               Level of the DRIVER_INFO_X structure

    pDriverInfo         Buffer of the DRIVER_INFO_X structure

    pEnd                pointer to the end of the  pDriverInfo

    lpRemote              flag which determines whether Remote or Local

    pIniSpooler         pointer to the INISPOOLER structure
Return Value:

    if the call is successful, the return value is the updated pEnd value.

    if the call is unsuccessful, the return value is NULL.


Note:

--*/
{
    LPWSTR *pSourceStrings, *SourceStrings;
    WCHAR  string[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
    DWORD i, j;
    DWORD *pOffsets;
    LPWSTR pTempDriverPath=NULL;
    LPWSTR pTempConfigFile=NULL;
    LPWSTR pTempDataFile=NULL;
    LPWSTR pTempHelpFile=NULL;

    switch (Level) {

    case DRIVER_INFO_VERSION_LEVEL:

        return CopyIniDriverToDriverInfoVersion(pIniEnvironment,
                                                pIniVersion,
                                                pIniDriver,
                                                pDriverInfo,
                                                pEnd,
                                                lpRemote,
                                                pIniSpooler);
        break;

    case 1:
        pOffsets = DriverInfo1Strings;
        break;

    case 2:
    case 5:
        pOffsets = DriverInfo2Strings;
        break;

    case 3:
    case 4:
        pOffsets = DriverInfo3Strings;
        break;
    case 6:
        pOffsets = DriverInfo6Strings;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return NULL;
    }

    for (j=0; pOffsets[j] != -1; j++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(j * sizeof(LPWSTR));

    if ( pSourceStrings ) {

        switch (Level) {

        case 1:
            *pSourceStrings++=pIniDriver->pName;

            pEnd = PackStrings(SourceStrings, pDriverInfo, pOffsets, pEnd);
            break;

        case 2:
        case 3:
        case 4:
        case 5:
        case 6:

            i = GetDriverVersionDirectory(string, (DWORD)(COUNTOF(string) - wcslen(pIniDriver->pDriverFile) - 1), pIniSpooler, pIniEnvironment,
                                          pIniVersion, pIniDriver, lpRemote);
            if(!i) {
                pEnd = NULL;
                goto Fail;
            }
            string[i++] = L'\\';

            *pSourceStrings++ = pIniDriver->pName;

            *pSourceStrings++ = pIniEnvironment->pName;

            StringCchCopy(&string[i], COUNTOF(string) - i, pIniDriver->pDriverFile);

            if (( pTempDriverPath = AllocSplStr(string) ) == NULL){

                DBGMSG( DBG_WARNING, ("CopyIniDriverToDriverInfo: AlloSplStr failed\n"));
                pEnd = NULL;
                goto Fail;
            }

            *pSourceStrings++ = pTempDriverPath;

            StringCchCopy(&string[i], COUNTOF(string) - i, pIniDriver->pDataFile);

            if (( pTempDataFile = AllocSplStr(string) ) == NULL){

                DBGMSG( DBG_WARNING, ("CopyIniDriverToDriverInfo: AlloSplStr failed\n"));
                pEnd = NULL;
                goto Fail;
            }

            *pSourceStrings++ = pTempDataFile;


            if ( pIniDriver->pConfigFile && *pIniDriver->pConfigFile ) {

                StringCchCopy(&string[i], COUNTOF(string) - i, pIniDriver->pConfigFile );

                if (( pTempConfigFile = AllocSplStr(string) ) == NULL) {

                    DBGMSG( DBG_WARNING, ("CopyIniDriverToDriverInfo: AlloSplStr failed\n"));
                    pEnd = NULL;
                    goto Fail;
                }

                *pSourceStrings++ = pTempConfigFile;

            } else {

                *pSourceStrings++=0;
            }

            if ( Level == 3 || Level == 4 || Level == 6 ) {

                if ( pIniDriver->pHelpFile && *pIniDriver->pHelpFile ) {

                    StringCchCopy(&string[i], COUNTOF(string) - i, pIniDriver ->pHelpFile);

                    if (( pTempHelpFile = AllocSplStr(string) ) == NULL) {
                        DBGMSG(DBG_WARNING,
                               ("CopyIniDriverToDriverInfo: AlloSplStr failed\n"));
                        pEnd = NULL;
                        goto Fail;
                    }
                    *pSourceStrings++ = pTempHelpFile;
                } else {

                    *pSourceStrings++=0;
                }

                *pSourceStrings++ = pIniDriver->pMonitorName;

                *pSourceStrings++ = pIniDriver->pDefaultDataType;

            }


            if (Level == 6) {

                ((PDRIVER_INFO_6)pDriverInfo)->ftDriverDate = pIniDriver->ftDriverDate;

                ((PDRIVER_INFO_6)pDriverInfo)->dwlDriverVersion = pIniDriver->dwlDriverVersion;

                *pSourceStrings++ = pIniDriver->pszMfgName;

                *pSourceStrings++ = pIniDriver->pszOEMUrl;

                *pSourceStrings++ = pIniDriver->pszHardwareID;

                *pSourceStrings++ = pIniDriver->pszProvider;
            }

            pEnd = PackStrings( SourceStrings, pDriverInfo, pOffsets, pEnd );

            if ( Level == 3 || Level == 4 || Level == 6 ) {

                //
                // Dependent files need to be copied till \0\0
                // so need to do it outside PackStirngs
                //
                if ( pIniDriver->cchDependentFiles ) {

                    pEnd = CopyMultiSzFieldToDriverInfo(
                                    pIniDriver->pDependentFiles,
                                    pEnd,
                                    string,
                                    i);
                   ((PDRIVER_INFO_3)pDriverInfo)->pDependentFiles = (LPWSTR) pEnd;
                }
                else {
                    ((PDRIVER_INFO_3)pDriverInfo)->pDependentFiles  = NULL;
                }

                //
                // pszzPreviousNames is multi-sz too
                //
                if ( Level == 4 || Level == 6) {

                    if ( pIniDriver->cchPreviousNames ) {

                        pEnd = CopyMultiSzFieldToDriverInfo(
                                        pIniDriver->pszzPreviousNames,
                                        pEnd,
                                        NULL,
                                        0);
                        ((PDRIVER_INFO_4)pDriverInfo)->pszzPreviousNames = (LPWSTR) pEnd;
                    } else {

                        ((PDRIVER_INFO_4)pDriverInfo)->pszzPreviousNames = NULL;
                    }

                }

                ((PDRIVER_INFO_3)pDriverInfo)->cVersion = pIniDriver->cVersion;
            } else {
                //
                // Level == 2 or Level = 5.
                //
                if (Level == 2) {

                    ((PDRIVER_INFO_2)pDriverInfo)->cVersion = pIniDriver->cVersion;

                } else {

                    PDRIVER_INFO_5 pDriver5;

                    pDriver5 = (PDRIVER_INFO_5) pDriverInfo;
                    pDriver5->cVersion = pIniDriver->cVersion;

                    if (!pIniDriver->dwDriverAttributes) {

                        //
                        // Driver Attributes has not been initialized as yet; do it now
                        //
                        CheckDriverAttributes(pIniSpooler, pIniEnvironment,
                                              pIniVersion, pIniDriver);
                    }

                    pDriver5->dwDriverAttributes = pIniDriver->dwDriverAttributes;
                    pDriver5->dwConfigVersion = GetDriverFileVersion(pIniVersion,
                                                                     pIniDriver->pConfigFile);
                    pDriver5->dwDriverVersion = GetDriverFileVersion(pIniVersion,
                                                                     pIniDriver->pDriverFile);
                }
            }

            break;

        }

Fail:

        FreeSplStr( pTempDriverPath );
        FreeSplStr( pTempConfigFile );
        FreeSplStr( pTempDataFile );
        FreeSplStr( pTempHelpFile );
        FreeSplMem( SourceStrings );

    } else {

        DBGMSG( DBG_WARNING, ("Failed to alloc driver source strings.\n"));
        pEnd = NULL;
    }

    return pEnd;
}

LPBYTE
CopyIniDriverToDriverInfoVersion(
    IN  PINIENVIRONMENT pIniEnvironment,
    IN  PINIVERSION     pIniVersion,
    IN  PINIDRIVER      pIniDriver,
    IN  LPBYTE          pDriverInfo,
    IN  LPBYTE          pEnd,
    IN  LPWSTR          lpRemote,
    IN  PINISPOOLER     pIniSpooler
)
/*++

Routine Name:

    CopyIniDriverToDriverInfoVersion

Routine Description:

    This routine copy data from pIniDriver to the pDriverInfo as a DRIVER_INFO_VERSION

Arguments:

    pIniEnvironment     pointer to the INIENVIRONMENT structure
    pIniVersion         pointer to the INIVERSION structure.
    pIniDriver          pointer to the INIDRIVER structure.
    pDriverInfo         Buffer big enough to fit a DRIVER_INFO_VERSION and
                        the strings that needs to be packed
    pEnd                pointer to the end of the  pDriverInfo
    lpRemote            flag which determines whether Remote or Local
    pIniSpooler         pointer to the INISPOOLER structure

Return Value:

    Returns the pointer to the "end" of pDriverInfo if success.
    NULL if it failes.

--*/
{
    LPWSTR *pSourceStrings = NULL;
    LPWSTR *SourceStrings = NULL;
    DRIVER_INFO_VERSION *pDriverVersion;
    WCHAR  szDriverVersionDir[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
    DWORD  cStrings;
    LPWSTR pTempDllFile = NULL;

    pDriverVersion = (DRIVER_INFO_VERSION *)pDriverInfo;

    if (!GetDriverVersionDirectory(szDriverVersionDir,
                                  COUNTOF(szDriverVersionDir),
                                  pIniSpooler,
                                  pIniEnvironment,
                                  pIniVersion,
                                  pIniDriver,
                                  lpRemote))
    {
        pEnd = NULL;
    }
    else
    {
        for (cStrings=0; DriverInfoVersionStrings[cStrings] != 0xFFFFFFFF; cStrings++);

        if (!(pSourceStrings = SourceStrings = AllocSplMem(cStrings * sizeof(LPWSTR))))
        {
            DBGMSG( DBG_WARNING, ("Failed to alloc driver source strings.\n"));
            pEnd = NULL;
        }
        else
        {
            *pSourceStrings++ = pIniDriver->pName;
            *pSourceStrings++ = pIniEnvironment->pName;
            *pSourceStrings++ = pIniDriver->pMonitorName;
            *pSourceStrings++ = pIniDriver->pDefaultDataType;
            *pSourceStrings++ = pIniDriver->pszMfgName;
            *pSourceStrings++ = pIniDriver->pszOEMUrl;
            *pSourceStrings++ = pIniDriver->pszHardwareID;
            *pSourceStrings++ = pIniDriver->pszProvider;
            //
            // Pack the strings at the end of pDriverInfo
            //
            pEnd = PackStrings( SourceStrings, pDriverInfo, DriverInfoVersionStrings, pEnd );

            if (pEnd)
            {
                if (pIniDriver->cchPreviousNames == 0)
                {
                    pDriverVersion->pszzPreviousNames = NULL;
                }
                else
                {
                    pEnd = CopyMultiSzFieldToDriverInfo(pIniDriver->pszzPreviousNames,
                                                        pEnd,
                                                        NULL,
                                                        0);
                    if (pEnd)
                    {
                        pDriverVersion->pszzPreviousNames = (LPWSTR) pEnd;
                    }
                }

                if (pEnd)
                {
                    pDriverVersion->cVersion            = pIniDriver->cVersion;
                    pDriverVersion->ftDriverDate        = pIniDriver->ftDriverDate;
                    pDriverVersion->dwlDriverVersion    = pIniDriver->dwlDriverVersion;
                    pDriverVersion->dwFileCount         = 3;

                    if (pIniDriver->pHelpFile && *pIniDriver->pHelpFile)
                    {
                        pDriverVersion->dwFileCount++;
                    }

                    if (pIniDriver->cchDependentFiles)
                    {
                        for (pTempDllFile = pIniDriver->pDependentFiles;
                             *pTempDllFile;
                             pTempDllFile += wcslen(pTempDllFile) + 1,
                             pDriverVersion->dwFileCount++ );
                    }

                    //
                    // Pack in the file names and versions in pDriverVersion->pFileInfo.
                    //
                    pEnd = CopyIniDriverFilesToDriverInfo(pDriverVersion,
                                                          pIniVersion,
                                                          pIniDriver,
                                                          szDriverVersionDir,
                                                          pEnd);

                    //
                    // When we are done, the end shoud not be less than the
                    // start of the buffer plus the driver info version buffer
                    // size. If these have overlapped, we are in serious trouble.
                    //
                    SPLASSERT(pEnd >= pDriverInfo + sizeof(DRIVER_INFO_VERSION));
                }
            }
        }
    }

    FreeSplMem(SourceStrings);

    return pEnd;
}


LPBYTE
CopyIniDriverFilesToDriverInfo(
    IN  LPDRIVER_INFO_VERSION   pDriverVersion,
    IN  PINIVERSION             pIniVersion,
    IN  PINIDRIVER              pIniDriver,
    IN  LPCWSTR                 pszDriverVersionDir,
    IN  LPBYTE                  pEnd
)
/*++

Routine Name:

    CopyIniDriverFilesToDriverInfo

Routine Description:

    This routine copy data from pIniDriver to the pDriverInfo->pFileInfo.
    The number of files is already filled in pDriverInfo->dwFileCount

Arguments:

    pDriverVersion      pointer to a DRIVER_INFO_VERSION structure
    pIniVersion         pointer to the INIVERSION structure.
    pIniDriver          pointer to the INIDRIVER structure.
    pszDriverVersionDir string containing the driver version directory
    pEnd                pointer to the end of the  pDriverInfo

Return Value:

    Returns the pointer to the "end" of pDriverInfo if success.
    NULL if it failes.

--*/
{
    DWORD   dwIndex = 0;
    LPWSTR  pTempDllFile = NULL;
    DWORD dwFileSetCount = pDriverVersion->dwFileCount;

    //
    // Reserve space for DRIVER_FILE_INFO array
    //
    pEnd = (LPBYTE)ALIGN_DOWN(pEnd, ULONG_PTR);
    pEnd -= dwFileSetCount * sizeof(DRIVER_FILE_INFO);

    pDriverVersion->pFileInfo = (DRIVER_FILE_INFO*)pEnd;
    //
    // For each file call FillDriverInfo and fill in the entry
    // in the array of DRIVER_FILE_INFO.
    //
    if (dwIndex >= pDriverVersion->dwFileCount ||
        !(pEnd = FillDriverInfo(pDriverVersion,
                                dwIndex++,
                                pIniVersion,
                                pszDriverVersionDir,
                                pIniDriver->pDriverFile,
                                DRIVER_FILE,
                                pEnd)))
    {
        goto End;
    }

    if (dwIndex >= dwFileSetCount ||
        !(pEnd = FillDriverInfo(pDriverVersion,
                                dwIndex++,
                                pIniVersion,
                                pszDriverVersionDir,
                                pIniDriver->pConfigFile,
                                CONFIG_FILE,
                                pEnd)))
    {
        goto End;
    }

    if (dwIndex >= dwFileSetCount ||
        !(pEnd = FillDriverInfo(pDriverVersion,
                                dwIndex++,
                                pIniVersion,
                                pszDriverVersionDir,
                                pIniDriver->pDataFile,
                                DATA_FILE,
                                pEnd)))
    {
        goto End;
    }

    if (pIniDriver->pHelpFile && *pIniDriver->pHelpFile)
    {
        if (dwIndex >= dwFileSetCount ||
            !(pEnd = FillDriverInfo(pDriverVersion,
                                    dwIndex++,
                                    pIniVersion,
                                    pszDriverVersionDir,
                                    pIniDriver->pHelpFile,
                                    HELP_FILE,
                                    pEnd)))
        {
            goto End;
        }
    }

    if (pIniDriver->cchDependentFiles)
    {
        for (pTempDllFile = pIniDriver->pDependentFiles;
             *pTempDllFile;
             pTempDllFile += wcslen(pTempDllFile) + 1)
             {
                 if (dwIndex >= dwFileSetCount ||
                     !(pEnd = FillDriverInfo(pDriverVersion,
                                             dwIndex++,
                                             pIniVersion,
                                             pszDriverVersionDir,
                                             pTempDllFile,
                                             DEPENDENT_FILE,
                                             pEnd)))
                 {
                        goto End;
                 }

             }
    }

End:

    return pEnd;
}


LPBYTE
FillDriverInfo (
    LPDRIVER_INFO_VERSION   pDriverVersion,
    DWORD                   Index,
    PINIVERSION             pIniVersion,
    LPCWSTR                 pszPrefix,
    LPCWSTR                 pszFileName,
    DRIVER_FILE_TYPE        FileType,
    LPBYTE                  pEnd
    )
/*++

Routine Name:

    FillDriverInfo

Routine Description:

    This routine copy a file name and version into the pDriverInfo->pFileInfo entry

Arguments:

    pDriverVersion      pointer to a DRIVER_INFO_VERSION structure
    Index               index in the pDriverInfo->pFileInfo array of
    pIniVersion         pointer to the INIVERSION structure.
    pszPrefix           prefix string for file name.
                        This should be the driver version directory
    pszFileName         file name, no path
    FileType            file type: Driver, Config, Data, etc
    pEnd                pointer to the end of the  pDriverInfo

Return Value:

    Returns the pointer to the "end" of pDriverInfo if success.
    NULL if it failes.

--*/
{
    LPWSTR  pszTempFilePath = NULL;
    LPBYTE  pszNewEnd = NULL;
    DWORD   dwRet = ERROR_SUCCESS;

    if ((dwRet = StrCatAlloc(&pszTempFilePath,
                            pszPrefix,
                            L"\\",
                            pszFileName,
                            NULL)) != ERROR_SUCCESS)
    {
        SetLastError(dwRet);
        pszNewEnd = NULL;

    }
    else
    {
        //
        // Packs the file name into pDriverInfo
        //
        pszNewEnd = PackStringToEOB(pszTempFilePath, pEnd);
        //
        // Fills in the offset in pDriverVersion where the string was packed.
        // We cannot store pointers because we don't marshall anything else
        // but the structure at the begining of the buffer. We could marshall
        // the array of DRIVER_FILE_INFO but there is no way to update the buffer
        // size between 32 and 64 bits in Win32spl.dll ( UpdateBufferSize ) since we
        // don't know how many files are by that time.
        //
        pDriverVersion->pFileInfo[Index].FileNameOffset = MakeOffset((LPVOID)pszNewEnd, (LPVOID)pDriverVersion);

        pDriverVersion->pFileInfo[Index].FileVersion = 0;

        pDriverVersion->pFileInfo[Index].FileType = FileType;

        if (!GetDriverFileCachedVersion(pIniVersion,
                                        (LPWSTR)pszNewEnd,
                                        &pDriverVersion->pFileInfo[Index].FileVersion))
        {
            pszNewEnd = NULL;
        }


    }

    FreeSplMem(pszTempFilePath);

    return pszNewEnd;
}

BOOL
WriteDriverIni(
    PINIDRIVER      pIniDriver,
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
)
{
    HKEY    hEnvironmentsRootKey, hEnvironmentKey, hDriversKey, hDriverKey;
    HKEY    hVersionKey;
    HANDLE  hToken;
    DWORD   dwLastError=ERROR_SUCCESS;
    PINIDRIVER  pUpdateIniDriver;

    hToken = RevertToPrinterSelf();

    if ((dwLastError = SplRegCreateKey(pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ? pIniSpooler->hckRoot : HKEY_LOCAL_MACHINE,
                                       pIniSpooler->pszRegistryEnvironments,
                                       0,
                                       KEY_WRITE,
                                       NULL,
                                       &hEnvironmentsRootKey,
                                       NULL,
                                       pIniSpooler)) == ERROR_SUCCESS) {
        DBGMSG(DBG_TRACE, ("WriteDriverIni Created key %ws\n", pIniSpooler->pszRegistryEnvironments));

        if ((dwLastError = SplRegCreateKey(hEnvironmentsRootKey,
                                           pIniEnvironment->pName,
                                           0,
                                           KEY_WRITE,
                                           NULL,
                                           &hEnvironmentKey,
                                           NULL,
                                           pIniSpooler)) == ERROR_SUCCESS) {

            DBGMSG(DBG_TRACE, ("WriteDriverIni Created key %ws\n", pIniEnvironment->pName));

            if ((dwLastError = SplRegCreateKey(hEnvironmentKey,
                                               szDriversKey,
                                               0,
                                               KEY_WRITE,
                                               NULL,
                                               &hDriversKey,
                                               NULL,
                                               pIniSpooler)) == ERROR_SUCCESS) {
                DBGMSG(DBG_TRACE, ("WriteDriverIni Created key %ws\n", szDriversKey));
                DBGMSG(DBG_TRACE, ("WriteDriverIni Trying to create version key %ws\n", pIniVersion->pName));
                if ((dwLastError = SplRegCreateKey(hDriversKey,
                                                   pIniVersion->pName,
                                                   0,
                                                   KEY_WRITE,
                                                   NULL,
                                                   &hVersionKey,
                                                   NULL,
                                                   pIniSpooler)) == ERROR_SUCCESS) {

                    DBGMSG(DBG_TRACE, ("WriteDriverIni Created key %ws\n", pIniVersion->pName));
                    if ((dwLastError = SplRegCreateKey(hVersionKey,
                                                       pIniDriver->pName,
                                                       0,
                                                       KEY_WRITE,
                                                       NULL,
                                                       &hDriverKey,
                                                       NULL,
                                                       pIniSpooler)) == ERROR_SUCCESS) {
                        DBGMSG(DBG_TRACE,(" WriteDriverIni Created key %ws\n", pIniDriver->pName));

                        RegSetString(hDriverKey, szConfigurationKey, pIniDriver->pConfigFile, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szDataFileKey, pIniDriver->pDataFile, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szDriverFile,  pIniDriver->pDriverFile, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szHelpFile, pIniDriver->pHelpFile, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szMonitor, pIniDriver->pMonitorName, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szDatatype, pIniDriver->pDefaultDataType, &dwLastError, pIniSpooler);

                        RegSetMultiString(hDriverKey, szDependentFiles, pIniDriver->pDependentFiles, pIniDriver->cchDependentFiles, &dwLastError, pIniSpooler);

                        RegSetMultiString(hDriverKey, szPreviousNames, pIniDriver->pszzPreviousNames, pIniDriver->cchPreviousNames, &dwLastError, pIniSpooler);

                        RegSetDWord(hDriverKey, szDriverVersion, pIniDriver->cVersion, &dwLastError, pIniSpooler);

                        RegSetDWord(hDriverKey, szTempDir, pIniDriver->dwTempDir, &dwLastError, pIniSpooler);

                        RegSetDWord(hDriverKey, szAttributes, pIniDriver->dwDriverAttributes, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szMfgName, pIniDriver->pszMfgName, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szOEMUrl, pIniDriver->pszOEMUrl, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szHardwareID, pIniDriver->pszHardwareID, &dwLastError, pIniSpooler);

                        RegSetString(hDriverKey, szProvider, pIniDriver->pszProvider, &dwLastError, pIniSpooler);

                        RegSetBinaryData(hDriverKey,
                                         szDriverDate,
                                         (LPBYTE)&pIniDriver->ftDriverDate,
                                         sizeof(FILETIME),
                                         &dwLastError,
                                         pIniSpooler);

                        RegSetBinaryData(hDriverKey,
                                         szLongVersion,
                                         (LPBYTE)&pIniDriver->dwlDriverVersion,
                                         sizeof(DWORDLONG),
                                         &dwLastError,
                                         pIniSpooler);

                        SplRegCloseKey(hDriverKey, pIniSpooler);

                        if(dwLastError != ERROR_SUCCESS) {

                            SplRegDeleteKey(hVersionKey, pIniDriver->pName, pIniSpooler);
                        }
                    }

                    SplRegCloseKey(hVersionKey, pIniSpooler);
                }

                SplRegCloseKey(hDriversKey, pIniSpooler);
            }

            SplRegCloseKey(hEnvironmentKey, pIniSpooler);
        }

        SplRegCloseKey(hEnvironmentsRootKey, pIniSpooler);
    }

    ImpersonatePrinterClient( hToken );

    if ( dwLastError != ERROR_SUCCESS ) {

        SetLastError( dwLastError );
        return FALSE;

    } else {
        return TRUE;
    }
}


BOOL
DeleteDriverIni(
    PINIDRIVER      pIniDriver,
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
)
{
    HKEY    hEnvironmentsRootKey, hEnvironmentKey, hDriversKey;
    HANDLE  hToken;
    HKEY    hVersionKey;
    DWORD   LastError= 0;
    DWORD   dwRet = 0;

    hToken = RevertToPrinterSelf();

    if ((dwRet = SplRegCreateKey(pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ? pIniSpooler->hckRoot : HKEY_LOCAL_MACHINE,
                                 pIniSpooler->pszRegistryEnvironments,
                                 0,
                                 KEY_WRITE,
                                 NULL,
                                 &hEnvironmentsRootKey,
                                 NULL,
                                 pIniSpooler) == ERROR_SUCCESS)) {
        if ((dwRet = SplRegOpenKey(hEnvironmentsRootKey,
                                   pIniEnvironment->pName,
                                   KEY_WRITE,
                                   &hEnvironmentKey,
                                   pIniSpooler)) == ERROR_SUCCESS) {

            if ((dwRet = SplRegOpenKey(hEnvironmentKey,
                                       szDriversKey,
                                       KEY_WRITE,
                                       &hDriversKey,
                                       pIniSpooler)) == ERROR_SUCCESS) {
                if ((dwRet = SplRegOpenKey(hDriversKey,
                                           pIniVersion->pName,
                                           KEY_WRITE,
                                           &hVersionKey,
                                           pIniSpooler)) == ERROR_SUCCESS) {

                    if ((dwRet = SplRegDeleteKey(hVersionKey, pIniDriver->pName, pIniSpooler)) != ERROR_SUCCESS) {
                        LastError = dwRet;
                        DBGMSG( DBG_WARNING, ("Error:RegDeleteKey failed with %d\n", dwRet));
                    }

                    SplRegCloseKey(hVersionKey, pIniSpooler);
                } else {
                    LastError = dwRet;
                    DBGMSG( DBG_WARNING, ("Error: RegOpenKeyEx <version> failed with %d\n", dwRet));
                }
                SplRegCloseKey(hDriversKey, pIniSpooler);
            } else {
                LastError = dwRet;
                DBGMSG( DBG_WARNING, ("Error:RegOpenKeyEx <Drivers>failed with %d\n", dwRet));
            }
            SplRegCloseKey(hEnvironmentKey, pIniSpooler);
        } else {
            LastError = dwRet;
            DBGMSG( DBG_WARNING, ("Error:RegOpenKeyEx <Environment> failed with %d\n", dwRet));
        }
        SplRegCloseKey(hEnvironmentsRootKey, pIniSpooler);
    } else {
        LastError = dwRet;
        DBGMSG( DBG_WARNING, ("Error:RegCreateKeyEx <Environments> failed with %d\n", dwRet));
    }

    ImpersonatePrinterClient( hToken );

    if (LastError) {
        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}

VOID
SetOldDateOnSingleDriverFile(
    LPWSTR  pFileName
    )
/*++
Routine Description:

    This routine changes the Date / Time of the file.

    The reason for doing this is that, when AddPrinterDriver is called we move the Driver
    file from the ScratchDiretory to a \version directory.    We then want to mark the original
    file for deletion.    However Integraphs install program ( an possibly others ) rely on the
    file still being located in the scratch directory.   By setting the files date / time
    back to an earlier date / time we will not attemp to copy this file again to the \version
    directory since it will be an older date.

    It is then marked for deletion at reboot.

Arguments:

    pFileName           Just file Name ( not fully qualified )

    pDir                Directory where file to be deleted is located

Return Value:

    None

Note:

--*/
{
    FILETIME  WriteFileTime;
    HANDLE hFile;

    if ( pFileName ) {

        DBGMSG( DBG_TRACE,("Attempting to delete file %ws\n", pFileName));

        hFile = CreateFile(pFileName, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if ( hFile != INVALID_HANDLE_VALUE ) {

            DBGMSG( DBG_TRACE, ("CreateFile %ws succeeded\n", pFileName));

            DosDateTimeToFileTime(0xc3, 0x3000, &WriteFileTime);
            SetFileTime(hFile, &WriteFileTime, &WriteFileTime, &WriteFileTime);
            CloseHandle(hFile);

        } else {
            DBGMSG( DBG_WARNING, ("CreateFile %ws failed with %d\n", pFileName, GetLastError()));
        }
    }
}


VOID
SetOldDateOnDriverFilesInScratchDirectory(
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               FileCount,
    PINISPOOLER         pIniSpooler
    )
{
    HANDLE  hToken;

    SPLASSERT(FileCount);

    //
    //  Run as SYSTEM so we don't run into problems
    //  Changing the file time or date
    //
    hToken = RevertToPrinterSelf();

    do {
        SetOldDateOnSingleDriverFile(pInternalDriverFiles[--FileCount].pFileName);
    } while (FileCount);

    ImpersonatePrinterClient(hToken);

}



PINIVERSION
FindVersionEntry(
    PINIENVIRONMENT pIniEnvironment,
    DWORD dwVersion
    )
{
    PINIVERSION pIniVersion;

    pIniVersion = pIniEnvironment->pIniVersion;

    while (pIniVersion) {
        if (pIniVersion->cMajorVersion == dwVersion) {
            return pIniVersion;
        } else {
            pIniVersion = pIniVersion->pNext;
        }
    }
    return NULL;
}



PINIVERSION
CreateVersionEntry(
    PINIENVIRONMENT pIniEnvironment,
    DWORD dwVersion,
    PINISPOOLER pIniSpooler
    )
{
    PINIVERSION pIniVersion = NULL;
    WCHAR szTempBuffer[MAX_PATH];
    BOOL    bSuccess = FALSE;

try {

    pIniVersion = AllocSplMem(sizeof(INIVERSION));
    if ( pIniVersion == NULL ) {
        leave;
    }

    pIniVersion->signature = IV_SIGNATURE;

    if (!BoolFromHResult(StringCchPrintf(szTempBuffer, COUNTOF(szTempBuffer), L"Version-%d", dwVersion))) {
        leave;
    }

    pIniVersion->pName = AllocSplStr( szTempBuffer );

    if ( pIniVersion->pName == NULL ) {
        leave;
    }

    if (!BoolFromHResult(StringCchPrintf(szTempBuffer, COUNTOF(szTempBuffer), L"%d", dwVersion))) {
        leave;
    }

    pIniVersion->szDirectory = AllocSplStr(szTempBuffer);

    if ( pIniVersion->szDirectory == NULL ) {
        leave;
    }

    pIniVersion->cMajorVersion = dwVersion;

    //
    // Initialize the Driver Files Reference count list.
    //
    pIniVersion->pDrvRefCnt = NULL;

    //
    // Create the version directory.  This will write it out to the
    // registry since it will create a new directory.
    //
    if ( !CreateVersionDirectory( pIniVersion,
                                  pIniEnvironment,
                                  TRUE,
                                  pIniSpooler )) {

        //
        // Something Went Wrong Clean Up Registry Entry
        //
        DeleteDriverVersionIni( pIniVersion, pIniEnvironment, pIniSpooler );
        leave;
    }

    //
    // insert version entry into version list
    //
    InsertVersionList( &pIniEnvironment->pIniVersion, pIniVersion );

    bSuccess = TRUE;

 } finally {

    if ( !bSuccess && pIniVersion != NULL ) {

        FreeSplStr( pIniVersion->pName );
        FreeSplStr( pIniVersion->szDirectory );
        FreeSplMem( pIniVersion );
        pIniVersion = NULL;
    }
 }

    return pIniVersion;
}


BOOL
SetDependentFiles(
    IN  OUT LPWSTR              *ppszDependentFiles,
    IN  OUT LPDWORD             pcchDependentFiles,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               FileCount,
    IN      BOOL                bFixICM,
    IN      BOOL                bMergeDependentFiles
    )
/*++

Routine Description:
    Sets dependentFiles field in IniDriver

Arguments:
    pDependentFiles     : copy the field to this (copy file names only, not full path)
    cchDependentFiles   : this is the character count (inc. \0\0) of the field
    pInternalDriverFiles: array of INTERNAL_DRV_FILE structures
    FileCount           : number of entries in previous array
    bFixICM             : For Win95 drivers ICM files should be used as
                          Color\<icm-file> in the dependent file list since
                          that is how SMB point and print needs it.

Return Value:
    TRUE  success (memory will be allocated)
    FALSE else

--*/
{
    BOOL    bRet                = TRUE;
    LPCWSTR pFileName           = NULL;
    LPWSTR  pStr                = NULL;
    LPWSTR  pszDependentFiles   = NULL;
    DWORD   cchDependentFiles   = 0;
    DWORD  i;

    SPLASSERT(FileCount);

    for ( i = cchDependentFiles = 0; i < FileCount && bRet ; ++i ) {

        pFileName = FindFileName(pInternalDriverFiles[i].pFileName);

        if (pFileName)
        {
            cchDependentFiles += wcslen(pFileName)+1;

            if ( bFixICM && IsAnICMFile(pInternalDriverFiles[i].pFileName) )
                cchDependentFiles += 6;
        }
        else
        {
            bRet = FALSE;

            SetLastError(ERROR_FILE_NOT_FOUND);
        }
    }

    //
    // Make room for the last \0.
    //
    ++(cchDependentFiles);

    if (bRet)
    {
        pszDependentFiles = AllocSplMem(cchDependentFiles*sizeof(WCHAR));

        bRet = pszDependentFiles != NULL;
    }

    if (bRet)
    {
        //
        // Use this to count down the amount of buffer space left which copying
        // the string. Subtract one for the final terminating NULL;
        //
        SIZE_T  cchBufferLeft = cchDependentFiles - 1;

        for ( i=0, pStr = pszDependentFiles; i < FileCount && bRet ; ++i ) {

            pFileName = FindFileName(pInternalDriverFiles[i].pFileName);

            if (pFileName)
            {
                if ( bFixICM && IsAnICMFile(pInternalDriverFiles[i].pFileName) ) {

                    bRet = BoolFromHResult(StringCchCopyEx(pStr, cchBufferLeft, L"Color\\", &pStr, &cchBufferLeft, 0)) &&
                           BoolFromHResult(StrCchCopyMultipleStr(pStr, cchBufferLeft, pFileName, &pStr, &cchBufferLeft));

                } else {

                    bRet = BoolFromHResult(StrCchCopyMultipleStr(pStr, cchBufferLeft, pFileName, &pStr, &cchBufferLeft));
                }
            }
            else
            {
                bRet = FALSE;

                SetLastError(ERROR_FILE_NOT_FOUND);
            }
        }

        //
        // The space for this NULL has been reserved up front.
        //
        *pStr = '\0';
    }

    //
    // If everything succeeded so far, we have two multi-sz strings that
    // represent the old and the new dependent files, what we want to do
    // is to merge the resulting set of files together
    //
    if (bRet && bMergeDependentFiles)
    {
        PWSTR   pszNewDependentFiles = pszDependentFiles;
        DWORD   cchNewDependentFiles = cchDependentFiles;

        pszDependentFiles = NULL; cchDependentFiles = 0;

        bRet = MergeMultiSz(*ppszDependentFiles, *pcchDependentFiles, pszNewDependentFiles, cchNewDependentFiles, &pszDependentFiles, &cchDependentFiles);

        FreeSplMem(pszNewDependentFiles);
    }

    if (bRet)
    {
        *ppszDependentFiles = pszDependentFiles;

        pszDependentFiles = NULL;
        *pcchDependentFiles = cchDependentFiles;
    }
    else
    {
        *pcchDependentFiles = 0;
        *ppszDependentFiles = NULL;
    }

    FreeSplMem(pszDependentFiles);

    return bRet;
}


PINIDRIVER
CreateDriverEntry(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      DWORD               Level,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN      PINISPOOLER         pIniSpooler,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               FileCount,
    IN      DWORD               dwTempDir,
    IN      PINIDRIVER          pOldIniDriver
    )
{
    PINIDRIVER      pIniDriver;
    PDRIVER_INFO_2  pDriver = (PDRIVER_INFO_2)pDriverInfo;
    PDRIVER_INFO_3  pDriver3 = (PDRIVER_INFO_3)pDriverInfo;
    PDRIVER_INFO_4  pDriver4 = (PDRIVER_INFO_4)pDriverInfo;
    PDRIVER_INFO_6  pDriver6 = (PDRIVER_INFO_6)pDriverInfo;
    PDRIVER_INFO_VERSION pDriverVersion = (PDRIVER_INFO_VERSION)pDriverInfo;
    LPWSTR          pszzPreviousNames;
    BOOL            bFail = FALSE, bUpdate;
    BOOL            bCoreFilesSame = TRUE;
    DWORD           dwDepFileIndex, dwDepFileCount, dwLen;

    bUpdate = pOldIniDriver != NULL;

    if ( !(pIniDriver = (PINIDRIVER) AllocSplMem(sizeof(INIDRIVER))) ) {

        return NULL;
    }

    //
    // If it is an update pIniDriver is just a place holder for strings
    //
    if ( !bUpdate ) {

        pIniDriver->signature       = ID_SIGNATURE;
        pIniDriver->cVersion        = pIniVersion->cMajorVersion;

    } else {

        UpdateDriverFileRefCnt(pIniEnvironment, pIniVersion, pOldIniDriver, NULL, 0, FALSE);
        CopyMemory(pIniDriver, pOldIniDriver, sizeof(INIDRIVER));
    }

    //
    // For the core driver files, we want to see if any of them have changed, if
    // they are the same and the behaviour is APD_COPY_NEW_FILES, then we merge
    // the dependent files. This is to handle plugins correctly.
    //
    AllocOrUpdateStringAndTestSame(&pIniDriver->pDriverFile,
                                   FindFileName(pInternalDriverFiles[0].pFileName),
                                   bUpdate ? pOldIniDriver->pDriverFile : NULL,
                                   FALSE,
                                   &bFail,
                                   &bCoreFilesSame);

    AllocOrUpdateStringAndTestSame(&pIniDriver->pConfigFile,
                                   FindFileName(pInternalDriverFiles[1].pFileName),
                                   bUpdate ? pOldIniDriver->pConfigFile : NULL,
                                   FALSE,
                                   &bFail,
                                   &bCoreFilesSame);

    AllocOrUpdateStringAndTestSame(&pIniDriver->pDataFile,
                                   FindFileName(pInternalDriverFiles[2].pFileName),
                                   bUpdate ? pOldIniDriver->pDataFile : NULL,
                                   FALSE,
                                   &bFail,
                                   &bCoreFilesSame);

    pIniDriver->dwTempDir = dwTempDir;

    switch (Level) {
        case 2:
            AllocOrUpdateString(&pIniDriver->pName,
                                pDriver->pName,
                                bUpdate ? pOldIniDriver->pName : NULL,
                                FALSE,
                                &bFail);

            pIniDriver->pHelpFile   = pIniDriver->pDependentFiles
                                    = pIniDriver->pMonitorName
                                    = pIniDriver->pDefaultDataType
                                    = pIniDriver->pszzPreviousNames
                                    = NULL;

            pIniDriver->cchDependentFiles   = pIniDriver->cchPreviousNames
                                            = 0;
            break;

        case 3:
        case 4:
            pIniDriver->pszMfgName    = NULL;
            pIniDriver->pszOEMUrl     = NULL;
            pIniDriver->pszHardwareID = NULL;
            pIniDriver->pszProvider   = NULL;

        case DRIVER_INFO_VERSION_LEVEL :
        case 6:
            AllocOrUpdateString(&pIniDriver->pName,
                                pDriver3->pName,
                                bUpdate ? pOldIniDriver->pName : NULL,
                                FALSE,
                                &bFail);

            dwDepFileIndex          = 3;
            dwDepFileCount          = FileCount - 3;

            //
            // Look for the help file
            //
            {
                LPWSTR pszHelpFile = NULL;

                if (Level == DRIVER_INFO_VERSION_LEVEL)
                {
                    DWORD HelpFileIndex;

                    //
                    // Search for the help file in the array of file infos. All inbox
                    // drivers have a help file, but IHV printer drivers may not have
                    // one. Therefore it is not safe to assume we always have a help file
                    //
                    if (S_OK == FindIndexInDrvFileInfo(pDriverVersion->pFileInfo,
                                                       pDriverVersion->dwFileCount,
                                                       HELP_FILE,
                                                       &HelpFileIndex))
                    {
                        pszHelpFile = (LPWSTR)((LPBYTE)pDriverVersion +
                                               pDriverVersion->pFileInfo[HelpFileIndex].FileNameOffset);
                    }
                }
                else
                {
                    //
                    // Level is 3,4 or 6
                    //
                    pszHelpFile = pDriver3->pHelpFile;
                }

                if (pszHelpFile && *pszHelpFile)
                {
                    AllocOrUpdateString(&pIniDriver->pHelpFile,
                                        FindFileName(pInternalDriverFiles[3].pFileName),
                                        bUpdate ? pOldIniDriver->pHelpFile : NULL,
                                        FALSE,
                                        &bFail);

                    ++dwDepFileIndex;
                    --dwDepFileCount;
                }
                else
                {
                    pIniDriver->pHelpFile = NULL;
                }
            }

            if ( dwDepFileCount ) {

                //
                // We want to merge the dependent files if:
                // 1. None of the Core files have changed.
                // 2. The call was made with APD_COPY_NEW_FILES.
                //
                BOOL    bMergeDependentFiles = bCoreFilesSame && dwFileCopyFlags & APD_COPY_NEW_FILES;

                if ( !bFail &&
                     !SetDependentFiles(&pIniDriver->pDependentFiles,
                                        &pIniDriver->cchDependentFiles,
                                        pInternalDriverFiles+dwDepFileIndex,
                                        dwDepFileCount,
                                        !wcscmp(pIniEnvironment->pName, szWin95Environment),
                                        bMergeDependentFiles) ) {
                    bFail = TRUE;
                }
            } else {

                pIniDriver->pDependentFiles = NULL;
                pIniDriver->cchDependentFiles = 0;
            }

            AllocOrUpdateString(&pIniDriver->pMonitorName,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pMonitorName : pDriver3->pMonitorName,
                                bUpdate ? pOldIniDriver->pMonitorName : NULL,
                                FALSE,
                                &bFail);

            AllocOrUpdateString(&pIniDriver->pDefaultDataType,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pDefaultDataType : pDriver3->pDefaultDataType,
                                bUpdate ? pOldIniDriver->pDefaultDataType : NULL,
                                FALSE,
                                &bFail);

            pIniDriver->cchPreviousNames = 0;

            if ( Level == 4 || Level == 6 || Level == DRIVER_INFO_VERSION_LEVEL) {

                pszzPreviousNames = (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                    pDriverVersion->pszzPreviousNames :
                                    pDriver4->pszzPreviousNames;

                for ( ; pszzPreviousNames && *pszzPreviousNames; pszzPreviousNames += dwLen) {

                    dwLen = wcslen(pszzPreviousNames) + 1;

                    pIniDriver->cchPreviousNames += dwLen;
                }

                if ( pIniDriver->cchPreviousNames ) {

                    pIniDriver->cchPreviousNames++;

                    if ( !(pIniDriver->pszzPreviousNames
                                = AllocSplMem(pIniDriver->cchPreviousNames
                                                            * sizeof(WCHAR))) ) {

                        bFail = TRUE;

                    } else {

                        CopyMemory(
                                (LPBYTE)(pIniDriver->pszzPreviousNames),
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pszzPreviousNames :
                                pDriver4->pszzPreviousNames,
                                pIniDriver->cchPreviousNames * sizeof(WCHAR));
                    }

                } else {

                    pIniDriver->pszzPreviousNames = NULL;
                }

            }

            if (Level == 6 || Level == DRIVER_INFO_VERSION_LEVEL) {

                 AllocOrUpdateString(&pIniDriver->pszMfgName,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pszMfgName : pDriver6->pszMfgName,
                                bUpdate ? pOldIniDriver->pszMfgName : NULL,
                                FALSE,
                                &bFail);

                 AllocOrUpdateString(&pIniDriver->pszOEMUrl,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pszOEMUrl : pDriver6->pszOEMUrl,
                                bUpdate ? pOldIniDriver->pszOEMUrl : NULL,
                                FALSE,
                                &bFail);

                 AllocOrUpdateString(&pIniDriver->pszHardwareID,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pszHardwareID : pDriver6->pszHardwareID,
                                bUpdate ? pOldIniDriver->pszHardwareID : NULL,
                                FALSE,
                                &bFail);

                 AllocOrUpdateString(&pIniDriver->pszProvider,
                                (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                pDriverVersion->pszProvider : pDriver6->pszProvider,
                                bUpdate ? pOldIniDriver->pszProvider : NULL,
                                FALSE,
                                &bFail);

                 pIniDriver->dwlDriverVersion = (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                                pDriverVersion->dwlDriverVersion : pDriver6->dwlDriverVersion;
                 pIniDriver->ftDriverDate     = (Level == DRIVER_INFO_VERSION_LEVEL) ?
                                                pDriverVersion->ftDriverDate : pDriver6->ftDriverDate;
            }

            break;

        default: 
            DBGMSG(DBG_ERROR,
                   ("CreateDriverEntry: level can not be %d", Level) );
            return NULL;
    }

    //
    // Added calls to update driver files ref counts.
    //
    if ( !bFail && UpdateDriverFileRefCnt(pIniEnvironment,pIniVersion,pIniDriver,NULL,0,TRUE) ) {

        //
        // Update the files minor version
        //
        UpdateDriverFileVersion(pIniVersion, pInternalDriverFiles, FileCount);

        //
        // UMPD\KMPD detection
        //
        CheckDriverAttributes(pIniSpooler, pIniEnvironment,
                              pIniVersion, pIniDriver);

        if ( WriteDriverIni(pIniDriver, pIniVersion, pIniEnvironment, pIniSpooler)) {

            if ( bUpdate ) {
                CopyNewOffsets((LPBYTE) pOldIniDriver,
                               (LPBYTE) pIniDriver,
                               IniDriverOffsets);

                //
                // Remove temp files and directory, if any.
                //
                if (pOldIniDriver->dwTempDir && (dwTempDir == 0)) {

                    RemoveDriverTempFiles(pIniSpooler,
                                          pIniEnvironment,
                                          pIniVersion,
                                          pOldIniDriver);
                }

                pOldIniDriver->dwDriverAttributes = pIniDriver->dwDriverAttributes;
                pOldIniDriver->cchDependentFiles = pIniDriver->cchDependentFiles;
                pOldIniDriver->dwTempDir = pIniDriver->dwTempDir;
                pOldIniDriver->cchPreviousNames = pIniDriver->cchPreviousNames;

                if(Level == 6)
                {
                    pOldIniDriver->dwlDriverVersion = pIniDriver->dwlDriverVersion;
                    pOldIniDriver->ftDriverDate     = pIniDriver->ftDriverDate;
                }

                FreeSplMem( pIniDriver );

                return pOldIniDriver;
            } else {
                pIniDriver->pNext = pIniVersion->pIniDriver;
                pIniVersion->pIniDriver = pIniDriver;

                return pIniDriver;
            }
        }
    }

    //
    // Get here only for failure cases.
    //
    FreeStructurePointers((LPBYTE) pIniDriver,
                          (LPBYTE) pOldIniDriver,
                          IniDriverOffsets);
    FreeSplMem( pIniDriver );

    return NULL;

}

BOOL
IsKMPD(
    LPWSTR  pDriverName
    )
/*++
Function Description:  Determines if the driver is kernel or user mode. If the dll
                       cant be loaded or the required export is not found, the spooler
                       assumes that the driver runs in kernel mode.

Parameters:  pDriverName  -- Driver file name

Return Values: TRUE if kernel mode;
               FALSE otherwise

REMARK: to be rewritten to not make any assumption if something went wrong.
--*/
{
    DWORD  dwOldErrorMode, dwUserMode, cb;
    HANDLE hInst;
    BOOL   bReturn = TRUE;
    BOOL   (*pfnDrvQuery)(DWORD, PVOID, DWORD, PDWORD);

    // Avoid popups from loadlibrary failures
    dwOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hInst = LoadLibraryExW(pDriverName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if (hInst) {

        // Check if the printer driver DLL exports DrvQueryDriverInfo entrypoint
        pfnDrvQuery = (BOOL (*)(DWORD, PVOID, DWORD, PDWORD))
                              GetProcAddress(hInst, "DrvQueryDriverInfo");

        if ( pfnDrvQuery ) {

            try {

                if ( pfnDrvQuery(DRVQUERY_USERMODE, &dwUserMode,
                                 sizeof(dwUserMode), &cb) )
                    bReturn = (dwUserMode == 0);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                SetLastError( GetExceptionCode() );
                DBGMSG(DBG_ERROR,
                       ("IsKMPD ExceptionCode %x Driver %ws Error %d\n",
                         GetLastError(), pDriverName, GetLastError() ));
            }
        }

        FreeLibrary(hInst);
    }

    SetErrorMode(dwOldErrorMode);

    return bReturn;
}

BOOL
IniDriverIsKMPD (
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver
    )
/*++
Function Description:
    Determines if the driver is kernel or user mode.
    For Whistler we save pIniDriver->dwDriverAttributes under registry.
    pIniDriver->dwDriverAttributes could be un-initialized at the time we do
    the check to see if a driver is KM or UM.

Parameters:   pIniSpooler          -- pointer to INISPOOLER
              pIniEnvironment      -- pointer to INIENVIRONMENT
              pIniVersion          -- pointer to INVERSION
              pIniDriver           -- pointer to INIDRIVER

Return Values: TRUE if kernel mode;
               FALSE otherwise
--*/
{
    //
    // Call IsKMPD if dwDriverAttributes is not initialized
    //
    if ( pIniDriver->dwDriverAttributes == 0 ) {

        CheckDriverAttributes(pIniSpooler, pIniEnvironment, pIniVersion, pIniDriver);
    }

    return (BOOL)(pIniDriver->dwDriverAttributes & DRIVER_KERNELMODE);
}

VOID
CheckDriverAttributes(
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver
    )
/*++
Function Description: Updates the pIniDriver->dwDriverAttributes field

Parameters:   pIniSpooler          -- pointer to INISPOOLER
              pIniEnvironment      -- pointer to INIENVIRONMENT
              pIniVersion          -- pointer to INVERSION
              pIniDriver           -- pointer to INIDRIVER

Return Values: NONE
--*/
{
    WCHAR       szDriverFile[MAX_PATH];
    PINIDRIVER  pUpdateIniDriver;

    if( GetDriverVersionDirectory(  szDriverFile,
                                    COUNTOF(szDriverFile),
                                    pIniSpooler,
                                    pIniEnvironment,
                                    pIniVersion,
                                    pIniDriver,
                                    NULL)   &&
        StrNCatBuff(szDriverFile,
                    COUNTOF(szDriverFile),
                    szDriverFile,
                    L"\\",
                    FindFileName(pIniDriver->pDriverFile),
                    NULL) == ERROR_SUCCESS )
    {
         pIniDriver->dwDriverAttributes = IsKMPD(szDriverFile) ? DRIVER_KERNELMODE
                                                               : DRIVER_USERMODE;
         //
         // Update other pIniDriver structs with the new driver attributes.
         //
         for (pUpdateIniDriver = pIniVersion->pIniDriver;
              pUpdateIniDriver;
              pUpdateIniDriver = pUpdateIniDriver->pNext) {

             if (pUpdateIniDriver == pIniDriver) {
                 //
                 // Already updated this driver
                 //
                 continue;
             }

             if (!_wcsicmp(FindFileName(pIniDriver->pDriverFile),
                           FindFileName(pUpdateIniDriver->pDriverFile))) {

                 pUpdateIniDriver->dwDriverAttributes = pIniDriver->dwDriverAttributes;
             }
         }
    }
    return;
}

BOOL
FileInUse(
    PINIVERSION pIniVersion,
    LPWSTR      pFileName
    )
/*++
Function Description: Finds if the file specified by pFileName is used by any driver.

Parameters: pIniVersion - pointer to INIVERSION struct where the ref counts are
                          stored
            pFileName   - Name of the driver related file

Return Value: TRUE if file is in Use
              FALSE otherwise
--*/
{
    PDRVREFCNT pdrc;

    if (!pFileName || !(*pFileName)) {
       return FALSE;
    }

    pdrc = pIniVersion->pDrvRefCnt;

    while (pdrc != NULL) {
       if (_wcsicmp(pFileName,pdrc->szDrvFileName) == 0) {
          return (pdrc->refcount > 1);
       }
       pdrc = pdrc->pNext;
    }

    return FALSE;

}

BOOL
FilesInUse(
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver
    )

/*++
Function Description: FilesInUse checks if any of the driver files are used by another
                      driver

Parameters: pIniVersion - pointer to INIVERSION struct where the ref counts are
                          stored
            pIniDriver  - pointer to INIDRIVER struct where the filenames are stored

Return Value: TRUE if any file is in Use
              FALSE otherwise
--*/
{
    LPWSTR pIndex;

    if (FileInUse(pIniVersion,pIniDriver->pDriverFile)) {
       return TRUE;
    }
    if (FileInUse(pIniVersion,pIniDriver->pConfigFile)) {
       return TRUE;
    }
    if (FileInUse(pIniVersion,pIniDriver->pDataFile)) {
       return TRUE;
    }
    if (FileInUse(pIniVersion,pIniDriver->pHelpFile)) {
       return TRUE;
    }

    pIndex = pIniDriver->pDependentFiles;
    while (pIndex && *pIndex) {
       if (FileInUse(pIniVersion,pIndex)) return TRUE;
       pIndex += wcslen(pIndex) + 1;
    }

    return FALSE;
}

BOOL
DuplicateFile(
    PDRVFILE    *ppfile,
    LPCWSTR      pFileName,
    BOOL        *pbDuplicate
    )
/*++
Function Description:   Detects repeated filenames in INIDRIVER struct.
                        The function adds nodes to the list of filenames.

Parameters:   ppfile      - pointer to a list of filenames seen till now
              pFileName   - name of the file
              pbDuplicate - pointer to flag to indicate duplication

Return Values: TRUE - if successful
               FALSE - otherwise
--*/
{
    PDRVFILE    pfile = *ppfile,pfiletemp;

    *pbDuplicate = FALSE;

    if (!pFileName || !(*pFileName)) {
        return TRUE;
    }

    while (pfile) {
       if (pfile->pFileName && (lstrcmpi(pFileName,pfile->pFileName) == 0)) {
           *pbDuplicate = TRUE;
           return TRUE;
       }
       pfile = pfile->pnext;
    }

    if (!(pfiletemp = AllocSplMem(sizeof(DRVFILE)))) {
       return FALSE;
    }
    pfiletemp->pnext = *ppfile;
    pfiletemp->pFileName = pFileName;
    *ppfile = pfiletemp;

    return TRUE;
}


BOOL
InternalIncrement(
    PDRVREFNODE *pNew,
    PDRVFILE    *ppfile,
    PINIVERSION pIniVersion,
    LPCWSTR     pFileName
    )
/*++
Function Description: InternalIncrement calls IncrementFileRefCnt and saves the pointer to
                      to the DRVREFCNT in a DRVREFNODE. These pointers are used to readjust
                      the ref counts if any intermediate call to IncrementFileRefCnt fails.

Parameters: pNew - pointer to a variable which contains a pointer to a DRVREFNODE.
                   The new DRVREFNODE is assigned to this variable.
            ppfile - list of filenames seen so far.
            pIniVersion - pointer to INIVERSION struct.
            pFileName - Name of the file whose ref cnt is to be incremented.

Return Value: TRUE if memory allocation and call to IncrementFileRefCnt succeeds
              FALSE otherwise.

--*/
{
    PDRVREFNODE ptemp;
    BOOL        bDuplicate;

    if (!pFileName || !pFileName[0]) {
        return TRUE;
    }

    if (!DuplicateFile(ppfile, pFileName, &bDuplicate)) {
        return FALSE;
    }

    if (bDuplicate) {
        return TRUE;
    }

    if (!(ptemp = AllocSplMem(sizeof(DRVREFNODE)))) {
        return FALSE;
    }

    ptemp->pNext = *pNew;
    *pNew = ptemp;

    if ((*pNew)->pdrc = IncrementFileRefCnt(pIniVersion,pFileName)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
InternalDecrement(
    PDRVREFNODE *pNew,
    PDRVFILE    *ppfile,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver,
    LPCWSTR     pFileName,
    LPCWSTR     pDirectory,
    DWORD       dwDeleteFlag
    )
/*++
Function Description: InternalDecrement calls DecrementFileRefCnt and saves the pointer to
                      to the DRVREFCNT in a DRVREFNODE. These pointers are used to readjust
                      the ref counts if any intermediate call to DecrementFileRefCnt fails.

Parameters: pNew - pointer to a variable which contains a pointer to a DRVREFNODE.
                   The new DRVREFNODE is assigned to this variable.
            ppfile - list of filenames seen so far.
            pIniEnvironment - pointer to INIENVIRONMENT.
            pIniVersion - pointer to INIVERSION struct.
            pIniDriver - pointer to INIDRIVER.
            pFileName - Name of the file whose ref cnt is to be decremented.
            pDirectory - Directory where the files are stored.
            dwDeleteFlag - Flag to delete files.

Return Value: TRUE if memory allocation and call to DecrementFileRefCnt succeeds
              FALSE otherwise.

--*/

{
    PDRVREFNODE ptemp;
    BOOL        bDuplicate;

    if( !pFileName || !pFileName[0] ){
        return TRUE;
    }

    if (!DuplicateFile(ppfile, pFileName, &bDuplicate)) {
        return FALSE;
    }

    if (bDuplicate) {
        return TRUE;
    }

    if (!(ptemp = AllocSplMem(sizeof(DRVREFNODE)))) {
        return FALSE;
    }

    ptemp->pNext = *pNew;
    *pNew = ptemp;

    if ((*pNew)->pdrc = DecrementFileRefCnt(pIniEnvironment,pIniVersion,pIniDriver,pFileName,
                                            pDirectory,dwDeleteFlag)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
UpdateDriverFileRefCnt(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver,
    LPCWSTR     pDirectory,
    DWORD       dwDeleteFlag,
    BOOL        bIncrementFlag
    )
/*++
Function Description: UpdateDriverRefCnt calls the functions to increment or decrement
                      the ref cnts for the driver related files. If any call fails, the
                      ref cnts are returned to their previous values.

Parameters: pIniEnvironment : pointer to INIENVIRONMENT
            pIniVersion : pointer to INIVERSION struct which contains the ref cnts.
            pIniDriver  : pointer to INIDRIVER struct which contains driver info.
            pDirectory  : Directory where the files are stored.
            dwDeleteFlag: Flag to delete the files.
            bIncrementFlag: TRUE if driver added
                            FALSE if driver deleted.

Return Values: TRUE if success
               FALSE otherwise.
--*/
{
    LPWSTR      pIndex;
    PDRVREFNODE phead=NULL,ptemp=NULL;
    BOOL        bReturn = TRUE;
    PDRVFILE    pfile = NULL,pfiletemp;
    PDRVREFCNT  pDrvRefCnt, *ppDrvRefCnt;

    pIndex = pIniDriver->pDependentFiles;

    if (bIncrementFlag) {
       //
       // Adding driver entry. Increment fileref counts.
       //
       if (!InternalIncrement(&phead,&pfile,pIniVersion,pIniDriver->pDriverFile)
           || !InternalIncrement(&phead,&pfile,pIniVersion,pIniDriver->pConfigFile)
           || !InternalIncrement(&phead,&pfile,pIniVersion,pIniDriver->pHelpFile)
           || !InternalIncrement(&phead,&pfile,pIniVersion,pIniDriver->pDataFile)) {

           bReturn = FALSE;
           goto CleanUp;

       }

       while (pIndex && *pIndex) {
          if (!InternalIncrement(&phead,&pfile,pIniVersion,pIndex)) {
             bReturn = FALSE;
             goto CleanUp;
          }
          pIndex += wcslen(pIndex) + 1;
       }

    } else {
       //
       // Deleting driver entry. Decrement fileref counts.
       //
       if (!InternalDecrement(&phead,&pfile,pIniEnvironment,pIniVersion,pIniDriver,pIniDriver->pDriverFile,
                               pDirectory,dwDeleteFlag)
           || !InternalDecrement(&phead,&pfile,pIniEnvironment,pIniVersion,pIniDriver,pIniDriver->pConfigFile,
                               pDirectory,dwDeleteFlag)
           || !InternalDecrement(&phead,&pfile,pIniEnvironment,pIniVersion,pIniDriver,pIniDriver->pHelpFile,
                               pDirectory,dwDeleteFlag)
           || !InternalDecrement(&phead,&pfile,pIniEnvironment,pIniVersion,pIniDriver,pIniDriver->pDataFile,
                               pDirectory,dwDeleteFlag)) {

           bReturn = FALSE;
           goto CleanUp;
       }

       while (pIndex && *pIndex) {
          if (!InternalDecrement(&phead,&pfile,pIniEnvironment,pIniVersion,pIniDriver,pIndex,pDirectory,dwDeleteFlag)) {
             bReturn = FALSE;
             goto CleanUp;
          }
          pIndex += wcslen(pIndex) + 1;
       }
    }

CleanUp:

    if (bReturn) {
       //
       // When delete the file, remove the RefCnt nodes with count = 0.
       // We want to keep the node when we don't delete the file because the node
       // contains info about how many times the file was updated (dwVersion).
       // Client apps (WINSPOOL.DRV) rely on this when decide to reload the driver files.
       //
       while (ptemp = phead) {
          if (ptemp->pdrc &&
              ptemp->pdrc->refcount == 0 &&
              (dwDeleteFlag & DPD_DELETE_UNUSED_FILES ||
               dwDeleteFlag & DPD_DELETE_ALL_FILES)) {
             FreeSplStr(ptemp->pdrc->szDrvFileName);
             FreeSplMem(ptemp->pdrc);
          }
          phead = phead->pNext;
          FreeSplMem(ptemp);
       }

    } else {
       // Adjust the ref counts.
       while (ptemp = phead) {
          if (ptemp->pdrc) {
             if (bIncrementFlag) {
                ptemp->pdrc->refcount--;
             } else {
                ptemp->pdrc->refcount++;
                if (ptemp->pdrc->refcount == 1) {
                   ptemp->pdrc->pNext = pIniVersion->pDrvRefCnt;
                   pIniVersion->pDrvRefCnt = ptemp->pdrc;
                }
             }
          }
          phead = phead->pNext;
          FreeSplMem(ptemp);
       }

       //
       // When delete the file, remove the RefCnt nodes with count = 0.
       // We want to keep the node when we don't delete the file because the node
       // contains info about how many times the file was updated (dwVersion).
       // Client apps (WINSPOOL.DRV) rely on this when decide to reload the driver files.
       //
       ppDrvRefCnt = &(pIniVersion->pDrvRefCnt);
       while (pDrvRefCnt = *ppDrvRefCnt) {
           if (pDrvRefCnt->refcount == 0 && dwDeleteFlag) {
               *ppDrvRefCnt = pDrvRefCnt->pNext;
               FreeSplStr(pDrvRefCnt->szDrvFileName);
               FreeSplMem(pDrvRefCnt);
           } else {
               ppDrvRefCnt = &(pDrvRefCnt->pNext);
           }
       }
    }

    while (pfiletemp = pfile) {
       pfile = pfile->pnext;
       FreeSplMem(pfiletemp);
    }

    return bReturn;

}

VOID
UpdateDriverFileVersion(
    IN  PINIVERSION         pIniVersion,
    IN  PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN  DWORD               FileCount
    )
{
    PDRVREFCNT pdrc;
    DWORD      dwIndex;

    SplInSem();

    if (pInternalDriverFiles && pIniVersion)
    {
        for (dwIndex = 0 ; dwIndex < FileCount ; dwIndex ++)
        {
            //
            // Don't do anything for non-executable files
            //
            if (!IsEXEFile(pInternalDriverFiles[dwIndex].pFileName))
            {
                continue;
            }

            //
            // Search the entry in pIniVersion's list of files
            //
            for (pdrc = pIniVersion->pDrvRefCnt;
                 pdrc &&
                 lstrcmpi(FindFileName(pInternalDriverFiles[dwIndex].pFileName),
                                       pdrc->szDrvFileName) != 0;
                 pdrc = pdrc->pNext);

            if (pdrc)
            {
                if (pInternalDriverFiles[dwIndex].hFileHandle == INVALID_HANDLE_VALUE)
                {
                    //
                    // We can come in here from a pending upgrade when we don't know the
                    // version.
                    //
                    pdrc->bInitialized = FALSE;
                }
                else if (pInternalDriverFiles[dwIndex].bUpdated)
                {
                    pdrc->dwFileMinorVersion = pInternalDriverFiles[dwIndex].dwVersion;
                    pdrc->bInitialized = TRUE;
                }
            }
        }
    }
}


PDRVREFCNT
IncrementFileRefCnt(
    PINIVERSION pIniVersion,
    LPCWSTR pFileName
    )
/*++
Function Description: IncrementFileRefCnt increments/initializes to 1 the ref count node
                      for pFileName in the IniVersion Struct.

Parameters: pIniversion - pointer to the INIVERSION struct.
            pFileName   - Name of the file whose ref cnt is to be incremented.

Return Values: Pointer to the ref cnt that was incremented
               NULL if memory allocation fails.

--*/
{
    PDRVREFCNT pdrc;

    SplInSem();

    if (!pIniVersion || !pFileName || !(*pFileName)) {
       return NULL;
    }

    pdrc = pIniVersion->pDrvRefCnt;

    while (pdrc != NULL) {

       if (lstrcmpi(pFileName,pdrc->szDrvFileName) == 0) {
          pdrc->refcount++;
          return pdrc;
       }
       pdrc = pdrc->pNext;
    }

    if (!(pdrc = (PDRVREFCNT) AllocSplMem(sizeof(DRVREFCNT)))) return NULL;
    pdrc->refcount = 1;
    pdrc->dwVersion = 0;
    pdrc->dwFileMinorVersion = 0;
    pdrc->dwFileMajorVersion = 0;
    pdrc->bInitialized = 0;
    if (!(pdrc->szDrvFileName = AllocSplStr(pFileName))) {
       FreeSplMem(pdrc);
       return NULL;
    }
    pdrc->pNext = pIniVersion->pDrvRefCnt;
    pIniVersion->pDrvRefCnt = pdrc;

    return pdrc;
}


DWORD
GetEnvironmentScratchDirectory(
    LPWSTR   pDir,
    DWORD    MaxLength,
    PINIENVIRONMENT  pIniEnvironment,
    BOOL    Remote
    )
{
   PINISPOOLER pIniSpooler = pIniEnvironment->pIniSpooler;

   if (Remote) {

       if( StrNCatBuff( pDir,
                        MaxLength,
                        pIniSpooler->pMachineName,
                        L"\\",
                        pIniSpooler->pszDriversShare,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        NULL) != ERROR_SUCCESS )
        return 0;

   } else {

       if( StrNCatBuff( pDir,
                        MaxLength,
                        pIniSpooler->pDir,
                        L"\\",
                        szDriverDir,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        NULL) != ERROR_SUCCESS ) {
           return 0;
       }
   }

   return wcslen(pDir);

}


BOOL
CreateVersionDirectory(
    PINIVERSION pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    BOOL bUpdate,
    PINISPOOLER pIniSpooler
    )
/*++

Routine Description:

    Creates a version directory if necessary for the environment.
    If a version number file exists instead of a directory, a tmp
    directory is created, and pIniVersion is updated appropriately.

    We will update the registry if we need to create a directory by
    re-writing the entire version entry.  This is how the version
    entry in the registry is initially created.

Arguments:

    pIniVersion - Version of drivers that the directory will hold.
                  If the directory already exists, we will modify
                  pIniVersion->szDirectory to a temp name and write
                  it to the registry.

    pIniEnvironment - Environment to use.

    bUpdate - Indicates whether we should write out the IniVersion
              registry entries.  We need to do this if we just alloced
              the pIniVersion, or if we have changed directories.

    pIniSpooler

Return Value:

    BOOL - TRUE   = Version directory and registry created/updated.
           FALSE  = Failure, call GetLastError().

--*/
{
    WCHAR   ParentDir[MAX_PATH];
    WCHAR   Directory[MAX_PATH];
    DWORD   dwParentLen=0;
    DWORD   dwAttributes = 0;
    BOOL    bCreateDirectory = FALSE;
    BOOL    bReturn = TRUE;
    HANDLE  hToken;

    if((StrNCatBuff (  ParentDir,
                       COUNTOF(ParentDir),
                       pIniSpooler->pDir,
                       L"\\drivers\\" ,
                       pIniEnvironment->pDirectory,
                       NULL) != ERROR_SUCCESS ) ||
       (StrNCatBuff (  Directory,
                       COUNTOF(Directory),
                       pIniSpooler->pDir,
                       L"\\drivers\\",
                       pIniEnvironment->pDirectory,
                       L"\\",
                       pIniVersion->szDirectory,
                       NULL) != ERROR_SUCCESS ) )
    {
        bReturn = FALSE;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto End;
    }

    DBGMSG( DBG_TRACE, ("The name of the version directory is %ws\n", Directory));
    dwAttributes = GetFileAttributes( Directory );

    hToken = RevertToPrinterSelf();

    if (dwAttributes == 0xffffffff) {

        bCreateDirectory = TRUE;

    } else if (!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

        LPWSTR pszOldDirectory = pIniVersion->szDirectory;

        DBGMSG(DBG_WARNING, ("CreateVersionDirectory: a file <not a dir> exists by the name of %ws\n", Directory));

        GetTempFileName(ParentDir, L"SPL", 0, Directory);

        //
        // GetTempFileName creates the file.  (Small window where someone
        // else could grab our file name.)
        //
        SplDeleteFile(Directory);

        //
        // We created a new dir, so modify the string.
        //
        dwParentLen = wcslen(ParentDir);
        pIniVersion->szDirectory = AllocSplStr(&Directory[dwParentLen+1]);

        if (!pIniVersion->szDirectory) {

            pIniVersion->szDirectory = pszOldDirectory;

            //
            // Memory allocation failed, just revert back to old and
            // let downwind code handle failure case.
            //
            bReturn = FALSE;

        } else {

            FreeSplStr(pszOldDirectory);
            bCreateDirectory = TRUE;
        }
    }

    if( bCreateDirectory ){

        if( CreateCompleteDirectory( Directory )){

            //
            // Be sure to update the registry entries.
            //
            bUpdate = TRUE;

        } else {

            //
            // Fail the operation since we couldn't create the directory.
            //
            bReturn = FALSE;
        }
    }

    if( bUpdate ){

        //
        // Directory exists, update registry.
        //
        bReturn = WriteDriverVersionIni( pIniVersion,
                                         pIniEnvironment,
                                         pIniSpooler);
    }

    ImpersonatePrinterClient( hToken );

End:

    return bReturn;
}


BOOL
WriteDriverVersionIni(
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
    )
/*++

Routine Description:

    Writes out the driver version registry entries.

    Note: assumes we are running in the system context; callee must
    call RevertToPrinterSelf()!

Arguments:

    pIniVersion - version to write out

    pIniEnvironment - environment the version belongs to

    pIniSpooler

Return Value:

    TRUE  =  success
    FALSE =  failure, call GetLastError()

--*/
{
    HKEY    hEnvironmentsRootKey = NULL;
    HKEY    hEnvironmentKey = NULL;
    HKEY    hDriversKey = NULL;
    HKEY    hVersionKey = NULL;
    DWORD   dwLastError = ERROR_SUCCESS;
    BOOL    bReturnValue;

 try {

     //
     // The local spooler and cluster spoolers do not share the same resgirty location
     // for environments, drivers, processors etc.
     //
    if ( !PrinterCreateKey( pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ? pIniSpooler->hckRoot : HKEY_LOCAL_MACHINE,
                            (LPWSTR)pIniSpooler->pszRegistryEnvironments,
                            &hEnvironmentsRootKey,
                            &dwLastError,
                            pIniSpooler )) {

        leave;
    }

    if ( !PrinterCreateKey( hEnvironmentsRootKey,
                            pIniEnvironment->pName,
                            &hEnvironmentKey,
                            &dwLastError,
                            pIniSpooler )) {

        leave;
    }

    if ( !PrinterCreateKey( hEnvironmentKey,
                            szDriversKey,
                            &hDriversKey,
                            &dwLastError,
                            pIniSpooler )) {


        leave;
    }

    if ( !PrinterCreateKey( hDriversKey,
                            pIniVersion->pName,
                            &hVersionKey,
                            &dwLastError,
                            pIniSpooler )) {

        leave;
    }

    RegSetString( hVersionKey, szDirectory, pIniVersion->szDirectory, &dwLastError, pIniSpooler );
    RegSetDWord(  hVersionKey, szMajorVersion, pIniVersion->cMajorVersion, &dwLastError, pIniSpooler );
    RegSetDWord(  hVersionKey, szMinorVersion, pIniVersion->cMinorVersion ,&dwLastError, pIniSpooler );

 } finally {

    if (hVersionKey)
        SplRegCloseKey(hVersionKey, pIniSpooler);

    if (hDriversKey)
        SplRegCloseKey(hDriversKey, pIniSpooler);

    if (hEnvironmentKey)
        SplRegCloseKey(hEnvironmentKey, pIniSpooler);

    if (hEnvironmentsRootKey)
        SplRegCloseKey(hEnvironmentsRootKey, pIniSpooler);

    if (dwLastError != ERROR_SUCCESS) {

        SetLastError(dwLastError);
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;
    }

 }
    return bReturnValue;
}

BOOL
DeleteDriverVersionIni(
    PINIVERSION pIniVersion,
    PINIENVIRONMENT  pIniEnvironment,
    PINISPOOLER pIniSpooler
    )
{
    HKEY    hEnvironmentsRootKey, hEnvironmentKey, hDriversKey;
    HANDLE  hToken;
    HKEY    hVersionKey;
    BOOL    bReturnValue = FALSE;
    DWORD   Status;

    hToken = RevertToPrinterSelf();

    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryEnvironments, 0,
                         NULL, 0, KEY_WRITE, NULL, &hEnvironmentsRootKey, NULL) == ERROR_SUCCESS) {

        if ( RegOpenKeyEx( hEnvironmentsRootKey, pIniEnvironment->pName, 0,
                           KEY_WRITE, &hEnvironmentKey) == ERROR_SUCCESS) {

            if ( RegOpenKeyEx( hEnvironmentKey, szDriversKey, 0,
                               KEY_WRITE, &hDriversKey) == ERROR_SUCCESS) {

                Status = RegDeleteKey( hDriversKey, pIniVersion->pName );

                if ( Status == ERROR_SUCCESS ) {

                    bReturnValue = TRUE;

                } else {

                    DBGMSG( DBG_WARNING, ( "DeleteDriverVersionIni failed RegDeleteKey %x %ws error %d\n",
                                           hDriversKey,
                                           pIniVersion->pName,
                                           Status ));
                }

                RegCloseKey(hDriversKey);
            }

            RegCloseKey(hEnvironmentKey);
        }

        RegCloseKey(hEnvironmentsRootKey);
    }

    ImpersonatePrinterClient( hToken );

    return bReturnValue;
}



BOOL
SplGetPrinterDriverEx(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion
    )
{
    PINIDRIVER          pIniDriver=NULL;
    PINIVERSION         pIniVersion=NULL;
    PINIENVIRONMENT     pIniEnvironment;
    DWORD               cb;
    LPBYTE              pEnd;
    PSPOOL              pSpool = (PSPOOL)hPrinter;
    PINISPOOLER         pIniSpooler;
    LPWSTR              psz;

    if ((dwClientMajorVersion == (DWORD)-1) && (dwClientMinorVersion == (DWORD)-1)) {
        dwClientMajorVersion = dwMajorVersion;
        dwClientMinorVersion = dwMinorVersion;
    }

    EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {

        LeaveSplSem();
        return FALSE;
    }

    pIniSpooler = pSpool->pIniSpooler;

    if (!(pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler))) {
        LeaveSplSem();
        SetLastError(ERROR_INVALID_ENVIRONMENT);
        return FALSE;
    }

    //
    // If the printer handle is remote or a non-native driver is asked for,
    // then return back a compatible driver; Else return pIniPrinter->pIniDriver
    //
    if ( (pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL) ||
         lstrcmpi(szEnvironment, pIniEnvironment->pName) ) {

        pIniDriver = FindCompatibleDriver(pIniEnvironment,
                                          &pIniVersion,
                                          pSpool->pIniPrinter->pIniDriver->pName,
                                          dwClientMajorVersion,
                                          FIND_COMPATIBLE_VERSION | DRIVER_SEARCH);

        //
        // For Windows 9x drivers if no driver with same name is found
        // then we look for a driver with name in the pszzPreviousNames field
        //
        if ( !pIniDriver                                                &&
             !wcscmp(pIniEnvironment->pName, szWin95Environment)        &&
             (psz = pSpool->pIniPrinter->pIniDriver->pszzPreviousNames) ) {

            for ( ; !pIniDriver && *psz ; psz += wcslen(psz) + 1 )
                pIniDriver = FindCompatibleDriver(pIniEnvironment,
                                                  &pIniVersion,
                                                  psz,
                                                  0,
                                                  FIND_COMPATIBLE_VERSION | DRIVER_SEARCH);

            if (!pIniDriver && Level == 1) {

                //
                // SMB code calls GetPrinterDriver level 1 to findout which
                // driver name to send to Win9x client in GetPrinter info
                // If we do not have Win9x printer driver installed and previous
                // names field is not NULL our best guess is the first one in
                // the pszzPreviousNames. This is expected to be the popular
                // driver on Win9x. If client already has the driver they can
                // print
                //
                psz = pSpool->pIniPrinter->pIniDriver->pszzPreviousNames;
                *pcbNeeded = ( wcslen(psz) + 1 ) * sizeof(WCHAR)
                                                + sizeof(DRIVER_INFO_1);
                if ( *pcbNeeded > cbBuf ) {

                    LeaveSplSem();
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return FALSE;
                }

                ((LPDRIVER_INFO_1)pDriverInfo)->pName = (LPWSTR)(pDriverInfo + sizeof(DRIVER_INFO_1));

                StringCbCopy(((LPDRIVER_INFO_1)pDriverInfo)->pName, cbBuf, psz);

                LeaveSplSem();
                return TRUE;
            }
        }

        if ( !pIniDriver ) {

            LeaveSplSem();
            return FALSE;
        }
    } else {

        pIniDriver = pSpool->pIniPrinter->pIniDriver;

        pIniVersion = FindVersionForDriver(pIniEnvironment, pIniDriver);
    }

    cb = GetDriverInfoSize( pIniDriver, Level, pIniVersion,pIniEnvironment,
                            pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL ?
                                pSpool->pFullMachineName : NULL,
                            pSpool->pIniSpooler );
    *pcbNeeded=cb;

    if (cb > cbBuf) {
        LeaveSplSem();
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    pEnd = pDriverInfo+cbBuf;
    if (!CopyIniDriverToDriverInfo(pIniEnvironment, pIniVersion, pIniDriver,
                                   Level, pDriverInfo, pEnd,
                                   pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL ?
                                       pSpool->pFullMachineName : NULL,
                                   pIniSpooler)) {
        LeaveSplSem();
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }
    LeaveSplSem();
    return TRUE;
}



PINIVERSION
FindCompatibleVersion(
    PINIENVIRONMENT pIniEnvironment,
    DWORD   dwMajorVersion,
    int     FindAnyVersion
    )
{
    PINIVERSION pIniVersion;

    if (!pIniEnvironment) {
        return NULL;
    }

    for ( pIniVersion = pIniEnvironment->pIniVersion;
          pIniVersion != NULL;
          pIniVersion = pIniVersion->pNext ) {

        if ( (FindAnyVersion & DRIVER_UPGRADE) ?
             (pIniVersion->cMajorVersion >= dwMajorVersion) :
             (pIniVersion->cMajorVersion <= dwMajorVersion))
            {

            //
            // Pre version 2 is not comparable with version 2 or newer
            //
            if ( dwMajorVersion >= 2                                            &&
                 pIniVersion->cMajorVersion < 2                                 &&
                 ((FindAnyVersion & FIND_ANY_VERSION)==FIND_COMPATIBLE_VERSION) &&
                 lstrcmpi(pIniEnvironment->pName, szWin95Environment) ) {

                return NULL;
            }

            return pIniVersion;
        }
    }

    return NULL;
}


PINIDRIVER
FindCompatibleDriver(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION * ppIniVersion,
    LPWSTR pDriverName,
    DWORD dwMajorVersion,
    int FindAnyDriver
    )
{
    PINIVERSION pIniVersion;
    PINIDRIVER  pIniDriver = NULL;

    try {

        *ppIniVersion = NULL;

        if (!pIniEnvironment) {
            leave;
        }

        pIniVersion = FindCompatibleVersion( pIniEnvironment, dwMajorVersion, FindAnyDriver );

        if ( pIniVersion == NULL) {
            leave;
        }

        while (pIniVersion){

            //
            // Pre version 2 is not comparable with version 2 or newer
            //
            if ( dwMajorVersion >= 2                                              &&
                 ((FindAnyDriver & FIND_ANY_VERSION) == FIND_COMPATIBLE_VERSION)  &&
                 pIniVersion->cMajorVersion < 2 ) {

                break;
            }

            if ( pIniDriver = FindDriverEntry( pIniVersion, pDriverName ) ) {

                //
                // We found the driver. Break the loop and return succesfully.
                //
                *ppIniVersion = pIniVersion;
                leave;
            }

            pIniVersion = pIniVersion->pNext;
        }

    } finally {

       if ( pIniDriver == NULL ) {

           SetLastError(ERROR_UNKNOWN_PRINTER_DRIVER);
       }
    }

    return pIniDriver;

}


VOID
InsertVersionList(
    PINIVERSION* ppIniVersionHead,
    PINIVERSION pIniVersion
    )

/*++

Routine Description:

    Insert a version entry into the verions linked list.

    Versions are stored in decending order (2, 1, 0) so that
    when a version is needed, we get the highest first.

Arguments:

    ppIniVersionHead - Pointer to the head of the pIniVersion head.

    pIniVersion - Version structure we want to add.

Return Value:

--*/

{
    SplInSem();

    //
    // Insert into single-linked list code.  We take the address of
    // the head pointer so that we can avoid special casing the
    // insert into empty list case.
    //
    for( ; *ppIniVersionHead; ppIniVersionHead = &(*ppIniVersionHead)->pNext ){

        //
        // If the major version of the pIniVersion we're inserting
        // is > the next pIniVersion on the list, insert it before
        // that one.
        //
        // 4 3 2 1
        //    ^
        // New '3' gets inserted here.  (Note: duplicate versions should
        // never be added.)
        //
        if( pIniVersion->cMajorVersion > (*ppIniVersionHead)->cMajorVersion ){
            break;
        }
    }

    //
    // Link up the new version.
    //
    pIniVersion->pNext = *ppIniVersionHead;
    *ppIniVersionHead = pIniVersion;
}



PINIDRIVER
FindDriverEntry(
    PINIVERSION pIniVersion,
    LPWSTR pszName
    )
{
    PINIDRIVER pIniDriver;

    if (!pIniVersion) {
        return NULL;
    }

    if (!pszName || !*pszName) {
        DBGMSG( DBG_WARNING, ("Passing a Null Printer Driver Name to FindDriverEntry\n"));
        return NULL;
    }

    pIniDriver = pIniVersion->pIniDriver;

    //
    // Only return the driver if it is not pending deletion.
    //
    while (pIniDriver) {
        if (!lstrcmpi(pIniDriver->pName, pszName) &&
            !(pIniDriver->dwDriverFlags & PRINTER_DRIVER_PENDING_DELETION)) {
            return pIniDriver;
        }
        pIniDriver = pIniDriver->pNext;
    }
    return NULL;
}


VOID
DeleteDriverEntry(
   PINIVERSION pIniVersion,
   PINIDRIVER pIniDriver
   )
{   PINIDRIVER pPrev, pCurrent;
    if (!pIniVersion) {
        return;
    }

    if (!pIniVersion->pIniDriver) {
        return;
    }
    pPrev = pCurrent = NULL;
    pCurrent = pIniVersion->pIniDriver;

    while (pCurrent) {
        if (pCurrent == pIniDriver) {
            if (pPrev == NULL) {
                pIniVersion->pIniDriver = pCurrent->pNext;
            } else{
                pPrev->pNext = pCurrent->pNext;
            }
            //
            // Free all the entries in the entry
            //
            FreeStructurePointers((LPBYTE) pIniDriver, NULL, IniDriverOffsets);
            FreeSplMem(pIniDriver);
            return;
        }
        pPrev = pCurrent;
        pCurrent = pCurrent->pNext;
    }
    return;
}

BOOL CheckFileCopy(
    PINIVERSION         pIniVersion,
    LPWSTR              pTargetFile,
    LPWSTR              pSourceFile,
    PWIN32_FIND_DATA    pSourceData,
    DWORD               dwSourceVersion,
    DWORD               dwFileCopyFlags,
    LPBOOL              pbCopyFile,
    LPBOOL              pbTargetExists)

/*++
Function Description: This functions determines if the target exists and if it should
                      be overwritten.

Parameters:

Return Values: TRUE if successful; FALSE otherwise.
--*/

{
    WIN32_FIND_DATA DestFileData, SourceFileData, *pSourceFileData;
    HANDLE          hFileExists;
    BOOL            bReturn = FALSE, bSourceFileHandleCreated = FALSE;
    DWORD           dwTargetVersion = 0;

    LeaveSplSem();

    *pbCopyFile = *pbTargetExists = FALSE;

    pSourceFileData = pSourceData ? pSourceData : &SourceFileData;

    //
    // Get Source File Date & Time Stamp
    //
    hFileExists = FindFirstFile( pSourceFile, pSourceFileData );

    if (hFileExists == INVALID_HANDLE_VALUE) {
        goto CleanUp;
    }

    FindClose( hFileExists );

    //
    // Get Target File Date Time
    //
    hFileExists = FindFirstFile( pTargetFile, &DestFileData );

    if (hFileExists == INVALID_HANDLE_VALUE) {

        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            //
            // Copy the source since there is no target
            //
            *pbCopyFile = TRUE;
            bReturn = TRUE;
        }

        goto CleanUp;
    }

    *pbTargetExists = TRUE;
    FindClose(hFileExists);

    //
    //  Check Source File version and LastWrite Times vs Target File if only new files
    //  are to be copied
    //
    if (dwFileCopyFlags == APD_COPY_NEW_FILES) {

        EnterSplSem();
        bReturn = GetDriverFileCachedVersion (pIniVersion, pTargetFile, &dwTargetVersion);
        LeaveSplSem();

        if(!bReturn) {
            goto CleanUp;
        }

        if (dwSourceVersion > dwTargetVersion) {
            *pbCopyFile = TRUE;

        } else {

            if (dwSourceVersion == dwTargetVersion) {

                if(CompareFileTime(&(pSourceFileData->ftLastWriteTime),
                                   &DestFileData.ftLastWriteTime)
                                   != FIRST_FILE_TIME_GREATER_THAN_SECOND) {

                    //
                    // Target File is up to date. It doesn't need to be updated.
                    //
                    DBGMSG( DBG_TRACE, ("UpdateFile Target file is up to date\n"));

                } else {
                    *pbCopyFile = TRUE;
                }
            }
        }
    } else {
        *pbCopyFile = TRUE;
    }

    bReturn = TRUE;

CleanUp:

    EnterSplSem();

    return bReturn;
}

BOOL
UpdateFile(
    PINIVERSION pIniVersion,
    HANDLE      hSourceFile,
    LPWSTR      pSourceFile,
    DWORD       dwVersion,
    LPWSTR      pDestDir,
    DWORD       dwFileCopyFlags,
    BOOL        bImpersonateOnCreate,
    LPBOOL      pbFileUpdated,
    LPBOOL      pbFileMoved,
    BOOL        bSameEnvironment,
    BOOL        bWin95Environment
    )

/*++
Function Description: The file times are checked to verify if the file needs to be copied.

                      If the file already exists in the version directory, then it is copied
                      into ...\environment\version\new. The corresponding file, which is
                      present in environment\version, is copied to \version\old. The new file
                      is marked for move on REBOOT.

                      New files are copied into env\version.

Parameters: hSourceFile          --  file handle
            pSourceFile          --  file name
            pDestDir             --  driver directory (e.g system32\spool\w32x86\3)
            bImpersonateOnCreate --  flag to impersonate client on any file creation
            pbFilesUpdated       --  Have any new files been copied or moved ?
            pbFileMoved          --  Have any old files been moved ?
            bSameEnvironment     --  flag to indicate if the machine env == driver env
            bWin95Environment    --  flag to indicate if the driver env == win95

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    HANDLE  hToken = INVALID_HANDLE_VALUE;
    WCHAR   szTargetFile[MAX_PATH], szNewFile[MAX_PATH];
    LPWSTR  pFileName;
    BOOL    bReturn = FALSE, bCopyFile, bTargetExists;
    DWORD   FileAttrib;

    WIN32_FIND_DATA SourceFileData;

    *pbFileMoved = FALSE;

    pFileName = wcsrchr(pSourceFile, L'\\');
    if (!pFileName || !pDestDir || !*pDestDir) {
        //
        // Invalid file name. Fail the call.
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        goto CleanUp;
    }

    //
    // Set the target directory.
    //
    if(StrNCatBuff(szTargetFile,
                   COUNTOF(szTargetFile),
                   pDestDir,
                   NULL) != ERROR_SUCCESS)
    {
         goto CleanUp;
    }

    if (bWin95Environment && IsAnICMFile(pSourceFile)) {
        if((StrNCatBuff(szTargetFile,
                       COUNTOF(szTargetFile),
                       szTargetFile,
                       L"\\Color",
                       NULL)!=ERROR_SUCCESS))
        {
             goto CleanUp;
        }
    }

    if((StrNCatBuff(szTargetFile,
                   COUNTOF(szTargetFile),
                   szTargetFile,
                   pFileName,
                   NULL)!=ERROR_SUCCESS))
    {
         goto CleanUp;
    }

    //
    // Check if the file has to be copied given the version, timestamp and flags.
    //
    if (!CheckFileCopy(pIniVersion, szTargetFile, pSourceFile, &SourceFileData, dwVersion,
                       dwFileCopyFlags, &bCopyFile, &bTargetExists)) {
        goto CleanUp;
    }

    if (bCopyFile) {

        if (!bImpersonateOnCreate) {
            hToken = RevertToPrinterSelf();
        }

        if((StrNCatBuff(szNewFile,
                        COUNTOF(szNewFile),
                        pDestDir,
                        L"\\New",
                        pFileName,
                        NULL)!=ERROR_SUCCESS))
        {
           goto CleanUp;
        }

        //
        // Leave Spooler semaphore for copying the files
        //
        LeaveSplSem();

        if (!InternalCopyFile(hSourceFile, &SourceFileData,
                              szNewFile, OVERWRITE_IF_TARGET_EXISTS)) {

            //
            // InternalCopyFile failed. Fail the call. It isn't obvious what is the reason
            // we call InternalCopyFile instead of CopyFile.
            //
            EnterSplSem();
            goto CleanUp;
        }

        EnterSplSem();

    } else {

        *pbFileMoved = TRUE;
        bReturn = TRUE;
        goto CleanUp;
    }

    if (bCopyFile) {

        if (!bSameEnvironment) {

            if (bTargetExists) {

                DWORD dwAttr;

                dwAttr = GetFileAttributes(szTargetFile);

                //
                // Check if the function succeeded and the target file is write protected.
                // Some non native drivers, notably Win 9x drivers, can be copied over to
                // the drivers directory and have the read only attribute. When we update
                // a non native driver, we want to make sure that it is not write protected.
                //
                if (dwAttr != (DWORD)-1 &&
                    dwAttr & FILE_ATTRIBUTE_READONLY) {

                    SetFileAttributes(szTargetFile, dwAttr & ~FILE_ATTRIBUTE_READONLY);
                }
            }

            if (!SplMoveFileEx(szNewFile, szTargetFile, MOVEFILE_REPLACE_EXISTING)) {
                // MoveFile failed
                goto CleanUp;
            }

        } else {

            if (bTargetExists) {

                //
                // Move the file on REBOOT. It may get moved earlier if the driver
                // can be unloaded.
                //
                if (SplMoveFileEx(szNewFile, szTargetFile, MOVEFILE_DELAY_UNTIL_REBOOT)) {

                    *pbFileMoved = TRUE;
                    //
                    // Don't fail the call here. MoveFileEx with MOVEFILE_DELAY_UNTIL_REBOOT will just write the registry.
                    // We'll need this only if the driver is still loaded, which we find out only later.
                    // If the driver is not loaded, we'll actually move these files later and this call won't make sense.
                    // So,don't fail the api call at this point because MoveFileEx. Hopefully, one day MoveFileEx won't
                    // be hard-coded to write only two PendingFileRenameOperations values.
                    //
                }

            } else {

                if (!SplMoveFileEx(szNewFile, szTargetFile, MOVEFILE_REPLACE_EXISTING)) {
                    goto CleanUp;
                }
                *pbFileMoved = TRUE;
            }
        }

        *pbFileUpdated = TRUE;
    }

    bReturn = TRUE;

CleanUp:

    if (hToken != INVALID_HANDLE_VALUE) {
        ImpersonatePrinterClient(hToken);
    }

    return bReturn;
}


BOOL
CopyAllFilesAndDeleteOldOnes(
    PINIVERSION         pIniVersion,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    LPWSTR              pDestDir,
    DWORD               dwFileCopyFlags,
    BOOL                bImpersonateOnCreate,
    LPBOOL              pbFileMoved,
    BOOL                bSameEnvironment,
    BOOL                bWin95Environment
    )
/*++

Function Description: This function loops thru all the files in the driver_info
                      struct and calls an update routine.

Parameters: pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
            dwFileCount          -- number of files in file set
            pDestDir             --  driver directory (e.g system32\spool\w32x86\3)
            bImpersonateOnCreate --  flag to impersonate client on any file creation
            pbFileMoved          --  Have any old files been moved ?
            bSameEnvironment     --  flag to indicate if the machine env == driver env
            bWin95Environment    --  flag to indicate if the driver env == win95

Return Values: TRUE if successful; FALSE otherwise

--*/
{
    BOOL        bRet = TRUE;
    DWORD       dwCount;
    BOOL        bFilesUpdated;
    BOOL        bFilesMoved = TRUE;

    *pbFileMoved = TRUE;

    for (dwCount = 0 ; dwCount < dwFileCount ; ++dwCount) {

        bFilesUpdated = FALSE;

        if (!(bRet = UpdateFile(pIniVersion,
                                pInternalDriverFiles[dwCount].hFileHandle,
                                pInternalDriverFiles[dwCount].pFileName,
                                pInternalDriverFiles[dwCount].dwVersion,
                                pDestDir,
                                dwFileCopyFlags,
                                bImpersonateOnCreate,
                                &bFilesUpdated,
                                &bFilesMoved,
                                bSameEnvironment,
                                bWin95Environment))) {

            //
            // Files could not be copied correctly.
            //
            break;
        }

        if (bFilesUpdated) {
            pInternalDriverFiles[dwCount].bUpdated = TRUE;
        }

        if(!bFilesMoved) {
            *pbFileMoved = FALSE;
        }
    }

    return bRet;
}


BOOL
CopyFilesToFinalDirectory(
    PINISPOOLER         pIniSpooler,
    PINIENVIRONMENT     pIniEnvironment,
    PINIVERSION         pIniVersion,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    DWORD               dwFileCopyFlags,
    BOOL                bImpersonateOnCreate,
    LPBOOL              pbFilesMoved
    )

/*++

Function Description: This function copies all the new files into the the correct
                      directory i.e ...\environment\version.

                      The files which already exist in the version directory are copied
                      in ...\environment\version\new. The corresponding files, which are
                      present in environment\version, are copied to \version\old.

                      The common files are upgraded when the old files can be unloaded
                      from either the kernel (for KMPD) or the spooler (for UMPD)

Parameters: pIniSpooler          --  pointer to the INISPOOLER struct
            pIniEnvironment      --  pointer to the driver environment struct
            pIniVersion          --  pointer to the driver version struct
            pInternalDriverFiles -- array of INTERNAL_DRV_FILE structures
            dwFileCount          -- number of files in file setes
            dwFileCount          --  number of files
            bImpersonateOnCreate --  flag to impersonate client on any file creation
            pbFileMoved          --  Have any old files been moved ?

Return Values: TRUE if successful; FALSE otherwise

--*/

{
    WCHAR   szDestDir[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
    LPWSTR  pStringEnd = NULL;
    DWORD   dwIndex;
    BOOL    bRet = FALSE, bSameEnvironment, bWin95Environment;

    //
    // Initialize szDestDir to an empty string. This is to due a bogus prefix
    // bug. In practice GetEnvironment scratch directory cannot fail under
    // these conditions.
    //
    szDestDir[0] = L'\0';

    SplInSem();

    GetEnvironmentScratchDirectory( szDestDir, MAX_PATH, pIniEnvironment, FALSE );

    if (!BoolFromHResult(StringCchCat(szDestDir, COUNTOF(szDestDir), L"\\")) ||
        !BoolFromHResult(StringCchCat(szDestDir, COUNTOF(szDestDir),  pIniVersion->szDirectory))) {
        goto CleanUp;
    }

    //
    // pStringEnd points to the NULL character in szDestDir
    //
    pStringEnd = (LPWSTR) szDestDir + wcslen(szDestDir);

    bSameEnvironment = !lstrcmpi(pIniEnvironment->pName, szEnvironment);

    //
    // Create the Old directory
    //
    if (!BoolFromHResult(StringCchCat(szDestDir, COUNTOF(szDestDir), L"\\Old"))) {
        goto CleanUp;
    }

    if (!DirectoryExists(szDestDir) &&
        !CreateDirectoryWithoutImpersonatingUser(szDestDir)) {

        //
        // Failed to create Old directory
        //
        goto CleanUp;
    }
    *pStringEnd = L'\0';

    //
    // Create the New Directory.
    //
    if (!BoolFromHResult(StringCchCat(szDestDir, COUNTOF(szDestDir), L"\\New"))) {
        goto CleanUp;
    }

    if (!DirectoryExists(szDestDir) &&
        !CreateDirectoryWithoutImpersonatingUser(szDestDir)) {

         //
         // Failed to create New directory
         //
         goto CleanUp;
    }
    *pStringEnd = L'\0';

    //
    // Create the Color Directory if necessary
    //
    if (!wcscmp(pIniEnvironment->pName, szWin95Environment)) {

        for (dwIndex = 0 ; dwIndex < dwFileCount ; ++dwIndex) {

            //
            // Search for ICM files that need the Color directory
            //
            if (IsAnICMFile(pInternalDriverFiles[dwIndex].pFileName)) {

                //
                // Create the Color Directory
                //
                if (!BoolFromHResult(StringCchCat(szDestDir, COUNTOF(szDestDir), L"\\Color"))) {
                    goto CleanUp;
                }

                if (!DirectoryExists(szDestDir) &&
                    !CreateDirectoryWithoutImpersonatingUser(szDestDir)) {

                     //
                     // Failed to create Color directory.
                     //
                     goto CleanUp;
                }
                *pStringEnd = L'\0';

                break;
            }
        }

        bWin95Environment = TRUE;

    } else {

        bWin95Environment = FALSE;
    }

    DBGMSG(DBG_CLUSTER, ("CopyFilesToFinalDirectory szDestDir "TSTR"\n", szDestDir));

    bRet = CopyAllFilesAndDeleteOldOnes(pIniVersion,
                                        pInternalDriverFiles,
                                        dwFileCount,
                                        szDestDir,
                                        dwFileCopyFlags,
                                        bImpersonateOnCreate,
                                        pbFilesMoved,
                                        bSameEnvironment,
                                        bWin95Environment);

CleanUp:

    if (!bRet) {
        SPLASSERT( GetLastError() != ERROR_SUCCESS );
    }

    return bRet;
}


DWORD
GetDriverVersionDirectory(
    LPWSTR pDir,
    DWORD  MaxLength,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver,
    LPWSTR lpRemote
    )
{
    WCHAR  pTempDir[MAX_PATH];

    if (lpRemote) {

        if( StrNCatBuff(pDir,
                        MaxLength,
                        lpRemote,
                        L"\\",
                        pIniSpooler->pszDriversShare,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        L"\\",
                        pIniVersion->szDirectory,
                        NULL) != ERROR_SUCCESS ) {
            return 0;
        }

    } else {

        if( StrNCatBuff(pDir,
                        MaxLength,
                        pIniSpooler->pDir,
                        L"\\",
                        szDriverDir,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        L"\\",
                        pIniVersion->szDirectory,
                        NULL) != ERROR_SUCCESS ) {
            return 0;
        }

    }

    if (pIniDriver && pIniDriver->dwTempDir) {

        StringCchPrintf(pTempDir, COUNTOF(pTempDir), L"%d", pIniDriver->dwTempDir);

        if( StrNCatBuff(pDir,
                        MaxLength,
                        pDir,
                        L"\\",
                        pTempDir,
                        NULL) != ERROR_SUCCESS ) {
            return 0;
        }
    }

    return wcslen(pDir);
}



PINIVERSION
FindVersionForDriver(
    PINIENVIRONMENT pIniEnvironment,
    PINIDRIVER pIniDriver
    )
{
    PINIVERSION pIniVersion;
    PINIDRIVER pIniVerDriver;

    pIniVersion = pIniEnvironment->pIniVersion;

    while (pIniVersion) {

        pIniVerDriver = pIniVersion->pIniDriver;

        while (pIniVerDriver) {

            if ( pIniVerDriver == pIniDriver ) {

                return pIniVersion;
            }
            pIniVerDriver = pIniVerDriver->pNext;
        }
        pIniVersion = pIniVersion->pNext;
    }
    return NULL;
}



LPWSTR
GetFileNameInScratchDir(
    LPWSTR          pPathName,
    PINIENVIRONMENT pIniEnvironment
)
{
    WCHAR   szDir[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
    LPCWSTR pszFileName;
    LPWSTR  pszReturn = NULL;

    //
    // Initialize the szDir to a known string value. This was a bogus prefix bug,
    // but, it is probably a good idea anyway.
    //
    szDir[0] = L'\0';

    if ((pszFileName = FindFileName(pPathName)) &&
        wcslen(pszFileName) < MAX_PATH          &&
        GetEnvironmentScratchDirectory(szDir, (DWORD)(COUNTOF(szDir) - wcslen(pszFileName) - 2), pIniEnvironment, FALSE) &&
        BoolFromHResult(StringCchCat(szDir, COUNTOF(szDir), L"\\")) &&
        BoolFromHResult(StringCchCat(szDir, COUNTOF(szDir), pszFileName)))
    {
       pszReturn = AllocSplStr(szDir);
    }

    return pszReturn;
}


BOOL
CreateInternalDriverFileArray(
    DWORD               Level,
    LPBYTE              pDriverInfo,
    INTERNAL_DRV_FILE **ppInternalDriverFiles,
    LPDWORD             pFileCount,
    BOOL                bUseScratchDir,
    PINIENVIRONMENT     pIniEnvironment,
    BOOL                bFileNamesOnly
    )
/*++

Routine Description:

    Creates the array of INTERNAL_DRV_FILE structures.
    For each file in file set, we build an array with information
    about the file: file name, driver minor version, file handle,
    if the file was updated.
    The field regrading updating is initialized to FALSE and modified later.

Arguments:

    Level                   : level of driver info structure
    pDriverInfo             : pointer to driver info structure
    pInternalDriverFiles    : allocate memory to this array for list of file names
    pFileCount              : will point to number of files on return
    bUseScratchDir          : Should a scratch directory be used for file names
    pIniEnvironment         : environment the version belongs to

Return Value:
    TRUE  =  success
        *ppInternalDriverFiles will (routine allocates memory) give
        the internal list of files
        *pFileCount will give number of files specified by the driver info
    FALSE =  failure, call GetLastError()

--*/
{
    LPWSTR  pStr;
    DWORD   dDepFileCount = 0, dFirstDepFileIndex, Count, Size;
    BOOL    bReturnValue = TRUE, bInSplSem = TRUE;
    PDRIVER_INFO_2 pDriverInfo2 = NULL;
    PDRIVER_INFO_3 pDriverInfo3 = NULL;
    PDRIVER_INFO_VERSION pDriverVersion = NULL;
    LPWSTR  pDependentFiles = NULL, pDependentFilestoFree = NULL;
    LPWSTR  pFileName = NULL;

    SplInSem();

    if ( !ppInternalDriverFiles || !pFileCount) {
        bReturnValue = FALSE;
        SetLastError(ERROR_INVALID_DATA);
        goto End;
    }

    *pFileCount = 0;
    *ppInternalDriverFiles = NULL;

    switch (Level) {
        case 2:
                *pFileCount = 3;
                pDriverInfo2 = (PDRIVER_INFO_2) pDriverInfo;
                break;

        case 3:
        case 4:
        case 6:
                *pFileCount = 3;
                dFirstDepFileIndex = 3;
                pDriverInfo3 = (PDRIVER_INFO_3) pDriverInfo;

                //
                // For any environment other than Win95 we build dependent files
                // without other DRIVER_INFO_3 files (i.e. ConfigFile etc)
                //
                if ( _wcsicmp(pIniEnvironment->pName, szWin95Environment) ) {

                    if ( !BuildTrueDependentFileField(pDriverInfo3->pDriverPath,
                                                      pDriverInfo3->pDataFile,
                                                      pDriverInfo3->pConfigFile,
                                                      pDriverInfo3->pHelpFile,
                                                      pDriverInfo3->pDependentFiles,
                                                      &pDependentFiles) ) {
                         bReturnValue = FALSE;
                         SetLastError(ERROR_INVALID_DATA);
                         pDependentFilestoFree = NULL;
                         goto End;
                    }
                    pDependentFilestoFree = pDependentFiles;

                } else {

                    pDependentFiles = pDriverInfo3->pDependentFiles;
                }

                if ( pDriverInfo3->pHelpFile && *pDriverInfo3->pHelpFile ) {

                    if(wcslen(pDriverInfo3->pHelpFile) >= MAX_PATH) {
                        bReturnValue = FALSE;
                        SetLastError(ERROR_INVALID_DATA);
                        *pFileCount = 0;
                        goto End;
                    }
                    ++*pFileCount;
                    ++dFirstDepFileIndex;
                }

                for ( dDepFileCount = 0, pStr = pDependentFiles ;
                      pStr && *pStr ;
                      pStr += wcslen(pStr) + 1) {

                        if(wcslen(pStr) >= MAX_PATH) {
                            bReturnValue = FALSE;
                            SetLastError(ERROR_INVALID_DATA);
                            *pFileCount = 0;
                            goto End;
                        }
                        ++dDepFileCount;
                      }

                *pFileCount += dDepFileCount;
                break;

        case DRIVER_INFO_VERSION_LEVEL:

                pDriverVersion = (LPDRIVER_INFO_VERSION)pDriverInfo;
                *pFileCount = pDriverVersion->dwFileCount;

                break;
        default:
                bReturnValue = FALSE;
                SetLastError(ERROR_INVALID_DATA);
                goto End;
                break;

    }

    try {
        *ppInternalDriverFiles = (INTERNAL_DRV_FILE *) AllocSplMem(*pFileCount * sizeof(INTERNAL_DRV_FILE));

        if ( !*ppInternalDriverFiles ) {
            bReturnValue = FALSE;
            leave;
        }

        for ( Count = 0; Count < *pFileCount; Count++ ) {
            (*ppInternalDriverFiles)[Count].pFileName = NULL;
            (*ppInternalDriverFiles)[Count].hFileHandle = INVALID_HANDLE_VALUE;
            (*ppInternalDriverFiles)[Count].dwVersion = 0;
            (*ppInternalDriverFiles)[Count].bUpdated = FALSE;
        }

        switch (Level) {
            case 2:
                if ( bUseScratchDir ) {
                   (*ppInternalDriverFiles)[0].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo2->pDriverPath,
                                                                pIniEnvironment);
                   (*ppInternalDriverFiles)[1].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo2->pConfigFile,
                                                                pIniEnvironment);
                   (*ppInternalDriverFiles)[2].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo2->pDataFile,
                                                                pIniEnvironment);
                } else {
                   (*ppInternalDriverFiles)[0].pFileName = AllocSplStr(pDriverInfo2->pDriverPath);
                   (*ppInternalDriverFiles)[1].pFileName = AllocSplStr(pDriverInfo2->pConfigFile);
                   (*ppInternalDriverFiles)[2].pFileName = AllocSplStr(pDriverInfo2->pDataFile);
                }

                break;

            case 3:
            case 4:
            case 5:
            case 6:
                if ( bUseScratchDir ) {
                   (*ppInternalDriverFiles)[0].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo3->pDriverPath,
                                                                pIniEnvironment);
                   (*ppInternalDriverFiles)[1].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo3->pConfigFile,
                                                                pIniEnvironment);
                   (*ppInternalDriverFiles)[2].pFileName = GetFileNameInScratchDir(
                                                                pDriverInfo3->pDataFile,
                                                                pIniEnvironment);

                    if ( pDriverInfo3->pHelpFile && *pDriverInfo3->pHelpFile ) {
                        (*ppInternalDriverFiles)[3].pFileName = GetFileNameInScratchDir(
                                                                    pDriverInfo3->pHelpFile,
                                                                    pIniEnvironment);
                    }
                } else {
                   (*ppInternalDriverFiles)[0].pFileName = AllocSplStr(pDriverInfo3->pDriverPath);
                   (*ppInternalDriverFiles)[1].pFileName = AllocSplStr(pDriverInfo3->pConfigFile);
                   (*ppInternalDriverFiles)[2].pFileName = AllocSplStr(pDriverInfo3->pDataFile);

                   if ( pDriverInfo3->pHelpFile && *pDriverInfo3->pHelpFile ) {
                        (*ppInternalDriverFiles)[3].pFileName = AllocSplStr(pDriverInfo3->pHelpFile);
                    }
                }

                if ( dDepFileCount ) {
                    for (pStr = pDependentFiles, Count = dFirstDepFileIndex;
                         *pStr ; pStr += wcslen(pStr) + 1) {

                        if ( bUseScratchDir ) {
                            (*ppInternalDriverFiles)[Count++].pFileName = GetFileNameInScratchDir(
                                                                           pStr,
                                                                           pIniEnvironment);
                        }
                        else {
                            (*ppInternalDriverFiles)[Count++].pFileName = AllocSplStr(pStr);
                        }
                    }
                }

                break;

            case DRIVER_INFO_VERSION_LEVEL:

                for ( Count = 0 ; Count < *pFileCount ; Count++ ) {

                    pFileName = MakePTR(pDriverVersion, pDriverVersion->pFileInfo[Count].FileNameOffset);

                    if ( bUseScratchDir ) {
                        (*ppInternalDriverFiles)[Count].pFileName = GetFileNameInScratchDir(
                                                                    pFileName,
                                                                    pIniEnvironment);
                    } else {
                        (*ppInternalDriverFiles)[Count].pFileName = AllocSplStr(pFileName);
                    }
                }

                break;
        }

        for ( Count = 0 ; Count < *pFileCount ; ) {
            if ( !(*ppInternalDriverFiles)[Count++].pFileName ) {
                DBGMSG( DBG_WARNING,
                        ("CreateInternalDriverFileArray failed to allocate memory %d\n",
                        GetLastError()) );
                bReturnValue = FALSE;
                leave;
            }
        }

        if (bFileNamesOnly) {
            leave;
        }
        //
        // CreateFile may take a long time, if we are trying to copy files
        // from a server and server crashed we want a deadlock to be
        // detected during stress.
        //

        pIniEnvironment->cRef++;
        LeaveSplSem();
        SplOutSem();
        bInSplSem = FALSE;
        for ( Count = 0 ; Count < *pFileCount ; ++Count ) {

            (*ppInternalDriverFiles)[Count].hFileHandle = CreateFile((*ppInternalDriverFiles)[Count].pFileName,
                                                                      GENERIC_READ,
                                                                      FILE_SHARE_READ,
                                                                      NULL,
                                                                      OPEN_EXISTING,
                                                                      FILE_FLAG_SEQUENTIAL_SCAN,
                                                                      NULL);

            if ( (*ppInternalDriverFiles)[Count].hFileHandle == INVALID_HANDLE_VALUE ) {
                DBGMSG( DBG_WARNING,
                        ("CreateFileNames failed to Open %ws %d\n",
                        (*ppInternalDriverFiles)[Count].pFileName, GetLastError()) );
                bReturnValue = FALSE;
                leave;
            }
        }


        //
        // Build the array of file versions.
        // Stay out of Spooler CS since we might do a LoadLibrary over the network.
        //
        if (Level == DRIVER_INFO_VERSION_LEVEL) {
            bReturnValue = GetDriverFileVersions((DRIVER_INFO_VERSION*)pDriverInfo,
                                                 *ppInternalDriverFiles,
                                                 *pFileCount);

        } else {
            bReturnValue = GetDriverFileVersionsFromNames(*ppInternalDriverFiles,
                                                          *pFileCount);
        }

    } finally {

        if (!bReturnValue) {

            CleanupInternalDriverInfo(*ppInternalDriverFiles, *pFileCount);

            *pFileCount = 0;
            *ppInternalDriverFiles  = NULL;
        }
    }

    FreeSplMem(pDependentFilestoFree);

End:

    if ( !bInSplSem ) {

        SplOutSem();
        EnterSplSem();
        SPLASSERT(pIniEnvironment->signature == IE_SIGNATURE);
        pIniEnvironment->cRef--;
    }

    return bReturnValue;
}


DWORD
CopyFileToClusterDirectory (
    IN  PINISPOOLER         pIniSpooler,
    IN  PINIENVIRONMENT     pIniEnvironment,
    IN  PINIVERSION         pIniVersion,
    IN  PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN  DWORD               FileCount
    )
/*++

Routine Name:

    CopyFileToClusterDirectory

Routine Description:

    Copy the updated driver files on the cluster disk

Arguments:

    pIniSpooler     -   Spooler
    pIniEnvironment -   Environment
    pIniVersion     -   Version
    pInternalDriverFiles - pointer to array of INTERNAL_DRV_FILE
    FileCount           - number of elemnts in array

Return Value:

    Last error

--*/
{
    DWORD uIndex;

    DWORD   LastError = ERROR_SUCCESS;

    for (uIndex = 0;
         uIndex < FileCount && LastError == ERROR_SUCCESS;
         uIndex++)
    {
        //
        // If the file was updated, it needs to go onto the cluster disk
        //
        if (pInternalDriverFiles[uIndex].bUpdated)
        {
            WCHAR szDir[MAX_PATH] = {0};

            if ((LastError = StrNCatBuff(szDir,
                                         MAX_PATH,
                                         pIniSpooler->pszClusResDriveLetter,
                                         L"\\",
                                         szClusterDriverRoot,
                                         NULL)) == ERROR_SUCCESS)
            {
                //
                // Let's assume foo is an x86 version 3 driver and k: is the
                // cluster drive letter. The file foo.dll will be copied to the
                // K:\PrinterDrivers\W32x86\3\foo.dll. If foo.icm is an ICM file
                // installed with a 9x driver, then it will be copied to
                // K:\PrinterDrivers\WIN40\0\foo.icm. This is the design. We keep
                // 9x ICM files in the Color subdirectory.
                //
                LastError = CopyFileToDirectory(pInternalDriverFiles[uIndex].pFileName,
                                                szDir,
                                                pIniEnvironment->pDirectory,
                                                pIniVersion->szDirectory,
                                                IsAnICMFile(pInternalDriverFiles[uIndex].pFileName) &&
                                                !_wcsicmp(pIniEnvironment->pName, szWin95Environment) ? L"Color" : NULL);
            }
        }
    }

    return LastError;
}

/*++

Routine Name

    LocalStartSystemRestorePoint

Routine Description:

    This starts a system restore point, if we are on the right sku (PER or PRO).

Arguments:

    pszDriverName   -   The name of the driver to install.
    phRestorePoint  -   The restore point handle to be used in EndSystemRestorePoint.

Return Value:

    TRUE    -   The system restore point was set, or it didn't have to be set.
    FALSE   -   An error occurred, Last Error is set.

--*/
BOOL
LocalStartSystemRestorePoint(
    IN      PCWSTR      pszDriverName,
        OUT HANDLE      *phRestorePoint
    )
{
#ifndef _WIN64

    BOOL            bRet                = FALSE;
    OSVERSIONINFOEX osvi                = { 0 };
    HANDLE          hRestorePoint       = NULL;
    DWORDLONG       dwlConditionMask    = 0;

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    osvi.wProductType = VER_NT_WORKSTATION;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

    //
    // We only do checkpointing on server and we don't do it for remote
    // admin cases. We are invoked during upgrade before the SR client
    // is installed, since it doesn't make sense to put in a restore
    // point here anyway, also fail the call.
    //
    if (!dwUpgradeFlag  &&
        VerifyVersionInfo( &osvi,
                           VER_PRODUCT_TYPE,
                           dwlConditionMask) &&
        S_OK == CheckLocalCall())
    {

        hRestorePoint = StartSystemRestorePoint( NULL,
                                                 pszDriverName,
                                                 hInst,
                                                 IDS_DRIVER_CHECKPOINT);

        bRet = hRestorePoint != NULL;
    }
    else
    {
        //
        // On SRV skus, we don't set system restore points, but that is OK.
        //
        bRet = TRUE;
    }

    *phRestorePoint = hRestorePoint;

    return bRet;

#else

    *phRestorePoint = NULL;
    return TRUE;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\ds.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//  All rights reserved.
//
//  File:       ds.hxx
//
//  Contents:   Print DS
//
//
//  History:    Nov 1996  SWilson
//
//----------------------------------------------------------------------------


#ifdef __cplusplus
extern "C" {
#endif

DWORD
SetPrinterDs(
    HANDLE          hPrinter,
    DWORD           dwAction,
    BOOL            bSynchronous
);

VOID
InitializeDS(
    PINISPOOLER pIniSpooler
    );

VOID
UpdateDsSpoolerKey(
    HANDLE  hPrinter,
    DWORD   dwVector
);

VOID
UpdateDsDriverKey(
    HANDLE hPrinter
);

DWORD
RecreateDsKey(
    HANDLE  hPrinter,
    PWSTR   pszKey
);


DWORD
InitializeDSClusterInfo(
    PINISPOOLER     pIniSpooler,
    HANDLE          *hToken
);

HRESULT
GetDNSMachineName(
    PWSTR pszShortServerName,
    PWSTR *ppszServerName
);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\dsupdate.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

    This module provides functionality for ADs within spooler

Author:

    Steve Wilson (NT) July 1997

Revision History:

--*/


#include <precomp.h>
#pragma hdrstop

#include "dsprune.hxx"
#include "clusspl.h"

DWORD WINAPI DsUpdate(PDWORD pdwDelay);
VOID ValidateDsProperties(PINIPRINTER pIniPrinter);
HANDLE  ghUpdateNow = NULL;

extern DWORD dwUpdateFlag;

extern "C" HANDLE    ghDsUpdateThread;
extern "C" DWORD     gdwDsUpdateThreadId;

HANDLE    ghDsUpdateThread  = NULL;
DWORD     gdwDsUpdateThreadId;

BOOL                gbInDomain;
BOOL                gdwLogDsEvents = LOG_ALL_EVENTS;


DWORD
SpawnDsUpdate(
    DWORD dwDelay
)
{
    DWORD   dwError;
    PDWORD  pdwDelay;

    SplInSem();

    if (!ghDsUpdateThread && !dwUpgradeFlag) {
        if (pdwDelay = (PDWORD) AllocSplMem(sizeof(DWORD))) {
            *pdwDelay = dwDelay;

            if(!(ghDsUpdateThread = CreateThread(NULL,
                                                0,
                                                (LPTHREAD_START_ROUTINE) DsUpdate,
                                                (PVOID) pdwDelay,
                                                0,
                                                &gdwDsUpdateThreadId))) {
                dwError = GetLastError();
                FreeSplMem(pdwDelay);
            } else {
                CloseHandle(ghDsUpdateThread);
                dwError = ERROR_SUCCESS;
            }
        } else {
            dwError = GetLastError();
        }
    } else {
        if (ghUpdateNow)
            SetEvent(ghUpdateNow);

        dwError = ERROR_BUSY;
    }

    return dwError;
}




BOOL
DsUpdatePrinter(
    HANDLE h,
    PINIPRINTER pIniPrinter
    )
{
    HANDLE hPrinter;
    PWSTR pszPrinterName = NULL;
    PDSUPDATEDATA pData = (PDSUPDATEDATA)h;
    DWORD dwAction;

    PRINTER_DEFAULTS    Defaults;

    SplInSem();

    Defaults.pDatatype = NULL;
    Defaults.pDevMode = NULL;
    Defaults.DesiredAccess = PRINTER_ACCESS_ADMINISTER;

    //
    // dwAction and DsKeyUpdateForeground are the foreground (client) thread's requested 
    // action and state. DsKeyUpdate is the background (DsUpdate) thread's state
    // Foreground state always has priority over background, so sync up if needed.
    // When both the foreground and background actions are 0, then the publish state
    // is up to date.
    //
    DBGMSG( DBG_EXEC, ("\nBACKGROUND UPDATE: Printer \"%ws\", dwAction = %x, DsKeyUpdate = %x, DsKeyUpdateForeground = %x, Attributes = %x\n",
            pIniPrinter->pName, pIniPrinter->dwAction, pIniPrinter->DsKeyUpdate, pIniPrinter->DsKeyUpdateForeground, pIniPrinter->Attributes ) );

    if (dwAction = pIniPrinter->dwAction) {
        pIniPrinter->dwAction = 0;          // set to 0 so we know when client thread sets it

        pIniPrinter->DsKeyUpdate |= pIniPrinter->DsKeyUpdateForeground;
        pIniPrinter->DsKeyUpdateForeground = 0;

        //
        // Mask off possible conflicts in DS_KEY_PUBLISH, REPUBLISH, and UNPUBLISH actions
        //
        pIniPrinter->DsKeyUpdate &= ~(DS_KEY_PUBLISH | DS_KEY_REPUBLISH | DS_KEY_UNPUBLISH);
 
        if (dwAction == DSPRINT_PUBLISH) {
            pIniPrinter->DsKeyUpdate |= DS_KEY_PUBLISH;
        } else if (dwAction == DSPRINT_REPUBLISH) {
            pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
        } else if (dwAction == DSPRINT_UNPUBLISH) {
            pIniPrinter->DsKeyUpdate = DS_KEY_UNPUBLISH;
        }
    } else {
        //
        // If DS_KEY_UPDATE_DRIVER is set by AddForm or DeleteForm foreground threads
        // in DsUpdateDriverKeys(). We have to copy that to pIniPrinter->DsKeyUpdate
        // even if dwAction is not set. 
        //
        pIniPrinter->DsKeyUpdate |= (pIniPrinter->DsKeyUpdateForeground & DS_KEY_UPDATE_DRIVER);
        pIniPrinter->DsKeyUpdateForeground &= ~DS_KEY_UPDATE_DRIVER;
    }

    UpdatePrinterIni(pIniPrinter, UPDATE_DS_ONLY);

    if (pIniPrinter->DsKeyUpdate) {

        pData->bAllUpdated = FALSE;

        LeaveSplSem();

        //
        // If this printer is pending deletion, delete by GUID because OpenPrinter
        // will fail.
        //
        // We check pIniPrinter->bDsPendingDeletion instead of 
        // pIniPrinter->Status ~ PRINTER_PENDING_DELETION because PRINTER_PENDING_DELETION
        // is set in InternalDeletePrinter after it leaves Spooler CS. This gives the DS thread
        // a chance to check PRINTER_PENDING_DELETION flag before it is set.
        // The reason we cannot set PRINTER_PENDING_DELETION before we leave Spooler CS is because 
        // we want OpenPrinter calls that come from PrinterDriverEvent to succeed.
        // See how InternalDeletePrinter sets the printer on PRINTER_NO_MORE_JOBS to reject incoming jobs
        // but accept OpenPrinter calls.
        //
        if (pIniPrinter->bDsPendingDeletion) {
            //
            // This will DECPRINTERREF to match DECPRINTERREF in SplDeletePrinter.
            // UnpublishByGUID won't call DeletePrinterCheck when it DECPRINTERREF.
            // RunForEachPrinter will do that.
            //
            UnpublishByGUID(pIniPrinter);

        } else {

            EnterSplSem();
            pszPrinterName = pszGetPrinterName( pIniPrinter, TRUE, NULL );
            LeaveSplSem();

            if (pszPrinterName) {
                if(LocalOpenPrinter(pszPrinterName, &hPrinter, &Defaults) == ROUTER_SUCCESS) {

                    EnterSplSem();
                    if( (pIniPrinter->DsKeyUpdate & DS_KEY_UPDATE_DRIVER) && 
                        !(pIniPrinter->DsKeyUpdate & DS_KEY_REPUBLISH)) {

                        // 
                        // We update the Registry with the Form data and then
                        // set DS_KEY_PUBLISH. Eventually SetPrinterDS() would 
                        // update the DS. 
                        UpdateDsDriverKey(hPrinter);
                        pIniPrinter->DsKeyUpdate &= ~DS_KEY_UPDATE_DRIVER;

                        if(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) {
                            pIniPrinter->DsKeyUpdate |= DS_KEY_PUBLISH;
                        } 
                    }
                    if (pIniPrinter->DsKeyUpdate & DS_KEY_REPUBLISH) {

                        SetPrinterDs(hPrinter, DSPRINT_UNPUBLISH, TRUE);

                        // Unpublishing & republishing printer doesn't rewrite DS keys,
                        // so on Republish, we should also rewrite DS keys so we know
                        // everything is synched up
                        SplDeletePrinterKey(hPrinter, SPLDS_DRIVER_KEY);
                        SplDeletePrinterKey(hPrinter, SPLDS_SPOOLER_KEY);
                        UpdateDsDriverKey(hPrinter);
                        UpdateDsSpoolerKey(hPrinter, 0xffffffff);

                        SetPrinterDs(hPrinter, DSPRINT_PUBLISH, TRUE);

                    } else if (pIniPrinter->DsKeyUpdate & DS_KEY_UNPUBLISH) {
                        SetPrinterDs(hPrinter, DSPRINT_UNPUBLISH, TRUE);

                    } else if (pIniPrinter->DsKeyUpdate & DS_KEY_PUBLISH) {
                        SetPrinterDs(hPrinter, DSPRINT_PUBLISH, TRUE);

                    } else {
                        // 
                        // If the printer is not published and DS_KEY_UPDATE_DRIVER
                        // is set, then we will reach here and 
                        // DsKeyUpdate will have the DS_KEY_DRIVER set by 
                        // UpdateDsDriverKey(). So we just clear it here.
                        //
                        pIniPrinter->DsKeyUpdate = 0;
                        UpdatePrinterIni(pIniPrinter, UPDATE_DS_ONLY);
                    }
                    LeaveSplSem();

                    SplClosePrinter(hPrinter);
                }
                FreeSplStr(pszPrinterName);
            }
        }
        EnterSplSem();

        if (pIniPrinter->DsKeyUpdate) {
            pData->bSleep = TRUE;      // Only sleep if the DS is down
            gdwLogDsEvents = LOG_INFO | LOG_SUCCESS; // Only report Warnings & Errors for first printer failures
        }
    }
    return TRUE;
}

BOOL
DsUpdateSpooler(
    HANDLE h,
    PINISPOOLER pIniSpooler
    )
{
    //
    // Only do this for local spoolers.
    //
    if (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL) {
        RunForEachPrinter(pIniSpooler, h, DsUpdatePrinter);
    }
    return TRUE;
}


DWORD
WINAPI
DsUpdate(
    PDWORD  pdwDelay
)
{
    DWORD               dwSleep;
    DWORD               dwError = ERROR_SUCCESS;
    HRESULT             hr;
    DSUPDATEDATA        Data;
    DWORD               dwWaitTime = 0;
    
    SplOutSem();

    ghUpdateNow = CreateEvent((LPSECURITY_ATTRIBUTES) NULL, FALSE, FALSE, NULL);
    
    if (ghUpdateNow) {

        if (RegisterGPNotification(ghUpdateNow, TRUE)) {

            hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

            if (SUCCEEDED(hr)) {    

                DBGMSG( DBG_EXEC, ("************** ENTER DSUPDATE\n" ) );
                //
                // Force initial sleep to be within 1 sec & 5 minutes
                //
                dwSleep = (*pdwDelay >= 1 && *pdwDelay < 300) ? *pdwDelay : 1;

                FreeSplMem(pdwDelay);

                if (dwSleep > 1) {

                    Sleep(dwSleep*1000);
                }

                Data.dwSleepTime = dwSleep * 1000;

                gdwLogDsEvents = LOG_ALL_EVENTS;


                EnterSplSem();

                //
                // The logic of this loop changed from between Win2K to Whistler. 
                // On Win2k, the DS background thread used to die if there were no DS
                // actions to be made.If the "Check published state" was changed, 
                // Spooler couldn't reflect this change unless another DS action 
                // created the DS thread.
                // On Whistler we keep it alive but sleeping.
                //
                do {

                    Data.bAllUpdated = TRUE;
                    Data.bSleep = FALSE;

                    //
                    // Run through and update each printer.
                    //
                    RunForEachSpooler(&Data, DsUpdateSpooler);
        
                    //
                    // If all printers are updated or the DS is not responding,
                    // then put the DS thread to sleep.
                    //
                    if (Data.bAllUpdated || Data.bSleep) {

                        dwWaitTime = GetDSSleepInterval(&Data);

                        //
                        // If the VerifyPublishedState Policy is set, then we need to verify 
                        // we're published based on the schedule specified by the policy.
                        // However, if updating is failing, we should revert to the background
                        // updating schedule rather than the "check published state" schedule.
                        //             
                        LeaveSplSem();

                        DBGMSG( DBG_EXEC, ("BACKGROUND UPDATE SLEEP: %d\n", dwWaitTime));

                        dwError = WaitForSingleObject(ghUpdateNow, dwWaitTime);

                        if (dwError == WAIT_FAILED) {

                            //
                            // There is one case when the DS thread can still die.
                            // If this wait fails, we don't want the thread indefinitely spinning.
                            //
                            DBGMSG(DBG_WARNING, ("VerifyPublishedState Wait Failed: %d\n", GetLastError()));
                            dwError = GetLastError();
                            break;
                        }

                        EnterSplSem();
            
                        //
                        // If the "Check published state" policy is enabled,CheckPublishedPrinters will force the DS update
                        // for published printers.If the object doesn't exist in DS, the printer is republished.(see GetPublishPoint)
                        // The call returns 0 if there is the "check published state" policy 
                        // is disabled or it is enabled and there are no published printers.
                        // We could actually break the loop and kill the thread in the case when we don't have published printers,
                        // because we don't care for policy changes.
                        //
                        CheckPublishedPrinters();
                    }

                } while (TRUE);

                LeaveSplSem();
                SplOutSem();

                CoUninitialize();

            } else {

                dwError = HRESULT_CODE(hr);
            }

            UnregisterGPNotification(ghUpdateNow);

        } else {

            dwError = GetLastError();
        }

        CloseHandle(ghUpdateNow);
        ghUpdateNow = NULL;

    } else {

        dwError = GetLastError();
    }

    DBGMSG(DBG_EXEC, ("************ LEAVE DSUPDATE\n"));

    ghDsUpdateThread = NULL;

    return dwError;
}


VOID
ValidateDsProperties(
    PINIPRINTER pIniPrinter
)
{
    // Properties not generated by driver, spooler, or user should be checked here.
    // Currently, that means only the Server name.  Note that we republish the object
    // if the server name changes, so the UNCName property gets fixed as well.

    DWORD               dwError = ERROR_SUCCESS;
    BOOL                dwAction = 0;
    HRESULT             hr;

    SplInSem();

    PINISPOOLER         pIniSpooler = pIniPrinter->pIniSpooler;
    WCHAR               pData[INTERNET_MAX_HOST_NAME_LENGTH + 3];
    DWORD               cbNeeded;
    DWORD               dwType;
    struct hostent      *pHostEnt;
    HKEY                hKey = NULL;


    dwError = OpenPrinterKey(pIniPrinter, KEY_READ | KEY_WRITE, &hKey, SPLDS_SPOOLER_KEY, TRUE);
    if (dwError != ERROR_SUCCESS) {
        pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
        return;
    }

    INCPRINTERREF(pIniPrinter);
    LeaveSplSem();

    //
    // Set to publish by default.  This will verify that the printer is published, but won't
    // write anything if there's nothing to update.
    //
    pIniPrinter->DsKeyUpdate |= DS_KEY_PUBLISH;

    // Check Server Name

    //
    // If we were unable to find a DNS name for this machine, then gethostbyname failed.
    // In this case, let's just treat this attribute as being correct.  If other attributes
    // cause us to update, we'll probably fail because the network is down or something.  But
    // then again, we also might succeed.
    //
    if (pIniSpooler->pszFullMachineName) {

        cbNeeded = (INTERNET_MAX_HOST_NAME_LENGTH + 3)*sizeof *pData;
        dwType = REG_SZ;
        dwError = SplRegQueryValue( hKey,
                                    SPLDS_SERVER_NAME,
                                    &dwType,
                                    (PBYTE) pData,
                                    &cbNeeded,
                                    pIniSpooler);

        if (dwError != ERROR_SUCCESS || _wcsicmp((PWSTR) pData, pIniSpooler->pszFullMachineName)) {
            pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
            goto error;
        }
    }

    //
    // Check Short Server Name
    //
    cbNeeded = (INTERNET_MAX_HOST_NAME_LENGTH + 3)*sizeof *pData;
    dwType = REG_SZ;
    dwError = SplRegQueryValue( hKey,
                                SPLDS_SHORT_SERVER_NAME,
                                &dwType,
                                (PBYTE) pData,
                                &cbNeeded,
                                pIniSpooler);

    if (dwError != ERROR_SUCCESS || _wcsicmp((PWSTR) pData, pIniSpooler->pMachineName + 2)) {
        pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
        goto error;
    }

    //
    // Check Version Number
    //
    cbNeeded = (INTERNET_MAX_HOST_NAME_LENGTH + 3)*sizeof *pData;
    dwType = REG_DWORD;
    dwError = SplRegQueryValue( hKey,
                                SPLDS_VERSION_NUMBER,
                                &dwType,
                                (PBYTE) pData,
                                &cbNeeded,
                                pIniSpooler);

    if (dwError != ERROR_SUCCESS || *((PDWORD) pData) != DS_PRINTQUEUE_VERSION_WIN2000) {
        pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
        goto error;
    }

    //
    // Check Immortal flag
    //
    cbNeeded = (INTERNET_MAX_HOST_NAME_LENGTH + 3)*sizeof *pData;
    dwType = REG_DWORD;
    dwError = SplRegQueryValue( hKey,
                                SPLDS_FLAGS,
                                &dwType,
                                (PBYTE) pData,
                                &cbNeeded,
                                pIniSpooler);

    if (dwError != ERROR_SUCCESS) {
        pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
        goto error;
    } else if (*((PDWORD) pData) != (DWORD) pIniSpooler->bImmortal) {
        dwError = SplRegSetValue(   hKey,
                                    SPLDS_FLAGS,
                                    dwType,
                                    (PBYTE) &pIniSpooler->bImmortal,
                                    sizeof pIniSpooler->bImmortal,
                                    pIniSpooler);

        if (dwError == ERROR_SUCCESS) {
            pIniPrinter->DsKeyUpdate |= DS_KEY_SPOOLER;
        }
        else {
            pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
            goto error;
        }
    }


error:

    if (hKey)
        SplRegCloseKey(hKey, pIniSpooler);


    EnterSplSem();
    DECPRINTERREF(pIniPrinter);
    SplInSem();

    return;
}



extern "C" VOID
InitializeDS(
    PINISPOOLER pIniSpooler
    )
{
    PINIPRINTER                         pIniPrinter = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    DWORD                               dwError = ERROR_SUCCESS;
    SYSTEMTIME                          SystemTime;
    DWORD                               dwDelay = 0;

    //
    // Verify that we're in a domain
    //
    dwError = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) &pDsRole);

    if (pDsRole) {
        gbInDomain = (dwError == ERROR_SUCCESS &&
                      pDsRole->MachineRole != DsRole_RoleStandaloneServer &&
                      pDsRole->MachineRole != DsRole_RoleStandaloneWorkstation);

        DsRoleFreeMemory((PVOID) pDsRole);

    } else {

        gbInDomain = FALSE;
    }


    if (gbInDomain) {

        //
        // Check if we need to update the ds
        //
        EnterSplSem();
        //
        // Get spooler policies
        //
        pIniSpooler->bImmortal = ImmortalPolicy();
        BOOL bPublishProhibited = PrinterPublishProhibited();

        //
        // Run through all the printers and see if any need updating
        //
        for (pIniPrinter = pIniSpooler->pIniPrinter ; pIniPrinter ; pIniPrinter = pIniPrinter->pNext) {

            //
            // PublishProhibited not only prohibits new publishing, but also
            // removes currently published printers
            //
            if (bPublishProhibited) {
                pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_PUBLISHED;
            }

            if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) {
                //
                // Verify properties not changed by driver or spooler
                //
                ValidateDsProperties(pIniPrinter);

            } else if (pIniPrinter->pszObjectGUID) {   
                //
                // State is unpublished, but we haven't deleted
                // the PrintQueue from the DS yet.
                //
                pIniPrinter->DsKeyUpdate = DS_KEY_UNPUBLISH;
            } else {
                pIniPrinter->DsKeyUpdate = 0;
            }

            if (!dwDelay && (pIniPrinter->DsKeyUpdate || pIniPrinter->DsKeyUpdateForeground)) {
                //
                // Initially sleep a random amount of time
                // This keeps network traffic down if there's been a power outage
                //
                GetSystemTime(&SystemTime);

                srand((unsigned) SystemTime.wMilliseconds);
                //
                // 100 different sleep times from 1 sec - 100 sec
                // Typical time to publish printer is 5 seconds.  Updates and deletes are just a couple seconds
                //
                dwDelay = (rand()%100) + 1;
            }
        }

        if (dwDelay)
            SpawnDsUpdate(dwDelay);

        LeaveSplSem();

        if (ThisMachineIsADC()) {

            GetSystemTime(&SystemTime);
            srand((unsigned) SystemTime.wMilliseconds);

            DWORD dwPruningInterval = PruningInterval();

            if (dwPruningInterval == INFINITE)
                dwPruningInterval = DEFAULT_PRUNING_INTERVAL;

            if (dwPruningInterval)
                SpawnDsPrune(rand()%dwPruningInterval);
            else
                SpawnDsPrune(0);
        }
    }

    ServerThreadPolicy(gbInDomain);

    return;
}

BOOL
DsUpdateDriverKeys(
    HANDLE h,
    PINIPRINTER pIniPrinter
    )
{
    //
    // For now, we need this only when a new user defined form is added/deleted.
    // For this case, UpdateDsDriverKey is not called before call SetPrinterDS
    // We set all pIniPrinters->DsKeyUpdateForeground with DS_KEY_UPDATE_DRIVER so that 
    // on DsUpdatePrinter we know that UpdateDsDriverKey must be called before 
    // we try to publish the printer.
    //
    SplInSem();

    pIniPrinter->DsKeyUpdateForeground |= DS_KEY_UPDATE_DRIVER;    
    
    return TRUE;
}
    
BOOL
DsUpdateAllDriverKeys(
    HANDLE h,
    PINISPOOLER pIniSpooler
    )
{
    HANDLE          hToken = NULL;
    
    //
    // Only do this for local spoolers.
    //
    if (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL) {
        RunForEachPrinter(pIniSpooler, h, DsUpdateDriverKeys);
    }

    //
    // All DS accesses are done by LocalSystem account
    //
    hToken = RevertToPrinterSelf(); 
    SpawnDsUpdate(1);
    if (hToken)
        ImpersonatePrinterClient(hToken);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\dsprune.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Abstract:

    This module provides functionality for ADs within spooler

Author:

    Steve Wilson (NT) July 1997

Revision History:

--*/


#include <precomp.h>
#pragma hdrstop

#include "ds.hxx"
#include "dsprune.hxx"


RETRYLIST   gRetry = {NULL, 0, NULL};


#define IADSPATH        0
#define IUNCNAME        1
#define ICN             2
#define IVERSION        3
#define ISERVER         4
#define IFLAGS          5
#define ADSPATH         L"ADsPath"
#define CN              L"CN"

PWSTR gpszAttributes[] = {ADSPATH, SPLDS_UNC_NAME, CN, SPLDS_VERSION_NUMBER, SPLDS_SERVER_NAME, SPLDS_FLAGS};
#define N_ATTRIBUTES    COUNTOF(gpszAttributes)

#define SZ_NO_CACHE         L",NoCache"

#define LOG_EVENT_ERROR_BUFFER_SIZE     11

DWORD
SpawnDsPrune(
    DWORD dwDelay
)
{
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   ThreadId;
    HANDLE  hDsPruneThread;
    PDWORD  pdwDelay;

    if (pdwDelay = (PDWORD) AllocSplMem(sizeof(DWORD)))
        *pdwDelay = dwDelay;

    if(!(hDsPruneThread = CreateThread(NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE) DsPrune,
                                        (PVOID) pdwDelay,
                                        0,
                                        &ThreadId))) {
        dwError = GetLastError();
        FreeSplMem(pdwDelay);
    } else {
        CloseHandle(hDsPruneThread);
        dwError = ERROR_SUCCESS;
    }


    return dwError;
}


DWORD
WINAPI
DsPrune(
    PDWORD  pdwDelay
)
{
    PWSTR   *ppszMySites = NULL;
    PWSTR   pszDomainRoot = NULL;
    ULONG   cMySites;
    DWORD   dwRet;
    HRESULT hr;

    /*
        1) Determine my site
        2) Query for all PrintQueue objects in my domain
        3) For each PrintQueue:
            a) Get array of IP addresses
            b) Pass IP addresses to DsAddressToSiteNames
            c) If no site returned by DsAddressToSiteNames matches my site, goto 3
            d) Delete PrintQueue if orphaned
    */

    //
    // Sleep random amount on startup so DCs aren't all pruning at the same time
    //
    if (pdwDelay) {
        Sleep(*pdwDelay*ONE_MINUTE);     // *pdwDelay is number of minutes
        FreeSplMem(pdwDelay);
    }

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) {
        return HRESULT_CODE(hr);
    }
    //
    // Determine my sites
    //
    dwRet = DsGetDcSiteCoverage(NULL, &cMySites, &ppszMySites);
    if (dwRet != NO_ERROR)
        goto error;

    dwRet = GetDomainRoot(&pszDomainRoot);
    if (dwRet != NERR_Success)
        goto error;

    while(1) {

        PRUNINGPOLICIES PruningPolicies;
        DWORD dwSleep, dwOriginalSleep;

        PruningPolicies.dwPruneDownlevel = PruneDownlevel();
        PruningPolicies.dwPruningRetries = PruningRetries();
        PruningPolicies.dwPruningRetryLog = PruningRetryLog();

        SetPruningPriority();

        DeleteOrphans(ppszMySites, cMySites, pszDomainRoot, &PruningPolicies);

        dwSleep = dwOriginalSleep = PruningInterval();

        while (dwSleep > HOUR_OF_MINUTES) {

            Sleep(ONE_HOUR);     // Check interval every hour

            DWORD dwNewSleep = PruningInterval();

            if (dwNewSleep != dwOriginalSleep) {
                dwSleep = dwOriginalSleep = dwNewSleep;
            }

            if (dwSleep != INFINITE && dwSleep > HOUR_OF_MINUTES)
                dwSleep -= HOUR_OF_MINUTES;
        }
        Sleep(dwSleep*ONE_MINUTE);
    }


error:

    if (ppszMySites)
        NetApiBufferFree(ppszMySites);

    FreeSplMem(pszDomainRoot);

    CoUninitialize();

    return ERROR_SUCCESS;
}



HRESULT
DeleteOrphans(
    PWSTR           *ppszMySites,
    ULONG            cMySites,
    PWSTR            pszSearchRoot,
    PRUNINGPOLICIES *pPruningPolicies
)
{
    ADS_SEARCH_HANDLE    hSearchHandle = NULL;
    IDirectorySearch    *pDSSearch = NULL;
    HRESULT              hr = S_OK;
    WCHAR                szSearchPattern[] = L"(objectCategory=printQueue)";
    SEARCHCOLUMN         Col[N_ATTRIBUTES];
    DWORD                i;
    ADS_SEARCHPREF_INFO  SearchPrefs;
    DWORD                dwError;



    // Find all PrintQueues in domain
    hr = ADsGetObject(  pszSearchRoot,
                        IID_IDirectorySearch,
                        (void **)&pDSSearch);
    BAIL_ON_FAILURE(hr);


    SearchPrefs.dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs.vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs.vValue.Integer = 256;

    hr = pDSSearch->SetSearchPreference(&SearchPrefs, 1);
    if (FAILED(hr)) {
        DBGMSG(DBG_WARNING, ("DSPrune: SetSearchPref failed: %d\n", hr));
    } else if (hr != S_OK && SearchPrefs.dwStatus != ADS_STATUS_S_OK) {
        DBGMSG(DBG_WARNING, ("DSPrune: SearchPref failed: %d\n", SearchPrefs.dwStatus));
    }

    hr = pDSSearch->ExecuteSearch(
         szSearchPattern,
         gpszAttributes,
         N_ATTRIBUTES,
         &hSearchHandle);
    BAIL_ON_FAILURE(hr);

    hr = pDSSearch->GetNextRow(hSearchHandle);
    //
    // This is the new way of checking for rows in Whistler.
    // see bug 163776. I expect to be changed in the future.
    //
    if (hr == S_ADS_NOMORE_ROWS) {
        ADsGetLastError(&dwError, NULL, 0, NULL, 0);
        if (dwError == ERROR_MORE_DATA) {
            hr = pDSSearch->GetNextRow(hSearchHandle);
        }
    }
    BAIL_ON_FAILURE(hr);

    while (hr != S_ADS_NOMORE_ROWS) {

        for (i = 0 ; i < N_ATTRIBUTES ; ++i)
            Col[i].hr = pDSSearch->GetColumn(hSearchHandle, gpszAttributes[i], &Col[i].Column);

        DeleteOrphan(ppszMySites, cMySites, Col, pPruningPolicies);

        for (i = 0 ; i < N_ATTRIBUTES ; ++i)
            if (SUCCEEDED(Col[i].hr))
                pDSSearch->FreeColumn(&Col[i].Column);

        hr = pDSSearch->GetNextRow(hSearchHandle);
        //
        // This is the new way of checking for rows in Whistler.
        // see bug 163776. I expect to be changed in the future.
        //
        if (hr == S_ADS_NOMORE_ROWS) {
            ADsGetLastError(&dwError, NULL, 0, NULL, 0);
            if (dwError == ERROR_MORE_DATA) {
                hr = pDSSearch->GetNextRow(hSearchHandle);
            }
        }
        BAIL_ON_FAILURE(hr);
    }

    hr = S_OK;


error:


    if (hSearchHandle)
        pDSSearch->CloseSearchHandle(hSearchHandle);

    if (pDSSearch)
        pDSSearch->Release();

    return hr;
}


VOID
DeleteOrphan(
    PWSTR           *ppszMySites,
    ULONG            cMySites,
    SEARCHCOLUMN     Col[],
    PRUNINGPOLICIES *pPruningPolicies
)
{
    IADs                *pADs           = NULL;
    IADsContainer       *pContainer     = NULL;
    PWSTR               pszParent       = NULL;
    PWSTR               pszCommonName   = NULL;
    HANDLE              hPrinter        = NULL;
    PWSTR               pszServerName   = NULL;
    PWSTR               pszEscapedCN    = NULL;
    PWSTR               pszCN;
    PWSTR               pszADsPath;
    PWSTR               pszUNCName;
    PWSTR               pszServer;
    DWORD               dwError         = ERROR_SUCCESS;
    HRESULT             hr;
    DWORD               dwVersion;
    DWORD               dwFlags;
    BOOL                bDeleteIt               = FALSE;
    BOOL                bDeleteImmediately      = FALSE;
    WCHAR               ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];

    pszADsPath = SUCCEEDED(Col[IADSPATH].hr) ? Col[IADSPATH].Column.pADsValues->DNString : NULL;
    pszUNCName = SUCCEEDED(Col[IUNCNAME].hr) ? Col[IUNCNAME].Column.pADsValues->DNString : NULL;
    pszServer = SUCCEEDED(Col[ISERVER].hr) ? Col[ISERVER].Column.pADsValues->DNString : NULL;
    pszCN = SUCCEEDED(Col[ICN].hr) ? Col[ICN].Column.pADsValues->DNString : NULL;
    dwVersion = SUCCEEDED(Col[IVERSION].hr) ? Col[IVERSION].Column.pADsValues->Integer : 0;
    dwFlags = SUCCEEDED(Col[IFLAGS].hr) ? Col[IFLAGS].Column.pADsValues->Integer : 0;

    //
    // We should always have an ADsPath & CN, but if not, don't continue because there's
    // no way to delete something if we don't know where it is.
    //
    if (!pszADsPath || !pszCN) {
        DBGMSG(DBG_WARNING, ("DeleteOrphan: No ADs Path or CN!\n"));
        return;
    }

    if (!(dwFlags & IMMORTAL)) {
        if (!pszUNCName || !pszServer || FAILED(Col[IVERSION].hr)) {
            bDeleteIt = bDeleteImmediately = TRUE;

            SplLogEvent( pLocalIniSpooler,
                         LOG_INFO,
                         MSG_PRUNING_NOUNC_PRINTER,
                         FALSE,
                         pszADsPath,
                         NULL );

        } else if ((dwVersion >= DS_PRINTQUEUE_VERSION_WIN2000 ||
                    pPruningPolicies->dwPruneDownlevel != PRUNE_DOWNLEVEL_NEVER) &&
                    UNC2Server(pszUNCName, &pszServerName) == ERROR_SUCCESS &&
                    ServerOnSite(ppszMySites, cMySites, pszServerName)) {
            //
            // Try to open the printer.  If it doesn't exist, delete it!
            //
            PWSTR   pszNoCacheUNCName = NULL;

            if (ERROR_SUCCESS == StrCatAlloc((PCWSTR *)&pszNoCacheUNCName, pszUNCName, SZ_NO_CACHE, NULL)) {

                DBGMSG(DBG_EXEC, ("DSPrune: Checking %ws\n", pszUNCName));

                if (!OpenPrinter(pszNoCacheUNCName, &hPrinter, NULL)) {
                    dwError = GetLastError();

                    if (dwError != ERROR_ACCESS_DENIED &&
                       (dwVersion >= DS_PRINTQUEUE_VERSION_WIN2000 ||
                        pPruningPolicies->dwPruneDownlevel == PRUNE_DOWNLEVEL_AGGRESSIVELY ||
                       (pPruningPolicies->dwPruneDownlevel == PRUNE_DOWNLEVEL_NICELY && ServerExists(pszServerName)))) {
                        bDeleteIt = TRUE;

                        //
                        // Log an info event for each retry, if the policy is configured so.
                        //
                        if (pPruningPolicies->dwPruningRetryLog) {
                            StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%0x", dwError);
                            SplLogEvent( pLocalIniSpooler,
                                         LOG_INFO,
                                         MSG_PRUNING_ABSENT_PRINTER,
                                         FALSE,
                                         pszADsPath,
                                         ErrorBuffer,
                                         NULL );
                        }

                    }
                } else if (dwVersion >= DS_PRINTQUEUE_VERSION_WIN2000) {

                    BYTE    Data[256];
                    DWORD   cbNeeded  = 0;
                    BYTE    *pData = Data;
                    BYTE    bHaveData = TRUE;

                    // Verify that the printer should indeed be published and that
                    // the GUID of the published object matches the GUID on the print server.
                    // NOTE: The GUID check is needed because we may publish the same printer
                    // twice if the spooler is restarted and checks a DC before the first publish
                    // is replicated.

                    if (!GetPrinter(hPrinter, 7, Data, COUNTOF(Data), &cbNeeded)) {
                        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                            //
                            // Forget this printer if alloc or second GetPrinter fails
                            //
                            pData = (PBYTE) AllocSplMem(cbNeeded);
                            if (pData) {
                                if (!GetPrinter(hPrinter, 7, pData, cbNeeded, &cbNeeded)) {
                                    bHaveData = FALSE;
                                }
                            } else {
                                bHaveData = FALSE;
                            }
                        } else {
                            //
                            // A Win9x machine may have the same printer UNCName
                            //
                            bDeleteIt = TRUE;
                            bHaveData = FALSE;
                        }
                    }

                    if (bHaveData) {
                        if (!(((PPRINTER_INFO_7) pData)->dwAction & DSPRINT_PUBLISH)) {
                            bDeleteIt = bDeleteImmediately = TRUE;

                            SplLogEvent( pLocalIniSpooler,
                                         LOG_INFO,
                                         MSG_PRUNING_UNPUBLISHED_PRINTER,
                                         FALSE,
                                         pszADsPath,
                                         NULL );
                        } else {
                            //
                            // Compare object GUID to printer's GUID
                            //
                            PWSTR pszObjectGUID = NULL;

                            hr = ADsGetObject(pszADsPath, IID_IADs, (void **) &pADs);
                            BAIL_ON_FAILURE(hr);

                            hr = GetGUID(pADs, &pszObjectGUID);
                            BAIL_ON_FAILURE(hr);

                            if (!((PPRINTER_INFO_7) pData)->pszObjectGUID ||
                                wcscmp(((PPRINTER_INFO_7) pData)->pszObjectGUID, pszObjectGUID)) {
                                bDeleteIt = bDeleteImmediately = TRUE;

                                SplLogEvent( pLocalIniSpooler,
                                             LOG_INFO,
                                             MSG_PRUNING_DUPLICATE_PRINTER,
                                             FALSE,
                                             pszADsPath,
                                             NULL );
                            }


                            FreeSplStr(pszObjectGUID);
                            pADs->Release();
                            pADs = NULL;
                        }
                    }

                    if (pData != Data)
                        FreeSplMem(pData);
                }
                FreeSplMem(pszNoCacheUNCName);
            }
        }
    }


    // Get PrintQueue object
    hr = ADsGetObject(pszADsPath, IID_IADs, (void **) &pADs);
    BAIL_ON_FAILURE(hr);

    if (bDeleteIt) {

        //
        // Delete the printqueue, but check retry count first
        //
        if (!bDeleteImmediately && !EnoughRetries(pADs, pPruningPolicies->dwPruningRetries))
            goto error;

        //
        // Get the Parent ADsPath
        //
        hr = pADs->get_Parent(&pszParent);
        BAIL_ON_FAILURE(hr);

        //
        // Get the Parent object
        //
        hr = ADsGetObject(  pszParent,
                            IID_IADsContainer,
                            (void **) &pContainer);
        BAIL_ON_FAILURE(hr);

        //
        // The CN string read from ExecuteSearch may have unescaped characters, so
        // be sure to fix this before trying to delete
        //
        pszEscapedCN = CreateEscapedString(pszCN, DN_SPECIAL_CHARS);
        if (!pszEscapedCN) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        hr = HResultFromWin32(StrCatAlloc((PCWSTR *)&pszCommonName, L"CN=", pszEscapedCN, NULL));

        if (SUCCEEDED(hr))
        {
            hr = pContainer->Delete(SPLDS_PRINTER_CLASS, pszCommonName);
        }

        if (FAILED(hr)) {
            StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%0x", hr);
            SplLogEvent( pLocalIniSpooler,
                         LOG_ERROR,
                         MSG_CANT_PRUNE_PRINTER,
                         FALSE,
                         pszADsPath,
                         ErrorBuffer,
                         NULL );
            DBGMSG(DBG_EXEC, ("DSPrune: Can't delete %ws.  Error: %0x\n", pszUNCName, hr));
            goto error;
        }

        SplLogEvent( pLocalIniSpooler,
                     LOG_INFO,
                     MSG_PRUNING_PRINTER,
                     FALSE,
                     pszADsPath,
                     NULL );
        DBGMSG(DBG_EXEC, ("DSPrune: DELETING %ws\n", pszUNCName));

    } else {
        //
        // Delete the Retry Entry (if any) if we aren't deleting it
        //
        DeleteRetryEntry(pADs);
    }


error:

    if (hPrinter)
        ClosePrinter(hPrinter);

    if (pADs)
        pADs->Release();

    if (pContainer)
        pContainer->Release();

    if (pszParent)
        SysFreeString(pszParent);

    FreeSplMem(pszCommonName);
    FreeSplMem(pszEscapedCN);
    FreeSplMem(pszServerName);
}



BOOL
EnoughRetries(
    IADs        *pADs,
    DWORD       dwPruningRetries
)
/*++
Function Description:
    This function return TRUE if we have retry count is greater than retry policy, FALSE otherwise

Parameters:
    pADs        - pointer to the PrintQueue object

Return Values:
    TRUE if retry count is greater than the policy setting for this object
    FALSE if we can't get the GUID or entry doesn't exist and it can't be created (out of memory)
--*/
{
    HRESULT     hr = S_OK;
    PWSTR       pszObjectGUID = NULL;
    PRETRYLIST  pRetry = NULL;
    BOOL        bEnoughRetries = FALSE;

    //
    // Get the GUID
    //
    hr = GetGUID(pADs, &pszObjectGUID);
    BAIL_ON_FAILURE(hr);

    //
    // Get the entry
    //
    if (!(pRetry = GetRetry(pszObjectGUID))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    //
    // Increment retry count if we're not done.  Delete retry if we're done.
    //
    if (++pRetry->nRetries > dwPruningRetries) {
        DeleteRetry(pRetry);
        bEnoughRetries = TRUE;
    }

error:

    FreeSplStr(pszObjectGUID);

    return bEnoughRetries;
}


VOID
DeleteRetryEntry(
    IADs        *pADs
)
/*++
Function Description:
    This function removes a Retry entry based on the supplied ADs pointer

Parameters:
    pADs        - pointer to the PrintQueue object

Return Values:
    none
--*/
{
    HRESULT     hr = S_OK;
    PWSTR       pszObjectGUID = NULL;
    PRETRYLIST  pRetry = NULL;

    //
    // Get the GUID
    //
    hr = GetGUID(pADs, &pszObjectGUID);
    BAIL_ON_FAILURE(hr);

    //
    // Get & Delete the entry
    //
    if (pRetry = FindRetry(pszObjectGUID)) {
        DeleteRetry(pRetry);
    }

error:

    FreeSplStr(pszObjectGUID);
}


PRETRYLIST
FindRetry(
    PWSTR pszObjectGUID
)
/*++
Function Description:
    This function finds a RETRYLIST entry.

Parameters:
    pszObjectGUID - pointer to buffer containing the GUID of the RETRYLIST entry to find or create.

Return Values:
    PRETRYLIST  - pointer to the found or create RETRYLIST entry.  This may be NULL if the entry is
                  not found and a new one could not be created.

--*/
{
    PRETRYLIST  pRetry = &gRetry;

    for (; pRetry->pNext ; pRetry = pRetry->pNext) {
        //
        // If entry exists, just return
        //
        if (!wcscmp(pszObjectGUID, pRetry->pNext->pszObjectGUID))
            return pRetry->pNext;
    }

    return NULL;
}


PRETRYLIST
GetRetry(
    PWSTR pszObjectGUID
)
/*++
Function Description:
    This function finds or creates a RETRYLIST entry.

Parameters:
    pszObjectGUID - pointer to buffer containing the GUID of the RETRYLIST entry to find or create.

Return Values:
    PRETRYLIST  - pointer to the found or create RETRYLIST entry.  This may be NULL if the entry is
                  not found and a new one could not be created.

--*/
{
    PRETRYLIST  pRetry = &gRetry;
    int         iRet = -1;

    for (; pRetry->pNext ; pRetry = pRetry->pNext) {
        //
        // If entry exists, just return
        //
        if (!(iRet = wcscmp(pszObjectGUID, pRetry->pNext->pszObjectGUID)))
            return pRetry->pNext;
        //
        // If next entry is greater than New entry, then insert New entry here
        //
        if (iRet > 0)
            break;
    }

    //
    // Create a new entry
    //
    PRETRYLIST pRetryNew;

    if (!(pRetryNew = (PRETRYLIST) AllocSplMem(sizeof(RETRYLIST))))
        return NULL;

    if (!(pRetryNew->pszObjectGUID = (PWSTR) AllocSplStr(pszObjectGUID))) {
        FreeSplMem(pRetryNew);
        return NULL;
    }

    if (!pRetry->pNext) {   
        //
        // End of list
        //
        pRetryNew->pNext = NULL;
        pRetryNew->pPrev = pRetry;
        pRetry->pNext = pRetryNew;
    } else {                
        //
        // Middle of list
        //
        pRetryNew->pNext = pRetry->pNext;
        pRetryNew->pPrev = pRetry;
        pRetry->pNext->pPrev = pRetryNew;
        pRetry->pNext = pRetryNew;
    }

    pRetryNew->nRetries = 0;

    return pRetryNew;
}


VOID
DeleteRetry(
    PRETRYLIST pRetry
)
{
    SPLASSERT(pRetry != &gRetry);
    SPLASSERT(pRetry);
    SPLASSERT(pRetry->pszObjectGUID);
    SPLASSERT(pRetry->pPrev);

    pRetry->pPrev->pNext = pRetry->pNext;

    if (pRetry->pNext)
        pRetry->pNext->pPrev = pRetry->pPrev;

    FreeSplStr(pRetry->pszObjectGUID);
    FreeSplMem(pRetry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\eventlog.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation
All rights reserved.

Module Name:

    eventlog.c

Abstract:

    This module provides all functions that the Local Print Providor
    uses to write to the Event Log.

    InitializeEventLogging
    DisableEventLogging
    LogEvent
    GetUserSid

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Matthew Felton ( MattFe ) 15-Mar-1995
    Change defaults on Workstation to not log information messages
    Also add regsitry key to allow user to filter some types of call


--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

#define MAX_MERGE_STRINGS   7

HANDLE hEventSource = NULL;

#if DBG
BOOL   EventLogFull = FALSE;
#endif

BOOL
GetUserSid(
    PTOKEN_USER *ppTokenUser,
    PDWORD pcbTokenUser
);

DWORD
InitializeEventLogging(
    PINISPOOLER pIniSpooler
    )
{
    DWORD Status;
    HKEY  hkey;
    DWORD dwData;
    DWORD dwDisposition;

    DWORD Flags;
    NT_PRODUCT_TYPE NtProductType;

    //
    // Initialize defaults.
    //
    pIniSpooler->dwEventLogging = LOG_DEFAULTS_WORKSTATION_EVENTS;

    //
    // Default is no NetPopup. 0 - Disable NetPopup, 1 - Enable
    //
    pIniSpooler->bEnableNetPopups = 0;

    //
    //  Caching Providers Might not require Event Logging
    //

    if ( ( pIniSpooler->SpoolerFlags & SPL_LOG_EVENTS ) == FALSE ) return TRUE;

    //
    // Turn on logging if we are a server.
    //

    if (RtlGetNtProductType(&NtProductType)) {

        if (NtProductType != NtProductWinNt) {

            pIniSpooler->dwEventLogging = LOG_ALL_EVENTS;

        }
    }

    //
    // If we aren't event logging or we are a cluster reg, then
    // don't initialize per-machine resources.
    //
    if( pIniSpooler != pLocalIniSpooler ){
        return NO_ERROR;
    }

    Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                            pIniSpooler->pszRegistryEventLog,
                            0,
                            NULL,
                            0,
                            KEY_WRITE,
                            NULL,
                            &hkey,
                            &dwDisposition);


    if( Status == NO_ERROR )
    {
        // Add the Event-ID message-file name to the subkey.

        Status = RegSetValueEx( hkey,
                                L"EventMessageFile",
                                0,
                                REG_EXPAND_SZ,
                                (LPBYTE)pIniSpooler->pszEventLogMsgFile,
                                wcslen( pIniSpooler->pszEventLogMsgFile ) * sizeof( WCHAR )
                                + sizeof( WCHAR ) );

        if( Status != NO_ERROR )
        {
            DBGMSG( DBG_ERROR, ( "Could not set event message file: Error %d\n",
                                 Status ) );
        }

        dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE
                 | EVENTLOG_INFORMATION_TYPE;

        if( Status == NO_ERROR )
        {
            Status = RegSetValueEx( hkey,
                                    L"TypesSupported",
                                    0,
                                    REG_DWORD,
                                    (LPBYTE)&dwData,
                                    sizeof dwData );

            if( Status != NO_ERROR )
            {
                DBGMSG( DBG_ERROR, ( "Could not set supported types: Error %d\n",
                                     Status ) );
            }
        }

        RegCloseKey(hkey);
    }

    else
    {
        DBGMSG( DBG_ERROR, ( "Could not create registry key for event logging: Error %d\n",
                             Status ) );
    }

    if( Status == NO_ERROR )
    {
        if( !( hEventSource = RegisterEventSource( NULL, L"Print" ) ) )
            Status = GetLastError( );
    }

    return Status;
}

VOID
SplLogEventWorker(
    IN      PINISPOOLER pIniSpooler,
    IN      WORD        EventType,
    IN      NTSTATUS    EventID,
    IN      BOOL        bInSplSem,
    IN      LPWSTR      pFirstString,
    IN      va_list     vargs
)
/*++

Function Description:

    This provides a common entry point to support event logging. This is now
    called by the print processor and Win32spl.

Parameters:

    EventType   - E.g. LOG_ERROR (defined in local.h)

    EventID     - Constant as defined in messages.h.  This refers to a string
                  resource located in the event-log message DLL specified in
                  InitializeEventLogging (which currently is localspl.dll itself).

    bInSplSem   - flag to indicate if the call was made from inside SplSem

    pFirstString- The first of up to MAX_MERGE_STRINGS.  This may be NULL,
                  if no strings are to be inserted.  If strings are passed to this
                  routine, the last one must be followed by NULL.
                  Don't rely on the fact that the argument copying stops when it
                  reaches MAX_MERGE_STRINGS, because this could change if future
                  messages are found to need more replaceable parameters.

    vargs       - The remaining strings to be passed in.

Return Values: NONE

--*/
{
    PTOKEN_USER pTokenUser = NULL;
    DWORD       cbTokenUser;
    PSID        pSid = NULL;
    LPWSTR      pMergeStrings[MAX_MERGE_STRINGS];
    WORD        cMergeStrings = 0, index;
    DWORD       LastError = GetLastError();

    if (!hEventSource)
        return;

    //
    // If the Inispooler is NULL, don't check whether to log an event, just log one,
    // This allows us to log events when failing to start up spooler.
    //
    if ( pIniSpooler )
    {
        if (( pIniSpooler->dwEventLogging & EventType ) == FALSE )
            return;

        if ( ( pIniSpooler->SpoolerFlags & SPL_LOG_EVENTS ) == FALSE )
            return;
    }

    if( GetUserSid( &pTokenUser, &cbTokenUser ) )
        pSid = pTokenUser->User.Sid;

    // Put the strings into a format accepted by ReportEvent,
    // by picking off each non-null argument, and storing it in the array
    // of merge strings.  Continue till we hit a NULL, or MAX_MERGE_STRINGS.

    if( pFirstString )
    {
        LPWSTR pszInsert;

        if (pMergeStrings[cMergeStrings] = AllocSplStr(pFirstString))
        {
            cMergeStrings++;
        }
        else
        {
            goto CleanUp;
        }

        while ((cMergeStrings < MAX_MERGE_STRINGS) &&
               (pszInsert = va_arg(vargs, LPWSTR))) {

            if (pMergeStrings[cMergeStrings] = AllocSplStr(pszInsert))
            {
                cMergeStrings++;
            }
            else
            {
                goto CleanUp;
            }
        }
    }

    //
    //  Leave the semaphore before calling into the event logging service
    //
    if (bInSplSem)
    {
        LeaveSplSem();
        SplOutSem();
    }

    if ( !ReportEvent(hEventSource,    // handle returned by RegisterEventSource
                      EventType,       // event type to log
                      0,               // event category
                      EventID,         // event identifier
                      pSid,            // user security identifier (optional)
                      cMergeStrings,   // number of strings to merge with message
                      0,               // size of raw data (in bytes)
                      pMergeStrings,   // array of strings to merge with message
                      NULL) ) {       // address of raw data
#if DBG
        if( GetLastError() == ERROR_LOG_FILE_FULL ) {

            // Put out a warning message only the first time this happens:

            if( !EventLogFull ) {

                DBGMSG( DBG_WARNING, ( "The Event Log is full\n" ) );
                EventLogFull = TRUE;
            }

        } else {

            DBGMSG( DBG_WARNING, ( "ReportEvent failed: Error %d\n", GetLastError( ) ));
        }
#endif // DBG
    }

    //
    //  Reenter the semaphore after logging the event
    //
    if (bInSplSem)
    {
        EnterSplSem();
    }

CleanUp:

    // Free the strings
    for (index = 0; index < cMergeStrings ; index++) {

        FreeSplStr(pMergeStrings[index]);
    }

    if( pTokenUser ) {

        FreeSplMem( pTokenUser );
    }
    // GetUserSid() wipes out the Last Error, so restore it before returning
    SetLastError(LastError);
}

VOID
SplLogEvent(
    PINISPOOLER pIniSpooler,
    WORD        EventType,
    NTSTATUS    EventID,
    BOOL        bInSplSem,
    LPWSTR      pFirstString,
    ...
)
/*++

Function Description: Writes to the event log with up to MAX_MERGE_STRINGS parameter strings.

Parameters: EventType -   E.g. LOG_ERROR (defined in local.h)

            EventID   -   Constant as defined in messages.h.  This refers to a string
                          resource located in the event-log message DLL specified in
                          InitializeEventLogging (which currently is localspl.dll itself).

            bInSplSem -   flag to indicate if the call was made from inside SplSem

           pFirstString - The first of up to MAX_MERGE_STRINGS.  This may be NULL,
                          if no strings are to be inserted.  If strings are passed to this
                          routine, the last one must be followed by NULL.
                          Don't rely on the fact that the argument copying stops when it
                          reaches MAX_MERGE_STRINGS, because this could change if future
                          messages are found to need more replaceable parameters.

Return Values: NONE

--*/
{
    va_list vargs;

    va_start(vargs, pFirstString);

    SplLogEventWorker(pIniSpooler, EventType, EventID, bInSplSem, pFirstString, vargs);

    va_end(vargs);
}

VOID
PrintProcLogEvent(
    WORD     EventType,
    NTSTATUS EventID,
    LPWSTR   pLog
)

/*++
Function Description: This is an export for the print processor to log errors.

Parameters:  EventType - E.g. LOG_ERROR (defined in local.h)
             EventID   - Constant as defined in messages.h
             pLog      - string containg the log message

Return Values: NONE
--*/

{
    // Ensure that the last parameter is NULL
    if (pLog == NULL)
    {
        SplLogEvent(pLocalIniSpooler, EventType, EventID, FALSE, NULL);
    }
    else
    {
        SplLogEvent(pLocalIniSpooler, EventType, EventID, FALSE, pLog, NULL);
    }

    return;
}

VOID
SplLogEventExternal(
    IN      WORD        EventType,
    IN      DWORD       EventID,
    IN      LPWSTR      pFirstString,
    ...
)
/*++

Function Description:

    This is an export for external components to log an event. (It is currently
    used for Win32spl). It supports variable arguments, unlike PrintProcLogEvent.

Parameters:

    EventType       - E.g. LOG_ERROR (defined in local.h)
    EventID         - Constant as defined in messages.h
    pFirstString    - The first string supplied by the system in the log message.
    ...             - The remaining strings, must be NULL terminated.

Return Values: NONE

--*/
{
    va_list vargs;

    va_start(vargs, pFirstString);

    //
    // It might not seem logical to use the local inispooler. However, win32spl's
    // inispooler's explicitely turn off event logging. So, this is necessary.
    // Passing in NULL seems worse since this would mean you could not tone down
    // event logging for those events.
    //
    SplLogEventWorker(pLocalIniSpooler, EventType, (NTSTATUS)EventID, FALSE, pFirstString, vargs);

    va_end(vargs);
}

 // GetUserSid
 //
 // Well, actually it gets a pointer to a newly allocated TOKEN_USER,
 // which contains a SID, somewhere.
 // Caller must remember to free it when it's been used.

BOOL
GetUserSid(
    PTOKEN_USER *ppTokenUser,
    PDWORD pcbTokenUser
)
{
    HANDLE      TokenHandle;
    HANDLE      ImpersonationToken;
    PTOKEN_USER pTokenUser = NULL;
    DWORD       cbTokenUser = 0;
    DWORD       cbNeeded;
    BOOL        bRet = FALSE;

    if ( !GetTokenHandle( &TokenHandle) ) {
        return FALSE;
    }

    ImpersonationToken = RevertToPrinterSelf();

    bRet = GetTokenInformation( TokenHandle,
                                TokenUser,
                                pTokenUser,
                                cbTokenUser,
                                &cbNeeded);

    // We've passed a NULL pointer and 0 for the amount of memory
    // allocated.  We expect to fail with bRet = FALSE and
    // GetLastError = ERROR_INSUFFICIENT_BUFFER. If we do not
    // have these conditions we will return FALSE

    if ( !bRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER) ) {

        pTokenUser = AllocSplMem( cbNeeded );

        if ( pTokenUser == NULL ) {

            goto GetUserSidDone;
        }

        cbTokenUser = cbNeeded;

        bRet = GetTokenInformation( TokenHandle,
                                    TokenUser,
                                    pTokenUser,
                                    cbTokenUser,
                                    &cbNeeded );

    } else {

        //
        // Any other case -- return FALSE
        //

        bRet = FALSE;
    }

GetUserSidDone:
    if ( bRet == TRUE ) {

        *ppTokenUser  = pTokenUser;
        *pcbTokenUser = cbTokenUser;

    } else if ( pTokenUser ) {

        FreeSplMem( pTokenUser );
    }

    if (!ImpersonatePrinterClient( ImpersonationToken ))
    {
        bRet = FALSE;
    }

    CloseHandle( TokenHandle );

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\filepool.cxx ===
/*++

Copyright (c) 1990 - 2000  Microsoft Corporation

Module Name:

    filepool.cxx

Abstract:

    Contains the routines for handling Filepools for the Spooler. Contains the C++ objects
    and the C wrapper functions.

Author:

    Bryan Kilian (Bryankil) 5-Apr-2000

Revision History:


--*/


#include "precomp.h"

#pragma hdrstop


#include "filepool.hxx"


VOID FPCloseFiles(struct FileListItem * pItem, BOOL CloseShad);

/*--

Interface Functions:

    CreateFilePool
    GetFileItemHandle
    GetNameFromHandle
    GetWriterFromHandle
    GetReaderFromHandle
    ReleasePoolHandle
    DestroyFilePool

--*/

/*********************
 * CreateFilePool()
 *
 * Creates the Filepool.
 *
 * Arguments:
 *   OUT  FilePool     : Pointer to a Filepool handle.
 *   IN   BasePath     : String to use as a spool dir.
 *   IN   PreNumStr    : String to use as a filename prefix.
 *   IN   SplExt       : String to use as a spool extension.
 *   IN   ShdExt       : String to use as a shadow file extension.
 *   IN   PoolTimeout  : Dword in milliseconds before an idle pool item gets deleted.
 *   IN   MaxFiles     : Maximum number of free files in the pool.
 *
 * The path gets created as <Basepath>\<PreNumStr>XXXXX<SplExt>
 *
 */


HRESULT CreateFilePool(
    HANDLE * FilePoolHandle,
    LPCTSTR  BasePath,
    LPCTSTR  PreNumStr,
    LPCTSTR  SplExt,
    LPCTSTR  ShdExt,
    DWORD    PoolTimeout,
    DWORD    MaxFiles
    )
{
    HRESULT RetVal = E_FAIL;

    class FilePool * FP = NULL;

    if (FilePoolHandle && BasePath && PreNumStr && SplExt && ShdExt)
    {
        MaxFiles = (MaxFiles > 9999) ? 9999 : MaxFiles;
        FP = new FilePool(
                    PoolTimeout,
                    MaxFiles
                    );


        if ( FP )
        {
            RetVal = FP->AllocInit(
                            BasePath,
                            PreNumStr,
                            SplExt,
                            ShdExt
                            );
            if (SUCCEEDED(RetVal))
            {
                *FilePoolHandle = (HANDLE) FP;
            }
            else
            {
                delete FP;
                *FilePoolHandle = INVALID_HANDLE_VALUE;
            }
        }
        else
        {
            RetVal = E_OUTOFMEMORY;
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }


    return RetVal;
}

/*********************
 * GetFileItemHandle()
 *
 * Takes a FilePool Object and An empty Filehandle, and returns
 * an open File handle. Use ReleasePoolHandle Once you're finished
 * with the file.
 *
 * Arguments:
 *   IN   FilePool     : Handle of a FilePool Object Created with CreateFilePool()
 *   OUT  FileItem     : Pointer to a FileItem Handle.
 *   IN   FromFilename : String to use as a filename.
 *
 * Returns Error if it is passed in an invalid argument, or S_OK if it succeeds.
 *
 */

HRESULT
GetFileItemHandle(
    HANDLE FilePoolHandle,
    HANDLE * FileItem,
    LPWSTR FromFilename
    )
{
   class FilePool * FP = NULL;
   HRESULT RetVal = E_FAIL;
   struct FileListItem * FLItem = NULL;

   FP = (class FilePool *)FilePoolHandle;

   RetVal = FP->GetWriteFileStruct(&FLItem, FromFilename);

   if (SUCCEEDED(RetVal))
   {
       *FileItem = (HANDLE) FLItem;
   }
   else
   {
       *FileItem = INVALID_HANDLE_VALUE;
   }

   return RetVal;
}


/*********************
 * GetNameFromHandle()
 *
 * Takes a FileItem and a string pointer, and returns
 * an allocated string containing the name of the file.
 *
 * Arguments:
 *   IN   FileItem     : Handle of a FileItem, retrieved with GetFileItemHandle()
 *   OUT  FileNameStr  : Pointer to a string variable.
 *   IN   IsSpool      : BOOL - TRUE - Returns the Spool Filename, FALSE returns the Shadow Filename
 *
 * Returns Error if it is passed in an invalid argument or if it cannot allocate the string,
 * or S_OK if it succeeds.
 *
 */

HRESULT
GetNameFromHandle(
    HANDLE FileItem,
    PWSTR * FileNameStr,
    BOOL    IsSpool
    )
{
    HRESULT RetVal = S_OK;
    struct FileListItem * FPI;

    if (FileItem && (FileItem != INVALID_HANDLE_VALUE))
    {
        FPI = (struct FileListItem *)FileItem;

        if (FileNameStr && !*FileNameStr)
        {
            if (IsSpool)
            {
                *FileNameStr = AllocSplStr(FPI->SplFilename);
            }
            else
            {
                *FileNameStr = AllocSplStr(FPI->ShdFilename);
            }
            if (!*FileNameStr)
            {
                RetVal = E_OUTOFMEMORY;
            }
        }
        else
        {
            RetVal = E_INVALIDARG;
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }

    return RetVal;
}

/*********************
 * GetCurrentWriter()
 *
 * Takes a FileItem and returns a FileHandle of the current WriteHandle if it exists.
 *
 * Arguments:
 *   IN   FileItem     : FileItem Handle.
 *   IN   IsSpool      : BOOL - TRUE: Returns the Spool file handle, FALSE returns the Shadow file handle.
 *
 * This will not create a writer if it is not yet created, and will also not update the object's flags.
 *
 * Return: Valid Handle if success or INVALID_HANDLE_VALUE.
 */

HANDLE GetCurrentWriter(
    HANDLE FileItem,
    BOOL   IsSpool)
{
    struct FileListItem * FPI;
    HANDLE RetVal = INVALID_HANDLE_VALUE;
    HANDLE Temp = INVALID_HANDLE_VALUE;

    if (FileItem)
    {
        FPI = (struct FileListItem *) FileItem;

        FPI->EnterCritSec();

        if (IsSpool)
        {
            Temp = FPI->SplWriteHandle;
        }
        else
        {
            Temp = FPI->ShdWriteHandle;
        }

        FPI->LeaveCritSec();

        if (Temp != INVALID_HANDLE_VALUE)
        {
            RetVal = Temp;
        }
    }

    return RetVal;
}

/*********************
 * GetFileCreationInfo
 *
 * Takes a FileItem and returns a bitmap.
 *
 * Arguments:
 *   IN   FileItem     : FileItem Handle.
 *   OUT  BitMap
 *
 * Returns bitmap indicating which files needed to be opened.  Bitmap reset when
 * the pool handle is released.
 *
 * Return: S_OK if success, otherwise an error value.
 */


HRESULT
GetFileCreationInfo(
    HANDLE FileItem,
    PDWORD BitMap
    )
{
    struct FileListItem * FPI;
    *BitMap = 0;

    if (FileItem && (FileItem != INVALID_HANDLE_VALUE))
    {
        FPI = (struct FileListItem *) FileItem;
        *BitMap = FPI->CreateInfo;
        return S_OK;
    }
    return E_FAIL;
}



/*********************
 * GetWriterFromHandle()
 *
 * Takes a FileItem and returns a FileHandle with an open Writer.
 *
 * Arguments:
 *   IN   FileItem     : FileItem Handle.
 *   OUT  File         : Pointer to a filehandle.
 *   IN   IsSpool      : BOOL - TRUE: Returns the Spool file handle, FALSE returns the Shadow file handle.
 *
 * This will create a writer if it is not yet created, and will also update the object's flags. It will
 * return the current handle if there is one.
 *
 * Return: S_OK if success, otherwise an error value.
 */

HRESULT
GetWriterFromHandle(
    HANDLE   FileItem,
    HANDLE * File,
    BOOL     IsSpool
    )
{
    HRESULT RetVal = S_OK;
    class FilePool * FP = NULL;
    struct FileListItem * FPI;


    if (FileItem && File)
    {
        FPI = (struct FileListItem *) FileItem;
        FP = FPI->FP;

        *File = INVALID_HANDLE_VALUE;

        FPI->EnterCritSec();

        if (IsSpool)
        {
            if (FPI->SplWriteHandle == INVALID_HANDLE_VALUE)
            {
                RetVal = FP->CreateSplWriter(FPI);
            }

        }
        else
        {
            if (FPI->ShdWriteHandle == INVALID_HANDLE_VALUE)
            {
                RetVal = FP->CreateShdWriter(FPI);
            }

        }

        if (SUCCEEDED(RetVal))
        {
            if (IsSpool)
            {
                *File = FPI->SplWriteHandle;
                FPI->Status |= FP_STATUS_SPL_WRITING;
            }
            else
            {
                *File = FPI->ShdWriteHandle;
                FPI->Status |= FP_STATUS_SHD_WRITING;
            }
        }
        else
        {
            RetVal = E_FAIL;
        }

        FPI->LeaveCritSec();

    }
    else
    {
        RetVal = E_INVALIDARG;
    }


    return RetVal;
}

/*********************
 * GetReaderFromHandle()
 *
 * Takes a FileItem and returns a FileHandle with an open Reader.
 *
 * Arguments:
 *   IN   FileItem     : FileItem Handle.
 *   OUT  File         : Pointer to a filehandle.
 *
 * This will create a Reader if it is not yet created, and will also update the object's flags. It will
 * return the current handle if there is one. It will also return the writer if the system is finished with it.
 *
 * Return: S_OK if success, otherwise an error value.
 */

HRESULT
GetReaderFromHandle(
    HANDLE FileItem,
    HANDLE * File
    )
{
    HRESULT RetVal = S_OK;
    class FilePool * FP = NULL;
    struct FileListItem * FPI;

    if (FileItem)
    {
        FPI = (struct FileListItem *) FileItem;
        FP = FPI->FP;

        // CriticalSection

        FPI->EnterCritSec();

        if (!(FPI->Status & FP_STATUS_SPL_WRITING) &&
            (FPI->SplWriteHandle != INVALID_HANDLE_VALUE) &&
            (FPI->SplReadHandle == INVALID_HANDLE_VALUE) )
        {
            //
            // We aren't writing this job anymore, we can reuse the
            // write handle for reading.
            //
            if (!(FPI->Status & FP_STATUS_SPL_READING))
            {
                if (SetFilePointer(FPI->SplWriteHandle, 0, NULL, FILE_BEGIN) !=
                    INVALID_SET_FILE_POINTER)
                {
                    *File = FPI->SplWriteHandle;
                    FPI->Status |= FP_STATUS_SPL_READING;
                }
                else
                {
                    RetVal = E_FAIL;
                }

            }
            else
            {
                *File = FPI->SplWriteHandle;
            }
        }
        else
        {
            //
            // We are still writing this job, so we need to use the readhandle.
            //
            if (FPI->SplReadHandle == INVALID_HANDLE_VALUE)
            {
                //
                // The Reader doesn't already exist, We need to create it.
                //
                RetVal = FP->CreateSplReader(FPI);

            }

            if (SUCCEEDED(RetVal))
            {
                //
                // We now have a valid handle
                //

                *File = FPI->SplReadHandle;
                FPI->Status |= FP_STATUS_SPL_READING;

            }
            else
            {
                RetVal = E_FAIL;
            }

        }

        FPI->LeaveCritSec();

    }
    else
    {
        RetVal = E_INVALIDARG;
    }
    return RetVal;
}

/*********************
 * FishedReading()
 *
 * Indicates to the object that we are finished with it for reading purposes.
 *
 * Arguments:
 *   IN   FileItem     : Handle of a FileItem.
 *
 * Returns Error if it is passed in an invalid argument, or S_OK if it succeeds.
 *
 */

HRESULT
FinishedReading(
    HANDLE FileItem
    )
{
    HRESULT RetVal = S_OK;
    struct FileListItem * FPI;

    if (FileItem)
    {
        FPI = (struct FileListItem *) FileItem;

        FPI->EnterCritSec();
        FPI->Status &= ~FP_STATUS_SPL_READING;
        CloseFilesCheck(FPI, kCloseReadHandle);
        FPI->LeaveCritSec();

    }
    else
    {
        RetVal = E_INVALIDARG;
    }


    return RetVal;

}

/*********************
 * FishedWriting()
 *
 * Indicates to the object that we are finished with it for writing purposes.
 *
 * Arguments:
 *   IN   FileItem     : Handle of a FileItem.
 *   IN   IsSpool      : BOOL - TRUE: Affects the Spl file, FALSE: Affects the Shd file.
 *
 * Returns Error if it is passed in an invalid argument, or S_OK if it succeeds.
 *
 */

HRESULT
FinishedWriting(
    HANDLE FileItem,
    BOOL   IsSpool
    )
{
    HRESULT RetVal = S_OK;
    struct FileListItem * FPI;

    if (FileItem)
    {
        FPI = (struct FileListItem *) FileItem;

        FPI->EnterCritSec();
        if (IsSpool)
        {
            FPI->Status &= ~FP_STATUS_SPL_WRITING;
            CloseFilesCheck(FPI, kCloseWriteHandle);
        }
        else
        {
            FPI->Status &= ~FP_STATUS_SHD_WRITING;
            CloseFilesCheck(FPI, kCloseShdHandle);
        }
        FPI->LeaveCritSec();
    }
    else
    {
        RetVal = E_INVALIDARG;
    }


    return RetVal;

}

/*********************
 * ReleasePoolHandle()
 *
 * Releases the pool item back to the pool to reuse. The pool will not reuse the item if all the
 * filehandles are closed, and also if we have reached our free files limit.
 *
 * Arguments:
 * IN OUT FileItem     : Pointer to a FileItem Handle.
 *
 * Returns Error if it fails, or S_OK if it succeeds. FileItem gets set to INVALID_HANDLE_VALUE if it succeeds.
 *
 */

HRESULT
ReleasePoolHandle(
    HANDLE * FileItem
    )
{
    HRESULT RetVal = S_OK;
    class FilePool * FP = NULL;
    struct FileListItem * FPI;

    if (FileItem && *FileItem )
    {
        FPI = (struct FileListItem *) *FileItem;
        FP = FPI->FP;

        //
        // This should not be in the critsec, since we might delete
        // the critical section.
        //
        RetVal = FP->ReleasePoolHandle(FPI);

        if (SUCCEEDED(RetVal))
        {
            *FileItem = INVALID_HANDLE_VALUE;
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }
    return RetVal;
}

/*********************
 * RemoveFromFilePool()
 *
 * Removes the pool item from the pool completely and frees the associated memory.
 *
 * Arguments:
 * IN OUT FileItem     : Pointer to a FileItem Handle.
 *    IN  Delete       : BOOL, Tells us whether to delete the files or not.
 *
 * Returns Error if it fails, or S_OK if it succeeds. FileItem gets set to INVALID_HANDLE_VALUE if it succeeds.
 *
 */

HRESULT
RemoveFromFilePool(
    HANDLE* FileItem,
    BOOL    Delete
    )
{
    HRESULT RetVal = S_OK;
    class FilePool * FP = NULL;
    struct FileListItem * FPI;

    if (FileItem && *FileItem )
    {
        FPI = (struct FileListItem *) *FileItem;
        FP = FPI->FP;

        RetVal = FP->RemoveFromPool(FPI, Delete);

        if (SUCCEEDED(RetVal))
        {
            *FileItem = INVALID_HANDLE_VALUE;
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }
    return RetVal;

}

/*++

Routine Name

    ForceCloseJobPoolFiles

Routine Description:

    Closes all the handles to the SHD and SPL files, regardless if they are in use or not.

Arguments:

    hFileItem - handle to file pool item

Return Value:

    S_OK - all handles were closed or hFileItem is NULL
    other HRESULT - an error occurred

--*/
HRESULT
ForceCloseJobPoolFiles(
    HANDLE hFileItem
    )
{
    HRESULT hRet = S_OK;

    if (hFileItem)
    {
        //
        // Mark the files as ready to be closed. The function below
        // won't close the file handles ,if they are in use
        //
        CloseFiles(hFileItem, TRUE);

        //
        // Because CloseFile marked the handles as ready to be closed, the function
        // below will close the handle for writing to the spool file
        //
        if (FAILED(hRet = FinishedWriting(hFileItem, TRUE)))
        {
            DBGMSG(DBG_WARN, ("ForceCloseJobPoolFiles FinishedWriting on SPL file failed. HRESULT 0x%x\n", hRet));
        }

        //
        // Because CloseFile marked the handles as ready to be closed, the function
        // below will close the handle for reading from the spool file
        //
        if (FAILED(hRet = FinishedReading(hFileItem)))
        {
            DBGMSG(DBG_WARN, ("ForceCloseJobPoolFiles FinishedReading failed. HRESULT 0x%x\n", hRet));
        }

        //
        // Because CloseFile marked the handles as ready to be closed, the function
        // below will close the handle for writing to the shadow file
        //
        if (FAILED(hRet = FinishedWriting(hFileItem, FALSE)))
        {
            DBGMSG(DBG_WARN, ("ForceCloseJobPoolFiles FinishedWriting on SHD file failed. HRESULT 0x%x\n", hRet));
        }
    }

    return hRet;
}


/*********************
 * CloseFiles()
 *
 * Closes the filehandles in the Pool Item (To save memory).
 *
 * Arguments:
 *   IN  FileItem     : FileItem Handle.
 *   IN  CloseShad    : Close the shadow file handle too.
 *
 *
 */

VOID
CloseFiles(
    HANDLE FileItem,
    BOOL   CloseShad
    )
{
    struct FileListItem * FPI;

    if (FileItem )
    {
        FPI = (struct FileListItem *) FileItem;

        FPCloseFiles(FPI, CloseShad);
    }
}

/*********************
 * CloseFilesCheck()
 *
 * Checks to see if there are any file handles which were not
 * closed on the call to CloseFiles because they were in use.
 * If the status was set at that time we delete the files now.
 * Assumes we are holding the critical section.
 *
 * Arguments:
 *   IN  FileListItem     : FileListItem pointer.
 *   IN  CloseHandle      : Type of handle to be closed.
 *
 */

VOID
CloseFilesCheck(
    FileListItem *pItem,
    ECloseHandle eCloseHandle
    )
{
    if (pItem)
    {
        switch (eCloseHandle)
        {
        case kCloseWriteHandle:

            if ((pItem->Status & FP_STATUS_SPL_WRITE_CLOSED) && pItem->SplWriteHandle != INVALID_HANDLE_VALUE)
            {
                __try
                {
                    CloseHandle(pItem->SplWriteHandle);
                    pItem->SplWriteHandle = INVALID_HANDLE_VALUE;
                }
                __except ( EXCEPTION_EXECUTE_HANDLER )
                {
                    DBGMSG(DBG_WARN, ("Hit an Exception Closing SplWriteHandle in CloseFilesCheck\n"));
                    pItem->SplWriteHandle = INVALID_HANDLE_VALUE;
                }
            }
            break;

        case kCloseReadHandle:

            if ((pItem->Status & FP_STATUS_SPL_READ_CLOSED) && pItem->SplReadHandle != INVALID_HANDLE_VALUE)
            {
                __try
                {
                    CloseHandle(pItem->SplReadHandle);
                    pItem->SplReadHandle = INVALID_HANDLE_VALUE;
                }
                __except ( EXCEPTION_EXECUTE_HANDLER )
                {
                    DBGMSG(DBG_WARN, ("Hit an Exception Closing SplReadHandle in CloseFilesCheck\n"));
                    pItem->SplReadHandle = INVALID_HANDLE_VALUE;
                }
            }
            break;

        case kCloseShdHandle:
            if ((pItem->Status & FP_STATUS_SHD_CLOSED) && pItem->ShdWriteHandle != INVALID_HANDLE_VALUE)
            {
                __try
                {
                    CloseHandle(pItem->ShdWriteHandle);
                    pItem->ShdWriteHandle = INVALID_HANDLE_VALUE;
                }
                __except ( EXCEPTION_EXECUTE_HANDLER )
                {
                    DBGMSG(DBG_WARN, ("Hit an Exception Closing ShdWriteHandle in CloseFilesCheck\n"));
                    pItem->ShdWriteHandle = INVALID_HANDLE_VALUE;
                }
            }
            break;

        default:
            break;
        }
    }
}

/*********************
 * SetFileItemState
 *
 * Takes a FilePool Object and frees it, optionally deleting the files associated with it.
 *
 * Arguments:
 *  hFileItem       -   The file item whose state we are going to change.
 *  eState          -   The new state of the file item
 *
 * Returns Error if it is passed in an invalid argument, or S_OK if it succeeds.
 *
 */
HRESULT
SetFileItemState(
    IN      HANDLE              hFileItem,
    IN      EFileItemState      eState
    )
{
    HRESULT     hr  = S_OK;

    hr = hFileItem ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hr))
    {
        hr = FPSetFileItemState(reinterpret_cast<FileListItem *>(hFileItem), eState);
    }

    return hr;
}


/*********************
 * DestroyFilePool()
 *
 * Takes a FilePool Object and frees it, optionally deleting the files associated with it.
 *
 * Arguments:
 * IN OUT FilePoolHandle : Pointer to existing Filepool.
 *    IN  DeleteFiles    : BOOL - TRUE: Delete the Pool files.
 *
 * Returns Error if it is passed in an invalid argument, or S_OK if it succeeds.
 *
 */

HRESULT
DestroyFilePool(
    HANDLE* FilePoolHandle,
    BOOL    DeleteFiles
    )
{
    HRESULT RetVal = S_OK;
    class FilePool * FP = NULL;

    if (FilePoolHandle && *FilePoolHandle)
    {
        FP = (class FilePool *)FilePoolHandle;

        FP->DeleteEmptyFilesOnClose = DeleteFiles;

        delete FP;
    }
    else
    {
        RetVal = E_INVALIDARG;
    }

    return RetVal;
}


/*********************
 * TrimPool()
 *
 * Takes a FilePool Object and trim the free list, deleting old files.
 *
 * Arguments:
 *   IN   FilePool     : Handle of a FilePool Object Created with CreateFilePool()
 *
 * Returns TRUE if there are files still in the free list, or FALSE if no files left.
 */

BOOL
TrimPool(
    HANDLE FilePoolHandle
    )
{
    class FilePool * FP = NULL;
    BOOL Retval = FALSE;

    if (FilePoolHandle)
    {
        FP = (class FilePool *)FilePoolHandle;

        Retval = FP->TrimPool();
    }

    return Retval;
}


/*********************
 * ChangeFilePoolBasePath()
 *
 * Takes a FilePool Object and changes the base path in it. This will be called
 * when the spool directory is changed.
 *
 * Arguments:
 *   IN   FilePool     : Handle of a FilePool Object Created with CreateFilePool
 *   IN   BasePath     : New base path to use
 *
 * Returns an HRESULT
 */
HRESULT
ChangeFilePoolBasePath(
    IN HANDLE  *FilePoolHandle,
    IN LPCTSTR  BasePath
    )
{
    FilePool    *FP = (FilePool *)FilePoolHandle;
    HRESULT RetVal = E_INVALIDARG;
    LPTSTR  FileBase = NULL;

    if (FP)
    {
        if (FileBase = AllocSplStr(BasePath))
        {
            FP->EnterCritSec();

            FreeSplStr(FP->FileBase);
            FP->FileBase = FileBase;
            FP->LeaveCritSec();

            RetVal = S_OK;
        }
        else
        {
            RetVal = E_OUTOFMEMORY;
        }
    }

    return RetVal;
}


/*--
Generic Utility Functions

  ConvertFileExt

--*/

/*********************
 * ConvertFileExt()
 *
 * Utility function to change one extension to another.
 * Requires the extension to only be in the filename once.
 * The extensions being converted must be the same size.
 *
 * Arguments:
 * IN OUT FileName     : String of Filename to be changed.
 * IN     ExtFrom      : Extension to change.
 * IN     ExtTo        : Extension to change it to.
 *
 */

HRESULT
ConvertFileExt(
    PWSTR  Filename,
    PCWSTR ExtFrom,
    PCWSTR ExtTo
    )
{
    HRESULT RetVal = E_FAIL;
    PWSTR   Temp = NULL;
    DWORD   cchExtTo = 0;

    if (Filename && ExtFrom && ExtTo && (wcslen(ExtFrom) == (cchExtTo = wcslen(ExtTo))) && ExtFrom[0])
    {
        Temp = wcsstr(Filename, ExtFrom);

        if (Temp)
        {
            //
            // This should work in all our cases.
            //
            CopyMemory(Temp, ExtTo, cchExtTo * sizeof(WCHAR));
            RetVal = S_OK;
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }
    return RetVal;
}

/*--
FileItem Management Functions

    TruncateFiles

--*/

/*********************
 * TruncateFiles()
 *
 * Takes a File Item and truncates any open files to 0 length.
 *
 * Arguments:
 *   IN   FileListItem : Item containing the files to truncate.
 *
 *
 */
VOID
TruncateFiles(
    struct FileListItem * Item
    )
{
    BOOL Trunced = FALSE;
    if (Item)
    {
        Item->EnterCritSec();

        //
        // Reinitialize cache data.
        //
        Item->CreateInfo = 0;

        //
        // Truncate the Shadow File
        //
        if (Item->ShdWriteHandle != INVALID_HANDLE_VALUE)
        {
            if (SetFilePointer(Item->ShdWriteHandle, 0, NULL, FILE_BEGIN) !=
                     INVALID_SET_FILE_POINTER)
            {
                if (!SetEndOfFile(Item->ShdWriteHandle))
                {
                    DBGMSG(DBG_WARN, ("FAILED to set SPL end of file to 0 %d.\n", GetLastError()));
                }
            }
        }

        //
        // Truncate the Spool File. If the writehandle is closed, use the readhandle.
        //
        if (Item->SplWriteHandle != INVALID_HANDLE_VALUE)
        {
            if (SetFilePointer(Item->SplWriteHandle, 0, NULL, FILE_BEGIN) !=
                     INVALID_SET_FILE_POINTER)
            {
                if (!SetEndOfFile(Item->SplWriteHandle))
                {
                    DBGMSG(DBG_WARN, ("FAILED to set SPL end of file to 0 %d.\n", GetLastError()));
                }
            }
        }
        else if (Item->SplReadHandle != INVALID_HANDLE_VALUE)
        {
            if (SetFilePointer(Item->SplReadHandle, 0, NULL, FILE_BEGIN) !=
                     INVALID_SET_FILE_POINTER)
            {
                if (!SetEndOfFile(Item->SplReadHandle))
                {
                    DBGMSG(DBG_WARN, ("FAILED to set SPL end of file to 0 %d.\n", GetLastError()));
                }
            }
            // There is only one open spool handle at this point so make that
            // open handle the writer.  This is what the spooler needs when it
            // first requests a new pool item.  This also saves file I/O if the
            // next use of this item doesn't need both writer and reader at the
            // same time.
            Item->SplWriteHandle = Item->SplReadHandle;
            Item->SplReadHandle = INVALID_HANDLE_VALUE;

            Trunced = TRUE;
        }

        if ((Item->SplReadHandle != INVALID_HANDLE_VALUE) && !Trunced)
        {
            //CloseHandle(Item->SplReadHandle);
            SetFilePointer(Item->SplReadHandle, 0, NULL, FILE_BEGIN);
        }

        Item->LeaveCritSec();
    }
}


/*********************
 * FPCloseFiles()
 *
 * Takes a FileList item and closes the files associated with it, if they
 * are not in use. Else it just marks them as closed and it is the job of the
 * reader or writer to close the handles when it is done with them.
 *
 * Arguments:
 *   IN   FileListItem     : FileItem with files to close.
 *   IN   CloseShad        : BOOL - TRUE: Close the Shadow File too.
 *
 *
 */
VOID
FPCloseFiles(
    struct FileListItem * pItem,
    BOOL CloseShad
    )
{
    if (pItem)
    {
        pItem->EnterCritSec();

        if (pItem->SplWriteHandle != INVALID_HANDLE_VALUE)
        {
            if (pItem->Status & FP_STATUS_SPL_WRITING)
            {
                pItem->Status |= FP_STATUS_SPL_WRITE_CLOSED;
            }
            else
            {
                __try
                {
                    CloseHandle(pItem->SplWriteHandle);
                    pItem->SplWriteHandle = INVALID_HANDLE_VALUE;
                }
                __except ( EXCEPTION_EXECUTE_HANDLER )
                {
                    DBGMSG(DBG_WARN, ("Hit an Exception Closing SplWriteHandle in FPCloseFiles\n"));
                    pItem->SplWriteHandle = INVALID_HANDLE_VALUE;
                }
            }
        }

        if (pItem->SplReadHandle != INVALID_HANDLE_VALUE)
        {
            if (pItem->Status & FP_STATUS_SPL_READING)
            {
                pItem->Status |= FP_STATUS_SPL_READ_CLOSED;
            }
            else
            {
                __try
                {
                    CloseHandle(pItem->SplReadHandle);
                    pItem->SplReadHandle = INVALID_HANDLE_VALUE;
                }
                __except ( EXCEPTION_EXECUTE_HANDLER )
                {
                    DBGMSG(DBG_WARN, ("Hit an Exception Closing SplReadHandle in FPCloseFiles\n"));
                    pItem->SplReadHandle = INVALID_HANDLE_VALUE;
                }
            }
        }

        if ( CloseShad && pItem->ShdWriteHandle != INVALID_HANDLE_VALUE)
        {
            if (pItem->Status & FP_STATUS_SPL_WRITING)
            {
                pItem->Status |= FP_STATUS_SPL_WRITE_CLOSED;
            }
            else
            {
                __try
                {
                    CloseHandle(pItem->ShdWriteHandle);
                    pItem->ShdWriteHandle = INVALID_HANDLE_VALUE;
                }
                __except ( EXCEPTION_EXECUTE_HANDLER )
                {
                    DBGMSG(DBG_WARN, ("Hit an Exception Closing ShdWriteHandle in FPCloseFiles\n"));
                    pItem->ShdWriteHandle = INVALID_HANDLE_VALUE;
                }
            }
        }

        pItem->LeaveCritSec();
    }
}

/*********************
 * FPSetFileItemState
 *
 * Changes the state of a file pool item. Currently, it can just be marked not
 * to recycle the file pool object.
 *
 * Arguments:
 *   pItem          : The file list item.
 *   eFileItemState : New state for the file item.
 *
 */
HRESULT
FPSetFileItemState(
    IN      FileListItem        *pItem,
    IN      EFileItemState      eFileItemState
    )
{
    HRESULT hr = S_OK;

    pItem->EnterCritSec();

    switch(eFileItemState)
    {
    case kDontRecycle:

        pItem->Status |= FP_STATUS_ITEM_DONT_RECYCLE;
        break;

    default:

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_LEVEL);
        break;
    }


    pItem->LeaveCritSec();

    return hr;
}


/*********************
 * DeletePoolFile()
 *
 * Takes a FilePool Object and trim the free list, deleting old files and freeing memory.
 *
 * Arguments:
 * IN OUT FileListItem     : FileItem to delete the files from and free up.
 *
 * Closes the files, deletes them, frees the memory, and sets the pItem to NULL
 *
 */
VOID
DeletePoolFile(struct FileListItem ** ppItem)
{
    struct FileListItem * pItem;

    if (ppItem && *ppItem)
    {
        pItem = *ppItem;
        FPCloseFiles(pItem, TRUE);

        DeleteCriticalSection(&pItem->CritSec);

        if (pItem->SplFilename)
        {
            DeleteFile(pItem->SplFilename);
            FreeSplMem(pItem->SplFilename);
        }

        if (pItem->ShdFilename)
        {
            DeleteFile(pItem->ShdFilename);
            FreeSplMem(pItem->ShdFilename);
        }

        FreeSplMem(pItem);
    }


    *ppItem = NULL;
}

/*--

List Management Functions

    RemoveFromFPList
    AddToFPListEnd
    AddToFPListHead

--*/



HRESULT
RemoveFromFPList(
    struct FileListItem * Item,
    struct FileListItem ** Head,
    struct FileListItem ** Tail
    )
{
    struct FileListItem * Check = NULL;
    HRESULT RetVal = E_FAIL;

    //
    // Validate we have valid args.
    //
    if ( Item && Head && *Head && Tail && *Tail )
    {

        for ( Check = *Head; Check && (Item != Check); Check = Check->FLNext );

        if ( Check )
        {
            if ( *Head == Check )
            {
                *Head = Check->FLNext;
            }
            else
            {
                Check->FLPrev->FLNext = Check->FLNext;

            }

            if ( *Tail == Check )
            {
                *Tail = Check->FLPrev;
            }
            else
            {
                Check->FLNext->FLPrev = Check->FLPrev;
            }

            Check->FLNext = NULL;
            Check->FLPrev = NULL;

            RetVal = S_OK;

        }
        else
        {
            //
            // you gave me a pointer to an item not in the list.
            //
            RetVal = E_POINTER;
        }


    }
    else
    {
        RetVal = E_INVALIDARG;
    }

    return RetVal;
}

HRESULT
AddToFPListEnd(
    struct FileListItem * Item,
    struct FileListItem ** Head,
    struct FileListItem ** Tail
    )
{
    struct FileListItem * Check = NULL;
    HRESULT RetVal = E_FAIL;

    //
    // Validate we have valid args.
    //
    if ( Item && Head && Tail )
    {

        if ( *Tail )
        {
            //
            // There are items in the list, add something
            // onto the end.
            //
            Check = *Tail;

            Check->FLNext = Item;
            Item->FLPrev = Check;
            Item->FLNext = NULL;

            *Tail = Item;
            RetVal = S_OK;
        }
        else
        {
            if ( *Head )
            {
                //
                // If we have a head and no tail, something
                // is seriously wrong.
                //
                RetVal = E_FAIL;
            }
            else
            {
                //
                // Adding the first item into a list.
                //

                Item->FLNext = NULL;
                Item->FLPrev = NULL;

                *Head = Item;
                *Tail = Item;
                RetVal = S_OK;
            }
        }
    }
    else
    {
        RetVal = E_INVALIDARG;
    }

    return RetVal;
}


HRESULT
AddToFPListHead(
    struct FileListItem * Item,
    struct FileListItem ** Head,
    struct FileListItem ** Tail
    )
{
    HRESULT RetVal = S_OK;

    if ( Item && Head && Tail )
    {
        if ( *Head )
        {
            Item->FLNext = *Head;
            (*Head)->FLPrev = Item;
        }
        else
        {
            *Tail = Item;
        }
        *Head = Item;
        Item->FLPrev = NULL;
    }
    else
    {
        RetVal = E_INVALIDARG;
    }

    return RetVal;
}

VOID
FreeFPList(
    struct FileListItem ** Head,
    BOOL DeleteFiles
    )
{
    struct FileListItem * Item = NULL;
    struct FileListItem * Next = NULL;

    if (Head && *Head)
    {
        Item = *Head;
        while (Item)
        {
            Next = Item->FLNext;
            Item->FLNext = NULL;
            Item->FLPrev = NULL;

            if (Item->SplFilename && DeleteFiles)
            {
                DeletePoolFile(&Item);
                Item = Next;
            }
            else
            {
                FPCloseFiles(Item, TRUE);
                DeleteCriticalSection(&Item->CritSec);

                if (Item->SplFilename)
                {
                    FreeSplMem(Item->SplFilename);
                }
                if (Item->ShdFilename)
                {
                    FreeSplMem(Item->ShdFilename);
                }
                FreeSplMem(Item);
                Item = Next;
            }
        }
        *Head = NULL;
    }
}


/*--

FilePool Class Functions:

    InitFilePoolVars
    FilePool
    ~FilePool
    EnterCritSec
    LeaveCritSec
    GetNextFileName
    CreatePoolFile
    GetWriteFileStruct
    ReleasePoolHandle
    DeletePoolFile
    operator delete

--*/





/*********************
 * Filepool::FilePool()
 *
 * See CreateFilePool() Above.
 */

FilePool::FilePool(
    DWORD   PTimeout,
    DWORD   MaxFreeFiles
    )     : FreeFiles(NULL), EndFreeFiles(NULL), FileInUse(NULL), EndUsedFiles(NULL),
            CurrentNum(0), PoolTimeout(PTimeout), MaxFiles(MaxFreeFiles), FreeSize(0), UsedSize(0),
            DeleteEmptyFilesOnClose(FALSE)
{
    SplModes.Mode      = GENERIC_READ | GENERIC_WRITE;
    SplModes.Flags     = FILE_ATTRIBUTE_NORMAL;
    SplModes.ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    SplModes.Disp      = 0;

    ShdModes.Mode      = GENERIC_WRITE;
    ShdModes.Flags     = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;
    ShdModes.ShareMode = 0;
    ShdModes.Disp      = 0;
}


/*********************
 * Filepool::AllocInit()
 *
 * See CreateFilePool() Above.
 */

HRESULT
FilePool::AllocInit(
    LPCTSTR BasePath,
    LPCTSTR PreNumStr,
    LPCTSTR SplExt,
    LPCTSTR ShdExt
    )
{
    HRESULT RetVal = S_OK;

    __try
    {
        InitializeCriticalSection(&FilePoolCritSec);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DBGMSG(DBG_WARN, ("FilePool: Failed to Initialise Critical Section.\n"));
        RetVal = E_FAIL;
    }


    if ((RetVal == S_OK) &&
        (FileBase = AllocSplStr(BasePath)) &&
        (FilePreNumStr = AllocSplStr(PreNumStr)) &&
        (SplFileExt = AllocSplStr(SplExt)) &&
        (ShdFileExt = AllocSplStr(ShdExt))
        )
    {
        //
        // We have all of our strings allocated.
        //
    }
    else
    {
        FreeSplStr(FileBase);
        FreeSplStr(FilePreNumStr);
        FreeSplStr(SplFileExt);
        FreeSplStr(ShdFileExt);
        RetVal = E_FAIL;
    }

    return RetVal;
}


/*********************
 * Filepool::FilePool()
 *
 * See CreateFilePool() Above.
 */

FilePool::~FilePool(
    )
{
    if (FileBase)
    {
        FreeSplMem(FileBase);
    }

    if (FilePreNumStr)
    {
        FreeSplMem(FilePreNumStr);
    }

    if (SplFileExt)
    {
        FreeSplMem(SplFileExt);
    }

    if (ShdFileExt)
    {
        FreeSplMem(ShdFileExt);
    }

    //
    // Free The lists here.
    //
    FreeFPList(&FileInUse, FALSE);
    FreeFPList(&FreeFiles, DeleteEmptyFilesOnClose);
    EndUsedFiles = NULL;
    EndFreeFiles = NULL;

    DeleteCriticalSection(&FilePoolCritSec);
}

VOID
FilePool::EnterCritSec()
{
    EnterCriticalSection(&FilePoolCritSec);
}

VOID
FilePool::LeaveCritSec()
{
    LeaveCriticalSection(&FilePoolCritSec);
}


VOID
FileListItem::EnterCritSec()
{
    EnterCriticalSection(&CritSec);
}

VOID
FileListItem::LeaveCritSec()
{
    LeaveCriticalSection(&CritSec);
}

/*********************
 * FilePool::GetNextFileName()
 *
 * Returns the next open Spool file name. Allocates memory.
 *
 * Arguments:
 *
 * Return:
 *   A valid spool file name, or NULL.
 *
 */

LPWSTR
FilePool::GetNextFileName(VOID)
{

    DWORD SizeToAlloc = 0;
    PWSTR FName = NULL;

    SizeToAlloc =
        wcslen(FileBase) + 1 +
        wcslen(FilePreNumStr) + 5 +
        wcslen(SplFileExt) + 1;

    FName = (PWSTR)AllocSplMem(SizeToAlloc * sizeof(WCHAR));

    if (FName)
    {
        DWORD NextNum;

        EnterCritSec();
        NextNum = CurrentNum;

        CurrentNum++;

        if (CurrentNum > 99999)
        {
            CurrentNum = 0;
        }

        LeaveCritSec();

        StringCchPrintf(FName,
                        SizeToAlloc,
                        L"%ws\\%ws%05d%ws",
                        FileBase,
                        FilePreNumStr,
                        NextNum,
                        SplFileExt);
    }

    return FName;
}

/*********************
 * FilePool::GetNextFileNameNoAlloc()
 *
 * Returns the next open Spool file name. Uses a buffer.
 * It is only used after a call to GetNextFileName.
 *
 * Arguments:
 * IN OUT Filename    : Buffer to copy the name into.
 * IN     cchFileName : Size of the buffer to copy into.
 *
 * Return:
 *   None.
 *
 */

HRESULT
FilePool::GetNextFileNameNoAlloc(
    IN  OUT PWSTR   Filename,
    IN      SIZE_T  cchFileName
    )
{
    DWORD NextNum;

    EnterCritSec();
    NextNum = CurrentNum;

    CurrentNum++;

    if (CurrentNum > 99999)
    {
        CurrentNum = 0;
    }

    LeaveCritSec();

    return StringCchPrintf(Filename,
                           cchFileName,
                           L"%ws\\%ws%05d%ws",
                           FileBase,
                           FilePreNumStr,
                           NextNum,
                           SplFileExt);

}

/*********************
 * Filepool::CreatePoolFile()
 *
 * Takes a pointer to a Filepool item and returns a new one. Can use a filename
 * passed in.
 *
 * Parameters:
 *    OUT  Item      : Pointer to a File Item.
 *    IN   Filename  : Optional Filename. Can be NULL.
 *
 * Returns S_OK if successful.
 */


HRESULT
FilePool::CreatePoolFile(
    struct FileListItem ** Item,
    PWSTR  Filename
    )
{
    HRESULT RetVal = E_FAIL;
    struct FileListItem * Temp = NULL;
    DWORD  OldNum = 0;
    BOOL CritInitialized = FALSE;

    if ( Item )
    {
        Temp = (struct FileListItem *)AllocSplMem(sizeof(struct FileListItem));

        if ( Temp )
        {
           Temp->FLNext = NULL;
           Temp->FLPrev = NULL;
           OldNum = CurrentNum;
           Temp->TimeStamp = 0;
           Temp->FP = this;
           Temp->CreateInfo = 0;

           __try
               {
                   InitializeCriticalSection(&Temp->CritSec);
                   CritInitialized = TRUE;
               }
           __except( EXCEPTION_EXECUTE_HANDLER )
               {
                   DBGMSG(DBG_WARN, ("FilePool: Failed to Initialise FL Critical Section.\n"));
                   RetVal = E_FAIL;
               }
           if (CritInitialized)
           {

               if ( Filename )
               {
                   Temp->SplFilename = AllocSplStr(Filename);
                   Temp->ShdFilename = AllocSplStr(Filename);

                   if (Temp->SplFilename && Temp->ShdFilename)
                   {
                       *Item = Temp;
                       ConvertFileExt(Temp->ShdFilename, SplFileExt, ShdFileExt);
                       Temp->SplReadHandle = INVALID_HANDLE_VALUE;
                       Temp->SplWriteHandle = INVALID_HANDLE_VALUE;
                       Temp->ShdWriteHandle = INVALID_HANDLE_VALUE;
                       RetVal = S_OK;
                   }
                   else
                   {
                       RetVal = E_OUTOFMEMORY;
                   }
               }
               else
               {
                   Temp->SplFilename = GetNextFileName();

                   if (Temp->SplFilename)
                   {
                       RetVal = S_OK;
                       while (FileExists(Temp->SplFilename))
                       {
                            //
                            // Fundamental assumption here is the number of
                            // characters occupied by the filename does not
                            // change.
                            //
                            GetNextFileNameNoAlloc(Temp->SplFilename, wcslen(Temp->SplFilename) + 1);
                            if (OldNum == CurrentNum)
                            {
                                //
                                // We went right around.
                                //
                                RetVal = E_FAIL;
                                break;
                            }
                       }
                       if (SUCCEEDED(RetVal))
                       {
                           Temp->ShdFilename = AllocSplStr(Temp->SplFilename);
                           if (Temp->ShdFilename)
                           {
                               ConvertFileExt(Temp->ShdFilename, SplFileExt, ShdFileExt);
                               Temp->SplReadHandle = INVALID_HANDLE_VALUE;
                               Temp->SplWriteHandle = INVALID_HANDLE_VALUE;
                               Temp->ShdWriteHandle = INVALID_HANDLE_VALUE;
                               *Item = Temp;
                               RetVal = S_OK;
                           }
                       }
                   }
               }
           }
       }
    }
    else
    {
        RetVal = E_INVALIDARG;

    }

    if (FAILED(RetVal))
    {
        if (Temp)
        {
            if (CritInitialized)
            {
                DeleteCriticalSection(&Temp->CritSec);
            }

            if (Temp->SplFilename)
            {
                FreeSplMem(Temp->SplFilename);
            }

            if (Temp->ShdFilename)
            {
                FreeSplMem(Temp->ShdFilename);
            }

            FreeSplMem(Temp);
        }
    }
    return RetVal;
}


/*********************
 * Filepool::GetWriteFileStruct()
 *
 * See GetFileItemHandle() Above.
 */

HRESULT
FilePool::GetWriteFileStruct(
    struct FileListItem ** File,
    PWSTR  Filename
    )
{
    struct FileListItem * Temp = NULL;
    HRESULT RetVal = S_OK;
    HRESULT OurRetVal = S_OK;

    EnterCritSec();

    if ( FreeFiles && !Filename)
    {
        Temp = FreeFiles;

        RetVal = RemoveFromFPList( Temp, &FreeFiles, &EndFreeFiles );

        if (SUCCEEDED(RetVal))
        {
            FreeSize--;

            RetVal = AddToFPListEnd( Temp, &FileInUse, &EndUsedFiles);

            if (FAILED(RetVal))
            {
                //
                // Bad things
                //
                DBGMSG(DBG_WARN, ("Could not add to List End %x\n", RetVal));
                OurRetVal = E_FAIL;
            }
            else
            {
                UsedSize++;
            }
        }
        else
        {
            //
            // Find out what went wrong.
            //
            DBGMSG(DBG_WARN, ("Could not remove Item %x\n", RetVal));
            Temp = NULL;
            OurRetVal = E_FAIL;

        }
    }
    else
    {
        LeaveCritSec();

        RetVal = CreatePoolFile(&Temp, Filename);

        if ( FAILED(RetVal) )
        {
            //
            // Bad Things
            //
            DBGMSG(DBG_WARN, ("Could not create Item %x\n", RetVal));
            OurRetVal = E_FAIL;
        }
        else
        {
            EnterCritSec();
            RetVal = AddToFPListEnd(Temp, &FileInUse, &EndUsedFiles);

            if ( FAILED(RetVal) )
            {
                //
                // Bad Things
                //
                DBGMSG(DBG_WARN, ("Could not add to List End after create %x\n", RetVal));
                OurRetVal = E_FAIL;
            }
            else
            {
                UsedSize++;
            }
            LeaveCritSec();
        }
        EnterCritSec();
    }

    LeaveCritSec();

    if ( FAILED(OurRetVal) )
    {
        //
        // Clean up.
        //

        if ( Temp )
        {
            //
            // We weren't able to add the file to the structure,
            // This should never happen, but if it does, clean up
            // the memory we use.
            //
            DeletePoolFile(&Temp);

        }

        *File = NULL;
    }
    else
    {
        *File = Temp;
    }

    return OurRetVal;
}

/*********************
 * Filepool::ReleasePoolHandle()
 *
 * See ReleasePoolHandle() Above.
 */

HRESULT
FilePool::ReleasePoolHandle(
    struct FileListItem * File
    )
{
    BOOL    bDeletePoolFile = FALSE;
    HRESULT RetVal = S_OK;
    HRESULT RemRetVal = S_OK;

    if ((File->Status & FP_STATUS_SPL_READING) ||
        (File->Status & FP_STATUS_SPL_WRITING) ||
        (File->Status & FP_STATUS_SHD_WRITING))
    {
        RetVal = E_FAIL;

        //
        // This is a pathological case as we will subsequently leak this handle.
        // Break.
        //
        DBGMSG(DBG_ERROR, ("Tried to release a file with handles in use\n"));
    }
    else
    {
        EnterCritSec();
        RemRetVal = RemoveFromFPList(File, &FileInUse, &EndUsedFiles);

        if (SUCCEEDED(RemRetVal))
        {
            UsedSize--;

            //
            // If the spool directory has changed we need to delete the pool file
            //
            if ( _wcsnicmp(FileBase, File->SplFilename, wcslen(FileBase)) )
            {
                bDeletePoolFile = TRUE;
            }
        }
        LeaveCritSec();

        if (SUCCEEDED(RemRetVal))
        {
            if (bDeletePoolFile == TRUE                             ||
                FreeSize >= MaxFiles                                ||
                File->Status & FP_STATUS_ITEM_DONT_RECYCLE          ||
                ((File->SplWriteHandle == INVALID_HANDLE_VALUE) &&
                 (File->SplReadHandle == INVALID_HANDLE_VALUE)))
            {
                DeletePoolFile(&File);
            }
            else
            {
                File->TimeStamp = GetTickCount();

                TruncateFiles(File);

                EnterCritSec();
                RetVal = AddToFPListEnd(File, &FreeFiles, &EndFreeFiles);

                if (SUCCEEDED(RetVal))
                {
                    FreeSize++;
                }
                LeaveCritSec();

            }
        }
        else
        {
            RetVal = E_INVALIDARG;
        }
    }

    return RetVal;
}

/*********************
 * Filepool::CreateSplReader()
 *
 *Used in GetReaderFromHandle.
 */

HRESULT
FilePool::CreateSplReader(
    struct FileListItem * Item
    )
{
    HRESULT RetVal = S_OK;
    HANDLE Temp = INVALID_HANDLE_VALUE;


    Temp = CreateFile( Item->SplFilename,
                       SplModes.Mode,
                       SplModes.ShareMode,
                       NULL,
                       OPEN_EXISTING | SplModes.Disp,
                       SplModes.Flags,
                       NULL);

    if (Temp && (Temp != INVALID_HANDLE_VALUE))
    {
        Item->SplReadHandle = Temp;
        Item->CreateInfo |= FP_SPL_READER_CREATED;
    }
    else
    {
        RetVal = E_FAIL;
    }

    return RetVal;
}


/*********************
 * Filepool::CreateSplWriter()
 *
 * Does the CreateFile for the Spool File. Used for GetWriterFromHandle().
 */

HRESULT
FilePool::CreateSplWriter(
    struct FileListItem * Item
    )
{
    HRESULT RetVal = S_OK;
    HANDLE Temp = INVALID_HANDLE_VALUE;

    Temp = CreateFile( Item->SplFilename,
                       SplModes.Mode,
                       SplModes.ShareMode,
                       NULL,
                       CREATE_ALWAYS | SplModes.Disp,
                       SplModes.Flags,
                       NULL);

    if (Temp && (Temp != INVALID_HANDLE_VALUE))
    {
        Item->SplWriteHandle = Temp;
        Item->CreateInfo |= FP_SPL_WRITER_CREATED;
    }
    else
    {
        RetVal = E_FAIL;
    }

    return RetVal;
}

/*********************
 * Filepool::CreateShdWriter()
 *
 * Does the CreateFile for the ShadowFile. Used for GetWriterFromHandle().
 */

HRESULT
FilePool::CreateShdWriter(
    struct FileListItem * Item
    )
{
    HRESULT RetVal = S_OK;
    HANDLE Temp = INVALID_HANDLE_VALUE;


    Temp = CreateFile( Item->ShdFilename,
                       ShdModes.Mode,
                       ShdModes.ShareMode,
                       NULL,
                       CREATE_ALWAYS | ShdModes.Disp,
                       ShdModes.Flags,
                       NULL);

    if (Temp && (Temp != INVALID_HANDLE_VALUE))
    {
        Item->ShdWriteHandle = Temp;
        Item->CreateInfo |= FP_SHD_CREATED;
    }
    else
    {
        RetVal = E_FAIL;
    }

    return RetVal;
}

/*********************
 * Filepool::RemoveFromPool()
 *
 * See RemoveFromFilePool() Above.
 */

HRESULT
FilePool::RemoveFromPool(
    struct FileListItem * File,
    BOOL Delete
    )
{
    HRESULT RemRetVal = S_OK;

    if ((File->Status & FP_STATUS_SPL_READING) ||
        (File->Status & FP_STATUS_SPL_WRITING) ||
        (File->Status & FP_STATUS_SHD_WRITING))
    {
        RemRetVal = E_FAIL;

        //
        // This is a pathological case as it will cause us to leak a KM handle.
        // Hard break here.
        //
        DBGMSG(DBG_ERROR, ("Tried to release a file with handles in use\n"));
    }
    else
    {
        EnterCritSec();
        RemRetVal = RemoveFromFPList(File, &FileInUse, &EndUsedFiles);

        if (SUCCEEDED(RemRetVal))
        {
            UsedSize--;
        }
        LeaveCritSec();

        if (FAILED(RemRetVal))
        {
            EnterCritSec();
            RemRetVal = RemoveFromFPList(File, &FreeFiles, &EndFreeFiles);

            if (SUCCEEDED(RemRetVal))
            {
                FreeSize--;
            }
            LeaveCritSec();
        }


        if (SUCCEEDED(RemRetVal))
        {
            if (Delete)
            {
                DeletePoolFile(&File);
            }
            else
            {
                FPCloseFiles(File, TRUE);

                DeleteCriticalSection(&File->CritSec);

                if (File->SplFilename)
                {
                    FreeSplMem(File->SplFilename);
                }
                if (File->ShdFilename)
                {
                    FreeSplMem(File->ShdFilename);
                }
                FreeSplMem(File);
            }
        }
    }

    return RemRetVal;

}

/*********************
 * Filepool::TrimPool()
 *
 * See TrimPool() Above.
 */


BOOL
FilePool::TrimPool(
    VOID
    )
{
    DWORD  Time                         = 0;
    BOOL   GotToTrim                    = TRUE;
    struct FileListItem * Temp          = NULL;
    struct FileListItem * DeleteFiles   = NULL;
    DWORD  TrimCount                    = 0;
    BOOL   bFilesToTrim                 = FALSE;

    Time = GetTickCount();

    EnterCritSec();

    DeleteFiles = FreeFiles;

    while (FreeFiles)
    {
        if ((FreeFiles->TimeStamp > Time) ||
            (Time - FreeFiles->TimeStamp > PoolTimeout))
        {
            //
            // Walk forward until you reach a file that is not too old.
            //
            FreeFiles = FreeFiles->FLNext;

            TrimCount++;
        }
        else
        {
            if (FreeFiles->FLPrev)
            {
                //
                // There are files to delete.
                //
                FreeFiles->FLPrev->FLNext = NULL;
                FreeFiles->FLPrev = NULL;
            }
            else
            {
                //
                // No files have timed out.
                //
                DeleteFiles = NULL;
            }
            break;
        }
    }

    if (!FreeFiles)
    {
        EndFreeFiles = NULL;
    }

    //
    // We need to decrease the FreeSize by the number of elements we are just about
    // to trim off it.
    //
    FreeSize -= TrimCount;

    //
    // We should trim files the next time around if there is a FreeFiles list.
    //
    bFilesToTrim = FreeFiles != NULL;

    LeaveCritSec();

    //
    // Now outside the critsec do the deletions.
    //
    while (DeleteFiles)
    {
        struct FileListItem * Temp = DeleteFiles;
        DeleteFiles = DeleteFiles->FLNext;
        DeletePoolFile(&Temp);
    }

    return bFilesToTrim;
}


void*
FilePool::operator new(
    size_t n
    )
{
    return AllocSplMem(n);
}

void
FilePool::operator delete(
    void* p,
    size_t n
    )
{
    if (p)
    {
        FreeSplMem(p);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\dsutil.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Abstract:

    This module provides functionality for ADs within spooler

Author:

    Steve Wilson (NT) Nov 1997

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop



#define LOG_EVENT_ERROR_BUFFER_SIZE     11
#define MAX_CN  63                  // DS limits common names to 63 non-null chars
#define UNIQUE_NUMBER_SIZE  10
#define MIN_CN  (UNIQUE_NUMBER_SIZE + 3 + 1) // CN= + room for unique number if needed, plus NULL

extern BOOL gdwLogDsEvents;

extern "C" HANDLE    ghDsUpdateThread;
extern "C" DWORD     gdwDsUpdateThreadId;

// Policy values
WCHAR *szPublishPrinters        = L"PublishPrinters";
WCHAR *szPruneDownlevel         = L"PruneDownlevel";
WCHAR *szPruningInterval        = L"PruningInterval";
WCHAR *szPruningRetries         = L"PruningRetries";
WCHAR *szPruningPriority        = L"PruningPriority";
WCHAR *szVerifyPublishedState   = L"VerifyPublishedState";
WCHAR *szImmortal               = L"Immortal";
WCHAR *szServerThreadPolicy     = L"ServerThread";
WCHAR *szPruningRetryLog        = L"PruningRetryLog";

extern "C" BOOL (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
extern "C" BOOL (*pfnClosePrinter)(HANDLE);
extern "C" LONG (*pfnDocumentProperties)(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODE, DWORD);

DWORD dwLastPruningPriority = DEFAULT_PRUNING_PRIORITY;


HRESULT
GetPrintQueue(
    HANDLE          hPrinter,
    IADs            **ppADs
)
/*++
Function Description:
    This function returns the ADs PrintQueue object of the supplied printer handle.

Parameters:
    hPrinter - printer handle
    ppADs    - return pointer to the PrintQueue object.  Caller frees via ppADs->Release().

Return Values:
    HRESULT
--*/
{
    HRESULT         hr;
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    IDispatch       *pDispatch = NULL;
    IADsContainer   *pADsContainer = NULL;
    WCHAR           ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];


    // Create the Print-Queue object
    // Get the container

    hr = GetPrintQueueContainer(hPrinter, &pADsContainer, ppADs);
    BAIL_ON_FAILURE(hr);

    if (!*ppADs) {  // PrintQueue object does not exist, so create it

        hr = pADsContainer->Create( SPLDS_PRINTER_CLASS,
                                    pIniPrinter->pszCN,
                                    &pDispatch);
        if (FAILED(hr)) {

            StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%0x", hr);

            SplLogEvent(((PSPOOL)hPrinter)->pIniSpooler,
                        gdwLogDsEvents & LOG_ERROR,
                        MSG_CANT_CREATE_PRINTQUEUE,
                        FALSE,
                        pIniPrinter->pszDN,
                        ErrorBuffer,
                        NULL);

            DBGMSG(DBG_WARNING,("Can't Create PrintQueue: %ws, %ws\n", pIniPrinter->pszDN, ErrorBuffer));
            BAIL_ON_FAILURE(hr);
        }

        hr = pDispatch->QueryInterface(IID_IADs, (void **) ppADs);
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pADsContainer)
        pADsContainer->Release();

    if (pDispatch)
        pDispatch->Release();

    return hr;
}




HRESULT
GetPublishPoint(
    HANDLE  hPrinter
)
/*++
Function Description:
    This function gets the publish point by setting pIniPrinter->pszDN and pIniPrinter->pszCN

Parameters:
    hPrinter - printer handle

Return Values:
    HRESULT
--*/
{
    HRESULT     hr;
    PSPOOL      pSpool = (PSPOOL) hPrinter;
    PINIPRINTER pIniPrinter = pSpool->pIniPrinter;


    // We should only be here if we couldn't use the existing DN & CN, so free old ones
    FreeSplStr(pIniPrinter->pszCN);
    pIniPrinter->pszCN = NULL;

    FreeSplStr(pIniPrinter->pszDN);
    pIniPrinter->pszDN = NULL;

    // If Published, update DN from GUID
    if (pIniPrinter->pszObjectGUID) {

        hr = GetPublishPointFromGUID(   hPrinter,
                                        pIniPrinter->pszObjectGUID,
                                        &pIniPrinter->pszDN,
                                        &pIniPrinter->pszCN,
                                        TRUE);

        //
        // If the object is actually deleted, the error is ERROR_FILE_NOT_FOUND
        // If the object is a tombstone, the error is ERROR_DS_NO_SUCH_OBJECT
        //
        if (HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND ||
            HRESULT_CODE(hr) == ERROR_DS_NO_SUCH_OBJECT) {
            if (ghDsUpdateThread && gdwDsUpdateThreadId == GetCurrentThreadId()) {
                // We are in the background thread
                pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;
            } else {
                pIniPrinter->DsKeyUpdateForeground = DS_KEY_REPUBLISH;
            }
        }

        BAIL_ON_FAILURE(hr);

    } else {

        // Generate default publish point & common name
        hr = GetDefaultPublishPoint(hPrinter, &pIniPrinter->pszDN);
        BAIL_ON_FAILURE(hr);


        // Printer name might change, so make a copy here
        EnterSplSem();
        PWSTR pszPrinterName = AllocSplStr(pIniPrinter->pName);
        LeaveSplSem();

        if (pszPrinterName) {
            hr = GetCommonName( hPrinter,
                                pIniPrinter->pIniSpooler->pMachineName,
                                pszPrinterName,
                                pIniPrinter->pszDN,
                                &pIniPrinter->pszCN);
            FreeSplStr(pszPrinterName);
        } else {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        }
        BAIL_ON_FAILURE(hr);
    }

error:

    return hr;
}



HRESULT
GetPublishPointFromGUID(
    HANDLE  hPrinter,
    PWSTR   pszObjectGUID,
    PWSTR   *ppszDN,
    PWSTR   *ppszCN,
    BOOL    bGetDNAndCN
)
/*++
Function Description:
    This function returns the publish point of a specified GUID

Parameters:
    hPrinter - printer handle
    ppszObjectGUID - objectGUID of object for which we want to find the publish point
    ppszDN - ADsPath of container containing object.  Caller frees via FreeSplMem().
    ppszCN - Common Name of object.  Caller frees via FreeSplMem().
    bGetDNAndCN - if TRUE, DN of Container & CN of object are returned.  If FALSE, DN is path to object

Return Values:
    HRESULT
--*/
{
    PSPOOL      pSpool = (PSPOOL) hPrinter;
    DWORD dwRet, nBytes, nChars;
    BOOL bRet;
    PWSTR pNames[2];
    DS_NAME_RESULT *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO *pDCI = NULL;
    HANDLE hDS = NULL;
    PWSTR psz;
    WCHAR ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    HRESULT hr = S_OK;


    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS) {
        StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%0x", dwRet);
        if (pSpool) {
            SplLogEvent(  pSpool->pIniSpooler,
                          gdwLogDsEvents & LOG_ERROR,
                          MSG_CANT_GET_DNS_DOMAIN_NAME,
                          FALSE,
                          ErrorBuffer,
                          NULL );
        }
        DBGMSG(DBG_WARNING,("Can't get DNS Domain Name: %ws\n", ErrorBuffer));
        goto error;
    }


    // Get Publish Point

    if (ppszDN) {

        pNames[0] = pszObjectGUID;
        pNames[1] = NULL;

        if (!(DsCrackNames(
                        hDS,
                        DS_NAME_NO_FLAGS,
                        DS_UNKNOWN_NAME,
                        DS_FQDN_1779_NAME,
                        1,
                        &pNames[0],
                        &pDNR) == ERROR_SUCCESS)) {

            dwRet = GetLastError();
            StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%0x", dwRet);
            if (pSpool) {
                SplLogEvent(  pSpool->pIniSpooler,
                              gdwLogDsEvents & LOG_WARNING,
                              MSG_CANT_CRACK_GUID,
                              FALSE,
                              pDCI->DomainName,
                              ErrorBuffer,
                              NULL );
                DBGMSG(DBG_WARNING,("Can't crack GUID: %ws, %ws\n", pDCI->DomainName, ErrorBuffer));
            }
            dwRet = ERROR_FILE_NOT_FOUND;
            goto error;
        }

        if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
            dwRet = DsCrackNamesStatus2Win32Error(pDNR->rItems[0].status);

            StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%0x", dwRet);
            if (pSpool) {
                SplLogEvent(  pSpool->pIniSpooler,
                              gdwLogDsEvents & LOG_WARNING,
                              MSG_CANT_CRACK_GUID,
                              FALSE,
                              pDCI->DomainName,
                              ErrorBuffer,
                              NULL );
            }
            DBGMSG(DBG_WARNING,("Can't crack GUID: %ws %ws\n", pDCI->DomainName, ErrorBuffer));
            dwRet = ERROR_FILE_NOT_FOUND;
            goto error;
        }


        if (bGetDNAndCN) {
            // Separate DN into CN & PublishPoint
            // pDNR has form: CN=CommonName,DN...

            hr = FQDN2CNDN(pDCI->DomainControllerName + 2, pDNR->rItems[0].pName, ppszCN, ppszDN);
            BAIL_ON_FAILURE(hr);

        } else {

            hr = BuildLDAPPath(pDCI->DomainControllerName + 2, pDNR->rItems[0].pName, ppszDN);
            BAIL_ON_FAILURE(hr);
        }
    }


error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (dwRet != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
    }

    if (FAILED(hr)) {
        if (ppszCN) {
            FreeSplMem(*ppszCN);
            *ppszCN = NULL;
        }
        if (ppszDN) {
            FreeSplMem(*ppszDN);
            *ppszDN = NULL;
        }
    }

    return hr;
}


HRESULT
FQDN2CNDN(
    PWSTR   pszDCName,
    PWSTR   pszFQDN,
    PWSTR   *ppszCN,
    PWSTR   *ppszDN
)
{
    IADs    *pADs = NULL;
    PWSTR   pszCN = NULL;
    PWSTR   pszDN = NULL;
    PWSTR   pszLDAPPath = NULL;
    HRESULT hr;

    // Get LDAP path to object
    hr = BuildLDAPPath(pszDCName, pszFQDN, &pszLDAPPath);
    BAIL_ON_FAILURE(hr);

    // Get DN
    hr = ADsGetObject(pszLDAPPath, IID_IADs, (void **) &pADs);
    BAIL_ON_FAILURE(hr);

    hr = pADs->get_Parent(&pszDN);
    BAIL_ON_FAILURE(hr);

    if (!(*ppszDN = AllocSplStr(pszDN))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    // Get CN
    hr = pADs->get_Name(&pszCN);
    BAIL_ON_FAILURE(hr);

    if (!(*ppszCN = AllocSplStr(pszCN))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pADs)
        pADs->Release();

    if (pszCN)
        SysFreeString(pszCN);

    if (pszDN)
        SysFreeString(pszDN);

    FreeSplStr(pszLDAPPath);

    if (FAILED(hr)) {
        FreeSplStr(*ppszCN);
        FreeSplStr(*ppszDN);
    }

    return hr;
}


HRESULT
BuildLDAPPath(
    PWSTR   pszDC,
    PWSTR   pszFQDN,
    PWSTR   *ppszLDAPPath
)
{
    PWSTR   pszEscapedFQDN = NULL;
    DWORD   nBytes;
    HRESULT hr = S_OK;

    //
    // pszFQDN is assumed to contain escaped DN_SPECIAL_CHARS characters, but
    // ADSI has additional special characters that need to be escaped before using
    // the LDAP path in ADSI calls.
    //
    pszEscapedFQDN = CreateEscapedString(pszFQDN, ADSI_SPECIAL_CHARS);
    if (!pszEscapedFQDN) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    // LDAP:// + pDCName + / + pName + 1
    nBytes = (wcslen(pszDC) + wcslen(pszEscapedFQDN) + 9)*sizeof(WCHAR);

    if (!(*ppszLDAPPath = (PWSTR) AllocSplMem(nBytes))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    StringCbPrintf(*ppszLDAPPath, nBytes, L"LDAP://%ws/%ws", pszDC, pszEscapedFQDN);

error:

    FreeSplStr(pszEscapedFQDN);

    return hr;
}


HRESULT
GetPrintQueueContainer(
    HANDLE          hPrinter,
    IADsContainer   **ppADsContainer,
    IADs            **ppADs
)
/*++
Function Description:
    This function returns the container and, if it exists, the PrintQueue object pointer
    corresponding to the supplied printer handle

Parameters:
    hPrinter - printer handle
    ppADsContainer - return Container ADsPath. Caller frees via ppADsContainer->Release().
    ppADs - return PrintQueue object ADsPath.  Caller frees via ppADs->Release().

Return Values:
    If successful, returns the printqueue container and, if found, the printqueue dispatch.
    If there is no printqueue, the dispatch is set to NULL and the default container is returned.
--*/
{
    HRESULT         hr;
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    WCHAR           ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    DWORD           nBytes;
    PWSTR           pszObjectGUID = NULL;
    IDispatch       *pPrintQDispatch = NULL;
    LPWSTR          pszPrinterObjectGUID = pIniPrinter->pszObjectGUID;
    LPWSTR          pszPrinterDN = pIniPrinter->pszDN;
    LPWSTR          pszPrinterCN = pIniPrinter->pszCN;


    *ppADsContainer = NULL;
    *ppADs = NULL;

    //
    // Try quick search for object using known properties.
    //
    // We are outside Spooler CS and  pIniPrinter->pszObjectGUID,
    // pIniPrinter->pszDN, pIniPrinter->pszCN might get changed by
    // the DS background thread. In the case they are set to NULL,
    // we'll take an AV. So, even if they change or are set to NULL,
    // we'll use whatever we have when we entered the function.
    // The worst that can happen is to find a DS printQueue
    // object that doesn't last till we use it, which is fine. This
    // is already assumed. Or, to not find a DS printQueue that will
    // be created just after we query the DS. This is also fine.
    //
    if (pszPrinterObjectGUID &&
        pszPrinterDN &&
        pszPrinterCN) {

        // Try to get the container using existing DN
        hr = ADsGetObject(  pszPrinterDN,
                            IID_IADsContainer,
                            (void **) ppADsContainer
                            );

        if (SUCCEEDED(hr)) {

            // Verify that printqueue exists in this container
            hr = (*ppADsContainer)->GetObject(  SPLDS_PRINTER_CLASS,
                                                pszPrinterCN,
                                                &pPrintQDispatch);

            // Verify that the found printQueue object has the same GUID
            if (SUCCEEDED(hr) && pPrintQDispatch) {
                hr = pPrintQDispatch->QueryInterface(IID_IADs, (void **) ppADs);
                BAIL_ON_FAILURE(hr);

                hr = GetGUID(*ppADs, &pszObjectGUID);
                BAIL_ON_FAILURE(hr);

                if (wcscmp(pszObjectGUID, pszPrinterObjectGUID))
                    hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND);
            } else {
                hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND);
            }
        }
    } else {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND);
    }

    // Couldn't find container or printQueue, so find by GUID or get default container
    if (FAILED(hr)) {

        // The following items may have been allocated above and need to be freed
        // here since we're going to reallocate them
        if (pPrintQDispatch) {
            pPrintQDispatch->Release();
            pPrintQDispatch = NULL;
        }
        if (*ppADsContainer) {
            (*ppADsContainer)->Release();
            *ppADsContainer = NULL;
        }
        if (*ppADs) {
            (*ppADs)->Release();
            *ppADs = NULL;
        }


        // find or create pszDN and pszCN
        hr = GetPublishPoint(hPrinter);
        BAIL_ON_FAILURE(hr);

        SPLASSERT(pIniPrinter->pszDN);

        hr = ADsGetObject(  pIniPrinter->pszDN,
                            IID_IADsContainer,
                            (void **) ppADsContainer
                            );

        if (FAILED(hr)) {
            StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%0x", hr);
            DBGMSG(DBG_WARNING,("Can't get Container: %ws, %ws\n", pIniPrinter->pszDN, ErrorBuffer));
            SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                          gdwLogDsEvents & LOG_ERROR,
                          MSG_CANT_GET_CONTAINER,
                          FALSE,
                          pIniPrinter->pszDN,
                          ErrorBuffer,
                          NULL );

            BAIL_ON_FAILURE(hr);
        }


        // Try to get the printqueue, but don't error out if we can't
        (*ppADsContainer)->GetObject(   SPLDS_PRINTER_CLASS,
                                        pIniPrinter->pszCN,
                                        &pPrintQDispatch);
        if (pPrintQDispatch)
            pPrintQDispatch->QueryInterface(IID_IADs, (void **) ppADs);
    }


error:


    if (pPrintQDispatch)
        pPrintQDispatch->Release();

    FreeSplStr(pszObjectGUID);

    return hr;
}



HRESULT
GetCommonName(
    HANDLE hPrinter,
    PWSTR  pszServerName,
    PWSTR  pszPrinterName,
    PWSTR  pszDN,
    PWSTR  *ppszCommonName
)
/*++
Function Description:
    This function returns a standard format Common Name of the PrintQueue object
    generated from the supplied Server and Printer names

Parameters:
    hPrinter - printer handle
    pszServerName - name of a server
    pszPrinterName - name of a printer on the server
    pszDN - container DN
    ppszCommonName - return CommonName. Caller frees via FreeSplMem().

Return Values:
    HRESULT
--*/
{
    DWORD nBytes;
    PWSTR psz;
    PWSTR pszPrinterNameStart = pszPrinterName;

    // "CN=Server-Printer"
    nBytes = (wcslen(pszPrinterName) + wcslen(pszServerName) + 5)*sizeof(WCHAR);

    // We need to also make room for a unique number if there is a conflict
    if (nBytes < MIN_CN)
        nBytes = MIN_CN;

    if (!(*ppszCommonName = psz = (PWSTR) AllocSplMem(nBytes))) {
        return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
    }

    // CN=
    StringCbCopy(psz, nBytes, L"CN=");

    // Server
    for(psz += 3, pszServerName += 2 ; *pszServerName    ; ++psz, ++pszServerName) {
        *psz = wcschr(DN_SPECIAL_CHARS, *pszServerName) ? TEXT('_') : *pszServerName;
    }
    *psz = L'-';

    // Printer
    for(++psz; *pszPrinterName ; ++psz, ++pszPrinterName) {
        *psz = wcschr(DN_SPECIAL_CHARS, *pszPrinterName) ? TEXT('_') : *pszPrinterName;
    }

    // NULL
    *psz = *pszPrinterName;

    // DS only allows 64 characters in CN attribute, so shorten this if needed
    if (wcslen(*ppszCommonName) > MAX_CN - 1) {
        (*ppszCommonName)[MAX_CN] = NULL;
    }

    // Generate a non-conflicting name in this container
    GetUniqueCN(pszDN, ppszCommonName, pszPrinterNameStart);

    return S_OK;
}


VOID
GetUniqueCN(
    PWSTR pszDN,
    PWSTR *ppszCommonName,
    PWSTR pszPrinterName
)
{
    // Check if an object with this CN already exists in this container

    // Get Container
    IADsContainer   *pADsContainer = NULL;
    UINT32          CN;     // This is a "random" number we append to the common name to make it unique

    CN = (UINT32) (ULONG_PTR) &CN;   // Initialize with some random number

    HRESULT hr = ADsGetObject(pszDN, IID_IADsContainer, (void **) &pADsContainer);

    if (SUCCEEDED(hr)) {

        BOOL bTryAgain;

        do {
            IDispatch   *pPrintQDispatch = NULL;
            bTryAgain = FALSE;

            // Get PrintQueue, if it exists
            pADsContainer->GetObject(  SPLDS_PRINTER_CLASS,
                                       *ppszCommonName,
                                       &pPrintQDispatch);
            if (pPrintQDispatch) {

                IADs *pADs = NULL;

                hr = pPrintQDispatch->QueryInterface(IID_IADs, (void **) &pADs);

                if (SUCCEEDED(hr)) {

                    // Generate a unique Common Name.
                    UINT32  cchCommonName = wcslen(*ppszCommonName);
                    PWSTR   pszDigits;

                    if (cchCommonName >= MIN_CN) {
                        pszDigits = *ppszCommonName + cchCommonName - UNIQUE_NUMBER_SIZE;
                    } else {
                        pszDigits = *ppszCommonName + 3;    // CN=
                    }

                    bTryAgain = TRUE;

                    StringCchPrintf(pszDigits, (cchCommonName + 1) - (pszDigits - *ppszCommonName), L"%010d", ++CN);

                    pADs->Release();
                }
                pPrintQDispatch->Release();
            }
        } while(bTryAgain);

        pADsContainer->Release();
    }
}



HRESULT
GetDefaultPublishPoint(
    HANDLE hPrinter,
    PWSTR *ppszDN
)
/*++
Function Description:
    This function returns the default publish point (Container) of a PrintQueue
    based on the supplied printer handle.

Parameters:
    hPrinter - printer handle
    ppszDN - return default PrintQueue container.  Caller frees via FreeSplMem()

Return Values:
    HRESULT
--*/
{
    WCHAR szServerName[MAX_COMPUTERNAME_LENGTH + 1];
    WCHAR szName[MAX_PATH + 1];
    DWORD nSize;
    HANDLE hDS = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL bRet;
    PWSTR pNames[2];
    DS_NAME_RESULT *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO *pDCI = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    WCHAR   ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    HRESULT hr = S_OK;


    // Get Computer name

    nSize = MAX_COMPUTERNAME_LENGTH + 1;
    if (!(bRet = GetComputerName(szServerName, &nSize))) {
        dwRet = GetLastError();
        goto error;
    }


    // Get Domain name
    dwRet = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) &pDsRole);
    if (dwRet) {
        StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%0x", dwRet);
        DBGMSG(DBG_WARNING,("Can't get Primary Domain Info: %ws\n", ErrorBuffer));
        SplLogEvent(((PSPOOL) hPrinter)->pIniSpooler,
                   gdwLogDsEvents & LOG_ERROR,
                   MSG_CANT_GET_PRIMARY_DOMAIN_INFO,
                   FALSE,
                   ErrorBuffer,
                   NULL );
        goto error;
    }

    // Domain\Server
    StringCchPrintf(szName, COUNTOF(szName), L"%ws\\%ws$", pDsRole->DomainNameFlat, szServerName);
    pNames[0] = szName;
    pNames[1] = NULL;


    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS) {
        StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%0x", dwRet);
        DBGMSG(DBG_WARNING,("Can't get DNS Domain Name: %ws\n", ErrorBuffer));
        SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                   gdwLogDsEvents & LOG_ERROR,
                   MSG_CANT_GET_DNS_DOMAIN_NAME,
                   FALSE,
                   ErrorBuffer,
                   NULL );
        goto error;
    }


    // Get Publish Point

    if (ppszDN) {
        if (!(DsCrackNames(
                        hDS,
                        DS_NAME_NO_FLAGS,
                        DS_UNKNOWN_NAME,
                        DS_FQDN_1779_NAME,
                        1,
                        &pNames[0],
                        &pDNR) == ERROR_SUCCESS)) {

            dwRet = GetLastError();

            StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%0x", dwRet);
            DBGMSG(DBG_WARNING,("Can't Crack Name: %ws, %ws\n", pDCI->DomainName, ErrorBuffer));
            SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                       gdwLogDsEvents & LOG_ERROR,
                       MSG_CANT_CRACK,
                       FALSE,
                       pDCI->DomainName,
                       ErrorBuffer,
                       NULL );
            goto error;
        }

        if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
            dwRet = DsCrackNamesStatus2Win32Error(pDNR->rItems[0].status);

            StringCchPrintf(ErrorBuffer, COUNTOF(ErrorBuffer), L"%0x", dwRet);
            DBGMSG(DBG_WARNING,("Can't Crack Name: %ws, %ws\n", pDCI->DomainName, ErrorBuffer));
            SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                       gdwLogDsEvents & LOG_ERROR,
                       MSG_CANT_CRACK,
                       FALSE,
                       pDCI->DomainName,
                       ErrorBuffer,
                       NULL );
            goto error;
        }

        // LDAP:// + pDCName + / + pName + 1
        hr = BuildLDAPPath(pDCI->DomainControllerName + 2, pDNR->rItems[0].pName, ppszDN);
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (pDsRole)
        DsRoleFreeMemory((PVOID) pDsRole);

    // If dwRet has no facility, then make into HRESULT
    if (dwRet != ERROR_SUCCESS) {
        if (HRESULT_CODE(dwRet) == dwRet) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
        } else {
            hr = dwRet;
        }
    }

    // Finally, make absolutely sure we are failing if *ppszDN is NULL
    if (hr == S_OK && (!ppszDN || !*ppszDN)) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND);
    }

    return hr;
}


//  Utility routine to report if a printer is color or monochrome

BOOL
ThisIsAColorPrinter(
    LPCTSTR lpstrName
)
/*++
Function Description:
    This function determines whether or not a printer supports color printing

Parameters:
    lpstrName - Printer name

Return Values:
    If printer supports color, return is TRUE.  Otherwise, return value is FALSE
--*/
{
    HANDLE      hPrinter = NULL;
    LPTSTR      lpstrMe = const_cast <LPTSTR> (lpstrName);
    BOOL        bReturn = FALSE;
    LPDEVMODE   lpdm = NULL;
    long        lcbNeeded;

    if  (!(*pfnOpenPrinter)(lpstrMe, &hPrinter, NULL)) {
        DBGMSG(DBG_WARNING, ("Unable to open printer '%ws'- error %d\n", lpstrName,
            GetLastError()));
        goto error;
    }


    //  First, use DocumentProperties to find the correct DEVMODE size- we
    //  must use the DEVMODE to force color on, in case the user's defaults
    //  have turned it off...

    lcbNeeded = (*pfnDocumentProperties)(NULL, hPrinter, lpstrMe, NULL, NULL, 0);

    if  (lcbNeeded <= 0) {
        DBGMSG( DBG_WARNING,
                ("Document Properties (get size) for '%ws' returned %d\n",
                lpstrName,lcbNeeded));
        goto error;
    }

    lpdm = (LPDEVMODE) AllocSplMem(lcbNeeded);
    if (lpdm) {

        lpdm->dmSize = sizeof(DEVMODE);
        lpdm->dmFields = DM_COLOR;
        lpdm->dmColor = DMCOLOR_COLOR;

        if (IDOK == (*pfnDocumentProperties)(NULL, hPrinter, lpstrMe, lpdm, lpdm, DM_IN_BUFFER | DM_OUT_BUFFER)) {

            //  Finally, we can create the DC!
            HDC hdcThis = CreateDC(NULL, lpstrName, NULL, lpdm);

            if  (hdcThis) {
                bReturn =  2 < (unsigned) GetDeviceCaps(hdcThis, NUMCOLORS);
                DeleteDC(hdcThis);
            }
        }
        else
            DBGMSG(DBG_WARNING, ("DocumentProperties (retrieve) on '%s' failed- error %d\n",
                                lpstrName, GetLastError()));
    }
    else
        DBGMSG(DBG_WARNING, ("ThisIsAColorPrinter(%s) failed to get %d bytes\n",
                                lpstrName, lcbNeeded));


error:

    FreeSplMem(lpdm);

    if (hPrinter)
        (*pfnClosePrinter)(hPrinter);

    return  bReturn;
}


HRESULT
GetSID(
    IADs    *pADs,
    PWSTR   *ppszObjectSID
)
/*++
Function Description:
    This function returns the ObjectSID of a given ADs user object.
    ppszObjectGUID must be freed by caller using FreeSplStr().

Parameters:
    pADs - input ADs object pointer
    ppszObjectSID - objectSID of pADs

Return Values:
    HRESULT
--*/
{
    HRESULT     hr;
    LPWSTR      pszObjectSID = NULL;
    SID         ObjectSID;

    hr = pADs->GetInfo();

    if (SUCCEEDED(hr)) {

        hr = get_SID_Property(pADs, L"ObjectSID", &pszObjectSID);

        if (SUCCEEDED(hr)) {

            if (!(*ppszObjectSID = AllocSplStr(pszObjectSID))) {

                    hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            }

            LocalFree(pszObjectSID);
        }
    }

    return hr;
}

HRESULT
GetGUID(
    IADs    *pADs,
    PWSTR   *ppszObjectGUID
)
/*++
Function Description:
    This function returns the ObjectGUID of a given ADs object.
    ppszObjectGUID must be freed by caller using FreeSplStr().

Parameters:
    pADs - input ADs object pointer
    ppszObjectGUID - object GUID of pADs

Return Values:
    HRESULT
--*/
{
    HRESULT     hr;
    LPOLESTR    pszObjectGUID = NULL;
    IID         ObjectIID;

    hr = pADs->GetInfo();

    if (SUCCEEDED(hr)) {
        hr = get_UI1Array_Property(pADs, L"ObjectGUID", &ObjectIID);

        if (SUCCEEDED(hr)) {
            hr = StringFromIID(ObjectIID, &pszObjectGUID);

            if (SUCCEEDED(hr)) {
                if (!(*ppszObjectGUID = AllocSplStr(pszObjectGUID)))
                    hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            }
            CoTaskMemFree(pszObjectGUID);
        }
    }

    return hr;
}



BOOL
PrinterPublishProhibited()
{
    return !GetSpoolerNumericPolicy(szPublishPrinters, DEFAULT_PRINT_PUBLISH_POLICY);
}


DWORD
VerifyPublishedStatePolicy()
{
    return GetSpoolerNumericPolicy(szVerifyPublishedState, DEFAULT_VERIFY_PUBLISHED_STATE);
}


DWORD
PruneDownlevel()
{
    return GetSpoolerNumericPolicy(szPruneDownlevel, DEFAULT_PRUNE_DOWNLEVEL);
}

DWORD
PruningInterval(
)
{
    return GetSpoolerNumericPolicy(szPruningInterval, DEFAULT_PRUNING_INTERVAL);
}

DWORD
ImmortalPolicy(
)
{
    return GetSpoolerNumericPolicy(szImmortal, DEFAULT_IMMORTAL);
}

VOID
ServerThreadPolicy(
    BOOL bHaveDs
)
{
    DWORD dwPolicy;

    dwPolicy = GetSpoolerNumericPolicy(szServerThreadPolicy, SERVER_THREAD_UNCONFIGURED);

    if (dwPolicy == SERVER_THREAD_UNCONFIGURED) {
        ServerThreadRunning = !(bHaveDs ? SERVER_THREAD_OFF : SERVER_THREAD_ON);
    } else {
        ServerThreadRunning = !dwPolicy;
    }
    CreateServerThread();
}

DWORD
PruningRetries(
)
{
    DWORD dwPruningRetries;

    dwPruningRetries = GetSpoolerNumericPolicy(szPruningRetries, DEFAULT_PRUNING_RETRIES);

    if (dwPruningRetries > MAX_PRUNING_RETRIES)
        dwPruningRetries = MAX_PRUNING_RETRIES;

    return dwPruningRetries;
}

DWORD
PruningRetryLog(
)
{
    DWORD dwPruningRetryLog;

    dwPruningRetryLog = GetSpoolerNumericPolicy(szPruningRetryLog, DEFAULT_PRUNING_RETRY_LOG);

    return dwPruningRetryLog;
}

VOID
SetPruningPriority(
)
{
    DWORD dwPriority = GetSpoolerNumericPolicy(szPruningPriority, DEFAULT_PRUNING_PRIORITY);

    if (dwPriority != dwLastPruningPriority) {
        if (dwPriority == THREAD_PRIORITY_LOWEST          ||
            dwPriority == THREAD_PRIORITY_BELOW_NORMAL    ||
            dwPriority == THREAD_PRIORITY_NORMAL          ||
            dwPriority == THREAD_PRIORITY_ABOVE_NORMAL    ||
            dwPriority == THREAD_PRIORITY_HIGHEST) {
            SetThreadPriority(GetCurrentThread(), DEFAULT_PRUNING_PRIORITY);
        } else {
            SetThreadPriority(GetCurrentThread(), dwPriority);
        }
        dwLastPruningPriority = dwPriority;
    }
}



BOOL
ThisMachineIsADC(
)
{
    NT_PRODUCT_TYPE  NtProductType;
    RtlGetNtProductType(&NtProductType);
    return NtProductType == NtProductLanManNt;
}



DWORD
GetDomainRoot(
    PWSTR   *ppszDomainRoot
)
/*++
Function Description:
    This function returns the ADsPath of the root of the current domain

Parameters:
    ppszDomainRoot - pointer to buffer receiving string pointer of domain root ADsPath string
                     free ppszDomainRoot with a call to FreeSplMem

Return Values:
    DWORD

--*/
{
    DWORD                                dwRet = ERROR_SUCCESS;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    DS_NAME_RESULT                        *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO                *pDCI = NULL;
    HANDLE                                hDS = NULL;
    WCHAR                                szName[MAX_PATH + 1];
    PWSTR                                pNames[2];
    PWSTR                               pszDomainRoot;
    DWORD                               cb;


    if (!ppszDomainRoot) {
        dwRet = ERROR_INVALID_PARAMETER;
        goto error;
    }

    // Get Domain name
    dwRet = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) &pDsRole);
    if (dwRet)
        goto error;

    StringCchPrintf(szName, COUNTOF(szName), L"%ws\\", pDsRole->DomainNameFlat);

    pNames[0] = szName;
    pNames[1] = NULL;


    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS) {
        goto error;
    }

    if (!(DsCrackNames(
                    hDS,
                    DS_NAME_NO_FLAGS,
                    DS_UNKNOWN_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &pNames[0],
                    &pDNR) == ERROR_SUCCESS)) {

        dwRet = GetLastError();
        goto error;
    }

    if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
        dwRet = DsCrackNamesStatus2Win32Error(pDNR->rItems[0].status);
        goto error;
    }

    // LDAP:// + pDCName + 1
    cb = (wcslen(pDNR->rItems[0].pName) + 8)*sizeof(WCHAR);

    if (!(*ppszDomainRoot = (PWSTR) AllocSplMem(cb))) {
        dwRet = GetLastError();
        goto error;
    }

    StringCbPrintf(*ppszDomainRoot, cb, L"LDAP://%ws", pDNR->rItems[0].pName);

error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (pDsRole)
        DsRoleFreeMemory((PVOID) pDsRole);

    return dwRet;
}



PWSTR
CreateSearchString(
    PWSTR pszIn
)
{
    PWSTR psz, pszSS;
    PWSTR pszSearchString = NULL;
    DWORD cb;

    /* Replace \ with \5c */

    /* Count chars & pad */

    for (cb = 0, psz = pszIn ; *psz ; ++psz, ++cb) {
        if (*psz == L'\\')
            cb += 2;
    }
    cb = (cb + 1)*sizeof *psz;

    if (pszSearchString = (PWSTR) GlobalAlloc(GMEM_FIXED, cb)) {

        for(psz = pszIn, pszSS = pszSearchString ; *psz ; ++psz, ++pszSS) {
            *pszSS = *psz;

            if (*psz == L'\\') {
                *++pszSS = L'5';
                *++pszSS = L'c';
            }
        }
        *pszSS = L'\0';
    }

    return pszSearchString;
}



BOOL
ServerOnSite(
    PWSTR   *ppszMySites,
    ULONG   cMySites,
    PWSTR   pszServer
)
/*++
Function Description:
    This function returns TRUE if pszServer is on one of the ppszMySites and pszServer exists

Parameters:
    ppszMySites - input sites
    pszServer - input server name

Return Values:
    BOOL - TRUE if server exists on site, FALSE otherwise or on error

--*/
{
    PSOCKET_ADDRESS pSocketAddresses = NULL;
    PWSTR           *ppszSiteNames = NULL;
    DWORD           nAddresses;
    DWORD           dwRet, i;
    ULONG           j;
    WORD            wVersion;
    WSADATA         WSAData;
    BOOL            bServerOnSite = FALSE;

    wVersion = MAKEWORD(1, 1);

    if (WSAStartup(wVersion, &WSAData) == ERROR_SUCCESS) {

        // Find out if Server is on Site
        GetSocketAddressesFromMachineName(pszServer, &pSocketAddresses, &nAddresses);

        if (nAddresses == 0) {
            bServerOnSite = TRUE;   // Claim server is on site if we can't find it
        } else {
            dwRet = DsAddressToSiteNames(   (PCWSTR) NULL,
                                            nAddresses,
                                            pSocketAddresses,
                                            &ppszSiteNames);
            if (dwRet == NO_ERROR) {
                for(i = 0 ; i < nAddresses ; ++i) {
                    for(j = 0 ; j < cMySites ; ++j) {
                        if (ppszSiteNames[i] && ppszMySites[j] && !wcscmp(ppszSiteNames[i], ppszMySites[j])) {
                            bServerOnSite = TRUE;
                            break;
                        }
                    }
                }
            }
        }

        if (ppszSiteNames)
            NetApiBufferFree(ppszSiteNames);

        if (pSocketAddresses)
            FreeSplSockets(pSocketAddresses, nAddresses);

        WSACleanup();
    }

    return bServerOnSite;
}


VOID
FreeSplSockets(
    PSOCKET_ADDRESS  pSocketAddress,
    DWORD            nAddresses
)
{
    DWORD           i;
    PSOCKET_ADDRESS  pSocket;

    for(i = 0, pSocket = pSocketAddress ; i < nAddresses ; ++i, ++pSocket)
        FreeSplMem(pSocket->lpSockaddr);

    FreeSplMem(pSocketAddress);
}


VOID
AllocSplSockets(
    struct hostent  *pHostEnt,
    PSOCKET_ADDRESS *ppSocketAddress,
    DWORD           *nSocketAddresses
)
{
    DWORD           i;
    PSOCKET_ADDRESS pSocket;

    for ( *nSocketAddresses  = 0 ; pHostEnt->h_addr_list[*nSocketAddresses] ; ++(*nSocketAddresses))
        ;

    // Allocate SOCKET_ADDRESS array
    *ppSocketAddress = (PSOCKET_ADDRESS) AllocSplMem(*nSocketAddresses*sizeof(SOCKET_ADDRESS));
    if (!*ppSocketAddress)
        *nSocketAddresses = 0;

    // Allocate Sockaddr element for each SOCKET_ADDRESS
    // If we fail partway through, just use partial list
    for (i = 0, pSocket = *ppSocketAddress ; i < *nSocketAddresses ; ++i, ++pSocket) {
        if (!(pSocket->lpSockaddr = (struct sockaddr *) AllocSplMem(sizeof(struct sockaddr_in)))) {
            *nSocketAddresses = i;
            break;
        }
        if (pHostEnt->h_addrtype == AF_INET) {
            ((struct sockaddr_in *) pSocket->lpSockaddr)->sin_family = AF_INET;
            ((struct sockaddr_in *) pSocket->lpSockaddr)->sin_addr = *(struct in_addr *) pHostEnt->h_addr_list[i];
            pSocket->iSockaddrLength = sizeof(struct sockaddr_in);
        } else {
            DBGMSG(DBG_WARNING,("AllocSplSockets: addrtype != AF_INET: %d\n", pHostEnt->h_addrtype));
        }
    }
}


VOID
GetSocketAddressesFromMachineName(
    PWSTR           pszMachineName,     // \\Machine
    PSOCKET_ADDRESS *ppSocketAddress,
    DWORD           *nSocketAddresses
)
/*++

Routine Description:
    This routine builds list of names other than the machine name that
    can be used to call spooler APIs.

--*/
{
    struct hostent     *HostEnt;
    PSTR               pszAnsiMachineName = NULL;
    DWORD              iWsaError;

    *nSocketAddresses  = 0;
    *ppSocketAddress = 0;

    if (SUCCEEDED(UnicodeToAnsiString(pszMachineName + 2, &pszAnsiMachineName))) {
        if (HostEnt = gethostbyname(pszAnsiMachineName)) {
            AllocSplSockets(HostEnt, ppSocketAddress, nSocketAddresses);
        } else {
            iWsaError = WSAGetLastError();
            DBGMSG(DBG_WARNING, ("gethostbyname failed in DsPrune: %d\n", iWsaError));
        }
    }

    FreeSplMem(pszAnsiMachineName);
}


DWORD
UNC2Server(
    PCWSTR pszUNC,
    PWSTR *ppszServer
)
{
    PWSTR psz;
    DWORD cb;
    DWORD nChars;

    if (!pszUNC || pszUNC[0] != L'\\' || pszUNC[1] != L'\\')
        return ERROR_INVALID_PARAMETER;

    if(!(psz = wcschr(pszUNC + 2, L'\\')))
        return ERROR_INVALID_PARAMETER;

    cb = (DWORD) ((ULONG_PTR) psz - (ULONG_PTR) pszUNC + sizeof *psz);

    if (!(*ppszServer = (PWSTR) AllocSplMem(cb)))
        return GetLastError();


    nChars = (DWORD) (psz - pszUNC);
    wcsncpy(*ppszServer, pszUNC, nChars);
    (*ppszServer)[nChars] = L'\0';

    return ERROR_SUCCESS;
}




BOOL
ServerExists(
    PWSTR   pszServerName
)
{
    NET_API_STATUS  Status;
    SERVER_INFO_100 *pServer;
    BOOL            bServerExists;

    Status = NetServerGetInfo(pszServerName, 100, (PBYTE *) &pServer);
    bServerExists = !Status;
    Status = NetApiBufferFree(pServer);

    return bServerExists;
}



HRESULT
UnpublishByGUID(
    PINIPRINTER pIniPrinter
)
{
    HRESULT         hr;

    SplOutSem();

    if (!pIniPrinter->pszObjectGUID) {
        pIniPrinter->DsKeyUpdate = 0;
        pIniPrinter->DsKeyUpdateForeground = 0;
        hr = S_OK;

    } else {

        PWSTR           pszDN = NULL;
        PWSTR           pszCN = NULL;

        hr = GetPublishPointFromGUID(NULL, pIniPrinter->pszObjectGUID, &pszDN, &pszCN, TRUE);

        DBGMSG(DBG_EXEC,
               ("UnpublishByGUID: GUID %ws\n", pIniPrinter->pszObjectGUID));

        if (SUCCEEDED(hr)) {

            DBGMSG(DBG_EXEC,
                   ("UnpublishByGUID: DN %ws CN %ws\n",
                    pszDN,
                    pszCN));

            IADsContainer *pADsContainer = NULL;

            // Get the container
            hr = ADsGetObject(  pszDN,
                                IID_IADsContainer,
                                (void **) &pADsContainer
                                );

            if (SUCCEEDED(hr)) {
                hr = pADsContainer->Delete(SPLDS_PRINTER_CLASS, pszCN);
                pADsContainer->Release();
            }

            // If the container or the object is gone, succeed
            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) ||
                HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND ||
                HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND)
                hr = S_OK;

        }
        FreeSplStr(pszDN);
        FreeSplStr(pszCN);
    }


    // free GUID if object is deleted
    if (SUCCEEDED(hr)) {
        pIniPrinter->DsKeyUpdate = 0;
        pIniPrinter->DsKeyUpdateForeground = 0;

        FreeSplStr(pIniPrinter->pszObjectGUID);
        pIniPrinter->pszObjectGUID = NULL;

        FreeSplStr(pIniPrinter->pszCN);
        pIniPrinter->pszCN = NULL;

        FreeSplStr(pIniPrinter->pszDN);
        pIniPrinter->pszDN = NULL;

        EnterSplSem();

        if (pIniPrinter->bDsPendingDeletion) {
            pIniPrinter->bDsPendingDeletion = 0;
            DECPRINTERREF(pIniPrinter);
        }

        LeaveSplSem();


        DBGMSG(DBG_EXEC, ("UnpublishByGUID Succeeded\n"));
    } else {
        pIniPrinter->DsKeyUpdate = DS_KEY_UNPUBLISH;
        DBGMSG(DBG_EXEC, ("UnpublishByGUID Failed\n"));
    }

    SplOutSem();

    return hr;
}


HRESULT
GetDNSMachineName(
    PWSTR pszShortMachineName,
    PWSTR *ppszMachineName
)
{
    struct  hostent  *pHostEnt;
    DWORD   dwRet   = ERROR_SUCCESS;
    HRESULT hr      = S_OK;
    PSTR    pszAnsiMachineName = NULL;
    WORD    wVersion;
    WSADATA WSAData;

    wVersion = MAKEWORD(1, 1);

    dwRet = WSAStartup(wVersion, &WSAData);

    if (dwRet == ERROR_SUCCESS) {

        if (!pszShortMachineName || !*pszShortMachineName) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);
            BAIL_ON_FAILURE(hr);
        }

        hr = UnicodeToAnsiString(pszShortMachineName, &pszAnsiMachineName);
        BAIL_ON_FAILURE(hr);

        if (!(pHostEnt = gethostbyname(pszAnsiMachineName))) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, WSAGetLastError());
            BAIL_ON_FAILURE(hr);
        }

        if (!(*ppszMachineName = AnsiToUnicodeStringWithAlloc(pHostEnt->h_name))) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            BAIL_ON_FAILURE(hr);
        }

    } else {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
    }

error:

    if (dwRet == ERROR_SUCCESS)
    {
        WSACleanup();
    }

    FreeSplMem(pszAnsiMachineName);

    return hr;
}

HRESULT
GetClusterUser(
    IADs    **ppADs
)
{
    HRESULT         hr;
    WCHAR           szUserName[MAX_PATH + 8];   // Allow for LDAP://
    PWSTR           pszUserName = szUserName;
    DWORD           cchUserName = MAX_PATH + 1;
    BOOL            bRet;


    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
        return hr;

    // Get cluster container's name, which must be the current user name
    StringCchCopy(pszUserName, COUNTOF(szUserName), L"LDAP://");

    if (!GetUserNameEx(NameFullyQualifiedDN, pszUserName + 7, &cchUserName)) {
        if (cchUserName > MAX_PATH + 1) {

            pszUserName = (PWSTR) AllocSplMem((cchUserName + 7)*sizeof(WCHAR));
            if (!pszUserName) {
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
                goto error;
            }

            StringCchPrintf(pszUserName, cchUserName + 7, L"LDAP://");

            if (!GetUserNameEx(NameFullyQualifiedDN, pszUserName + 7, &cchUserName)) {
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
                goto error;
            }

        } else {
            hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            goto error;
        }
    }

    // Get the object
    hr = ADsGetObject(  pszUserName,
                        IID_IADs,
                        (void **) ppADs
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pszUserName != szUserName)
        FreeSplStr(pszUserName);

    CoUninitialize();

    return hr;
}



HRESULT
FQDN2Whatever(
    PWSTR pszIn,
    PWSTR *ppszOut,
    DS_NAME_FORMAT  NameFormat
)
{
    DWORD                               dwRet = ERROR_SUCCESS;
    DS_NAME_RESULT                      *pDNR = NULL;
    DOMAIN_CONTROLLER_INFO              *pDCI = NULL;
    HANDLE                              hDS = NULL;
    PWSTR                               pNames[2];
    PWSTR                               psz;
    HRESULT                             hr = S_OK;


    *ppszOut = NULL;

    // Get the DC name
    dwRet = Bind2DS(&hDS, &pDCI, DS_DIRECTORY_SERVICE_PREFERRED);
    if (dwRet != ERROR_SUCCESS)
        goto error;

    // Translate the name
    if (wcslen(pszIn) < 8) {
        dwRet = ERROR_INVALID_PARAMETER;
        goto error;
    }

    psz = wcschr(pszIn + 7, L'/');
    if (!psz) {
        dwRet = ERROR_INVALID_PARAMETER;
        goto error;
    }

    pNames[0] = ++psz;  // Input string is LDAP://ntdev.microsoft.com/CN=...  Strip off the LDAP://.../ portion
    pNames[1] = NULL;

    if (!(DsCrackNames(
                    hDS,
                    DS_NAME_NO_FLAGS,
                    DS_FQDN_1779_NAME,
                    NameFormat,
                    1,
                    &pNames[0],
                    &pDNR) == ERROR_SUCCESS)) {

        dwRet = GetLastError();
        goto error;
    }

    if (pDNR->rItems[0].status != DS_NAME_NO_ERROR) {
        dwRet = DsCrackNamesStatus2Win32Error(pDNR->rItems[0].status);
        goto error;
    }

    *ppszOut = AllocSplStr(pDNR->rItems[0].pName);


error:

    if (pDNR)
        DsFreeNameResult(pDNR);

    if (hDS)
        DsUnBind(&hDS);

    if (pDCI)
        NetApiBufferFree(pDCI);


    return dwRet == ERROR_SUCCESS ? S_OK : MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
}



DWORD
InitializeDSClusterInfo(
    PINISPOOLER     pIniSpooler,
    HANDLE          *phToken
)
{
    HRESULT hr = S_OK;
    DWORD   dwError = ERROR_SUCCESS;
    IADs    *pADs = NULL;


    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) {
        return HRESULT_CODE(hr);
    }


    // Impersonate the client
    if (!ImpersonatePrinterClient(*phToken)) {
        dwError = GetLastError();
        DBGMSG(DBG_WARNING,("InitializeDSClusterInfo FAILED: %d\n", dwError));
        CoUninitialize();
        return dwError;
    }


    // Get a copy of the client token
    dwError = NtOpenThreadToken(NtCurrentThread(), TOKEN_IMPERSONATE, TRUE, &pIniSpooler->hClusterToken);
    if (dwError != STATUS_SUCCESS) {
        DBGMSG(DBG_WARNING,("InitializeDSClusterInfo DuplicateToken FAILED: %d\n", dwError));
        pIniSpooler->hClusterToken = INVALID_HANDLE_VALUE;
        goto error;
    }

    // Get the Cluster User Object
    if (SUCCEEDED(hr = GetClusterUser(&pADs))) {

        hr = GetSID(pADs, &pIniSpooler->pszClusterSID);
    }

error:

    *phToken = RevertToPrinterSelf();

    if (FAILED(hr)) {
        dwError = HRESULT_CODE(hr);
        FreeSplStr(pIniSpooler->pszClusterSID);
        pIniSpooler->pszClusterSID = NULL;
    }

    if (pADs)
    pADs->Release();

    CoUninitialize();

    return dwError;
}



BOOL
CheckPublishedPrinters(
)
{
    PINIPRINTER pIniPrinter;
    BOOL        bHavePublishedPrinters = FALSE;

    SplInSem();

    if (VerifyPublishedStatePolicy() == INFINITE)
        return FALSE;

    RunForEachSpooler(&bHavePublishedPrinters, CheckPublishedSpooler);

    return bHavePublishedPrinters;
}

BOOL
CheckPublishedSpooler(
    HANDLE      h,
    PINISPOOLER pIniSpooler
)
{
    PBOOL       pbHavePublishedPrinters = (PBOOL)h;
    PINIPRINTER pIniPrinter;

    if (!(pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL))
        return TRUE;

    for (pIniPrinter = pIniSpooler->pIniPrinter ; pIniPrinter ; pIniPrinter = pIniPrinter->pNext) {
        if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) {

            // Refresh: verify that we're really published
            // Note that if there isn't any new info to publish and we're published,
            // we won't do any SetInfo so the overhead is minimal
            pIniPrinter->DsKeyUpdate |= DS_KEY_PUBLISH;
            *pbHavePublishedPrinters = TRUE;

        } else if (pIniPrinter->pszObjectGUID) {

            // The only way we can get here is if someone is unpublishing the printer,
            // so we don't really need to set the background DsKeyUpdate state.  Doing
            // so maintains symmetry with above statement and InitializeDS
            pIniPrinter->DsKeyUpdate |= DS_KEY_UNPUBLISH;
            *pbHavePublishedPrinters = TRUE;
        }
    }

    return TRUE;
}


PWSTR
CreateEscapedString(
    PCWSTR pszIn,
    PCWSTR pszSpecialChars
)
{
    PWSTR psz, pszO;
    PWSTR pszOut = NULL;
    DWORD cb;

    if (!pszIn || !pszSpecialChars) {
        SetLastError(ERROR_INVALID_NAME);
        return NULL;
    }

    // Count special characters
    for (cb = 0, psz = (PWSTR) pszIn ; psz = wcspbrk(psz, pszSpecialChars) ; ++cb, ++psz)
        ;

    // Add in length of input string
    cb = (wcslen(pszIn) + cb + 1)*sizeof *pszIn;

    // Allocate output buffer and precede special DS chars with '\'
    if (pszOut = (PWSTR) AllocSplMem(cb)) {

        for(psz = (PWSTR) pszIn, pszO = pszOut ; *psz ; ++psz, ++pszO) {
            if (wcschr(pszSpecialChars, *psz)) {
                *pszO++ = L'\\';
            }
            *pszO = *psz;
        }
        *pszO = L'\0';
    }

    return pszOut;
}


PWSTR
DevCapStrings2MultiSz(
    PWSTR   pszDevCapString,
    DWORD   nDevCapStrings,
    DWORD   dwDevCapStringLength,
    DWORD   *pcbBytes
)
{
    DWORD   i, cbBytes, cbSize;
    PWSTR   pszMultiSz = NULL;
    PWSTR   pStr;


    if (!pszDevCapString || !pcbBytes)
        return NULL;

    *pcbBytes = 0;

    //
    // Devcap buffers may not be NULL terminated
    //
    cbBytes = (nDevCapStrings*(dwDevCapStringLength + 1) + 1)*sizeof(WCHAR);


    //
    // Allocate and copy
    //
    if (pszMultiSz = (PWSTR) AllocSplMem(cbBytes)) {
        for(i = 0, pStr = pszMultiSz, cbBytes = 0 ; i < nDevCapStrings ; ++i, pStr += cbSize, cbBytes +=cbSize ) {
            wcsncpy(pStr, pszDevCapString + i*dwDevCapStringLength, dwDevCapStringLength);
            cbSize = *pStr ? wcslen(pStr) + 1 : 0;
        }
        *pStr = L'\0';
        *pcbBytes = (cbBytes + 1) * sizeof(WCHAR);
    }

    return pszMultiSz;
}

DWORD
Bind2DS(
    HANDLE                  *phDS,
    DOMAIN_CONTROLLER_INFO  **ppDCI,
    ULONG                   Flags
)
{
    DWORD dwRet;

    dwRet = DsGetDcName(NULL, NULL, NULL, NULL, Flags, ppDCI);
    if (dwRet == ERROR_SUCCESS) {

        if ((*ppDCI)->Flags & DS_DS_FLAG) {

            dwRet = DsBind (NULL, (*ppDCI)->DomainName, phDS);
            if (dwRet != ERROR_SUCCESS) {

                NetApiBufferFree(*ppDCI);
                *ppDCI = NULL;

                if (!(Flags & DS_FORCE_REDISCOVERY)) {
                    dwRet = Bind2DS(phDS, ppDCI, DS_FORCE_REDISCOVERY | Flags);
                }
            }
        } else {
            NetApiBufferFree(*ppDCI);
            *ppDCI = NULL;
            dwRet = ERROR_CANT_ACCESS_DOMAIN_INFO;
        }
    }

    return dwRet;
}


DWORD
DsCrackNamesStatus2Win32Error(
    DWORD dwStatus
)
{
    switch (dwStatus) {
        case DS_NAME_ERROR_RESOLVING:
            return ERROR_DS_NAME_ERROR_RESOLVING;

        case DS_NAME_ERROR_NOT_FOUND:
            return ERROR_DS_NAME_ERROR_NOT_FOUND;

        case DS_NAME_ERROR_NOT_UNIQUE:
            return ERROR_DS_NAME_ERROR_NOT_UNIQUE;

        case DS_NAME_ERROR_NO_MAPPING:
            return ERROR_DS_NAME_ERROR_NO_MAPPING;

        case DS_NAME_ERROR_DOMAIN_ONLY:
            return ERROR_DS_NAME_ERROR_DOMAIN_ONLY;

        case DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING:
            return ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
    }

    return ERROR_FILE_NOT_FOUND;
}

DWORD
GetDSSleepInterval (
    HANDLE h
)
{
    DWORD           dwVerifyPublishedStateInterval;
    PDSUPDATEDATA   pData = (PDSUPDATEDATA)h;
    DWORD           dwTimeToSleep = 30 * ONE_MINUTE;
    //
    // 30 min is the minimum interval that can be set with the policy editor.
    // If someone enables the policy while we are sleeping, then we need to wake up
    // to pick the settings. This doesn't apply if the DS doesn't respond.
    //


    if (pData && pData->bSleep) {

        //
        // If the updating is failing, Data.bSleep is set to TRUE.
        // This happens when the DS is down.
        //
        dwTimeToSleep = pData->dwSleepTime;

        //
        // Sleep interval is doubled to a maximum of 2 hours.
        // We still want to attempt publishing every 2 hours. We also attempt if
        // a "publish" action is taken(the even will be signaled).
        //
        //
        pData->dwSleepTime = pData->dwSleepTime * 2 > 2 * ONE_HOUR ?
                             2 * ONE_HOUR :
                             pData->dwSleepTime * 2;

    } else {

        dwTimeToSleep = VerifyPublishedStatePolicy();

        if (dwTimeToSleep != INFINITE)
        {
            dwTimeToSleep *= ONE_MINUTE;
        }
    }

    return dwTimeToSleep;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\files.c ===
/*++

Copyright (c) 1990 - 1996 Microsoft Corporation

Module Name:

    Files.c

Abstract:

    This module provides routines required to copy files associated with a
    printer on printer connection

Author:

    Muhunthan Sivapragasam (MuhuntS) 05-Dec-96

Revision History:

--*/

#include <precomp.h>
#include "clusspl.h"

HMODULE
SplLoadLibraryTheCopyFileModule(
    HANDLE  hPrinter,
    LPWSTR  pszModule
    )
{
    UINT        uErrorMode;
    DWORD       dwLen;
    WCHAR       szPath[MAX_PATH];
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    HMODULE     hModule;
    PINIDRIVER  pIniDriver;

    uErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    //
    // This should be fine because we will be using the process path. Unforunately
    // the registry has been set up not to use a full path, so we can't change this
    // and be sure of not breaking backward compatability.
    //
    hModule = LoadLibrary(pszModule);

    //
    // If the module could not be found in $Path look for it in the
    // printer driver directory
    //
    if ( !hModule &&
         GetLastError() == ERROR_MOD_NOT_FOUND  &&
         (dwLen = GetIniDriverAndDirForThisMachine(pSpool->pIniPrinter,
                                                   szPath,
                                                   &pIniDriver)) ) {

        if (!BoolFromHResult(StringCchCopy(szPath+dwLen, COUNTOF(szPath) - dwLen, pszModule))) {

            goto Cleanup;
        }

        hModule = LoadLibraryEx(szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    }

Cleanup:
    (VOID)SetErrorMode(uErrorMode);

    return hModule;
}


BOOL
GenerateDirectoryNamesForCopyFilesKey(
    PSPOOL      pSpool,
    HKEY        hKey,
    LPWSTR      *ppszSourceDir,
    LPWSTR      *ppszTargetDir,
    DWORD       cbMax
    )
{
    BOOL        bRet = FALSE, bInCS = FALSE;
    DWORD       dwType, dwSize, dwSourceDirSize, dwTargetDirSize;
    LPWSTR      pszDir, ppszFiles, pszModule = NULL, pszPrinterName = NULL;
    HMODULE     hModule = NULL;
    DWORD       (*pfn)(LPWSTR       pszPrinterName,
                       LPCWSTR      pszDirectory,
                       LPBYTE       pSplClientInfo,
                       DWORD        dwLevel,
                       LPWSTR       pszSourceDir,
                       LPDWORD      pcchSourceDirSize,
                       LPWSTR       pszTargetDir,
                       LPDWORD      pcchTargetDirSize,
                       DWORD        dwFlags
                      );
    SPLCLIENT_INFO_1    SplClientInfo1;

    //
    // First find the keys we need from the registry
    // "Directory", "Files" values are mandatory. "Module" is optional
    //
    pszDir          = (LPWSTR) AllocSplMem(cbMax);
    ppszFiles       = (LPWSTR) AllocSplMem(cbMax);
    pszModule       = (LPWSTR) AllocSplMem(cbMax);

    if ( !pszDir || !ppszFiles || !pszModule )
        goto Cleanup;

    if ( (dwSize = cbMax)                                            &&
         ERROR_SUCCESS == SplRegQueryValue(hKey,
                                           L"Directory",
                                           &dwType,
                                           (LPBYTE)pszDir,
                                           &dwSize,
                                           pSpool->pIniSpooler)      &&
         dwType == REG_SZ                                            &&
         (dwSize = cbMax)                                            &&
         ERROR_SUCCESS == SplRegQueryValue(hKey,
                                          L"Files",
                                          &dwType,
                                          (LPBYTE)ppszFiles,
                                          &dwSize,
                                          pSpool->pIniSpooler)       &&
        dwType == REG_MULTI_SZ ) {

        dwSize = cbMax;
        if ( ERROR_SUCCESS == SplRegQueryValue(hKey,
                                               L"Module",
                                               &dwType,
                                               (LPBYTE)pszModule,
                                               &dwSize,
                                               pSpool->pIniSpooler)  &&
             dwType != REG_SZ ) {

            SetLastError(ERROR_INVALID_PARAMETER);
            goto Cleanup;
        }
    }

    //
    // If a module is given we need to call into to "correct" the path
    // We will first try LoadLibrary on the module, if we can't find the module
    // we will look in the driver directory for it
    //
    if ( pszModule && *pszModule ) {

        if ( !(hModule = SplLoadLibraryTheCopyFileModule(pSpool, pszModule)) ||
             !((FARPROC)pfn = GetProcAddress(hModule, "GenerateCopyFilePaths")) )
        goto Cleanup;
    }


    dwTargetDirSize = MAX_PATH;
    dwSourceDirSize = INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH;
    *ppszSourceDir    = (LPWSTR) AllocSplMem(dwSourceDirSize * sizeof(WCHAR));
    *ppszTargetDir    = (LPWSTR) AllocSplMem(dwTargetDirSize * sizeof(WCHAR));

    if ( !*ppszSourceDir || !*ppszTargetDir )
        goto Cleanup;

    EnterSplSem();
    bInCS = TRUE;
    pszPrinterName = AllocSplStr(pSpool->pIniPrinter->pName);

    //
    // For source dir we will give full path the way the client will understand
    // (ie. have correct prefix -- server nam, dns name etc).
    // For target dir we will give a relative path off print$
    //
    if ( !pszPrinterName || wcslen(pszDir) >= dwTargetDirSize ||
         wcslen(pSpool->pFullMachineName) +
         wcslen(pSpool->pIniSpooler->pszDriversShare) +
         wcslen(pszDir) + 2 >= dwSourceDirSize ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;

    }

    StringCchPrintf(*ppszSourceDir, dwSourceDirSize,
                    L"%ws\\%ws\\%ws",
                    pSpool->pFullMachineName,
                    pSpool->pIniSpooler->pszDriversShare,
                    pszDir);

    CopyMemory((LPBYTE)&SplClientInfo1, (LPBYTE)&pSpool->SplClientInfo1, sizeof(SPLCLIENT_INFO_1));

    SplClientInfo1.pUserName    = NULL;
    SplClientInfo1.pMachineName = NULL;

    LeaveSplSem();
    bInCS = FALSE;

    StringCchCopy(*ppszTargetDir, dwTargetDirSize, pszDir);

    if ( hModule ) {

        //
        // On free builds we do not want spooler to crash
        //
#if DBG
#else
        try {
#endif
            if ( ERROR_SUCCESS != pfn(pszPrinterName,
                                      pszDir,
                                      (LPBYTE)&SplClientInfo1,
                                      1,
                                      *ppszSourceDir,
                                      &dwSourceDirSize,
                                      *ppszTargetDir,
                                      &dwTargetDirSize,
                                      COPYFILE_FLAG_SERVER_SPOOLER) )
#if DBG
                goto Cleanup;
#else
                leave;
#endif
            bRet = TRUE;
#if DBG
#else
        } except(1) {
        }
#endif
    } else {

        bRet = TRUE;
    }


Cleanup:
    if ( bInCS )
        LeaveSplSem();

    SplOutSem();

    FreeSplStr(pszDir);
    FreeSplStr(ppszFiles);
    FreeSplStr(pszModule);
    FreeSplStr(pszPrinterName);

    if ( hModule )
        FreeLibrary(hModule);

    if ( !bRet ) {

        FreeSplStr(*ppszSourceDir);
        FreeSplStr(*ppszTargetDir);
        *ppszSourceDir = *ppszTargetDir = NULL;
    }

    return bRet;
}


LPWSTR
BuildFilesCopiedAsAString(
    PINTERNAL_DRV_FILE  pInternalDriverFile,
    DWORD               dwCount
    )
/*++
    For files copied we log an event. This routine allocates memory and
    generates the file list as a comma separated string
--*/
{
    DWORD   dwIndex;
    SIZE_T  Size;
    LPWSTR  pszRet, psz2;
    LPCWSTR psz;

    //
    // Must have some files.
    //
    SPLASSERT( dwCount );

    for ( dwIndex = 0, Size = 0 ; dwIndex < dwCount ; ++dwIndex ) {

        //
        // Find the file name part
        //
        psz = FindFileName(pInternalDriverFile[dwIndex]. pFileName);

        if( psz ){

            //
            // Two characters for ", " separator. This also includes the
            // terminating NULL sice we count this for all files, but only
            // append ", " to the internal ones.
            //
            Size  += wcslen(psz) + 2;
        }
    }

    pszRet = AllocSplMem((DWORD)(Size * sizeof(WCHAR)));

    if ( !pszRet )
        return NULL;

    for ( dwIndex = 0, psz2 = pszRet ; dwIndex < dwCount ; ++dwIndex ) {

        //
        // Find the file name part
        //
        psz = FindFileName(pInternalDriverFile[dwIndex].pFileName );

        if( psz ){

            StringCchCopyEx(psz2, Size, psz, &psz2, &Size, 0);

            if ( dwIndex < dwCount - 1) {

                StringCchCopyEx(psz2, Size, L", ", &psz2, &Size, 0);
            }
        }
    }

    return pszRet;
}

BOOL
SplCopyNumberOfFiles(
    LPWSTR      pszPrinterName,
    LPWSTR     *ppszSourceFileNames,
    DWORD       dwCount,
    LPWSTR      pszTargetDir,
    LPBOOL      pbFilesAddedOrUpdated
    )
{
    BOOL        bRet=FALSE, bFilesMoved;
    LPWSTR      pszFiles;
    DWORD       dwIndex;
    LPWSTR      pszNewDir = NULL;
    LPWSTR      pszOldDir = NULL;
    BOOL        bFilesUpdated;
    INTERNAL_DRV_FILE    *pInternalDriverFiles = NULL;
    BOOL        bWaitForReboot = FALSE;

    *pbFilesAddedOrUpdated = FALSE;

    pInternalDriverFiles  = (INTERNAL_DRV_FILE *) AllocSplMem(dwCount*sizeof(INTERNAL_DRV_FILE));

    if ( !pInternalDriverFiles )
        return FALSE;

    for ( dwIndex = 0 ; dwIndex < dwCount ; ++dwIndex ) {

        pInternalDriverFiles[dwIndex].pFileName = ppszSourceFileNames[dwIndex];

        //
        // This is "fine" because this ultimately comes from the server registry,
        // so it is no worse than anything else in point and print. Which is a
        // known filed issue.
        //
        pInternalDriverFiles[dwIndex].hFileHandle = CreateFile(ppszSourceFileNames[dwIndex],
                                                              GENERIC_READ,
                                                              FILE_SHARE_READ,
                                                              NULL,
                                                              OPEN_EXISTING,
                                                              FILE_FLAG_SEQUENTIAL_SCAN,
                                                              NULL);

        if ( pInternalDriverFiles[dwIndex].hFileHandle == INVALID_HANDLE_VALUE )
            goto Cleanup;
    }

    if ( !DirectoryExists(pszTargetDir) &&
         !CreateDirectoryWithoutImpersonatingUser(pszTargetDir) )
        goto Cleanup;

    // Create the New Directory

    if (!BoolFromStatus(StrCatAlloc(&pszNewDir, pszTargetDir, L"\\New", NULL))) {
        goto Cleanup;
    }

    if (!DirectoryExists(pszNewDir) &&
        !CreateDirectoryWithoutImpersonatingUser(pszNewDir)) {

         // Failed to create New directory
         goto Cleanup;
    }

    // Create the Old Directory
    if (!BoolFromStatus(StrCatAlloc(&pszOldDir, pszTargetDir, L"\\Old", NULL))) {
        goto Cleanup;
    }

    if (!DirectoryExists(pszOldDir) &&
        !CreateDirectoryWithoutImpersonatingUser(pszOldDir)) {

         // Failed to create Old directory
         goto Cleanup;
    }


    EnterSplSem();

    bFilesUpdated = FALSE;

    for (dwIndex = 0 ; dwIndex < dwCount ; ++dwIndex) {

        if (!(bRet = UpdateFile(NULL,
                                pInternalDriverFiles[dwIndex].hFileHandle,
                                pInternalDriverFiles[dwIndex].pFileName,
                                0,
                                pszTargetDir,
                                APD_COPY_NEW_FILES,
                                TRUE,
                                &bFilesUpdated,
                                &bFilesMoved,
                                TRUE,
                                FALSE))) {

            //
            // Files could not be copied correctly
            //
            break;
        }

        if (bFilesUpdated) {
            *pbFilesAddedOrUpdated = TRUE;
        }
    }

    if (bRet && *pbFilesAddedOrUpdated) {

        bRet = MoveNewDriverRelatedFiles( pszNewDir,
                                          pszTargetDir,
                                          pszOldDir,
                                          pInternalDriverFiles,
                                          dwCount,
                                          NULL,
                                          NULL);
        //
        // Don't delete "New" directory if the files couldn't be moved in "Color" directory
        //
        bWaitForReboot = !bRet;

    }

    LeaveSplSem();

Cleanup:

    if ( pszNewDir ) {
        DeleteDirectoryRecursively(pszNewDir, bWaitForReboot);
        FreeSplMem(pszNewDir);
    }

    if ( pszOldDir ) {
        DeleteDirectoryRecursively(pszOldDir, FALSE);
        FreeSplMem(pszOldDir);
    }

    if ( *pbFilesAddedOrUpdated &&
         (pszFiles = BuildFilesCopiedAsAString(pInternalDriverFiles, dwCount)) ) {

            SplLogEvent(pLocalIniSpooler,
                        LOG_WARNING,
                        MSG_FILES_COPIED,
                        FALSE,
                        pszFiles,
                        pszPrinterName,
                        NULL);
            FreeSplMem(pszFiles);
    }

    if ( pInternalDriverFiles ) {

        while ( dwIndex-- )
            CloseHandle(pInternalDriverFiles[dwIndex].hFileHandle);
        FreeSplMem(pInternalDriverFiles);
    }

    return bRet;
}


BOOL
SplCopyFileEvent(
    HANDLE  hPrinter,
    LPWSTR  pszKey,
    DWORD   dwCopyFileEvent
    )
{
    BOOL        bRet = FALSE;
    DWORD       dwNeeded, dwType, dwLastError;
    LPWSTR      pszModule = NULL;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    HMODULE     hModule = NULL;
    BOOL        (*pfnSpoolerCopyFileEvent)(
                                LPWSTR  pszPrinterName,
                                LPWSTR  pszKey,
                                DWORD   dwCopyFileEvent
                                );

    SPLASSERT(pSpool->pIniSpooler->signature == ISP_SIGNATURE);

    dwLastError = SplGetPrinterDataEx(hPrinter,
                                      pszKey,
                                      L"Module",
                                      &dwType,
                                      NULL,
                                      0,
                                      &dwNeeded);

    //
    // If there is no module name there is no callback needed
    //
    if ( dwLastError == ERROR_FILE_NOT_FOUND )
        return TRUE;

    if ( dwLastError != ERROR_SUCCESS                   ||
         !(pszModule = (LPWSTR) AllocSplMem(dwNeeded))  ||
         SplGetPrinterDataEx(hPrinter,
                             pszKey,
                             L"Module",
                             &dwType,
                             (LPBYTE)pszModule,
                             dwNeeded,
                             &dwNeeded)                 ||
        dwType != REG_SZ ) {

        goto Cleanup;
    }

    if ( !(hModule = SplLoadLibraryTheCopyFileModule(hPrinter,
                                                     pszModule))        ||
         !((FARPROC)pfnSpoolerCopyFileEvent = GetProcAddress(hModule,
                                                             "SpoolerCopyFileEvent")) )
        goto Cleanup;

#if DBG
#else
        try {
#endif
            bRet = pfnSpoolerCopyFileEvent(pSpool->pName,
                                           pszKey,
                                           dwCopyFileEvent);

#if DBG
#else
        } except(1) {
        }
#endif

Cleanup:
    FreeSplStr(pszModule);

    if ( hModule )
        FreeLibrary(hModule);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\gdi.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    gdi.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#define NOMINMAX

#include <precomp.h>

#include "wingdip.h"


HANDLE
LocalCreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODE   pDevMode
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    PSPOOLIC pSpoolIC;

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
        return NULL;
    }

    pSpoolIC = (PSPOOLIC)AllocSplMem( sizeof( SPOOLIC ));

    if( !pSpoolIC ){
        return NULL;
    }

    pSpoolIC->signature = IC_SIGNATURE;
    pSpoolIC->pIniPrinter = pSpool->pIniPrinter;

    ++pSpoolIC->pIniPrinter->cRefIC;

    return (HANDLE)pSpoolIC;
}

BOOL
LocalPlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
)
{
    INT nBufferSize,iRet;
    PUNIVERSAL_FONT_ID pufi;
    LARGE_INTEGER TimeStamp;

    if( cOut == sizeof(INT) )
    {
        pufi = NULL;
        nBufferSize = 0;
    }
    else
    {
        pufi = (PUNIVERSAL_FONT_ID) (pOut + sizeof(INT));
        nBufferSize = (cOut - sizeof(INT)) / sizeof(UNIVERSAL_FONT_ID);
    }

    iRet = GdiQueryFonts( pufi, nBufferSize, &TimeStamp );

    if( iRet < 0 )
    {
        if (GetLastError() == ERROR_SUCCESS) {
            // Set a generic last error for GDI
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
        return FALSE;
    }
    else
    {
        *((INT*)pOut) = iRet;
        return TRUE;
    }
}

BOOL
LocalDeletePrinterIC(
    HANDLE  hPrinterIC
)
{
    PSPOOLIC pSpoolIC = (PSPOOLIC)hPrinterIC;

    if( !pSpoolIC || pSpoolIC->signature != IC_SIGNATURE ){
        SetLastError( ERROR_INVALID_HANDLE );
        DBGMSG( DBG_WARN,
                ( "LocalDeletePrinterIC: Invalid handle value %x\n",
                  hPrinterIC ));
        return FALSE;
    }

    --pSpoolIC->pIniPrinter->cRefIC;
    FreeSplMem( pSpoolIC );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\forms.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    forms.c

Abstract:

   This module provides all the public exported APIs relating to the
   Driver-based Spooler Apis for the Local Print Providor

   SplAddForm
   SplDeleteForm
   SplSetForm
   SplGetForm
   SplEnumForms

   Support Functions in forms.c - (Warning! Do Not Add to this list!!)


Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include <precomp.h>
#include <offsets.h>

VOID
BroadcastChangeForms(
    PINISPOOLER pIniSpooler);

DWORD
BroadcastChangeFormsThread(
    PINISPOOLER pIniSpooler);


typedef struct _REG_FORM_INFO {

    SIZEL   Size;
    RECTL   ImageableArea;

    DWORD   cFormOrder;
    DWORD   Flags;

} REG_FORM_INFO, *PREG_FORM_INFO;


// These figures are accurate to .001 mm
// There are 25.4 mm per inch

BUILTIN_FORM BuiltInForms[] = {
    0, IDS_FORM_LETTER,                215900, 279400, 0, 0, 215900, 279400,
    0, IDS_FORM_LETTER_SMALL,          215900, 279400, 0, 0, 215900, 279400,
    0, IDS_FORM_TABLOID,               279400, 431800, 0, 0, 279400, 431800,
    0, IDS_FORM_LEDGER,                431800, 279400, 0, 0, 431800, 279400,
    0, IDS_FORM_LEGAL,                 215900, 355600, 0, 0, 215900, 355600,
    0, IDS_FORM_STATEMENT,             139700, 215900, 0, 0, 139700, 215900,
    0, IDS_FORM_EXECUTIVE,             184150, 266700, 0, 0, 184150, 266700,
    0, IDS_FORM_A3,                    297000, 420000, 0, 0, 297000, 420000,
    0, IDS_FORM_A4,                    210000, 297000, 0, 0, 210000, 297000,
    0, IDS_FORM_A4_SMALL,              210000, 297000, 0, 0, 210000, 297000,
    0, IDS_FORM_A5,                    148000, 210000, 0, 0, 148000, 210000,
    0, IDS_FORM_B4,                    257000, 364000, 0, 0, 257000, 364000,
    0, IDS_FORM_B5,                    182000, 257000, 0, 0, 182000, 257000,
    0, IDS_FORM_FOLIO,                 215900, 330200, 0, 0, 215900, 330200,
    0, IDS_FORM_QUARTO,                215000, 275000, 0, 0, 215000, 275000,
    0, IDS_FORM_10X14,                 254000, 355600, 0, 0, 254000, 355600,
    0, IDS_FORM_11X17,                 279400, 431800, 0, 0, 279400, 431800,
    0, IDS_FORM_NOTE,                  215900, 279400, 0, 0, 215900, 279400,
    0, IDS_FORM_ENVELOPE9,             98425,  225425, 0, 0,  98425, 225425,
    0, IDS_FORM_ENVELOPE10,            104775, 241300, 0, 0, 104775, 241300,
    0, IDS_FORM_ENVELOPE11,            114300, 263525, 0, 0, 114300, 263525,
    0, IDS_FORM_ENVELOPE12,            120650, 279400, 0, 0, 120650, 279400,
    0, IDS_FORM_ENVELOPE14,            127000, 292100, 0, 0, 127000, 292100,
    0, IDS_FORM_ENVELOPE_CSIZE_SHEET,  431800, 558800, 0, 0, 431800, 558800,
    0, IDS_FORM_ENVELOPE_DSIZE_SHEET,  558800, 863600, 0, 0, 558800, 863600,
    0, IDS_FORM_ENVELOPE_ESIZE_SHEET,  863600,1117600, 0, 0, 863600,1117600,
    0, IDS_FORM_ENVELOPE_DL,           110000, 220000, 0, 0, 110000, 220000,
    0, IDS_FORM_ENVELOPE_C5,           162000, 229000, 0, 0, 162000, 229000,
    0, IDS_FORM_ENVELOPE_C3,           324000, 458000, 0, 0, 324000, 458000,
    0, IDS_FORM_ENVELOPE_C4,           229000, 324000, 0, 0, 229000, 324000,
    0, IDS_FORM_ENVELOPE_C6,           114000, 162000, 0, 0, 114000, 162000,
    0, IDS_FORM_ENVELOPE_C65,          114000, 229000, 0, 0, 114000, 229000,
    0, IDS_FORM_ENVELOPE_B4,           250000, 353000, 0, 0, 250000, 353000,
    0, IDS_FORM_ENVELOPE_B5,           176000, 250000, 0, 0, 176000, 250000,
    0, IDS_FORM_ENVELOPE_B6,           176000, 125000, 0, 0, 176000, 125000,
    0, IDS_FORM_ENVELOPE,              110000, 230000, 0, 0, 110000, 230000,
    0, IDS_FORM_ENVELOPE_MONARCH,       98425, 190500, 0, 0,  98425, 190500,
    0, IDS_FORM_SIX34_ENVELOPE,         92075, 165100, 0, 0,  92075, 165100,
    0, IDS_FORM_US_STD_FANFOLD,        377825, 279400, 0, 0, 377825, 279400,
    0, IDS_FORM_GMAN_STD_FANFOLD,      215900, 304800, 0, 0, 215900, 304800,
    0, IDS_FORM_GMAN_LEGAL_FANFOLD,    215900, 330200, 0, 0, 215900, 330200,

    // Predefined forms currently availble only in Win95.  Included here
    // for compatibility.

    0, IDS_FORM_ISO_B4,                250000, 353000, 0, 0, 250000, 353000,
    0, IDS_FORM_JAPANESE_POSTCARD,     100000, 148000, 0, 0, 100000, 148000,
    0, IDS_FORM_9X11,                  228600, 279400, 0, 0, 228600, 279400,
    0, IDS_FORM_10X11,                 254000, 279400, 0, 0, 254000, 279400,
    0, IDS_FORM_15X11,                 381000, 279400, 0, 0, 381000, 279400,
    0, IDS_FORM_ENV_INVITE,            220000, 220000, 0, 0, 220000, 220000,
    0, IDS_FORM_RESERVED_48,                1,      1, 0, 0,      1,      1,
    0, IDS_FORM_RESERVED_49,                1,      1, 0, 0,      1,      1,
    0, IDS_FORM_LETTER_EXTRA,          241300, 304800, 0, 0, 241300, 304800,

    0, IDS_FORM_LEGAL_EXTRA,           241300, 381000, 0, 0, 241300, 381000,
    0, IDS_FORM_TABLOID_EXTRA,         304800, 457200, 0, 0, 304800, 457200,
    0, IDS_FORM_A4_EXTRA,                   235458, 322326, 0, 0, 235458, 322326,
    0, IDS_FORM_LETTER_TRANSVERSE,          215900, 279400, 0, 0, 215900, 279400,
    0, IDS_FORM_A4_TRANSVERSE,              210000, 297000, 0, 0, 210000, 297000,
    0, IDS_FORM_LETTER_EXTRA_TRANSVERSE,    241300, 304800, 0, 0, 241300, 304800,
    0, IDS_FORM_A_PLUS,                     227000, 356000, 0, 0, 227000, 356000,
    0, IDS_FORM_B_PLUS,                     305000, 487000, 0, 0, 305000, 487000,
    0, IDS_FORM_LETTER_PLUS,                215900, 322326, 0, 0, 215900, 322326,
    0, IDS_FORM_A4_PLUS,                    210000, 330000, 0, 0, 210000, 330000,
    0, IDS_FORM_A5_TRANSVERSE,              148000, 210000, 0, 0, 148000, 210000,
    0, IDS_FORM_B5_TRANSVERSE,              182000, 257000, 0, 0, 182000, 257000,
    0, IDS_FORM_A3_EXTRA,                   322000, 445000, 0, 0, 322000, 445000,
    0, IDS_FORM_A5_EXTRA,                   174000, 235000, 0, 0, 174000, 235000,
    0, IDS_FORM_B5_EXTRA,                   201000, 276000, 0, 0, 201000, 276000,
    0, IDS_FORM_A2,                         420000, 594000, 0, 0, 420000, 594000,
    0, IDS_FORM_A3_TRANSVERSE,              297000, 420000, 0, 0, 297000, 420000,
    0, IDS_FORM_A3_EXTRA_TRANSVERSE,        322000, 445000, 0, 0, 322000, 445000,

    0, IDS_FORM_DBL_JAPANESE_POSTCARD,           200000, 148000, 0, 0, 200000, 148000,
    0, IDS_FORM_A6,                              105000, 148000, 0, 0, 105000, 148000,
    0, IDS_FORM_JENV_KAKU2,                      240000, 332000, 0, 0, 240000, 332000,
    0, IDS_FORM_JENV_KAKU3,                      216000, 277000, 0, 0, 216000, 277000,
    0, IDS_FORM_JENV_CHOU3,                      120000, 235000, 0, 0, 120000, 235000,
    0, IDS_FORM_JENV_CHOU4,                       90000, 205000, 0, 0,  90000, 205000,
    0, IDS_FORM_LETTER_ROTATED,                  279400, 215900, 0, 0, 279400, 215900,
    0, IDS_FORM_A3_ROTATED,                      420000, 297000, 0, 0, 420000, 297000,
    0, IDS_FORM_A4_ROTATED,                      297000, 210000, 0, 0, 297000, 210000,
    0, IDS_FORM_A5_ROTATED,                      210000, 148000, 0, 0, 210000, 148000,
    0, IDS_FORM_B4_JIS_ROTATED,                  364000, 257000, 0, 0, 364000, 257000,
    0, IDS_FORM_B5_JIS_ROTATED,                  257000, 182000, 0, 0, 257000, 182000,
    0, IDS_FORM_JAPANESE_POSTCARD_ROTATED,       148000, 100000, 0, 0, 148000, 100000,
    0, IDS_FORM_DBL_JAPANESE_POSTCARD_ROTATED,   148000, 200000, 0, 0, 148000, 200000,
    0, IDS_FORM_A6_ROTATED,                      148000, 105000, 0, 0, 148000, 105000,
    0, IDS_FORM_JENV_KAKU2_ROTATED,              332000, 240000, 0, 0, 332000, 240000,
    0, IDS_FORM_JENV_KAKU3_ROTATED,              277000, 216000, 0, 0, 277000, 216000,
    0, IDS_FORM_JENV_CHOU3_ROTATED,              235000, 120000, 0, 0, 235000, 120000,
    0, IDS_FORM_JENV_CHOU4_ROTATED,              205000,  90000, 0, 0, 205000,  90000,
    0, IDS_FORM_B6_JIS,                          128000, 182000, 0, 0, 128000, 182000,
    0, IDS_FORM_B6_JIS_ROTATED,                  182000, 128000, 0, 0, 182000, 128000,
    0, IDS_FORM_12X11,                           304932, 279521, 0, 0, 304932, 279521,
    0, IDS_FORM_JENV_YOU4,                       105000, 235000, 0, 0, 105000, 235000,
    0, IDS_FORM_JENV_YOU4_ROTATED,               235000, 105000, 0, 0, 235000, 105000,
    0, IDS_FORM_P16K,                            188000, 260000, 0, 0, 188000, 260000,
    0, IDS_FORM_P32K,                            130000, 184000, 0, 0, 130000, 184000,
    0, IDS_FORM_P32KBIG,                         140000, 203000, 0, 0, 140000, 203000,
    0, IDS_FORM_PENV_1,                          102000, 165000, 0, 0, 102000, 165000,
    0, IDS_FORM_PENV_2,                          102000, 176000, 0, 0, 102000, 176000,
    0, IDS_FORM_PENV_3,                          125000, 176000, 0, 0, 125000, 176000,
    0, IDS_FORM_PENV_4,                          110000, 208000, 0, 0, 110000, 208000,
    0, IDS_FORM_PENV_5,                          110000, 220000, 0, 0, 110000, 220000,
    0, IDS_FORM_PENV_6,                          120000, 230000, 0, 0, 120000, 230000,
    0, IDS_FORM_PENV_7,                          160000, 230000, 0, 0, 160000, 230000,
    0, IDS_FORM_PENV_8,                          120000, 309000, 0, 0, 120000, 309000,
    0, IDS_FORM_PENV_9,                          229000, 324000, 0, 0, 229000, 324000,
    0, IDS_FORM_PENV_10,                         324000, 458000, 0, 0, 324000, 458000,
    0, IDS_FORM_P16K_ROTATED,                    260000, 188000, 0, 0, 260000, 188000,
    0, IDS_FORM_P32K_ROTATED,                    184000, 130000, 0, 0, 184000, 130000,
    0, IDS_FORM_P32KBIG_ROTATED,                 203000, 140000, 0, 0, 203000, 140000,
    0, IDS_FORM_PENV_1_ROTATED,                  165000, 102000, 0, 0, 165000, 102000,
    0, IDS_FORM_PENV_2_ROTATED,                  176000, 102000, 0, 0, 176000, 102000,
    0, IDS_FORM_PENV_3_ROTATED,                  176000, 125000, 0, 0, 176000, 125000,
    0, IDS_FORM_PENV_4_ROTATED,                  208000, 110000, 0, 0, 208000, 110000,
    0, IDS_FORM_PENV_5_ROTATED,                  220000, 110000, 0, 0, 220000, 110000,
    0, IDS_FORM_PENV_6_ROTATED,                  230000, 120000, 0, 0, 230000, 120000,
    0, IDS_FORM_PENV_7_ROTATED,                  230000, 160000, 0, 0, 230000, 160000,
    0, IDS_FORM_PENV_8_ROTATED,                  309000, 120000, 0, 0, 309000, 120000,
    0, IDS_FORM_PENV_9_ROTATED,                  324000, 229000, 0, 0, 324000, 229000,
    0, IDS_FORM_PENV_10_ROTATED,                 458000, 324000, 0, 0, 458000, 324000,

    0, 0,                                   0,      0, 0, 0,      0,      0
};


PINIFORM
CreateFormEntry(
    LPWSTR  pFormName,
    SIZEL   Size,
    RECTL  *pImageableArea,
    DWORD   Type,
    DWORD   cFormOrder,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Creates a Form entry, and insert it into the right place in
    pIniSpooler.

Arguments:

    pFormName - Name of Form.

    Size - Size of form.

    pImageableArea - Area of form that the printer can print to.

    Type - Type of form (usually indicates if BUILTIN form).

    cFormOrder - Where the form should be inserted for user-defined forms,
        form order increases from beginning to end.

        If this value is -1, generate a new cFormOrder for this form.
        (Put it at the end.)

Return Value:

    pIniForm - Created form, NULL = error.

Notes:

    This routine ensures that forms are put in proper order so that
    EnumForms always returns them in the same order.  We do this by
    scanning the list and inserting the new form such that all forms
    with cFormOrder =< the current on are to the left of it.

    This routine updates pIniSpooler->pIniForm (inserts or appends) and
    updates pIniSpooler->cFormOrderMax if necessary.

    i.e., 0 0 0 2 3 4 6
               ^
           New 0 inserted here.
--*/

{
    DWORD       cb;
    PINIFORM    pIniForm, pForm;

    cb = sizeof(INIFORM) + wcslen(pFormName)*sizeof(WCHAR) + sizeof(WCHAR);

    if ( pIniForm = AllocSplMem(cb) ) {

        StringCbCopy((LPWSTR)(pIniForm+1), cb - sizeof(*pIniForm), pFormName);
        pIniForm->pName         = (LPWSTR)(pIniForm+1);
        pIniForm->pNext         = NULL;
        pIniForm->signature     = IFO_SIGNATURE;
        pIniForm->Size          = Size;
        pIniForm->ImageableArea = *pImageableArea;
        pIniForm->Type          = Type;
        pIniForm->cFormOrder    = cFormOrder;

        //
        // This code will insert the item in order, but will always never
        // insert before the first item.  The built-in forms are always
        // at the front so this is not an issue.
        //

        if ( pForm = pIniSpooler->pShared->pIniForm ) {

            for( ; pForm->pNext; pForm = pForm->pNext ){

                //
                // If the next form is greater than the one we want
                // to insert, then insert it right now.
                //
                if( pForm->pNext->cFormOrder > cFormOrder ){

                    //
                    // The current from should be inserted here.
                    //
                    break;
                }
            }

            //
            // Link it up.
            //
            pIniForm->pNext = pForm->pNext;
            pForm->pNext = pIniForm;

        } else {

            pIniSpooler->pShared->pIniForm = pIniForm;
        }

        //
        // If the added form has a higher count than the current global
        // count, update the global.
        //
        if( cFormOrder > pIniSpooler->cFormOrderMax ){
            pIniSpooler->cFormOrderMax = cFormOrder;
        }
    }

    return pIniForm;
}

BOOL
InitializeForms(
    PINISPOOLER pIniSpooler
)
{
    PBUILTIN_FORM pBuiltInForm;
    HKEY          hFormsKey;
    DWORD         cUserDefinedForms;
    WCHAR         FormName[MAX_PATH];
    WCHAR         FormBuffer[FORM_NAME_LEN+1];
    DWORD         cchFormName;
    REG_FORM_INFO RegFormInfo;
    DWORD         cbRegFormInfo;

    DWORD         dwError;
    BOOL          bUpgradeTried = FALSE;
    BOOL          bStatus = TRUE;

    WORD PrimaryLangId = PRIMARYLANGID( GetSystemDefaultLangID( ));

    //
    // For win32spl pIniSpoolers, the built-in forms are part of the cache
    // database. They will be stored under registry, together with user forms.
    // This solves the cross language synchronization of the cache.
    //
    if (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL)
    {
        for( pBuiltInForm = BuiltInForms; pBuiltInForm->NameId; pBuiltInForm++ ) {

            FormBuffer[0] = 0;

            LoadString( hInst,
                        pBuiltInForm->NameId,
                        FormBuffer,
                        FORM_NAME_LEN+1 );

            if ( CreateFormEntry( FormBuffer,
                             pBuiltInForm->Size,
                             &pBuiltInForm->ImageableArea,
                             FORM_BUILTIN,
                             0,
                             pIniSpooler ) == NULL)
            {
                bStatus = FALSE;
                break;
            }
        }
    }

    if ( bStatus )
    {
        //
        // Now see if there are any user-defined forms in the registry:
        //
        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           pIniSpooler->pszRegistryForms,
                           0,
                           KEY_READ | KEY_WRITE,
                           &hFormsKey) == NO_ERROR ) {

            for( cUserDefinedForms = 0; TRUE; ++cUserDefinedForms ){

                cchFormName = COUNTOF( FormName );
                cbRegFormInfo = sizeof( RegFormInfo );

                dwError = RegEnumValue( hFormsKey,
                                        cUserDefinedForms,
                                        (LPWSTR)FormName,
                                        &cchFormName,
                                        NULL,
                                        NULL,
                                        (LPBYTE)&RegFormInfo,
                                        &cbRegFormInfo );

                if( dwError ){
                    break;
                }

                //
                // We will attempt the upgrade only if
                //     we are on the first item,
                //     the size is incorrect, and
                //     we haven't tried upgrading once in the function before.
                //
                if ( CreateFormEntry( FormName,
                                 RegFormInfo.Size,
                                 &RegFormInfo.ImageableArea,
                                 RegFormInfo.Flags,
                                 RegFormInfo.cFormOrder,
                                 pIniSpooler ) == NULL )
                {
                    bStatus = FALSE;
                    break;
                }
            }

            RegCloseKey( hFormsKey );
            hFormsKey = NULL;
        }
    }


    return bStatus;
}


DWORD
GetFormSize(
    PINIFORM    pIniForm,
    DWORD       Level
)
{
    DWORD   cb;

    switch (Level) {

    case 1:

        cb=sizeof(FORM_INFO_1) +
           wcslen(pIniForm->pName)*sizeof(WCHAR) + sizeof(WCHAR);
        break;

    default:
        cb = 0;
        break;
    }

    return cb;
}

// We are being a bit naughty here as we are not sure exactly how much
// memory to allocate for the source strings. We will just assume that
// FORM_INFO_1 is the biggest structure around for the moment.

LPBYTE
CopyIniFormToForm(
    PINIFORM pIniForm,
    DWORD   Level,
    LPBYTE  pFormInfo,
    LPBYTE  pEnd
)
{
    LPWSTR   SourceStrings[sizeof(FORM_INFO_1)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    LPFORM_INFO_1 pFormInfo1=(LPFORM_INFO_1)pFormInfo;
    DWORD   *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = FormInfo1Strings;
        break;

    default:
        return pEnd;
    }

    switch (Level) {

    case 1:

        *pSourceStrings++=pIniForm->pName;

        pEnd = PackStrings(SourceStrings, pFormInfo, pOffsets, pEnd);

        pFormInfo1->Flags |= pIniForm->Type;
        pFormInfo1->Size = pIniForm->Size;
        pFormInfo1->ImageableArea = pIniForm->ImageableArea;

        break;

    default:
        return pEnd;
    }

    return pEnd;
}

/* Checks for logically impossible sizes.
 */
BOOL
ValidateForm(
    LPBYTE pForm
)
{
    LPFORM_INFO_1 pFormInfo = (LPFORM_INFO_1)pForm;
    DWORD    Error = NO_ERROR;

    if( !pForm ||
        (pFormInfo->Flags != FORM_USER &&
         pFormInfo->Flags != FORM_BUILTIN &&
         pFormInfo->Flags != FORM_PRINTER)) {

        Error = ERROR_INVALID_PARAMETER;

    } else

      /* Make sure name isn't longer than GDI DEVMODE specifies:
       */
    if( ( !pFormInfo->pName ) ||
        ( !pFormInfo->pName[0] ) ||
        ( wcslen( pFormInfo->pName ) > FORM_NAME_LEN )){

        Error = ERROR_INVALID_FORM_NAME;

    } else
    if( ( pFormInfo->Size.cx <= 0 )     /* Check for negative width */
        ||( pFormInfo->Size.cy <= 0 )     /* ... and height           */

      /* Check for strange imageable area:
       */
        || (pFormInfo->ImageableArea.right < 0)
        || (pFormInfo->ImageableArea.left < 0)
        || (pFormInfo->ImageableArea.bottom < 0)
        || (pFormInfo->ImageableArea.top < 0)
        ||( pFormInfo->ImageableArea.right <= pFormInfo->ImageableArea.left )
        ||( pFormInfo->ImageableArea.bottom <= pFormInfo->ImageableArea.top ) ) {

        Error = ERROR_INVALID_FORM_SIZE;
    }

    if( Error != NO_ERROR ) {

        SetLastError(Error);
        return FALSE;
    }

    return TRUE;
}


BOOL
SplAddForm(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
)
{
    LPFORM_INFO_1 pFormInfo;
    PINIFORM      pIniForm;
    HKEY          hFormsKey;
    REG_FORM_INFO RegFormInfo;
    DWORD         Status;
    PSPOOL        pSpool = (PSPOOL)hPrinter;
    PINISPOOLER   pIniSpooler;
    HANDLE        hToken = INVALID_HANDLE_VALUE;


    if (!ValidateSpoolHandle( pSpool, 0 )) {
        return(FALSE);
    }

    pIniSpooler = pSpool->pIniSpooler;

    if (Level != 1) {
        return FALSE;
    }

    if (!ValidateForm(pForm)) {

        /* ValidateForm sets the appropriate error code:
         */
        return FALSE;
    }


    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    pFormInfo = (LPFORM_INFO_1)pForm;

    pIniForm = FindForm(pFormInfo->pName, pIniSpooler);

    /* If there's already a form by this name, don't go on:
     */
    if (pIniForm) {

        /* Is there a better error code than this?? */
        SetLastError(ERROR_FILE_EXISTS);
        LeaveSplSem();
        return FALSE;
    }

    //
    //  Revert to LocalSystem, since a regular user cannot do this CreateKey call.
    //

    hToken = RevertToPrinterSelf();

    Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryForms, 0, NULL, 0,
                            KEY_WRITE, NULL, &hFormsKey, NULL);

    if (Status == NO_ERROR) {

        RegFormInfo.Size = pFormInfo->Size;
        RegFormInfo.ImageableArea = pFormInfo->ImageableArea;
        RegFormInfo.cFormOrder = pIniSpooler->cFormOrderMax + 1;
        RegFormInfo.Flags = pFormInfo->Flags;

        Status = RegSetValueEx( hFormsKey, pFormInfo->pName, 0, REG_BINARY,
                                (LPBYTE)&RegFormInfo, sizeof RegFormInfo );

        RegCloseKey( hFormsKey );

        if ( Status == NO_ERROR ) {

            CreateFormEntry( pFormInfo->pName,
                             pFormInfo->Size,
                             &pFormInfo->ImageableArea,
                             RegFormInfo.Flags,
                             RegFormInfo.cFormOrder,
                             pIniSpooler );

            SetPrinterChange( NULL,
                              NULL,
                              NULL,
                              PRINTER_CHANGE_ADD_FORM,
                              pIniSpooler );

            BroadcastChangeForms( pIniSpooler );
        }
    }

    ImpersonatePrinterClient( hToken );

    RunForEachSpooler( NULL, DsUpdateAllDriverKeys);

    LeaveSplSem();

    if ( Status != NO_ERROR )
        SetLastError( Status );

    SplLogEvent( pIniSpooler,
                 LOG_INFO,
                 MSG_FORM_ADDED,
                 FALSE,
                 pFormInfo->pName,
                 NULL );


    return ( Status == NO_ERROR );
}

BOOL
DeleteFormEntry(
    PINIFORM pIniForm,
    PINISPOOLER pIniSpooler
)
{
    PINIFORM *ppCurForm;

    ppCurForm = &pIniSpooler->pShared->pIniForm;

    while (*ppCurForm != pIniForm)
        ppCurForm = &(*ppCurForm)->pNext;

    *ppCurForm = (*ppCurForm)->pNext;

    FreeSplMem(pIniForm);

    return TRUE;

}

BOOL
SplDeleteForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName
)
{
    HKEY     hFormsKey;
    DWORD    Status;
    PINIFORM pIniForm;
    PSPOOL   pSpool = (PSPOOL) hPrinter;
    HANDLE   hToken = INVALID_HANDLE_VALUE;
    PINISPOOLER pIniSpooler;


    if (!ValidateSpoolHandle( pSpool, 0 )) {
        return(FALSE);
    }

    pIniSpooler = pSpool->pIniSpooler;

    if (!pFormName) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();


    pIniForm = FindForm(pFormName, pIniSpooler);

    //
    // Built-in forms cannot be deleted for local iniSpooler(s).
    //
    if (!pIniForm || ((pIniForm->Type == FORM_BUILTIN) && 
        pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL)) {

        SetLastError( pIniForm ?
                          ERROR_INVALID_PARAMETER :
                          ERROR_INVALID_FORM_NAME );
        LeaveSplSem();
        return FALSE;
    }

    hToken = RevertToPrinterSelf();

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryForms, 0,
                          KEY_WRITE, &hFormsKey);

    if (Status == NO_ERROR) {

        Status = RegDeleteValue(hFormsKey, pFormName);

        RegCloseKey(hFormsKey);

        if (Status == NO_ERROR) {

            DeleteFormEntry(pIniForm , pIniSpooler );

            SetPrinterChange(NULL,
                             NULL,
                             NULL,
                             PRINTER_CHANGE_DELETE_FORM,
                             pIniSpooler);

            BroadcastChangeForms(pIniSpooler);

            RunForEachSpooler( NULL, DsUpdateAllDriverKeys);
        }
    }

    if(hToken != INVALID_HANDLE_VALUE)
    {
        ImpersonatePrinterClient( hToken );
    }

    LeaveSplSem();

    if (Status != NO_ERROR)
        SetLastError(Status);

    SplLogEvent( pIniSpooler,
                 LOG_INFO,
                 MSG_FORM_DELETED,
                 FALSE,
                 pFormName,
                 NULL );

    return (Status == NO_ERROR);
}

BOOL
SplGetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PINIFORM    pIniForm;
    DWORD       cb;
    LPBYTE      pEnd;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    PINISPOOLER pIniSpooler;

    if (!ValidateSpoolHandle(pSpool, 0 )) {
        return(FALSE);
    }

    if (!pSpool->pIniPrinter ||
        !pSpool->pIniSpooler ||
        (pSpool->pIniPrinter->signature != IP_SIGNATURE)) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

   EnterSplSem();

    SPLASSERT(pSpool->pIniSpooler->signature == ISP_SIGNATURE);

    pIniSpooler = pSpool->pIniSpooler;


    cb=0;

    if (pIniForm=FindForm(pFormName, pIniSpooler)) {

        cb=GetFormSize(pIniForm, Level);

        *pcbNeeded=cb;

        if (cb > cbBuf) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
           LeaveSplSem();
            SplOutSem();
            return FALSE;
        }

        pEnd=pForm+cbBuf;

        CopyIniFormToForm(pIniForm, Level, pForm, pEnd);
    } else {
        SetLastError( ERROR_INVALID_FORM_NAME );
    }

   LeaveSplSem();
    SplOutSem();

    return !!pIniForm;
}

BOOL
SplSetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
)
{
    HKEY     hFormsKey;
    DWORD    Status;
    PINIFORM pIniForm;
    LPFORM_INFO_1 pFormInfo;
    REG_FORM_INFO RegFormInfo;
    PINISPOOLER pIniSpooler;
    PSPOOL   pSpool = (PSPOOL)hPrinter;


    //
    // Validate this Printer Handle
    // Disallow Mask: PRINTER_HANDLE_SERVER
    //

    if (!ValidateSpoolHandle( pSpool , 0 )) {
        return(FALSE);
    }

    pIniSpooler = pSpool->pIniSpooler;

    if (Level != 1) {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (!ValidateForm(pForm)) {

        /* ValidateForm sets the appropriate error code:
         */
        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();


    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    pFormInfo = (LPFORM_INFO_1)pForm;

    pIniForm = FindForm(pFormName, pIniSpooler);

    if (!pIniForm || (pIniForm->Type == FORM_BUILTIN) || (pFormInfo->Flags & FORM_BUILTIN)) {

        SetLastError( pIniForm ?
                          ERROR_INVALID_PARAMETER :
                          ERROR_INVALID_FORM_NAME );
        LeaveSplSem();
        return FALSE;
    }

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryForms, 0,
                          KEY_WRITE, &hFormsKey);

    if (Status == NO_ERROR) {

        RegFormInfo.Size = pFormInfo->Size;
        RegFormInfo.ImageableArea = pFormInfo->ImageableArea;
        RegFormInfo.Flags = pFormInfo->Flags;

        Status = RegSetValueEx(hFormsKey, pFormInfo->pName, 0, REG_BINARY,
                               (LPBYTE)&RegFormInfo, sizeof RegFormInfo);

        RegCloseKey(hFormsKey);
    }

    if (Status == NO_ERROR) {

        pIniForm->Size = pFormInfo->Size;
        pIniForm->ImageableArea = pFormInfo->ImageableArea;
        pIniForm->Type = pFormInfo->Flags;

        SetPrinterChange(NULL,
                         NULL,
                         NULL,
                         PRINTER_CHANGE_SET_FORM,
                         pIniSpooler);

        BroadcastChangeForms(pIniSpooler);
    }

    LeaveSplSem();

    return (Status == NO_ERROR);
}


BOOL
SplEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    PINIFORM    pIniForm;
    DWORD       cb;
    LPBYTE      pEnd;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    PINISPOOLER pIniSpooler;

    if (!ValidateSpoolHandle(pSpool, 0 )) {
        return FALSE;
    }

    *pcReturned=0;

   EnterSplSem();

    pIniSpooler = pSpool->pIniSpooler;

    SPLASSERT( ( pIniSpooler != NULL ) &&
               ( pIniSpooler->signature == ISP_SIGNATURE ));


    cb=0;
    pIniForm=pIniSpooler->pShared->pIniForm;

    while (pIniForm) {
        cb+=GetFormSize(pIniForm, Level);
        pIniForm=pIniForm->pNext;
    }

    *pcbNeeded=cb;

    if (cb > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
       LeaveSplSem();
        SplOutSem();
        return FALSE;
    }

    pIniForm=pIniSpooler->pShared->pIniForm;
    pEnd=pForm+cbBuf;
    while (pIniForm) {
        pEnd = CopyIniFormToForm(pIniForm, Level, pForm, pEnd);
        switch (Level) {
        case 1:
            pForm+=sizeof(FORM_INFO_1);
            break;
        }
        pIniForm=pIniForm->pNext;
        (*pcReturned)++;
    }


   LeaveSplSem();
    SplOutSem();
    return TRUE;
}

DWORD dwBroadcastChangeFormsThread = 0;

VOID
BroadcastChangeForms(
    PINISPOOLER pIniSpooler)

/*++

Routine Description:

    Notify all applications that their devmode may have changed (when
    a form is changed).

Arguments:

Return Value:

--*/

{
    PINIPRINTER pIniPrinter;
    WCHAR       PrinterName[ MAX_UNC_PRINTER_NAME ];
    UINT        MachineNameLen;

    SplInSem();

    if( !( pIniSpooler->SpoolerFlags & SPL_FORMS_CHANGE )) {
        return;
    }

    INCSPOOLERREF( pIniSpooler );

    ++dwBroadcastChangeFormsThread;

    if ( pIniSpooler != pLocalIniSpooler ) {

        //
        // For Non Local Printers prepend the Machine Name
        //
        StringCchPrintf(PrinterName, COUNTOF(PrinterName), L"%ws\\", pIniSpooler->pMachineName );

    } else {

        PrinterName[0] = L'\0';
    }

    MachineNameLen = wcslen( PrinterName ) ;

    for( pIniPrinter = pIniSpooler->pIniPrinter;
         pIniPrinter;
         pIniPrinter = pIniPrinter->pNext ) {

        StringCchCopy(&PrinterName[MachineNameLen], COUNTOF(PrinterName) - MachineNameLen, pIniPrinter->pName);

        //
        // Stress testing has shown that SendNotifyMessage can take
        // a long time to return, so leave critical section.
        //
        INCPRINTERREF( pIniPrinter );

        LeaveSplSem();
        SplOutSem();

        SendNotifyMessage(HWND_BROADCAST,
                          WM_DEVMODECHANGE,
                          0,
                          (LPARAM)PrinterName);
        EnterSplSem();

        DECPRINTERREF( pIniPrinter );
    }

    DECSPOOLERREF( pIniSpooler );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\getprn.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    getprn.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    management for the Local Print Providor

    SplGetPrinter
    LocalEnumPrinters

Author:

    Dave Snipp (DaveSn) 15-Mar-1991
    Steve Wilson (SWilson) - Dec 1996 Added GetPrinter Level 7

Revision History:

--*/
#define NOMINMAX

#include <precomp.h>
#include <offsets.h>


WCHAR *szNull = L"";
WCHAR *szPrintProvidorName = L"Windows NT Local Print Providor";
WCHAR *szPrintProvidorDescription=L"Windows NT Local Printers";
WCHAR *szPrintProvidorComment=L"Locally connected Printers";

WCHAR *gszDrvConvert = L",DrvConvert";

#define Nulwcslen(psz)  ((psz) ? wcslen(psz)*sizeof(WCHAR)+sizeof(WCHAR) : 0)

#define PRINTER_STATUS_INTERNAL 0
#define PRINTER_STATUS_EXTERNAL 1

DWORD SettablePrinterStatusMappings[] = {

//  INTERNAL:                   EXTERNAL:

    PRINTER_OFFLINE,            PRINTER_STATUS_OFFLINE,
    PRINTER_PAPEROUT,           PRINTER_STATUS_PAPER_OUT,
    PRINTER_PAPER_JAM,          PRINTER_STATUS_PAPER_JAM,
    PRINTER_MANUAL_FEED,        PRINTER_STATUS_MANUAL_FEED,
    PRINTER_PAPER_PROBLEM,      PRINTER_STATUS_PAPER_PROBLEM,
    PRINTER_IO_ACTIVE,          PRINTER_STATUS_IO_ACTIVE,
    PRINTER_BUSY,               PRINTER_STATUS_BUSY,
    PRINTER_PRINTING,           PRINTER_STATUS_PRINTING,
    PRINTER_OUTPUT_BIN_FULL,    PRINTER_STATUS_OUTPUT_BIN_FULL,
    PRINTER_NOT_AVAILABLE,      PRINTER_STATUS_NOT_AVAILABLE,
    PRINTER_WAITING,            PRINTER_STATUS_WAITING,
    PRINTER_PROCESSING,         PRINTER_STATUS_PROCESSING,
    PRINTER_INITIALIZING,       PRINTER_STATUS_INITIALIZING,
    PRINTER_WARMING_UP,         PRINTER_STATUS_WARMING_UP,
    PRINTER_TONER_LOW,          PRINTER_STATUS_TONER_LOW,
    PRINTER_NO_TONER,           PRINTER_STATUS_NO_TONER,
    PRINTER_PAGE_PUNT,          PRINTER_STATUS_PAGE_PUNT,
    PRINTER_USER_INTERVENTION,  PRINTER_STATUS_USER_INTERVENTION,
    PRINTER_OUT_OF_MEMORY,      PRINTER_STATUS_OUT_OF_MEMORY,
    PRINTER_DOOR_OPEN,          PRINTER_STATUS_DOOR_OPEN,
    PRINTER_SERVER_UNKNOWN,     PRINTER_STATUS_SERVER_UNKNOWN,
    PRINTER_POWER_SAVE,         PRINTER_STATUS_POWER_SAVE,
    0,                          0
};

DWORD ReadablePrinterStatusMappings[] = {

//  INTERNAL:               EXTERNAL:

    PRINTER_PAUSED,             PRINTER_STATUS_PAUSED,
    PRINTER_PENDING_DELETION,   PRINTER_STATUS_PENDING_DELETION,

    PRINTER_OFFLINE,            PRINTER_STATUS_OFFLINE,
    PRINTER_PAPEROUT,           PRINTER_STATUS_PAPER_OUT,
    PRINTER_PAPER_JAM,          PRINTER_STATUS_PAPER_JAM,
    PRINTER_MANUAL_FEED,        PRINTER_STATUS_MANUAL_FEED,
    PRINTER_PAPER_PROBLEM,      PRINTER_STATUS_PAPER_PROBLEM,
    PRINTER_IO_ACTIVE,          PRINTER_STATUS_IO_ACTIVE,
    PRINTER_BUSY,               PRINTER_STATUS_BUSY,
    PRINTER_PRINTING,           PRINTER_STATUS_PRINTING,
    PRINTER_OUTPUT_BIN_FULL,    PRINTER_STATUS_OUTPUT_BIN_FULL,
    PRINTER_NOT_AVAILABLE,      PRINTER_STATUS_NOT_AVAILABLE,
    PRINTER_WAITING,            PRINTER_STATUS_WAITING,
    PRINTER_PROCESSING,         PRINTER_STATUS_PROCESSING,
    PRINTER_INITIALIZING,       PRINTER_STATUS_INITIALIZING,
    PRINTER_WARMING_UP,         PRINTER_STATUS_WARMING_UP,
    PRINTER_TONER_LOW,          PRINTER_STATUS_TONER_LOW,
    PRINTER_NO_TONER,           PRINTER_STATUS_NO_TONER,
    PRINTER_PAGE_PUNT,          PRINTER_STATUS_PAGE_PUNT,
    PRINTER_USER_INTERVENTION,  PRINTER_STATUS_USER_INTERVENTION,
    PRINTER_OUT_OF_MEMORY,      PRINTER_STATUS_OUT_OF_MEMORY,
    PRINTER_DOOR_OPEN,          PRINTER_STATUS_DOOR_OPEN,
    PRINTER_SERVER_UNKNOWN,     PRINTER_STATUS_SERVER_UNKNOWN,
    PRINTER_POWER_SAVE,         PRINTER_STATUS_POWER_SAVE,

    0,                          0
};

DWORD
MapPrinterStatus(
    DWORD Type,
    DWORD SourceStatus)
{
    DWORD  TargetStatus;
    PDWORD pMappings;
    INT   MapFrom;
    INT   MapTo;

    if (Type == MAP_READABLE) {

        MapFrom = PRINTER_STATUS_INTERNAL;
        MapTo   = PRINTER_STATUS_EXTERNAL;

        pMappings = ReadablePrinterStatusMappings;

    } else {

        MapFrom = PRINTER_STATUS_EXTERNAL;
        MapTo   = PRINTER_STATUS_INTERNAL;

        pMappings = SettablePrinterStatusMappings;
    }

    TargetStatus = 0;

    while(*pMappings) {

        if (SourceStatus & pMappings[MapFrom])
            TargetStatus |= pMappings[MapTo];

        pMappings += 2;
    }

    return TargetStatus;
}

DWORD
GetIniNetPrintSize(
    PININETPRINT pIniNetPrint
)
{
    return sizeof(PRINTER_INFO_1) +
           wcslen(pIniNetPrint->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
           Nulwcslen(pIniNetPrint->pDescription) +
           Nulwcslen(pIniNetPrint->pComment);
}

DWORD
GetPrinterSize(
    PINIPRINTER     pIniPrinter,
    DWORD           Level,
    DWORD           Flags,
    LPWSTR          lpRemote,
    LPDEVMODE       pDevMode
)
{
    DWORD   cb;
    DWORD   cbNeeded;
    LPWSTR  pszPorts;

    switch (Level) {

    case STRESSINFOLEVEL:
        cb = sizeof(PRINTER_INFO_STRESS) +
             wcslen(pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR);

        if( lpRemote ){

            //
            // Allocate space for ServerName "\\foobar" and the prefix
            // for PrinterName "\\foobar\."  The rest of PrinterName
            // is allocated above.
            //
            // ServerName + NULL + ServerName +'\'
            //
            cb += 2 * wcslen(lpRemote) * sizeof(WCHAR) +
                  sizeof(WCHAR) + sizeof(WCHAR);
        }
        break;

    case 4:
        cb = sizeof(PRINTER_INFO_4) +
            wcslen(pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR);

        if( lpRemote ){
            cb += 2 * wcslen(lpRemote) * sizeof(WCHAR) +
                  sizeof(WCHAR) + sizeof(WCHAR);
        }
        break;

    case 1:

        //
        // Local:
        //
        // "pName,pDriver,pLocation"
        // "pName"
        // "pComment"
        //
        // Remote:
        //
        // "pMachine\pName,pDriver,<pLocation>"
        // "pMachine\pName"
        // "pComment"
        //

        //
        // Mandatory items, plus NULLs for _all_ strings.
        //     2 * PrinterName +
        //     DriverName +
        //     2 commas, 3 NULL terminators.
        //
        cb = 2 * wcslen( pIniPrinter->pName ) +
             wcslen( pIniPrinter->pIniDriver->pName ) +
             2 + 3;
        //
        // Add items that may be NULL.
        //

        if( pIniPrinter->pLocation ){
            cb += wcslen( pIniPrinter->pLocation );
        }

        if( pIniPrinter->pComment ){
            cb += wcslen( pIniPrinter->pComment );
        }

        //
        // Remote case adds prefix.
        //    2 * ( MachineName + BackSlash )
        //
        if( lpRemote ){
            cb += 2 * ( wcslen( lpRemote ) + 1 );
        }

        //
        // cb was a char count, convert to byte count.
        //
        cb *= sizeof( WCHAR );
        cb += sizeof( PRINTER_INFO_1 );

        break;

    case 2:

        cbNeeded = 0;
        GetPrinterPorts(pIniPrinter, 0, &cbNeeded);

        cb = sizeof(PRINTER_INFO_2) +
             wcslen(pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nulwcslen(pIniPrinter->pShareName) +
             cbNeeded +
             wcslen(pIniPrinter->pIniDriver->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nulwcslen(pIniPrinter->pComment) +
             Nulwcslen(pIniPrinter->pLocation) +
             Nulwcslen(pIniPrinter->pSepFile) +
             wcslen(pIniPrinter->pIniPrintProc->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nulwcslen(pIniPrinter->pDatatype) +
             Nulwcslen(pIniPrinter->pParameters);

        if( lpRemote ){
            cb += 2 * wcslen(lpRemote) * sizeof(WCHAR) +
                  sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pDevMode) {

            cb += pDevMode->dmSize + pDevMode->dmDriverExtra;
            cb = (cb + sizeof(ULONG_PTR)-1) & ~(sizeof(ULONG_PTR)-1);
        }

        if (pIniPrinter->pSecurityDescriptor) {

            cb += GetSecurityDescriptorLength(pIniPrinter->pSecurityDescriptor);
            cb = (cb + sizeof(ULONG_PTR)-1) & ~(sizeof(ULONG_PTR)-1);
        }

        break;

    case 3:

        cb = sizeof(PRINTER_INFO_3);
        cb += GetSecurityDescriptorLength(pIniPrinter->pSecurityDescriptor);
        cb = (cb + sizeof(ULONG_PTR)-1) & ~(sizeof(ULONG_PTR)-1);

        break;

    case 5:

        cbNeeded = 0;
        GetPrinterPorts(pIniPrinter, 0, &cbNeeded);

        cb = sizeof(PRINTER_INFO_5) +
             wcslen(pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             cbNeeded;

        //
        // Allocate space for just the PrinterName prefix:
        // "\\server\."
        //
        if( lpRemote ){
            cb += wcslen(lpRemote) * sizeof(WCHAR) +
                  sizeof(WCHAR);
        }
        break;

    case 6:
        cb = sizeof(PRINTER_INFO_6);
        break;

    case 7:
        cb = sizeof(PRINTER_INFO_7);
        cb += pIniPrinter->pszObjectGUID ? (wcslen(pIniPrinter->pszObjectGUID) + 1)*sizeof(WCHAR) : 0;
        break;

    default:
        cb = 0;
        break;
    }

    return cb;
}

LPBYTE
CopyIniNetPrintToPrinter(
    PININETPRINT pIniNetPrint,
    LPBYTE  pPrinterInfo,
    LPBYTE  pEnd
)
{
    LPWSTR   SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    PPRINTER_INFO_1 pPrinterInfo1 = (PPRINTER_INFO_1)pPrinterInfo;

    *pSourceStrings++=pIniNetPrint->pDescription;
    *pSourceStrings++=pIniNetPrint->pName;
    *pSourceStrings++=pIniNetPrint->pComment;

    pEnd = PackStrings(SourceStrings, pPrinterInfo, PrinterInfo1Strings, pEnd);

    pPrinterInfo1->Flags = PRINTER_ENUM_NAME;

    return pEnd;
}


/* CopyIniPrinterSecurityDescriptor
 *
 * Copies the security descriptor for the printer to the buffer provided
 * on a call to GetPrinter.  The portions of the security descriptor which
 * will be copied are determined by the accesses granted when the printer
 * was opened.  If it was opened with both READ_CONTROL and ACCESS_SYSTEM_SECURITY,
 * all of the security descriptor will be made available.  Otherwise a
 * partial descriptor is built containing those portions to which the caller
 * has access.
 *
 * Parameters
 *
 *     pIniPrinter - Spooler's private structure for this printer.
 *
 *     Level - Should be 2 or 3.  Any other will cause AV.
 *
 *     pPrinterInfo - Pointer to the buffer to receive the PRINTER_INFO_*
 *         structure.  The pSecurityDescriptor field will be filled in with
 *         a pointer to the security descriptor.
 *
 *     pEnd - Current position in the buffer to receive the data.
 *         This will be decremented to point to the next free bit of the
 *         buffer and will be returned.
 *
 *     GrantedAccess - An access mask used to determine how much of the
 *         security descriptor the caller has access to.
 *
 * Returns
 *
 *     Updated position in the buffer.
 *
 *     NULL if an error occurred copying the security descriptor.
 *     It is assumed that no other errors are possible.
 *
 */
LPBYTE
CopyIniPrinterSecurityDescriptor(
    PINIPRINTER pIniPrinter,
    DWORD       Level,
    LPBYTE      pPrinterInfo,
    LPBYTE      pEnd,
    ACCESS_MASK GrantedAccess
)
{
    PSECURITY_DESCRIPTOR pPartialSecurityDescriptor = NULL;
    DWORD                SecurityDescriptorLength = 0;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PSECURITY_DESCRIPTOR *ppSecurityDescriptorCopy;
    BOOL                 ErrorOccurred = FALSE;

    if(!(AreAllAccessesGranted(GrantedAccess,
                               READ_CONTROL | ACCESS_SYSTEM_SECURITY)))
    {
        /* Caller doesn't have full access, so we'll have to build
         * a partial descriptor:
         */
        if(!BuildPartialSecurityDescriptor(GrantedAccess,
                                           pIniPrinter->pSecurityDescriptor,
                                           &pPartialSecurityDescriptor,
                                           &SecurityDescriptorLength))
        {
            ErrorOccurred = TRUE;
        }
        else
        {
            if (pPartialSecurityDescriptor)
            {
                pSecurityDescriptor = pPartialSecurityDescriptor;
            }
            else
            {
                ErrorOccurred = TRUE;
            }
        }
    }
    else
    {
        pSecurityDescriptor = pIniPrinter->pSecurityDescriptor;

        SecurityDescriptorLength = GetSecurityDescriptorLength(pSecurityDescriptor);
    }

    if (!ErrorOccurred)
    {
        pEnd -= SecurityDescriptorLength;
        pEnd = (PBYTE) ALIGN_PTR_DOWN(pEnd);

        switch( Level )
        {
        case 2:
            ppSecurityDescriptorCopy =
                &((LPPRINTER_INFO_2)pPrinterInfo)->pSecurityDescriptor;
            break;

        case 3:
            ppSecurityDescriptorCopy =
                &((LPPRINTER_INFO_3)pPrinterInfo)->pSecurityDescriptor;
            break;

        default:

            ErrorOccurred = TRUE;

            /* This should never happen */
            DBGMSG( DBG_ERROR, ("Invalid level %d in CopyIniPrinterSecurityDescriptor\n", Level ));

            break;
        }

        if (!ErrorOccurred) {

            // Copy the descriptor into the buffer that will be returned:

            *ppSecurityDescriptorCopy = (PSECURITY_DESCRIPTOR)pEnd;

            //
            // This is OK because GetPrinterSize has validated that the buffer
            // is big enough.
            //
            memcpy(*ppSecurityDescriptorCopy, pSecurityDescriptor, SecurityDescriptorLength);
        }
    }

    if (pPartialSecurityDescriptor)
    {
        FreeSplMem(pPartialSecurityDescriptor);
    }

    if (ErrorOccurred)
    {
        pEnd = NULL;
    }

    return pEnd;
}



/* CopyIniPrinterToPrinter
 *
 * Copies the spooler's internal printer data to the caller's buffer,
 * depending on the level of information requested.
 *
 * Parameters
 *
 *     pIniPrinter - A pointer to the spooler's internal data structure
 *         for the printer concerned.
 *
 *     Level - Level of information requested (1, 2 or 3).  Any level
 *         other than those supported will cause the routine to return
 *         immediately.
 *
 *     pPrinterInfo - Pointer to the buffer to receive the PRINTER_INFO_*
 *         structure.
 *
 *     pEnd - Current position in the buffer to receive the data.
 *         This will be decremented to point to the next free bit of the
 *         buffer and will be returned.
 *
 *     pSecondPrinter - If the printer has a port which is being controlled
 *         by a monitor, this parameter points to information retrieved
 *         about a network printer.  This allows us, e.g., to return
 *         the number of jobs on the printer that the output of the
 *         printer is currently being directed to.
 *
 *     Remote - Indicates whether the caller is remote.  If so we have to
 *         include the machine name in the printer name returned.
 *
 *     CopySecurityDescriptor - Indicates whether the security descriptor
 *         should be copied.  The security descriptor should not be copied
 *         on EnumPrinters calls, because this API requires
 *         SERVER_ACCESS_ENUMERATE access, and we'd have to do an access
 *         check on every printer enumerated to determine how much of the
 *         security descriptor could be copied.  This would be costly,
 *         and the caller would probably not need the information anyway.
 *
 *     GrantedAccess - An access mask used to determine how much of the
 *         security descriptor the caller has access to.
 *
 *
 * Returns
 *
 *     A pointer to the point in the buffer reached after the requested
 *         data has been copied.
 *
 *     If there was an error, the  return value is NULL.
 *
 *
 * Assumes
 *
 *     The largest PRINTER_INFO_* structure is PRINTER_INFO_2.
 *
 */
LPBYTE
CopyIniPrinterToPrinter(
    PINIPRINTER         pIniPrinter,
    DWORD               Level,
    LPBYTE              pPrinterInfo,
    LPBYTE              pEnd,
    PPRINTER_INFO_2     pSecondPrinter2,
    LPWSTR              lpRemote,           // contains this machine name, or NULL
    BOOL                CopySecurityDescriptor,
    ACCESS_MASK         GrantedAccess,
    PDEVMODE            pDevMode
    )
{
    LPWSTR   SourceStrings[sizeof(PRINTER_INFO_2)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    DWORD    Attributes;

    //
    // Max string: "\\Computer\Printer,Driver,Location"
    //

    DWORD   dwRet;
    PWSTR   pszString = NULL;
    WCHAR   string[MAX_PRINTER_BROWSE_NAME];
    DWORD   dwLength;
    WCHAR   printerString[ MAX_UNC_PRINTER_NAME ];
    LPWSTR  pszPorts;

    PPRINTER_INFO_3 pPrinter3 = (PPRINTER_INFO_3)pPrinterInfo;
    PPRINTER_INFO_2 pPrinter2 = (PPRINTER_INFO_2)pPrinterInfo;
    PPRINTER_INFO_1 pPrinter1 = (PPRINTER_INFO_1)pPrinterInfo;
    PPRINTER_INFO_4 pPrinter4 = (PPRINTER_INFO_4)pPrinterInfo;
    PPRINTER_INFO_5 pPrinter5 = (PPRINTER_INFO_5)pPrinterInfo;
    PPRINTER_INFO_6 pPrinter6 = (PPRINTER_INFO_6)pPrinterInfo;
    PPRINTER_INFO_7 pPrinter7 = (PPRINTER_INFO_7)pPrinterInfo;
    PPRINTER_INFO_STRESS pPrinter0 = (PPRINTER_INFO_STRESS)pPrinterInfo;
    PSECURITY_DESCRIPTOR pPartialSecurityDescriptor = NULL;
    DWORD   *pOffsets;
    SYSTEM_INFO si;
    DWORD cbNeeded;

    switch (Level) {

    case STRESSINFOLEVEL:

        pOffsets = PrinterInfoStressStrings;
        break;

    case 4:

        pOffsets = PrinterInfo4Strings;
        break;

    case 1:

        pOffsets = PrinterInfo1Strings;
        break;

    case 2:
        pOffsets = PrinterInfo2Strings;
        break;

    case 3:
        pOffsets = PrinterInfo3Strings;
        break;

    case 5:
        pOffsets = PrinterInfo5Strings;
        break;

    case 6:
        pOffsets = PrinterInfo6Strings;
        break;

    case 7:
        pOffsets = PrinterInfo7Strings;
        break;

    default:
        return pEnd;
    }

    //
    // If it's a cluster printer, it always appears remote.
    //
    Attributes = pIniPrinter->Attributes;

    Attributes |= ( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ) ?
                     PRINTER_ATTRIBUTE_NETWORK :
                     PRINTER_ATTRIBUTE_LOCAL;

    switch (Level) {

    case STRESSINFOLEVEL:

        if (lpRemote) {

            if (!BoolFromHResult(StringCchPrintf(string, COUNTOF(string), L"%ws\\%ws", lpRemote, pIniPrinter->pName))) {

                pEnd = NULL;
                break;
            }

            *pSourceStrings++=string;
            *pSourceStrings++=lpRemote;

        } else {
            *pSourceStrings++=pIniPrinter->pName;
            *pSourceStrings++=NULL;
        }

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter0, pOffsets, pEnd);

        pPrinter0->cJobs                = pIniPrinter->cJobs;
        pPrinter0->cTotalJobs           = pIniPrinter->cTotalJobs;
        pPrinter0->cTotalBytes          = pIniPrinter->cTotalBytes.LowPart;
        pPrinter0->dwHighPartTotalBytes = pIniPrinter->cTotalBytes.HighPart;
        pPrinter0->stUpTime             = pIniPrinter->stUpTime;
        pPrinter0->MaxcRef              = pIniPrinter->MaxcRef;
        pPrinter0->cTotalPagesPrinted   = pIniPrinter->cTotalPagesPrinted;
        pPrinter0->dwGetVersion         = GetVersion();
#if DBG
        pPrinter0->fFreeBuild           = FALSE;
#else
        pPrinter0->fFreeBuild           = TRUE;
#endif
        GetSystemInfo(&si);
        pPrinter0->dwProcessorType      = si.dwProcessorType;
        pPrinter0->dwNumberOfProcessors   = si.dwNumberOfProcessors;
        pPrinter0->cSpooling              = pIniPrinter->cSpooling;
        pPrinter0->cMaxSpooling           = pIniPrinter->cMaxSpooling;
        pPrinter0->cRef                   = pIniPrinter->cRef;
        pPrinter0->cErrorOutOfPaper       = pIniPrinter->cErrorOutOfPaper;
        pPrinter0->cErrorNotReady         = pIniPrinter->cErrorNotReady;
        pPrinter0->cJobError              = pIniPrinter->cJobError;
        pPrinter0->cChangeID              = pIniPrinter->cChangeID;
        pPrinter0->dwLastError            = pIniPrinter->dwLastError;

        pPrinter0->Status   = MapPrinterStatus(MAP_READABLE,
                                               pIniPrinter->Status) |
                              pIniPrinter->PortStatus;

        pPrinter0->cEnumerateNetworkPrinters = pIniPrinter->pIniSpooler->cEnumerateNetworkPrinters;
        pPrinter0->cAddNetPrinters           = pIniPrinter->pIniSpooler->cAddNetPrinters;

        pPrinter0->wProcessorArchitecture    = si.wProcessorArchitecture;
        pPrinter0->wProcessorLevel           = si.wProcessorLevel;
        pPrinter0->cRefIC                    = pIniPrinter->cRefIC;

        break;

    case 4:

        if (lpRemote) {

            if (!BoolFromHResult(StringCchPrintf(string, COUNTOF(string), L"%ws\\%ws", lpRemote, pIniPrinter->pName))) {

                pEnd = NULL;
                break;
            }

            *pSourceStrings++=string;
            *pSourceStrings++= lpRemote;

        } else {
            *pSourceStrings++=pIniPrinter->pName;
            *pSourceStrings++=NULL;
        }

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter4, pOffsets, pEnd);

        //
        // Add additional info later
        //
        pPrinter4->Attributes = Attributes;
        break;

    case 1:

        if (lpRemote) {

            dwRet = StrCatAlloc(&pszString,
                                lpRemote,
                                L"\\",
                                pIniPrinter->pName,
                                L",",
                                pIniPrinter->pIniDriver->pName,
                                L",",
                                pIniPrinter->pLocation ?
                                pIniPrinter->pLocation :
                                szNull,
                                NULL);

            if (dwRet != ERROR_SUCCESS) {
                pEnd = NULL;
                break;
            }

            if (!BoolFromHResult(StringCchPrintf(printerString, COUNTOF(printerString), L"%ws\\%ws", lpRemote, pIniPrinter->pName))) {

                pEnd = NULL;
                break;
            }

        } else {

            dwRet = StrCatAlloc(&pszString,
                                pIniPrinter->pName,
                                L",",
                                pIniPrinter->pIniDriver->pName,
                                L",",
                                pIniPrinter->pLocation ?
                                pIniPrinter->pLocation :
                                szNull,
                                NULL);
            if (dwRet != ERROR_SUCCESS) {
                pEnd = NULL;
                break;
            }

            if (!BoolFromHResult(StringCchCopy(printerString, COUNTOF(printerString), pIniPrinter->pName))) {
                pEnd = NULL;
                break;
            }
        }

        *pSourceStrings++=pszString;
        *pSourceStrings++=printerString;
        *pSourceStrings++=pIniPrinter->pComment;

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter1, pOffsets, pEnd);

        FreeSplStr(pszString);

        pPrinter1->Flags = PRINTER_ENUM_ICON8;

        break;

    case 2:

        if (lpRemote) {
            *pSourceStrings++= lpRemote;

            if (!BoolFromHResult(StringCchPrintf(string, COUNTOF(string), L"%ws\\%ws", lpRemote, pIniPrinter->pName))){
                pEnd = NULL;
                break;
            }

            *pSourceStrings++=string;

        } else {
            *pSourceStrings++=NULL;
            *pSourceStrings++=pIniPrinter->pName;
        }

        *pSourceStrings++=pIniPrinter->pShareName;

        cbNeeded = 0;
        GetPrinterPorts(pIniPrinter, 0, &cbNeeded);

        if (pszPorts = AllocSplMem(cbNeeded)) {

            GetPrinterPorts(pIniPrinter, pszPorts, &cbNeeded);

            *pSourceStrings++=pszPorts;
            *pSourceStrings++=pIniPrinter->pIniDriver->pName;
            *pSourceStrings++=pIniPrinter->pComment;
            *pSourceStrings++=pIniPrinter->pLocation;
            *pSourceStrings++=pIniPrinter->pSepFile;
            *pSourceStrings++=pIniPrinter->pIniPrintProc->pName;
            *pSourceStrings++=pIniPrinter->pDatatype;
            *pSourceStrings++=pIniPrinter->pParameters;

            pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter2, pOffsets, pEnd);

            FreeSplMem(pszPorts);
        }
        else {
            pEnd = NULL;
            break;
        }


        if (pDevMode) {

            pEnd -= pDevMode->dmSize + pDevMode->dmDriverExtra;

            pEnd = (PBYTE)ALIGN_PTR_DOWN(pEnd);

            pPrinter2->pDevMode=(LPDEVMODE)pEnd;

            //
            // This is OK because GetPrinterSize has validated the buffer is big enough.
            //
            memcpy(pPrinter2->pDevMode, pDevMode, pDevMode->dmSize + pDevMode->dmDriverExtra);

            //
            // In the remote case, append the name of the server
            // in the devmode.dmDeviceName.  This allows dmDeviceName
            // to always match win.ini's [devices] section.
            //
            FixDevModeDeviceName(lpRemote ? string : pIniPrinter->pName,
                                 pPrinter2->pDevMode,
                                 pIniPrinter->cbDevMode);
        } else {

            pPrinter2->pDevMode=NULL;
        }



        pPrinter2->Attributes      = Attributes;
        pPrinter2->Priority        = pIniPrinter->Priority;
        pPrinter2->DefaultPriority = pIniPrinter->DefaultPriority;
        pPrinter2->StartTime       = pIniPrinter->StartTime;
        pPrinter2->UntilTime       = pIniPrinter->UntilTime;

        if (pSecondPrinter2) {

            pPrinter2->cJobs  = pSecondPrinter2->cJobs;
            pPrinter2->Status = pSecondPrinter2->Status;

            if( pIniPrinter->Status & PRINTER_PENDING_DELETION ){
                pPrinter2->Status |= PRINTER_STATUS_PENDING_DELETION;
            }

        } else {

            pPrinter2->cJobs=pIniPrinter->cJobs;

            pPrinter2->Status   = MapPrinterStatus(MAP_READABLE,
                                                   pIniPrinter->Status) |
                                  pIniPrinter->PortStatus;
        }

        pPrinter2->AveragePPM=pIniPrinter->AveragePPM;

        if( CopySecurityDescriptor ) {

            pEnd = CopyIniPrinterSecurityDescriptor(pIniPrinter,
                                                    Level,
                                                    pPrinterInfo,
                                                    pEnd,
                                                    GrantedAccess);
        } else {

            pPrinter2->pSecurityDescriptor = NULL;
        }

        break;

    case 3:

        pEnd = CopyIniPrinterSecurityDescriptor(pIniPrinter,
                                                Level,
                                                pPrinterInfo,
                                                pEnd,
                                                GrantedAccess);

        break;

    case 5:

        if (lpRemote) {

            if (!BoolFromHResult(StringCchPrintf(string, COUNTOF(string), L"%ws\\%ws", lpRemote, pIniPrinter->pName))) {
                pEnd = NULL;
                break;
            }

            *pSourceStrings++=string;
        } else {
            *pSourceStrings++=pIniPrinter->pName;
        }

        cbNeeded = 0;
        GetPrinterPorts(pIniPrinter, 0, &cbNeeded);

        if (pszPorts = AllocSplMem(cbNeeded)) {

            GetPrinterPorts(pIniPrinter, pszPorts, &cbNeeded);

            *pSourceStrings++ = pszPorts;

            pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter5, pOffsets, pEnd);

            pPrinter5->Attributes   = Attributes;
            pPrinter5->DeviceNotSelectedTimeout = pIniPrinter->dnsTimeout;
            pPrinter5->TransmissionRetryTimeout = pIniPrinter->txTimeout;

            FreeSplMem(pszPorts);
        }
        else
            pEnd = NULL;

        break;

    case 6:
        if (pSecondPrinter2) {
            pPrinter6->dwStatus = pSecondPrinter2->Status;

            if( pIniPrinter->Status & PRINTER_PENDING_DELETION ){
                pPrinter6->dwStatus |= PRINTER_STATUS_PENDING_DELETION;
            }
        } else {
            pPrinter6->dwStatus = MapPrinterStatus(MAP_READABLE,
                                                   pIniPrinter->Status) |
                                                   pIniPrinter->PortStatus;
        }
        break;

    case 7:

        *pSourceStrings++ = pIniPrinter->pszObjectGUID;

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter7, pOffsets, pEnd);

        if ( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CACHE) {

            //
            // For connections, we rely directly on dwAction. The caching code
            // is the only one that updates dwAction in RefreshPrinterInfo7.
            //
            pPrinter7->dwAction = pIniPrinter->dwAction;

        } else {

            if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) {
                pPrinter7->dwAction = DSPRINT_PUBLISH;
                if (!pIniPrinter->pszObjectGUID ||
                    pIniPrinter->DsKeyUpdate    ||
                    pIniPrinter->DsKeyUpdateForeground) {
                    pPrinter7->dwAction |= DSPRINT_PENDING;
                }
            } else {
                pPrinter7->dwAction = DSPRINT_UNPUBLISH;
                if (pIniPrinter->pszObjectGUID                    ||
                    (pIniPrinter->DsKeyUpdate & DS_KEY_UNPUBLISH) ||
                    (pIniPrinter->DsKeyUpdateForeground & DS_KEY_UNPUBLISH)) {
                    pPrinter7->dwAction |= DSPRINT_PENDING;
                }
            }
        }
        break;

    default:
        return pEnd;
    }

    return pEnd;
}

BOOL
SplGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PSPOOL             pSpool = (PSPOOL)hPrinter;
    BOOL               AccessIsGranted = FALSE;   // Must intialize
    PPRINTER_INFO_2    pSecondPrinter=NULL;
    LPBYTE             pEnd;
    LPWSTR             lpRemote;
    BOOL               bReturn = FALSE;
    PDEVMODE           pDevMode = NULL;
    PINIPRINTER        pIniPrinter;
    BOOL               bNt3xClient;
    PWSTR              pszCN = NULL, pszDN = NULL;
    DWORD              dwRet;


   EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {

        goto Cleanup;
    }

    pIniPrinter = pSpool->pIniPrinter;
    bNt3xClient = (pSpool->TypeofHandle & PRINTER_HANDLE_3XCLIENT);

    //
    // If Nt3x client we will converted devmode. If driver can't convert we will not return devmode
    //
    if ( bNt3xClient && Level == 2 && pIniPrinter->pDevMode ) {

        //
        // Call driver to get a Nt3x DevMode (if fails no devmode is given)
        //
        if (wcsstr(pSpool->pName, gszDrvConvert))
            pDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                        pIniPrinter->pDevMode,
                                                        NULL,
                                                        pSpool->pName,
                                                        NT3X_VERSION);
        else
            pDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                        pIniPrinter->pDevMode,
                                                        NULL,
                                                        NULL,
                                                        NT3X_VERSION);
    }

    SplInSem();

    if (( pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_DATA ) ||
        ( pSpool->pIniSpooler != pLocalIniSpooler )) {

        lpRemote = pSpool->pFullMachineName;

    } else {

        lpRemote = NULL;

    }


    switch (Level) {

        case STRESSINFOLEVEL:
        case 1:
        case 2:
        case 4:
        case 5:
        case 6:
        case 7:

            if ( !AccessGranted(SPOOLER_OBJECT_PRINTER,
                                PRINTER_ACCESS_USE,
                                pSpool) ) {
                SetLastError(ERROR_ACCESS_DENIED);
                goto Cleanup;
            }

            break;

        case 3:

            if (!AreAnyAccessesGranted(pSpool->GrantedAccess,
                                       READ_CONTROL | ACCESS_SYSTEM_SECURITY)) {

                SetLastError(ERROR_ACCESS_DENIED);
                goto Cleanup;
            }

            break;

        default:
            break;
    }


    if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR)) {

        HANDLE hPort = pSpool->hPort;

        if (hPort == INVALID_PORT_HANDLE) {

            DBGMSG(DBG_WARNING, ("GetPrinter called with bad port handle.  Setting error %d\n",
                                 pSpool->OpenPortError));

            //
            // If this value is 0, then when we return GetLastError,
            // the client will think we succeeded.
            //
            SPLASSERT(pSpool->OpenPortError);

            goto PartialSuccess;
        }


        LeaveSplSem();

        if ((Level == 2 || Level == 6)) {

            if (!RetrieveMasqPrinterInfo(pSpool, &pSecondPrinter)) {
                goto CleanupFromOutsideSplSem;
            }
        }

        EnterSplSem();

        /* Re-validate the handle, since it might possibly have been closed
         * while we were outside the semaphore:
         */
        if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {

            goto Cleanup;
        }
    }

PartialSuccess:

    *pcbNeeded = GetPrinterSize(pIniPrinter, Level, 0, lpRemote,
                                bNt3xClient ? pDevMode : pIniPrinter->pDevMode);


    if (*pcbNeeded > cbBuf) {

        DBGMSG(DBG_TRACE, ("SplGetPrinter Failure with ERROR_INSUFFICIENT_BUFFER cbBuf is %d and pcbNeeded is %d\n", cbBuf, *pcbNeeded));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    pEnd = CopyIniPrinterToPrinter(pIniPrinter, Level, pPrinter,
                                   pPrinter+cbBuf, pSecondPrinter,
                                   lpRemote,
                                   TRUE, pSpool->GrantedAccess,
                                   bNt3xClient ? pDevMode : pIniPrinter->pDevMode);

    if ( pEnd != NULL)
        bReturn = TRUE;

Cleanup:

   LeaveSplSem();

CleanupFromOutsideSplSem:

    SplOutSem();
    FreeSplMem(pSecondPrinter);

    FreeSplMem(pDevMode);

    if ( bReturn == FALSE ) {

        SPLASSERT(GetLastError() != ERROR_SUCCESS);
    }

    return bReturn;
}

BOOL
EnumerateNetworkPrinters(
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PININETPRINT pIniNetPrint;
    DWORD        cb;
    LPBYTE       pEnd;
    BOOL         bReturnValue = FALSE;

   EnterSplSem();

    //
    // All network printers reside in pLocalIniSpooler to avoid
    // duplicates.
    //
    RemoveOldNetPrinters( NULL, pLocalIniSpooler );

    //
    //  If the Server has not been up long enough, then fail
    //  so the client will ask another Server for the Browse List.
    //

    if ( bNetInfoReady == FALSE ) {

        SetLastError( ERROR_CAN_NOT_COMPLETE );
        goto Done;
    }

    cb = 0;

    pIniNetPrint = pIniSpooler->pIniNetPrint;

    while (pIniNetPrint) {

        cb += GetIniNetPrintSize( pIniNetPrint );
        pIniNetPrint = pIniNetPrint->pNext;
    }

    *pcbNeeded = cb;

    if (cb > cbBuf) {

        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        goto    Done;
    }

    pIniNetPrint = pIniSpooler->pIniNetPrint;
    pEnd = pPrinter + cbBuf;

    while ( pIniNetPrint ) {

        pEnd = CopyIniNetPrintToPrinter( pIniNetPrint, pPrinter, pEnd );
        (*pcReturned)++;
        pPrinter += sizeof(PRINTER_INFO_1);
        pIniNetPrint = pIniNetPrint->pNext;

    }

    if ( *pcReturned == 0 ) {

        bNetInfoReady = FALSE;
        FirstAddNetPrinterTickCount = 0;
        SetLastError( ERROR_CAN_NOT_COMPLETE );

        DBGMSG( DBG_TRACE, ("EnumerateNetworkPrinters returning ERROR_CAN_NOT_COMPELTE becase there is no browse list\n"));

    } else {

        pIniSpooler->cEnumerateNetworkPrinters++;           // Stats only
        bReturnValue = TRUE;

        DBGMSG( DBG_TRACE, (" EnumerateNetworkPrnters called %d times returning %d printers\n", pIniSpooler->cEnumerateNetworkPrinters, *pcReturned ));
    }

Done:
   LeaveSplSem();
    SplOutSem();
    return bReturnValue;
}

/*++

Routine Name

    UpdateSpoolersRef

Routine Description:

    Does and AddRef or a DecRef on all pIniSpooler matching a certain criteria

Arguments:

    SpoolerType - Type of pIniSpoolers which to addref/decref
                  (Ex. SPL_TYPE_CLUSTER | SPL_TYPE_LOCAL)
    bAddRef     - TRUE means AddRef, FALSE means DecRef

Return Value:

    None

--*/
VOID
UpdateSpoolersRef(
    IN DWORD SpoolerType,
    IN BOOL  bAddRef
    )
{
    PINISPOOLER pIniSpooler;

    EnterSplSem();

    //
    // AddRef or DecRef all local and cluster spoolers
    //
    for (pIniSpooler = pLocalIniSpooler; pIniSpooler; pIniSpooler = pIniSpooler->pIniNextSpooler)
    {
        if (pIniSpooler->SpoolerFlags & SpoolerType)
        {
            if (bAddRef)
            {
                INCSPOOLERREF(pIniSpooler);
            }
            else
            {
                DECSPOOLERREF(pIniSpooler);
            }
        }
    }

    LeaveSplSem();
}

/*++

Routine Name

    SplEnumAllClusterPrinters

Routine Description:

    Enumerates all printers in the local spooler and all cluster
    spoolers hosted by localspl at the time of the call.

Arguments:

    InputFlags     - combination of ENUM_PRINTER_xxx
    pszInputName   - name of the print provider
    Level          - level of the call
    pPrinter       - buffer to hold the PRINTER_INFO_xxx structures
    cbInputBufSize - size of pPrinter buffer
    pcbNeeded      - bytes required to hold all the printer info structures
    pcReturned     - number of structures returned by this function

Return Value:

    TRUE  - cal succeeded
    FALSE - an error occurred, the function sets the last error

--*/
BOOL
SplEnumAllClusterPrinters(
    DWORD   InputFlags,
    LPWSTR  pszInputName,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbInputBufSize,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    PINISPOOLER pIniSpooler;

    DWORD cbBuf          = cbInputBufSize;
    DWORD cTotalReturned = 0;
    DWORD cbTotalNeeded  = 0;
    DWORD dwError        = ERROR_SUCCESS;
    DWORD cbStruct;

    switch (Level)
    {
        case STRESSINFOLEVEL:
            cbStruct = sizeof(PRINTER_INFO_STRESS);
            break;

        case 1:
            cbStruct = sizeof(PRINTER_INFO_1);
            break;

        case 2:
            cbStruct = sizeof(PRINTER_INFO_2);
            break;

        case 4:
            cbStruct = sizeof(PRINTER_INFO_4);
            break;

        case 5:
            cbStruct = sizeof(PRINTER_INFO_5);
            break;

        default:
            dwError = ERROR_INVALID_LEVEL;
    }

    if (dwError == ERROR_SUCCESS)
    {
        //
        // AddRef all ini spoolers
        //
        UpdateSpoolersRef(SPL_TYPE_LOCAL | SPL_TYPE_CLUSTER, TRUE);

        //
        // Enumerate all the printers
        //
        for (pIniSpooler = pLocalIniSpooler; pIniSpooler; pIniSpooler = pIniSpooler->pIniNextSpooler)
        {
            if (pIniSpooler->SpoolerFlags & (SPL_TYPE_LOCAL | SPL_TYPE_CLUSTER))
            {
                DWORD  cReturned;
                DWORD  cbNeeded;
                DWORD  Flags   = InputFlags;
                LPWSTR pszName = pszInputName;

                //
                // For clusters force the printer name to be fully qualified
                //
                if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER)
                {
                    Flags   |= PRINTER_ENUM_NAME;
                    pszName  = pIniSpooler->pMachineName;
                }

                if (SplEnumPrinters(Flags,
                                    pszName,
                                    Level,
                                    pPrinter,
                                    cbBuf,
                                    &cbNeeded,
                                    &cReturned,
                                    pIniSpooler))
                {
                    cTotalReturned += cReturned;
                    cbBuf          -= cbNeeded;
                    pPrinter       += cReturned * cbStruct;
                }
                else
                {
                    dwError = GetLastError();

                    if (dwError == ERROR_INSUFFICIENT_BUFFER)
                    {
                        cbBuf = 0;
                    }
                    else
                    {
                        //
                        // We cannot continue on an error different than insufficient buffer
                        //
                        break;
                    }
                }

                cbTotalNeeded += cbNeeded;
            }
        }

        //
        // DecRef all ini spoolers
        //
        UpdateSpoolersRef(SPL_TYPE_LOCAL | SPL_TYPE_CLUSTER, FALSE);

        //
        // Update out variables
        //
        if (dwError == ERROR_SUCCESS)
        {
            *pcbNeeded  = cbTotalNeeded;
            *pcReturned = cTotalReturned;
        }
        else if (dwError == ERROR_INSUFFICIENT_BUFFER)
        {
            *pcbNeeded  = cbTotalNeeded;
        }
        else
        {
            SetLastError(dwError);
        }
    }

    return dwError == ERROR_SUCCESS;
}

/*

EnumPrinters can be called with the following combinations:

Flags                   Name            Meaning

PRINTER_ENUM_LOCAL      NULL            Enumerate all Printers on this machine

PRINTER_ENUM_NAME       MachineName     Enumerate all Printers on this machine

PRINTER_ENUM_NAME |     MachineName     Enumerate all shared Printers on this
PRINTER_ENUM_SHARED     MachineName     machine

PRINTER_ENUM_NETWORK    MachineName     Enumerate all added remote printers

PRINTER_ENUM_REMOTE     ?               Return error - let win32spl handle it

PRINTER_ENUM_NAME       NULL            Give back Print Providor name

PRINTER_ENUM_NAME       "Windows NT Local Print Providor"
                                        same as PRINTER_ENUM_LOCAL

It is not an error if no known flag is specified.
In this case we just return TRUE without any data
(This is so that other print providers may define
their own flags.)

*/

BOOL
LocalEnumPrinters(
    DWORD   Flags,
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL  bReturn = ROUTER_UNKNOWN;

    if (Flags & PRINTER_ENUM_CLUSTER)
    {
        bReturn = SplEnumAllClusterPrinters(Flags,
                                            pName,
                                            Level,
                                            pPrinter,
                                            cbBuf,
                                            pcbNeeded,
                                            pcReturned);
    }
    else
    {
        PINISPOOLER pIniSpooler;

        //
        // Mask cluster flag
        //
        Flags &= ~PRINTER_ENUM_CLUSTER;

        pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

        if (pIniSpooler)
        {
            bReturn = SplEnumPrinters(Flags,
                                      pName,
                                      Level,
                                      pPrinter,
                                      cbBuf,
                                      pcbNeeded,
                                      pcReturned,
                                      pIniSpooler);

            FindSpoolerByNameDecRef(pIniSpooler);
        }
    }

    return bReturn;
}


BOOL
EnumThisPrinter(
    DWORD           Flags,
    PINIPRINTER     pIniPrinter,
    PINISPOOLER     pIniSpooler
    )
{


    //
    //  If they only want shared Printers
    //
    if ( (Flags & PRINTER_ENUM_SHARED) &&
         !(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) )
        return FALSE;

    //
    //  Only allow them to see printers which are being deleted if they have jobs
    //  This allows remote admin to work well.
    if ( (pIniPrinter->Status & PRINTER_PENDING_DELETION) &&
         pIniPrinter->cJobs == 0 )
        return FALSE;

    //
    //  Don't count printers which are partially created
    //
    if ( pIniPrinter->Status & PRINTER_PENDING_CREATION )
        return FALSE;

    return TRUE;
}


BOOL
SplEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIPRINTER pIniPrinter;
    PPRINTER_INFO_1 pPrinter1=(PPRINTER_INFO_1)pPrinter;
    DWORD       cb;
    LPBYTE      pEnd;
    LPWSTR      lpRemote;


    *pcbNeeded = 0;
    *pcReturned = 0;

    if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                SERVER_ACCESS_ENUMERATE,
                                NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    if ( Flags & PRINTER_ENUM_NAME ) {
        if ( Name && *Name ) {
            if (lstrcmpi(Name, szPrintProvidorName) && !MyName( Name, pIniSpooler)) {

                return FALSE;
            }

            // If it's PRINTER_ENUM_NAME of our name,
            // do the same as PRINTER_ENUM_LOCAL:

            Flags |= PRINTER_ENUM_LOCAL;

            // Also if it is for us then ignore the REMOTE flag.
            // Otherwise the call will get passed to Win32Spl which
            // will end up calling us back forever.

            Flags &= ~PRINTER_ENUM_REMOTE;
        }
    }

    if ( Flags & PRINTER_ENUM_REMOTE ) {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }

    lpRemote = NULL;

    if ( Name && *Name ) {

        if ( MyName( Name, pIniSpooler ) ) {
            lpRemote = Name;
        }
    }

    if ((Level == 1) && (Flags & PRINTER_ENUM_NETWORK)) {

        SplOutSem();
        return EnumerateNetworkPrinters( pPrinter, cbBuf, pcbNeeded, pcReturned, pIniSpooler );
    }

   EnterSplSem();

    if ((Level == 1 ) && (Flags & PRINTER_ENUM_NAME) && !Name) {

        LPWSTR   SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
        LPWSTR   *pSourceStrings=SourceStrings;

        cb = wcslen(szPrintProvidorName)*sizeof(WCHAR) + sizeof(WCHAR) +
             wcslen(szPrintProvidorDescription)*sizeof(WCHAR) + sizeof(WCHAR) +
             wcslen(szPrintProvidorComment)*sizeof(WCHAR) + sizeof(WCHAR) +
             sizeof(PRINTER_INFO_1);

        *pcbNeeded=cb;

        if (cb > cbBuf) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
           LeaveSplSem();
            return FALSE;
        }

        *pcReturned = 1;

        pPrinter1->Flags = PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON1;

        *pSourceStrings++=szPrintProvidorDescription;
        *pSourceStrings++=szPrintProvidorName;
        *pSourceStrings++=szPrintProvidorComment;

        PackStrings(SourceStrings, pPrinter, PrinterInfo1Strings,
                    pPrinter+cbBuf);

       LeaveSplSem();

        return TRUE;
    }

    cb=0;

    if (Flags & (PRINTER_ENUM_LOCAL | PRINTER_ENUM_NAME)) {

        //
        // For remote user's who are not admins enumerate shared printers only
        //
        if ( S_FALSE == CheckLocalCall()                     &&
             !(Flags & PRINTER_ENUM_SHARED)                 &&
             !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                                   SERVER_ACCESS_ADMINISTER,
                                   NULL,
                                   NULL,
                                   pIniSpooler) )
            Flags   |= PRINTER_ENUM_SHARED;

        //
        //  Calculate the size required
        //

        for ( pIniPrinter = pIniSpooler->pIniPrinter;
              pIniPrinter != NULL;
              pIniPrinter = pIniPrinter->pNext ) {


            if ( EnumThisPrinter(Flags, pIniPrinter, pIniSpooler) && ShowThisPrinter(pIniPrinter, NULL))
                cb += GetPrinterSize(pIniPrinter, Level, Flags,
                                     lpRemote, pIniPrinter->pDevMode);
        }

    }
    *pcbNeeded=cb;

    if (cb > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
       LeaveSplSem();
        return FALSE;
    }

    if (Flags & (PRINTER_ENUM_LOCAL | PRINTER_ENUM_NAME)) {

        for ( pIniPrinter = pIniSpooler->pIniPrinter, pEnd = pPrinter + cbBuf;
              pIniPrinter != NULL;
              pIniPrinter = pIniPrinter->pNext ) {


            if ( !EnumThisPrinter(Flags, pIniPrinter, pIniSpooler) )
                continue;

            //
            // Do not list printers without access
            if( !ShowThisPrinter(pIniPrinter, NULL) ) {
                continue;
            }

            pEnd = CopyIniPrinterToPrinter( pIniPrinter, Level, pPrinter,
                                            pEnd, NULL, lpRemote, FALSE, 0,
                                            pIniPrinter->pDevMode );

            if (!pEnd) {
               LeaveSplSem();
                return FALSE;
            }

            (*pcReturned)++;

            switch (Level) {

                case STRESSINFOLEVEL:
                    pPrinter+=sizeof(PRINTER_INFO_STRESS);
                    break;

                case 1:
                    pPrinter+=sizeof(PRINTER_INFO_1);
                    break;

                case 2:
                    pPrinter+=sizeof(PRINTER_INFO_2);
                    break;

                case 4:
                    pPrinter+=sizeof(PRINTER_INFO_4);
                    break;

                case 5:
                    pPrinter+=sizeof(PRINTER_INFO_5);
                    break;

            }
        }
    }

   LeaveSplSem();

    return TRUE;
}

/* ShowThisPrinter
 *
 * Returns whether this printer should be visible to the current
 * user.
 *
 * We do not show printers that the caller does not
 * have access to. This is for two reasons:
 *
 * 1: A multi-user system with 200 users each with their
 *    own client printers would cause a large confusing
 *    list of printers from within applications such as word.
 *    "Client" printers are owned by the user of that station,
 *    and by default only allow print access for that user.
 *    This provides a simple way of filtering printers to show
 *    to the user for a selection.
 *
 * 2: Programs such as Windows write get confused when
 *    they see a printer they can not open. This is a bad
 *    program, since normal NT can have a printer denied to a user, but we must
 *    make it work anyway.
 *
 *
 * Must work out security modes!
 *
 * Parameters
 *
 *     pIniPrinter - A pointer to the spooler's internal data structure
 *         for the printer concerned.
 *     hToken      - An optional pointer to the token for the user we are
                     wanting to make the test for.
 */
BOOL
ShowThisPrinter(
    IN      PINIPRINTER     pIniPrinter,
    IN      HANDLE          hToken              OPTIONAL
    )
{
    LPWSTR            pObjectName;
    BOOL              bRet         = TRUE;
    BOOL              AccessStatus = TRUE;
    HANDLE            hClientToken = NULL;
    ACCESS_MASK       MappedDesiredAccess;
    DWORD             GrantedAccess = 0;
    PBOOL             pGenerateOnClose;
    BYTE              PrivilegeSetBuffer[256];
    DWORD             PrivilegeSetBufferLength = 256;
    PPRIVILEGE_SET    pPrivilegeSet;
    DWORD             dwRetCode;

    PTOKEN_PRIVILEGES pPreviousTokenPrivileges;
    DWORD PreviousTokenPrivilegesLength;

    //
    // External references to global variables in security.c
    //
    extern GENERIC_MAPPING GenericMapping[];
    extern WCHAR           *szSpooler;


    //
    // If Hydra is not enabled, keep NT behavior unchanged
    //
    if( !(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)) )
    {
        bRet = TRUE;
    }
    else
    {
        //
        // If we weren't passed in a token handle, then use the current
        // impersonation token or the process token.
        //
        if (!hToken)
        {
            bRet = GetTokenHandle(&hClientToken);
        }
        else
        {
            hClientToken = hToken;
        }

        //
        // Administrators see all printers. This allows an
        // Admin to take ownership of a printer whose ACL is
        // messed up.
        //
        if (bRet)
        {
            bRet = ValidateObjectAccessWithToken(hClientToken, SPOOLER_OBJECT_SERVER, SERVER_ACCESS_ADMINISTER, NULL, NULL, pIniPrinter->pIniSpooler);

            if (!bRet)
            {
                MapGenericToSpecificAccess(SPOOLER_OBJECT_PRINTER, PRINTER_ACCESS_USE, &MappedDesiredAccess);

                pPrivilegeSet = (PPRIVILEGE_SET)PrivilegeSetBuffer;

                //
                // Call AccessCheck followed by ObjectOpenAuditAlarm rather than
                // AccessCheckAndAuditAlarm, because we may need to enable
                // SeSecurityPrivilege in order to check for ACCESS_SYSTEM_SECURITY
                // privilege.  We must ensure that the security access-checking
                // API has the actual token whose security privilege we have enabled.
                // AccessCheckAndAuditAlarm is no good for this, because it opens
                // the client's token again, which may not have the privilege enabled.
                //
                // We do not audit and set off alarms because the caller
                // did not really try and open the printer.
                // We the server tried to check access for display purposes, not
                // for handle create.
                //
                bRet = AccessCheck(pIniPrinter->pSecurityDescriptor,
                                   hClientToken,
                                   MappedDesiredAccess,
                                   &GenericMapping[SPOOLER_OBJECT_PRINTER],
                                   pPrivilegeSet,
                                   &PrivilegeSetBufferLength,
                                   &GrantedAccess,
                                   &AccessStatus);

                //
                // If the access check failed, but it was because we didn't have an
                // impersonation token, then we can view the printer.
                //
                if (!bRet)
                {
                    if (GetLastError() == ERROR_NO_IMPERSONATION_TOKEN)
                    {
                        bRet = TRUE;
                        DBGMSG( DBG_ERROR, ("ShowThisPrinter: No impersonation token.  Printer will be enumerated\n"));
                    }
                    else
                    {
                        DBGMSG( DBG_TRACE, ("ShowThisPrinter: Printer %ws Not accessable by caller Access Check failuer %d\n",pIniPrinter->pName,GetLastError()));
                    }
                }
                else if (!AccessStatus)
                {
                    DBGMSG( DBG_TRACE, ("ShowThisPrinter: Printer %ws Not accessable by caller AccessStatus failure %d\n",pIniPrinter->pName,GetLastError()));
                    bRet = FALSE;
                }
            }
        }
    }

    //
    // If we have a client token and one was not passed in, then close the token
    // handle.
    //
    if (hClientToken && !hToken)
    {
        CloseHandle(hClientToken);
    }

    return bRet;
}

/*++

Routine Name:

    RetrieveMasqPrinterInfo

Description:

    This retrieves Masq information for the printer, it is either cached state
    or a direct call into the provider depending on Reg Settings.

Arguments:

    pSpool          -   The spool handle that we use for synchronisation.
    ppPrinterInfo   -   The returned printer info.

Returns:

    A Boolean, if FALSE, last error is set.

--*/
BOOL
RetrieveMasqPrinterInfo(
    IN      PSPOOL              pSpool,
        OUT PRINTER_INFO_2      **ppPrinterInfo
    )
{
    BOOL            bRet           = TRUE;
    PINIPRINTER     pIniPrinter    = NULL;

    pIniPrinter = pSpool->pIniPrinter;

    SplOutSem();

    if (!(pSpool->pIniSpooler->dwSpoolerSettings & SPOOLER_CACHEMASQPRINTERS))
    {
        //
        // Just synchronously return the data from the partial print provider.
        //
        bRet = BoolFromStatus(GetPrinterInfoFromRouter(pSpool->hPort, ppPrinterInfo));
    }
    else
    {
        //
        // Kick off the thread that goes and reads the masq status.
        //
        BOOL            bCreateThread  = FALSE;
        PRINTER_INFO_2  *pPrinterInfo2 = NULL;

        EnterSplSem();

        if (!pIniPrinter->MasqCache.bThreadRunning)
        {
            bCreateThread = TRUE;
            pIniPrinter->MasqCache.bThreadRunning = TRUE;

            INCPRINTERREF(pIniPrinter);
        }

        LeaveSplSem();

        SplOutSem();

        if (bCreateThread)
        {
            HANDLE                  hThread         = NULL;
            MasqUpdateThreadData    *pThreadData    = NULL;
            DWORD                   dwThreadId      = 0;

            pThreadData = AllocSplMem(sizeof(*pThreadData));

            bRet = pThreadData != NULL;

            if (bRet)
            {
                bRet = GetSid(&pThreadData->hUserToken);
            }

            if (bRet)
            {
                pThreadData->pIniPrinter = pIniPrinter;

                hThread = CreateThread(NULL, 0, AsyncPopulateMasqPrinterCache, (VOID *)pThreadData, 0, &dwThreadId);

                bRet = hThread != NULL;
            }

            if (bRet)
            {
                pThreadData = NULL;
            }

            //
            // If we couldn't create the thread, then drop the ref count on the
            // pIniPrinter again and set thread running to false.
            //
            if (!bRet)
            {
                EnterSplSem();

                pIniPrinter->MasqCache.bThreadRunning = FALSE;
                DECPRINTERREF(pIniPrinter);

                LeaveSplSem();
            }

            if (hThread)
            {
                CloseHandle(hThread);
            }

            if (pThreadData)
            {
                if (pThreadData->hUserToken)
                {
                    CloseHandle(pThreadData->hUserToken);
                }

                FreeSplMem(pThreadData);
            }
        }

        //
        // Check to see the cached error return for the printer.
        //
        if (bRet)
        {
            EnterSplSem();

            if (pIniPrinter->MasqCache.dwError != ERROR_SUCCESS)
            {
                SetLastError(pIniPrinter->MasqCache.dwError);

                bRet = FALSE;
            }

            //
            // Caller is only interested in the Status and cJobs members, all strings
            // are set to NULL by the allocation.
            //
            if (bRet)
            {
                pPrinterInfo2 = AllocSplMem(sizeof(PRINTER_INFO_2));

                bRet = pPrinterInfo2 != NULL;
            }

            if (bRet)
            {
                pPrinterInfo2->Status = pIniPrinter->MasqCache.Status;
                pPrinterInfo2->cJobs  = pIniPrinter->MasqCache.cJobs;

                *ppPrinterInfo = pPrinterInfo2;
                pPrinterInfo2 = NULL;
            }

            LeaveSplSem();
        }

        FreeSplMem(pPrinterInfo2);
    }

    return bRet;
}

/*++

Routine Name:

    GetPrinterInfoFromRouter

Description:

    This does a GetPrinter call against the router, it returns the error code
    as a status.

Arguments:

    hMasqPrinter    -   Handle to the masq printer.
    ppPrinterInfo   -   Returned printer info.

Returns:

    Status Code.

--*/
DWORD
GetPrinterInfoFromRouter(
    IN      HANDLE              hMasqPrinter,
        OUT PRINTER_INFO_2      **ppPrinterInfo
    )
{
    DWORD           Status = ERROR_SUCCESS;
    DWORD           cb     = 4096;
    PRINTER_INFO_2  *pPrinterInfo2 = NULL;
    DWORD           cbNeeded;

    SplOutSem();

    pPrinterInfo2 = AllocSplMem(cb);

    Status = pPrinterInfo2 != NULL ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;

    if (ERROR_SUCCESS == Status)
    {
        Status = GetPrinter(hMasqPrinter, 2, (BYTE *)pPrinterInfo2, cb, &cbNeeded) ? ERROR_SUCCESS : GetLastError();
    }

    if (ERROR_INSUFFICIENT_BUFFER == Status)
    {
        FreeSplMem(pPrinterInfo2);
        pPrinterInfo2 = NULL;

        cb = cbNeeded;

        pPrinterInfo2 = AllocSplMem(cb);

        Status = pPrinterInfo2 != NULL ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;

        if (ERROR_SUCCESS == Status)
        {
            Status = GetPrinter(hMasqPrinter, 2, (BYTE *)pPrinterInfo2, cb, &cbNeeded) ? ERROR_SUCCESS : GetLastError();
        }
    }

    if (ERROR_SUCCESS == Status)
    {
        *ppPrinterInfo = pPrinterInfo2;
        pPrinterInfo2 = NULL;
    }

    FreeSplMem(pPrinterInfo2);

    return Status;
}


/*++

Routine Name:

    AsyncPopulateMasqPrinterCache

Description:

    This populates the Masq printer cache for a given pIniPrinter.

Arguments:

    pvThreadData     -   Pointer to a MasqUpdateThreadData structure

Returns:

    A DWORD status, ignored.

--*/
DWORD
AsyncPopulateMasqPrinterCache(
    IN      VOID                *pvThreadData
    )
{
    DWORD                   Status          = ERROR_SUCCESS;
    PINIPRINTER             pIniPrinter     = NULL;
    PINIPORT                pIniPort        = NULL;
    PWSTR                   pszPrinterName  = NULL;
    HANDLE                  hMasqPrinter    = NULL;
    PRINTER_INFO_2          *pPrinterInfo2  = NULL;
    MasqUpdateThreadData    *pThreadData    = NULL;

    SplOutSem();

    pThreadData = (MasqUpdateThreadData *)pvThreadData;

    pIniPrinter = pThreadData->pIniPrinter;

    Status = SetCurrentSid(pThreadData->hUserToken) ? ERROR_SUCCESS : GetLastError();

    EnterSplSem();

    //
    // Find the port associated with the printer.
    //
    if (Status == ERROR_SUCCESS)
    {
        pIniPort = FindIniPortFromIniPrinter(pIniPrinter);

        Status = pIniPort && !(pIniPort->Status & PP_MONITOR) ? ERROR_SUCCESS : ERROR_INVALID_FUNCTION;
    }

    if (Status == ERROR_SUCCESS)
    {
        INCPORTREF(pIniPort);

        LeaveSplSem();

        SplOutSem();

        //
        // This relies on the fact that a masq port cannot be renamed.
        //
        if (OpenPrinterPortW(pIniPort->pName, &hMasqPrinter, NULL))
        {
            //
            // This will propogate any errors into the masq cache, which we
            // don't have to do twice, so we ignore the return code.
            //
            Status = GetPrinterInfoFromRouter(hMasqPrinter, &pPrinterInfo2);

            ClosePrinter(hMasqPrinter);
        }
        else
        {
            Status = GetLastError();

            if (Status == ERROR_SUCCESS)
            {
                Status = ERROR_UNEXP_NET_ERR;
            }
        }

        EnterSplSem();

        if (ERROR_SUCCESS == Status)
        {
            pIniPrinter->MasqCache.cJobs    = pPrinterInfo2->cJobs;
            pIniPrinter->MasqCache.Status   = pPrinterInfo2->Status;
        }
        else
        {
            pIniPrinter->MasqCache.cJobs = 0;
            pIniPrinter->MasqCache.Status = 0;
        }

        //
        // We always want to reset the status.
        //
        pIniPrinter->MasqCache.dwError = Status;


        DECPORTREF(pIniPort);
    }

    SplInSem();

    pIniPrinter->MasqCache.bThreadRunning = FALSE;
    DECPRINTERREF(pIniPrinter);

    DeletePrinterCheck(pIniPrinter);

    LeaveSplSem();

    if (pThreadData)
    {
        CloseHandle(pThreadData->hUserToken);
    }

    FreeSplMem(pThreadData);

    FreeSplMem(pPrinterInfo2);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetsrv\aspapp\ipp_util.inc ===
<%
'------------------------------------------------------------
'
' Microsoft Internet Printing Project
'
' Copyright (c) Microsoft Corporation. All rights reserved.
'
'------------------------------------------------------------
%>

<%

' Replace EN-US with localized language code. E.g. "HE" -- Hebrew.
Const L_Language            = "EN-US"

Const L_DocumentList_Text   = "Document List"
Const L_DerivedFont_Text    = " face=""Tahoma, Verdana, Arial, MS Sans Serif"" "
Const L_DoubleDevFont_Text  = " face=""""Tahoma, Verdana, Arial, MS Sans Serif"""" "

Const PROGID_CLIENT_HELPER  = "OlePrn.PrinterURL"
Const PROGID_SNMP           = "OlePrn.OleSNMP"
Const PROGID_HELPER         = "OlePrn.AspHelp"
Const PROGID_CONVERTER      = "OlePrn.OleCvt"
Const PROGID_ADDPRINTER     = "OlePrn.AddPrint"
Const VIEW_EQUALS           = "&view="
Const ONCLICK_EQUALS        = " onclick="
Const QUOTE                 = """"
Const QUEUE_VIEW            = "ipp_0007.asp"
Const PROPERTY_VIEW         = "ipp_0006.asp"
Const UNAUTHORIZED_401      = "401 Unauthorized"
Const FAXDRIVER             = "Microsoft Shared Fax Driver"

Const COMPUTER              = "MS_Computer"
Const LOCAL_SERVER          = "MS_LocalServer"
Const DHTML_ENABLED         = "MS_DHTMLEnabled"
Const DEFAULT_PAGE          = "MS_DefaultPage"
Const PRINTER               = "MS_Printer"
Const URLPRINTER            = "MS_URLPrinter"
Const SNMP                  = "MS_SNMP"
Const IPADDRESS             = "MS_IPAddress"
Const COMMUNITY             = "MS_Community"
Const DEVICE                = "MS_Device"
Const PORTNAME              = "MS_Portname"
Const MODEL                 = "MS_Model"
Const ASP1                  = "MS_ASP1"
Const CONNECT               = "showconnect"
Const ATPRINTER             = "&MS_Printer="
Const ATURLPRINTER          = "&MS_URLPrinter="
Const ATSNMP                = "&MS_SNMP="
Const ATIPADDRESS           = "&MS_IPAddress="
Const ATCOMMUNITY           = "&MS_Community="
Const ATDEVICE              = "&MS_Device="
Const ATPORTNAME            = "&MS_Portname="
Const ATMODEL               = "&MS_Model="
Const ATASP1                = "&MS_ASP1="
Const ATPAGE                = "&page="
Const ATCONNECT             = "&showconnect="

Dim   DEF_FONT, DEF_BASEFONT_TAG, DEF_FONT_TAG, LARGE_FONT_TAG, MENU_FONT_TAG
Dim   SUBMENU_FONT, SUBMENU_FONT_TAG, CLIENT_FONT, DEF_DOUBLEFONT, DEF_DOUBLEFONT_TAG

DEF_FONT                    = L_DerivedFont_Text
DEF_DOUBLEFONT              = L_DoubleDevFont_Text
DEF_BASEFONT_TAG            = "<basefont  " & L_DerivedFont_Text & " size=2>"
DEF_FONT_TAG                = "<font " & L_DerivedFont_Text & " size=2>"
LARGE_FONT_TAG              = "<font " & L_DerivedFont_Text & " size=4>"
MENU_FONT_TAG               = "<font " & L_DerivedFont_Text & " size=2 color=white>"
SUBMENU_FONT                = L_DerivedFont_Text & " size=1 "
SUBMENU_FONT_TAG            = "<font " & L_DerivedFont_Text & " size=2>"
CLIENT_FONT                 = "<font " & L_DerivedFont_Text & ">"
Const END_FONT              = "</font>"

Dim OleCvt
Set OleCvt = Server.CreateObject (PROGID_CONVERTER)
Session.Codepage = 65001

Function Write (strUnicode)
    Write = strUnicode
End Function

Function SubstituteString(strIn, strPattern, strReplacement)
    Dim iStrPos

    iStrPos = InStr(strIn,strPattern)
    SubstituteString = Left(strIn, iStrPos-1) & strReplacement & Mid(strIn, iStrPos + Len(strPattern))
End Function

Function RepString1( strIn, strRep )
    RepString1 = SubStituteString( strIn, "%1", strRep)
End Function

Function RepString2( strIn, strRep1, strRep2 )
    RepString2 = SubStituteString( RepString1(strIn, strRep1) , "%2", strRep2)
End Function

Function RepString3( strIn, strRep1, strRep2, strRep3 )
    RepString3 = SubStituteString( RepString2(strIn, strRep1, StrRep2), "%3", strRep3)
End Function

Function GenErrorPage (iCode, strSource, strDscp, strNote)
    Dim strHTML
    Const L_ErrCode_Text      = "<b>Error Code:</b>"
    Const L_ErrDscp_Text      = "<b>Description:</b>"
    Const L_ErrNote_Text      = "<b>Note:</b>"
    Const L_ErrTitle_Text     = "Internet Printing Error"
    Const L_ErrSource_Text    = "The error occurred in <b>%1</b>"
    Const L_ErrOccurProc_Text = "<p>An <b>error</b> occurred processing your request.</p>"

    strHTML = "<!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.0 Transitional//EN"">"
    strHTML = strHTML & "<html lang=" & L_Language & ">"
    strHTML = strHTML & "<head>"
    strHTML = strHTML & "<Meta Http-equiv=""Content-Type"" Content=""text/html; CHARSET=UTF-8"">"
    strHTML = strHTML & "<title>" & L_ErrTitle_Text & "</title>"
    strHTML = strHTML & "</head><body bgcolor=#FFFFFF>" & DEF_BASEFONT_TAG
    strHTML = strHTML & L_ErrOccurProc_Text

    If strSource <> "" Then
        strHTML = strHTML & RepString1(L_ErrSource_Text, strSource)
    End If

    strHTML = strHTML & "<table>"

    strHTML = strHTML & "<tr><td>" & L_ErrCode_Text & "</td><td>" & (Hex (iCode)) & "</td></tr>"

    If strDscp <> "" Then
        strHTML = strHTML & "<tr><td>" & L_ErrDscp_Text & "</td><td>" & strDscp & "</td></tr>"
    End If

    If strNote <> "" Then
        strHTML = strHTML & "<tr><td>" & L_ErrNote_Text & "</td><td>" & strNote & "</td></tr>"
    End If

    strHTML = strHTML & "</table></body></html>"
    GenErrorPage = strHTML
End Function

Sub ErrorHandler(strNotes)
    Dim strDscp, strSource

    Dim str401Error

    If Err.Number = 70 Or Err.Number = &H80070005 Then
        Const L_ErrTitle_Text = "Internet Printing Authentication Error"
        Const L_ErrTitle2_Text = "Authentication Failed"
        Const L_ErrLine1_Text = "The error indicates that the action you chose requires a higher privilege than what you have with your account."
        Const L_ErrLine2_Text = "Please contact your system administrator to verify that you have the privilege on the requested action."

        str401Error = "<!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.0 Transitional//EN"">" &_
            "<html lang=" & L_Language & ">" &_
            "<head>" &_
            "<Meta Http-equiv=""Content-Type"" Content=""text/html; CHARSET=UTF-8"">" &_
            "<title>" & L_ErrTitle_Text & "</title>" & "</head>" &_
            "<body bgcolor=#FFFFFF>" &_
            DEF_FONT_TAG &_
            "<p><H2>" & L_ErrTitle2_Text & "</H2></p>" &_
            "<p>" & L_ErrLine1_Text &_
            "<br>" &_
            "<br>" & L_ErrLine2_Text & "</p>" &_
            "</font></body></html>"
        response.write (Write(str401Error))
        response.status = UNAUTHORIZED_401
    Else
        If Err.Number = &H80070709 Then
            Const L_ErrInvalidName_Text = "Printer not found on server, unable to connect."
            Err.Description = L_ErrInvalidName_Text
        End If

        response.write(Write(GenErrorPage (Err.Number, Err.Source, Err.Description, strCleanString(strNotes))))
    End If
    response.Expires = 0
    response.end

End Sub

Function bDHTMLSupported()
    On Error Resume Next
    Err.Clear
    Dim objBrowcap

    Set objBrowcap = server.CreateObject("MSWC.browsertype")
    If Not Err And objBrowcap.browser = "IE" And objBrowcap.majorver >= "4" Then
        bDHTMLSupported = True
    Else
        bDHTMLSupported = False
    End If
End Function

Sub CheckSession()
    ' check to see if the session has timed out
    If Session(COMPUTER) = "" Then
        response.redirect ("ipp_0003.asp")
        response.end
    End If
End Sub

Function strPrinterStatus(iStatus)
    Dim L_PrinterStatus_Text(24)
    Const L_Seperator_Text = " - "
    Const L_PrinterReady_Text = "Ready"

    L_PrinterStatus_Text(0)  = "Paused"
    L_PrinterStatus_Text(1)  = "Error"
    L_PrinterStatus_Text(2)  = "Deleting"
    L_PrinterStatus_Text(3)  = "Paper Jam"
    L_PrinterStatus_Text(4)  = "Out of Paper"
    L_PrinterStatus_Text(5)  = "Manual Feed Required"
    L_PrinterStatus_Text(6)  = "Paper Problem"
    L_PrinterStatus_Text(7)  = "Printer Offline"
    L_PrinterStatus_Text(8)  = "IO Active"
    L_PrinterStatus_Text(9)  = "Busy"
    L_PrinterStatus_Text(10) = "Printing"
    L_PrinterStatus_Text(11) = "Output Bin Full"
    L_PrinterStatus_Text(12) = "Not Available"
    L_PrinterStatus_Text(13) = "Waiting"
    L_PrinterStatus_Text(14) = "Processing"
    L_PrinterStatus_Text(15) = "Initializing"
    L_PrinterStatus_Text(16) = "Warming Up"
    L_PrinterStatus_Text(17) = "Toner Low"
    L_PrinterStatus_Text(18) = "No Toner"
    L_PrinterStatus_Text(19) = "Page Punt"
    L_PrinterStatus_Text(20) = "User Intervention Required"
    L_PrinterStatus_Text(21) = "Out of Memory"
    L_PrinterStatus_Text(22) = "Door Open"
    L_PrinterStatus_Text(23) = "Server Status Unknown"
    L_PrinterStatus_Text(24) = "Power Save Mode"

    Dim bit, i
    bit = 1
    i = 0
    Dim strHTML, bFirst

    bFirst = True
    strHTML = ""

    For i = 0 To 24
    If iStatus And bit Then
        If Not bFirst Then
        strHTML = strHTML + L_Seperator_Text
        End If
        strHTML = strHTML + L_PrinterStatus_Text(i)
            bFirst = False
    End If
        bit = bit * 2
    Next
    If bFirst Then
        strHTML = "<font color=green>" & L_PrinterReady_Text & "</font>"
    Else
        strHTML = "<font color=red>" & strHTML & "</font>"
    End If

    strPrinterStatus = strHTML
End Function

Function strFormatJobSize(iJobSize)
    Const  L_Bytes_Text     = "%1 bytes"
    Const  L_KiloBytes_Text = "%1 Kb"
    Const  L_MegaBytes_Text = "%1 Mb"
	

    If iJobSize < 1024 Then
        strFormatJobSize = RepString1(L_Bytes_Text, CStr(iJobSize) )
    ElseIf iJobSize < 1048576 Then
        strFormatJobSize = RepString1(L_KiloBytes_Text, formatnumber(iJobSize / 1024, 1) )
    Else
        strFormatJobSize = RepString1(L_MegaBytes_Text, formatnumber(iJobSize / (1024 * 1024), 1) )
    End If
End Function

Function strFormatString(str)
    If str = "" Then
        strFormatString = "&nbsp;"
    Else
        strFormatString = str
    End If
End Function

Function strCleanString (str)

    Dim strClean, i, iLength, ch

    strClean = ""
    iLength = Len (str)

    For i = 1 To iLength
        ch = Mid (str, i, 1)

        Select Case ch
        Case "<"
            strClean = strClean & "&lt;"
        Case ">"
            strClean = strClean & "&gt;"
        Case """"
            strClean = strClean & "&quot;"
        Case "&"
            strClean = strClean & "&amp;"
        Case Else
            strClean = strClean & ch
        End Select
    Next
    strCleanString = strClean

End Function

Function strCleanRequest (str)

    strCleanRequest = strCleanString (Request(str))

End Function

Function JobEtaInfo (objPrinter)
    Dim strTime, iJobCount, iMinute
    Dim strHTML

    Const L_NoJobPending_Text = "&nbsp;&nbsp;&nbsp;&nbsp;<b>Waiting Time:</b> 0 <br><b>Pending Documents:</b> 0 "
    Const L_ErrorNoJobCompletion_Text = "<font color=red>Error in printing</font> "
    Const L_LongHour_Text = "> 8 hr"
    Const L_About_Text = "about "
    Const L_Hour_Text = " hr"
    Const L_Minute_Text = " min"

    Const L_QueueStatus_Text = "<b>Printer Queue:</b> "
    Const L_WaitingTime_Text = " &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Waiting Time:</b> "
    Const L_Unknown_Text = "Unknown"
    Const L_JobPending_Text = "<b>Pending Documents:</b> "
    Const L_AvgSize_Text = " &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Average size:</b> "
    Const L_Pages_Text =  " page(s)"


    strHTML = L_QueueStatus_Text & strPrinterStatus (objPrinter.Status) & L_WaitingTime_Text

    objPrinter.CalcJobETA

    If ( objPrinter.Status And &H9F ) Then
        strHTML = strHTML & L_Unknown_Text
    'End If
    'If 1 Then
    Else
        If objPrinter.PendingJobCount = 0 Then
            strHTML = strHTML & "0"
        Else
            iMinute = objPrinter.JobCompletionMinute
            'iMinute = 240  'For testing purpose
            If iMinute <> -1 Then
                If iMinute > 480 Then
                    strTime = L_LongHour_Text
                Elseif iMinute > 60 Then
                    strTime = L_About_Text & CStr (Int (iMinute / 60)) & L_Hour_Text
                Else
                    strTime = L_About_Text & CStr (iMinute) & L_Minute_Text
                End If
                strHTML = strHTML & strTime
            Else
                strHTML = strHTML & L_Unknown_Text
            End If
        End If
    End If

    strHTML = strHTML & "<br>"
    iJobCount = objPrinter.PendingJobCount
    strHTML = strHTML & L_JobPending_Text & CStr (iJobCount)

    If iJobCount > 0 Then
        strHTML = strHTML & L_AvgSize_Text
        If ObjPrinter.AvgJobSizeUnit = 1 Then 'Page
            strHTML = strHTML & CStr (ObjPrinter.AvgJobSize) + L_Pages_Text
        Else
            strHTML = strHTML & strFormatJobSize(ObjPrinter.AvgJobSize)
        End If
    End If

    JobEtaInfo = "<font " & DEF_FONT & "size= -1>" & strHTML & "</font>"

End Function

Function GetFriendlyName (strPrtName, strComputer)

    Dim lOffset, strServerName

    If Left (strPrtName, 2) = "\\" Then
        lOffset = InStr (3, strPrtName, "\")
        strServerName = Mid (strPrtName, 3, lOffset - 3)
        If strServerName = strComputer Then 'Cut the server name only if it is same as the computer name
            strPrtName = Mid (strPrtName, lOffset + 1)
        End If
    End If
    GetFriendlyName = strPrtName

End Function

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\inet.cxx ===
/*****************************************************************************\
* MODULE: inet.cxx
*
* The module contains routines for the setting up the WWW Printer Service during spooler start up.
*
* The entry point here should be called by localspl\init.c\InitializePrintProvidor() once it is done
* with its work.
*
* Copyright (C) 1996 Microsoft Corporation
*
* History:
*   Dec-1996   BabakJ     Wrote it for IIS 2.0.
*   June-1997  BabakJ     Rewrote to use IIS 4.0's new Metabase interface
*   Feb-1998   Weihaic    Modify the URL in default.htm
*   Feb 1999   BabakJ     Made metabase interface a global to avoi calling too many CoCreateInstance() for perfrmance.
\*****************************************************************************/

//
//
// Note: We cannot use precomp.h here since we requrie ATL which can only be included in C++ source files.
//
//


#define INITGUID     // Needed to do it to get GUID_NULL defined.

#include "precomp.h"
#pragma hdrstop

#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines

#define MY_META_TIMEOUT 1000

TCHAR const cszW3SvcRootPath[] = TEXT("/LM/W3svc/1/Root");
TCHAR const cszPrinters[]      = TEXT("Printers");
TCHAR const cszW3SvcReg[]      = TEXT("System\\CurrentControlSet\\Services\\W3SVC");


typedef enum
{
    kWebPrintingStateUnknown,
    kWebPrintingStateNotInstalled,
    kWebPrintingStateInstalled
} EWebPrintingState;

EWebPrintingState  WebPrintingInstalled = kWebPrintingStateUnknown;   // Gobal flag telling if WebPrinting is currently installed


class CWebShareData
{
public:
    LPWSTR m_pszShareName;
    BOOL   m_bSharePrinter;
    BOOL   m_bValid;
public:
    CWebShareData (LPWSTR pszShareName, BOOL bSharePrinter);
    ~CWebShareData ();
    int Compare (CWebShareData *pSecond)
    {
        return 0;
    };
};

class CWebShareList :
public CSingleList<CWebShareData*>
{
public:
    CWebShareList ()
    {
    };
    ~CWebShareList ()
    {
    };

    void WebSharePrinterList (IMSAdminBase *pIMetaBase);
};

HRESULT
AccessMetaBase(
              OUT  IMSAdminBase** ppIMetaBase
              );

void
ReleaseMetaBase(
               IN   IMSAdminBase** ppIMetaBase
               );

DWORD
ManageAllWebShares(
                   IN   IMSAdminBase*   pIMetaBase,
                   IN   PINISPOOLER     pIniSpooler,
                   IN   BOOL            bEnableWebShares
                   );

void
WebShareManagement(
                  IN   LPWSTR  pShareName,
                  IN   BOOL    bShare          // If TRUE, will share it, else unshare it.
                  );

HRESULT
IsWebPrintingInstalled(
                      IN   IMSAdminBase*  pIMetaBase
                      );

HRESULT
ProcessWebShare(
              IN   IMSAdminBase* pIMetaBase,
              IN   LPWSTR        pShareName,
              IN   BOOL          bCreateShare
              );

HRESULT
CreateVirtualDirForPrinterShare(
                               IN   IMSAdminBase *pIMetaBase,
                               IN   LPWSTR       pShareName
                               );

HRESULT
RemoveVirtualDirForPrinterShare(
                               IN   IMSAdminBase *pIMetaBase,
                               IN   LPWSTR       pShareName
                               );

DWORD
CheckWebPrinting(
                BOOL*  pbWebPrintingInstalled
                )
{
    HRESULT       hr         = S_OK;
    IMSAdminBase* pIMetaBase = NULL;
    *pbWebPrintingInstalled  = FALSE;

    //
    // If this is the first time we have called a Web function
    //  init the installed variable.
    //
    if (WebPrintingInstalled == kWebPrintingStateUnknown)
    {
        //
        // First get a MetaBase interface
        //
        hr = AccessMetaBase( &pIMetaBase );

        if (SUCCEEDED(hr))
        {
            hr = IsWebPrintingInstalled(pIMetaBase);
        }

        //
        // If we have a MetaBase interface free it and uninit COM.
        //
        ReleaseMetaBase(&pIMetaBase);
    }

    if (SUCCEEDED(hr))
    {
        *pbWebPrintingInstalled = (WebPrintingInstalled == kWebPrintingStateInstalled);
    }
    else
    {
        // Something failed so just set thstate to uninstalled but don't change the saved state,
        // so we will look again the next time this function is called
        *pbWebPrintingInstalled = FALSE;
    }

    return ERROR_SUCCESS;
}


DWORD
WebShareManager(
               IN   PINISPOOLER pIniSpooler,
               IN   BOOL        bEnableWebShares
               )
{
    IMSAdminBase*  pIMetaBase = NULL;
    HRESULT        hr;
    DWORD          dwRet = ERROR_SUCCESS;

    //
    // The IniSpooler needs to be from the local server
    //
    if ((pIniSpooler != NULL) &&
        (pIniSpooler != pLocalIniSpooler) )
    {
        dwRet = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Get an interface for the MetaBase
        //
        hr = AccessMetaBase( &pIMetaBase );

        if (SUCCEEDED(hr))
        {
            dwRet = ManageAllWebShares( pIMetaBase, pIniSpooler, bEnableWebShares );
            if (dwRet == ERROR_SUCCESS)
            {
                if (bEnableWebShares)
                    WebPrintingInstalled = kWebPrintingStateInstalled;
                else
                    WebPrintingInstalled = kWebPrintingStateNotInstalled;
            }
        }
        else
        {
            //
            // Did we fail beause the WWW Service is gone??
            //
            HKEY          hKey;
            if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, cszW3SvcReg, 0, KEY_READ, &hKey))
            {
                RegCloseKey( hKey );
                dwRet = HRESULT_CODE(hr);
            }
            else
            {
                WebPrintingInstalled = kWebPrintingStateNotInstalled;
                dwRet = ERROR_SUCCESS;
            }
        }

        ReleaseMetaBase(&pIMetaBase);
    }

    return dwRet;
}


/*++

Routine Name:
    AccessMetaBase

Routine Description:
    Open an interface handle to the IIS MetaBase

Arguments:
    ppIMetaBase - The Address of a MetaBase Interface pointer

Return Value:
    HRESULT

--*/
HRESULT
AccessMetaBase(
              OUT  IMSAdminBase** ppIMetaBase
              )
{
    HRESULT   hr;

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( SUCCEEDED(hr) )
    {
        hr = ::CoCreateInstance(CLSID_MSAdminBase,
                                NULL,
                                CLSCTX_ALL,
                                IID_IMSAdminBase,
                                (void **)ppIMetaBase);
        if (FAILED(hr))
        {
            CoUninitialize();
            *ppIMetaBase = NULL;
        }
    }

    return hr;
}


/*++

Routine Name:
    ReleaseMetaBase

Routine Description:
    Release an open interface handle to the IIS MetaBase and
    uninit COM.

Arguments:
    pIMetaBase - A MetaBase Interface pointer

Return Value:

--*/
void
ReleaseMetaBase(
               IN OUT  IMSAdminBase** ppIMetaBase
               )
{
    if (*ppIMetaBase)
    {
        (*ppIMetaBase)->Release();
        *ppIMetaBase = NULL;

        CoUninitialize();
    }
}

DWORD
ManageAllWebShares(
                   IMSAdminBase*   pIMetaBase,
                   PINISPOOLER     pIniSpooler,
                   BOOL            bEnableWebShares
                   )
{
    CWebShareList *pWebShareList = NULL;
    BOOL   bProcessedEntry = FALSE;
    PINIPRINTER   pIniPrinter;
    DWORD  dwRet = ERROR_SUCCESS;


    if ( pWebShareList = new CWebShareList () )
    {

        EnterSplSem();

        //
        // Update VDIRs for each shared printers.
        //  Either add or delete the VDIRS based on bEnableWebShares
        //

        for ( pIniPrinter = pIniSpooler->pIniPrinter;
            pIniPrinter;
            pIniPrinter = pIniPrinter->pNext )
        {
            if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED )
            {
                CWebShareData *pData = new CWebShareData (pIniPrinter->pShareName, bEnableWebShares);

                if ( pData && pData->m_bValid &&
                     pWebShareList->Insert (pData) )
                {
                    bProcessedEntry = TRUE;
                    continue;
                }
                else
                {
                    if ( pData )
                    {
                        delete pData;
                    }

                    break;
                }
            }
        }

        LeaveSplSem ();

        if ( bProcessedEntry )
        {
            pWebShareList->WebSharePrinterList (pIMetaBase);
        }

        delete pWebShareList;
    }
    else
        dwRet = GetLastError();

    return dwRet;
}


//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//
// Adding printer shares:
//
//  To support http://<server>/<share>, we create a virtual directory with a redirect property.
//
//
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================

//=====================================================================================================
//
//  This function may be called during initialization time after fW3SvcInstalled is set,
//  which means, a printer maybe webshared twice (once in InstallWebPrnSvcWorkerThread,
//  and the other time when WebShare () is calleb by  ShareThisPrinter() in net.c by
//  FinalInitAfterRouterInitCompleteThread () during localspl initialization time.
//
//=====================================================================================================

void
WebShare(
        LPWSTR pShareName
        )
{
    WebShareManagement( pShareName, TRUE );
}

//=====================================================================================================
//=====================================================================================================
//=====================================================================================================
//
// Removing printer shares
//
//
//=====================================================================================================
//=====================================================================================================
//=====================================================================================================

void
WebUnShare(
          LPWSTR pShareName
          )
{
    WebShareManagement( pShareName, FALSE );
}


void
WebShareManagement(
                  LPWSTR  pShareName,
                  BOOL    bShare          // If TRUE, will share it, else unshare it.
                  )
{
    HRESULT       hr         = S_OK;
    IMSAdminBase* pIMetaBase = NULL;

    //
    // If this is the first time we have called a Web function
    //  init the installed variable.
    //
    if (WebPrintingInstalled == kWebPrintingStateUnknown)
    {
        //
        // First get a MetaBase interface
        //
        hr = AccessMetaBase( &pIMetaBase );

        if (SUCCEEDED(hr))
        {
            hr = IsWebPrintingInstalled( pIMetaBase );
        }
    }

    if (SUCCEEDED(hr) &&
        (WebPrintingInstalled == kWebPrintingStateInstalled))
    {
        // If we don't have a metabase interface yet
        if (!pIMetaBase)
            hr = AccessMetaBase( &pIMetaBase );

        if (SUCCEEDED(hr))
           hr = ProcessWebShare( pIMetaBase, pShareName, bShare );
    }

    //
    // If we have a MetaBase interface free it and uninit COM.
    //
    ReleaseMetaBase(&pIMetaBase);
}

HRESULT
IsWebPrintingInstalled(
                      IMSAdminBase*   pIMetaBase
                      )
{
    BOOL            bInstalled = FALSE;

    WCHAR           szVirPath[MAX_PATH];
    HRESULT         hr;                 // com error status
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    DWORD           dwMDRequiredDataLen;
    METADATA_RECORD mr;


    // open key to ROOT on website #1 (default)
    hr = pIMetaBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                             cszW3SvcRootPath,
                             METADATA_PERMISSION_READ,
                             MY_META_TIMEOUT,
                             &hMeta);
    if ( SUCCEEDED( hr ) )
    {
        mr.dwMDIdentifier = MD_VR_PATH;
        mr.dwMDAttributes = 0;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = sizeof( szVirPath );
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szVirPath);

        // Read LM/W3Svc/1/Root/Printers see if MD_VR_PATH exists.
        hr = pIMetaBase->GetData( hMeta, cszPrinters, &mr, &dwMDRequiredDataLen );
        if ( SUCCEEDED(hr) )
        {
            WebPrintingInstalled = kWebPrintingStateInstalled;
        }
        else if ( HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND )
        {
            WebPrintingInstalled = kWebPrintingStateNotInstalled;
            hr = S_OK;
        }

        //
        // Close the Web Server Key
        //
        pIMetaBase->CloseKey( hMeta );
    }

    return hr;
}

HRESULT
ProcessWebShare(
              IMSAdminBase* pIMetaBase,
              LPWSTR        pShareName,
              BOOL          bCreateShare
              )
{
    HRESULT hr;                         // com error status

    if (bCreateShare)
        hr = CreateVirtualDirForPrinterShare( pIMetaBase, pShareName );
    else
        hr = RemoveVirtualDirForPrinterShare( pIMetaBase, pShareName );

    if (SUCCEEDED(hr))
    {
        // Flush out the changes and close
        // Call SaveData() after making bulk changes, do not call it on each update
        hr = pIMetaBase->SaveData();
    }

    return hr;
}


HRESULT
CreateVirtualDirForPrinterShare(
                               IMSAdminBase *pIMetaBase,
                               LPWSTR       pShareName
                               )
{
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    WCHAR   szOldURL[MAX_PATH];
    WCHAR   szPath[MAX_PATH];
    DWORD   dwMDRequiredDataLen;
    DWORD   dwAccessPerm;
    METADATA_RECORD mr;
    HRESULT hr;
    BOOL    fRet;


    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMetaBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                 cszW3SvcRootPath,
                                 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                 MY_META_TIMEOUT,
                                 &hMeta );

    // Create the key if it does not exist.
    if ( SUCCEEDED( hr ) )
    {
        mr.dwMDIdentifier = MD_HTTP_REDIRECT;
        mr.dwMDAttributes = 0;
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = sizeof( szOldURL );
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szOldURL);

        // Read LM/W3Svc/1/Root/Printers to see if MD_HTTP_REDIRECT exists.
        // Note that we are only concerned with the presence of the vir dir,
        // not any properties it might have.
        //
        hr = pIMetaBase->GetData( hMeta, pShareName, &mr, &dwMDRequiredDataLen );

        if ( FAILED( hr ) )
        {
            // Notice if the virtual dir exists, we won't touch it. One scenario is
            // if there is a name collision between a printer sharename and an existing,
            // unrelated virtual dir.
            if ( HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND )
            {

                // Write both the key and the values if GetData() failed with any of the two errors.
                pIMetaBase->AddKey( hMeta, pShareName );


                dwAccessPerm = MD_ACCESS_READ;

                mr.dwMDIdentifier = MD_ACCESS_PERM;
                mr.dwMDAttributes = 0;      // no need for inheritence
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = DWORD_METADATA;
                mr.dwMDDataLen    = sizeof(DWORD);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAccessPerm);

                // Write MD_ACCESS_PERM value
                hr = pIMetaBase->SetData( hMeta, pShareName, &mr );

                if (SUCCEEDED( hr ))
                {
                    PWCHAR  szKeyType = IIS_CLASS_WEB_VDIR_W;

                    mr.dwMDIdentifier = MD_KEY_TYPE;
                    mr.dwMDAttributes = 0;   // no need for inheritence
                    mr.dwMDUserType   = IIS_MD_UT_FILE;
                    mr.dwMDDataType   = STRING_METADATA;
                    mr.dwMDDataLen    = (wcslen(szKeyType) + 1) * sizeof(WCHAR);
                    mr.pbMDData       = reinterpret_cast<unsigned char *>(szKeyType);

                    // Write MD_DEFAULT_LOAD_FILE value
                    hr = pIMetaBase->SetData( hMeta, pShareName, &mr );
                }

                if (SUCCEEDED( hr ))
                {
                    WCHAR szURL[MAX_PATH];

                    hr = StringCchPrintf(szURL, COUNTOF(szURL), L"/printers/%ws/.printer", pShareName );

                    if ( SUCCEEDED(hr) )
                    {
                        mr.dwMDIdentifier = MD_HTTP_REDIRECT;
                        mr.dwMDAttributes = 0;   // no need for inheritence
                        mr.dwMDUserType   = IIS_MD_UT_FILE;
                        mr.dwMDDataType   = STRING_METADATA;
                        mr.dwMDDataLen    = (wcslen(szURL) + 1) * sizeof(WCHAR);
                        mr.pbMDData       = reinterpret_cast<unsigned char *>(szURL);

                        // Write MD_DEFAULT_LOAD_FILE value
                        hr = pIMetaBase->SetData( hMeta, pShareName, &mr );
                    }
                }
            }
        }

        pIMetaBase->CloseKey( hMeta );
    }

    return hr;
}

HRESULT
RemoveVirtualDirForPrinterShare(
                               IMSAdminBase *pIMetaBase,
                               LPWSTR       pShareName
                               )
{
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    HRESULT hr;


    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMetaBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                 cszW3SvcRootPath,
                                 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                 MY_META_TIMEOUT,
                                 &hMeta );

    // Create the key if it does not exist.
    if ( SUCCEEDED( hr ) )
    {
        pIMetaBase->DeleteKey( hMeta, pShareName );  // We don't check the retrun value since the key may already not exist and we could get an error for that reason.
        pIMetaBase->CloseKey( hMeta );
    }

    return hr;
}


CWebShareData::CWebShareData (LPWSTR pszShareName, BOOL bSharePrinter)
{
    m_bValid = FALSE;
    m_pszShareName = NULL;
    m_bSharePrinter = bSharePrinter;

    DWORD cchShareLen = lstrlen (pszShareName) +1;

    if ( m_pszShareName = new WCHAR[cchShareLen] )
    {

        StringCchCopy(m_pszShareName, cchShareLen, pszShareName);
        m_bValid = TRUE;
    }
}


CWebShareData::~CWebShareData ()
{
    if ( m_pszShareName )
    {
        delete [] m_pszShareName;
    }
}


void CWebShareList::WebSharePrinterList ( IMSAdminBase *pIMetaBase )
{
    CSingleItem<CWebShareData*> * pItem = m_Dummy.GetNext();

    CWebShareData * pData = NULL;

    while ( pItem && (pData = pItem->GetData ()) && pData->m_bValid )
    {
        (VOID) ProcessWebShare(pIMetaBase, pData->m_pszShareName, pData->m_bSharePrinter);
        pItem = pItem->GetNext ();
    }
}


PWSTR
GetPrinterUrl(
             PSPOOL  pSpool
             )
{
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    DWORD           cb;
    PWSTR           pszURL         = NULL;
    PWSTR           pszServerName  = NULL;
    LPWSTR          pszMachineName = NULL;
    HRESULT         hr;


    SplInSem();

    // http://machine/share
    if ( !pIniPrinter->pShareName )
    {
        goto error;
    }


    // Get FQDN of this machine

    //
    // Since we should not make a network call while holding the critical section, we
    // shall save all the needed variables and leave the CS, make the call and take it
    // back.
    //

    pszMachineName = AllocSplStr(pIniPrinter->pIniSpooler->pMachineName);
    if ( !pszMachineName )
    {
        goto error;
    }

    LeaveSplSem();
    SplOutSem();

    hr = GetDNSMachineName(pszMachineName+2, &pszServerName);

    EnterSplSem();

    if ( FAILED(hr) )
    {
        SetLastError(HRESULT_CODE(hr));
        goto error;
    }

    cb = 7 + wcslen(pszServerName);  // http://machine
    cb += 1 + wcslen(pIniPrinter->pShareName) + 1;  // /share + NULL
    cb *= sizeof(WCHAR);

    if ( pszURL = (PWSTR) AllocSplMem(cb) )
    {
        StringCbPrintf(pszURL, cb, L"http://%ws/%ws", pszServerName, pIniPrinter->pShareName);
    }

    error:

    FreeSplStr(pszServerName);
    FreeSplStr(pszMachineName);

    return pszURL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\job.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    job.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:
    MattFe 23-Feb-96 JobInfo3

--*/

#include <precomp.h>
#pragma hdrstop

#include <offsets.h>
#include "jobid.h"
#include "filepool.hxx"

#define JOB_STATUS_INTERNAL 0
#define JOB_STATUS_EXTERNAL 1

DWORD SettableJobStatusMappings[] = {

//  INTERNAL:               EXTERNAL:

    JOB_PAUSED,             JOB_STATUS_PAUSED,
    JOB_ERROR,              JOB_STATUS_ERROR,
    JOB_OFFLINE,            JOB_STATUS_OFFLINE,
    JOB_PAPEROUT,           JOB_STATUS_PAPEROUT,
    0,                      0
};

DWORD ReadableJobStatusMappings[] = {

//  INTERNAL:               EXTERNAL:

    JOB_PAUSED,             JOB_STATUS_PAUSED,
    JOB_ERROR,              JOB_STATUS_ERROR,
    JOB_PENDING_DELETION,   JOB_STATUS_DELETING,
    JOB_SPOOLING,           JOB_STATUS_SPOOLING,
    JOB_PRINTING,           JOB_STATUS_PRINTING,
    JOB_COMPLETE,           JOB_STATUS_COMPLETE,
    JOB_OFFLINE,            JOB_STATUS_OFFLINE,
    JOB_PAPEROUT,           JOB_STATUS_PAPEROUT,
    JOB_PRINTED,            JOB_STATUS_PRINTED,
    JOB_BLOCKED_DEVQ,       JOB_STATUS_BLOCKED_DEVQ,
    JOB_DELETED,            JOB_STATUS_DELETED,
    JOB_HIDDEN,             JOB_STATUS_DELETED,
    JOB_RESTART,            JOB_STATUS_RESTART,
    0,                      0
};

DWORD gdwZombieCount = 0;


DWORD
MapJobStatus(
    DWORD Type,
    DWORD SourceStatus)
{
    DWORD  TargetStatus;
    PDWORD pMappings;
    INT   MapFrom;
    INT   MapTo;

    if (Type == MAP_READABLE) {

        MapFrom = JOB_STATUS_INTERNAL;
        MapTo = JOB_STATUS_EXTERNAL;

        pMappings = ReadableJobStatusMappings;

    } else {

        MapFrom = JOB_STATUS_EXTERNAL;
        MapTo = JOB_STATUS_INTERNAL;

        pMappings = SettableJobStatusMappings;
    }

    TargetStatus = 0;

    while(*pMappings) {

        if (SourceStatus & pMappings[MapFrom])
            TargetStatus |= pMappings[MapTo];

        pMappings += 2;
    }

    return TargetStatus;
}


PINIJOB
FindJob(
   PINIPRINTER pIniPrinter,
   DWORD JobId,
   PDWORD pPosition)
{
   PINIJOB pIniJob;

   SplInSem();

   for (pIniJob = pIniPrinter->pIniFirstJob, *pPosition = 1;
        pIniJob;
        pIniJob = pIniJob->pIniNextJob, (*pPosition)++) {

      if (pIniJob->JobId == JobId)
         return pIniJob;
   }

   *pPosition = JOB_POSITION_UNSPECIFIED;
   return (NULL);
}

PINIJOB
FindServerJob(
    PINISPOOLER pIniSpooler,
    DWORD JobId,
    PDWORD pdwPosition,
    PINIPRINTER* ppIniPrinter
    )

/*++

Routine Description:

    Finds a pIniJob, position, and pIniPrinter based on a JobId and
    pIniSpooler.  This works because JobIds are unique across pIniSpoolers.

Arguments:

    pIniSpooler - pIniSpooler to search

    JobId - Job to search for.

    pdwPosition - When a valid pIniJob is returned, this is the position in
        the queue of the returned job.

    ppIniPrinter - When a valid pIniJob is returned, this is the queue
        that the job belongs to.

Return Value:

    PINIJOB if success,
    NULL if not found (LastError NOT set)

--*/

{
    DWORD dwPosition;
    PINIJOB pIniJob;

    SplInSem();

    for( *ppIniPrinter = pIniSpooler->pIniPrinter;
         *ppIniPrinter;
         *ppIniPrinter = (*ppIniPrinter)->pNext ){

        if( pIniJob = FindJob( *ppIniPrinter, JobId, pdwPosition )){

            return pIniJob;
        }
    }
    return NULL;
}

PINIJOB
FindIniJob (
    PSPOOL pSpool,
    DWORD  JobId
)
{
    PINIJOB     pIniJob = NULL;
    PINIPRINTER pIniPrinter = NULL;
    DWORD       dwPosition;

    if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER)
    {
        //
        // If it's a server handle, then search all jobs on this spooler.
        // This call also retrieves the pIniPrinter associated
        // with a print job. pIniPrinter is not needed, but FindServerJob
        // requires a valid pointer.
        //
        pIniJob = FindServerJob(pSpool->pIniSpooler,
                                JobId,
                                &dwPosition,
                                &pIniPrinter);
    }
    else
    {
        pIniJob = FindJob(pSpool->pIniPrinter, JobId, &dwPosition);
    }

    return pIniJob;
}

DWORD
GetJobSessionId (
    PSPOOL pSpool,
    DWORD  JobId
)
{
    DWORD   SessionId = -1;
    PINIJOB pIniJob = NULL;

    EnterSplSem();

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER))
    {
        pIniJob = FindIniJob(pSpool, JobId);

        if (pIniJob)
        {
            SessionId = pIniJob->SessionId;
        }
    }

    LeaveSplSem();

    return SessionId;
}

BOOL
SetJobPosition(
    PINIJOB pIniSetJob,
    DWORD   NewPosition
)
{
   PINIJOB pIniJob;
   PINIJOB pIniPrevJob;
   DWORD   Position;
   PINISPOOLER pIniSpooler = NULL;

    SPLASSERT( pIniSetJob != NULL );
    SPLASSERT( pIniSetJob->pIniPrinter != NULL );
    SPLASSERT( pIniSetJob->pIniPrinter->pIniSpooler != NULL );

    pIniSpooler = pIniSetJob->pIniPrinter->pIniSpooler;

SplInSem();

   /* Remove this job from the linked list, and
    * link the jobs either side of the one we're repositioning:
    */
   if (pIniSetJob->pIniPrevJob)
       pIniSetJob->pIniPrevJob->pIniNextJob = pIniSetJob->pIniNextJob;
   else
       pIniSetJob->pIniPrinter->pIniFirstJob = pIniSetJob->pIniNextJob;

   if (pIniSetJob->pIniNextJob)
       pIniSetJob->pIniNextJob->pIniPrevJob = pIniSetJob->pIniPrevJob;
   else
       pIniSetJob->pIniPrinter->pIniLastJob = pIniSetJob->pIniPrevJob;


   pIniJob = pIniSetJob->pIniPrinter->pIniFirstJob;
   pIniPrevJob = NULL;

   /* Find the new position for the job:
    */
   Position = 1;

   while (pIniJob && (Position < NewPosition)) {

       pIniPrevJob = pIniJob;
       pIniJob = pIniJob->pIniNextJob;

       Position++;
   }


   /* If we're at position 1, pIniPrevJob == NULL,
    * if we're at the end of the list, pIniJob == NULL.
    */

   /* Now fix up the new links:
    */
   pIniSetJob->pIniPrevJob = pIniPrevJob;
   pIniSetJob->pIniNextJob = pIniJob;

   if (pIniPrevJob)
       pIniPrevJob->pIniNextJob = pIniSetJob;
   else
       pIniSetJob->pIniPrinter->pIniFirstJob = pIniSetJob;

   if (pIniSetJob->pIniNextJob)
       pIniSetJob->pIniNextJob->pIniPrevJob = pIniSetJob;
   else
       pIniSetJob->pIniPrinter->pIniLastJob = pIniSetJob;


   INCJOBREF( pIniSetJob );

   LogJobInfo(
       pIniSpooler,
       MSG_DOCUMENT_POSITION_CHANGED,
       pIniSetJob->JobId,
       pIniSetJob->pDocument,
       pIniSetJob->pUser,
       pIniSetJob->pIniPrinter->pName,
       NewPosition
       );

   DECJOBREF( pIniSetJob );

   return TRUE;
}


#if DBG
/* For the debug message:
 */
#define HOUR_FROM_MINUTES(Time)     ((Time) / 60)
#define MINUTE_FROM_MINUTES(Time)   ((Time) % 60)

/* Format for %02d:%02d replaceable string:
 */
#define FORMAT_HOUR_MIN(Time)       HOUR_FROM_MINUTES(Time),    \
                                    MINUTE_FROM_MINUTES(Time)
#endif


BOOL
ValidateJobTimes(
    PINIJOB      pIniJob,
    LPJOB_INFO_2 pJob2
)
{
    BOOL        TimesAreValid = FALSE;
    PINIPRINTER pIniPrinter;

    pIniPrinter = pIniJob->pIniPrinter;

    DBGMSG(DBG_TRACE, ("Validating job times\n"
                       "\tPrinter hours: %02d:%02d to %02d:%02d\n"
                       "\tJob hours:     %02d:%02d to %02d:%02d\n",
                       FORMAT_HOUR_MIN(pIniPrinter->StartTime),
                       FORMAT_HOUR_MIN(pIniPrinter->UntilTime),
                       FORMAT_HOUR_MIN(pJob2->StartTime),
                       FORMAT_HOUR_MIN(pJob2->UntilTime)));

    if ((pJob2->StartTime < ONEDAY) && (pJob2->UntilTime < ONEDAY)) {

        if ((pJob2->StartTime == pIniJob->StartTime)
          &&(pJob2->UntilTime == pIniJob->UntilTime)) {

            DBGMSG(DBG_TRACE, ("Times are unchanged\n"));

            TimesAreValid = TRUE;

        } else {

            /* New time must be wholly within the window between StartTime
             * and UntilTime of the printer.
             */
            if (pIniPrinter->StartTime > pIniPrinter->UntilTime) {

                /* E.g. StartTime = 20:00
                 *      UntilTime = 06:00
                 *
                 * This spans midnight, so check we're not in the period
                 * between UntilTime and StartTime:
                 */
                if (pJob2->StartTime > pJob2->UntilTime) {

                    /* This appears to span midnight too.
                     * Make sure the window fits in the printer's window:
                     */
                    if ((pJob2->StartTime >= pIniPrinter->StartTime)
                      &&(pJob2->UntilTime <= pIniPrinter->UntilTime)) {

                        TimesAreValid = TRUE;

                    } else {

                        DBGMSG(DBG_TRACE, ("Failed test 2\n"));
                    }

                } else {

                    if ((pJob2->StartTime >= pIniPrinter->StartTime)
                      &&(pJob2->UntilTime > pIniPrinter->StartTime)) {

                        TimesAreValid = TRUE;

                    } else if ((pJob2->UntilTime < pIniPrinter->UntilTime)
                             &&(pJob2->StartTime < pIniPrinter->UntilTime)) {

                        TimesAreValid = TRUE;

                    } else {

                        DBGMSG(DBG_TRACE, ("Failed test 3\n"));
                    }
                }

            } else if (pIniPrinter->StartTime < pIniPrinter->UntilTime) {

                /* E.g. StartTime = 08:00
                 *      UntilTime = 18:00
                 */
                if ((pJob2->StartTime >= pIniPrinter->StartTime)
                  &&(pJob2->UntilTime <= pIniPrinter->UntilTime)
                  &&(pJob2->StartTime <= pJob2->UntilTime)) {

                    TimesAreValid = TRUE;

                } else {

                    DBGMSG(DBG_TRACE, ("Failed test 4\n"));
                }

            } else {

                /* Printer times  are round the clock:
                 */
                TimesAreValid = TRUE;
            }
        }

    } else {

        TimesAreValid = FALSE;
    }

    DBGMSG(DBG_TRACE, ("Times are %svalid\n", TimesAreValid ? "" : "in"));

    return TimesAreValid;
}

/*++

Routine Name:

    CircularChainedJobsList

Routine Description:

    Check if chaining 2 jobs together will cause us to have a circular chain of jobs.
    This thing is not allowed.

Arguments:

    pIniJob     - pointer to the job that we want to link
    pNextIniJob - pointer to the job to which we want to link

Return Value:

    TRUE  - if chaining the jobs together builds a circular list
    FALSE - if chaining the jobs together is allowed

Last Error:

    None

--*/
BOOL
CircularChainedJobsList(
    IN PINIJOB pIniJob,
    IN PINIJOB pNextIniJob
    )
{
    BOOL  bCircular = FALSE;

    //
    // Validate input parameters
    //
    if (pIniJob && pNextIniJob)
    {
        DWORD Position;

        //
        // Traverse chained list of jobs. Try to arrive from pNextIniJob->JobId to pIniJob->JobId
        //
        while (pNextIniJob = FindJob(pIniJob->pIniPrinter, pNextIniJob->NextJobId, &Position))
        {
            DBGMSG(DBG_TRACE, ("CircularChainedJobsList job %u\n", pNextIniJob->JobId));

            if (pNextIniJob->JobId == pIniJob->JobId)
            {
                bCircular = TRUE;

                break;
            }
        }
    }

    return bCircular;
}

DWORD
SetLocalJob(
    HANDLE  hPrinter,
    PINIJOB pIniJob,
    DWORD   Level,
    LPBYTE  pJob
    )

/*++

Routine Description:

    Sets information about a localspl job.

Arguments:

    hPrinter - Handle to printer OR server.  Since this is could be a
        server, the pSpool->pIniPrinter is not always valid!

        Use pIniJob->pIniPrinter instead of pSpool->pIniPrinter.

    pIniJob - Job that should be set

    Level - Level of pJob structure

    pJob - New information to set

Return Value:

    ERROR_SUCCESS for success, else error code.

Notes:

    The 3.51 spooler has been changed to accept server handles since
    net\dosprint\dosprtw.c does not have a printername, just a job id.
    This relies on the fact that job ids are unique across a pIniSpooler.

    To move a job with a server pSpool, you need administrative access
    on the server handle.

    The TotalPages and PagesPrinted fields can no longer be set.
    Otherwise, users can change the number of pages in their jobs to 0,
    and get charged a lot less (some people charge based on eventlog
    pagecounts).  Also, hpmon does a GetJob/SetJob to set the status,
    and sometimes the page count changes between the Get and Set.

--*/

{
    LPJOB_INFO_2 pJob2 = (PJOB_INFO_2)pJob;
    LPJOB_INFO_1 pJob1 = (PJOB_INFO_1)pJob;
    LPJOB_INFO_3 pJob3 = (PJOB_INFO_3)pJob;
    PINIPRINTPROC pIniPrintProc;
    PINIJOB pOldJob;
    DWORD   OldJobId;
    PINIJOB pNextIniJob;
    DWORD   dwPosition;
    DWORD   ReturnValue = ERROR_SUCCESS;
    LPDEVMODE   pDevMode;

    PINISPOOLER     pIniSpooler     = NULL;
    PINIENVIRONMENT pIniEnvironment = NULL;

    PSPOOL pSpool = (PSPOOL)hPrinter;
    DWORD OldStatus;
    DWORD dwJobVector = 0;

    NOTIFYVECTOR NotifyVector;
    ZERONV(NotifyVector);


    SplInSem();

    switch (Level) {

    case 1:

        if (!pJob1->pDatatype ||
            !CheckDataTypes(pIniJob->pIniPrintProc, pJob1->pDatatype)) {

            return ERROR_INVALID_DATATYPE;
        }

        if (pJob1->Position != JOB_POSITION_UNSPECIFIED) {

            //
            // Check for Administer privilege on the printer
            // if the guy wants to reorder the job:
            //
            if (!AccessGranted(SPOOLER_OBJECT_PRINTER,
                               PRINTER_ACCESS_ADMINISTER,
                               pSpool)) {
                return ERROR_ACCESS_DENIED;
            }

            SetJobPosition(pIniJob, pJob1->Position);
            dwJobVector |= BIT(I_JOB_POSITION);
        }

        if (pJob1->Priority <= MAX_PRIORITY) {

            if (pIniJob->Priority != pJob1->Priority) {
                pIniJob->Priority = pJob1->Priority;
                dwJobVector |= BIT(I_JOB_PRIORITY);
            }
        }

        if (UpdateString(&pIniJob->pUser, pJob1->pUserName)) {
            dwJobVector |= BIT(I_JOB_USER_NAME);
        }

        if (UpdateString(&pIniJob->pDocument, pJob1->pDocument)) {
            dwJobVector |= BIT(I_JOB_DOCUMENT);
        }

        if (UpdateString(&pIniJob->pDatatype, pJob1->pDatatype)) {
            dwJobVector |= BIT(I_JOB_DATATYPE);
        }

        if (UpdateString(&pIniJob->pStatus, pJob1->pStatus)) {
            dwJobVector |= BIT(I_JOB_STATUS_STRING);
        }

        OldStatus = pIniJob->Status;
        InterlockedAnd((LONG*)&(pIniJob->Status), JOB_STATUS_PRIVATE);

        InterlockedOr((LONG*)&(pIniJob->Status),
                       MapJobStatus(MAP_SETTABLE,pJob1->Status));

        if (OldStatus != pIniJob->Status) {
            dwJobVector |= BIT(I_JOB_STATUS);
        }

        break;

    case 2:

        //
        // The local spooler and cluster spooler do not share the same Environment structures.
        //
        pIniEnvironment = GetLocalArchEnv(pIniJob->pIniPrinter->pIniSpooler);

        pIniPrintProc = FindPrintProc(pJob2->pPrintProcessor, pIniEnvironment);

        if (!pIniPrintProc) {

            return ERROR_UNKNOWN_PRINTPROCESSOR;
        }

        if( !pJob2->pDatatype ||
            !CheckDataTypes(pIniPrintProc, pJob2->pDatatype)) {

            return ERROR_INVALID_DATATYPE;
        }

        if (pJob2->Position != JOB_POSITION_UNSPECIFIED) {

            //
            // Check for Administer privilege on the printer
            // if the guy wants to reorder the job:
            //
            if (!AccessGranted(SPOOLER_OBJECT_PRINTER,
                               PRINTER_ACCESS_ADMINISTER,
                               pSpool)) {
                return ERROR_ACCESS_DENIED;
            }
        }


        if (ValidateJobTimes(pIniJob, pJob2)) {

            if (pIniJob->StartTime != pJob2->StartTime) {

                pIniJob->StartTime = pJob2->StartTime;
                dwJobVector |= BIT(I_JOB_START_TIME);
            }

            if (pIniJob->UntilTime != pJob2->UntilTime) {

                pIniJob->UntilTime = pJob2->UntilTime;
                dwJobVector |= BIT(I_JOB_UNTIL_TIME);
            }

        } else {

            return ERROR_INVALID_TIME;
        }


        if (pJob2->Position != JOB_POSITION_UNSPECIFIED) {

            SetJobPosition(pIniJob, pJob2->Position);
            dwJobVector |= BIT(I_JOB_POSITION);
        }

        //
        // We really need some error returns here.
        //
        if (pJob2->Priority <= MAX_PRIORITY) {

            if (pIniJob->Priority != pJob2->Priority) {

                pIniJob->Priority = pJob2->Priority;
                dwJobVector |= BIT(I_JOB_PRIORITY);
            }
        }

        if (pIniJob->pIniPrintProc != pIniPrintProc) {

            pIniJob->pIniPrintProc->cRef--;
            pIniJob->pIniPrintProc = pIniPrintProc;
            pIniJob->pIniPrintProc->cRef++;

            dwJobVector |= BIT(I_JOB_PRINT_PROCESSOR);
        }

        if (UpdateString(&pIniJob->pUser, pJob2->pUserName)) {
            dwJobVector |= BIT(I_JOB_USER_NAME);
        }
        if (UpdateString(&pIniJob->pDocument, pJob2->pDocument)) {
            dwJobVector |= BIT(I_JOB_DOCUMENT);
        }
        if (UpdateString(&pIniJob->pNotify, pJob2->pNotifyName)) {
            dwJobVector |= BIT(I_JOB_NOTIFY_NAME);
        }
        if (UpdateString(&pIniJob->pDatatype, pJob2->pDatatype)) {
            dwJobVector |= BIT(I_JOB_DATATYPE);
        }
        if (UpdateString(&pIniJob->pParameters, pJob2->pParameters)) {
            dwJobVector |= BIT(I_JOB_PARAMETERS);
        }

        if (UpdateString(&pIniJob->pStatus, pJob2->pStatus)) {
            dwJobVector |= BIT(I_JOB_STATUS_STRING);
        }

        OldStatus = pIniJob->Status;
        InterlockedAnd((LONG*)&(pIniJob->Status), JOB_STATUS_PRIVATE);

        InterlockedOr((LONG*)&(pIniJob->Status),
                       MapJobStatus(MAP_SETTABLE, pJob2->Status));

        if (OldStatus != pIniJob->Status) {
            dwJobVector |= BIT(I_JOB_STATUS);
        }

        break;

    case 3:

        //  SetJob with Job_info_3
        //  The goal is to tell the scheduler the printer order of jobs
        //  so that they can be chained together.   This is first implemented
        //  so that FAX applications can print multiple cover sheets and point to
        //  the same print document.   Each cover sheet / FAX job might be successful
        //  or might fail to print - so status will be shown against the MasterJob
        //  the first job in the chain.
        //  Subsequent Jobs in the chain are then considered to be part of the main document.

        SplInSem();

        // Validate that the NextJob exists

        pNextIniJob = FindJob( pIniJob->pIniPrinter, pJob3->NextJobId, &dwPosition );

        //
        // Check for Errors. Note that we only chain jobs that have the same data type.
        // Also, once you chain a job, you can't chain it to a different job anymore
        //
        if (pNextIniJob        == NULL          ||
            pNextIniJob        == pIniJob       ||
            pIniJob->JobId     != pJob3->JobId  ||
            pJob3->Reserved    != 0             ||
            pIniJob->NextJobId != 0             ||
            CircularChainedJobsList(pIniJob, pNextIniJob) ||
            _wcsicmp(pIniJob->pDatatype, pNextIniJob->pDatatype)) {

            return ERROR_INVALID_PARAMETER;
        }

        //
        //  Check Access to the chained job
        //

        if ( !ValidateObjectAccess( SPOOLER_OBJECT_DOCUMENT,
                                    JOB_ACCESS_ADMINISTER,
                                    pNextIniJob,
                                    NULL,
                                    pNextIniJob->pIniPrinter->pIniSpooler ) ) {

            DBGMSG( DBG_WARNING,
                    ( "LocalSetJob failed ValidateObjectAccess JobId %d pNextIniJob %x, error %d\n",
                      pNextIniJob->JobId, pNextIniJob, GetLastError()));

            return GetLastError();
        }

        if ( (pIniJob->Status & JOB_DESPOOLING) ||
             (pNextIniJob->Status & JOB_DESPOOLING) ) {

            return ERROR_INVALID_PRINTER_STATE;
        }

        //
        // Save Old Pointer, incase we want to delete it.
        //

        OldJobId = pIniJob->NextJobId;

        // Point the Current Job to user specified new job
        // and increment its reference count.

        pIniJob->NextJobId = pJob3->NextJobId;
        pNextIniJob->Status |= ( JOB_COMPOUND | JOB_HIDDEN );
        INCJOBREF( pNextIniJob );

        //
        // Page count/Size for the head job should include the other job also
        //
        pIniJob->cPages += pNextIniJob->cPages;
        pIniJob->Size   += pNextIniJob->Size;

        // If there was an old reference then decrement its reference count
        // check for deletion.

        if ( OldJobId ) {

            pOldJob = FindJob( pIniJob->pIniPrinter, OldJobId, &dwPosition );

            DECJOBREF( pOldJob );

            if ( (pOldJob->Status & JOB_COMPOUND) &&
                 (pOldJob->cRef == 0) ) {

                pOldJob->Status &= ~( JOB_COMPOUND | JOB_HIDDEN );

                WriteShadowJob(pOldJob, FALSE);
            }

            DeleteJobCheck( pOldJob );
        }

        //
        //  Hide the Compound Job from the UI, by making it look deleted
        //

        SetPrinterChange( pNextIniJob->pIniPrinter,
                          pNextIniJob,
                          NVDeletedJob,
                          PRINTER_CHANGE_DELETE_JOB | PRINTER_CHANGE_SET_PRINTER,
                          pNextIniJob->pIniPrinter->pIniSpooler );

        break;

    }

    //
    // Log an event if the priority of the job changed
    //
    if (dwJobVector & BIT(I_JOB_PRIORITY))  {

        LogJobInfo(pIniJob->pIniPrinter->pIniSpooler,
                   MSG_DOCUMENT_PRIORITY_CHANGED,
                   pIniJob->JobId,
                   pIniJob->pDocument,
                   pIniJob->pUser,
                   pIniJob->pIniPrinter->pName,
                   pIniJob->Priority);
    }

    CHECK_SCHEDULER();

    NotifyVector[JOB_NOTIFY_TYPE] = dwJobVector;

    SetPrinterChange(pIniJob->pIniPrinter,
                     pIniJob,
                     NotifyVector,
                     PRINTER_CHANGE_SET_JOB,
                     pSpool->pIniSpooler);

    //
    //  if something important changed in the Job
    //  we should update the shadowjob
    //

    if ( pIniJob &&
         ( Level == 3 ||
         ( dwJobVector & ~(BIT(I_JOB_STATUS_STRING))))) {

        WriteShadowJob( pIniJob, FALSE );
    }

    return NO_ERROR;
}


BOOL
PauseJob(
    PINIJOB pIniJob)
{
    PINISPOOLER pIniSpooler = NULL;
    PINIPORT    pIniPort    = NULL;
    BOOL        ReturnValue = TRUE;

    SplInSem();

    InterlockedOr((LONG*)&(pIniJob->Status), JOB_PAUSED);
    WriteShadowJob(pIniJob, FALSE);

    if(pIniJob->pIniPrintProc)
    {
        INCJOBREF(pIniJob);

        if (pIniJob->pIniPort && !(pIniJob->pIniPort->InCriticalSection & PRINTPROC_PAUSE))
        {
            //
            // Capture the pIniPort so that the InCriticalSection operations we
            // apply to it are at least consistent.
            //
            pIniPort = pIniJob->pIniPort;

            INCPORTREF(pIniPort);

            LeaveSplSem();
            EnterCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);
            EnterSplSem();

            pIniPort->InCriticalSection |= PRINTPROC_PAUSE;

            if (pIniJob->Status & JOB_PRINTING )
            {
                if (pIniPort->hProc)
                {
                    LeaveSplSem();
                    ReturnValue = (*pIniJob->pIniPrintProc->Control)(pIniPort->hProc, JOB_CONTROL_PAUSE );
                    EnterSplSem();
                }

            }

            pIniPort->InCriticalSection &= ~PRINTPROC_PAUSE;

            LeaveCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);

            DECPORTREF(pIniPort);
        }

        DECJOBREF(pIniJob);
    }


    DBGMSG( DBG_INFO, ( "Paused Job %d; Status = %08x\n", pIniJob->JobId, pIniJob->Status ) );

    SPLASSERT( pIniJob != NULL &&
               pIniJob->pIniPrinter != NULL &&
               pIniJob->pIniPrinter->pIniSpooler != NULL );

    pIniSpooler = pIniJob->pIniPrinter->pIniSpooler;

    INCJOBREF( pIniJob );

    LogJobInfo(
        pIniSpooler,
        MSG_DOCUMENT_PAUSED,
        pIniJob->JobId,
        pIniJob->pDocument,
        pIniJob->pUser,
        pIniJob->pIniPrinter->pName,
        0);

    DECJOBREF( pIniJob );

    return ReturnValue;
}

BOOL
ResumeJob(
    PINIJOB pIniJob
)
{
    PINISPOOLER pIniSpooler     = NULL;
    PINIPORT    pIniPort        = NULL;
    BOOL        ReturnValue     = TRUE;
    BOOL        CheckSchedular  = FALSE;

    SplInSem();

    InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_PAUSED);
    WriteShadowJob(pIniJob, FALSE);


    if(pIniJob->pIniPrintProc)
    {
        INCJOBREF(pIniJob);

        if (pIniJob->pIniPort && !(pIniJob->pIniPort->InCriticalSection & PRINTPROC_RESUME))
        {
            pIniPort = pIniJob->pIniPort;

            INCPORTREF(pIniPort);

            LeaveSplSem();
            EnterCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);
            EnterSplSem();

            pIniPort->InCriticalSection |= PRINTPROC_RESUME;

            if ( pIniJob->Status & JOB_PRINTING)
            {
                if ( pIniPort->hProc )
                {
                    LeaveSplSem();
                    ReturnValue = (*pIniJob->pIniPrintProc->Control)(pIniPort->hProc, JOB_CONTROL_RESUME);
                    EnterSplSem();
                }

            }
            else
            {
                CheckSchedular = TRUE;
            }

            pIniPort->InCriticalSection &= ~PRINTPROC_RESUME;

            LeaveCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);

            DECPORTREF(pIniPort);
        }

        DECJOBREF(pIniJob);
    }
    else
    {
        CheckSchedular = TRUE;
    }

    if(CheckSchedular)
    {
        CHECK_SCHEDULER();
    }


    DBGMSG( DBG_INFO, ( "Resumed Job %d; Status = %08x\n", pIniJob->JobId, pIniJob->Status ) );

    SPLASSERT( pIniJob != NULL &&
               pIniJob->pIniPrinter != NULL &&
               pIniJob->pIniPrinter->pIniSpooler != NULL );

    pIniSpooler = pIniJob->pIniPrinter->pIniSpooler;

    INCJOBREF( pIniJob );

    LogJobInfo(
        pIniSpooler,
        MSG_DOCUMENT_RESUMED,
        pIniJob->JobId,
        pIniJob->pDocument,
        pIniJob->pUser,
        pIniJob->pIniPrinter->pName,
        0);


    DECJOBREF( pIniJob );

    return ReturnValue;
}

DWORD
RestartJob(
    PINIJOB pIniJob
)
{

    //
    // If the job is pending deletion can't restart. Monitor could call this
    // when there is a port error to reprint the job. If user has already
    // deleted the job this should fail
    //
    if ( pIniJob->Status & JOB_PENDING_DELETION )
        return ERROR_INVALID_PARAMETER;

    //
    // A job can be restarted only if:
    // it is currently printing or
    // it is printed or sent to printer.
    //
    if (!(pIniJob->Status & JOB_PRINTING) && !(pIniJob->Status & JOB_PRINTED) && !(pIniJob->Status & JOB_COMPLETE))
    {
        return ERROR_SUCCESS;
    }

    //  JOB_PRINTING - means you have a print processor open
    //  JOB_DESPOOLING - means a job have been scheduled, it might be PRINTING
    //  or might have completed PRINTING but we are still logging etc.
    //  So be careful if you alter the JOB_PRINTING flag to know everywhere
    //  it is used.

    InterlockedOr((LONG*)&(pIniJob->Status), JOB_RESTART);

    if (pIniJob->pIniPort)
    {
        pIniJob->pIniPort->InCriticalSection = 0;
    }

    // Release any thread waiting on SeekPrinter
    SeekPrinterSetEvent(pIniJob, NULL, TRUE);

    // Release any thread waiting on LocalSetPort
    SetPortErrorEvent(pIniJob->pIniPort);

    //
    //  JOB_DESPOOLING and JOB_RESTART are checked in the PortThread port.c
    //

    if (!( pIniJob->Status & JOB_DESPOOLING )) {

        InterlockedAnd((LONG*)&(pIniJob->Status), ~( JOB_PRINTED | JOB_BLOCKED_DEVQ | JOB_COMPLETE));
        //
        // Reset cbPrinted and cPagesPrinted.
        //
        pIniJob->cbPrinted = 0;
        pIniJob->cPagesPrinted = 0;
    }

    if ( pIniJob->Status & JOB_TIMEOUT ) {
        InterlockedAnd((LONG*)&(pIniJob->Status), ~( JOB_TIMEOUT | JOB_ABANDON ));
        FreeSplStr( pIniJob->pStatus );
        pIniJob->pStatus = NULL;
    }

    SetPrinterChange(pIniJob->pIniPrinter,
                     pIniJob,
                     NVJobStatusAndString,
                     PRINTER_CHANGE_SET_JOB,
                     pIniJob->pIniPrinter->pIniSpooler);

    CHECK_SCHEDULER();

    DBGMSG( DBG_INFO, ( "Restarted Job %d; Status = %08x\n", pIniJob->JobId, pIniJob->Status ) );

    return 0;
}








BOOL
LocalSetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD Command
    )

/*++

Routine Description:

    This function will modify the settings of the specified Print Job.

Arguments:

    hPrinter - Handle to printer OR server.  Since this is could be a
        server, the pSpool->pIniPrinter is not always valid!

        Use pIniJob->pIniPrinter instead of pSpool->pIniPrinter.

    pJob - Points to a valid JOB structure containing at least a valid
        pPrinter, and JobId.

    Command - Specifies the operation to perform on the specified Job. A value
        of FALSE indicates that only the elements of the JOB structure are to
        be examined and set.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PINIJOB pIniJob = NULL;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   LastError = 0;
    DWORD   Position;
    BOOL    rc;
    PINISPOOLER pIniSpooler = NULL;
    PINIPRINTER pIniPrinter = NULL;
    LPWSTR pszDatatype = NULL;
    BOOL bValidDatatype = TRUE;

    DBGMSG( DBG_TRACE, ( "ENTER LocalSetJob\n" ) );

    //
    // We only allow RAW to go to downlevel machines (StartDocPrinter
    // already checks this).  We need to check this here since
    // the AddJob optimization tries to send an non-RAW (EMF) file, and
    // downlevel servers don't like that.
    //
    switch( Level ){
    case 1:
        pszDatatype = ((PJOB_INFO_1)pJob)->pDatatype;
        break;
    case 2:
        pszDatatype = ((PJOB_INFO_2)pJob)->pDatatype;
        break;
    default:

        //
        // 0 and 3 are the only other valid levels.
        //
        SPLASSERT( Level == 0 || Level == 3 );
        break;
    }

    EnterSplSem();

    if ( ValidateSpoolHandle(pSpool, 0 ) ) {

        pIniSpooler = pSpool->pIniSpooler;

        if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {

            //
            // If it's a server handle, then search all jobs on this spooler.
            // This call also retrieves the pIniPrinter associated
            // with a print job.
            //
            pIniJob = FindServerJob( pIniSpooler,
                                     JobId,
                                     &Position,
                                     &pIniPrinter );

        } else if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR)) {

            //
            // It's a masq printer.  Send the call to the port RPC handle.
            //
            hPrinter = pSpool->hPort;

            if( pszDatatype ){
                bValidDatatype = ValidRawDatatype( pszDatatype );
            }

           LeaveSplSem();

            if( bValidDatatype ){
                rc = SetJob(hPrinter, JobId, Level, pJob, Command);
            } else {
                rc = FALSE;
                SetLastError( ERROR_INVALID_DATATYPE );
            }

            DBGMSG( DBG_TRACE, ( "EXIT LocalSetJob, rc = %d, %d", rc, GetLastError( ) ) );
            return rc;

        } else {

            //
            // It's a regular printer handle.
            //
            SPLASSERT( pSpool->pIniPrinter->pIniSpooler != NULL );
            SPLASSERT( pSpool->pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );
            SPLASSERT( pSpool->pIniPrinter->pIniSpooler == pSpool->pIniSpooler );

            pIniPrinter = pSpool->pIniPrinter;
            pIniJob = FindJob( pIniPrinter, JobId, &Position );
        }

        if ( pIniJob ){

            DWORD dwError;
            BOOL  bGrantAccess;

            //
            // If we are changing the datatype, and this is a RAW_ONLY
            // printer, and the datatype is not a valid RAW datatype,
            // then fail the call.
            //
            if( pszDatatype &&
                ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_RAW_ONLY ) &&
                !ValidRawDatatype( pszDatatype )){

                SetLastError( ERROR_INVALID_DATATYPE );
                LeaveSplSem();

                DBGMSG( DBG_TRACE, ( "Failed to set to non-RAW datatype (RAW_ONLY)\n" ));
                return FALSE;
            }

            //
            // If the LocalSetJob comes from inside the spooler, it won't come over RPC.
            // The monitor calls SetJob when the job printed so the spooler will let go
            // of the job. If we grant printing but not manage doc privileges to a principal
            // then the monitor loaded in the context of the user won't have access to set
            // the job. In this case, if the LocalSetJob comes from within the spooler, we
            // grant privileges.
            //
            bGrantAccess = !IsCallViaRPC();

            if ( bGrantAccess ||
                 ValidateObjectAccess(SPOOLER_OBJECT_DOCUMENT,
                                      (Command == JOB_CONTROL_CANCEL ||
                                       Command == JOB_CONTROL_DELETE) ?
                                      DELETE : JOB_ACCESS_ADMINISTER,
                                      pIniJob, NULL, pIniSpooler ) ) {

                switch (Command) {
                case 0:
                    break;
                case JOB_CONTROL_PAUSE:
                    //
                    // WMI Trace Event
                    //
                    INCJOBREF(pIniJob);
                    LeaveSplSem();
                    LogWmiTraceEvent(pIniJob->JobId, EVENT_TRACE_TYPE_SPL_PAUSE, NULL);
                    EnterSplSem();
                    DECJOBREF(pIniJob);
                    PauseJob(pIniJob);
                    break;
                case JOB_CONTROL_RESUME:
                    //
                    // WMI Trace Event
                    //
                    INCJOBREF(pIniJob);
                    LeaveSplSem();
                    LogWmiTraceEvent(pIniJob->JobId, EVENT_TRACE_TYPE_SPL_RESUME, NULL);
                    EnterSplSem();
                    DECJOBREF(pIniJob);
                    ResumeJob(pIniJob);
                    break;
                //
                // JOB_CONTROL_DELETE is meant to delete the job.
                // So remove the JOB_RESTART bit and delete the job
                //
                case JOB_CONTROL_DELETE:
                    InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_RESTART);
                    // Fall thru
                    pIniJob->dwJobControlsPending = 0;
                    DeleteJob(pIniJob,BROADCAST);
                    break;
                case JOB_CONTROL_CANCEL:
                    //
                    // JOB_CONTROL_CANCEL was used by old print monitors
                    // because of that we can't remove the JOB_RESTART bit
                    //
                    //
                    // Reset dwJobControlsPending
                    // Some old port monitors at EndDoc call SetJob with
                    // JOB_CONTROL_CANCEL instead of JOB_CONTROL_SENT_TO_PRINTER,
                    // Because of this, dwJobControlsPending is not decremented
                    // and the job doesn't get deleted after printing.
                    //
                    // If we are printing RAW, then we can't use the number of
                    // pages printed, we use the number of bytes printed instead.
                    //
                    if (!(pIniJob->Status & (JOB_INTERRUPTED | JOB_SPOOLING | JOB_ERROR | JOB_PAPEROUT | JOB_OFFLINE))) {

                        InterlockedOr((LONG*)&(pIniJob->Status), JOB_PRINTED);
                        InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_COMPLETE);

                        if ( !(pIniJob->Status & JOB_RESTART) &&
                             pIniJob->pCurrentIniJob == NULL ) {

                            INCJOBREF(pIniJob);
                            LeaveSplSem();

                            if (!(pIniJob->dwAlert & JOB_NO_ALERT)) {
                                SendJobAlert(pIniJob);
                            }

                            EnterSplSem();
                            DECJOBREF(pIniJob);
                        }
                    }

                    InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_INTERRUPTED);
                    pIniJob->dwJobControlsPending = 0;
                    DeleteJob(pIniJob,BROADCAST);
                    break;
                case JOB_CONTROL_RESTART:
                    if (!(pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT))
                    {
                        //
                        // WMI Trace Event.
                        //
                        INCJOBREF(pIniJob);
                        LeaveSplSem();
                        LogWmiTraceEvent(pIniJob->JobId,
                                         EVENT_TRACE_TYPE_SPL_SPOOLJOB,
                                         NULL);
                        EnterSplSem();
                        DECJOBREF(pIniJob);
                        LastError = RestartJob( pIniJob );
                    }
                    else
                        LastError = ERROR_INVALID_PRINTER_COMMAND;
                    break;

                //
                // With the addition of these commands port monitors should
                // send JOB_CONTROL_SENT_TO_PRINTER when last byte is written
                // to printer, and language monitor (if there is one) should
                // send JOB_CONTROL_LAST_PAGE_EJECTED when the last page
                // has ejected
                //
                case JOB_CONTROL_SENT_TO_PRINTER:
                case JOB_CONTROL_LAST_PAGE_EJECTED:

#if DBG
                    if( !(pIniJob->dwJobControlsPending > 0)){
                        DBGMSG( DBG_WARN, ( "LocalSetJob: dwJobsControlsPending > 0\n" ));
                    }
#endif
                    if ( --pIniJob->dwJobControlsPending ) {
                        //
                        // We still have controls pending, so do nothing
                        //


                    } else {

                        if (!(pIniJob->Status & (JOB_INTERRUPTED | JOB_SPOOLING | JOB_ERROR | JOB_PAPEROUT | JOB_OFFLINE))){

                            if ((Command == JOB_CONTROL_SENT_TO_PRINTER &&
                                 !(pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_BIDI)) ||
                                (Command == JOB_CONTROL_LAST_PAGE_EJECTED)) {

                                InterlockedOr((LONG*)&(pIniJob->Status), JOB_PRINTED);
                                InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_COMPLETE);

                                if ( !(pIniJob->Status & JOB_RESTART) &&
                                     pIniJob->pCurrentIniJob == NULL ) {

                                    INCJOBREF(pIniJob);
                                    LeaveSplSem();

                                    if (!(pIniJob->dwAlert & JOB_NO_ALERT)) {
                                        SendJobAlert(pIniJob);
                                    }

                                    EnterSplSem();
                                    DECJOBREF(pIniJob);
                                }
                            }

                            InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_INTERRUPTED);
                        }

                        if ( pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS ) {

                            if ( pIniJob->pStatus ) {

                                FreeSplStr(pIniJob->pStatus);
                                pIniJob->pStatus    = NULL;

                                SetPrinterChange(pIniJob->pIniPrinter,
                                                 pIniJob,
                                                 NVJobStatusAndString,
                                                 PRINTER_CHANGE_SET_JOB,
                                                 pIniJob->pIniPrinter->pIniSpooler );
                            }

                        } else if ( pIniJob->pCurrentIniJob == NULL ||
                                    pIniJob->pCurrentIniJob->NextJobId == 0 ) {

                            DeleteJob(pIniJob,BROADCAST);
                        }
                    }
                    break;

                default:
                    LastError = ERROR_INVALID_PARAMETER;
                    break;
                }

                // If we managed to successfully complete the operation
                // specified by Command, let's go do the set job
                // properties as well.

                if (!LastError) {

                    // We must re-validate our pointers as we might have left
                    // our semaphore

                    if( pIniJob = FindJob( pIniPrinter, JobId, &Position )){
                        LastError = SetLocalJob( hPrinter,
                                                 pIniJob,
                                                 Level,
                                                 pJob );
                    }
                }

            } else

                LastError = GetLastError();
        } else

            LastError = ERROR_INVALID_PARAMETER;
    } else

        LastError = ERROR_INVALID_HANDLE;


    if (LastError) {

        SetLastError(LastError);

        DBGMSG( DBG_TRACE, ( "EXIT LocalSetJob, rc = FALSE, JobID %d, Status %08x, Error %d\n",
                             pIniJob ? pIniJob->JobId : 0,
                             pIniJob ? pIniJob->Status : 0,
                             LastError ) );
    } else {

        //
        // (DeleteJob calls SetPrinterChange; so does SetLocalJob)
        //
        if ( Command &&
             pIniJob != NULL ) {

            SetPrinterChange(pIniPrinter,
                             pIniJob,
                             NVJobStatus,
                             PRINTER_CHANGE_SET_JOB,
                             pSpool->pIniSpooler );
        }

        DBGMSG( DBG_TRACE, ( "EXIT LocalSetJob, rc = TRUE, JobID %d, Status %08x\n",
                             pIniJob ? pIniJob->JobId : 0,
                             pIniJob ? pIniJob->Status : 0 ) );
    }

    if ( pIniJob ) {
        DeleteJobCheck(pIniJob);
    }

    LeaveSplSem();

    return LastError==ERROR_SUCCESS;
}

#define Nullstrlen(psz)  ((psz) ? wcslen(psz)*sizeof(WCHAR)+sizeof(WCHAR) : 0)

DWORD
GetJobSize(
    DWORD   Level,
    PINIJOB pIniJob
)
{
    DWORD   cb;

SplInSem();

    switch (Level) {

    case 1:
        cb = sizeof(JOB_INFO_1) +
             wcslen(pIniJob->pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pIniJob->pMachineName) +
             Nullstrlen(pIniJob->pUser) +
             Nullstrlen(pIniJob->pDocument) +
             Nullstrlen(pIniJob->pDatatype) +
             Nullstrlen(pIniJob->pStatus);
        break;

    case 2:
        cb = sizeof(JOB_INFO_2) +
             wcslen(pIniJob->pIniPrinter->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pIniJob->pMachineName) +
             Nullstrlen(pIniJob->pUser) +
             Nullstrlen(pIniJob->pDocument) +
             Nullstrlen(pIniJob->pNotify) +
             Nullstrlen(pIniJob->pDatatype) +
             wcslen(pIniJob->pIniPrintProc->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pIniJob->pParameters) +
             wcslen(pIniJob->pIniPrinter->pIniDriver->pName)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pIniJob->pStatus);

        if (pIniJob->pDevMode) {
            cb += pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra;
            cb = (cb + sizeof(ULONG_PTR)-1) & ~(sizeof(ULONG_PTR)-1);
        }

        break;

    case 3:
        cb = sizeof(JOB_INFO_3);
        break;

    default:

        cb = 0;
        break;
    }

    return cb;
}

LPBYTE
CopyIniJobToJob(
    PINIJOB pIniJob,
    DWORD   Level,
    LPBYTE  pJobInfo,
    LPBYTE  pEnd,
    LPBOOL  pbSuccess
)
{
    LPWSTR *pSourceStrings, *SourceStrings;
    LPJOB_INFO_2 pJob = (PJOB_INFO_2)pJobInfo;
    LPJOB_INFO_2 pJob2 = (PJOB_INFO_2)pJobInfo;
    LPJOB_INFO_1 pJob1 = (PJOB_INFO_1)pJobInfo;
    LPJOB_INFO_3 pJob3 = (PJOB_INFO_3)pJobInfo;
    DWORD   i, Status;
    DWORD   *pOffsets;

    *pbSuccess = FALSE;

SplInSem();

    switch (Level) {

    case 1:
        pOffsets = JobInfo1Strings;
        break;

    case 2:
        pOffsets = JobInfo2Strings;
        break;

    case 3:
        pOffsets = JobInfo3Strings;
        break;

    default:
        return pEnd;
    }

    Status = MapJobStatus(MAP_READABLE,
                          pIniJob->Status);

    for (i=0; pOffsets[i] != -1; i++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(i * sizeof(LPWSTR));

    if ( pSourceStrings ) {

        switch ( Level ) {

        case 1:

            pJob1->JobId        = pIniJob->JobId;

            *pSourceStrings ++= pIniJob->pIniPrinter->pName;
            *pSourceStrings ++= pIniJob->pMachineName;
            *pSourceStrings ++= pIniJob->pUser;
            *pSourceStrings ++= pIniJob->pDocument;
            *pSourceStrings ++= pIniJob->pDatatype;
            *pSourceStrings ++= pIniJob->pStatus;

            pJob1->Status       = Status;
            pJob1->Priority     = pIniJob->Priority;
            pJob1->Position     = 0;
            pJob1->TotalPages   = pIniJob->cPages;
            pJob1->PagesPrinted = pIniJob->cPagesPrinted;
            pJob1->Submitted    = pIniJob->Submitted;

            // If this job is Printing then report back size remaining
            // rather than the job size.   This will allow users to see
            // progress of print jobs from printmanage.

            if (pIniJob->Status & JOB_PRINTING) {

                // For Remote Jobs we are NOT going to have an accurate
                // cPagesPrinted since we are not rendering on the
                // server.   So we have to figure out an estimate

                if ((pIniJob->Status & JOB_REMOTE) &&
                    (pIniJob->cPagesPrinted == 0) &&
                    (pIniJob->Size != 0) &&
                    (pIniJob->cPages != 0)) {

                    pJob1->PagesPrinted = ((pIniJob->cPages * pIniJob->cbPrinted) / pIniJob->Size);

                }

                if (pJob1->TotalPages < pIniJob->cPagesPrinted) {

                    //
                    // Never let the total pages drop below zero.
                    //
                    pJob1->TotalPages = 0;

                } else {

                    pJob1->TotalPages -= pIniJob->cPagesPrinted;
                }
            }
            break;

        case 2:

            pJob2->JobId = pIniJob->JobId;

            *pSourceStrings ++= pIniJob->pIniPrinter->pName;
            *pSourceStrings ++= pIniJob->pMachineName;
            *pSourceStrings ++= pIniJob->pUser;
            *pSourceStrings ++= pIniJob->pDocument;
            *pSourceStrings ++= pIniJob->pNotify;
            *pSourceStrings ++= pIniJob->pDatatype;
            *pSourceStrings ++= pIniJob->pIniPrintProc->pName;
            *pSourceStrings ++= pIniJob->pParameters;
            *pSourceStrings ++= pIniJob->pIniPrinter->pIniDriver->pName;
            *pSourceStrings ++= pIniJob->pStatus;

            if (pIniJob->pDevMode) {

                pEnd -= pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra;

                pEnd = (LPBYTE)ALIGN_PTR_DOWN(pEnd);

                pJob2->pDevMode = (LPDEVMODE)pEnd;

                CopyMemory(pJob2->pDevMode, pIniJob->pDevMode, pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra );

            } else {

                pJob2->pDevMode = NULL;

            }

            pJob2->pSecurityDescriptor = NULL;            // Not Supported.

            pJob2->Status       = Status;
            pJob2->Priority     = pIniJob->Priority;
            pJob2->Position     = 0;
            pJob2->StartTime    = pIniJob->StartTime;
            pJob2->UntilTime    = pIniJob->UntilTime;
            pJob2->TotalPages   = pIniJob->cPages;
            pJob2->Size         = pIniJob->Size;
            pJob2->Submitted    = pIniJob->Submitted;
            pJob2->Time         = pIniJob->Time;
            pJob2->PagesPrinted = pIniJob->cPagesPrinted;

            // If this job is Printing then report back size remaining
            // rather than the job size.   This will allow users to see
            // progress of print jobs from printmanage.

            if ( pIniJob->Status & JOB_PRINTING ) {

                pJob2->Size -= pIniJob->cbPrinted;

                // For Remote Jobs we are NOT going to have an accurate
                // cPagesPrinted since we are not rendering on the
                // server.   So we have to figure out an estimate

                if ((pIniJob->Status & JOB_REMOTE) &&
                    (pIniJob->cPagesPrinted == 0) &&
                    (pIniJob->Size != 0) &&
                    (pIniJob->cPages != 0)) {

                    pJob2->PagesPrinted = ((pIniJob->cPages * pIniJob->cbPrinted) / pIniJob->Size);

                }

                if (pJob2->TotalPages < pJob2->PagesPrinted) {

                    //
                    // Never let the total pages drop below zero.
                    //
                    pJob2->TotalPages = 0;

                } else {

                    pJob2->TotalPages -= pJob2->PagesPrinted;
                }
            }

            break;

        case 3:

            pJob3->JobId = pIniJob->JobId;

            if ( pIniJob->pCurrentIniJob == NULL ) {

                pJob3->NextJobId = pIniJob->NextJobId;

            } else {

                //
                //  If we are currently Printing this Job, then the
                //  FAX Monitor Needs to know if there is another job
                //  to know where we are in the chain of jobs
                //

                pJob3->NextJobId = pIniJob->pCurrentIniJob->NextJobId;
            }


            break;


        default:
            return pEnd;
        }

        pEnd = PackStrings( SourceStrings, pJobInfo, pOffsets, pEnd );

        FreeSplMem( SourceStrings );

        *pbSuccess = TRUE;

    } else {

        DBGMSG( DBG_WARNING, ("Failed to alloc Job source strings."));
    }

    return pEnd;
}

BOOL
LocalGetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)

/*++

Routine Description:

    This function will retrieve the settings of the specified Print Job.

Arguments:

    hPrinter - Handle to printer OR server.  Since this is could be a
        server, the pSpool->pIniPrinter is not always valid!  Use
        pIniJob->pIniPrinter instead of pSpool->pIniPrinter.

    pJob - Points to a valid JOB structure containing at least a valid
        pPrinter, and JobId.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.
--*/

{
    PINIJOB     pIniJob;
    DWORD       Position;
    DWORD       cb;
    LPBYTE      pEnd;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    DWORD       LastError=0;
    PINIPRINTER pIniPrinter;
    BOOL        bSuccess;

   EnterSplSem();

    if ( ValidateSpoolHandle(pSpool, 0 )) {

        if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {

            //
            // If it's a server handle, then search all jobs on this spooler.
            // This call also retrieves the pIniPrinter associated
            // with a print job.
            //
            pIniJob = FindServerJob( pSpool->pIniSpooler,
                                     JobId,
                                     &Position,
                                     &pIniPrinter );

        } else if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR)) {

            //
            // It's a masq printer.  Send the call to the port RPC handle.
            //
            hPrinter = pSpool->hPort;
           LeaveSplSem();

            return GetJob(hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded);

        } else {

            //
            // It's a regular printer handle.
            //
            pIniPrinter = pSpool->pIniPrinter;
            pIniJob = FindJob( pIniPrinter, JobId, &Position);
        }

        if( pIniJob ){

            cb=GetJobSize(Level, pIniJob);

            *pcbNeeded=cb;

            if (cbBuf >= cb) {

                pEnd = pJob+cbBuf;

                CopyIniJobToJob(pIniJob, Level, pJob, pEnd, &bSuccess);

                if (bSuccess) {

                    switch (Level) {
                    case 1:
                        ((PJOB_INFO_1)pJob)->Position = Position;
                        break;
                    case 2:
                        ((PJOB_INFO_2)pJob)->Position = Position;
                        break;
                    }

                } else

                    LastError = ERROR_NOT_ENOUGH_MEMORY;

            } else

                LastError = ERROR_INSUFFICIENT_BUFFER;

        } else

            LastError = ERROR_INVALID_PARAMETER;
    } else

        LastError = ERROR_INVALID_HANDLE;

   LeaveSplSem();
    SplOutSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}

// This will simply return the first port that is found that has a
// connection to this printer

PINIPORT
FindIniPortFromIniPrinter(
    PINIPRINTER pIniPrinter
)
{
    PINIPORT    pIniPort;
    DWORD       i;

    SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );
    SPLASSERT( pIniPrinter->pIniSpooler != NULL );
    SPLASSERT( pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );

    pIniPort = pIniPrinter->pIniSpooler->pIniPort;

    while (pIniPort) {

        for (i=0; i<pIniPort->cPrinters; i++) {

            if (pIniPort->ppIniPrinter[i] == pIniPrinter) {
                return pIniPort;
            }
        }

        pIniPort = pIniPort->pNext;
    }

    return NULL;
}

BOOL
LocalEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINIJOB pIniJob;
    PINIJOB pIniFirstJob;
    DWORD   cb;
    LPBYTE  pEnd;
    DWORD   cJobs;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   Position;
    DWORD   LastError=0;
    BOOL    bSuccess;

    *pcbNeeded = 0;
    *pcReturned = 0;

    SplOutSem();
   EnterSplSem();

    if ( ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {

        if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR)) {

            hPrinter = pSpool->hPort;

           LeaveSplSem();

            return EnumJobs(hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf,
                            pcbNeeded, pcReturned);
        }

        cb = 0;

        //
        //  Find the first Job
        //

        for ( pIniFirstJob = pSpool->pIniPrinter->pIniFirstJob, cJobs = FirstJob;
              pIniFirstJob && cJobs;
              pIniFirstJob = pIniFirstJob->pIniNextJob ) {

            if ( !( pIniFirstJob->Status & JOB_HIDDEN ) || Level == 3 )
                cJobs--;

        }

        //
        //  Calc size required
        //

        for ( pIniJob = pIniFirstJob, cJobs = NoJobs;
              pIniJob && cJobs;
              pIniJob = pIniJob->pIniNextJob ) {

            if ( !( pIniJob->Status & JOB_HIDDEN ) || Level == 3 ) {
                cb += GetJobSize( Level, pIniJob );
                cJobs--;
            }
        }

        *pcbNeeded = cb;

        if ( cb <= cbBuf ) {

            pEnd = pJob + cbBuf;
            *pcReturned = 0;


            //
            //  Copy in all the Job info into the Users Buffer
            //

            for ( pIniJob = pIniFirstJob, cJobs = NoJobs, Position = FirstJob;
                  pIniJob && cJobs;
                  pIniJob = pIniJob->pIniNextJob ) {


                //
                //  Hide Chained Jobs, unless requesting chaining info
                //

                if ( !( pIniJob->Status & JOB_HIDDEN ) || Level == 3 ) {

                    pEnd = CopyIniJobToJob( pIniJob, Level, pJob, pEnd, &bSuccess );

                    if (!bSuccess) {

                        LastError = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }

                    Position++;

                    switch (Level) {

                        case 1:
                            ((PJOB_INFO_1)pJob)->Position = Position;
                            pJob += sizeof(JOB_INFO_1);
                            break;

                        case 2:
                            ((PJOB_INFO_2)pJob)->Position = Position;
                            pJob += sizeof(JOB_INFO_2);
                            break;

                        case 3:
                            pJob += sizeof(JOB_INFO_3);
                            break;
                    }

                    cJobs--;
                    (*pcReturned)++;
                }
            }

        } else

            LastError = ERROR_INSUFFICIENT_BUFFER;

    } else

        LastError = ERROR_INVALID_HANDLE;

   LeaveSplSem();
    SplOutSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}


#define BUFFER_LENGTH   10
VOID LogJobPrinted(
    PINIJOB pIniJob
)
{
    WCHAR szJobId[BUFFER_LENGTH];
    WCHAR szSize[BUFFER_LENGTH];
    WCHAR szPages[BUFFER_LENGTH];

    PINISPOOLER pIniSpooler = NULL;

    SPLASSERT( pIniJob != NULL &&
               pIniJob->pIniPrinter != NULL &&
               pIniJob->pIniPrinter->pIniSpooler != NULL );

    pIniSpooler = pIniJob->pIniPrinter->pIniSpooler;

    StringCchPrintf(szJobId, COUNTOF(szJobId), L"%d", pIniJob->JobId);

    StringCchPrintf(szSize, COUNTOF(szSize), L"%d", pIniJob->cbPrinted);

    StringCchPrintf(szPages, COUNTOF(szPages), L"%d", pIniJob->cPagesPrinted);

    SplLogEvent( pIniSpooler,
                 LOG_INFO,
                 MSG_DOCUMENT_PRINTED,
                 FALSE,
                 szJobId,
                 pIniJob->pDocument ? pIniJob->pDocument : L"",
                 pIniJob->pUser,
                 pIniJob->pIniPrinter->pName,
                 pIniJob->pIniPort->pName,
                 szSize,
                 szPages,
                 NULL );
}


VOID
DeleteJobCheck(
    PINIJOB pIniJob
)
{
   SplInSem();

    if ((pIniJob->cRef == 0) && (pIniJob->Status & JOB_PENDING_DELETION)) {
        DeleteJob(pIniJob, BROADCAST);
    }
}


BOOL
DeleteJob(
    PINIJOB  pIniJob,
    BOOL     bBroadcast
)
{
    WCHAR szShadowFileName[MAX_PATH];
    WCHAR szSpoolFileName[MAX_PATH];
    BOOL  Direct;
    DWORD cJobs;
    DWORD Position;
    PINISPOOLER pIniSpooler = pIniJob->pIniPrinter->pIniSpooler;
    DWORD NextJobId;
    PINIPRINTER pIniPrinter;
    PNOTIFYVECTOR pNotifyVector;
    DWORD SpoolerFlags, JobId;
    BOOL bReturn = TRUE, bDeleteOnClose;
    PMAPPED_JOB *ppMappedJob, pTempMappedJob;
    PSPOOL      pSpool;
    BOOL bDeleteShdFile;
    HANDLE pFileItem = NULL;

    DWORD dwPrnEvntError = ERROR_SUCCESS;
    //
    // WMI Trace events vars.
    //
    WMI_SPOOL_DATA WmiData;
    DWORD CreateInfo;
    BOOL  bCheckScheduler = FALSE;

    //
    // Increment the pIniPrinter so that it and the pIniSpooler don't
    // potentially get deleted when the job goes away.
    //
    pIniPrinter = pIniJob->pIniPrinter;
    INCPRINTERREF( pIniPrinter );

 do {
    pNotifyVector = &NVJobStatus;

    SplInSem();

    SPLASSERT(pIniJob->signature == IJ_SIGNATURE);
    SPLASSERT(pIniJob->pIniPrinter->signature == IP_SIGNATURE );

    NextJobId = pIniJob->NextJobId;

    DBGMSG(DBG_INFO, ("DeleteJob Deleting job 0x%0x Status 0x%0x cRef = %d\n", pIniJob, pIniJob->Status, pIniJob->cRef));

    if (pIniJob->Status & JOB_RESTART)
        goto Done;

    Direct = pIniJob->Status & JOB_DIRECT;

    //
    //  Make sure users see the Pending Deleting bit
    //  over any other status string
    //
    if( pIniJob->pStatus ){

        FreeSplStr( pIniJob->pStatus );
        pIniJob->pStatus = NULL;
        pNotifyVector = &NVJobStatusAndString;
    }

    // Update the job alert flag
    if (!(pIniJob->dwAlert & JOB_ENDDOC_CALL)) {
        pIniJob->dwAlert |= JOB_NO_ALERT;
    }

    // Release any thread waiting on LocalSetPort
    SetPortErrorEvent(pIniJob->pIniPort);

    if (!(pIniJob->Status & JOB_PENDING_DELETION)) {
        InterlockedOr((LONG*)&(pIniJob->Status), JOB_PENDING_DELETION);

        // Release any thread waiting on SeekPrinter
        SeekPrinterSetEvent(pIniJob, NULL, TRUE);

        //
        // See that we always are StartDocComplete.
        //
        if ( pIniJob->StartDocComplete ) {
            SetEvent( pIniJob->StartDocComplete );
        }

        //
        // Just pending deletion, so don't use DELETE_JOB.
        //
        SetPrinterChange(pIniJob->pIniPrinter,
                         pIniJob,
                         *pNotifyVector,
                         PRINTER_CHANGE_SET_JOB,
                         pIniSpooler );

        if (pIniJob->Status & JOB_PRINTING) {


            BOOL            ReturnValue     = TRUE;
            PINIPRINTPROC   pIniPrintProc   = pIniJob->pIniPrintProc;
            PINIPORT        pIniPort        = NULL;

            INCJOBREF(pIniJob);

            // multiple threads may come in here, but they are all "delete"
            if (pIniJob->pIniPort && !(pIniJob->pIniPort->InCriticalSection & PRINTPROC_CANCEL)) {
                pIniPort = pIniJob->pIniPort;

                INCPORTREF(pIniPort);
                LeaveSplSem();
                EnterCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);
                EnterSplSem();

                pIniPort->InCriticalSection |= PRINTPROC_CANCEL;

                if (pIniPort->hProc) {
                    LeaveSplSem();

                    DBGMSG(DBG_TRACE, ("DeleteJob calling %x hProc %x JOB_CONTROL_CANCEL\n",*pIniPrintProc->Control, pIniPort->hProc));
                    ReturnValue = (*pIniPrintProc->Control)(pIniPort->hProc, JOB_CONTROL_CANCEL);

                    EnterSplSem();
                }

                pIniPort->InCriticalSection &= ~PRINTPROC_CANCEL;

                //
                // Tell any other printproc calls not to call into the print processor.
                //
                pIniPort->InCriticalSection |= PRINTPROC_CANCELLED;

                LeaveCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);

                DECPORTREF(pIniPort);
            }

            DECJOBREF(pIniJob);
        }
    }

    //
    // If we're Pooling, then don't bother with the
    // GetFilenameFromId call
    //
    if ( pIniJob->hFileItem == INVALID_HANDLE_VALUE )
    {
        GetFullNameFromId(pIniJob->pIniPrinter, pIniJob->JobId, FALSE, szShadowFileName, COUNTOF(szShadowFileName), FALSE);
    }

    if (pIniJob->cRef) {
        //
        // Instead of writing out the shadow job, let's just delete it.
        // If the spooler restarts, we will just kill the job.
        //
        // Note that we do not delete the file if the SPL_NO_UPDATE_JOBSHD
        // flag is set, this is so cluster failovers do not lose jobs.
        //
        // We also do not delete it if we're using filepools, we recycle the
        // handle.
        //

        if (!(pIniSpooler->SpoolerFlags & SPL_NO_UPDATE_JOBSHD))
        {
            if ( pIniJob->hFileItem != INVALID_HANDLE_VALUE )
            {
                FinishedWriting( pIniJob->hFileItem, FALSE );
                InterlockedOr((LONG*)&(pIniJob->Status), JOB_SHADOW_DELETED);
            }
            else
            {
                BOOL Deleted = FALSE;
                //
                // We set the flag here so that no one tries to write the job while we're deleting the file.
                //
                InterlockedOr((LONG*)&(pIniJob->Status), JOB_SHADOW_DELETED);

                INCJOBREF(pIniJob);

                LeaveSplSem();

                Deleted = DeleteFile(szShadowFileName);

                EnterSplSem();

                DECJOBREF(pIniJob);

                //
                // If we fail to delete the file, clear the deleted flag.
                //
                if (!Deleted) {
                    DBGMSG(DBG_WARNING, ("DeleteJob DeleteFile(%ws) failed %d\n", szShadowFileName, GetLastError()));
                    InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_SHADOW_DELETED);
                }
            }
        }
        //
        // We don't need an else here because the SPL_NO_UPDATE_JOBSHD
        // will cause a shadowfile not to be written anyway, so trying to write
        // it here is pointless.
        //


        goto Done;
    }

    if (pIniJob->Status & JOB_SPOOLING) {
        DBGMSG(DBG_WARNING,("DeleteJob: returning false because job still spooling\n"));
        bReturn = FALSE;
        goto Done;
    }

    SplInSem();

    SPLASSERT( pIniJob->hWriteFile == INVALID_HANDLE_VALUE );

    // Remove the job from linked list
    // The purpose of this is so the job has no other operations carried out
    // on it whilst we are out of critical section.

    SPLASSERT(pIniJob->cRef == 0);

    if (pIniJob->pIniPrinter->pIniFirstJob == pIniJob)
        pIniJob->pIniPrinter->pIniFirstJob = pIniJob->pIniNextJob;

    SPLASSERT(pIniJob->pIniPrinter->pIniFirstJob != pIniJob);

    if (pIniJob->pIniPrinter->pIniLastJob == pIniJob)
        pIniJob->pIniPrinter->pIniLastJob = pIniJob->pIniPrevJob;

    SPLASSERT(pIniJob->pIniPrinter->pIniLastJob != pIniJob);

    if (pIniJob->pIniPrevJob) {
        pIniJob->pIniPrevJob->pIniNextJob = pIniJob->pIniNextJob;
        SPLASSERT(pIniJob->pIniPrevJob->pIniNextJob != pIniJob);
    }

    if (pIniJob->pIniNextJob) {
        pIniJob->pIniNextJob->pIniPrevJob = pIniJob->pIniPrevJob;
        SPLASSERT(pIniJob->pIniNextJob->pIniPrevJob != pIniJob);
    }

    // MAKE Certain that the Job is gone
    SPLASSERT( pIniJob != FindJob( pIniJob->pIniPrinter, pIniJob->JobId, &Position ) );

    //
    //  Only log the Job Deleted Event if the job was not printed
    //  Or it was printing but it did not print all the bytes of the job
    //  This avoid having multiple event log entries for a job
    //  MSG_DOCUMENT_PRINTED and MSG_DOCUMENT_DELETED.
    //  If its not PRINTED, then most likely someone has manually
    //  deleted the job, so we are interested in logging that event.
    //
    if ( !( pIniJob->Status & JOB_PRINTED ) ||
          ( pIniJob->Status & JOB_PRINTED ) && pIniJob->Size > pIniJob->cbPrinted ) {

         //
         // We are going to leave critical section so up the ref count.
         //
         INCJOBREF(pIniJob);

         SPLASSERT( pIniJob != NULL &&
                    pIniJob->pIniPrinter != NULL &&
                    pIniSpooler != NULL );

         LogJobInfo(
             pIniSpooler,
             MSG_DOCUMENT_DELETED,
             pIniJob->JobId,
             pIniJob->pDocument,
             pIniJob->pUser,
             pIniJob->pIniPrinter->pName,
             0
             );

         DECJOBREF(pIniJob);

    }

    SPLASSERT( pIniJob->cRef == 0 );

    if ( pIniJob->hFileItem != INVALID_HANDLE_VALUE )
    {
        pFileItem = pIniJob->hFileItem;
    }
    else
    {
        GetFullNameFromId( pIniJob->pIniPrinter, pIniJob->JobId, TRUE, szSpoolFileName, COUNTOF(szSpoolFileName), FALSE);
    }

    //
    // WMI Trace Events
    //
    if (GetFileCreationInfo(pFileItem, &CreateInfo) != S_OK)
    {
        // Assume all file created.
        CreateInfo = FP_ALL_FILES_CREATED;
    }
    SplWmiCopyEndJobData(&WmiData, pIniJob, CreateInfo);

    FreeSplStr( pIniJob->pDocument );
    FreeSplStr( pIniJob->pUser );
    FreeSplStr( pIniJob->pNotify );
    FreeSplStr( pIniJob->pDatatype );
    FreeSplStr( pIniJob->pMachineName );
    FreeSplStr( pIniJob->pParameters );
    FreeSplStr( pIniJob->pStatus );
    FreeSplStr( pIniJob->pOutputFile );
    FreeSplStr( pIniJob->pszSplFileName );

    if (pIniJob->pDevMode)
        FreeSplMem(pIniJob->pDevMode);

    if (!CloseHandle(pIniJob->hToken))
        DBGMSG( DBG_WARNING, ("CloseHandle(hToken) failed %d\n", GetLastError() ));

    if( pIniJob->pIniPort && pIniJob->pIniPort->hErrorEvent != NULL ){
        CloseHandle(pIniJob->pIniPort->hErrorEvent);
        pIniJob->pIniPort->hErrorEvent = NULL;
    }

    SPLASSERT( pIniJob->pIniPrinter->cJobs  != 0 );
    SPLASSERT( pIniJob->pIniPrintProc->cRef != 0 );
    SPLASSERT( !pIniJob->pIniPort );

    //
    // Freeup the JobId before we decrement cJobs.  We won't delete
    // the printer if cJobs is non-zero.  Since the pIniPrinter holds
    // a reference to pIniSpooler, we know pIniSpooler is valid at this
    // point.
    //

    // Record the JobId for updating the Id map
    JobId = pIniJob->JobId;

    //
    // If the printer in in pending deletion and
    // this is the last job in the queue, tell the driver that the printer
    // is beeing deleted.
    //
    if (pIniJob->pIniPrinter->cJobs == 1 &&
        pIniJob->pIniPrinter->Status & PRINTER_PENDING_DELETION) {

        INCPRINTERREF(pIniPrinter);
        LeaveSplSem();
        SplOutSem();

        PrinterDriverEvent( pIniPrinter, PRINTER_EVENT_DELETE, (LPARAM)NULL, &dwPrnEvntError );

        EnterSplSem();
        SplInSem();
        DECPRINTERREF(pIniPrinter);

    }

    pIniJob->pIniPrinter->cJobs--;

    DECDRIVERREF( pIniJob->pIniDriver );

    pIniJob->pIniPrintProc->cRef--;

    cJobs = pIniJob->pIniPrinter->cJobs;

    if (pIniJob->pSecurityDescriptor)
        DeleteDocumentSecurity(pIniJob);


    // If we are doing a Purge Printer we don't want to set a printer change
    // event for each job being deleted

    if ( bBroadcast == BROADCAST ) {

        //
        // Flip on the JOB_STATUS_DELETED bit so that it can be reported.
        //
        InterlockedOr((LONG*)&(pIniJob->Status), JOB_DELETED);

        SetPrinterChange( pIniJob->pIniPrinter,
                          pIniJob,
                          NVDeletedJob,
                          PRINTER_CHANGE_DELETE_JOB | PRINTER_CHANGE_SET_PRINTER,
                          pIniSpooler );
    }

    // On Inspection it might look as though a Printer which is pending
    // deletion which is then purged might case the printer to be deleted
    // and Purge Printer to access violate or access a dead pIniPrinter.
    // However in order to do a purge there must be a valid active
    // hPrinter which would mean the cRef != 0.

    //
    // Check whether we should delete the spool files.
    //
    SpoolerFlags = pIniSpooler->SpoolerFlags;

    DeletePrinterCheck( pIniJob->pIniPrinter );

    SplInSem();
    SPLASSERT(pIniJob->cRef == 0);

    //  If the job was being printed whilst spooling it will have
    //  some syncronization handles which need to be cleaned up

    if ( pIniJob->WaitForWrite != NULL ){
        DBGMSG( DBG_TRACE, ("DeleteJob Closing WaitForWrite handle %x\n", pIniJob->WaitForWrite));
        CloseHandle( pIniJob->WaitForWrite );
        pIniJob->WaitForWrite = NULL;
    }

    if ( pIniJob->WaitForSeek != NULL ){
        DBGMSG( DBG_TRACE, ("DeleteJob Closing WaitForSeek handle %x\n", pIniJob->WaitForSeek));
        CloseHandle( pIniJob->WaitForSeek );
        pIniJob->WaitForSeek = NULL;
    }

    if ( pIniJob->WaitForRead != NULL ){
        DBGMSG( DBG_TRACE, ("DeleteJob Closing WaitForRead handle %x\n", pIniJob->WaitForRead));
        CloseHandle( pIniJob->WaitForRead );
        pIniJob->WaitForRead = NULL;
    }

    bDeleteShdFile = pIniJob->Status & JOB_SHADOW_DELETED;

    SPLASSERT( pIniJob->hWriteFile == INVALID_HANDLE_VALUE );

    FreeSplMem(pIniJob);
    pIniJob = NULL;

    // This flag indicates if the spool file is to be deleted on ClosePrinter
    bDeleteOnClose = FALSE;

    if (!Direct) {

        //
        // Don't delete the files if we don't want JOBSHD changes.
        // This happens when we are taking a cluster offline: we want
        // to free the pIniJobs, but leave the spool files intact so they
        // can be restarted on the other node.
        //
        if( !( SpoolerFlags & SPL_NO_UPDATE_JOBSHD )){

            HANDLE  hToken;

            LeaveSplSem();

            hToken = RevertToPrinterSelf();

            //
            // Delete the spool and shadow files.
            //
            if (!bDeleteShdFile)
            {
                if ( pFileItem )
                {
                    FinishedWriting( pFileItem, FALSE );
                }
                else
                {
                    if (!DeleteFile(szShadowFileName)) {

                        DBGMSG(DBG_WARNING, ("DeleteJob DeleteFile(%ws) failed %d\n", szShadowFileName, GetLastError()));
                    }
                }
            }

            if ( pFileItem )
            {
                FinishedWriting( pFileItem, TRUE );
                FinishedReading( pFileItem );

                //
                // This releases the shadow and Spool files ate the same time.
                //
                ReleasePoolHandle( &pFileItem );

                //
                // We need to check the scheduler to insure that this file item
                // gets removed from the pool if there is no other printing in
                // the system.
                //
                bCheckScheduler = TRUE;

            }
            else
            {
                if (!DeleteFile(szSpoolFileName)) {

                    bDeleteOnClose = TRUE;
                    DBGMSG(DBG_WARNING, ("DeleteJob DeleteFile(%ws) failed %d\n", szSpoolFileName, GetLastError()));
                }
            }

            ImpersonatePrinterClient(hToken);

            EnterSplSem();
        }
        else if (pFileItem && SpoolerFlags & SPL_TYPE_CLUSTER)
        {
            ForceCloseJobPoolFiles(pFileItem);
        }
    }

    // If the spool file could not be deleted and it must be deleted on ClosePrinter
    if (!bDeleteOnClose)
    {
        // Free the job id from the id map
        vMarkOff(pIniSpooler->hJobIdMap, JobId);

        // Remove the job info from any of the pSpool structures, since the spool file
        // does not have to be deleted on ClosePrinter.
        for (pSpool = pIniPrinter->pSpool;
             pSpool;
             pSpool = pSpool->pNext)
        {
            //
            // Only run this list if the handle is not in a closing state.
            // 
            if (!(pSpool->eStatus & STATUS_CLOSING)) 
            {
                for (ppMappedJob = &(pSpool->pMappedJob);
                     *ppMappedJob;
                     ppMappedJob = &((*ppMappedJob)->pNext))
                {
                    if ((*ppMappedJob)->JobId == JobId && !((*ppMappedJob)->fStatus & kMappedJobAddJob))
                    {
                        // Delete this entry
                        pTempMappedJob = *ppMappedJob;
                        *ppMappedJob = pTempMappedJob->pNext;
                        FreeSplMem(pTempMappedJob->pszSpoolFile);
                        FreeSplMem(pTempMappedJob);

                        // There are no duplicates in this list
                        break;
                    }
                }
            }
        }
    }

    if ( bBroadcast == BROADCAST && dwEnableBroadcastSpoolerStatus ){
        BroadcastChange( pIniSpooler,WM_SPOOLERSTATUS, PR_JOBSTATUS, (LPARAM)cJobs);
    }

    //
    //  Chained Jobs
    //  If the Job we just deleted is part of a chain we need to go along
    //  the chain decrementing the reference count and potentially deleting the
    //  next job in the chain.
    //
    if ( NextJobId != 0 ) {

        //
        //  Decrement the reference count of the NextJobId
        //

        SplInSem();


        pIniJob = FindJob( pIniPrinter, NextJobId, &Position );

        if ( pIniJob != NULL ) {

            //
            //  was incremented in SetJob job_info_3
            //

            DECJOBREF( pIniJob );

            //
            //  Do not attempt to delete the NextJob until its ref count is Zero
            //

            if ( pIniJob->cRef != 0 ) {
                pIniJob = NULL;
            }

        } else {

            DBGMSG(DBG_WARNING, ("DeleteJob pIniJob %x NextJobId %d not found\n", pIniJob, pIniJob->NextJobId ));
        }

    }
    //
    // WMI Trace Events
    //
    if (pIniJob)
    {
        INCJOBREF(pIniJob);
    }
    LeaveSplSem();
    LogWmiTraceEvent(JobId, EVENT_TRACE_TYPE_SPL_DELETEJOB, &WmiData);
    EnterSplSem();
    if (pIniJob)
    {
        DECJOBREF(pIniJob);
    }

 } while ( pIniJob != NULL );

Done:

    //
    // Matches the increment at the beginning of this function.
    //
    DECPRINTERREF( pIniPrinter );
    DeletePrinterCheck( pIniPrinter );

    if (bCheckScheduler) {

        CHECK_SCHEDULER();
    }

    return bReturn;
}


VOID
LogJobInfo(
    PINISPOOLER pIniSpooler,
    NTSTATUS    EventId,
    DWORD       JobId,
    LPWSTR      pDocumentName,
    LPWSTR      pUser,
    LPWSTR      pPrinterName,
    DWORD       dwArgument
    )

/*++

Routine Description:
    Performs generic event logging for all job based events.

Arguments:
    DWORD EventId
    DWORD JobId
    LPWSTR

Return Value:
    VOID

Note:


--*/
{
    WCHAR szJobId[BUFFER_LENGTH];
    WCHAR szBuffer[BUFFER_LENGTH];

    StringCchPrintf(szJobId, COUNTOF(szJobId), L"%d", JobId);

    switch (EventId) {

    case MSG_DOCUMENT_DELETED:
    case MSG_DOCUMENT_PAUSED:
    case MSG_DOCUMENT_RESUMED:
       SplLogEvent(  pIniSpooler,
                     LOG_INFO,
                     EventId,
                     TRUE,
                     szJobId,
                     pDocumentName ? pDocumentName : L"",
                     pUser,
                     pPrinterName,
                     NULL );
        break;

    case MSG_DOCUMENT_POSITION_CHANGED:
    case MSG_DOCUMENT_PRIORITY_CHANGED:

        StringCchPrintf(szBuffer, COUNTOF(szBuffer), L"%d", dwArgument);

        SplLogEvent( pIniSpooler,
                     LOG_INFO,
                     EventId,
                     TRUE,
                     szJobId,
                     pDocumentName ? pDocumentName : L"",
                     pUser,
                     szBuffer,
                     pPrinterName,
                     NULL );
        break;

    case MSG_DOCUMENT_TIMEOUT:

        StringCchPrintf(szBuffer, COUNTOF(szBuffer), L"%d", dwArgument);

        SplLogEvent( pIniSpooler,
                     LOG_WARNING,
                     EventId,
                     TRUE,
                     szJobId,
                     pDocumentName ? pDocumentName : L"",
                     pUser,
                     pPrinterName,
                     szBuffer,
                     NULL );
        break;

    default:
        DBGMSG( DBG_ERROR, ("LogJobInfo EventId %x not supported\n", EventId ));

    }
}


BOOL
bAddMachineName(
    PSPOOL pSpool,
    PINIJOB pIniJob,
    LPCWSTR pMachineName
    )

/*++

Routine Description:

    Add a machine name to a pIniJob.

Arguments:

    pSpool - Handle of session.

    pIniJob - pIniJob to update (pMachineName field).

    pMachineName - Name passed in from ADDJOB_INFO_2 structure.  OPTIONAL

Return Value:

    TRUE - Success
    FALSE - Failure -- last error set.

--*/

{
    DWORD Status;
    LPWSTR pszRpcFree = NULL;
    LPCWSTR pszPartialName = NULL;

    if( pMachineName ){

        //
        // We have a machine name passed in from the client.
        //
        pszPartialName = pMachineName;

    } else {

        handle_t serverBinding;
        LPWSTR pszBinding;

        Status = RpcBindingServerFromClient( NULL, &serverBinding );
        if( Status != ERROR_SUCCESS ){
            DBGMSG( DBG_WARN,
                    ( "RpcBindingServerFromClient failed with Status %d\n",
                      Status ));
        } else {

            Status = RpcBindingToStringBinding( serverBinding, &pszBinding );
            if( Status != ERROR_SUCCESS ){
                DBGMSG( DBG_WARN,
                        ( "RpcBindingToStringBinding failed with Status %d\n",
                          Status ));
            } else {

                //
                // Acquire just the network address.
                //
                Status = RpcStringBindingParse( pszBinding,
                                                NULL,
                                                NULL,
                                                &pszRpcFree,
                                                NULL,
                                                NULL );
                if( Status == RPC_S_OK ){

                    pszPartialName = pszRpcFree;

                } else  {

                    DBGMSG( DBG_WARN,
                            ( "RpcStringBindingParse failed with Status %d\n",
                              Status ));
                }

                Status = RpcStringFree( &pszBinding );
                if( Status != ERROR_SUCCESS ){
                    DBGMSG( DBG_WARN,
                            ( "RpcStringFree failed with Status %d\n",
                              Status ));
                }
            }

            Status = RpcBindingFree( &serverBinding );
            if( Status != ERROR_SUCCESS ){
                DBGMSG( DBG_WARN,
                        ( "RpcBindingFree failed with Status %d\n",
                          Status ));
            }
        }

        //
        // If no partial name from RPC, use the client info.
        //
        if( !pszPartialName ){

            //
            // Unable to retrieve name; rely on handle's passed in name.
            //
            if( pSpool->SplClientInfo1.pMachineName ){
                pIniJob->pMachineName = AllocSplStr( pSpool->SplClientInfo1.pMachineName );
            }

            //
            // Very last resort, use local machine name.  This is completely
            // bogus, but backward compatible.
            //
            if( !pIniJob->pMachineName ){
                pIniJob->pMachineName = AllocSplStr(pSpool->pIniSpooler->pMachineName);
            }
        }
    }

    //
    // If it's a partial name, make sure it starts with two backslashes.
    //
    if( pszPartialName ){

        if( pszPartialName[0] != '\\' ){

            //
            // This sets the last error if the call fails.
            //
            if (!BoolFromStatus(StrCatAlloc(&pIniJob->pMachineName, L"\\\\", pszPartialName, NULL))) {

                pIniJob->pMachineName = NULL;
            }

        } else {
            pIniJob->pMachineName = AllocSplStr( pszPartialName );
        }
    }

    //
    // Free off any necessary buffers.
    //
    if( pszRpcFree ){

        Status = RpcStringFree( &pszRpcFree );
        if( Status != ERROR_SUCCESS ){
            DBGMSG( DBG_WARN,
                    ( "RpcStringFree failed with Status %d\n", Status ));
        }
    }

    return pIniJob->pMachineName != NULL;
}

PINIJOB
CreateJobEntry(
    PSPOOL pSpool,
    DWORD  Level,
    LPBYTE pDocInfo,
    DWORD  JobId,
    BOOL  bRemote,
    DWORD  JobStatus,
    LPWSTR pMachineName)
{
    PDOC_INFO_1 pDocInfo1 = (PDOC_INFO_1)pDocInfo;
    PINIJOB pIniJob = NULL;
    PINIPRINTPROC pIniPrintProc;
    BOOL        bUserName;
    WCHAR       UserName[MAX_PATH];
    DWORD       cbUserName = MAX_PATH;
    PDEVMODE pDevMode;
    LPWSTR pDefaultDatatype;
    DWORD       cchCount;
    LPWSTR  pName;
    PDEVMODE pDevModeFree = NULL;
    LPWSTR pMachineNameFixup = NULL;

    //
    // Assert that we are in Spooler Semaphore
    //

    SplInSem();

    //
    //  Sorry You cannot print whilst Upgrading
    //

    if ( dwUpgradeFlag != 0 ) {

        SetLastError( ERROR_PRINTQ_FULL );
        goto Fail;
    }


    //
    // Do the check for the printer pending deletion first
    //

    if (pSpool->pIniPrinter->Status & (PRINTER_PENDING_DELETION | PRINTER_NO_MORE_JOBS )) {

        DBGMSG(DBG_WARNING, ("The printer is pending deletion %ws\n", pSpool->pIniPrinter->pName));

        SetLastError(ERROR_PRINTER_DELETED);
        goto Fail;
    }


    //
    //  NT FAX Requires that you not be able to remotely print to a FAX
    //  printer unless you've installed the FAX Server
    //

    if ( bRemote &&
         pSpool->pIniPrinter->pIniSpooler->pNoRemotePrintDrivers ) {

         for ( cchCount = pSpool->pIniSpooler->cchNoRemotePrintDrivers, pName = pSpool->pIniSpooler->pNoRemotePrintDrivers;
               cchCount && *pName;
               cchCount -=  wcslen( pName ) + 1, pName += wcslen( pName ) + 1 ) {

            if ( _wcsicmp( pSpool->pIniPrinter->pIniDriver->pName, pName ) == STRINGS_ARE_EQUAL )  {


                SetLastError( ERROR_NETWORK_ACCESS_DENIED );

                DBGMSG( DBG_WARN, ("CreateJobEntry failing because driver %ws used, error %d\n", pName, GetLastError() ));
                goto Fail;
            }
        }
    }

    pIniJob = AllocSplMem( sizeof( INIJOB ));

    if ( pIniJob == NULL ) {

        DBGMSG( DBG_WARNING, ("AllocSplMem for the IniJob failed in CreateJobEntry\n"));
        goto Fail;
    }

    pIniJob->signature = IJ_SIGNATURE;
    pIniJob->pIniNextJob = pIniJob->pIniPrevJob = NULL;
    pIniJob->hFileItem = INVALID_HANDLE_VALUE;
    pIniJob->pszSplFileName = NULL;
    pIniJob->AddJobLevel = 0;

    //
    // Must set the Job SessionId
    //
    pIniJob->SessionId = pSpool->SessionId;

    //
    // Pickup the default datatype/printproc if not in pSpool or
    // DocInfo.
    //

    pIniPrintProc = pSpool->pIniPrintProc ?
                        pSpool->pIniPrintProc :
                        pSpool->pIniPrinter->pIniPrintProc;

    if ( pDocInfo1 && pDocInfo1->pDatatype ) {

        if (!(pIniJob->pDatatype = AllocSplStr( pDocInfo1->pDatatype ))) {
            goto Fail;
        }

    } else {

        pDefaultDatatype = pSpool->pDatatype ?
                               pSpool->pDatatype :
                               pSpool->pIniPrinter->pDatatype;

        //
        // If going direct, we must use a RAW datatype.
        //

        if ((JobStatus & JOB_DIRECT) &&
            (!ValidRawDatatype(pDefaultDatatype))) {

            //
            // Can't use a non-raw, so fail with invalid datatype.
            // Cleanup and exit.
            //
            SetLastError( ERROR_INVALID_DATATYPE );
            goto Fail;

        } else {

            if (!(pIniJob->pDatatype = AllocSplStr( pDefaultDatatype ))) {
                goto Fail;
            }
        }
    }

    pIniJob->pIniPrintProc = FindDatatype( pIniPrintProc,
                                           pIniJob->pDatatype );

    if ( !pIniJob->pIniPrintProc )  {

        SetLastError( ERROR_INVALID_DATATYPE );
        goto Fail;
    }

    pIniJob->pIniPrintProc->cRef++;


    //
    // cRef is decremented in LocalEndDocPrinter and
    // in LocalScheduleJob
    //

    INITJOBREFONE(pIniJob);

    if ( bRemote ) {

        JobStatus |= JOB_REMOTE;
    }


    pIniJob->JobId = JobId;
    pIniJob->Status = JobStatus;

    //
    // If the printer is a TS Printer we mark job, so that we know it was
    // assigned to a TS print queue.
    //
    if (pSpool->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_TS)
    {
        pIniJob->Status |= JOB_TS;
    }

    //
    // Get the name of the user, leave critical section, this might take a long time to call LSA.
    //

   LeaveSplSem();
   SplOutSem();

    bUserName = GetUserName( UserName, &cbUserName );

   EnterSplSem();

    if ( bUserName ) {

        //
        // If we got user name from remote handle check it is the same we get here
        //
#if DBG
        if( pSpool->SplClientInfo1.pUserName &&
            _wcsicmp( UserName, pSpool->SplClientInfo1.pUserName ) &&
            _wcsicmp( UserName, L"ANONYMOUS LOGON" )){

            DBGMSG( DBG_WARN,
                    ( "CreateJobEntry: Bad UserName pSpool= "TSTR" Curent= "TSTR"\n",
                      DBGSTR( pSpool->SplClientInfo1.pUserName ),
                      DBGSTR( UserName )));
        }
#endif

        if (!(pIniJob->pUser = AllocSplStr( UserName ))) {
            goto Fail;
        }

        if (!(pIniJob->pNotify = AllocSplStr( UserName ))) {
            goto Fail;
        }


    } else {

        DBGMSG(DBG_WARNING, ("CreateJobEntry GetUserName failed: %d\n", GetLastError()));
        goto Fail;

    }

    //
    // Create a document security descriptor
    //

    pIniJob->pSecurityDescriptor = CreateDocumentSecurityDescriptor( pSpool->pIniPrinter->pSecurityDescriptor );

    if( !pIniJob->pSecurityDescriptor ){
        goto Fail;
    }

    //
    // Now process the DocInfo structure passed in
    //

    if (pDocInfo1 && pDocInfo1->pDocName)
        pIniJob->pDocument = AllocSplStr(pDocInfo1->pDocName);
    else
        pIniJob->pDocument = AllocSplStr(L"No Document Name");

    if (!pIniJob->pDocument)
        goto Fail;

    if (pDocInfo1 && pDocInfo1->pOutputFile) {
        if (!(pIniJob->pOutputFile = AllocSplStr(pDocInfo1->pOutputFile)))
            goto Fail;
    }
    else
        pIniJob->pOutputFile = NULL;


    GetSid( &pIniJob->hToken );

    //
    // Pickup default if none specified.
    // (Default at time of job submission.)
    //
    if( pSpool->pDevMode ){

        pDevMode = pSpool->pDevMode;

    } else {

        if( bGetDevModePerUser( NULL,
                                pSpool->pIniPrinter->pName,
                                &pDevModeFree )){

            pDevMode = pDevModeFree;

        } else {

            pDevMode = pSpool->pIniPrinter->pDevMode;
        }
    }

    if ( pDevMode ) {

        pIniJob->pDevMode = AllocDevMode(pDevMode);

        if ( pIniJob->pDevMode == NULL )
            goto Fail;

        FreeSplMem( pDevModeFree );
    }

    GetSystemTime( &pIniJob->Submitted );
    pIniJob->pIniPrinter = pSpool->pIniPrinter;
    pSpool->pIniPrinter->cJobs++;
    pSpool->pIniPrinter->cTotalJobs++;
    pIniJob->pIniDriver = pSpool->pIniPrinter->pIniDriver;

    INCDRIVERREF( pIniJob->pIniDriver );

    pIniJob->pIniPort = NULL;
    pIniJob->pParameters = NULL;

    if( !bAddMachineName( pSpool, pIniJob, pMachineName )){
        goto Fail;
    }

    pIniJob->pStatus = NULL;
    pIniJob->cPages = pIniJob->Size = 0;
    pIniJob->cPagesPrinted = 0;
    pIniJob->Priority  = pSpool->pIniPrinter->DefaultPriority == NO_PRIORITY ?
                         DEF_PRIORITY : pSpool->pIniPrinter->DefaultPriority;
    pIniJob->StartTime = pSpool->pIniPrinter->StartTime;
    pIniJob->UntilTime = pSpool->pIniPrinter->UntilTime;
    pIniJob->cbPrinted = 0;
    pIniJob->WaitForWrite = NULL;
    pIniJob->WaitForRead  = NULL;
    pIniJob->hWriteFile   = INVALID_HANDLE_VALUE;
    pIniJob->dwJobNumberOfPagesPerSide = 0;
    pIniJob->dwDrvNumberOfPagesPerSide = 0;
    pIniJob->cLogicalPages             = 0;
    pIniJob->cLogicalPagesPrinted      = 0;

    // Additional fields for SeekPrinter.
    pIniJob->WaitForSeek  = NULL;
    pIniJob->bWaitForEnd  = FALSE;
    pIniJob->bWaitForSeek = FALSE;
    pIniJob->liFileSeekPosn.u.HighPart = 0;
    pIniJob->liFileSeekPosn.u.LowPart  = 0;

    if( dwEnableBroadcastSpoolerStatus ){

        BroadcastChange( pIniJob->pIniPrinter->pIniSpooler,
                         WM_SPOOLERSTATUS,
                         PR_JOBSTATUS,
                         pIniJob->pIniPrinter->cJobs );
    }

    return pIniJob;

Fail:

    if (pIniJob) {
        FreeSplStr(pIniJob->pDatatype);
        FreeSplStr(pIniJob->pUser);
        FreeSplStr(pIniJob->pNotify);
        FreeSplStr(pIniJob->pDocument);
        FreeSplStr(pIniJob->pOutputFile);
        FreeSplStr(pIniJob->pMachineName);

        if ( pIniJob->pDevMode != NULL )
            FreeSplMem(pIniJob->pDevMode);

        if (pIniJob->pSecurityDescriptor)
            DeleteDocumentSecurity(pIniJob);

        if (pIniJob->hToken)
            CloseHandle(pIniJob->hToken);

        FreeSplMem(pIniJob);
    }

    return NULL;
}


BOOL
DeletePrinterCheck(
    PINIPRINTER pIniPrinter
    )
{
    //
    // Enough space for printer, DWORD.  (Zombie string)
    //
    WCHAR TempName[MAX_PATH + 20];
    BOOL bReturn = FALSE;

    SplInSem();

    if ( pIniPrinter->Status & PRINTER_PENDING_DELETION ) {

        if ( pIniPrinter->cJobs == 0 ) {

            if ( pIniPrinter->cRef == 0 ) {

                return DeletePrinterForReal( pIniPrinter, NON_INIT_TIME );
            }

            //
            // If we don't want to update PRINTERINI, then don't
            // zombie the printer.
            //
            if( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_OFFLINE ){
                return TRUE;
            }

            //
            // We will have zombie printers only if we should fail OpenPrinter
            // on printers pending deletion. Because when marking a printer
            // as zombie printer we change the name
            //
            if ( pIniPrinter->pIniSpooler->SpoolerFlags &
                 SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION ) {

                if ( !( pIniPrinter->Status & PRINTER_ZOMBIE_OBJECT )) {

                    if ( !pIniPrinter->cZombieRef ) {
                        PWSTR pNameTemp = NULL;
                        PWSTR pShareNameTemp = NULL;

                        if (BoolFromHResult(StringCchPrintf(TempName, COUNTOF(TempName), L"%ws,%d", pIniPrinter->pName, gdwZombieCount++))) {

                            pNameTemp = AllocSplStr(TempName);
                            pShareNameTemp = AllocSplStr(TempName);

                            if (pNameTemp && pShareNameTemp) {

                                UpdateWinIni( pIniPrinter );

                                // Change "PrinterName" to "PrinterName,UniqueId"
                                // Since comma is not legal in a printer name
                                // the name will continue to be unique, but different
                                // so that OpenPrinters will still fail.
                                // We have to have a unique ID appended in case someone is crazy enough
                                // to create / delete / create / delete the same printer over and over.


                                CopyPrinterIni( pIniPrinter, TempName );

                                DeletePrinterIni( pIniPrinter );

                                FreeSplStr(pIniPrinter->pName);
                                FreeSplStr(pIniPrinter->pShareName);

                                pIniPrinter->pName = pNameTemp;
                                pIniPrinter->pShareName = pShareNameTemp;

                                if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

                                    pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
                                    pIniPrinter->Status |= PRINTER_WAS_SHARED;
                                }

                                pIniPrinter->Status |= PRINTER_ZOMBIE_OBJECT;

                                UpdatePrinterIni( pIniPrinter , UPDATE_CHANGEID );

                                UpdateWinIni( pIniPrinter );

                                bReturn = TRUE;

                            } else {
                                FreeSplStr(pNameTemp);
                                FreeSplStr(pShareNameTemp);

                                DBGMSG(DBG_WARNING, ("%ws printer object could not be zombied\n", pIniPrinter->pName));
                            }
                        }

                    } else {

                        DBGMSG(DBG_WARNING, ("%ws Printer object should be zombied but is locked with %d ZombieRefs\n", pIniPrinter->pName, pIniPrinter->cZombieRef));
                    }

                } else {

                    DBGMSG(DBG_TRACE, ("%ws zombie printer object\n", pIniPrinter->pName));
                    bReturn = TRUE;
                }

                DBGMSG( DBG_TRACE, ("%ws pending deletion: There %s still %d reference%s waiting\n",
                                      pIniPrinter->pName,
                                      pIniPrinter->cRef == 1 ? "is" : "are",
                                      pIniPrinter->cRef,
                                      pIniPrinter->cRef == 1 ? "" : "s"));
            }

        } else {

            DBGMSG( DBG_TRACE, ("%ws pending deletion: There %s still %d jobs%s\n",
                                 pIniPrinter->pName,
                                 pIniPrinter->cJobs == 1 ? "is" : "are",
                                 pIniPrinter->cJobs,
                                 pIniPrinter->cJobs == 1 ? "" : "s"));
        }
    }

    return bReturn;
}



VOID
UpdateReferencesToChainedJobs(
    PINISPOOLER pIniSpooler
    )
/*++

Routine Description:

        Walks through all printers and all jobs associated with those printers
        Once it finds a job with a NextJobId, it increments the reference on the
        NextJob.

    Called on reboot

Arguments:
        pIniSpooer  Pointer to the Spooler


Return Value:
        NONE

--*/
{

    PINIJOB pIniJob;
    PINIJOB pNextJob;
    PINIPRINTER pIniPrinter;
    DWORD   Position;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );


    for ( pIniPrinter = pIniSpooler->pIniPrinter;
          pIniPrinter;
          pIniPrinter = pIniPrinter->pNext ) {


        SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );


        for ( pIniJob = pIniPrinter->pIniFirstJob;
              pIniJob;
              pIniJob = pIniJob->pIniNextJob ) {


            SPLASSERT( pIniJob->signature == IJ_SIGNATURE );

            if ( pIniJob->NextJobId ) {

                pNextJob = FindJob( pIniPrinter, pIniJob->NextJobId, &Position );

                if ( pNextJob ) {

                    pNextJob->Status |= ( JOB_COMPOUND | JOB_HIDDEN );

                    DBGMSG( DBG_TRACE, ("UpdateReferencesToChainedJobs Found pNextJob %x JobId %d\n",pNextJob, pNextJob->JobId));
                    INCJOBREF( pNextJob );

                } else {

                    DBGMSG( DBG_WARNING, ("UpdateReferenesToChainedJobs unable to find Job %d\n", pIniJob->NextJobId ));

                    pIniJob->NextJobId = 0;

                }
            }
        }
    }
}


VOID UpdateJobAttributes(
    PINIJOB  pIniJob
)

/*++
Function Description: Updates the nup attributes in the pIniJob struct

Parameters: pIniJob   - job struct to be updated

Return Values: NONE
--*/

{
    ATTRIBUTE_INFO_2 AttributeInfo;
    HANDLE           hDrvPrinter = NULL;
    FARPROC          pfnDrvQueryJobAttributes;
    HINSTANCE        hDrvLib = NULL;
    fnWinSpoolDrv    fnList;

    SplOutSem();

    //
    // No job or the job has already been initialized or we're printing Raw
    //
    if (!pIniJob || !pIniJob->pIniPrinter  ||
        pIniJob->dwDrvNumberOfPagesPerSide ||
        pIniJob->dwJobNumberOfPagesPerSide ||
        ValidRawDatatype(pIniJob->pDatatype))
    {
        return;
    }

    // Initialize job attributes;
    pIniJob->dwJobNumberOfPagesPerSide = 1;
    pIniJob->dwDrvNumberOfPagesPerSide = 1;

    // Get the pointer to the client side functions from the router
    if (!SplInitializeWinSpoolDrv(&fnList)) {
        return;
    }

    // Get a client side printer handle to pass to the driver
    if (!(* (fnList.pfnOpenPrinter))(pIniJob->pIniPrinter->pName, &hDrvPrinter, NULL)) {
        DBGMSG(DBG_WARNING, ("Open printer failed\n"));
        goto CleanUp;
    }

    // Load the driver config file
    if (!(hDrvLib = (* (fnList.pfnLoadPrinterDriver))(hDrvPrinter))) {
        DBGMSG(DBG_WARNING, ("Driver could not be loaded\n"));
        goto CleanUp;
    }

    // Call the DrvQueryJobAtributes function in the driver
    if (pfnDrvQueryJobAttributes = GetProcAddress(hDrvLib, "DrvQueryJobAttributes")) {

        if ((* pfnDrvQueryJobAttributes) (hDrvPrinter,
                                          pIniJob->pDevMode,
                                          1,
                                          (LPBYTE) &AttributeInfo)) {

            pIniJob->dwJobNumberOfPagesPerSide = AttributeInfo.dwJobNumberOfPagesPerSide;
            pIniJob->dwDrvNumberOfPagesPerSide = AttributeInfo.dwDrvNumberOfPagesPerSide;
        }
    }

CleanUp:

    if (hDrvPrinter) {
        (* (fnList.pfnClosePrinter))(hDrvPrinter);
    }
    if (hDrvLib) {
        (* (fnList.pfnRefCntUnloadDriver))(hDrvLib, TRUE);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\jobid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Module Name:

    jobid.c

Abstract:

    Handles job id bitmap.

Author:

    Albert Ting (AlbertT) 24-Oct-96

Environment:

    User Mode -Win32

Revision History:

    Ported from spooler.c code.

--*/

#include "precomp.h"
#pragma hdrstop

#include "jobid.h"

BOOL
ReallocJobIdMap(
    HANDLE hJobIdMap,
    DWORD dwNewMinSize
    )

/*++

Routine Description:

    Reallocates the job id bitmap to a new minimum size.

Arguments:

    hJobId - Handle to job ID bitmap.

    dwNewMinSize - Specifies the minimum size of the job id bitmap.
        Note that the allocation size may be larger.  Also, if 0x10
        is requested, only ids 0x0-0xf are guaranteed to be valid
        (0x10 is the 11th id, and therefore not valid).

Return Value:

    TRUE - Success
    False - Failed.

--*/

{
    PJOB_ID_MAP pJobIdMap = (PJOB_ID_MAP)hJobIdMap;
    PDWORD pMap;

    if( dwNewMinSize & 7 ){
        dwNewMinSize&=~7;
        dwNewMinSize+=8;
    }

    pMap = ReallocSplMem( pJobIdMap->pMap,
                          pJobIdMap->dwMaxJobId/8,
                          dwNewMinSize/8 );

    if( !pMap ){

        DBGMSG( DBG_WARN,
                ( "ReallocJobIdMap failed ReallocSplMem dwNewMinSize %d Error %d\n",
                  dwNewMinSize, GetLastError() ));
    } else {

        pJobIdMap->pMap = pMap;
        pJobIdMap->dwMaxJobId = dwNewMinSize;
    }

    return pMap != NULL;
}

DWORD
GetNextId(
    HANDLE hJobIdMap
    )

/*++

Routine Description:

    Retrieves a free job id, although not necessarily the next
    free bit.

Arguments:

    hJobId - Handle to job ID bitmap.

Return Value:

    DWORD - Next job.

--*/

{
    PJOB_ID_MAP pJobIdMap = (PJOB_ID_MAP)hJobIdMap;
    DWORD id;

    do {

        //
        // Scan forward from current job.
        //
        for( id = pJobIdMap->dwCurrentJobId + 1;
             id < pJobIdMap->dwMaxJobId;
             ++id ){

            if( !bBitOn( hJobIdMap, id )){
                goto FoundJobId;
            }
        }

        //
        // Scan from beginning to current job.
        //
        for( id = 1; id < pJobIdMap->dwCurrentJobId; ++id ){

            if( !bBitOn( hJobIdMap, id )){
                goto FoundJobId;
            }
        }
    } while( ReallocJobIdMap( hJobIdMap, pJobIdMap->dwMaxJobId + 128 ));

    //
    // No job ids; fail.
    //
    return 0;

FoundJobId:

    vMarkOn( hJobIdMap, id );
    pJobIdMap->dwCurrentJobId = id;

    return id;
}


/********************************************************************

    Create and delete functions.

********************************************************************/

HANDLE
hCreateJobIdMap(
    DWORD dwMinSize
    )
{
    PJOB_ID_MAP pJobIdMap;

    pJobIdMap = AllocSplMem( sizeof( JOB_ID_MAP ));

    if( !pJobIdMap ){
        goto Fail;
    }

    pJobIdMap->pMap = AllocSplMem( dwMinSize/8 );
    if( !pJobIdMap->pMap ){
        goto Fail;
    }

    pJobIdMap->dwMaxJobId = dwMinSize;
    pJobIdMap->dwCurrentJobId = 1;

    return (HANDLE)pJobIdMap;

Fail:

    if( pJobIdMap ){
        FreeSplMem( pJobIdMap );
    }
    return NULL;
}



VOID
vDeleteJobIdMap(
    HANDLE hJobIdMap
    )
{
    PJOB_ID_MAP pJobIdMap = (PJOB_ID_MAP)hJobIdMap;

    if( pJobIdMap ){

        if( pJobIdMap->pMap ){
            FreeSplMem( pJobIdMap->pMap );
        }

        FreeSplMem( pJobIdMap );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\local.h ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    local.h

Abstract:

    Header file for Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    06-Jun-1995       MuhuntS   DRIVER_INFO_3, PRINTER_INFO_5 changes
    17-May-1992       ChuckC    Added CreateSplUniStr, DeleteSplUniStr.
    27 June 94        MattFe    pIniSpooler
    10 July 94        MattFe    Spl entry points for Caching

--*/

#include <ntfytab.h>
#include "splcom.h"

#ifdef __cplusplus
extern "C" {
#endif

//
//  Defines to make code more readable.
//
#define ONEDAY  60*24
#define BROADCAST    TRUE
#define NO_BROADCAST FALSE
#define UPDATE_DS_ONLY  3
#define CHANGEID_ONLY   2
#define UPDATE_CHANGEID 1
#define KEEP_CHANGEID   0
#define FIRST_FILE_TIME_GREATER_THAN_SECOND 1
#define OVERWRITE_IF_TARGET_EXISTS FALSE
#define IMPERSONATE_USER TRUE
#define DO_NOT_IMPERSONATE_USER FALSE
#define STRINGS_ARE_EQUAL 0
#define ONE_MINUTE       60*1000
#define TEN_MINUTES   10*ONE_MINUTE
#define TWO_MINUTES    2*ONE_MINUTE
#define SEVEN_MINUTES  7*ONE_MINUTE
#define HOUR_OF_MINUTES     60
#define ONE_HOUR            ONE_MINUTE*HOUR_OF_MINUTES
#define DAY_OF_HOURS        24
#define DAY_OF_MINUTES      DAY_OF_HOURS*60
#define DEFAULT_NUMBER_MASTER_AND_BACKUP 3
#define DEFAULT_NUMBER_BROWSE_WORKSTATIONS 2
#define DEFAULT_REFRESH_TIMES_PER_DECAY_PERIOD 2;
#define FIND_ANY_VERSION        TRUE
#define FIND_COMPATIBLE_VERSION FALSE
#define DRIVER_UPGRADE          2
#define DRIVER_SEARCH           4
#define NT3X_VERSION    TRUE
#define CURRENT_VERSION FALSE
#define MAX_STATIC_ALLOC 2048

// Default timeout values we will return
#define DEFAULT_DNS_TIMEOUT     15000
#define DEFAULT_TX_TIMEOUT      45000


// Pruning definitions
#define PRUNE_DOWNLEVEL_NEVER           0
#define PRUNE_DOWNLEVEL_NICELY          1
#define PRUNE_DOWNLEVEL_AGGRESSIVELY    2

// Default pruning settings
#define DS_PRINTQUEUE_VERSION_WIN2000   4
#define DEFAULT_PRUNE_DOWNLEVEL         PRUNE_DOWNLEVEL_NEVER       // Never delete downlevel PQ
#define DEFAULT_PRUNING_PRIORITY        THREAD_PRIORITY_NORMAL
#define DEFAULT_PRUNING_RETRIES         2
#define DEFAULT_PRUNING_INTERVAL        (DAY_OF_MINUTES/(DEFAULT_PRUNING_RETRIES + 1)) // 8 hrs
#define DEFAULT_PRUNING_RETRY_LOG       0

#define MAX_PRUNING_RETRIES             10

// Default printQueue settings
#define IMMORTAL                        1
#define DEFAULT_IMMORTAL                !IMMORTAL
#define DEFAULT_VERIFY_PUBLISHED_STATE  INFINITE    // This is the interval
#define DEFAULT_PRINT_PUBLISH_POLICY    1

#define SERVER_THREAD_OFF               0
#define SERVER_THREAD_ON                1
#define SERVER_THREAD_UNCONFIGURED      2

// Default policy values
#define  KM_PRINTERS_ARE_BLOCKED 1       // 1 = blocked, 0 = not blocked
#define  SERVER_DEFAULT_KM_PRINTERS_ARE_BLOCKED  1
#define  WKS_DEFAULT_KM_PRINTERS_ARE_BLOCKED    0

extern  DWORD   DefaultKMPrintersAreBlocked;

extern  DWORD   gdwServerInstallTimeOut;

#define INIT_TIME       TRUE
#define NON_INIT_TIME   FALSE

enum
{
    kMaximumNumberOfBrowsePrinters  =   256
};

extern  WCHAR *szPrinterData;
extern  WCHAR *szConfigurationKey;
extern  WCHAR *szDataFileKey;
extern  WCHAR *szDriverVersion;
extern  WCHAR *szTempDir;
extern  WCHAR *szDriversKey;
extern  WCHAR *szPrintersKey;
extern  WCHAR *szDirectory;
extern  WCHAR *szDriverIni;
extern  WCHAR *szDriverFile;
extern  WCHAR *szDriverDir;
extern  WCHAR *szPrintProcDir;
extern  WCHAR *szPrinterDir;
extern  WCHAR *szClusterPrinterDir;
extern  WCHAR *szPrinterIni;
extern  WCHAR *szNullPort;
extern  WCHAR *szComma;
extern  WCHAR *szName;
extern  WCHAR *szShare;
extern  WCHAR *szPort;
extern  WCHAR *szPrintProcessor;
extern  WCHAR *szDatatype;
extern  WCHAR *szObjectGUID;
extern  WCHAR *szDsKeyUpdate;
extern  WCHAR *szDsKeyUpdateForeground;
extern  WCHAR *szAction;
extern  WCHAR *szDriver;
extern  WCHAR *szLocation;
extern  WCHAR *szDescription;
extern  WCHAR *szAttributes;
extern  WCHAR *szStatus;
extern  WCHAR *szPriority;
extern  WCHAR *szDefaultPriority;
extern  WCHAR *szUntilTime;
extern  WCHAR *szStartTime;
extern  WCHAR *szParameters;
extern  WCHAR *szSepFile;
extern  WCHAR *szDevMode;
extern  WCHAR *szSecurity;
extern  WCHAR *szSpoolDir;
extern  WCHAR *szNetMsgDll;
extern  WCHAR *szTimeLastChange;
extern  WCHAR *szHelpFile;
extern  WCHAR *szMonitor;
extern  WCHAR *szDependentFiles;
extern  WCHAR *szPreviousNames;
extern  WCHAR *szDNSTimeout;
extern  WCHAR *szTXTimeout;
extern  WCHAR *szNull;
extern  WCHAR *szPendingUpgrades;
extern  WCHAR *szMfgName;
extern  WCHAR *szOEMUrl;
extern  WCHAR *szHardwareID;
extern  WCHAR *szProvider;
extern  WCHAR *szDriverDate;
extern  WCHAR *szLongVersion;
extern  WCHAR *szClusDrvTimeStamp;
extern  const WCHAR szDiscardTSJobs[];
extern  const WCHAR szDisableFilePooling[];

extern  HANDLE   hInst;
extern  PINISPOOLER pLocalIniSpooler;
extern  HANDLE   SchedulerSignal;
extern  HANDLE   PowerManagementSignal;
extern  DWORD    dwSchedulerThreadPriority;
extern  CRITICAL_SECTION SpoolerSection;

#if DBG
extern  HANDLE   hcsSpoolerSection;
#endif

extern  HANDLE   WinStaDllHandle;

extern  PINIENVIRONMENT pThisEnvironment;
extern  WCHAR *szPrintProcKey;
extern  WCHAR *szEnvironment;
extern  WCHAR *szMajorVersion;
extern  WCHAR *szMinorVersion;
extern  WCHAR *szRegistryRoot;
extern  WCHAR *szEMFThrottle;
extern  WCHAR *szFlushShadowFileBuffers;

extern  WCHAR *szClusterDriverRoot;
extern  WCHAR *szClusterNonAwareMonitors;

extern LPWSTR szRemoteDoc;
extern LPWSTR szLocalDoc;
extern LPWSTR szFastPrintTimeout;

extern LPWSTR szRaw;
extern DWORD  dwUpgradeFlag;

#define CHECK_SCHEDULER()   SetEvent(SchedulerSignal)

extern DWORD dwFastPrintWaitTimeout;
extern DWORD dwPortThreadPriority;
extern DWORD dwFastPrintThrottleTimeout;
extern DWORD dwFastPrintSlowDownThreshold;
extern DWORD dwWritePrinterSleepTime;
extern DWORD dwServerThreadPriority;
extern DWORD dwEnableBroadcastSpoolerStatus;
extern DWORD ServerThreadTimeout;
extern DWORD ServerThreadRunning;
extern DWORD NetPrinterDecayPeriod;
extern DWORD RefreshTimesPerDecayPeriod;
extern HANDLE ServerThreadSemaphore;
extern BOOL  bNetInfoReady;
extern DWORD FirstAddNetPrinterTickCount;
extern DWORD BrowsePrintWorkstations;

extern DWORD dwFlushShadowFileBuffers;

extern DWORD dwMajorVersion;
extern DWORD dwMinorVersion;

extern DWORD dwUniquePrinterSessionID;

extern DWORD PortToPrinterStatusMappings[];

extern WCHAR *szSpooler;
extern LPCTSTR pszLocalOnlyToken;
extern LPCTSTR pszLocalsplOnlyToken;

typedef DWORD NOTIFYVECTOR[NOTIFY_TYPE_MAX];
typedef NOTIFYVECTOR *PNOTIFYVECTOR;

#define ZERONV(dest) \
    dest[0] = dest[1] = 0

#define COPYNV(dest, src) \
    {   dest[0] = src[0]; dest[1] = src[1]; }

#define ADDNV(dest, src) \
    {   dest[0] |= src[0]; dest[1] |= src[1]; }

extern NOTIFYVECTOR NVPrinterStatus;
extern NOTIFYVECTOR NVPrinterSD;
extern NOTIFYVECTOR NVJobStatus;
extern NOTIFYVECTOR NVJobStatusString;
extern NOTIFYVECTOR NVJobStatusAndString;
extern NOTIFYVECTOR NVPurge;
extern NOTIFYVECTOR NVDeletedJob;
extern NOTIFYVECTOR NVAddJob;
extern NOTIFYVECTOR NVSpoolJob;
extern NOTIFYVECTOR NVWriteJob;
extern NOTIFYVECTOR NVPrinterAll;
extern NOTIFYVECTOR NVJobPrinted;
extern BOOL         (*pfnPrinterEvent)();

extern BOOL    fW3SvcInstalled;   // Says if IIS or "Peer web Server" is installed on the local machine.
extern PWCHAR  szW3Root;          // The WWWRoot dir, e.g. c:\inetpub\wwwroot

extern  OSVERSIONINFO     OsVersionInfo;
extern  OSVERSIONINFOEX   OsVersionInfoEx;

extern WCHAR *gszNT4EMF;
extern WCHAR *gszNT5EMF;

extern WCHAR *ipszRegistryClusRepository;
extern WCHAR *szDriversDirectory;
extern WCHAR *szDriversKey;
extern WCHAR *szWin95Environment;

extern ERemoteRPCEndPointPolicy gRemoteRPCEndPointPolicy;

BOOL
IsPrinterSharingAllowed(
    VOID
    );

typedef struct _JOBDATA {
    struct _JOBDATA   *pNext;
    PINIJOB            pIniJob;
    SIZE_T             MemoryUse;
    DWORD              dwWaitTime;
    DWORD              dwScheduleTime;
    DWORD              dwNumberOfTries;
} JOBDATA, *PJOBDATA;


typedef struct _Strings {
    DWORD   nElements;
    PWSTR   ppszString[1];
} STRINGS, *PSTRINGS;


typedef struct _INTERNAL_DRV_FILE {
    LPWSTR   pFileName;
    DWORD    dwVersion;
    HANDLE   hFileHandle;
    BOOL     bUpdated;
} INTERNAL_DRV_FILE, *PINTERNAL_DRV_FILE;

extern DWORD   dwNumberOfEMFJobsRendering;
extern BOOL    bUseEMFScheduling;
extern SIZE_T   TotalMemoryForRendering;
extern SIZE_T   AvailMemoryForRendering;
extern DWORD   dwLastScheduleTime;

extern PJOBDATA pWaitingList;
extern PJOBDATA pScheduleList;

#define JOB_SCHEDULE_LIST  0x00000001
#define JOB_WAITING_LIST   0x00000002

#define SPL_FIRST_JOB      0x00000001
#define SPL_USE_MEMORY     0x00000002

typedef BOOL (*PFNSPOOLER_MAP)( HANDLE h, PINISPOOLER pIniSpooler );
typedef BOOL (*PFNPRINTER_MAP)( HANDLE h, PINIPRINTER pIniPrinter );

#define DBG_CLUSTER 0x200

VOID
RunForEachSpooler(
    HANDLE h,
    PFNSPOOLER_MAP pfnMap
    );

VOID
RunForEachPrinter(
    PINISPOOLER pIniSpooler,
    HANDLE h,
    PFNPRINTER_MAP pfnMap
    );

BOOL
DsUpdateAllDriverKeys(
    HANDLE h,
    PINISPOOLER pIniSpooler
    );

BOOL
InitializeLocalspl(
    VOID
    );

VOID
EnterSplSem(
    VOID
    );

VOID
LeaveSplSem(
    VOID
    );

BOOL
IsThreadInSem(
    DWORD ThreadID
    );

#if DBG

extern HANDLE ghbtClusterRef;
extern PDBG_POINTERS gpDbgPointers;

VOID
SplInSem(
   VOID
);

VOID
SplOutSem(
   VOID
);
#else
#define SplInSem()
#define SplOutSem()
#endif

PDEVMODE
AllocDevMode(
    PDEVMODE    pDevMode
);

BOOL
FreeDevMode(
    PDEVMODE    pDevMode
);

PINIENTRY
FindIniKey(
   PINIENTRY pIniEntry,
   LPWSTR lpName
);

VOID
RemoveFromJobList(
    PINIJOB    pIniJob,
    DWORD      dwJobList
);

BOOL
CheckSepFile(
   LPWSTR lpFileName
);

int
DoSeparator(
    PSPOOL
);

DWORD
GetFullNameFromId(
    IN      PINIPRINTER     pIniPrinter,
    IN      DWORD           JobId,
    IN      BOOL            fJob,
    IN      PWSTR           pFileName,
    IN      SIZE_T          cchFileName,
    IN      BOOL            Remote
    );

DWORD
GetPrinterDirectory(
   PINIPRINTER pIniPrinter,
   BOOL Remote,
   LPWSTR pFileName,
   DWORD MaxLength,
   PINISPOOLER pIniSpooler
);


VOID
CreatePrintProcDirectory(
   LPWSTR lpEnvironment,
   PINISPOOLER pIniSpooler
);

VOID
ProcessShadowJobs(
    PINIPRINTER pIniPrinter,
    PINISPOOLER pIniSpooler
);

PINIJOB
ReadShadowJob(
   LPWSTR  szDir,
   PWIN32_FIND_DATA pFindFileData,
   PINISPOOLER pIniSpooler
);

VOID
GetDiscardTSJobsSettings(
   PINISPOOLER pIniSpooler
);

BOOL
WriteShadowJob(
   IN   PINIJOB pIniJob,
   IN   BOOL    bLeaveCS
);

BOOL
BuildEnvironmentInfo(
    PINISPOOLER pIniSpooler
    );

BOOL
BuildPrinterInfo(
PINISPOOLER pIniSpooler,
BOOL    UpdateChangeID
);

BOOL
BuildAllPorts(
);

BOOL
BuildDriverInfo(
    HKEY            hEnvironmentKey,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
);

BOOL
BuildTrueDependentFileField(
    LPWSTR              pDriverPath,
    LPWSTR              pDataFile,
    LPWSTR              pConfigFile,
    LPWSTR              pHelpFile,
    LPWSTR              pInputDependentFiles,
    LPWSTR             *ppDependentFiles
    );

DWORD
GetDriverVersionDirectory(
    LPWSTR pDir,
    DWORD  MaxLength,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver,
    LPWSTR lpRemote
    );

PINIVERSION
FindVersionForDriver(
    PINIENVIRONMENT pIniEnvironment,
    PINIDRIVER pIniDriver
    );

BOOL
BuildPrintProcInfo(
    HKEY            hEnvironmentKey,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
);

BOOL
MoveNewDriverRelatedFiles(
    LPWSTR              pNewDir,
    LPWSTR              pCurrDir,
    LPWSTR              pOldDir,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    LPBOOL              pbDriverFileMoved,
    LPBOOL              pbConfigFileMoved
    );

BOOL
RemoveFromList(
   PINIENTRY   *ppIniHead,
   PINIENTRY   pIniEntry
);

PINIDRIVER
GetDriver(
    HKEY hVersionKey,
    LPWSTR DriverName,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion
    );

DWORD
GetDriverDirectory(
   LPWSTR lpDir,
   DWORD   MaxLength,
   PINIENVIRONMENT lpEnvironment,
   LPWSTR  lpRemotePath,
   PINISPOOLER pIniSpooler
);

DWORD
GetProcessorDirectory(
   LPWSTR *lpDir,
   LPWSTR lpEnvironment,
   PINISPOOLER pIniSpooler
);

BOOL
CreateCompleteDirectory(
   LPWSTR lpDir
);


HRESULT
OpenMonitorPort(
    PINIPORT        pIniPort,
    PINIMONITOR     pIniLangMonitor,
    LPWSTR          pszPrinterName
    );

HRESULT
CloseMonitorPort(
    PINIPORT    pIniPort
    );

HRESULT
ReleaseMonitorPort(
    PINIPORT    pIniPort
    );

HANDLE
GetMonitorHandle(
    PINIPORT    pIniPort
    );

PINIMONITOR
GetOpenedMonitor(
    PINIPORT    pIniPort
    );


VOID
ShutdownPorts(
    PINISPOOLER pIniSpooler
);

BOOL
CreatePortThread(
   PINIPORT pIniPort
);

#define WAIT   TRUE
#define NOWAIT FALSE

BOOL
DestroyPortThread(
    PINIPORT    pIniPort,
    BOOL        bShutdown
);

DWORD
PortThread(
   PINIPORT  pIniPort
);

BOOL
DeleteJob(
   PINIJOB  pIniJob,
   BOOL     bBroadcast
);

VOID
DeleteJobCheck(
    PINIJOB pIniJob
);

BOOL
UpdateWinIni(
    PINIPRINTER pIniPrinter
);

PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData
);

PINIPORT
CreatePortEntry(
    LPWSTR      pPortName,
    PINIMONITOR pIniMonitor,
    PINISPOOLER pIniSpooler
);

VOID
GetPrinterPorts(
    PINIPRINTER pIniPrinter,
    LPWSTR      pszPorts,
    DWORD       *pcbNeeded
);

DWORD
SchedulerThread(
    PINISPOOLER pIniSpooler
);

BOOL
UpdatePrinterIni(
   PINIPRINTER pIniPrinter,
   DWORD    dwChangeID
);

BOOL
UpdatePrinterNetworkName(
   PINIPRINTER pIniPrinter,
   LPWSTR pszPorts
);

BOOL
CopyPrinterDevModeToIniPrinter(
    IN OUT PINIPRINTER      pIniPrinter,
    IN     LPDEVMODE        pDevMode
    );

BOOL
InitializeForms(
    PINISPOOLER pIniSpooler
);

BOOL
InitializeNet(
    VOID
);

BOOL
ShareThisPrinter(
    PINIPRINTER pIniPrinter,
    LPWSTR   pShareName,
    BOOL    Share
);


DWORD
AddPrintShare(
    PINISPOOLER pIniSpooler
    );

PINIJOB
FindJob(
   PINIPRINTER pIniPrinter,
   DWORD JobId,
   PDWORD pPosition
);

PINIJOB
FindServerJob(
    PINISPOOLER pIniSpooler,
    DWORD JobId,
    PDWORD pPosition,
    PINIPRINTER* ppIniPrinter
    );

PINIJOB
FindIniJob (
    PSPOOL pSpool,
    DWORD  JobId
    );

DWORD
GetJobSessionId (
    PSPOOL pSpool,
    DWORD  JobId
    );

BOOL
MyName(
    LPWSTR   pName,
    PINISPOOLER pIniSpooler
);

BOOL
IsValidPrinterName(
    IN LPCWSTR pszPrinter,
    IN DWORD   cchMax
    );

BOOL
CheckMyName(
    LPWSTR   pName,
    PINISPOOLER pIniSpooler
);


PINISPOOLER
FindSpoolerByNameIncRef(
    LPTSTR pszName,
    LPCTSTR *ppszLocalName OPTIONAL
    );

VOID
FindSpoolerByNameDecRef(
    PINISPOOLER pIniSpooler
    );

PINISPOOLER
FindSpoolerByName(
    LPTSTR pszName,
    LPCTSTR *ppszLocalName OPTIONAL
    );


HANDLE
AddNetPrinter(
    LPBYTE  pPrinterInfo,
    PINISPOOLER pIniSpooler
);

BOOL
CreateServerThread(
    VOID
);

BOOL
GetSid(
    PHANDLE hToken
);

BOOL
SetCurrentSid(
    HANDLE  phToken
);

BOOL
LocalEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

DWORD
LocalOpenPrinter(
   LPWSTR   pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTS pDefault
);

DWORD
LocalOpenPrinterEx(
   LPWSTR               pPrinterName,
   LPHANDLE             phPrinter,
   LPPRINTER_DEFAULTS   pDefault,
   LPBYTE               pSplClientInfo,
   DWORD                dwLevel
);

BOOL
LocalSetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);

BOOL
LocalGetJob(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);

BOOL
LocalEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

HANDLE
LocalAddPrinter(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
);

HANDLE
LocalAddPrinterEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter,
    LPBYTE  pSplClientInfo,
    DWORD   dwClientInfoLevel
);

BOOL
DeletePrinterForReal(
    PINIPRINTER pIniPrinter,
    BOOL        bIsInitTime
);

VOID
DeleteIniNetPort(
    PINIPRINTER pIniPrinter
);

BOOL
LocalDeletePrinter(
   HANDLE   hPrinter
);

BOOL
LocalAddPrinterConnection(
    LPWSTR   pName
);

BOOL
LocalDeletePrinterConnection(
    LPWSTR  pName
);

BOOL
LocalAddPrinterDriver(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
);

BOOL
LocalAddPrinterDriverEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags
);

BOOL
LocalAddDriverCatalog(
    IN     HANDLE      hPrinter,
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     DWORD       dwCatalogCopyFlags
    );

BOOL
LocalEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
LocalGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
LocalDeletePrinterDriver(
   LPWSTR   pName,
   LPWSTR   pEnvironment,
   LPWSTR   pDriverName
);

BOOL
LocalDeletePrinterDriverEx(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pDriverName,
    DWORD   dwDeleteFlag,
    DWORD   dwVersionNum
);

BOOL
LocalAddPerMachineConnection(
   LPCWSTR  pServer,
   LPCWSTR  pPrinterName,
   LPCWSTR  pPrintServer,
   LPCWSTR  pProvider
);

BOOL
LocalDeletePerMachineConnection(
   LPCWSTR  pServer,
   LPCWSTR  pPrinterName
);

BOOL
LocalEnumPerMachineConnections(
   LPCWSTR  pServer,
   LPBYTE   pPrinterEnum,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
);

BOOL
LocalAddPrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPathName,
    LPWSTR  pPrintProcessorName
);

BOOL
LocalEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
LocalGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
LocalDeletePrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
);

BOOL
LocalEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

DWORD
LocalStartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);

BOOL
LocalStartPagePrinter(
    HANDLE  hPrinter
);

BOOL
LocalGetSpoolFileHandle(
    HANDLE    hPrinter,
    LPWSTR    *pSpoolDir,
    LPHANDLE  phFile,
    HANDLE    hSpoolerProcess,
    HANDLE    hAppProcess
);

BOOL
LocalCommitSpoolData(
    HANDLE  hPrinter,
    DWORD   cbCommit
);

BOOL
LocalCloseSpoolFileHandle(
    HANDLE  hPrinter
);

BOOL
LocalFlushPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
);

DWORD
LocalSendRecvBidiData(
    HANDLE                    hPrinter,
    LPCTSTR                   pAction,
    PBIDI_REQUEST_CONTAINER   pReqData,
    PBIDI_RESPONSE_CONTAINER* ppResData
);

BOOL
LocalWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

BOOL
LocalSeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWritePrinter
);

BOOL
LocalEndPagePrinter(
   HANDLE   hPrinter
);

BOOL
LocalAbortPrinter(
   HANDLE   hPrinter
);

BOOL
LocalReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead
);

BOOL
SplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
);

BOOL
LocalEndDocPrinter(
   HANDLE   hPrinter
);

BOOL
LocalAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
LocalScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
);

DWORD
LocalWaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
);

BOOL
SetSpoolClosingChange(
    PSPOOL pSpool
);

BOOL
SetPrinterChange(
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob,
    PDWORD      pdwNotifyVectors,
    DWORD       Flags,
    PINISPOOLER pIniSpooler
);

BOOL
LocalEnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
LocalEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
LocalAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
);

BOOL
LocalConfigurePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);

BOOL
LocalDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);


BOOL
LocalXcvData(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus
);

DWORD
XcvOpen(
    PCWSTR              pszServer,
    PCWSTR              pszObject,
    DWORD               dwType,
    PPRINTER_DEFAULTS   pDefault,
    PHANDLE             phXcv,
    PINISPOOLER         pIniSpooler
);

BOOL
XcvClose(
    PINIXCV pIniXcv
);

BOOL
XcvDeletePort(
    PINIXCV     pIniXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    PINISPOOLER pIniSpooler
);

BOOL
XcvAddPort(
    PINIXCV     pIniXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    PINISPOOLER pIniSpooler
);


BOOL
AddPortToSpooler(
    PCWSTR      pName,
    PINIMONITOR pIniMonitor,
    PINISPOOLER pIniSpooler
);

BOOL
DeletePortFromSpoolerStart(
    PINIPORT    pIniPort
);


BOOL
DeletePortFromSpoolerEnd(
    PINIPORT    pIniPort,
    PINISPOOLER pIniSpooler,
    BOOL        bSuccess
);



HANDLE
LocalCreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODE   pDevMode
);

BOOL
LocalPlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
);

BOOL
LocalDeletePrinterIC(
    HANDLE  hPrinterIC
);

DWORD
LocalPrinterMessageBox(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
);

BOOL
LocalAddMonitor(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitors
);

BOOL
LocalDeleteMonitor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pMonitorName
);

BOOL
LocalFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus,
    PVOID pvReserved0,
    PVOID pvReserved1
);


BOOL
LocalFindClosePrinterChangeNotification(
    HANDLE hPrinter
);


PINIPRINTPROC
FindDatatype(
    PINIPRINTPROC pDefaultPrintProc,
    LPWSTR  pDatatype
);

PINIPRINTPROC
InitializePrintProcessor(
    HINSTANCE       hLibrary,
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR          pPrintProcessorName,
    LPWSTR          pDLLName
);

HRESULT
InitializeLocalPrintProcessor(
    IN      PINIENVIRONMENT     pIniEnvironment
    );

PINIPRINTPROC
LoadPrintProcessor(
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR          pPrintProcessorName,
    LPWSTR          pPathName,
    PINISPOOLER     pIniSpooler
);

PINIMONITOR
CreateMonitorEntry(
    LPWSTR   pMonitorDll,
    LPWSTR   pMonitorName,
    PINISPOOLER pIniSpooler
);

PINIPORT
FindIniPortFromIniPrinter(
    PINIPRINTER pIniPrinter
);


BOOL
GetPrintDriverVersion(
    IN  LPCWSTR pszFileName,
    OUT LPDWORD pdwFileMajorVersion,
    OUT LPDWORD pdwFileMinorVersion
);

BOOL
GetBinaryVersion(
    IN  PCWSTR pszFileName,
    OUT PDWORD pdwFileMajorVersion,
    OUT PDWORD pdwFileMinorVersion
    );

BOOL
IsSpecialDriver(
    IN PINIDRIVER    pIniDriver,
    IN PINIPRINTPROC pIniProc,
    IN PINISPOOLER   pIniSpooler
    );

BOOL
IsLocalFile (
    IN  LPCWSTR     pszFileName,
    IN  PINISPOOLER pIniSpooler
);

BOOL
IsEXEFile(
    IN  LPCWSTR     pszFileName
);

LPBYTE
PackStringToEOB(
    IN  LPWSTR pszSource,
    IN  LPBYTE pEnd
);

LPVOID
MakePTR (
    IN  LPVOID pBuf,
    IN  DWORD  Quantity
);

DWORD
MakeOffset (
    IN  LPVOID pFirst,
    IN  LPVOID pSecond
);


LPWSTR
GetErrorString(
    DWORD   Error
);

DWORD
KMPrintersAreBlocked(
);


#define NULL_TERMINATED 0
INT
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
);

int
Message(
    HWND hwnd,
    DWORD Type,
    int CaptionID,
    int TextID,
    ...
);

DWORD
PromptWriteError(
    PSPOOL pSpool,
    PHANDLE  phThread,
    PDWORD   pdwThreadId
);

DWORD
InitializeEventLogging(
    PINISPOOLER pIniSpooler
);

VOID
SplLogEventWorker(
    IN      PINISPOOLER pIniSpooler,
    IN      WORD        EventType,
    IN      NTSTATUS    EventID,
    IN      BOOL        bInSplSem,
    IN      LPWSTR      pFirstString,
    IN      va_list     vargs
);

VOID
SplLogEvent(
    PINISPOOLER pIniSpooler,
    WORD        EventType,
    NTSTATUS    EventID,
    BOOL        bInSplSem,
    LPWSTR      pFirstString,
    ...
);

VOID
SplLogEventExternal(
    IN      WORD        EventType,
    IN      DWORD       EventID,
    IN      LPWSTR      pFirstString,
    ...
);

VOID
LogPrintProcError(
    IN DWORD   Error,
    IN PINIJOB pIniJob
    );

LONG
InterlockedAnd (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

LONG
InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

VOID
GetServerFilePoolSettings(
    PINISPOOLER pIniSpooler
    );

#define IDS_LOCALSPOOLER            100
#define IDS_ERROR_WRITING_TO_PORT   101
#define IDS_ERROR_WRITING_TO_DISK   102

#define IDS_PRINTER_DRIVERS         104
#define IDS_UNNAMED                 105
#define IDS_ERROR_WRITING_GENERAL   106
#define IDS_REMOTE_DOC              107
#define IDS_LOCAL_DOC               108
#define IDS_FASTPRINT_TIMEOUT       109
#define IDS_DRIVER_CHECKPOINT       110

// Maximum length of a builtin form
//

#define FORM_NAME_LEN                31
#define CUSTOM_NAME_LEN              31
#define FORM_DATA_LEN                32

// String table Ids for builtin form names
//
#define IDS_FORM_LETTER             200
#define IDS_FORM_LETTER_SMALL       201
#define IDS_FORM_TABLOID            202
#define IDS_FORM_LEDGER             203
#define IDS_FORM_LEGAL              204
#define IDS_FORM_STATEMENT          205
#define IDS_FORM_EXECUTIVE          206
#define IDS_FORM_A3                 207
#define IDS_FORM_A4                 208
#define IDS_FORM_A4_SMALL           209
#define IDS_FORM_A5                 210
#define IDS_FORM_B4                 211
#define IDS_FORM_B5                 212
#define IDS_FORM_FOLIO              213
#define IDS_FORM_QUARTO             214
#define IDS_FORM_10X14              215
#define IDS_FORM_11X17              216
#define IDS_FORM_NOTE               217
#define IDS_FORM_ENVELOPE9          218
#define IDS_FORM_ENVELOPE10         219
#define IDS_FORM_ENVELOPE11         220
#define IDS_FORM_ENVELOPE12         221
#define IDS_FORM_ENVELOPE14         222
#define IDS_FORM_ENVELOPE_CSIZE_SHEET        223
#define IDS_FORM_ENVELOPE_DSIZE_SHEET        224
#define IDS_FORM_ENVELOPE_ESIZE_SHEET        225
#define IDS_FORM_ENVELOPE_DL        226
#define IDS_FORM_ENVELOPE_C5        227
#define IDS_FORM_ENVELOPE_C3        228
#define IDS_FORM_ENVELOPE_C4        229
#define IDS_FORM_ENVELOPE_C6        230
#define IDS_FORM_ENVELOPE_C65       231
#define IDS_FORM_ENVELOPE_B4        232
#define IDS_FORM_ENVELOPE_B5        233
#define IDS_FORM_ENVELOPE_B6        234
#define IDS_FORM_ENVELOPE           235
#define IDS_FORM_ENVELOPE_MONARCH   236
#define IDS_FORM_SIX34_ENVELOPE     237
#define IDS_FORM_US_STD_FANFOLD     238
#define IDS_FORM_GMAN_STD_FANFOLD   239
#define IDS_FORM_GMAN_LEGAL_FANFOLD 240

#if(WINVER >= 0x0400)
#define IDS_FORM_ISO_B4                           241
#define IDS_FORM_JAPANESE_POSTCARD                242
#define IDS_FORM_9X11                             243
#define IDS_FORM_10X11                            244
#define IDS_FORM_15X11                            245
#define IDS_FORM_ENV_INVITE                       246
#define IDS_FORM_LETTER_EXTRA                     247
#define IDS_FORM_LEGAL_EXTRA                      248
#define IDS_FORM_TABLOID_EXTRA                    249
#define IDS_FORM_A4_EXTRA                         250
#define IDS_FORM_LETTER_TRANSVERSE                251
#define IDS_FORM_A4_TRANSVERSE                    252
#define IDS_FORM_LETTER_EXTRA_TRANSVERSE          253
#define IDS_FORM_A_PLUS                           254
#define IDS_FORM_B_PLUS                           255
#define IDS_FORM_LETTER_PLUS                      256
#define IDS_FORM_A4_PLUS                          257
#define IDS_FORM_A5_TRANSVERSE                    258
#define IDS_FORM_B5_TRANSVERSE                    259
#define IDS_FORM_A3_EXTRA                         260
#define IDS_FORM_A5_EXTRA                         261
#define IDS_FORM_B5_EXTRA                         262
#define IDS_FORM_A2                               263
#define IDS_FORM_A3_TRANSVERSE                    264
#define IDS_FORM_A3_EXTRA_TRANSVERSE              265

#define IDS_FORM_DBL_JAPANESE_POSTCARD            266
#define IDS_FORM_A6                               267
#define IDS_FORM_JENV_KAKU2                       268
#define IDS_FORM_JENV_KAKU3                       269
#define IDS_FORM_JENV_CHOU3                       270
#define IDS_FORM_JENV_CHOU4                       271
#define IDS_FORM_LETTER_ROTATED                   272
#define IDS_FORM_A3_ROTATED                       273
#define IDS_FORM_A4_ROTATED                       274
#define IDS_FORM_A5_ROTATED                       275
#define IDS_FORM_B4_JIS_ROTATED                   276
#define IDS_FORM_B5_JIS_ROTATED                   277
#define IDS_FORM_JAPANESE_POSTCARD_ROTATED        278
#define IDS_FORM_DBL_JAPANESE_POSTCARD_ROTATED    279
#define IDS_FORM_A6_ROTATED                       280
#define IDS_FORM_JENV_KAKU2_ROTATED               281
#define IDS_FORM_JENV_KAKU3_ROTATED               282
#define IDS_FORM_JENV_CHOU3_ROTATED               283
#define IDS_FORM_JENV_CHOU4_ROTATED               284
#define IDS_FORM_B6_JIS                           285
#define IDS_FORM_B6_JIS_ROTATED                   286
#define IDS_FORM_12X11                            287
#define IDS_FORM_JENV_YOU4                        288
#define IDS_FORM_JENV_YOU4_ROTATED                289
#define IDS_FORM_P16K                             290
#define IDS_FORM_P32K                             291
#define IDS_FORM_P32KBIG                          292
#define IDS_FORM_PENV_1                           293
#define IDS_FORM_PENV_2                           294
#define IDS_FORM_PENV_3                           295
#define IDS_FORM_PENV_4                           296
#define IDS_FORM_PENV_5                           297
#define IDS_FORM_PENV_6                           298
#define IDS_FORM_PENV_7                           299
#define IDS_FORM_PENV_8                           300
#define IDS_FORM_PENV_9                           301
#define IDS_FORM_PENV_10                          302
#define IDS_FORM_P16K_ROTATED                     303
#define IDS_FORM_P32K_ROTATED                     304
#define IDS_FORM_P32KBIG_ROTATED                  305
#define IDS_FORM_PENV_1_ROTATED                   306
#define IDS_FORM_PENV_2_ROTATED                   307
#define IDS_FORM_PENV_3_ROTATED                   308
#define IDS_FORM_PENV_4_ROTATED                   309
#define IDS_FORM_PENV_5_ROTATED                   310
#define IDS_FORM_PENV_6_ROTATED                   311
#define IDS_FORM_PENV_7_ROTATED                   312
#define IDS_FORM_PENV_8_ROTATED                   313
#define IDS_FORM_PENV_9_ROTATED                   314
#define IDS_FORM_PENV_10_ROTATED                  315

#define IDS_FORM_RESERVED_48                      316
#define IDS_FORM_RESERVED_49                      317
#define IDS_FORM_CUSTOMPAD                        318

#endif /* WINVER >= 0x0400 */

VOID LogJobPrinted(
    PINIJOB pIniJob
);

#define MAP_READABLE 0
#define MAP_SETTABLE 1

DWORD
MapJobStatus(
    DWORD Type,
    DWORD Status
    );

DWORD
MapPrinterStatus(
    DWORD Type,
    DWORD Status
    );


BOOL
OpenPrinterPortW(
    LPWSTR  pPrinterName,
    HANDLE *pHandle,
    LPPRINTER_DEFAULTS pDefault
);

VOID
BroadcastChange(
    PINISPOOLER pIniSpooler,
    DWORD   Message,
    WPARAM  wParam,
    LPARAM  lParam
);

VOID
MyMessageBeep(
    DWORD   fuType,
    PINISPOOLER pIniSpooler
);


VOID
SendJobAlert(
    PINIJOB pIniJob
);

BOOL
CheckDataTypes(
    PINIPRINTPROC pIniPrintProc,
    LPWSTR  pDatatype
);

BOOL
ValidatePortTokenList(
    IN  OUT PKEYDATA        pKeyData,
    IN      PINISPOOLER     pIniSpooler,
    IN      BOOL            bInitialize,
        OUT BOOL            *pbNoPorts          OPTIONAL
);

VOID
FreePortTokenList(
    PKEYDATA    pKeyData
    );

DWORD
ValidatePrinterInfo(
    IN  PPRINTER_INFO_2 pPrinter,
    IN  PINISPOOLER pIniSpooler,
    IN  PINIPRINTER pIniPrinter OPTIONAL,
    OUT LPWSTR* ppszLocalName   OPTIONAL
    );


BOOL
DeletePortEntry(
    PINIPORT    pIniPort
);

BOOL
GetTokenHandle(
    PHANDLE pTokenHandle
);


VOID
LogJobInfo(
    PINISPOOLER pIniSpooler,
    NTSTATUS EventId,
    DWORD JobId,
    LPWSTR pDocumentName,
    LPWSTR pUser,
    LPWSTR pPrinterName,
    DWORD  curPos
    );

LONG
Myatol(
   LPWSTR nptr
   );

ULONG_PTR
atox(
   LPCWSTR psz
   );


DWORD
DeleteSubkeys(
    HKEY hKey,
    PINISPOOLER pIniSpooler
);

DWORD
CreateClusterSpoolerEnvironmentsStructure(
    IN PINISPOOLER pIniSpooler
    );

DWORD
CopyNewerOrOlderFiles(
    IN LPCWSTR     pszSourceDir,
    IN LPCWSTR     pszMasterDir,
    IN BOOL (WINAPI *pfn)(LPWSTR, LPWSTR)
    );

PINIENVIRONMENT
GetLocalArchEnv(
    IN PINISPOOLER pIniSpooler
    );

DWORD
ClusterFindLanguageMonitor(
    IN LPCWSTR     pszMonitor,
    IN LPCWSTR     pszEnvName,
    IN PINISPOOLER pIniSpooler
    );

DWORD
ReadTimeStamp(
    IN     HKEY        hkRoot,
    IN OUT SYSTEMTIME *pSysTime,
    IN     LPCWSTR     pszSubKey1,
    IN     LPCWSTR     pszSubKey2,
    IN     LPCWSTR     pszSubKey3,
    IN     LPCWSTR     pszSubKey4,
    IN     LPCWSTR     pszSubKey5,
    IN     PINISPOOLER pIniSpooler
    );

DWORD
WriteTimeStamp(
    IN HKEY        hkRoot,
    IN SYSTEMTIME  SysTime,
    IN LPCWSTR     pszSubKey1,
    IN LPCWSTR     pszSubKey2,
    IN LPCWSTR     pszSubKey3,
    IN LPCWSTR     pszSubKey4,
    IN LPCWSTR     pszSubKey5,
    IN PINISPOOLER pIniSpooler
    );

BOOL
ClusterCheckDriverChanged(
    IN HKEY        hClusterVersionKey,
    IN LPCWSTR     pszDriver,
    IN LPCWSTR     pszEnv,
    IN LPCWSTR     pszVer,
    IN PINISPOOLER pIniSpooler
    );

DWORD
RunProcess(
    IN  LPCWSTR pszExe,
    IN  LPCWSTR pszCommand,
    IN  DWORD   dwTimeOut,
    OUT LPDWORD pdwExitCode OPTIONAL
    );

DWORD
CopyICMFromLocalDiskToClusterDisk(
    IN PINISPOOLER pIniSpooler
    );

DWORD
CopyICMFromClusterDiskToLocalDisk(
    IN PINISPOOLER pIniSpooler
    );

DWORD
CreateProtectedDirectory(
    IN LPCWSTR pszDir
    );

DWORD
AddLocalDriverToClusterSpooler(
    IN LPCWSTR     pszDriver,
    IN PINISPOOLER pIniSpooler
    );

DWORD
StrCatPrefixMsz(
    IN     LPCWSTR  pszPerfix,
    IN     LPWSTR   pszzFiles,
    IN OUT LPWSTR  *ppszFullPathFiles
    );

DWORD
ClusterSplDeleteUpgradeKey(
    IN LPCWSTR pszResourceID
    );

DWORD
ClusterSplReadUpgradeKey(
    IN  LPCWSTR pszResourceID,
    OUT LPDWORD pdwValue
    );

DWORD
CopyFileToDirectory(
    IN LPCWSTR pszFullFileName,
    IN LPCWSTR pszDestDir,
    IN LPCWSTR pszDir1,
    IN LPCWSTR pszDir2,
    IN LPCWSTR pszDir3
    );

DWORD
InstallMonitorFromCluster(
    IN LPCWSTR     pszName,
    IN LPCWSTR     pszEnvName,
    IN LPCWSTR     pszEnvDir,
    IN PINISPOOLER pIniSpooler
    );

PINIDRIVER
FindLocalDriver(
    PINISPOOLER pIniSpooler,
    LPWSTR      pz
);

BOOL
FindLocalDriverAndVersion(
    PINISPOOLER pIniSpooler,
    LPWSTR      pz,
    PINIDRIVER  *ppIniDriver,
    PINIVERSION *ppIniVersion
);

BOOL
IsKMPD(
    LPWSTR  pDriverName
);

BOOL
IniDriverIsKMPD (
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver
    );

PINIDRIVER
FindCompatibleDriver(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION * ppIniVersion,
    LPWSTR pDriverName,
    DWORD dwMajorVersion,
    int FindAnyDriver
    );

VOID
QueryUpgradeFlag(
    PINISPOOLER pIniSpooler
);


BOOL
LocalAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
);


BOOL
ValidateSpoolHandle(
    PSPOOL pSpool,
    DWORD  dwDisallowMask
    );


PSECURITY_DESCRIPTOR
MapPrinterSDToShareSD(
    PSECURITY_DESCRIPTOR pPrinterSD
    );

BOOL
CallDevQueryPrint(
    LPWSTR    pPrinterName,
    LPDEVMODE pDevMode,
    LPWSTR    ErrorString,
    DWORD     dwErrorString,
    DWORD     dwPrinterFlags,
    DWORD     dwJobFlags
    );


BOOL
InitializeWinSpoolDrv(
    VOID
    );


VOID
FixDevModeDeviceName(
    LPWSTR pPrinterName,
    PDEVMODE pDevMode,
    DWORD cbDevMode
    );

VOID
RemoveOldNetPrinters(
    PPRINTER_INFO_1 pCurrentPrinterInfo1,
    PINISPOOLER pIniSpooler
    );

PINIJOB
AssignFreeJobToFreePort(
    PINIPORT pIniPort,
    DWORD   *pTimeToWait
);

BOOL
ValidRawDatatype(
    LPWSTR pszDataType);

BOOL
InternalAddPrinterDriverEx(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags,
    PINISPOOLER pIniSpooler,
    BOOL    bUseScratchDir,
    BOOL    bImpersonateOnCreate
);

VOID
CheckSizeDetectionThread(
    VOID
);

VOID
UpgradeForms(
    PINISPOOLER pIniSpooler
);

HANDLE
CreatePrinterHandle(
    LPWSTR      pPrinterName,
    LPWSTR      pFullMachineName,
    PINIPRINTER pIniPrinter,
    PINIPORT    pIniPort,
    PINIPORT    pIniNetPort,
    PINIJOB     pIniJob,
    DWORD       TypeofHandle,
    HANDLE      hPort,
    PPRINTER_DEFAULTS pDefaults,
    PINISPOOLER pIniSpooler,
    DWORD       AccessRequested,
    LPBYTE      pSplClientInfo,
    DWORD   dwLevel,
    HANDLE  hReadFile
);

DWORD
CreateServerHandle(
    LPWSTR   pPrinterName,
    LPHANDLE pPrinterHandle,
    LPPRINTER_DEFAULTS pDefaults,
    PINISPOOLER pIniSpooler,
    DWORD   dwTypeofHandle
);


PINIPRINTER
FindPrinterShare(
   LPCWSTR pShareName,
   PINISPOOLER pIniSpooler
);

PINIJOB
CreateJobEntry(
    PSPOOL pSpool,
    DWORD  Level,
    LPBYTE pDocInfo,
    DWORD  JobId,
    BOOL  bRemote,
    DWORD  JobStatus,
    LPWSTR pMachineName
    );

BOOL
DeletePrinterCheck(
    PINIPRINTER pIniPrinter
    );

VOID
DeleteSpoolerCheck(
    PINISPOOLER pIniSpooler
    );


BOOL
DeletePrinterIni(
   PINIPRINTER pIniPrinter
   );

DWORD
SplDeleteThisKey(
    HKEY hParentKey,       // handle to parent of key to delete
    HKEY hThisKey,         // handle of key to delete
    LPWSTR pThisKeyName,   // name of this key
    BOOL bDeleteNullKey,   // if *pThisKeyName is NULL, delete it if TRUE
    PINISPOOLER pIniSpooler
    );

BOOL
CopyPrinterIni(
   PINIPRINTER pIniPrinter,
   LPWSTR pNewName
   );

BOOL
UpdateString(
    LPWSTR* ppszCur,
    LPWSTR pszNew);


BOOL
SetPrinterPorts(
    PSPOOL      pSpool,
    PINIPRINTER pIniPrinter,
    PKEYDATA    pKeyData
);

VOID
InternalDeletePrinter(
    PINIPRINTER pIniPrinter
);

BOOL
PurgePrinter(
    PINIPRINTER pIniPrinter
    );

BOOL
AddIniPrinterToIniPort(
    PINIPORT pIniPort,
    PINIPRINTER pIniPrinter
);

BOOL
AddIniPortToIniPrinter(
    PINIPRINTER pIniPrinter,
    PINIPORT pIniPort
);

LPCWSTR
FindFileName(
    LPCWSTR pPathName
    );

VOID
UpdateJobAttributes(
    PINIJOB  pIniJob
    );

BOOL
InternalCopyFile(
    HANDLE  hFile,
    PWIN32_FIND_DATA pSourceFileData,
    LPWSTR  pTagetFileName,
    BOOL    bOverWriteIfTargetExists
    );

BOOL
UpdateFile(
    PINIVERSION pIniVersion,
    HANDLE      hSourceFile,
    LPWSTR      pSourceFile,
    DWORD       dwVersion,
    LPWSTR      pDestDir,
    DWORD       dwFileCopyFlags,
    BOOL        bImpersonateOnCreate,
    LPBOOL      pbFileUpdated,
    LPBOOL      pbFileMoved,
    BOOL        bSameEnvironment,
    BOOL        bWin95Environment
    );

BOOL
PrinterCreateKey(
    HKEY    hKey,
    LPWSTR  pSubKey,
    PHKEY   phkResult,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegSetString(
    HANDLE  hPrinterKey,
    LPWSTR  pValueName,
    LPWSTR  pStringValue,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegSetDWord(
    HANDLE  hPrinterKey,
    LPWSTR  pValueName,
    DWORD   dwParam,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

VOID
CheckAndUpdatePrinterRegAll(
    PINISPOOLER pIniSpooler,
    LPWSTR pszPrinterName,
    LPWSTR pszPort,
    BOOL   bDelete
    );

BOOL
ForEachPrinterCallDriverDrvUpgrade(
    PINISPOOLER         pIniSpooler,
    PINIDRIVER          pIniDriver,
    LPCWSTR             pOldDriverDir,
    PINTERNAL_DRV_FILE  pInternalDriverFile,
    DWORD               dwFileCount,
    LPBYTE              pDriverInfo
);

BOOL
DeleteAllFilesInDirectory(
    LPWSTR pDirectory,
    BOOL   bWaitForReboot
);

BOOL
DeleteAllFilesAndDirectory(
    LPWSTR pDirectory,
    BOOL   bWaitForReboot
    );

VOID
DeleteDirectoryRecursively(
    LPCWSTR pDirectory,
    BOOL    bWaitForReboot
);

DWORD
CreateNumberedTempDirectory(
    LPCWSTR  pszDirectory,
    LPWSTR  *ppszTempDirectory
    );


BOOL
FileExists(
    LPWSTR pFileName
    );

BOOL
DirectoryExists(
    LPWSTR  pDirectoryName
    );

PINIVERSION
FindVersionEntry(
    PINIENVIRONMENT pIniEnvironment,
    DWORD dwVersion
    );

BOOL
CreateDirectoryWithoutImpersonatingUser(
    LPWSTR pDirectory
    );

VOID
InsertVersionList(
    PINIVERSION* pIniVersionHead,
    PINIVERSION pIniVersion
    );

int
wstrcmpEx(
    LPCWSTR s1,
    LPCWSTR s2,
    BOOL    bCaseSensitive
    );

BOOL
RegSetString(
    HANDLE  hKey,
    LPWSTR  pValueName,
    LPWSTR  pStringValue,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegSetDWord(
    HANDLE  hKey,
    LPWSTR  pValueName,
    DWORD   dwParam,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegSetBinaryData(
    HKEY    hKey,
    LPWSTR  pValueName,
    LPBYTE  pData,
    DWORD   cbData,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegSetMultiString(
    HANDLE  hKey,
    LPWSTR  pValueName,
    LPWSTR  pStringValue,
    DWORD   cbString,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    );

BOOL
RegGetString(
    HANDLE  hKey,
    LPWSTR  pValueName,
    LPWSTR *ppValue,
    LPDWORD pcchCount,
    PDWORD  pdwLastError,
    BOOL    bFailIfNotFound,
    PINISPOOLER pIniSpooler
    );

BOOL
RegGetMultiSzString(
    HANDLE    hKey,
    LPWSTR    pValueName,
    LPWSTR   *ppValue,
    LPDWORD   pcchValue,
    PDWORD    pdwLastError,
    BOOL      bFailIfNotFound,
    PINISPOOLER pIniSpooler
    );

DWORD
ValidatePrinterName(
    LPWSTR          pszNewName,
    PINISPOOLER     pIniSpooler,
    PINIPRINTER     pIniPrinter,
    LPWSTR         *ppszLocalName
    );

DWORD
ValidatePrinterShareName(
    LPWSTR          pszNewShareName,
    PINISPOOLER     pIniSpooler,
    PINIPRINTER     pIniPrinter
    );

BOOL
AllocOrUpdateStringAndTestSame(
    IN      LPWSTR      *ppString,
    IN      LPCWSTR     pNewValue,
    IN      LPCWSTR     pOldValue,
    IN      BOOL        bCaseSensitive,
    IN  OUT BOOL        *pbFail,
    IN  OUT BOOL        *pbIdentical
    );

BOOL
AllocOrUpdateString(
    IN      LPWSTR      *ppString,
    IN      LPCWSTR     pNewValue,
    IN      LPCWSTR     pOldValue,
    IN      BOOL        bCaseSensitive,
    IN  OUT BOOL        *bFail
    );

VOID
FreeStructurePointers(
    LPBYTE  lpStruct,
    LPBYTE  lpStruct2,
    LPDWORD lpOffsets);

VOID
CopyNewOffsets(
    LPBYTE  pStruct,
    LPBYTE  pTempStruct,
    LPDWORD lpOffsets
    );

LPWSTR
GetConfigFilePath(
    IN PINIPRINTER  pIniPrinter
    );

PDEVMODE
ConvertDevModeToSpecifiedVersion(
    IN  PINIPRINTER pIniPrinter,
    IN  PDEVMODE    pDevMode,
    IN  LPWSTR      pszConfigFile,              OPTIONAL
    IN  LPWSTR      pszPrinterNameWithToken,    OPTIONAL
    IN  BOOL        bNt35xVersion
    );

BOOL
CreateRedirectionThread(
    PINIPORT pIniPort
    );

VOID
RemoveDeviceName(
    PINIPORT pIniPort
    );

BOOL
IsPortType(
    LPWSTR  pPort,
    LPWSTR  pPrefix
    );

BOOL
LocalSetPort(
    LPWSTR      pszName,
    LPWSTR      pszPortName,
    DWORD       dwLevel,
    LPBYTE      pPortInfo
    );

DWORD
SetPrinterDataServer(
    PINISPOOLER    pIniSpooler,
    LPWSTR      pValueName,
    DWORD       Type,
    LPBYTE      pData,
    DWORD       cbData
    );

BOOL
BuildPrintObjectProtection(
    IN PUCHAR AceType,
    IN DWORD AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN BYTE *InheritFlags,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMap,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    );

LPWSTR
AnsiToUnicodeStringWithAlloc(
    LPSTR   pAnsi
    );

HRESULT
UnicodeToAnsiString(
    IN      PWSTR           pszUnicode,
        OUT PSTR            *ppszAnsi
    );

HRESULT
BuildIPArrayFromCommaList(
    LPTSTR   pszCommaList,
    LPWSTR **ppszNames,
    DWORD   *pcNames
    );

VOID
FreeIniMonitor(
    PINIMONITOR pIniMonitor
    );

DWORD
RestartJob(
    PINIJOB pIniJob
    );

BOOL
IsCallViaRPC(
    IN VOID
    );

VOID
UpdateReferencesToChainedJobs(
    PINISPOOLER pIniSpooler
    );

BOOL
PrinterDriverEvent(
    PINIPRINTER pIniPrinter,
    INT         PrinterEvent,
    LPARAM      lParam,
    DWORD       *pdwReturnedError
);

BOOL
SetPrinterShareInfo(
    PINIPRINTER     pIniPrinter
    );

VOID
LinkPortToSpooler(
    PINIPORT pIniPort,
    PINISPOOLER pIniSpooler
    );

VOID
DelinkPortFromSpooler(
    PINIPORT pIniPort,
    PINISPOOLER pIniSpooler
    );


DWORD
FinalInitAfterRouterInitComplete(
    DWORD dwUpgrade,
    PINISPOOLER pIniSpooler
    );

DWORD
CheckWebPrinting(
                BOOL*  bWebPrintingInstalled
                );

DWORD
WebShareManager(
               PINISPOOLER pIniSpooler,
               BOOL        bEnableWebShares
               );

VOID
WebShare(
    LPWSTR pShareName
);

VOID
WebUnShare(
    LPWSTR pShareName
);

DWORD
OpenPrinterKey(
    PINIPRINTER pIniPrinter,
    REGSAM      samDesired,
    HANDLE      *phKey,
    LPCWSTR     pKeyName,
    BOOL        bOpen
);

DWORD
GetIniDriverAndDirForThisMachine(
    IN  PINIPRINTER     pIniPrinter,
    OUT LPWSTR          pszDriverDir,
    OUT PINIDRIVER     *ppIniDriver
    );

BOOL
CopyAllFilesAndDeleteOldOnes(
    PINIVERSION         pIniVersion,
    PINTERNAL_DRV_FILE  pInternalDriverFile,
    DWORD               dwFileCount,
    LPWSTR              pDestDir,
    DWORD               dwFileCopyFlags,
    BOOL                bImpersonateOnCreate,
    LPBOOL              pbFileMoved,
    BOOL                bSameEnvironment,
    BOOL                bWin95Environment
    );

BOOL LocalDriverUnloadComplete(
    LPWSTR   pDriverFile);


VOID PendingDriverUpgrades(
    LPWSTR   pDriverFile
    );

BOOL
GenerateDirectoryNamesForCopyFilesKey(
    PSPOOL      pSpool,
    HKEY        hKey,
    LPWSTR     *ppszSourceDir,
    LPWSTR     *ppszTargetDir,
    DWORD       cbMax
    );

LPWSTR
BuildFilesCopiedAsAString(
    PINTERNAL_DRV_FILE  pInternalDriverFile,
    DWORD               dwCount
    );

VOID
SeekPrinterSetEvent(
    PINIJOB  pIniJob,
    HANDLE   hFile,
    BOOL     bEndDoc
    );

VOID
SetPortErrorEvent(
    PINIPORT pIniPort
    );

BOOL
DeleteIniPrinterDevNode(
    PINIPRINTER     pIniPrinter
    );

VOID
SplConfigChange(
    );

BOOL
DeletePrinterInAllConfigs(
    PINIPRINTER     pIniPrinter
    );

BOOL
WritePrinterOnlineStatusInCurrentConfig(
    PINIPRINTER     pIniPrinter
    );

BOOL
IsDsPresent(
    VOID
    );

PWSTR
FixDelim(
    PCWSTR  pszInBuffer,
    WCHAR   wcDelim
);

PWSTR
Array2DelimString(
    PSTRINGS    pStringArray,
    WCHAR       wcDelim
);

PSTRINGS
ShortNameArray2LongNameArray(
    PSTRINGS pShortNames
);

PSTRINGS
DelimString2Array(
    PCWSTR  pszDelimString,
    WCHAR   wcDelim
);

BOOL
ValidateXcvHandle(
    PINIXCV pIniXcv
);

VOID
FreeStringArray(
    PSTRINGS pStrings
);

PSTRINGS
AllocStringArray(
    DWORD   nStrings
);


VOID
GetRegistryLocation(
    HANDLE hKey,
    LPCWSTR pszPath,
    PHANDLE phKeyOut,
    LPCWSTR *ppszPathOut
    );

PWSTR
GetPrinterUrl(
    PSPOOL pSpool
);

VOID
ClearJobError(
    PINIJOB pIniJob
    );

BOOL
UpdateDriverFileRefCnt(
    PINIENVIRONMENT  pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver,
    LPCWSTR pDirectory,
    DWORD   dwDeleteFlag,
    BOOL    bIncrementFlag
    );


BOOL
LocalRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyRefresh,
    LPVOID* ppPrinterNotifyInfo
    );

BOOL
CopyRegistryKeys(
    HKEY hSourceParentKey,
    LPWSTR szSourceKey,
    HKEY hDestParentKey,
    LPWSTR szDestKey,
    PINISPOOLER pIniSpooler
    );

BOOL
SplDeleteFile(
    LPCTSTR lpFileName
    );

BOOL
SplMoveFileEx(
    LPCTSTR lpExistingFileName,
    LPCTSTR lpNewFileName,
    DWORD dwFlags
    );

DWORD
GetDefaultForKMPrintersBlockedPolicy (
    );

ULONG_PTR
AlignToRegType(
    IN  ULONG_PTR   Data,
    IN  DWORD       RegType
    );

BOOL
InternalINFInstallDriver(
    LPDRIVER_INFO_7 pDriverInfo
);

DWORD
GetServerInstallTimeOut(
);


BOOL
AllowFaxSharing(
    VOID
    );

BOOL
GetClientSessionData(
        OUT ULONG           *plSessionId        
    );

BOOL
ShowThisPrinter(
    IN      PINIPRINTER     pIniPrinter,
    IN      HANDLE          hToken              OPTIONAL
    );

BOOL
PrinterNotificationVisible(
    IN      PINIPRINTER     pIniPrinter         OPTIONAL,
    IN      PSPOOL          pSpool
    );

DWORD
DetermineJobSessionId(
    PSPOOL pSpool
    );

typedef BOOLEAN
(*PWINSTATION_SEND_MESSAGEW)(
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR  pTitle,
    ULONG TitleLength,
    LPWSTR  pMessage,
    ULONG MessageLength,
    ULONG Style,
    ULONG Timeout,
    PULONG pResponse,
    BOOL  DoNotWait
    );

int
WinStationMessage(
    DWORD SessionId,
    HWND  hWnd,
    DWORD Type,
    int CaptionID,
    int TextID,
    ...
    );

int
WinStationMessageBox(
    DWORD SessionId,
    HWND  hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    );

BOOL
InitializeMessageBoxFunction(
);

VOID
LogFatalPortError(
    IN      PINISPOOLER         pIniSpooler,
    IN      PCWSTR              pszName
    );

VOID
FreeIniEnvironment(
    IN      PINIENVIRONMENT     pIniEnvironment
    );

VOID
DeleteIniVersion(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion
    );

VOID
FreeIniDriver(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver
    );

VOID
FreeIniPrintProc(
    IN      PINIPRINTPROC       pIniPrintProc
    );

BOOL
MergeMultiSz(
    IN      PCWSTR              pszMultiSz1,
    IN      DWORD               cchMultiSz1,
    IN      PCWSTR              pszMultiSz2,
    IN      DWORD               cchMultiSz2,
        OUT PWSTR               *ppszMultiSzMerge,
        OUT DWORD               *pcchMultiSzMerge       OPTIONAL
    );

BOOL
AddMultiSzNoDuplicates(
    IN      PCWSTR              pszMultiSzIn,
    IN  OUT PWSTR               pszNewMultiSz,
    IN      DWORD               cchNewMultiSz
    );

DWORD
GetMultiSZLen(
    IN      LPWSTR              pMultiSzSrc
    );

DWORD
CheckShareSame(
    IN      PINIPRINTER         pIniPrinter,
    IN      SHARE_INFO_502      *pShareInfo502,
        OUT BOOL                *pbSame
    );


EXTERN_C
HRESULT
StrCchCopyMultipleStr(
    IN      PWSTR       pszBuffer,
    IN      SIZE_T      cchBuffer,
    IN      PCWSTR      pszSource,
        OUT PWSTR       *ppszNext,
        OUT SIZE_T      *pcchRemaining
    );

EXTERN_C
HRESULT
StrCbCopyMultipleStr(
    IN      PWSTR       pszBuffer,
    IN      SIZE_T      cbBuffer,
    IN      PCWSTR      pszSource,
        OUT PWSTR       *ppszNext,
        OUT SIZE_T      *pcbRemaining
    );

BOOL
IsStringNullTerminatedInBuffer(
    IN      PWSTR       pszBuffer,
    IN      SIZE_T      cchBuffer
    );

VOID
DiscardJobFromPortThread(
    IN      PINIJOB         pIniJob,
    IN      BOOL            bStartDocComplete
    );

BOOL
RetrieveMasqPrinterInfo(
    IN      PSPOOL              pSpool,
        OUT PRINTER_INFO_2      **ppPrinterInfo
    );

DWORD
GetPrinterInfoFromRouter(
    IN      HANDLE              hMasqPrinter,
        OUT PRINTER_INFO_2      **ppPrinterInfo
    );

DWORD
AsyncPopulateMasqPrinterCache(
    IN      VOID                *ThreadData
    );

BOOL 
GetClientTokenForNotification(
    IN  OUT SPOOL               *pSpool
    );


//
// WMI macros to fill the WMI data struct.
//
#define SplWmiCopyEndJobData(WmiData, pIniJob, CreateInfo) \
{ \
    if ((pIniJob)->pDatatype && \
        (_wcsnicmp((pIniJob)->pDatatype, L"TEXT", 4) == 0)) \
        (WmiData)->uJobData.eDataType = eDataTypeTEXT; \
    else if ((pIniJob)->pDatatype && \
             (_wcsnicmp((pIniJob)->pDatatype, L"NT EMF", 6) == 0)) \
        (WmiData)->uJobData.eDataType = eDataTypeEMF; \
    else \
        (WmiData)->uJobData.eDataType = eDataTypeRAW; \
    (WmiData)->uJobData.ulSize = (pIniJob)->Size; \
    (WmiData)->uJobData.ulPages = (pIniJob)->cPagesPrinted; \
    (WmiData)->uJobData.ulPagesPerSide = (pIniJob)->dwJobNumberOfPagesPerSide; \
    (WmiData)->uJobData.sFilesOpened = 0; \
    (WmiData)->uJobData.sFilesOpened += \
        (((CreateInfo) & FP_SHD_CREATED) ? 1 : 0); \
    (WmiData)->uJobData.sFilesOpened += \
        (((CreateInfo) & FP_SPL_WRITER_CREATED) ? 1 : 0); \
    (WmiData)->uJobData.sFilesOpened += \
        (((CreateInfo) & FP_SPL_READER_CREATED) ? 1 : 0); \
}

#define SplWmiCopyRenderedData(WmiData, pDevmode) \
{ \
    DWORD dmFields = (pDevmode)->dmFields; \
    if (dmFields & DM_YRESOLUTION) { \
        (WmiData)->uEmfData.sXRes = (pDevmode)->dmPrintQuality; \
        (WmiData)->uEmfData.sYRes = (pDevmode)->dmYResolution; \
        (WmiData)->uEmfData.sQuality = 0; \
    } \
    else if (dmFields & DM_PRINTQUALITY) { \
        (WmiData)->uEmfData.sQuality = (pDevmode)->dmPrintQuality; \
        (WmiData)->uEmfData.sXRes = 0; \
        (WmiData)->uEmfData.sYRes = 0; \
    } \
    else { \
        (WmiData)->uEmfData.sQuality = 0; \
        (WmiData)->uEmfData.sXRes = 0; \
        (WmiData)->uEmfData.sYRes = 0; \
    } \
        (WmiData)->uEmfData.sColor      = (dmFields & DM_COLOR     ? (pDevmode)->dmColor     : 0); \
    (WmiData)->uEmfData.sCopies     = (dmFields & DM_COPIES    ? (pDevmode)->dmCopies    : 0); \
    (WmiData)->uEmfData.sTTOption   = (dmFields & DM_TTOPTION  ? (pDevmode)->dmTTOption  : 0); \
    (WmiData)->uEmfData.ulICMMethod = (dmFields & DM_ICMMETHOD ? (pDevmode)->dmICMMethod : 0); \
    (WmiData)->uEmfData.ulSize = 0;\
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\init.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation
All rights reserved.

Module Name:

    init.c

Abstract:

    This module has all the initialization functions for the Local Print Provider

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Felix Maxa (amaxa) 18-Jun-2000
    Modified SplCreateSpooler to special case cluster pIniSpooler
    Modified LoadPrintProcessor to be able to copy the print processor
    from the cluster disk
    Added SplCreateSpoolerWorkerThread
          ClusterAddDriversFromClusterDisk
          ClusterAddVersionDrivers
          ClusterAddOrUpdateDriverFromClusterDisk, all part of the DCR
    regarding installing rpinter drivers on clusters

    Adina Trufinescu (adinatru) 07-December 1998
    Commented InitializePrintMonitor2 ;
    Changed back to the old interface - InitializePrintMonitor - which is defined in localmon.c


    Khaled Sedky (khaleds) 1-September 1998
    Modified InitializePrintProcessor amd added LoadPrintProcessor
    as a result of merging winprint and localspl

    Steve Wilson (swilson)  1-November 1996
    Added ShadowFile2 so spooler can delete crashing shadowfiles.

    Muhunthan Sivapragasam (MuhuntS) 1-June-1995
    Driver info 3 changes; Changes to use RegGetString, RegGetDword etc

    Matthew A Felton (MattFe) 27-June-1994
    pIniSpooler - allow other providers to call the spooler functions in LocalSpl

--*/

#include <precomp.h>
#pragma hdrstop

#include <lm.h>
#include <winbasep.h>
#include <faxreg.h>
#include "clusspl.h"
#include "jobid.h"
#include "filepool.hxx"

MODULE_DEBUG_INIT( DBG_ERROR , DBG_ERROR );

UINT gcClusterIniSpooler = 0;
#if DBG
HANDLE ghbtClusterRef = 0;
#endif

MONITORREG gMonitorReg = {
    sizeof( MONITORREG ),
    &SplRegCreateKey,
    &SplRegOpenKey,
    &SplRegCloseKey,
    &SplRegDeleteKey,
    &SplRegEnumKey,
    &SplRegQueryInfoKey,
    &SplRegSetValue,
    &SplRegDeleteValue,
    &SplRegEnumValue,
    &SplRegQueryValue
};

VOID
SplCreateSpoolerWorkerThread(
    PVOID pv
    );

DWORD
ClusterAddOrUpdateDriverFromClusterDisk(
    HKEY         hVersionKey,
    LPCWSTR      pszDriverName,
    LPCWSTR      pszEnvName,
    LPCWSTR      pszEnvDir,
    PINISPOOLER  pIniSpooler
    );

BOOL
Old2NewShadow(
    PSHADOWFILE   pShadowFile1,
    PSHADOWFILE_3 pShadowFile2,
    DWORD         *pnBytes
    );

VOID
FreeIniVersion(
    PINIVERSION pIniVersion
    );

BOOL
NotIniSpooler(
    BYTE *pMem
    );

PINIDRIVER
GetDriverList(
    HKEY hVersionKey,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion
    );

PINIVERSION
GetVersionDrivers(
    HKEY hDriversKey,
    LPWSTR VersionName,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment
    );

VOID
GetPrintSystemVersion(
    PINISPOOLER pIniSpooler
    );

VOID
InitializeSpoolerSettings(
    PINISPOOLER pIniSpooler
    );

VOID
WaitForSpoolerInitialization(
    VOID
    );

BOOL
ValidateProductSuite(
    PWSTR SuiteName
    );

LPWSTR
FormatRegistryKeyForPrinter(
    LPWSTR pSource,     /* The string from which backslashes are to be added. */
    LPWSTR pScratch     /* Scratch buffer for the function to write in;     */
    );                  /* must be at least as long as pSource.             */

#define MAX_LENGTH_DRIVERS_SHARE_REMARK 256

WCHAR *szSpoolDirectory   = L"\\spool";
WCHAR *szPrintShareName   = L"";            /* No share for printers in product1 */
WCHAR *szPrintDirectory   = L"\\printers";
WCHAR *szDriversDirectory = L"\\drivers";
WCHAR *gszNT4EMF = L"NT EMF 1.003";
WCHAR *gszNT5EMF = L"NT EMF 1.008";


SHARE_INFO_2 DriversShareInfo={NULL,                /* Netname - initialized below */
                               STYPE_DISKTREE,      /* Type of share */
                               NULL,                /* Remark */
                               0,                   /* Default permissions */
                               SHI_USES_UNLIMITED,  /* No users limit */
                               SHI_USES_UNLIMITED,  /* Current uses (??) */
                               NULL,                /* Path - initialized below */
                               NULL};               /* No password */


//  WARNING
//      Do not access these directly always go via pIniSpooler->pszRegistr...
//      This will then work for multiple pIniSpoolers

PWCHAR ipszRoot                   = L"Print";
PWCHAR ipszRegistryRoot           = L"System\\CurrentControlSet\\Control\\Print";
PWCHAR ipszRegistryPrinters       = L"System\\CurrentControlSet\\Control\\Print\\Printers";
PWCHAR ipszRegSwPrinters          = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Printers";
PWCHAR ipszRegistryMonitors       = L"Monitors";
PWCHAR ipszRegistryMonitorsHKLM   = L"\\System\\CurrentControlSet\\Control\\Print\\Monitors";
PWCHAR ipszRegistryEnvironments   = L"System\\CurrentControlSet\\Control\\Print\\Environments";
PWCHAR ipszClusterDatabaseEnvironments = L"Environments";
PWCHAR ipszRegistryEventLog       = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\Print";
PWCHAR ipszRegistryProviders      = L"Providers";
PWCHAR ipszEventLogMsgFile        = L"%SystemRoot%\\System32\\LocalSpl.dll";
PWCHAR ipszDriversShareName       = L"print$";
PWCHAR ipszRegistryForms          = L"System\\CurrentControlSet\\Control\\Print\\Forms";
PWCHAR ipszRegistryProductOptions = L"System\\CurrentControlSet\\Control\\ProductOptions";
PWCHAR ipszRegistryWin32Root      = L"System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Servers";
PWCHAR ipszRegistryClusRepository = SPLREG_CLUSTER_LOCAL_ROOT_KEY;

WCHAR *szPrinterData      = L"PrinterDriverData";
WCHAR *szConfigurationKey = L"Configuration File";
WCHAR *szDataFileKey      = L"Data File";
WCHAR *szDriverVersion    = L"Version";
WCHAR *szTempDir          = L"TempDir";
WCHAR *szDriverAttributes = L"DriverAttributes";
WCHAR *szDriversKey       = L"Drivers";
WCHAR *szPrintProcKey     = L"Print Processors";
WCHAR *szPrintersKey      = L"Printers";
WCHAR *szEnvironmentsKey  = L"Environments";
WCHAR *szDirectory        = L"Directory";
WCHAR *szDriverIni        = L"Drivers.ini";
WCHAR *szDriverFile       = L"Driver";
WCHAR *szDriverDir        = L"DRIVERS";
WCHAR *szPrintProcDir     = L"PRTPROCS";
WCHAR *szPrinterDir       = L"PRINTERS";
WCHAR *szClusterPrinterDir= L"Spool";
WCHAR *szPrinterIni       = L"\\printer.ini";
WCHAR *szAllSpools        = L"\\*.SPL";
WCHAR *szNullPort         = L"NULL";
WCHAR *szComma            = L",";
WCHAR *szName             = L"Name";
WCHAR *szShare            = L"Share Name";
WCHAR *szPort             = L"Port";
WCHAR *szPrintProcessor   = L"Print Processor";
WCHAR *szDatatype         = L"Datatype";
WCHAR *szDriver           = L"Printer Driver";
WCHAR *szLocation         = L"Location";
WCHAR *szDescription      = L"Description";
WCHAR *szAttributes       = L"Attributes";
WCHAR *szStatus           = L"Status";
WCHAR *szPriority         = L"Priority";
WCHAR *szDefaultPriority  = L"Default Priority";
WCHAR *szUntilTime        = L"UntilTime";
WCHAR *szStartTime        = L"StartTime";
WCHAR *szParameters       = L"Parameters";
WCHAR *szSepFile          = L"Separator File";
WCHAR *szDevMode          = L"Default DevMode";
WCHAR *szSecurity         = L"Security";
WCHAR *szSpoolDir         = L"SpoolDirectory";
WCHAR *szNetMsgDll        = L"NETMSG.DLL";
WCHAR *szMajorVersion     = L"MajorVersion";
WCHAR *szMinorVersion     = L"MinorVersion";
WCHAR *szTimeLastChange   = L"ChangeID";
WCHAR *szHelpFile         = L"Help File";
WCHAR *szMonitor          = L"Monitor";
WCHAR *szDependentFiles   = L"Dependent Files";
WCHAR *szPreviousNames    = L"Previous Names";
WCHAR *szDNSTimeout       = L"dnsTimeout";
WCHAR *szTXTimeout        = L"txTimeout";
WCHAR *szNTFaxDriver      = FAX_DRIVER_NAME;
WCHAR *szObjectGUID       = L"ObjectGUID";
WCHAR *szDsKeyUpdate      = L"DsKeyUpdate";
WCHAR *szDsKeyUpdateForeground = L"DsKeyUpdateForeground";
WCHAR *szAction           = L"Action";
WCHAR *szMfgName          = L"Manufacturer";
WCHAR *szOEMUrl           = L"OEM URL";
WCHAR *szHardwareID       = L"HardwareID";
WCHAR *szProvider         = L"Provider";
WCHAR *szDriverDate       = L"DriverDate";
WCHAR *szLongVersion      = L"DriverVersion";
WCHAR *szClusDrvTimeStamp = L"TimeStamp";
const WCHAR szDiscardTSJobs[] = L"DiscardTSJobs";
const WCHAR szDisableFilePooling[] = L"DisableServerFilePooling";

WCHAR *szRegistryRoot     = L"System\\CurrentControlSet\\Control\\Print";
WCHAR *szEMFThrottle      = L"EMFThrottle";
WCHAR *szFlushShadowFileBuffers = L"FlushShadowFileBuffers";
WCHAR *szPendingUpgrades  = L"PendingUpgrades";

WCHAR *szPrintPublishPolicy = L"Software\\Policies\\Microsoft\\Windows NT\\Printers";

WCHAR *szClusterDriverRoot       = L"PrinterDrivers";
WCHAR *szClusterNonAwareMonitors = L"OtherMonitors";

#if DBG
WCHAR *szDebugFlags       = L"DebugFlags";
#endif

WCHAR *szEnvironment      = LOCAL_ENVIRONMENT;
WCHAR *szWin95Environment = L"Windows 4.0";
const WCHAR gszCacheMasqPrinters[] = L"CacheMasqPrinters";

HANDLE hInst;

//  Time before a job is assumed abandond and deleted during FastPrint
//  operation
DWORD   dwFastPrintWaitTimeout        = FASTPRINT_WAIT_TIMEOUT;
DWORD   dwSpoolerPriority             = THREAD_PRIORITY_NORMAL;
DWORD   dwPortThreadPriority          = DEFAULT_PORT_THREAD_PRIORITY;
DWORD   dwSchedulerThreadPriority     = DEFAULT_SCHEDULER_THREAD_PRIORITY;
DWORD   dwFastPrintThrottleTimeout    = FASTPRINT_THROTTLE_TIMEOUT;
DWORD   dwFastPrintSlowDownThreshold  = FASTPRINT_SLOWDOWN_THRESHOLD;
DWORD   dwServerThreadPriority        = DEFAULT_SERVER_THREAD_PRIORITY;
DWORD   dwEnableBroadcastSpoolerStatus = 0;

//  NT 3.1  No Version ( Version 0 )    User Mode
//  NT 3.5 and 3.51      Version 1      User Mode
//  NT 4.0               Version 2      Kernel Mode

DWORD   dwMajorVersion = SPOOLER_VERSION;
DWORD   dwMinorVersion = 0;

// Unique Printer ID counter which increases monotonically. Wraps at 4G.
DWORD   dwUniquePrinterSessionID = 0;

// Globals for EMF job scheduling

DWORD   dwNumberOfEMFJobsRendering = 0;
BOOL    bUseEMFScheduling = FALSE;
SIZE_T  TotalMemoryForRendering = 0;
SIZE_T  AvailMemoryForRendering = 0;
DWORD   dwLastScheduleTime = 0;

PJOBDATA pWaitingList  = NULL;
PJOBDATA pScheduleList = NULL;

DWORD   dwFlushShadowFileBuffers  = 0;     // default for uninitialized


// Time to sleep if the LocalWritePrinter WritePort doesn't write any bytes
// but still returns success.
DWORD   dwWritePrinterSleepTime  = WRITE_PRINTER_SLEEP_TIME;

BOOL    gbRemoteFax = TRUE;

BOOL      Initialized = FALSE;

PINISPOOLER     pLocalIniSpooler = NULL;
PINIENVIRONMENT pThisEnvironment = NULL;

#define POOL_TIMEOUT     120000 // 2 minutes
#define MAX_POOL_FILES   50

//
// Allowing remote connection policy.
//
ERemoteRPCEndPointPolicy gRemoteRPCEndPointPolicy;

//
//  Global for KM Printers Blocking Policy
//  by default it is
//  1 "blocked" for Server and
//  0 "not blocked" for Workstation
//
DWORD   DefaultKMPrintersAreBlocked;

//
// Read from the registry if the HKLM\...\Print\ServerInstallTimeOut DWORD entry exists
// Otherwise default 5 mins.
//
DWORD   gdwServerInstallTimeOut;


//
//  0 - Not upgrading, 1 - performing upgrade
//

DWORD dwUpgradeFlag = 0;

LPWSTR szRemoteDoc;
LPWSTR szLocalDoc;
LPWSTR szFastPrintTimeout;
LPWSTR szRaw = L"RAW";


PRINTPROVIDOR PrintProvidor = {LocalOpenPrinter,
                               LocalSetJob,
                               LocalGetJob,
                               LocalEnumJobs,
                               LocalAddPrinter,
                               SplDeletePrinter,
                               SplSetPrinter,
                               SplGetPrinter,
                               LocalEnumPrinters,
                               LocalAddPrinterDriver,
                               LocalEnumPrinterDrivers,
                               SplGetPrinterDriver,
                               LocalGetPrinterDriverDirectory,
                               LocalDeletePrinterDriver,
                               LocalAddPrintProcessor,
                               LocalEnumPrintProcessors,
                               LocalGetPrintProcessorDirectory,
                               LocalDeletePrintProcessor,
                               LocalEnumPrintProcessorDatatypes,
                               LocalStartDocPrinter,
                               LocalStartPagePrinter,
                               LocalWritePrinter,
                               LocalEndPagePrinter,
                               LocalAbortPrinter,
                               LocalReadPrinter,
                               LocalEndDocPrinter,
                               LocalAddJob,
                               LocalScheduleJob,
                               SplGetPrinterData,
                               SplSetPrinterData,
                               LocalWaitForPrinterChange,
                               SplClosePrinter,
                               SplAddForm,
                               SplDeleteForm,
                               SplGetForm,
                               SplSetForm,
                               SplEnumForms,
                               LocalEnumMonitors,
                               LocalEnumPorts,
                               LocalAddPort,
                               LocalConfigurePort,
                               LocalDeletePort,
                               LocalCreatePrinterIC,
                               LocalPlayGdiScriptOnPrinterIC,
                               LocalDeletePrinterIC,
                               LocalAddPrinterConnection,
                               LocalDeletePrinterConnection,
                               LocalPrinterMessageBox,
                               LocalAddMonitor,
                               LocalDeleteMonitor,
                               SplResetPrinter,
                               SplGetPrinterDriverEx,
                               LocalFindFirstPrinterChangeNotification,
                               LocalFindClosePrinterChangeNotification,
                               LocalAddPortEx,
                               NULL,
                               LocalRefreshPrinterChangeNotification,
                               LocalOpenPrinterEx,
                               LocalAddPrinterEx,
                               LocalSetPort,
                               SplEnumPrinterData,
                               SplDeletePrinterData,
                               SplClusterSplOpen,
                               SplClusterSplClose,
                               SplClusterSplIsAlive,
                               SplSetPrinterDataEx,
                               SplGetPrinterDataEx,
                               SplEnumPrinterDataEx,
                               SplEnumPrinterKey,
                               SplDeletePrinterDataEx,
                               SplDeletePrinterKey,
                               LocalSeekPrinter,
                               LocalDeletePrinterDriverEx,
                               LocalAddPerMachineConnection,
                               LocalDeletePerMachineConnection,
                               LocalEnumPerMachineConnections,
                               LocalXcvData,
                               LocalAddPrinterDriverEx,
                               SplReadPrinter,
                               LocalDriverUnloadComplete,
                               LocalGetSpoolFileHandle,
                               LocalCommitSpoolData,
                               LocalCloseSpoolFileHandle,
                               LocalFlushPrinter,
                               LocalSendRecvBidiData,
                               LocalAddDriverCatalog,
                               };

DWORD
FinalInitAfterRouterInitCompleteThread(
    DWORD dwUpgrade
    );

#if DBG
VOID
InitializeDebug(
    PINISPOOLER pIniSpooler
);

PDBG_POINTERS
DbgSplGetPointers(
    VOID
    );
#endif

BOOL
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes
)
{
    BOOL bRet = TRUE;


    switch(dwReason) {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(hModule);
        hInst = hModule;

        bRet = InitializeLocalspl();

        if (bRet)
        {
            bRet = LocalMonInit(hInst);
        }

        break;

    case DLL_PROCESS_DETACH :
        ShutdownPorts( pLocalIniSpooler );
        break;

    default:
        break;
    }

    return bRet;

    UNREFERENCED_PARAMETER( lpRes );
}


BOOL
InitializeLocalspl(
    VOID
    )
{
    BOOL    bRet = TRUE;

#if DBG
    gpDbgPointers = DbgGetPointers();

    if( gpDbgPointers ){

        hcsSpoolerSection = gpDbgPointers->pfnAllocCritSec();
        SPLASSERT( hcsSpoolerSection );

        ghbtClusterRef = gpDbgPointers->pfnAllocBackTrace();
    }

    if( !hcsSpoolerSection ){

        //
        // Must be using the free version of spoolss.dll.
        //
        bRet = InitializeCriticalSectionAndSpinCount(&SpoolerSection, 0x80000000);
    }
#else
    bRet = InitializeCriticalSectionAndSpinCount(&SpoolerSection, 0x80000000);
#endif

    return bRet;
}

VOID
SplDeleteSpoolerThread(
    PVOID pv
    )
{
    PINIPORT        pIniPort;
    PINIPORT        pIniPortNext;

    PINIMONITOR     pIniMonitor;
    PINIMONITOR     pIniMonitorNext;
    PSHARE_INFO_2   pShareInfo;

    PINISPOOLER pIniSpooler = (PINISPOOLER)pv;

    //
    // Remove the cache entry associated with this pIniSpooler. At this time the pIniSpooler
    // is in pending deletion, so nobody is using it anymore.
    //
    CacheDeleteNode(pIniSpooler->pMachineName + 2);

    EnterSplSem();

    //
    // Cleanup the port monitors.
    //
    ShutdownMonitors( pIniSpooler );

    //
    // Close Cluster Access Token
    //
    if (pIniSpooler->hClusterToken != INVALID_HANDLE_VALUE)
        NtClose(pIniSpooler->hClusterToken);


    //
    //  Delete All the Strings
    //

    FreeStructurePointers((LPBYTE)pIniSpooler, NULL, IniSpoolerOffsets);

    DeleteShared( pIniSpooler );

    //
    // Run all of the environments down if this isn't the local ini-spoolers
    // environment. This frees up the memory for all of the drivers and also
    // handles the driver ref-counts.
    //
    if (pIniSpooler->pIniEnvironment != pLocalIniSpooler->pIniEnvironment && pIniSpooler->pIniEnvironment) {

        PINIENVIRONMENT pIniEnvironment  = NULL;
        PINIENVIRONMENT pNextEnvironment = NULL;

        for(pIniEnvironment = pIniSpooler->pIniEnvironment; pIniEnvironment; pIniEnvironment = pNextEnvironment) {

            pNextEnvironment = pIniEnvironment->pNext;

            FreeIniEnvironment(pIniEnvironment);
        }
    }

    //
    // Delete ports and monitors.
    //
    // Note that there is no reference counting here.  By the time
    // we get here all jobs and printers should be deleted (otherwise
    // the pIniSpooler reference count would be != 0).  Therefore,
    // even though we don't refcount ports and monitors, we should
    // be ok.
    //

    //
    // Remove all ports.
    //
    for( pIniPort = pIniSpooler->pIniPort;
         pIniPort;
         pIniPort = pIniPortNext ){

        pIniPortNext = pIniPort->pNext;

        if( !DeletePortEntry( pIniPort )){
            DBGMSG( DBG_ERROR,
                    ( "Unable to delete port %ws %x %x %d",
                      pIniPort->pName,
                      GetMonitorHandle(pIniPort),
                      pIniPort->Status,
                      pIniPort->cJobs ));
        }
    }

    //
    // Remove all the monitors.
    //
    for( pIniMonitor = pIniSpooler->pIniMonitor;
         pIniMonitor;
         pIniMonitor = pIniMonitorNext ){

        pIniMonitorNext = pIniMonitor->pNext;

        if( !pIniMonitor->cRef ){

            FreeIniMonitor( pIniMonitor );
        }
    }

    //
    // Close cluster resource key handle.
    //
    if( pIniSpooler->hckRoot ){
        SplRegCloseKey( pIniSpooler->hckRoot, pIniSpooler );
    }

    //
    // Close cluster resource key handle.
    //
    if( pIniSpooler->hckPrinters ){
        SplRegCloseKey( pIniSpooler->hckPrinters, pIniSpooler );
    }

    //
    // Keep a counter of cluster pIniSpoolers.
    //
    if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){
        --gcClusterIniSpooler;
    }

    //
    // Free the shared bitmap and shared driver info.
    //
    vDeleteJobIdMap( pIniSpooler->hJobIdMap );

    pShareInfo = (PSHARE_INFO_2)pIniSpooler->pDriversShareInfo;
    FreeSplStr( pShareInfo->shi2_remark );
    FreeSplStr( pShareInfo->shi2_path );

    FreeSplMem( pIniSpooler->pDriversShareInfo );


    LeaveSplSem();

    //
    // Shut down the file pool for this ini-spooler. It should not delete any of
    // the files.
    //
    if (pIniSpooler->hFilePool != INVALID_HANDLE_VALUE) {
        (VOID)DestroyFilePool(pIniSpooler->hFilePool, FALSE);
    }

    // Free this IniSpooler

    FreeSplMem( pIniSpooler );

    DBGMSG( DBG_WARN, ( "SplDeleteSpooler: Refcount 0 %x\n", pIniSpooler ));
}

BOOL
SplDeleteSpooler(
    HANDLE  hSpooler
    )
{
    PINISPOOLER pIniSpooler = (PINISPOOLER) hSpooler;
    BOOL    bReturn = FALSE;
    PINISPOOLER pCurrentIniSpooler = pLocalIniSpooler;

    HANDLE hThread;
    DWORD ThreadId;

    SplInSem();

    //
    // Whoever calls this must have deleted all the object associated with
    // this spooler, ie all printers etc, just make certain
    //

    if( pIniSpooler != pLocalIniSpooler ){

        //
        // Mark us as pending deletion.
        //
        pIniSpooler->SpoolerFlags |= SPL_PENDING_DELETION;

        DBGMSG(DBG_CLUSTER, ("SplDeleteSpooler: Deleting %x\n cRef %u\n", pIniSpooler, pIniSpooler->cRef ));

        //
        // pIniPrinters now acquire a reference to pIniSpooler.
        //
        if( pIniSpooler->cRef == 0 ){

            SPLASSERT( pIniSpooler->pIniPrinter == NULL );

            //( pIniSpooler->pIniPort == NULL ) &&
            //( pIniSpooler->pIniForm == NULL ) &&
            //( pIniSpooler->pIniMonitor == NULL ) &&
            //( pIniSpooler->pIniNetPrint == NULL ) &&
            //( pIniSpooler->pSpool == NULL ))


            //
            // Take this Spooler Off the Linked List if it's on it.
            //

            while (( pCurrentIniSpooler->pIniNextSpooler != NULL ) &&
                   ( pCurrentIniSpooler->pIniNextSpooler != pIniSpooler )) {

                pCurrentIniSpooler = pCurrentIniSpooler->pIniNextSpooler;

            }

            //
            // May not be on the linked list if it was removed earlier by
            // clustering.
            //
            if( pCurrentIniSpooler->pIniNextSpooler ){

                SPLASSERT( pCurrentIniSpooler->pIniNextSpooler == pIniSpooler );
                pCurrentIniSpooler->pIniNextSpooler = pIniSpooler->pIniNextSpooler;
            }

            //
            // Hack for port monitors.
            //
            // Some monitors will call ClosePrinter, which deletes the very
            // last printer and allows the pIniSpooler to be destroyed.
            // Unfortunately, we call back to the monitors to close themselves
            // in the same thread, which the monitor does not support.
            //
            // Create a new thread and shut everything down.
            //
            if (hThread = CreateThread( NULL, 0,
                                        (LPTHREAD_START_ROUTINE)SplDeleteSpoolerThread,
                                        (PVOID)pIniSpooler,
                                        0,
                                        &ThreadId ))
            {
                CloseHandle(hThread);
            }
            else
            {
                //
                // Bug 54840
                //
                // What do we do if we can't create a thread to shut down?
                // Sleep and retry?
                //
                DBGMSG(DBG_ERROR, ("Unable to create SplDeleteSpoolerThread\n"));
            }

            bReturn = TRUE;
        }
    }

    return bReturn;
}

BOOL
SplCloseSpooler(
    HANDLE  hSpooler
)
{
    PINISPOOLER pIniSpooler = (PINISPOOLER) hSpooler;

    EnterSplSem();

    if ((pIniSpooler == NULL) ||
        (pIniSpooler == INVALID_HANDLE_VALUE) ||
        (pIniSpooler == pLocalIniSpooler) ||
        (pIniSpooler->signature != ISP_SIGNATURE) ||
        (pIniSpooler->cRef == 0)) {


        SetLastError( ERROR_INVALID_HANDLE );

        DBGMSG(DBG_WARNING, ("SplCloseSpooler InvalidHandle %x\n", pIniSpooler ));
        LeaveSplSem();
        return FALSE;

    }

    DBGMSG(DBG_TRACE, ("SplCloseSpooler %x %ws cRef %d\n",pIniSpooler,
                                                            pIniSpooler->pMachineName,
                                                            pIniSpooler->cRef-1));

    DECSPOOLERREF( pIniSpooler );

    LeaveSplSem();
    return TRUE;
}

BOOL SplRegCopyTree(
    HKEY hDest,
    HKEY hSrc
    )

/*++
Function Description: Recursives copies every key and value from under hSrc to hDest

Parameters: hDest - destination key
            hSrc  - source key

Return Value: TRUE if successful; FALSE otherwise
--*/

{
    BOOL    bStatus = FALSE;
    DWORD   dwError, dwIndex, cbValueName, cbData, cbKeyName, dwType;
    DWORD   cKeys, cMaxValueNameLen, cMaxValueLen, cMaxKeyNameLen, cValues;

    LPBYTE  lpValueName = NULL, lpData = NULL, lpKeyName = NULL;
    HKEY    hSrcSubKey = NULL, hDestSubKey = NULL;

    //
    // Get the max key name length and value name length and data size for
    // allocating the buffers
    //
    if (dwError = RegQueryInfoKey( hSrc, NULL, NULL, NULL,
                                   &cKeys, &cMaxKeyNameLen, NULL,
                                   &cValues, &cMaxValueNameLen,
                                   &cMaxValueLen, NULL, NULL ))
    {
        SetLastError(dwError);
        goto CleanUp;
    }

    //
    // Adjust for the NULL char
    //
    ++cMaxValueNameLen;
    ++cMaxKeyNameLen;

    //
    // Allocate the buffers
    //
    lpValueName = AllocSplMem( cMaxValueNameLen * sizeof(WCHAR) );
    lpData      = AllocSplMem( cMaxValueLen );
    lpKeyName   = AllocSplMem( cMaxKeyNameLen * sizeof(WCHAR) );

    if (!lpValueName || !lpData || !lpKeyName)
    {
        goto CleanUp;
    }

    //
    // Copy all the values in the current key
    //
    for (dwIndex = 0; dwIndex < cValues; ++dwIndex)
    {
       cbData = cMaxValueLen;
       cbValueName = cMaxValueNameLen;

       //
       // Retrieve the value name and the data
       //
       dwError = RegEnumValue( hSrc, dwIndex, (LPWSTR) lpValueName, &cbValueName,
                               NULL, &dwType, lpData, &cbData );

       if (dwError)
       {
           SetLastError( dwError );
           goto CleanUp;
       }

       //
       // Set the value in the destination
       //
       dwError = RegSetValueEx( hDest, (LPWSTR) lpValueName, 0, dwType,
                                lpData, cbData );

       if (dwError)
       {
           SetLastError( dwError );
           goto CleanUp;
       }
    }

    //
    // Recursively copies all the subkeys
    //
    for (dwIndex = 0; dwIndex < cKeys; ++dwIndex)
    {
        cbKeyName = cMaxKeyNameLen;

        //
        // Retrieve the key name
        //
        dwError = RegEnumKeyEx( hSrc, dwIndex, (LPWSTR) lpKeyName, &cbKeyName,
                                NULL, NULL, NULL, NULL );

        if (dwError)
        {
            SetLastError( dwError );
            goto CleanUp;
        }

        //
        // Open the source subkey
        //
        if (dwError = RegOpenKeyEx( hSrc, (LPWSTR) lpKeyName, 0,
                                    KEY_READ, &hSrcSubKey ))
        {
            SetLastError( dwError );
            goto CleanUp;
        }

        //
        // Create the destination subkey
        //
        if (dwError = RegCreateKeyEx( hDest, (LPWSTR) lpKeyName, 0, NULL,
                                      REG_OPTION_VOLATILE, KEY_READ | KEY_WRITE | DELETE,
                                      NULL, &hDestSubKey, NULL ))
        {
            SetLastError( dwError );
            goto CleanUp;
        }

        //
        // Copy the subkey tree
        //
        if (!SplRegCopyTree( hDestSubKey, hSrcSubKey ))
        {
            goto CleanUp;
        }

        //
        // Close the registry handle
        //
        RegCloseKey( hDestSubKey );
        RegCloseKey( hSrcSubKey );

        hDestSubKey = NULL;
        hSrcSubKey = NULL;
    }

    bStatus = TRUE;

CleanUp:

    //
    // Free allocated resources
    //
    if (lpValueName)
    {
        FreeSplMem( lpValueName );
    }
    if (lpData)
    {
        FreeSplMem( lpData );
    }
    if (lpKeyName)
    {
        FreeSplMem( lpKeyName );
    }

    //
    // Close registry handles
    //
    if (hDestSubKey)
    {
        RegCloseKey( hDestSubKey );
    }
    if (hSrcSubKey)
    {
        RegCloseKey( hSrcSubKey );
    }

    return bStatus;
}

VOID
MigratePrinterData()

/*++
Function Description: When the spooler starts up for the first time after upgrade,
                      the printer data is moved from HKLM\Software to HKLM\System

Parameters: None

Return Values: None
--*/

{
    HKEY   hSysPrinters = NULL, hSwPrinters = NULL;

    //
    // Migrate the data only immediately following upgrade
    //
    if (!dwUpgradeFlag)
    {
        return;
    }

    //
    // Open the source and destination keys for the migration
    //
    if (( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        ipszRegSwPrinters,
                        0,
                        KEY_WRITE | KEY_READ | DELETE,
                        &hSwPrinters )  == ERROR_SUCCESS) &&

        ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        ipszRegistryPrinters,
                        0,
                        KEY_WRITE | KEY_READ | DELETE,
                        &hSysPrinters )  == ERROR_SUCCESS) )
    {
        //
        // Recursively copy the keys and the values from Software to System
        //
        SplRegCopyTree( hSysPrinters, hSwPrinters );
    }

    //
    // Close the registry handles
    //
    if (hSwPrinters)
    {
        RegCloseKey( hSwPrinters );
    }
    if (hSysPrinters)
    {
        RegCloseKey( hSysPrinters );
    }

    //
    // Delete the printers key from the software since it is no longer
    // accessed by the spooler
    //
    RegDeleteKey( HKEY_LOCAL_MACHINE, ipszRegSwPrinters );

    return;
}

NTSTATUS
IsCCSetLinkedtoSoftwareHive (
    PBOOL pbIsLinked
)
/*++
Function Description:
    Checks to see if it is a link between SYSTEM hive and SOFTWARE hive
    Only Nt Apis manage to do this.
Parameters:
    OUT pbIsLinked - TRUE if there is a symbolic link between SYSTEM hive and SOFTWARE hive
Return Values:

--*/
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      KeyName;
    HANDLE              KeyHandle;

    *pbIsLinked = FALSE;

    RtlInitUnicodeString(&KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Print\\Printers");

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENLINK,
                               (HANDLE)NULL,
                               NULL);

    //
    // Open CurrentControlSet\\Control\\Print\\Printers key
    //
    Status = NtOpenKey( (PHANDLE)(&KeyHandle),
                        MAXIMUM_ALLOWED,
                        &ObjectAttributes
                      );

    if (NT_SUCCESS(Status))
    {
        ULONG           len;
        UCHAR           ValueBuffer[MAX_PATH];
        UNICODE_STRING  ValueName;
        PKEY_VALUE_FULL_INFORMATION   keyInfo;

        RtlInitUnicodeString(&ValueName, L"SymbolicLinkValue");

        //
        // Query CurrentControlSet\\Control\\Print\\Printers for SymbolicLinkValue
        //
        Status = NtQueryValueKey(KeyHandle,
                                 &ValueName,
                                 KeyValueFullInformation,
                                 ValueBuffer,
                                 sizeof (ValueBuffer),
                                 &len
                                 );
        if( NT_SUCCESS(Status) ) {

            //
            // It's not enough that the value exists, it should be a REG_LINK value
            //
            keyInfo = ( PKEY_VALUE_FULL_INFORMATION ) ValueBuffer;
            *pbIsLinked = ( keyInfo->Type == REG_LINK );

        }

        NtClose(KeyHandle);
    }

    return Status;
}


DWORD
LinkControlSet (
    LPCTSTR pszRegistryPrinters
)
/*++
Function Description:
    Create a symbolic volatile link from SYSTEM hive to SOFTWARE hive
Parameters:

Return Values: ERROR_SUCCESS if succeeded
--*/
{
    HKEY    hCCSKey;
    DWORD   dwRet;
    BOOL    bIsLinked = FALSE;
    PWCHAR  pszRegistryPrintersFullLink = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Printers";

    dwRet = IsCCSetLinkedtoSoftwareHive(&bIsLinked);

    //
    // IsCCSetLinkedtoSoftwareHive returns NTSTATUS
    // If the link is not there , IsCCSetLinkedtoSoftwareHive fails with STATUS_OBJECT_NAME_NOT_FOUND
    // That's not an error.
    //
    if( NT_SUCCESS(dwRet) || dwRet == STATUS_OBJECT_NAME_NOT_FOUND ) {

        if (bIsLinked) {

            dwRet = ERROR_SUCCESS;

        }else{

            dwRet = SplDeleteThisKey( HKEY_LOCAL_MACHINE,
                                      NULL,
                                      (LPWSTR)pszRegistryPrinters,
                                      FALSE,
                                      NULL
                                    );

            if( dwRet == ERROR_SUCCESS || dwRet == ERROR_FILE_NOT_FOUND) {

                dwRet = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                        pszRegistryPrinters,
                                        0,
                                        NULL,
                                        REG_OPTION_VOLATILE|REG_OPTION_CREATE_LINK,
                                        KEY_WRITE | KEY_CREATE_LINK,
                                        NULL,
                                        &hCCSKey,
                                        NULL);

                if( dwRet == ERROR_SUCCESS )
                {
                    dwRet = RegSetValueEx( hCCSKey,
                                           _T("SymbolicLinkValue"),
                                           0,
                                           REG_LINK,
                                           (CONST BYTE *)pszRegistryPrintersFullLink,
                                           (_tcsclen(pszRegistryPrintersFullLink) * sizeof(WCHAR)));


                    RegCloseKey(hCCSKey);
                }

            }

        }
    }


    return dwRet;
}


DWORD
BackupPrintersToSystemHive(
    LPWSTR pszSwRegistryPrinters
)
/*++
Function Description:
    Because the print registry data location was moved to SOFTWARE hive, we need to create
    a symbolic registry link between the new location and the old one in SYSTEM hive.
    We are doing this for applications that read directly from registry print data and
    rely on the old location.

Parameters:
    pszSwRegistryPrinters - the new printer data location under SOFTWARE hive

Return Values:
    FALSE if the printer keys are not in SOFTWARE hive
    Since this fuction's failure might stop spooler working,
    Control set's cleanup and link failures are not considered fatal.
    Only apps that access printer data directly will fail.
--*/

{
    HKEY   hKey;
    DWORD  dwRet;
    HKEY   hSwPrinters = NULL;

    //
    // Check the existence of pszSwRegistryPrinters
    //
    dwRet = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                            pszSwRegistryPrinters,
                            0,
                            NULL,
                            0,
                            KEY_WRITE | KEY_CREATE_LINK,
                            NULL,
                            &hSwPrinters,
                            NULL);

    if ( dwRet != ERROR_SUCCESS ) {
        goto End;
    }
    //
    // Create a volatile link between current location in SOFTWARE hive and the old one in SYSTEM hive
    // Because it is volatile, this link must be created after each reboot (every time when spooler starts)
    // A failure at this level is not fatal since spooler doesn't rely on SYSTEM hive location anymore
    //
    dwRet = LinkControlSet(ipszRegistryPrinters);

End:

    if ( hSwPrinters ){

        RegCloseKey( hSwPrinters );
    }

    return dwRet;
}


BOOL
CleanupDeletedPrinters (
    PINISPOOLER pIniSpooler
    )
/*++

Routine Description:

      Deletes the printers in pending deletion for real if they have no more jobs and
      if they are not referenced anymore

Arguments:

    pIniSpooler - not null

Return Value:

    BOOL - ignored

--*/

{
    PINIPRINTER pIniPrinter;
    BOOL    bRet = FALSE;

    if(pIniSpooler) {

        pIniPrinter = pIniSpooler->pIniPrinter;

        while (pIniPrinter) {

                if (pIniPrinter->Status & PRINTER_PENDING_DELETION &&
                    !pIniPrinter->cJobs &&
                    !pIniPrinter->cRef ) {

                    DeletePrinterForReal(pIniPrinter, INIT_TIME);

                    // The link list will have changed underneath us
                    // DeletePrinterForReal leaves the Spooler CS
                    // Lets just loop through again from the beginning

                    pIniPrinter = pIniSpooler->pIniPrinter;

                } else

                    pIniPrinter = pIniPrinter->pNext;
            }

        bRet = TRUE;
    }

    return bRet;
}


HANDLE
SplCreateSpooler(
    LPWSTR  pMachineName,
    DWORD   Level,
    PBYTE   pSpooler,
    LPBYTE  pReserved
)
{
    HANDLE          hReturn          = INVALID_HANDLE_VALUE;
    PINISPOOLER     pIniSpooler      = NULL;
    PSPOOLER_INFO_2 pSpoolerInfo2    = (PSPOOLER_INFO_2)pSpooler;
    DWORD           i;
    WCHAR           Buffer[MAX_PATH];
    PSHARE_INFO_2   pShareInfo       = NULL;
    LONG            Status;
    HANDLE          hToken           = NULL;
    DWORD           dwRet;

    hToken = RevertToPrinterSelf();

    if (!hToken)
    {
        goto SplCreateDone;
    }

    EnterSplSem();

    //  Validate Parameters

    if ( pMachineName == NULL ) {
        SetLastError( ERROR_INVALID_NAME );
        goto SplCreateDone;
    }

    if( Level == 1 &&
        ( pSpoolerInfo2->SpoolerFlags & SPL_CLUSTER_REG ||
          !pSpoolerInfo2->pszRegistryRoot ||
          !pSpoolerInfo2->pszRegistryPrinters )){

        SetLastError( ERROR_INVALID_PARAMETER );
        goto SplCreateDone;
    }

    DBGMSG( DBG_TRACE, ("SplCreateSpooler %ws %d %x %x\n", pMachineName,
                         Level, pSpooler, pReserved ));

    if( (pSpoolerInfo2->SpoolerFlags & (SPL_TYPE_LOCAL | SPL_PRINT)) &&
        !(pSpoolerInfo2->SpoolerFlags & SPL_TYPE_CLUSTER) ){

        if ( dwRet = (BackupPrintersToSystemHive( pSpoolerInfo2->pszRegistryPrinters )) != ERROR_SUCCESS ){

            WCHAR szError[256];

            StringCchPrintf(szError, COUNTOF(szError), L"%x", dwRet);

            SplLogEvent(pIniSpooler,
                        LOG_ERROR,
                        MSG_BACKUP_SPOOLER_REGISTRY,
                        TRUE,
                        szError,
                        NULL);
        }
    }

    if (pLocalIniSpooler != NULL) {

        pIniSpooler = FindSpooler( pMachineName, pSpoolerInfo2->SpoolerFlags );

        if (pSpoolerInfo2->SpoolerFlags & SPL_OPEN_EXISTING_ONLY && !pIniSpooler) {

            SetLastError( ERROR_FILE_NOT_FOUND );
            goto SplCreateDone;
        }
    }

    //
    // Make sure we clear out a request to only open an existing inispooler.
    // This is not a useful flag except for when we are searching for inispoolers.
    //
    pSpoolerInfo2->SpoolerFlags &= ~SPL_OPEN_EXISTING_ONLY;

    if ( pIniSpooler == NULL ) {

        pIniSpooler = AllocSplMem( sizeof(INISPOOLER) );

        if (pIniSpooler == NULL ) {
            DBGMSG( DBG_WARNING, ("Unable to allocate IniSpooler\n"));
            goto SplCreateDone;
        }

        pIniSpooler->signature = ISP_SIGNATURE;
        INCSPOOLERREF( pIniSpooler );

        pIniSpooler->hClusSplReady = NULL;
        //
        // Setup the job id map.
        //
        pIniSpooler->hJobIdMap = hCreateJobIdMap( 256 );

        pIniSpooler->pMachineName = AllocSplStr( pMachineName );

        if ( pIniSpooler->pMachineName == NULL ||
             pIniSpooler->hJobIdMap == NULL ) {

            DBGMSG( DBG_WARNING, ("Unable to allocate\n"));
            goto SplCreateDone;
        }

        //
        // A cluster spooler owns its drivers, ports, pprocessors, etc. In order to manage those
        // resources, the cluster spooler needs to have information about the driver letter of
        // the cluster disk. Also the spooler needs to know its own cluster resource GUID
        //
        if( pSpoolerInfo2->SpoolerFlags & SPL_TYPE_CLUSTER )
        {
            pIniSpooler->pszClusResDriveLetter = AllocSplStr(pSpoolerInfo2->pszClusResDriveLetter);
            pIniSpooler->pszClusResID          = AllocSplStr(pSpoolerInfo2->pszClusResID);

            if (!pIniSpooler->pszClusResDriveLetter || !pIniSpooler->pszClusResID)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto SplCreateDone;
            }

            //
            // When a node is upgraded, the resource dll writes a key in the registry. When the cluster spooler
            // fails over for the first time on the node that was upgraded, then it will try to read that key
            // in the registry. Then it will know if it has to do upgrade specific tasks, like upgrading its
            // printer drivers.
            //
            Status = ClusterSplReadUpgradeKey(pIniSpooler->pszClusResID, &pIniSpooler->dwClusNodeUpgraded);

            if (Status != ERROR_SUCCESS)
            {
                SetLastError( Status );
                goto SplCreateDone;
            }

            DBGMSG(DBG_CLUSTER, ("SplCreateSpooler cluster ClusterUpgradeFlag %u\n", pIniSpooler->dwClusNodeUpgraded));
        }
        else
        {
            //
            // For a non cluster type spooler, these properties are meaningless.
            //
            pIniSpooler->pszClusResDriveLetter = NULL;
            pIniSpooler->pszClusResID          = NULL;
        }

        if (pSpoolerInfo2->pDir)
        {
            pIniSpooler->pDir = AllocSplStr( pSpoolerInfo2->pDir );

            if (!pIniSpooler->pDir)
            {
                DBGMSG( DBG_WARNING, ("Unable to allocate pSpoolerInfo2-pDir\n"));
                goto SplCreateDone;
            }

            StringCchCopy(&Buffer[0], COUNTOF(Buffer), pIniSpooler->pDir);
        }
        else
        {
            i = GetSystemDirectory(Buffer, COUNTOF(Buffer));

            StringCchCopy(&Buffer[i], COUNTOF(Buffer) - i, szSpoolDirectory);

            if (pSpoolerInfo2->SpoolerFlags & SPL_TYPE_CLUSTER)
            {
                //
                // For a cluster type spooler, the directory where it stores its driver files is of the form:
                // pDir = C:\Windows\system32\spool\Drivers\spooler-resource-GUID
                //
                StrCatAlloc(&pIniSpooler->pDir,
                            Buffer,
                            szDriversDirectory,
                            L"\\",
                            pIniSpooler->pszClusResID,
                            NULL);
            }
            else
            {
                //
                // For the local spooler, the directory where it stores its driver files is the following:
                // pDir = C:\Windows\system32\spool\Drivers
                //
                StrCatAlloc(&pIniSpooler->pDir,
                            Buffer,
                            NULL);
            }

            if (!pIniSpooler->pDir)
            {
                DBGMSG( DBG_WARNING, ("Unable to Allocate pIniSpooler->pDir\n"));
                goto SplCreateDone;
            }
        }

        //
        // DriverShareInfo
        //
        pIniSpooler->pDriversShareInfo = AllocSplMem( sizeof( SHARE_INFO_2));

        if ( pIniSpooler->pDriversShareInfo == NULL ) {
            DBGMSG(DBG_WARNING, ("Unable to Alloc pIniSpooler->pDriversShareInfo\n"));
            goto SplCreateDone;
        }

        pShareInfo = (PSHARE_INFO_2)pIniSpooler->pDriversShareInfo;

        if ( pIniSpooler->pDriversShareInfo == NULL )
            goto SplCreateDone;

        pShareInfo->shi2_netname = NULL;
        pShareInfo->shi2_type = STYPE_DISKTREE;
        pShareInfo->shi2_remark = NULL;
        pShareInfo->shi2_permissions = 0;
        pShareInfo->shi2_max_uses = SHI_USES_UNLIMITED;
        pShareInfo->shi2_current_uses = SHI_USES_UNLIMITED;
        pShareInfo->shi2_path = NULL;
        pShareInfo->shi2_passwd = NULL;

        //
        // Find end of "<winnt>\system32\spool"
        //
        i = wcslen(Buffer);

        //
        // Make <winnt>\system32\spool\drivers
        //
        StringCchCopy(&Buffer[i], COUNTOF(Buffer) - i, szDriversDirectory);

        pShareInfo->shi2_path = AllocSplStr(Buffer);

        if ( pShareInfo->shi2_path == NULL ) {
            DBGMSG( DBG_WARNING, ("Unable to alloc pShareInfo->shi2_path\n"));
            goto SplCreateDone;
        }

        pShareInfo->shi2_netname = ipszDriversShareName;

        *Buffer = L'\0';
        LoadString(hInst, IDS_PRINTER_DRIVERS, Buffer, (sizeof Buffer / sizeof *Buffer));

        pShareInfo->shi2_remark  = AllocSplStr(Buffer);

        if ( pShareInfo->shi2_remark == NULL ) {
            DBGMSG(DBG_WARNING, ("SplCreateSpooler Unable to allocate\n"));
            goto SplCreateDone;
        }

        pIniSpooler->pIniPrinter = NULL;
        pIniSpooler->pIniEnvironment = NULL;
        pIniSpooler->pIniNetPrint = NULL;
        pIniSpooler->cNetPrinters = 0;

        //
        // No need to initialize shared resources.
        //
        pIniSpooler->pSpool             = NULL;
        pIniSpooler->pDefaultSpoolDir   = NULL;
        pIniSpooler->bEnableRetryPopups = FALSE;
        pIniSpooler->dwRestartJobOnPoolTimeout = DEFAULT_JOB_RESTART_TIMEOUT_ON_POOL_ERROR;
        pIniSpooler->bRestartJobOnPoolEnabled  = TRUE;


        if (( pSpoolerInfo2->pszRegistryMonitors     == NULL ) &&
            ( pSpoolerInfo2->pszRegistryEnvironments == NULL ) &&
            ( pSpoolerInfo2->pszRegistryEventLog     == NULL ) &&
            ( pSpoolerInfo2->pszRegistryProviders    == NULL ) &&
            ( pSpoolerInfo2->pszEventLogMsgFile      == NULL ) &&
            ( pSpoolerInfo2->pszRegistryForms        == NULL ) &&
            ( pSpoolerInfo2->pszDriversShare         == NULL )) {

            DBGMSG( DBG_WARNING, ("SplCreateSpooler Invalid Parameters\n"));
            goto SplCreateDone;
        }

        if( !(  pSpoolerInfo2->SpoolerFlags & SPL_CLUSTER_REG ) &&
            ( pSpoolerInfo2->pszRegistryPrinters == NULL )){

            DBGMSG( DBG_WARNING, ("SplCreateSpooler Invalid RegistryPrinters\n"));
            goto SplCreateDone;
        }

        if ( pSpoolerInfo2->pDefaultSpoolDir != NULL ) {
            pIniSpooler->pDefaultSpoolDir = AllocSplStr( pSpoolerInfo2->pDefaultSpoolDir );

            if ( pIniSpooler->pDefaultSpoolDir == NULL ) {
                DBGMSG(DBG_WARNING, ("SplCreateSpooler Unable to allocate\n"));
                goto SplCreateDone;

            }
        }

        pIniSpooler->pszRegistryMonitors = AllocSplStr( pSpoolerInfo2->pszRegistryMonitors );

        //
        // The spooler stores data about environemnts, versions, drivers and print processors
        // in the regsitry (or cluster data base). This data is accessed via pIniSpooler->
        // pszRegistryEnvironemts
        //
        if (pSpoolerInfo2->SpoolerFlags & SPL_TYPE_CLUSTER)
        {
            //
            // For a cluster spooler pIniSpooler->hckRoot maps to Parameters key of the spooler
            // resource in the cluster database. pIniSpooler->pszRegistryEnvironments is a key
            // called "Environemts" under hckRoot.
            //
            pIniSpooler->pszRegistryEnvironments = AllocSplStr(ipszClusterDatabaseEnvironments);
        }
        else
        {
            //
            // For local spooler pIniSpooler->pszRegistryEnvironments is the following string:
            // System\CurrentControlSet\Control\Print\Environments. It is used relative to HKLM
            //
            pIniSpooler->pszRegistryEnvironments = AllocSplStr(!pLocalIniSpooler ? pSpoolerInfo2->pszRegistryEnvironments :
                                                                                   pLocalIniSpooler->pszRegistryEnvironments);
        }


        pIniSpooler->pszRegistryEventLog     = AllocSplStr( pSpoolerInfo2->pszRegistryEventLog );
        pIniSpooler->pszRegistryProviders    = AllocSplStr( pSpoolerInfo2->pszRegistryProviders );
        pIniSpooler->pszEventLogMsgFile      = AllocSplStr( pSpoolerInfo2->pszEventLogMsgFile );

        if (pSpoolerInfo2->SpoolerFlags & SPL_TYPE_CLUSTER)
        {
            //
            // The driver share for a cluster spooler is of the form \\server\print$\spooler-resource-GUID
            //
            StrCatAlloc(&pIniSpooler->pszDriversShare,
                        pSpoolerInfo2->pszDriversShare,
                        L"\\",
                        pIniSpooler->pszClusResID,
                        szDriversDirectory,
                        NULL);
        }
        else
        {
            //
            // The driver share for the local spooler is \\server\print$
            //
            StrCatAlloc(&pIniSpooler->pszDriversShare, pSpoolerInfo2->pszDriversShare, NULL);
        }

        pIniSpooler->pszRegistryForms        = AllocSplStr( pSpoolerInfo2->pszRegistryForms ) ;
        pIniSpooler->hClusterToken           = INVALID_HANDLE_VALUE;
        pIniSpooler->hFilePool               = INVALID_HANDLE_VALUE;

        if ( pIniSpooler->pszRegistryMonitors     == NULL ||
             pIniSpooler->pszRegistryEnvironments == NULL ||
             pIniSpooler->pszRegistryEventLog     == NULL ||
             pIniSpooler->pszRegistryProviders    == NULL ||
             pIniSpooler->pszEventLogMsgFile      == NULL ||
             pIniSpooler->pszDriversShare         == NULL ||
             pIniSpooler->pszRegistryForms        == NULL ) {

           DBGMSG(DBG_WARNING, ("SplCreateSpooler Unable to allocate\n"));
           goto SplCreateDone;

        }

        pIniSpooler->SpoolerFlags = pSpoolerInfo2->SpoolerFlags;

        //
        // Initialize the shared resources (pShared).
        //
        if( !InitializeShared( pIniSpooler )){
            DBGMSG( DBG_WARN,
                    ( "SplCreateSpooler: InitializeShared Failed %d\n",
                      GetLastError() ));
            goto SplCreateDone;
        }

        //
        // Create the print share if necessary.  This is always needed
        // since the cluster printers are shared, while the local ones
        // on this node aren't.
        //
        if(pIniSpooler->SpoolerFlags & SPL_ALWAYS_CREATE_DRIVER_SHARE ){

            if( !AddPrintShare( pIniSpooler )){
                goto SplCreateDone;
            }
        }

        //
        // Open and store the printer and root key from
        // the resource registry.
        //

        if( pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

            SPLASSERT( Level == 2 );

            // Set up the DS Cluster info.  If we fail here, we can't publish printers, but let's
            // not abort the cluster.
            Status = InitializeDSClusterInfo(pIniSpooler, &hToken);
            if (Status != ERROR_SUCCESS) {
                DBGMSG(DBG_WARNING, ("InitializeDSClusterInfo FAILED: %d\n", Status));
            }

            pIniSpooler->hckRoot = OpenClusterParameterKey(
                                       pSpoolerInfo2->pszResource );

            if( !pIniSpooler->hckRoot ) {
                goto SplCreateDone;
            }

            Status = SplRegCreateKey( pIniSpooler->hckRoot,
                                      szPrintersKey,
                                      0,
                                      KEY_WRITE | KEY_READ | DELETE,
                                      NULL,
                                      &pIniSpooler->hckPrinters,
                                      NULL,
                                      pIniSpooler );

            if( Status != ERROR_SUCCESS ){
                SetLastError( Status );
                goto SplCreateDone;
            }

        } else {

            DWORD dwDisposition;

            Status = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                     pSpoolerInfo2->pszRegistryRoot,
                                     0,
                                     NULL,
                                     0,
                                     KEY_WRITE | KEY_READ | DELETE,
                                     NULL,
                                     &pIniSpooler->hckRoot,
                                     &dwDisposition );

            if( Status != ERROR_SUCCESS ){
                SetLastError( Status );
                goto SplCreateDone;
            }

            Status = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                     pSpoolerInfo2->pszRegistryPrinters,
                                     0,
                                     NULL,
                                     0,
                                     KEY_WRITE | KEY_READ | DELETE,
                                     NULL,
                                     &pIniSpooler->hckPrinters,
                                     &dwDisposition );

            if( Status != ERROR_SUCCESS ){
                SetLastError( Status );
                goto SplCreateDone;
            }

        }


        pIniSpooler->pfnReadRegistryExtra = pSpoolerInfo2->pfnReadRegistryExtra;
        pIniSpooler->pfnWriteRegistryExtra = pSpoolerInfo2->pfnWriteRegistryExtra;
        pIniSpooler->pfnFreePrinterExtra = pSpoolerInfo2->pfnFreePrinterExtra;

        // Success add to Linked List

        if ( pLocalIniSpooler != NULL ) {

            pIniSpooler->pIniNextSpooler = pLocalIniSpooler->pIniNextSpooler;
            pLocalIniSpooler->pIniNextSpooler = pIniSpooler;


        } else {

            // First One is Always LocalSpl

            pLocalIniSpooler = pIniSpooler;
            pIniSpooler->pIniNextSpooler = NULL;


        }

        //
        // This function will update the global varaiable dwUpgradeFlag
        //
        QueryUpgradeFlag( pIniSpooler );

        InitializeEventLogging( pIniSpooler );

        //
        // Only initialize forms if this is not a clustered spooler.
        //
        if( !( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER )){
            InitializeForms( pIniSpooler );
        }

        //
        // Originally ports were a per-machine (manual) resource.  However,
        // this has changed for clustering in 5.0, so that ports can be
        // stored in the cluster registry.  Note that monitors are still
        // manual resources, since there isn't an easy way to install them
        // on a remote machine.
        //

        BuildAllPorts( pIniSpooler );

        InitializeSpoolerSettings( pIniSpooler );

        if ( pIniSpooler == pLocalIniSpooler ) {

            GetPrintSystemVersion( pIniSpooler );

            BuildEnvironmentInfo( pIniSpooler );

            if ( dwUpgradeFlag ) {

                //
                // The problem is that we have built-in forms, and
                // custom forms (duplicates disallowed).On NT4, we
                // may have a custom "A6" form.  When we upgrade to NT5,
                // and we have a new built-in from "A6."  We need to
                // rename the custom form to "A6 Custom," otherwise we'll
                // have duplicates.
                //

                UpgradeForms(pIniSpooler);
            }


        } else if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) {

            HANDLE hThread;
            DWORD  dwThreadId;
            DWORD  dwError;

            //
            // The setup creates the registry strucutre for the local spooler:
            // Environments {Windows NT x86, Windows IA64, etc}
            // For a cluster spooler we need to create it ourselves in the
            // cluster database
            //
            if ((dwError = CreateClusterSpoolerEnvironmentsStructure(pIniSpooler)) == ERROR_SUCCESS)
            {
                //
                // Create all the environments, versions, drivers, processors strurctres
                // This function always returns FALSE. We cannot take its return value
                // into account.
                //
                BuildEnvironmentInfo(pIniSpooler);

                //
                // Now we launch a thread to do time consuming tasks that can
                // be performed with the spooler on line. These inlude ungrading
                // printer drivers, copying ICM profiles from the cluster disk etc.
                //
                // We need to bump the ref count so that the worker thread has
                // a valid pIniSpooler. The worker thread will decref the pinispooler
                // when it is done
                //
                INCSPOOLERREF(pIniSpooler);

                //
                // The event has manual reset and is not signaled.
                //
                pIniSpooler->hClusSplReady = CreateEvent(NULL, TRUE, FALSE, NULL);

                //
                // If the thread is created, then SplCreateSpoolerWorkerThread will
                // close the hClusSplReady event handle.
                //
                if (pIniSpooler->hClusSplReady &&
                    (hThread = CreateThread(NULL,
                                            0,
                                            (LPTHREAD_START_ROUTINE)SplCreateSpoolerWorkerThread,
                                            (PVOID)pIniSpooler,
                                            0,
                                            &dwThreadId)))
                {
                    CloseHandle(hThread);
                }
                else
                {
                    //
                    // Either CreateEvent or CreatreThread failed.
                    //
                    dwError = GetLastError();

                    if (pIniSpooler->hClusSplReady)
                    {
                        CloseHandle(pIniSpooler->hClusSplReady);

                        pIniSpooler->hClusSplReady = NULL;
                    }

                    DECSPOOLERREF(pIniSpooler);

                    DBGMSG(DBG_ERROR, ("Unable to create SplCreateSpoolerWorkerThread\n"));
                }
            }

            //
            //  An error occured
            //
            if (dwError != ERROR_SUCCESS)
            {
                SetLastError(dwError);
                goto SplCreateDone;
            }
        }
        else
        {
            //
            // This is the case of a network spooler. You get one of those when
            // you make a true printer connection
            //
            pIniSpooler->pIniEnvironment = pLocalIniSpooler->pIniEnvironment;
        }

        //
        // Read Printer Info from Registry (cluster databse for cluster spooler)
        // There's no cleanup in any of this code--it doesn't free any allocated memory!
        //
        if( !BuildPrinterInfo( pIniSpooler, (BOOL) dwUpgradeFlag )){
            goto SplCreateDone;
        }

        if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

            //
            // Keep a counter of pIniSpoolers.
            //
            ++gcClusterIniSpooler;
        }

        //
        // We need to perform some costly initialization, so we increase the refcount
        // on the pIniSpooler and will do the lengthy operations outside the global
        // critical section
        //
        INCSPOOLERREF(pIniSpooler);
        LeaveSplSem();

        //
        // GetDNSMachineName may fail, but that's okay.  Just don't be surprised
        // if pszFullMachineName is NULL.
        //
        GetDNSMachineName(pIniSpooler->pMachineName + 2, &pIniSpooler->pszFullMachineName);

        if (Level == 2 && pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER)
        {
            LPWSTR *ppszIPAddresses = NULL;
            DWORD   cIPAddreeses    = 0;

            //
            // The cluster resource calls us with level 2. In this case we want to add a node
            // tothe cache, but we want the node to support the name and IP addresses we want.
            // The resource tells us all the IP addresses the cluster spooler is dependent on.
            //
            if (BuildIPArrayFromCommaList(pSpoolerInfo2->pszAddress,
                                          &ppszIPAddresses,
                                          &cIPAddreeses) != S_OK ||
                CacheCreateAndAddNodeWithIPAddresses(pIniSpooler->pMachineName + 2,
                                                     TRUE,
                                                     ppszIPAddresses,
                                                     cIPAddreeses) != S_OK)
            {
                EnterSplSem();
                goto SplCreateDone;
            }
        }
        else if (pIniSpooler->SpoolerFlags & (SPL_TYPE_CLUSTER | SPL_TYPE_LOCAL))
        {
            //
            // We skip the \\ prepended to the server name. Cache nodes for cluster pIniSpooler
            // are alwasy searched first. That is why in CacheCreateAndAddNode we indicate
            // the type of the spooler.
            //
            if (CacheCreateAndAddNode(pIniSpooler->pMachineName + 2,
                                      pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) != S_OK)
            {
                EnterSplSem();
                goto SplCreateDone;
            }
        }

        EnterSplSem();
        DECSPOOLERREF(pIniSpooler);

    } else {

        INCSPOOLERREF( pIniSpooler );

    }

    //
    // Initialize the DS.
    //
    if (pIniSpooler->SpoolerFlags & SPL_PRINT) {
        InitializeDS(pIniSpooler);
    }

    hReturn = (HANDLE)pIniSpooler;

SplCreateDone:

    //
    // Check if an error occurred while creating the spooler.
    //
    if (hReturn == INVALID_HANDLE_VALUE && pIniSpooler)
    {
        //
        // This will prevent leaking allocated fields
        //
        DECSPOOLERREF(pIniSpooler);
    }

    LeaveSplSem();

    if ( !pIniSpooler )
    {
        if (!(pSpoolerInfo2->SpoolerFlags & SPL_OPEN_EXISTING_ONLY))
        {
            SplLogEvent(
                NULL,
                LOG_ERROR,
                MSG_INIT_FAILED,
                FALSE,
                L"Spooler",
                L"SplCreateSpooler",
                L"Unknown Error",
                NULL
                );
        }
    }

    if (hToken)
    {
        ImpersonatePrinterClient(hToken);
    }

    //
    // Set the event that the cluster spooler is initialized
    //
    if (pIniSpooler &&
        pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
        pIniSpooler->hClusSplReady)
    {
        SetEvent(pIniSpooler->hClusSplReady);
    }

    return hReturn;
}



BOOL
InitializePrintProvidor(
   LPPRINTPROVIDOR pPrintProvidor,
   DWORD    cbPrintProvidor,
   LPWSTR   pFullRegistryPath
)
{
   HANDLE hSchedulerThread;
   HANDLE hFinalInitAfterRouterInitCompleteThread;
   DWORD  ThreadId;
   BOOL  bSucceeded = TRUE;
   WCHAR Buffer[MAX_PATH];
   DWORD i;
   PINISPOOLER pIniSpooler = NULL;
   static LPWSTR   pMachineName       = NULL;
   static LPWSTR   pszDriverShareName = NULL;
   SPOOLER_INFO_1 SpoolerInfo1;
   BOOL     bInSem = FALSE;

 try {

    if (!InitializeWinSpoolDrv())
        leave;

    //
    //  Make sure sizes of structres are good
    //

    SPLASSERT( sizeof( PRINTER_INFO_STRESSW ) == sizeof ( PRINTER_INFO_STRESSA ) );


    // !! LATER !!
    // We could change this to succeed even on failure
    // if we point all the routines to a function which returns failure
    //

    if (!InitializeNet())
        leave;

    //
    // JobIdMap initialized when spooler created.
    //

    //
    // Allocate LocalSpl Global IniSpooler
    //

    Buffer[0] = Buffer[1] = L'\\';
    i = MAX_PATH-2;
    OsVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( !GetComputerName(Buffer+2, &i) ||
         !GetVersionEx((POSVERSIONINFO)&OsVersionInfoEx) ||
         !GetVersionEx(&OsVersionInfo)) {

        DBGMSG(DBG_WARNING, ("GetComputerName/OSVersionInfo failed.\n"));
        leave;
    }

    pMachineName = AllocSplStr(Buffer);
    if ( pMachineName == NULL )
        leave;

    pszDriverShareName = AllocSplStr(ipszDriversShareName);    /* print$ */

    if ( pszDriverShareName == NULL )
    {
        leave;
    }

    SpoolerInfo1.pszDriversShare = pszDriverShareName;

    //
    // Read value for Allow remote connection policy.
    //
        if (FAILED(GetServerPolicy(szRegisterSpoolerRemoteRpcEndPoint,
                                   (ULONG*)(&gRemoteRPCEndPointPolicy))))
    {
        DBGMSG(DBG_ERROR, ("Failing to read the remote connections policy.\n"));
        leave;
    }

    if (!InitializeSecurityStructures())
        leave;


    // Use Defaults

    SpoolerInfo1.pDir                    = NULL;
    SpoolerInfo1.pDefaultSpoolDir        = NULL;

    SpoolerInfo1.pszRegistryRoot         = ipszRegistryRoot;
    SpoolerInfo1.pszRegistryPrinters     = ipszRegSwPrinters;
    SpoolerInfo1.pszRegistryMonitors     = ipszRegistryMonitorsHKLM;
    SpoolerInfo1.pszRegistryEnvironments = ipszRegistryEnvironments;
    SpoolerInfo1.pszRegistryEventLog     = ipszRegistryEventLog;
    SpoolerInfo1.pszRegistryProviders    = ipszRegistryProviders;
    SpoolerInfo1.pszEventLogMsgFile      = ipszEventLogMsgFile;
    SpoolerInfo1.pszRegistryForms        = ipszRegistryForms;

    SpoolerInfo1.SpoolerFlags = SPL_UPDATE_WININI_DEVICES                 |
                                SPL_PRINTER_CHANGES                       |
                                SPL_LOG_EVENTS                            |
                                SPL_FORMS_CHANGE                          |
                                SPL_BROADCAST_CHANGE                      |
                                SPL_SECURITY_CHECK                        |
                                SPL_OPEN_CREATE_PORTS                     |
                                SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION   |
                                SPL_REMOTE_HANDLE_CHECK                   |
                                SPL_PRINTER_DRIVER_EVENT                  |
                                SPL_SERVER_THREAD                         |
                                SPL_PRINT                                 |
                                SPL_TYPE_LOCAL;

    SpoolerInfo1.pfnReadRegistryExtra    = NULL;
    SpoolerInfo1.pfnWriteRegistryExtra   = NULL;
    SpoolerInfo1.pfnFreePrinterExtra     = NULL;

    pLocalIniSpooler = SplCreateSpooler( pMachineName,
                                         1,
                                         (PBYTE)&SpoolerInfo1,
                                         NULL );


    if ( pLocalIniSpooler == INVALID_HANDLE_VALUE ) {
        DBGMSG( DBG_WARNING, ("InitializePrintProvidor  Unable to allocate pLocalIniSpooler\n"));
        leave;
    }

    pIniSpooler = pLocalIniSpooler;

#if DBG
    InitializeDebug( pIniSpooler );
#endif

    // !! LATER !!
    // Why is this done inside critical section ?


   EnterSplSem();
    bInSem = TRUE;

    if (!LoadString(hInst, IDS_REMOTE_DOC, Buffer, MAX_PATH))
        leave;

    szRemoteDoc = AllocSplStr( Buffer );
    if ( szRemoteDoc == NULL )
        leave;

    if (!LoadString(hInst, IDS_LOCAL_DOC, Buffer, MAX_PATH))
        leave;

    szLocalDoc = AllocSplStr( Buffer );
    if ( szLocalDoc == NULL )
        leave;

    if (!LoadString(hInst, IDS_FASTPRINT_TIMEOUT, Buffer, MAX_PATH))
        leave;

    szFastPrintTimeout = AllocSplStr( Buffer );
    if ( szFastPrintTimeout == NULL )
        leave;

    SchedulerSignal  = CreateEvent(NULL,
                                   EVENT_RESET_AUTOMATIC,
                                   EVENT_INITIAL_STATE_NOT_SIGNALED,
                                   NULL);

    PowerManagementSignal = CreateEvent(NULL,
                                        EVENT_RESET_MANUAL,
                                        EVENT_INITIAL_STATE_SIGNALED,
                                        NULL);

    hSchedulerThread = CreateThread( NULL,
                                     INITIAL_STACK_COMMIT,
                                     (LPTHREAD_START_ROUTINE)SchedulerThread,
                                     pIniSpooler, 0, &ThreadId );

    hFinalInitAfterRouterInitCompleteThread = CreateThread( NULL, INITIAL_STACK_COMMIT,
                                      (LPTHREAD_START_ROUTINE)FinalInitAfterRouterInitCompleteThread,
                                      (LPVOID)ULongToPtr(dwUpgradeFlag), 0, &ThreadId );


    if (!SchedulerSignal || !PowerManagementSignal || !hSchedulerThread || !hFinalInitAfterRouterInitCompleteThread) {

       DBGMSG( DBG_WARNING, ("Scheduler/FinalInitAfterRouterInitCompleteThread not initialised properly: Error %d\n", GetLastError()));
       leave;
    }

    if ( !SetThreadPriority( hSchedulerThread, dwSchedulerThreadPriority ) ) {

        DBGMSG( DBG_WARNING, ("Setting Scheduler thread priority failed %d\n", GetLastError()));
    }


    CloseHandle( hSchedulerThread );
    CloseHandle( hFinalInitAfterRouterInitCompleteThread );

    //
    // Read online/offline status for local printers from current config
    //
    SplConfigChange();

    CHECK_SCHEDULER();

    CopyMemory( pPrintProvidor, &PrintProvidor, min(sizeof(PRINTPROVIDOR), cbPrintProvidor));

    LeaveSplSem();
    bInSem = FALSE;

    CloseProfileUserMapping(); // !!! We should be able to get rid of this

    //
    // Get the default value for DefaultKMPrintersAreBlocked. It depends
    // what type of OS is running. If we cannot identify the type of OS,
    // the default is set to "blocked"
    //
    DefaultKMPrintersAreBlocked = GetDefaultForKMPrintersBlockedPolicy();

    gdwServerInstallTimeOut = GetServerInstallTimeOut();

    Initialized = TRUE;


 } finally {

    if ( bInSem ) {
       LeaveSplSem();
    }

 }

    SplOutSem();

    return Initialized;
}


PINIPORT
CreatePortEntry(
    LPWSTR      pPortName,
    PINIMONITOR pIniMonitor,
    PINISPOOLER pIniSpooler
)
{
    DWORD       cb;
    PINIPORT    pIniPort            =   NULL;
    HANDLE      hPort               =   NULL;
    BOOL        bPlaceHolder        =   FALSE;
    BOOL        bInitCS             =   FALSE;

    //
    // This is a placeholder if there is no monitor and later if there is no
    // partial print provider.
    //
    bPlaceHolder = pIniMonitor == NULL;

    SplInSem();

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    if (!pPortName || !*pPortName || wcslen(pPortName) >= MAX_PATH) {

        SetLastError(ERROR_UNKNOWN_PORT);
        return NULL;
    }

    if (!pIniMonitor) {

        /* Don't bother validating the port if we aren't initialised.
         * It must be valid, since we wrote it in the registry.
         * This fixes the problem of attempting to open a network
         * printer before the redirector has initialised,
         * and the problem of access denied because we're currently
         * in the system's context.
         */
        if (Initialized) {

            //
            // !! Warning !!
            //
            // Watch for deadlock:
            //
            // spoolss!OpenPrinterPortW  -> RPC to self printer port
            // localspl!CreatePortEntry
            // localspl!ValidatePortTokenList
            // localspl!SetPrinterPorts
            // localspl!LocalSetPrinter
            // spoolss!SetPrinterW
            // spoolss!RpcSetPrinter
            // spoolss!winspool_RpcSetPrinter
            //

            //
            // If we can't open the port then fail the call since this
            // spooler did not know this name before.
            //

            LeaveSplSem();
            if ( !OpenPrinterPortW(pPortName, &hPort, NULL) ){
                EnterSplSem();
                goto Cleanup;
            }
            else {

                bPlaceHolder = FALSE;
                ClosePrinter(hPort);
            }

            EnterSplSem();
        }
    }

    cb = sizeof(INIPORT) + wcslen(pPortName)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pIniPort=AllocSplMem(cb)) {

        StringCbCopy((LPWSTR)(pIniPort+1), cb - sizeof(*pIniPort), pPortName);

        pIniPort->pName = (LPWSTR)(pIniPort+1);
        pIniPort->signature = IPO_SIGNATURE;
        pIniPort->pIniMonitor = pIniMonitor;
        pIniPort->IdleTime = GetTickCount() - 1;
        pIniPort->bIdleTimeValid = FALSE;
        pIniPort->ErrorTime = 0;
        pIniPort->hErrorEvent = NULL;
        pIniPort->InCriticalSection = 0;

        pIniPort->hPortThreadRunning = CreateEvent(NULL, TRUE, FALSE, NULL);
        if ( !pIniPort->hPortThreadRunning ) {
            goto Cleanup;
        }
        if (pIniMonitor) {
            pIniPort->Status |= PP_MONITOR;
        }

        if (bPlaceHolder) {
            pIniPort->Status |= PP_PLACEHOLDER;
        }

        if (!(bInitCS = InitializeCriticalSectionAndSpinCount(&(pIniPort->MonitorCS), 
                                                              0x80000000)))
        {
            goto Cleanup;
        }

        LinkPortToSpooler( pIniPort, pIniSpooler );
    }

Cleanup:

    if ( pIniPort && (!pIniPort->hPortThreadRunning || !bInitCS) ) {
        DeletePortEntry(pIniPort);
    }
    return pIniPort;
}

BOOL
DeletePortEntry(
    PINIPORT    pIniPort
    )

/*++

Routine Description:

    Free pIniPort resources then delete it.  If the pIniPort is on
    a pIniSpooler's linked list, remove it too.

Arguments:

    pIniPort - Port to delete.  May or may not be on a pIniSpooler.

Return Value:

    TRUE - deleted
    FALSE - not deleted (may be in use).

--*/

{
    PINISPOOLER pIniSpooler;

    SplInSem();

    SPLASSERT ( ( pIniPort != NULL) || ( pIniPort->signature == IPO_SIGNATURE) );

    //
    // We had better already closed the port monitor.
    //
    SPLASSERT( !GetMonitorHandle(pIniPort) &&
               !(pIniPort->Status & PP_THREADRUNNING) &&
               !pIniPort->cJobs);

    if (pIniPort->cRef) {
        pIniPort->Status |= PP_DELETING;
        return FALSE;
    }

    pIniSpooler = pIniPort->pIniSpooler;

    //
    // If currently linked to a pIniSpooler, delink it.
    //
    if( pIniSpooler ){

        SPLASSERT( pIniSpooler->signature ==  ISP_SIGNATURE );

        DelinkPortFromSpooler( pIniPort, pIniSpooler );
    }

    if (pIniPort->ppIniPrinter)
        FreeSplMem(pIniPort->ppIniPrinter);

    
    CloseHandle(pIniPort->hPortThreadRunning);

    DeleteCriticalSection(&pIniPort->MonitorCS);

    FreeSplMem(pIniPort);

    return TRUE;
}

VOID
FreeIniMonitor(
    PINIMONITOR pIniMonitor
    )
{
    if( pIniMonitor ){

        FreeSplStr( pIniMonitor->pMonitorDll );

        if( pIniMonitor->hModule ){
            FreeLibrary( pIniMonitor->hModule );
        }

        if( pIniMonitor->pMonitorInit ){

            FreeSplStr( (LPWSTR)pIniMonitor->pMonitorInit->pszServerName );

            if( pIniMonitor->pMonitorInit->hckRegistryRoot ){
                SplRegCloseKey( pIniMonitor->pMonitorInit->hckRegistryRoot,
                                pIniMonitor->pIniSpooler );
            }

            FreeSplMem( pIniMonitor->pMonitorInit );
        }

        FreeSplMem( pIniMonitor );
    }
}

#ifdef _SPL_CLUST
LPMONITOR2
InitializePrintMonitor2(
    PMONITORINIT pMonitorInit,
    PHANDLE phMonitor
    )
{
    return(LocalMonInitializePrintMonitor2(pMonitorInit,phMonitor));
}
#endif

PINIMONITOR
CreateMonitorEntry(
    LPWSTR   pMonitorDll,
    LPWSTR   pMonitorName,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

Arguments:

Return Value:

    Valid pIniMonitor - This means everything worked out fine.

    NULL - This means the monitor DLL was found, but the initialisation routine
           returned FALSE.  This is non-fatal, as the monitor may need the
           system to reboot before it can run properly.

    -1 - This means the monitor DLL or the initialization routine was not found.

--*/

{
    WCHAR       szRegistryRoot[MAX_PATH];
    DWORD       cb, cbNeeded, cReturned, dwRetVal;
    PPORT_INFO_1 pPorts, pPort;
    PINIMONITOR pIniMonitor;
    UINT        uOldErrMode;
    PMONITOR2 (*pfnInitializePrintMonitor2)(PMONITORINIT, PHANDLE) = NULL;
    PINIMONITOR pReturnValue = (PINIMONITOR)-1;

    HANDLE hKeyOut;
    LPWSTR pszPathOut;

    SPLASSERT( (pIniSpooler != NULL) || (pIniSpooler->signature == ISP_SIGNATURE));
    SplInSem();

    cb = sizeof(INIMONITOR) + wcslen(pMonitorName)*sizeof(WCHAR) + sizeof(WCHAR);
    pIniMonitor = AllocSplMem(cb);

    if( !pIniMonitor ){
        goto Fail;
    }

    StringCbCopy((LPWSTR)(pIniMonitor+1), cb - sizeof(*pIniMonitor), pMonitorName);

    pIniMonitor->pName = (LPWSTR)(pIniMonitor+1);
    pIniMonitor->signature = IMO_SIGNATURE;
    pIniMonitor->pMonitorDll = AllocSplStr(pMonitorDll);

    pIniMonitor->pIniSpooler = pIniSpooler;

    if( !pIniMonitor->pMonitorDll ){
        goto Fail;
    }

    //
    // Load the library, but don't show any hard error popups if it's an
    // invalid binary.
    //
    INCSPOOLERREF( pIniSpooler );
    LeaveSplSem();
    uOldErrMode = SetErrorMode( SEM_FAILCRITICALERRORS );
    pIniMonitor->hModule = LoadLibrary(pMonitorDll);
    SetErrorMode( uOldErrMode );
    EnterSplSem();
    DECSPOOLERREF( pIniSpooler );

    if (!pIniMonitor->hModule) {

        DBGMSG(DBG_WARNING, ("CreateMonitorEntry( %ws, %ws ) LoadLibrary failed %d\n",
                             pMonitorDll ? pMonitorDll : L"(NULL)",
                             pMonitorName ? pMonitorName : L"(NULL)",
                             GetLastError()));
        goto Fail;
    }

    GetRegistryLocation( pIniSpooler->hckRoot,
                         pIniSpooler->pszRegistryMonitors,
                         &hKeyOut,
                         &pszPathOut );


    dwRetVal = StrNCatBuff( szRegistryRoot,
                            COUNTOF(szRegistryRoot),
                            pszPathOut,
                            L"\\",
                            pMonitorName,
                            NULL );

    if (dwRetVal != ERROR_SUCCESS)
    {
        SetLastError(ERROR_INVALID_PRINT_MONITOR);
        goto Fail;
    }
    //
    // Try calling the entry points in the following order:
    //     InitializePrintMonitor2 (used for clustering),
    //     InitializePrintMonitor,
    //     InitializeMonitorEx,
    //     InitializeMonitor
    //

    (FARPROC)pfnInitializePrintMonitor2 = GetProcAddress(
                                              pIniMonitor->hModule,
                                              "InitializePrintMonitor2" );

    if( !pfnInitializePrintMonitor2 ){

        //
        // If this is clustered spooler, then only InitializePrintMonitor2
        // monitors are supported.
        //
        if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){
            goto Fail;
        }

        //
        // Add the parth to the Monitor name here.
        //

        pReturnValue = InitializeDMonitor( pIniMonitor,
                                           szRegistryRoot );

        if( pReturnValue == NULL ||
            pReturnValue == (PINIMONITOR)-1 ){

            goto Fail;
        }

    } else {

        PMONITORINIT pMonitorInit;
        DWORD Status;
        PMONITOR2 pMonitor2 = NULL;

        INCSPOOLERREF( pIniSpooler );
        LeaveSplSem();

        //
        // kKeyOut must either be not HKLM, or it must not be a cluster.
        // If it is both a cluster and also uses HKLM, then we have an error.
        // This should never happen because only win32spl uses an absolute
        // path.
        //
        SPLASSERT( (hKeyOut != HKEY_LOCAL_MACHINE) ||
                   !(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ));

        pMonitorInit = (PMONITORINIT)AllocSplMem( sizeof( MONITORINIT ));

        if( !pMonitorInit ){
            goto FailOutsideSem;
        }

        pMonitorInit->pszServerName = AllocSplStr( pIniSpooler->pMachineName );

        if( !pMonitorInit->pszServerName ){
            goto FailOutsideSem;
        }

        pMonitorInit->cbSize = sizeof( MONITORINIT );
        pMonitorInit->hSpooler = (HANDLE)pIniSpooler;
        pMonitorInit->pMonitorReg = &gMonitorReg;
        pMonitorInit->bLocal = ( pIniSpooler == pLocalIniSpooler );

        pIniMonitor->pMonitorInit = pMonitorInit;

        Status = SplRegCreateKey( hKeyOut,
                                  szRegistryRoot,
                                  0,
                                  KEY_READ | KEY_WRITE | DELETE,
                                  NULL,
                                  &pMonitorInit->hckRegistryRoot,
                                  NULL,
                                  pIniSpooler );
        //
        // If we can't create the hck root key, then fail
        // the call.  We should log an event here too.
        //
        if( Status == ERROR_SUCCESS ){

            pMonitor2 = (*pfnInitializePrintMonitor2)(
                            pMonitorInit,
                            &pIniMonitor->hMonitor );

            if( pMonitor2 ){

                DBGMSG( DBG_TRACE,
                        ( "CreateMonitorEntry: opened %x %x on %x\n",
                          pIniMonitor, pIniMonitor->hMonitor, pIniSpooler ));

                //
                // Succeeded, copy over the pMonitor2 structure into
                // pIniMonitor->Monitor2.
                //
                CopyMemory((LPBYTE)&pIniMonitor->Monitor2, (LPBYTE)pMonitor2, min(pMonitor2->cbSize, sizeof(MONITOR2)));

                //
                // Check if the monitor2 supports Shutdown.
                //
                // Raid#: 193150 - Accept any size Monitor2 as long as it supports Shutdown
                //
                if( !pIniMonitor->Monitor2.pfnShutdown ){

                    DBGMSG( DBG_ERROR,
                            ( "Invalid print monitor %ws (no shutdown)\n",
                              pMonitorName ));
                    SetLastError(ERROR_INVALID_PRINT_MONITOR);
                    DECSPOOLERREF( pIniSpooler );
                    goto FailOutsideSem;
                }

                //
                // Initialize an uplevel monitor for downlevel support.
                //
                InitializeUMonitor( pIniMonitor );

            } else {

                DBGMSG( DBG_WARN,
                        ( "CreateMonitorEntry: InitializePrintMonitor2 failed %d\n",
                          GetLastError() ));
            }

        } else {

            DBGMSG( DBG_WARN,
                    ( "CreateMonitorEntry: Unable to create hckRoot "TSTR"\n",
                      pMonitorName ));
        }

        EnterSplSem();
        DECSPOOLERREF( pIniSpooler );

        if( !pMonitor2 ){
            goto Fail;
        }

        pIniMonitor->bUplevel = TRUE;
    }

    //
    // Check if the monitor supports essential functions
    //
    if ( (!pIniMonitor->Monitor2.pfnOpenPort &&
          !pIniMonitor->Monitor2.pfnOpenPortEx)   ||
         !pIniMonitor->Monitor2.pfnClosePort      ||
         !pIniMonitor->Monitor2.pfnStartDocPort   ||
         !pIniMonitor->Monitor2.pfnWritePort      ||
         !pIniMonitor->Monitor2.pfnReadPort       ||
         !pIniMonitor->Monitor2.pfnEndDocPort ) {

        DBGMSG(DBG_ERROR, ("Invalid print monitor %ws\n", pMonitorName));
        SetLastError(ERROR_INVALID_PRINT_MONITOR);

        goto Fail;
    }

    if (FindMonitor(pMonitorName, pIniSpooler)) {

        SetLastError(ERROR_PRINT_MONITOR_ALREADY_INSTALLED);
        goto Fail;
    }


    if ((pIniMonitor->Monitor2.pfnEnumPorts) &&
        !(*pIniMonitor->Monitor2.pfnEnumPorts)(
              pIniMonitor->hMonitor,
              NULL,
              1,
              NULL,
              0,
              &cbNeeded,
              &cReturned)) {

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            if (pPorts = AllocSplMem(cbNeeded)) {
                pPort = pPorts;
                if ((*pIniMonitor->Monitor2.pfnEnumPorts)(
                         pIniMonitor->hMonitor,
                         NULL,
                         1,
                         (LPBYTE)pPorts,
                         cbNeeded,
                         &cbNeeded,
                         &cReturned)) {

                    while (cReturned--) {
                        CreatePortEntry(pPort->pName,
                                        pIniMonitor,
                                        pIniSpooler);
                        pPort++;
                    }
                }
                FreeSplMem(pPorts);
            }
        }
    }

    DBGMSG(DBG_TRACE, ("CreateMonitorEntry( %ws, %ws, %ws ) returning %x\n",
                       pMonitorDll ? pMonitorDll : L"(NULL)",
                       pMonitorName ? pMonitorName : L"(NULL)",
                       szRegistryRoot, pIniMonitor));

    SplInSem();

    //
    // Success, link it up.
    //

    pIniMonitor->pNext = pIniSpooler->pIniMonitor;
    pIniSpooler->pIniMonitor = pIniMonitor;

    return pIniMonitor;

FailOutsideSem:

    EnterSplSem();

Fail:

    FreeIniMonitor( pIniMonitor );

    return pReturnValue;
}

BOOL
BuildAllPorts(
    PINISPOOLER     pIniSpooler
)
{
    DWORD   cchData, cbDll, cMonitors;
    WCHAR   Dll[MAX_PATH];
    WCHAR   MonitorName[MAX_PATH];
    WCHAR   RegistryPath[MAX_PATH];
    HKEY    hKey, hKey1, hKeyOut;
    LPWSTR  pszPathOut;
    LONG    Status;
    PINIMONITOR pReturnValue = (PINIMONITOR)-1;

    PINISPOOLER pIniSpoolerMonitor;

    //
    // For pLocalIniSpooler or clustered spooler, read the monitors out
    // of HKLM (the same monitors used in pLocalIniMonitor).  This is because
    // you install a monitor for each node, then that monitor is initialized
    // for the local spooler and all clustered spoolers.
    //
    // You install monitors on the node, not on specific cluster groups.
    //
    if( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ){
        pIniSpoolerMonitor = pLocalIniSpooler;
    } else {
        pIniSpoolerMonitor = pIniSpooler;
    }

    GetRegistryLocation( pIniSpoolerMonitor->hckRoot,
                         pIniSpooler->pszRegistryMonitors,
                         &hKeyOut,
                         &pszPathOut );

    Status = RegOpenKeyEx( hKeyOut,
                           pszPathOut,
                           0,
                           KEY_READ,
                           &hKey);

    if (Status != ERROR_SUCCESS)
        return FALSE;

    cMonitors=0;
    cchData = COUNTOF( MonitorName );

    while (RegEnumKeyEx(hKey, cMonitors, MonitorName, &cchData, NULL, NULL,
                        NULL, NULL) == ERROR_SUCCESS) {

        DBGMSG(DBG_TRACE, ("Found monitor %ws\n", MonitorName));

        if (RegOpenKeyEx(hKey, MonitorName, 0, KEY_READ, &hKey1)
                                                        == ERROR_SUCCESS) {

            cbDll = sizeof(Dll);

            if (RegQueryValueEx(hKey1, L"Driver", NULL, NULL,
                                (LPBYTE)Dll, &cbDll)
                                                        == ERROR_SUCCESS) {

                CreateMonitorEntry(Dll, MonitorName, pIniSpooler);
            }

            RegCloseKey(hKey1);
        }

        cMonitors++;
        cchData = COUNTOF( MonitorName );
    }

    RegCloseKey(hKey);

    return TRUE;
}

/*
   Current Directory == <NT directory>\system32\spool\printers
   pFindFileData->cFileName == 0
*/

BOOL
BuildPrinterInfo(
    PINISPOOLER pIniSpooler,
    BOOL        UpdateChangeID
)
{
    WCHAR   PrinterName[MAX_PRINTER_NAME];
    WCHAR   szData[MAX_PATH];
    WCHAR   szDefaultPrinterDirectory[MAX_PATH];
    DWORD   cbData, i;
    DWORD   cbSecurity, dwLastError;
    DWORD   cPrinters, Type;
    HKEY    hPrinterKey;
    PINIPRINTER pIniPrinter;
    PINIPORT    pIniPort;
    LONG        Status;
    SECURITY_ATTRIBUTES SecurityAttributes;
    PKEYDATA    pKeyData                    = NULL;
    BOOL    bUpdateRegistryForThisPrinter   = UpdateChangeID;
    BOOL    bWriteDirectory                 = FALSE;
    BOOL    bAllocMem                       = FALSE;
    BOOL    bNoPorts                        = FALSE;
    LPWSTR  szPortData;


    //
    // Has user specified Default Spool Directory ?
    //

    cbData = sizeof( szData );
    *szData = (WCHAR)0;

    Status = SplRegQueryValue( pIniSpooler->hckPrinters,
                               SPLREG_DEFAULT_SPOOL_DIRECTORY,
                               NULL,
                               (LPBYTE)szData,
                               &cbData,
                               pIniSpooler );

    if (Status == ERROR_SUCCESS) {  // found a value, so verify the directory
        if (!(pIniSpooler->pDefaultSpoolDir = AllocSplStr( szData )))   // Copies szData to pDefaultSpoolDir
            return FALSE;
    } else {
        bWriteDirectory = TRUE;     // No registry directory, so create one
    }

    // Copy pDefaultSpoolDir to szDefaultPrinterDirectory
    GetPrinterDirectory(NULL, FALSE, szDefaultPrinterDirectory, COUNTOF(szDefaultPrinterDirectory), pIniSpooler);

    if (!pIniSpooler->pDefaultSpoolDir)
        return FALSE;


    // Create the directory with the proper security, or fail trying

    SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttributes.lpSecurityDescriptor = CreateEverybodySecurityDescriptor();
    SecurityAttributes.bInheritHandle = FALSE;

    //
    // CreateDirectory limits the length of a directory to 248 (MAX_PATH-12)
    // characters. By calculating the length, we ensure that an escape sequence
    // will not lead to the creation of a directory with a name longer than 248
    //
    if (wcslen(szDefaultPrinterDirectory) > MAX_PATH - 12 ||
        !CreateDirectory(szDefaultPrinterDirectory, &SecurityAttributes)) {

        // Failed to create the directory? Back to factory default

        bWriteDirectory = TRUE;

        if (GetLastError() != ERROR_ALREADY_EXISTS) {

            //
            // In the clustered case, just fail.
            //
            if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){
                return FALSE;
            }

            DBGMSG(DBG_WARNING, ("Failed to create DefaultSpoolDirectory %ws\n", szDefaultPrinterDirectory));
            FreeSplStr(pIniSpooler->pDefaultSpoolDir);

            pIniSpooler->pDefaultSpoolDir = NULL;     // This tells GetPrinterDirectory to alloc pDefaultSpoolDir
            GetPrinterDirectory(NULL, FALSE, szDefaultPrinterDirectory, COUNTOF(szDefaultPrinterDirectory), pIniSpooler);

            if (!pIniSpooler->pDefaultSpoolDir)
                return FALSE;

            Status = CreateDirectory(szDefaultPrinterDirectory, &SecurityAttributes);

            if (Status != ERROR_SUCCESS && Status != ERROR_ALREADY_EXISTS) {
                DBGMSG(DBG_WARNING, ("Failed to create DefaultSpoolDirectory %ws\n", szDefaultPrinterDirectory));
                FreeSplStr(pIniSpooler->pDefaultSpoolDir);
                pIniSpooler->pDefaultSpoolDir = NULL;
                return FALSE;
            }
        }
    }

    LocalFree(SecurityAttributes.lpSecurityDescriptor);

    if (bWriteDirectory) {
        Status = SetPrinterDataServer(  pIniSpooler,
                                        SPLREG_DEFAULT_SPOOL_DIRECTORY,
                                        REG_SZ,
                                        (LPBYTE) pIniSpooler->pDefaultSpoolDir,
                                        wcslen(pIniSpooler->pDefaultSpoolDir)*sizeof(WCHAR) + sizeof(WCHAR));
    }

    cPrinters=0;
    cbData = COUNTOF(PrinterName);

    while( SplRegEnumKey( pIniSpooler->hckPrinters,
                          cPrinters,
                          PrinterName,
                          &cbData,
                          NULL,
                          pIniSpooler ) == ERROR_SUCCESS) {

        DBGMSG(DBG_TRACE, ("Found printer %ws\n", PrinterName));

        if( SplRegCreateKey( pIniSpooler->hckPrinters,
                             PrinterName,
                             0,
                             KEY_READ,
                             NULL,
                             &hPrinterKey,
                             NULL,
                             pIniSpooler ) == ERROR_SUCCESS ){

            if ( pIniPrinter = AllocSplMem(sizeof(INIPRINTER) )) {

                //
                // Reference count the pIniSpooler.
                //
                INCSPOOLERREF( pIniSpooler );

                pIniPrinter->signature = IP_SIGNATURE;
                GetSystemTime( &pIniPrinter->stUpTime );

                // Give the printer a unique session ID to pass around in notifications
                pIniPrinter->dwUniqueSessionID = dwUniquePrinterSessionID++;

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue(hPrinterKey,
                                     szName,
                                     NULL,
                                     (LPBYTE)szData,
                                     &cbData,
                                     pIniSpooler) == ERROR_SUCCESS)

                    pIniPrinter->pName = AllocSplStr(szData);

                //
                // Get Spool Directory for this printer
                //

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szSpoolDir,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler) == ERROR_SUCCESS) {

                    if ( *szData != (WCHAR)0 ) {

                        pIniPrinter->pSpoolDir = AllocSplStr(szData);
                    }

                }


                //
                // Get ObjectGUID for this printer
                //

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue(   hPrinterKey,
                                        szObjectGUID,
                                        &Type,
                                        (LPBYTE)szData,
                                        &cbData,
                                        pIniSpooler) == ERROR_SUCCESS) {

                    if ( *szData != (WCHAR)0 ) {
                        pIniPrinter->pszObjectGUID = AllocSplStr(szData);
                    }
                }


                //
                // Get DsKeyUpdate and DsKeyUpdateForeground for this printer
                //

                cbData = sizeof(pIniPrinter->DsKeyUpdate );
                SplRegQueryValue(   hPrinterKey,
                                    szDsKeyUpdate,
                                    &Type,
                                    (LPBYTE) &pIniPrinter->DsKeyUpdate,
                                    &cbData,
                                    pIniSpooler);

                cbData = sizeof(pIniPrinter->DsKeyUpdateForeground );
                SplRegQueryValue(   hPrinterKey,
                                    szDsKeyUpdateForeground,
                                    &Type,
                                    (LPBYTE) &pIniPrinter->DsKeyUpdateForeground,
                                    &cbData,
                                    pIniSpooler);

                if ( !(pIniSpooler->SpoolerFlags & SPL_TYPE_CACHE) ) {

                    // We make sure that DsKeyUpdateForeground is consistent
                    // when the spooler startsup. Otherwise DsKeyUpdateForeground might be
                    // set without dwAction being set and the printer will always be in the
                    // IO_PENDING state.
                    if (pIniPrinter->DsKeyUpdateForeground & (DS_KEY_PUBLISH | DS_KEY_REPUBLISH | DS_KEY_UNPUBLISH)) {
                        if (pIniPrinter->DsKeyUpdateForeground & DS_KEY_PUBLISH) {
                            pIniPrinter->dwAction |= DSPRINT_PUBLISH;
                        } else if (pIniPrinter->DsKeyUpdateForeground & DS_KEY_REPUBLISH) {
                            pIniPrinter->dwAction |= DSPRINT_REPUBLISH;
                        } else if (pIniPrinter->DsKeyUpdateForeground & DS_KEY_UNPUBLISH) {
                            pIniPrinter->dwAction |= DSPRINT_UNPUBLISH;
                        }

                        pIniPrinter->DsKeyUpdateForeground &= ~(DS_KEY_PUBLISH | DS_KEY_REPUBLISH | DS_KEY_UNPUBLISH);

                    } else {
                        pIniPrinter->DsKeyUpdateForeground = 0;
                    }

                } else {

                    //
                    // For connections, dwAction is read from registry. It is updated by
                    // caching code with the value on the server.
                    //
                    cbData = sizeof(pIniPrinter->dwAction);
                    SplRegQueryValue(   hPrinterKey,
                                        szAction,
                                        &Type,
                                        (LPBYTE) &pIniPrinter->dwAction,
                                        &cbData,
                                        pIniSpooler);
                }

                // Make Certain this Printers Printer directory exists
                // with correct security

                if ((pIniPrinter->pSpoolDir) &&
                    (wcscmp(pIniPrinter->pSpoolDir, szDefaultPrinterDirectory) != 0)) {

                    SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
                    SecurityAttributes.lpSecurityDescriptor = CreateEverybodySecurityDescriptor();

                    SecurityAttributes.bInheritHandle = FALSE;


                    if (!CreateDirectory(pIniPrinter->pSpoolDir, &SecurityAttributes)) {

                        // Failed to Create the Directory, revert back
                        // to the default

                        if (GetLastError() != ERROR_ALREADY_EXISTS) {
                            DBGMSG(DBG_WARNING, ("Could not create printer spool directory %ws %d\n",
                                                  pIniPrinter->pSpoolDir, GetLastError() ));
                            pIniPrinter->pSpoolDir = NULL;
                        }

                    }

                    LocalFree(SecurityAttributes.lpSecurityDescriptor);
                }


                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szShare,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler) == ERROR_SUCCESS)

                    pIniPrinter->pShareName = AllocSplStr(szData);

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                dwLastError = SplRegQueryValue( hPrinterKey,
                                                szPort,
                                                &Type,
                                                (LPBYTE)szData,
                                                &cbData,
                                                pIniSpooler );

                if ((dwLastError == ERROR_MORE_DATA) &&
                    (szPortData = AllocSplMem(cbData)))
                {
                    bAllocMem = TRUE;
                    dwLastError = SplRegQueryValue( hPrinterKey,
                                                    szPort,
                                                    &Type,
                                                    (LPBYTE)szPortData,
                                                    &cbData,
                                                    pIniSpooler );
                }
                else
                {
                    bAllocMem = FALSE;
                    szPortData = szData;
                }

                if (dwLastError == ERROR_SUCCESS)
                {
                    if (pKeyData = CreateTokenList(szPortData)) {

                        if (!ValidatePortTokenList( pKeyData, pIniSpooler, TRUE, &bNoPorts)) {

                            LogFatalPortError(pIniSpooler, pIniPrinter->pName);

                            FreePortTokenList(pKeyData);
                            pKeyData = NULL;

                        } else {

                            //
                            // If there are no ports on the printer, just log
                            // a warning message, but only for pooled printers.
                            //
                            if (bNoPorts && pKeyData->cTokens > 1) {

                                SplLogEvent( pIniSpooler,
                                             LOG_WARNING,
                                             MSG_NO_PORT_FOUND_FOR_PRINTER,
                                             TRUE,
                                             pIniPrinter->pName,
                                             szPortData,
                                             NULL );
                            }

                            pIniPrinter->ppIniPorts = AllocSplMem(pKeyData->cTokens * sizeof(PINIPORT));
                        }
                    }
                }

                if (bAllocMem)
                {
                    FreeSplMem(szPortData);
                    szPortData = NULL;
                }

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szPrintProcessor,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler ) == ERROR_SUCCESS)
                {
                    //
                    // We are trying to find the environment relative to the pIniSpooler.
                    // The local spooler and cluster spoolers do not share the same
                    // environment strucutres anymore
                    //
                    PINIENVIRONMENT pIniEnv;

                    if (pIniEnv = FindEnvironment(szEnvironment, pIniSpooler))
                    {
                        pIniPrinter->pIniPrintProc = FindPrintProc(szData, pIniEnv);
                    }
                }

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szDatatype,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler ) == ERROR_SUCCESS)

                    pIniPrinter->pDatatype = AllocSplStr(szData);

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szDriver,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler ) == ERROR_SUCCESS) {

                    pIniPrinter->pIniDriver = (PINIDRIVER)FindLocalDriver(pIniSpooler, szData);

                    if (!pIniPrinter->pIniDriver)
                    {
                        //
                        // The hosting node of the cluster spooler was upgraded to Whistler.
                        //
                        if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
                            pIniSpooler->dwClusNodeUpgraded &&

                            //
                            // The driver was not found in the cluster spooler, not on the cluster disk.
                            // We attempt to install the driver from the local spooler to our cluster
                            // spooler. This will get the driver files on the cluster disk.
                            //
                            AddLocalDriverToClusterSpooler(szData, pIniSpooler) == ERROR_SUCCESS)
                        {
                                //
                                // Search again for the driver that must have been added
                                //
                            pIniPrinter->pIniDriver = (PINIDRIVER)FindLocalDriver(pIniSpooler, szData);
                        }
                    }

                    if (!pIniPrinter->pIniDriver)
                    {
                        SplLogEvent(pLocalIniSpooler,
                                    LOG_ERROR,
                                    MSG_NO_DRIVER_FOUND_FOR_PRINTER,
                                    TRUE,
                                    pIniPrinter->pName,
                                    szData,
                                    NULL);
                    }
                }

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szLocation,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData,
                                      pIniSpooler ) == ERROR_SUCCESS)

                    pIniPrinter->pLocation = AllocSplStr(szData);

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szDescription,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData, pIniSpooler ) == ERROR_SUCCESS)

                    pIniPrinter->pComment = AllocSplStr(szData);

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szParameters,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData, pIniSpooler ) == ERROR_SUCCESS)

                    pIniPrinter->pParameters = AllocSplStr(szData);

                cbData = sizeof(szData);
                *szData = (WCHAR)0;

                if (SplRegQueryValue( hPrinterKey,
                                      szSepFile,
                                      &Type,
                                      (LPBYTE)szData,
                                      &cbData, pIniSpooler ) == ERROR_SUCCESS)

                    pIniPrinter->pSepFile = AllocSplStr(szData);

                cbData = sizeof(pIniPrinter->Attributes);

                SplRegQueryValue( hPrinterKey,
                                  szAttributes,
                                  NULL,
                                  (LPBYTE)&pIniPrinter->Attributes,
                                  &cbData,
                                  pIniSpooler );

                cbData = sizeof(pIniPrinter->Status);

                Status = SplRegQueryValue( hPrinterKey,
                                           szStatus,
                                           &Type,
                                           (LPBYTE)&pIniPrinter->Status,
                                           &cbData,
                                           pIniSpooler );

                pIniPrinter->Status |= PRINTER_FROM_REG;

                if ( Status == ERROR_SUCCESS ) {

                    pIniPrinter->Status &= ( PRINTER_PAUSED           |
                                             PRINTER_PENDING_DELETION |
                                             PRINTER_ZOMBIE_OBJECT    |
                                             PRINTER_FROM_REG         |
                                             PRIN