a dock so we a little bit of work before starting it.
        // Take the profile change semaphore. We do this whenever a dock
        // is in our list, even if no query is going to occur.
        //
        PpProfileBeginHardwareProfileTransition(FALSE);

        //
        // Tell the profile code what dock device object may be bringing the
        // new hardware profile online.
        //
        PpProfileIncludeInHardwareProfileTransition(DeviceNode, DOCK_ARRIVING);

        //
        // Ask everyone if this is really a good idea right now.
        //
        status = PpProfileQueryHardwareProfileChange(
            FALSE,
            PROFILE_PERHAPS_IN_PNPEVENT,
            &vetoType,
            NULL
            );
    }

    if (NT_SUCCESS(status)) {

        status = IopStartDevice(deviceObject);
    }

    //
    // Failure cleanup is handled in PipProcessStartPhase2, thus we write away
    // the failure code and always succeed.
    //
    PipSetDevNodeState(DeviceNode, DeviceNodeStartCompletion, NULL);
    DeviceNode->CompletionStatus = status;
    return STATUS_SUCCESS;
}

NTSTATUS
PipProcessStartPhase2(
    IN PDEVICE_NODE     DeviceNode
    )
{
    ULONG       problem = CM_PROB_FAILED_START;
    NTSTATUS    status;

    PAGED_CODE();

    status = DeviceNode->CompletionStatus;
    if (DeviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

        if (NT_SUCCESS(status)) {

            //
            // Commit the current Hardware Profile as necessary.
            //
            PpProfileCommitTransitioningDock(DeviceNode, DOCK_ARRIVING);

        } else {

            PpProfileCancelHardwareProfileTransition();
        }
    }

    if (!NT_SUCCESS(status)) {

        SAVE_FAILURE_INFO(DeviceNode, DeviceNode->CompletionStatus);

        //
        // Handle certain problems determined by the status code
        //
        switch(status) {

            case STATUS_PNP_REBOOT_REQUIRED:
                problem = CM_PROB_NEED_RESTART;
                break;

            default:
                problem = CM_PROB_FAILED_START;
                break;
        }

        PipRequestDeviceRemoval(DeviceNode, FALSE, problem);

        if (DeviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

            ASSERT(DeviceNode->DockInfo.DockStatus == DOCK_QUIESCENT);
            IoRequestDeviceEject(DeviceNode->PhysicalDeviceObject);
        }

    } else {

        IopDoDeferredSetInterfaceState(DeviceNode);

        //
        // Reserve legacy resources for the legacy interface and bus number.
        //
        if (!IopBootConfigsReserved && DeviceNode->InterfaceType != InterfaceTypeUndefined) {

            //
            // ISA = EISA.
            //
            if (DeviceNode->InterfaceType == Isa) {

                IopAllocateLegacyBootResources(Eisa, DeviceNode->BusNumber);

            }

            IopAllocateLegacyBootResources(DeviceNode->InterfaceType, DeviceNode->BusNumber);
        }

        //
        // This code path currently doesn't expect any of the above functions
        // to fail. If they do, a removal should be queued and failure should
        // be returned.
        //
        ASSERT(DeviceNode->State == DeviceNodeStartCompletion);

        PipSetDevNodeState(DeviceNode, DeviceNodeStartPostWork, NULL);
    }

    return status;
}

NTSTATUS
PipProcessStartPhase3(
    IN PDEVICE_NODE     DeviceNode
    )
{
    NTSTATUS        status;
    PDEVICE_OBJECT  deviceObject;
    HANDLE          handle;
    PWCHAR          ids;
    UNICODE_STRING  unicodeName;

    PAGED_CODE();

    deviceObject = DeviceNode->PhysicalDeviceObject;

    if (!(DeviceNode->Flags & DNF_IDS_QUERIED)) {

        PWCHAR compatibleIds, hwIds;
        ULONG hwIdLength, compatibleIdLength;

        //
        // If the DNF_NEED_QUERY_IDS is set, the device is a reported device.
        // It should already be started.  We need to enumerate its children and ask
        // the HardwareId and the Compatible ids of the detected device.
        //

        status = IopDeviceObjectToDeviceInstance (deviceObject,
                                                  &handle,
                                                  KEY_READ
                                                  );
        if (NT_SUCCESS(status)) {

            PpQueryHardwareIDs( 
                DeviceNode,
                &hwIds,
                &hwIdLength);

            PpQueryCompatibleIDs(   
                DeviceNode,
                &compatibleIds,
                &compatibleIdLength);

            if (hwIds || compatibleIds) {

                UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
                PKEY_VALUE_PARTIAL_INFORMATION keyInfo =
                    (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
                PKEY_VALUE_FULL_INFORMATION keyValueInformation;
                ULONG flags, length;
                PWCHAR  oldID, newID;

                PiLockPnpRegistry(FALSE);

                //
                // Read the current config flags.
                //

                PiWstrToUnicodeString (&unicodeName, REGSTR_VALUE_CONFIG_FLAGS);
                status = ZwQueryValueKey(handle,
                                         &unicodeName,
                                         KeyValuePartialInformation,
                                         keyInfo,
                                         sizeof(buffer),
                                         &length
                                         );
                if (NT_SUCCESS(status) && (keyInfo->Type == REG_DWORD)) {

                    flags = *(PULONG)keyInfo->Data;
                } else {

                    flags = 0;
                }
                if (hwIds) {

                    if (!(flags & CONFIGFLAG_FINISH_INSTALL)) {

                        status = IopGetRegistryValue (handle,
                                                      REGSTR_VALUE_HARDWAREID,
                                                      &keyValueInformation);
                        if (NT_SUCCESS(status)) {

                            if (keyValueInformation->Type == REG_MULTI_SZ) {

                                ids = (PWCHAR)KEY_VALUE_DATA(keyValueInformation);
                                //
                                // Check if the old and new IDs are identical.
                                //
                                for (oldID = ids, newID = hwIds;
                                    *oldID && *newID;
                                    oldID += wcslen(oldID) + 1, newID += wcslen(newID) + 1) {
                                    if (_wcsicmp(oldID, newID)) {

                                        break;
                                    }
                                }
                                if (*oldID || *newID) {

                                    IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                                    "IopStartAndEnumerateDevice: Hardware ID has changed for %wZ\n", &DeviceNode->InstancePath));
                                    flags |= CONFIGFLAG_FINISH_INSTALL;
                                }
                            }
                            ExFreePool(keyValueInformation);
                        }
                    }
                    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_HARDWAREID);
                    ZwSetValueKey(handle,
                                  &unicodeName,
                                  TITLE_INDEX_VALUE,
                                  REG_MULTI_SZ,
                                  hwIds,
                                  hwIdLength);
                    ExFreePool(hwIds);
                }
                //
                // create CompatibleId value name.  It is a MULTI_SZ,
                //
                if (compatibleIds) {

                    if (!(flags & CONFIGFLAG_FINISH_INSTALL)) {
                        status = IopGetRegistryValue (handle,
                                                      REGSTR_VALUE_COMPATIBLEIDS,
                                                      &keyValueInformation);
                        if (NT_SUCCESS(status)) {

                            if (keyValueInformation->Type == REG_MULTI_SZ) {

                                ids = (PWCHAR)KEY_VALUE_DATA(keyValueInformation);
                                //
                                // Check if the old and new IDs are identical.
                                //
                                for (oldID = ids, newID = compatibleIds;
                                     *oldID && *newID;
                                     oldID += wcslen(oldID) + 1, newID += wcslen(newID) + 1) {
                                    if (_wcsicmp(oldID, newID)) {

                                        break;
                                    }
                                }
                                if (*oldID || *newID) {

                                    IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                                    "IopStartAndEnumerateDevice: Compatible ID has changed for %wZ\n", &DeviceNode->InstancePath));
                                    flags |= CONFIGFLAG_FINISH_INSTALL;
                                }
                            }
                            ExFreePool(keyValueInformation);
                        }
                    }
                    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_COMPATIBLEIDS);
                    ZwSetValueKey(handle,
                                  &unicodeName,
                                  TITLE_INDEX_VALUE,
                                  REG_MULTI_SZ,
                                  compatibleIds,
                                  compatibleIdLength);
                    ExFreePool(compatibleIds);
                }

                //
                // If we set the finish install flag, then write out the flags.
                //

                if (flags & CONFIGFLAG_FINISH_INSTALL) {

                    PiWstrToUnicodeString (&unicodeName, REGSTR_VALUE_CONFIG_FLAGS);
                    ZwSetValueKey(handle,
                                  &unicodeName,
                                  TITLE_INDEX_VALUE,
                                  REG_DWORD,
                                  &flags,
                                  sizeof(flags)
                                  );
                }

                PiUnlockPnpRegistry();
            }
            ZwClose(handle);

            DeviceNode->Flags |= DNF_IDS_QUERIED;
        }
    }

    if (PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA)) {

        return STATUS_UNSUCCESSFUL;
    }

    DeviceNode->Flags |= DNF_REENUMERATE;

    IopQueryAndSaveDeviceNodeCapabilities(DeviceNode);
    status = PiProcessQueryDeviceState(deviceObject);

    //
    // The device has been started, attempt to enumerate the device.
    //
    PpSetPlugPlayEvent( &GUID_DEVICE_ARRIVAL,
                        DeviceNode->PhysicalDeviceObject);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    PpvUtilTestStartedPdoStack(deviceObject);
    PipSetDevNodeState( DeviceNode, DeviceNodeStarted, NULL );

    return STATUS_SUCCESS;
}

NTSTATUS
PiProcessQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_NODE deviceNode;
    PNP_DEVICE_STATE deviceState;
    NTSTATUS status;
    ULONG problem;

    PAGED_CODE();

    //
    // If the device was removed or surprised removed while the work
    // item was queued then ignore it.
    //
    status = IopQueryDeviceState(DeviceObject, &deviceState);

    //
    // Now perform the appropriate action based on the returned state
    //
    if (!NT_SUCCESS(status)) {

        return STATUS_SUCCESS;
    }

    deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode;

    if (deviceState & PNP_DEVICE_DONT_DISPLAY_IN_UI) {

        deviceNode->UserFlags |= DNUF_DONT_SHOW_IN_UI;

    } else {

        deviceNode->UserFlags &= ~DNUF_DONT_SHOW_IN_UI;
    }

    if (deviceState & PNP_DEVICE_NOT_DISABLEABLE) {

        if ((deviceNode->UserFlags & DNUF_NOT_DISABLEABLE)==0) {

            //
            // this node itself is not disableable
            //
            deviceNode->UserFlags |= DNUF_NOT_DISABLEABLE;

            //
            // propagate up tree
            //
            IopIncDisableableDepends(deviceNode);
        }

    } else {

        if (deviceNode->UserFlags & DNUF_NOT_DISABLEABLE) {

            //
            // this node itself is now disableable
            //
            //
            // check tree
            //
            IopDecDisableableDepends(deviceNode);

            deviceNode->UserFlags &= ~DNUF_NOT_DISABLEABLE;
        }
    }

    //
    // everything here can only be turned on (state set)
    //
    if (deviceState & (PNP_DEVICE_DISABLED | PNP_DEVICE_REMOVED)) {

        problem = (deviceState & PNP_DEVICE_DISABLED) ?
            CM_PROB_HARDWARE_DISABLED : CM_PROB_DEVICE_NOT_THERE;

        PipRequestDeviceRemoval(deviceNode, FALSE, problem);

        status = STATUS_UNSUCCESSFUL;

    } else if (deviceState & PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED) {

        if (deviceState & PNP_DEVICE_FAILED) {

            IopResourceRequirementsChanged(DeviceObject, TRUE);

        } else {

            IopResourceRequirementsChanged(DeviceObject, FALSE);
        }

    } else if (deviceState & PNP_DEVICE_FAILED) {

        PipRequestDeviceRemoval(deviceNode, FALSE, CM_PROB_FAILED_POST_START);
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

NTSTATUS
PipProcessRestartPhase1(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN Synchronous
    )
{
    NTSTATUS status;
    PAGED_CODE();

    UNREFERENCED_PARAMETER (Synchronous);

    ASSERT(DeviceNode->State == DeviceNodeStopped);

    status = IopStartDevice(DeviceNode->PhysicalDeviceObject);

    //
    // Failure cleanup is handled in PipProcessRestartPhase2, thus we write away
    // the failure code and always succeed.
    //
    DeviceNode->CompletionStatus = status;
    PipSetDevNodeState(DeviceNode, DeviceNodeRestartCompletion, NULL);
    return STATUS_SUCCESS;
}

NTSTATUS
PipProcessRestartPhase2(
    IN PDEVICE_NODE     DeviceNode
    )
{
    ULONG       problem;
    NTSTATUS    status;

    PAGED_CODE();

    status = DeviceNode->CompletionStatus;

    if (!NT_SUCCESS(status)) {

        SAVE_FAILURE_INFO(DeviceNode, status);

        //
        // Handle certain problems determined by the status code
        //
        switch (status) {

            case STATUS_PNP_REBOOT_REQUIRED:
                problem = CM_PROB_NEED_RESTART;
                break;

            default:
                problem = CM_PROB_FAILED_START;
                break;
        }

        PipRequestDeviceRemoval(DeviceNode, FALSE, problem);

        if (DeviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

            ASSERT(DeviceNode->DockInfo.DockStatus == DOCK_QUIESCENT);
            IoRequestDeviceEject(DeviceNode->PhysicalDeviceObject);
        }

    } else {

        PipSetDevNodeState(DeviceNode, DeviceNodeStarted, NULL);
    }

    return status;
}


NTSTATUS
PiProcessHaltDevice(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This routine simulates a surprise removal scenario on the passed in device
    node.

Arguments:

    DeviceNode - DeviceNode to halt

    Flags - PNP_HALT_ALLOW_NONDISABLEABLE_DEVICES - Allows halt on nodes
                                                    marked non-disableable.

Return Value:

    NTSTATUS.

--*/
{
    ULONG flags = (ULONG)Request->RequestArgument;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (PipIsDevNodeDeleted(deviceNode)) {

        return STATUS_DELETE_PENDING;
    }

    if (flags & (~PNP_HALT_ALLOW_NONDISABLEABLE_DEVICES)) {

        return STATUS_INVALID_PARAMETER_2;
    }

    if (deviceNode->Flags & (DNF_MADEUP | DNF_LEGACY_DRIVER)) {

        //
        // Sending surprise removes to legacy devnodes would be a bad idea.
        // Today, if a legacy devnode fails it is manually taken to the removed
        // state rather than being put through the engine.
        //
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ((!(deviceNode->Flags & PNP_HALT_ALLOW_NONDISABLEABLE_DEVICES)) &&
        deviceNode->DisableableDepends) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (deviceNode->State != DeviceNodeStarted) {

        return STATUS_INVALID_DEVICE_STATE;
    }

    PipRequestDeviceRemoval(deviceNode, FALSE, CM_PROB_HALTED);

    return STATUS_SUCCESS;
}


VOID
PpResetProblemDevices(
    IN  PDEVICE_NODE    DeviceNode,
    IN  ULONG           Problem
    )
/*++

Routine Description:

    This routine resets all non-configured devices *beneath* the passed in
    devnode so a subsequent enum will kick off new hardware installation
    on them.

Arguments:

    DeviceNode - DeviceNode to halt

Return Value:

    None.

--*/
{
    PAGED_CODE();

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    PipForDeviceNodeSubtree(
        DeviceNode,
        PiResetProblemDevicesWorker,
        (PVOID)(ULONG_PTR)Problem
        );

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
}


NTSTATUS
PiResetProblemDevicesWorker(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This is a worker routine for PiResetNonConfiguredDevices. If the devnode
    has the problem CM_PROB_NOT_CONFIGURED, the devnode is reset so a
    subsequent reenumeration will bring it back.

Arguments:

    DeviceNode - Device to reset if it has the correct problem.

    Context - Not used.

Return Value:

    NTSTATUS, non-successful statuses terminate the tree walk.

--*/
{
    PAGED_CODE();

    if (PipIsDevNodeProblem(DeviceNode, (ULONG)(ULONG_PTR)Context)) {

        //
        // We only need to queue it as an enumeration will drop behind it soon
        // afterwards...
        //
        PipRequestDeviceAction(
            DeviceNode->PhysicalDeviceObject,
            ClearDeviceProblem,
            TRUE,
            0,
            NULL,
            NULL
            );
    }

    return STATUS_SUCCESS;
}

VOID
PiMarkDeviceTreeForReenumeration(
    IN  PDEVICE_NODE DeviceNode,
    IN  BOOLEAN Subtree
    )
/*++

Routine Description:

    This routine marks the devnode for reenumeration.

Arguments:

    DeviceNode  - DeviceNode to mark for re-enumeration

    Subtree     - If TRUE, the entire subtree is marked for re-enumeration.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    PPDEVNODE_ASSERT_LOCK_HELD(PPL_TREEOP_ALLOW_READS);

    PiMarkDeviceTreeForReenumerationWorker(DeviceNode, NULL);

    if (Subtree) {

        PipForDeviceNodeSubtree(
            DeviceNode,
            PiMarkDeviceTreeForReenumerationWorker,
            NULL
            );
    }
}

NTSTATUS
PiMarkDeviceTreeForReenumerationWorker(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This is a worker routine for PiMarkDeviceTreeForReenumeration. It marks all
    started devnodes with DNF_REENUMERATE so that the subsequent tree
    processing will reenumerate the device.

Arguments:

    DeviceNode - Device to mark if started.

    Context - Not used.

Return Value:

    NTSTATUS, non-successful statuses terminate the tree walk.

--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(Context);

    if (DeviceNode->State == DeviceNodeStarted) {

        if (DeviceNode->Flags & DNF_REENUMERATE) {

            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PiMarkDeviceTreeForReenumerationWorker: Collapsed enum request on %wZ\n", &DeviceNode->InstancePath));
        } else {

            IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                         "PiMarkDeviceTreeForReenumerationWorker: Reenumerating %wZ\n", &DeviceNode->InstancePath));
        }
        DeviceNode->Flags |= DNF_REENUMERATE;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
PiCollapseEnumRequests(
    PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    This function collapses reenumeration requests in the device action queue.

Parameters:

    ListHead - The collapses requests get added to the end of this list.

ReturnValue:

    None.

--*/
{
    KIRQL oldIrql;
    PPI_DEVICE_REQUEST  request;
    PLIST_ENTRY entry, next, last;
    PDEVICE_NODE deviceNode;

    ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);
    last = ListHead->Blink;
    //
    // Walk the list and build the list of collapsed requests.
    //
    for (entry = IopPnpEnumerationRequestList.Flink;
         entry != &IopPnpEnumerationRequestList;
         entry = next) {

        next = entry->Flink;
        request = CONTAINING_RECORD(entry, PI_DEVICE_REQUEST, ListEntry);
        if (request->ReorderingBarrier) {
            break;
        }
        switch(request->RequestType) {
        case ReenumerateRootDevices:
        case ReenumerateDeviceTree:
        case RestartEnumeration:
            //
            // Add it to our request list and mark the subtree.
            //
            RemoveEntryList(entry);
            InsertTailList(ListHead, entry);
            break;

        default:
            break;
        }
    }
    ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
    if (last == ListHead) {

        entry = ListHead->Flink;
    } else {

        entry = last;
    }
    while (entry != ListHead) {

        request = CONTAINING_RECORD(entry, PI_DEVICE_REQUEST, ListEntry);
        deviceNode = (PDEVICE_NODE)request->DeviceObject->DeviceObjectExtension->DeviceNode;
        PiMarkDeviceTreeForReenumeration(deviceNode, TRUE);
        ObDereferenceObject(request->DeviceObject);
        request->DeviceObject = NULL;
        entry = entry->Flink;
    }

    return (last != ListHead->Blink)? TRUE : FALSE;
}

NTSTATUS
PiProcessAddBootDevices(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the AddBootDevices device action.

Parameters:

    Request - AddBootDevices device action request.

    DeviceNode - Devnode on which the action needs to be performed.

ReturnValue:

    STATUS_SUCCESS.

--*/
{
    PDEVICE_NODE deviceNode;
    ADD_CONTEXT addContext;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    //
    // If the device has been added (or failed) skip it.
    //
    // If we know the device is a duplicate of another device which
    // has been enumerated at this point. we will skip this device.
    //
    if (deviceNode->State == DeviceNodeInitialized &&
        !PipDoesDevNodeHaveProblem(deviceNode) &&
        !(deviceNode->Flags & DNF_DUPLICATE) &&
        deviceNode->DuplicatePDO == NULL) {

        //
        // Invoke driver's AddDevice Entry for the device.
        //
        addContext.DriverStartType = SERVICE_BOOT_START;

        PipCallDriverAddDevice(deviceNode, PnPBootDriversInitialized, &addContext);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PiProcessClearDeviceProblem(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the ClearDeviceProblem device action.

Parameters:

    Request - ClearDeviceProblem device action request.

    DeviceNode - Devnode on which the action needs to be performed.

ReturnValue:

    STATUS_SUCCESS or STATUS_INVALID_PARAMETER_2.

--*/
{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (deviceNode->State == DeviceNodeUninitialized ||
        deviceNode->State == DeviceNodeInitialized ||
        deviceNode->State == DeviceNodeRemoved) {

        if (PipDoesDevNodeHaveProblem(deviceNode)) {

            if ((Request->RequestType == ClearDeviceProblem) &&
                (PipIsProblemReadonly(deviceNode->Problem))) {

                //
                // ClearDeviceProblem is a user mode request, and we don't let
                // user mode clear readonly problems!
                //
                status = STATUS_INVALID_PARAMETER_2;

            } else if ((Request->RequestType == ClearEjectProblem) &&
                       (!PipIsDevNodeProblem(deviceNode, CM_PROB_HELD_FOR_EJECT))) {

                //
                // Clear eject problem means clear CM_PROB_HELD_FOR_EJECT. If
                // it received another problem, we leave it alone.
                //
                status = STATUS_INVALID_DEVICE_REQUEST;

            } else {

                deviceNode->Flags &= ~(DNF_HAS_PROBLEM | DNF_HAS_PRIVATE_PROBLEM);
                deviceNode->Problem = 0;
                if (deviceNode->State != DeviceNodeUninitialized) {

                    IopRestartDeviceNode(deviceNode);
                }

                ASSERT(status == STATUS_SUCCESS);
            }
        }
    } else if (PipIsDevNodeDeleted(deviceNode)) {

        status = STATUS_DELETE_PENDING;
    }

    return status;
}

NTSTATUS
PiProcessRequeryDeviceState(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the RequeryDeviceState device action.

Parameters:

    Request - RequeryDeviceState device action request.

    DeviceNode - Devnode on which the action needs to be performed.

ReturnValue:

    STATUS_SUCCESS.

--*/
{
    PDEVICE_NODE deviceNode;
    NTSTATUS status;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (deviceNode->State == DeviceNodeStarted) {

        PiProcessQueryDeviceState(Request->DeviceObject);
        //
        // PCMCIA driver uses this when switching between Cardbus and R2 cards.
        //
        IopUncacheInterfaceInformation(Request->DeviceObject);

    } else if (PipIsDevNodeDeleted(deviceNode)) {

        status = STATUS_DELETE_PENDING;
    }

    return status;
}

NTSTATUS
PiProcessResourceRequirementsChanged(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the ResourceRequirementsChanged device action.

Parameters:

    Request - ResourceRequirementsChanged device action request.

    DeviceNode - Devnode on which the action needs to be performed.

ReturnValue:

    STATUS_SUCCESS or STATUS_UNSUCCESSFUL.

--*/
{
    NTSTATUS status;
    ADD_CONTEXT addContext;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (PipIsDevNodeDeleted(deviceNode)) {

        return STATUS_DELETE_PENDING;
    }
    //
    // Clear the NO_RESOURCE_REQUIRED flags.
    //
    deviceNode->Flags &= ~DNF_NO_RESOURCE_REQUIRED;
    //
    // If for some reason this device did not start, we need to clear some flags
    // such that it can be started later.  In this case, we call IopRequestDeviceEnumeration
    // with NULL device object, so the devices will be handled in non-started case.  They will
    // be assigned resources, started and enumerated.
    //
    deviceNode->Flags |= DNF_RESOURCE_REQUIREMENTS_CHANGED;
    PipClearDevNodeProblem(deviceNode);
    //
    // If the device is already started, we call IopRequestDeviceEnumeration with
    // the device object.
    //
    if (deviceNode->State == DeviceNodeStarted) {

        if (Request->RequestArgument == FALSE) {

            deviceNode->Flags |= DNF_NON_STOPPED_REBALANCE;

        } else {
            //
            // Explicitly clear it.
            //
            deviceNode->Flags &= ~DNF_NON_STOPPED_REBALANCE;
        }
        //
        // Reallocate resources for this devNode.
        //
        IopReallocateResources(deviceNode);

        addContext.DriverStartType = SERVICE_DEMAND_START;

        status = PipProcessDevNodeTree( IopRootDeviceNode,
                                        PnPBootDriversInitialized,          // LoadDriver
                                        FALSE,                              // ReallocateResources
                                        EnumTypeNone,                       // ShallowReenumeration
                                        Request->CompletionEvent != NULL ? TRUE: FALSE,   // Synchronous
                                        TRUE,                               // ProcessOnlyIntermediateStates
                                        &addContext,
                                        Request);
        ASSERT(NT_SUCCESS(status));
        if (!NT_SUCCESS(status)) {

            status = STATUS_SUCCESS;
        }
    } else {

        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

NTSTATUS
PiProcessReenumeration(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the RestartEnumeration\ReenumerateRootDevices\
    ReenumerateDeviceTree\ReenumerateDeviceOnly device action.

Parameters:

    RequestList - List of reenumeration requests.

ReturnValue:

    STATUS_SUCCESS.

--*/
{
    PDEVICE_NODE deviceNode;
    ADD_CONTEXT addContext;
    ENUM_TYPE enumType;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (PipIsDevNodeDeleted(deviceNode)) {

        return STATUS_DELETE_PENDING;
    }
    enumType = (Request->RequestType == ReenumerateDeviceOnly)? EnumTypeShallow : EnumTypeDeep;
    PiMarkDeviceTreeForReenumeration(
        deviceNode,
        enumType != EnumTypeShallow ? TRUE : FALSE);

    addContext.DriverStartType = SERVICE_DEMAND_START;

    PipProcessDevNodeTree(
        deviceNode,
        PnPBootDriversInitialized,  // LoadDriver
        FALSE,                      // ReallocateResources
        enumType,
        TRUE,                       // Synchronous
        FALSE,
        &addContext,
        Request);

    return STATUS_SUCCESS;
}

NTSTATUS
PiProcessSetDeviceProblem(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the SetDeviceProblem device action.

Parameters:

    Request - SetDeviceProblem device action request.

    DeviceNode - Devnode on which the action needs to be performed.

ReturnValue:

    STATUS_SUCCESS or STATUS_INVALID_PARAMETER_2.

--*/
{
    PPLUGPLAY_CONTROL_STATUS_DATA statusData;
    ULONG   flags, userFlags;
    NTSTATUS status;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (PipIsDevNodeDeleted(deviceNode)) {

        return STATUS_DELETE_PENDING;
    }
    status = STATUS_SUCCESS;
    statusData = (PPLUGPLAY_CONTROL_STATUS_DATA)Request->RequestArgument;
    userFlags = 0;
    flags = 0;
    if (statusData->DeviceStatus & DN_WILL_BE_REMOVED) {

        userFlags |= DNUF_WILL_BE_REMOVED;
    }
    if (statusData->DeviceStatus & DN_NEED_RESTART) {

        userFlags |= DNUF_NEED_RESTART;
    }
    if (statusData->DeviceStatus & DN_PRIVATE_PROBLEM) {

        flags |= DNF_HAS_PRIVATE_PROBLEM;
    }
    if (statusData->DeviceStatus & DN_HAS_PROBLEM) {

        flags |= DNF_HAS_PROBLEM;
    }
    if (statusData->DeviceProblem == CM_PROB_NEED_RESTART) {

        flags       &= ~DNF_HAS_PROBLEM;
        userFlags   |= DNUF_NEED_RESTART;
    }
    if (flags & (DNF_HAS_PROBLEM | DNF_HAS_PRIVATE_PROBLEM)) {

        ASSERT(!PipIsDevNodeDNStarted(deviceNode));
        //
        // ISSUE - 2000/12/07 - ADRIAO:
        //     This set of code allows you to clear read only
        // problems by first changing it to a resetable problem,
        // then clearing. This is not intentional.
        //
        if ( ((deviceNode->State == DeviceNodeInitialized) ||
              (deviceNode->State == DeviceNodeRemoved)) &&
                !PipIsProblemReadonly(statusData->DeviceProblem)) {

            deviceNode->Problem     = statusData->DeviceProblem;
            deviceNode->Flags       |= flags;
            deviceNode->UserFlags   |= userFlags;

        } else {

            status = STATUS_INVALID_PARAMETER_2;
        }
    } else {

        deviceNode->Flags |= flags;
        deviceNode->UserFlags |= userFlags;
    }

    return status;
}

NTSTATUS
PiProcessShutdownPnpDevices(
    IN OUT PDEVICE_NODE        DeviceNode
    )
/*++

Routine Description:

    This function processes the ShutdownPnpDevices device action. Walks the tree
    issuing IRP_MN_QUERY_REMOVE \ IRP_MN_REMOVE_DEVICE to each stack.

Parameters:

    DeviceNode - Root devnode.

ReturnValue:

    STATUS_SUCCESS.

--*/
{
    KEVENT          userEvent;
    ULONG           eventResult;
    WCHAR           vetoName[80];
    UNICODE_STRING  vetoNameString = { 0, sizeof(vetoName), vetoName };
    PNP_VETO_TYPE   vetoType;
    NTSTATUS        status;

    PAGED_CODE();

    ASSERT(DeviceNode == IopRootDeviceNode);
    status = STATUS_SUCCESS;
    if (PipTearDownPnpStacksOnShutdown ||
        (PoCleanShutdownEnabled() & PO_CLEAN_SHUTDOWN_PNP)) {

        DeviceNode->UserFlags |= DNUF_SHUTDOWN_QUERIED;

        for ( ; ; ) {

            //
            // Acquire the registry lock to prevent in process removals causing
            // Devnodes to be unlinked from the tree.
            //

            PiLockPnpRegistry(FALSE);

            //
            // Walk the tree looking for devnodes we haven't QueryRemoved yet.
            //

            DeviceNode = DeviceNode->Child;
            while (DeviceNode != NULL) {

                if (DeviceNode->UserFlags & DNUF_SHUTDOWN_SUBTREE_DONE) {
                    if (DeviceNode == IopRootDeviceNode) {
                        //
                        // We've processed the entire devnode tree - we're done
                        //
                        DeviceNode = NULL;
                        break;
                    }

                    if (DeviceNode->Sibling == NULL) {

                        DeviceNode = DeviceNode->Parent;

                        DeviceNode->UserFlags |= DNUF_SHUTDOWN_SUBTREE_DONE;

                    } else {

                        DeviceNode = DeviceNode->Sibling;
                    }

                    continue;
                }

                if (DeviceNode->UserFlags & DNUF_SHUTDOWN_QUERIED) {

                    if (DeviceNode->Child == NULL) {

                        DeviceNode->UserFlags |= DNUF_SHUTDOWN_SUBTREE_DONE;

                        if (DeviceNode->Sibling == NULL) {

                            DeviceNode = DeviceNode->Parent;

                            DeviceNode->UserFlags |= DNUF_SHUTDOWN_SUBTREE_DONE;

                        } else {

                            DeviceNode = DeviceNode->Sibling;
                        }
                    } else {

                        DeviceNode = DeviceNode->Child;
                    }

                    continue;
                }
                break;
            }

            if (DeviceNode != NULL) {

                DeviceNode->UserFlags |= DNUF_SHUTDOWN_QUERIED;

                //
                // Queue this device event
                //

                KeInitializeEvent(&userEvent, NotificationEvent, FALSE);

                vetoNameString.Length = 0;
                //
                // Queue the event, this call will return immediately. Note that status
                // is the status of the PpSetTargetDeviceChange while result is the
                // outcome of the actual event.
                //

                status = PpSetTargetDeviceRemove(DeviceNode->PhysicalDeviceObject,
                                                 FALSE,         // KernelInitiated
                                                 TRUE,          // NoRestart
                                                 FALSE,         // DoEject
                                                 FALSE,
                                                 CM_PROB_SYSTEM_SHUTDOWN,
                                                 &userEvent,
                                                 &eventResult,
                                                 &vetoType,
                                                 &vetoNameString);
            } else {

                status = STATUS_UNSUCCESSFUL;
                eventResult = 0;
            }

            PiUnlockPnpRegistry();

            if (DeviceNode == NULL) {
                //
                // We've processed the entire tree.
                //
                break;
            }

            //
            // Let the removes drain...
            //
            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

            if (NT_SUCCESS(status)) {

                //
                // Wait for the event we just queued to finish since synchronous
                // operation was requested (non alertable wait).
                //
                // FUTURE ITEM - Use a timeout here?
                //

                status = KeWaitForSingleObject( &userEvent,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);

                if (NT_SUCCESS(status)) {
                    status = eventResult;
                }
            }

            //
            // Require lock, start on the next
            //
            PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);
        }
    }

    //
    // Prevent any more events or action worker items from being queued
    //
    PpPnpShuttingDown = TRUE;

    //
    // Drain the event queue
    //
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
    PpSynchronizeDeviceEventQueue();
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    return status;
}

NTSTATUS
PiProcessStartSystemDevices(
    IN PPI_DEVICE_REQUEST  Request
    )
/*++

Routine Description:

    This function processes the StartSystemDevices device action.

Parameters:

    RequestList - List of reenumeration requests.

ReturnValue:

    STATUS_SUCCESS.

--*/
{
    PDEVICE_NODE deviceNode;
    ADD_CONTEXT addContext;

    PAGED_CODE();

    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;

    addContext.DriverStartType = SERVICE_DEMAND_START;

    PipProcessDevNodeTree(
        deviceNode,
        PnPBootDriversInitialized,          // LoadDriver
        FALSE,                              // ReallocateResources
        EnumTypeNone,
        Request->CompletionEvent != NULL ? TRUE : FALSE,   // Synchronous
        FALSE,
        &addContext,
        Request);

    return STATUS_SUCCESS;
}

VOID
PpRemoveDeviceActionRequests(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    KIRQL oldIrql;
    PPI_DEVICE_REQUEST request;
    PLIST_ENTRY entry, next;

    ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);
    //
    // Walk the list and build the list of collapsed requests.
    //
    for (entry = IopPnpEnumerationRequestList.Flink;
         entry != &IopPnpEnumerationRequestList;
         entry = next) {

        next = entry->Flink;
        request = CONTAINING_RECORD(entry, PI_DEVICE_REQUEST, ListEntry);
        if (request->DeviceObject == DeviceObject) {

            RemoveEntryList(entry);
            if (request->CompletionStatus) {

                *request->CompletionStatus = STATUS_NO_SUCH_DEVICE;
            }
            if (request->CompletionEvent) {

                KeSetEvent(request->CompletionEvent, 0, FALSE);
            }
            ObDereferenceObject(request->DeviceObject);
            ExFreePool(request);
        }
    }
    ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
}

#if DBG
VOID
PipAssertDevnodesInConsistentState(
    VOID
    )
{
    PDEVICE_NODE deviceNode;

    deviceNode = IopRootDeviceNode;

    do {

        ASSERT(deviceNode->State == DeviceNodeUninitialized ||
               deviceNode->State == DeviceNodeInitialized ||
               deviceNode->State == DeviceNodeDriversAdded ||
               deviceNode->State == DeviceNodeResourcesAssigned ||
               deviceNode->State == DeviceNodeStarted ||
               deviceNode->State == DeviceNodeStartPostWork ||
               deviceNode->State == DeviceNodeAwaitingQueuedDeletion ||
               deviceNode->State == DeviceNodeAwaitingQueuedRemoval ||
               deviceNode->State == DeviceNodeRemovePendingCloses ||
               deviceNode->State == DeviceNodeRemoved);

        if (deviceNode->Child != NULL) {

            deviceNode = deviceNode->Child;

        } else {

            while (deviceNode->Sibling == NULL) {

                if (deviceNode->Parent != NULL) {
                    deviceNode = deviceNode->Parent;
                } else {
                    break;
                }
            }

            if (deviceNode->Sibling != NULL) {
                deviceNode = deviceNode->Sibling;
            }
        }

    } while (deviceNode != IopRootDeviceNode);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpinit.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpinit.c

Abstract:

    This module contains the plug-and-play initialization
    subroutines for the I/O system.


Author:

    Shie-Lin Tzong (shielint) 30-Jan-1995

Environment:

    Kernel mode


Revision History:


--*/

#include "pnpmgrp.h"
#define _APPHELP_CACHE_INIT_
#include "ahcache.h"
#pragma hdrstop

#define SYSTEM_HIVE_LOW     80
#define SYSTEM_HIVE_HIGH    90

#include <inbv.h>
#include <hdlsblk.h>
#include <hdlsterm.h>

#include <initguid.h>
#include <ntddramd.h>

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'nipP')
#endif

//
// Define the type for driver group name entries in the group list so that
// load order dependencies can be tracked.
//

typedef struct _TREE_ENTRY {
    struct _TREE_ENTRY *Left;
    struct _TREE_ENTRY *Right;
    struct _TREE_ENTRY *Sibling;
    ULONG DriversThisType;
    ULONG DriversLoaded;
    UNICODE_STRING GroupName;
} TREE_ENTRY, *PTREE_ENTRY;

typedef struct _DRIVER_INFORMATION {
    LIST_ENTRY              Link;
    PDRIVER_OBJECT          DriverObject;
    PBOOT_DRIVER_LIST_ENTRY DataTableEntry;
    HANDLE                  ServiceHandle;
    USHORT                  TagPosition;
    BOOLEAN                 Failed;
    BOOLEAN                 Processed;
    NTSTATUS                Status;
} DRIVER_INFORMATION, *PDRIVER_INFORMATION;

PTREE_ENTRY IopGroupListHead;

#define ALLOW_WORLD_READ_OF_ENUM        1

PTREE_ENTRY
PipCreateEntry(
    IN PUNICODE_STRING GroupName
    );

VOID
PipFreeGroupTree(
    IN PTREE_ENTRY TreeEntry
    );

USHORT
PipGetDriverTagPriority(
    IN HANDLE Servicehandle
    );

NTSTATUS
PipPnPDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
PipAddDevicesToBootDriver(
   IN PDRIVER_OBJECT DriverObject
   );

BOOLEAN
PipAddDevicesToBootDriverWorker(
    IN HANDLE DeviceInstanceHandle,
    IN PUNICODE_STRING DeviceInstancePath,
    IN OUT PVOID Context
    );

BOOLEAN
PipCheckDependencies(
    IN HANDLE KeyHandle
    );

INTERFACE_TYPE
PipDetermineDefaultInterfaceType(
    VOID
    );

VOID
PipInsertDriverList(
    IN PLIST_ENTRY ListHead,
    IN PDRIVER_INFORMATION DriverInfo
    );

PTREE_ENTRY
PipLookupGroupName(
    IN PUNICODE_STRING GroupName,
    IN BOOLEAN Insert
    );

VOID
PipNotifySetupDevices(
    PDEVICE_NODE DeviceNode
    );

BOOLEAN
PipWaitForBootDevicesDeleted(
    IN VOID
    );

BOOLEAN
PipWaitForBootDevicesStarted(
    IN VOID
    );

BOOLEAN
PiInitPhase0(
    VOID
    );

BOOLEAN
PiInitPhase1(
    VOID
    );

NTSTATUS
RawInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
PiInitCacheGroupInformation(
    VOID
    );

VOID
PiInitReleaseCachedGroupInformation(
    VOID
    );

NTSTATUS
IopStartRamdisk(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

//
// Group order table
//

ULONG IopGroupIndex;
PLIST_ENTRY IopGroupTable;

//
// Group order cache list.
//
UNICODE_STRING *PiInitGroupOrderTable      = NULL;
USHORT          PiInitGroupOrderTableCount = 0;
BOOLEAN         PpDisableFirmwareMapper = FALSE;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IopInitializeBootDrivers)
#pragma alloc_text(INIT, IopInitializePlugPlayServices)
#pragma alloc_text(INIT, IopInitializeSystemDrivers)

#pragma alloc_text(INIT, PipAddDevicesToBootDriver)
#pragma alloc_text(INIT, PipAddDevicesToBootDriverWorker)
#pragma alloc_text(INIT, PipCheckDependencies)
#pragma alloc_text(INIT, PipCreateEntry)
#pragma alloc_text(INIT, PipDetermineDefaultInterfaceType)
#pragma alloc_text(INIT, PipFreeGroupTree)
#pragma alloc_text(INIT, PipGetDriverTagPriority)
#pragma alloc_text(INIT, PipInsertDriverList)
#pragma alloc_text(INIT, PipLoadBootFilterDriver)
#pragma alloc_text(INIT, PipLookupGroupName)
#pragma alloc_text(INIT, PipNotifySetupDevices)
#pragma alloc_text(INIT, PipPnPDriverEntry)
#pragma alloc_text(INIT, PipWaitForBootDevicesDeleted)
#pragma alloc_text(INIT, PipWaitForBootDevicesStarted)

#pragma alloc_text(INIT, PiInitPhase0)
#pragma alloc_text(INIT, PiInitPhase1)
#pragma alloc_text(INIT, PpInitSystem)
#pragma alloc_text(INIT, PiInitCacheGroupInformation)
#pragma alloc_text(INIT, PiInitReleaseCachedGroupInformation)
#pragma alloc_text(INIT, PpInitGetGroupOrderIndex)
#pragma alloc_text(INIT, IopStartRamdisk)
#endif

NTSTATUS
IopInitializePlugPlayServices(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG Phase
    )

/*++

Routine Description:

    This routine initializes kernel mode Plug and Play services.

Arguments:

    LoaderBlock - supplies a pointer to the LoaderBlock passed in from the
        OS Loader.

Returns:

    NTSTATUS code for sucess or reason of failure.

--*/
{
    NTSTATUS status;
    HANDLE hTreeHandle, parentHandle, handle, hCurrentControlSet = NULL;
    UNICODE_STRING unicodeName, previousDate, currentDate;
    PKEY_VALUE_FULL_INFORMATION detectionInfo, vetoHandleInfo;
    PDEVICE_OBJECT deviceObject;
    ULONG disposition;
    INTERFACE_TYPE interface;
    OBJECT_ATTRIBUTES objectAttributes;
    PKEY_VALUE_FULL_INFORMATION oldInformation, information;
    HANDLE systemInfoKey;

    if (Phase == 0) {

        PnPInitialized = FALSE;

        //
        // Register with CM so we get called when the system hive becomes too
        // large.
        //
        PpSystemHiveLimits.Low = SYSTEM_HIVE_LOW;
        PpSystemHiveLimits.High = SYSTEM_HIVE_HIGH;
        CmRegisterSystemHiveLimitCallback(
            SYSTEM_HIVE_LOW,
            SYSTEM_HIVE_HIGH,
            (PVOID)&PpSystemHiveLimits,
            (PCM_HYSTERESIS_CALLBACK)PpSystemHiveLimitCallback
            );
        PpSystemHiveTooLarge = FALSE;

        InitializeObjectAttributes(
            &objectAttributes,
            &CmRegistryMachineHardwareDescriptionSystemName,
            OBJ_CASE_INSENSITIVE  | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

        status = ZwCreateKey(
            &systemInfoKey,
            KEY_ALL_ACCESS,
            &objectAttributes,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            &disposition
            );
        if (NT_SUCCESS(status)) {

            //
            // Log an event if system firmware has been updated.
            //
            status = IopGetRegistryValue(
                systemInfoKey,
                L"OldSystemBiosDate",
                &oldInformation
                );
            if (NT_SUCCESS(status) && oldInformation) {

                status = IopGetRegistryValue(
                    systemInfoKey,
                    L"SystemBiosDate",
                    &information
                    );
                if (NT_SUCCESS(status) && information) {

                    RtlInitUnicodeString(&previousDate, (PWCHAR)KEY_VALUE_DATA(oldInformation));
                    RtlInitUnicodeString(&currentDate, (PWCHAR)KEY_VALUE_DATA(information));
                    PpLogEvent(&previousDate, &currentDate, STATUS_FIRMWARE_UPDATED, NULL, 0);

                    ExFreePool(information);
                }
                ExFreePool(oldInformation);
            }

            ZwClose(systemInfoKey);
        }

        //
        // Initialize the blocked driver database.
        //
        PpInitializeBootDDB(LoaderBlock);

        //
        // Build up the group order cache list. This is the MultiSz string that
        // tells us what order to start legacy drivers in. Drivers belonging to
        // an earlier group get started first (within the group Tag ordering is
        // used)
        //
        status = PiInitCacheGroupInformation();
        if (!NT_SUCCESS(status)) {

            return status;
        }

        //
        // Initialize the registry access semaphore.
        //

        KeInitializeSemaphore( &PpRegistrySemaphore, 1, 1 );

        //
        // Initialize the Legacy Bus information table.
        //

        for (interface = Internal; interface < MaximumInterfaceType; interface++) {

            InitializeListHead(&IopLegacyBusInformationTable[interface]);
        }

        //
        // Initialize the resource map
        //

        IopInitializeResourceMap (LoaderBlock);

        //
        // Allocate two one-page scratch buffers to be used by our
        // initialization code.  This avoids constant pool allocations.
        //

        IopPnpScratchBuffer1 = ExAllocatePool(PagedPool, PNP_LARGE_SCRATCH_BUFFER_SIZE);
        if (!IopPnpScratchBuffer1) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IopInitReservedResourceList = NULL;

        IopAllocateBootResourcesRoutine = IopReportBootResources;

        //
        // Determine the PnpDefaultInterfaceType.  For root enumerated devices if the Interface
        // type of their resource list or resource requirements list are undefined.  We will use
        // the default type instead.
        //

        PnpDefaultInterfaceType = PipDetermineDefaultInterfaceType();

        //
        // Initialize root arbiters
        //

        status = IopPortInitialize();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        status = IopMemInitialize();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        status = IopDmaInitialize();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        status = IopIrqInitialize();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        status = IopBusNumberInitialize();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        status = IopOpenRegistryKeyEx( &hCurrentControlSet,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSet,
                                       KEY_ALL_ACCESS
                                       );
        if (!NT_SUCCESS(status)) {
            hCurrentControlSet = NULL;
            goto init_Exit0;
        }
        //
        // Open HKLM\System\CurrentControlSet\Control\Pnp
        //

        PiWstrToUnicodeString(&unicodeName, REGSTR_PATH_CONTROL_PNP);
        status = IopCreateRegistryKeyEx( &handle,
                                         hCurrentControlSet,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
        if (NT_SUCCESS(status)) {

            //
            // HACK: Since it was too late to make the change in XP, we target
            // this behaviour at machines with MATROX G100. The inf sets this
            // flag in the registry.
            //
            // FUTURE: Rip this out in Longhorn.
            //
            status = IopGetRegistryValue(handle,
                                         REGSTR_VAL_WIN2000STARTORDER,
                                         &detectionInfo
                                         );
            if (NT_SUCCESS(status)) {

                if (detectionInfo->Type == REG_DWORD && detectionInfo->DataLength == sizeof(ULONG)) {

                    //
                    // KEY_VALUE_DATA returns a PUCHAR.
                    //
                    PpCallerInitializesRequestTable = (BOOLEAN) *(KEY_VALUE_DATA(detectionInfo));
                }
                ExFreePool(detectionInfo);
            }

            //
            // Read a flag that'll force us to dump handle information during
            // failed QueryRemoves to setupapi.log. This is only here for
            // debugging scenarios in which it's impossible to get the customer
            // up and running on a debugger under a checked build.
            //
            // FUTURE: Rip this out in Longhorn.
            //
            status = IopGetRegistryValue(handle,
                                         REGSTR_VAL_RETURNHANDLEINFO,
                                         &vetoHandleInfo
                                         );
            if (NT_SUCCESS(status)) {

                if (vetoHandleInfo->Type == REG_DWORD && vetoHandleInfo->DataLength == sizeof(ULONG)) {

                    //
                    // KEY_VALUE_DATA returns a PUCHAR.
                    //
                    PiCollectVetoedHandles = (LOGICAL) (BOOLEAN) *(KEY_VALUE_DATA(vetoHandleInfo));
                }

                ExFreePool(vetoHandleInfo);
            }

            //
            // Close the handle to the PnP control key now that we are done.
            //
            ZwClose(handle);
        }

        //
        // Next open/create System\CurrentControlSet\Enum\Root key.
        //

        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_ENUM);
        status = IopCreateRegistryKeyEx( &handle,
                                         hCurrentControlSet,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         &disposition
                                         );
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        if (disposition == REG_CREATED_NEW_KEY) {
            SECURITY_DESCRIPTOR     newSD;
            PACL                    newDacl;
            ULONG                   sizeDacl;

            status = RtlCreateSecurityDescriptor( &newSD,
                                                  SECURITY_DESCRIPTOR_REVISION );
            ASSERT( NT_SUCCESS( status ) );

            //
            // calculate the size of the new DACL
            //
            sizeDacl = sizeof(ACL);
            sizeDacl += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(SeLocalSystemSid) - sizeof(ULONG);

#if ALLOW_WORLD_READ_OF_ENUM
            sizeDacl += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(SeWorldSid) - sizeof(ULONG);
#endif

            //
            // create and initialize the new DACL
            //
            newDacl = ExAllocatePool(PagedPool, sizeDacl);

            if (newDacl != NULL) {

                status = RtlCreateAcl(newDacl, sizeDacl, ACL_REVISION);

                ASSERT( NT_SUCCESS( status ) );

                //
                // Add just the local system full control ace to this new DACL
                //
                status = RtlAddAccessAllowedAceEx( newDacl,
                                                   ACL_REVISION,
                                                   CONTAINER_INHERIT_ACE,
                                                   KEY_ALL_ACCESS,
                                                   SeLocalSystemSid
                                                   );
                ASSERT( NT_SUCCESS( status ) );

#if ALLOW_WORLD_READ_OF_ENUM
                //
                // Add a world read control ace to this new DACL
                //
                status = RtlAddAccessAllowedAceEx( newDacl,
                                                   ACL_REVISION,
                                                   CONTAINER_INHERIT_ACE,
                                                   KEY_READ,
                                                   SeWorldSid
                                                   );
                ASSERT( NT_SUCCESS( status ) );

#endif
                //
                // Set the new DACL in the absolute security descriptor
                //
                status = RtlSetDaclSecurityDescriptor( (PSECURITY_DESCRIPTOR) &newSD,
                                                       TRUE,
                                                       newDacl,
                                                       FALSE
                                                       );

                ASSERT( NT_SUCCESS( status ) );

                //
                // validate the new security descriptor
                //
                status = RtlValidSecurityDescriptor(&newSD);

                ASSERT( NT_SUCCESS( status ) );

                status = ZwSetSecurityObject( handle,
                                              DACL_SECURITY_INFORMATION,
                                              &newSD
                                              );
                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((   IOP_ERROR_LEVEL,
                                    "IopInitializePlugPlayServices: ZwSetSecurityObject on Enum key failed, status = %8.8X\n", status));
                }

                ExFreePool(newDacl);
            } else {

                IopDbgPrint((   IOP_ERROR_LEVEL,
                                "IopInitializePlugPlayServices: ExAllocatePool failed allocating DACL for Enum key\n"));
            }
        }

        parentHandle = handle;
        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_ROOTENUM);
        status = IopCreateRegistryKeyEx( &handle,
                                         parentHandle,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
        ZwClose(parentHandle);
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }
        ZwClose(handle);

        //
        // Create the registry entry for the root of the hardware tree (HTREE\ROOT\0).
        //

        status = IopOpenRegistryKeyEx( &handle,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSetEnumName,
                                       KEY_ALL_ACCESS
                                       );
        if (NT_SUCCESS(status)) {
            PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_ROOT_DEVNODE);
            status = IopCreateRegistryKeyEx( &hTreeHandle,
                                             handle,
                                             &unicodeName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_NON_VOLATILE,
                                             NULL
                                             );
            ZwClose(handle);
            if (NT_SUCCESS(status)) {
                ZwClose(hTreeHandle);
            }
        }

        //
        // Before creating device node tree, we need to initialize the device
        // tree lock.
        //

        InitializeListHead(&IopPendingEjects);
        InitializeListHead(&IopPendingSurpriseRemovals);
        InitializeListHead(&IopPnpEnumerationRequestList);
        ExInitializeResourceLite(&IopDeviceTreeLock);
        ExInitializeResourceLite(&IopSurpriseRemoveListLock);
        PiInitializeEngineLock();
        KeInitializeEvent(&PiEventQueueEmpty, NotificationEvent, TRUE );
        KeInitializeEvent(&PiEnumerationLock, NotificationEvent, TRUE );
        KeInitializeSpinLock(&IopPnPSpinLock);

        //
        // Initialize the hardware profile/docking support.
        //
        PpProfileInit();

        //
        // Initialize warm docking variables.
        //
        IopWarmEjectPdo = NULL;
        KeInitializeEvent(&IopWarmEjectLock, SynchronizationEvent, TRUE );

        //
        // Create a PnP manager's driver object to own all the detected PDOs.
        //

        PiWstrToUnicodeString(&unicodeName, PNPMGR_STR_PNP_DRIVER);
        status = IoCreateDriver (&unicodeName, PipPnPDriverEntry);
        if (NT_SUCCESS(status)) {

            //
            // Create empty device node tree, i.e., only contains only root device node
            //     (No need to initialize Parent, Child and Sibling links.)

            status = IoCreateDevice( IoPnpDriverObject,
                                     sizeof(IOPNP_DEVICE_EXTENSION),
                                     NULL,
                                     FILE_DEVICE_CONTROLLER,
                                     0,
                                     FALSE,
                                     &deviceObject );

            if (NT_SUCCESS(status)) {
                deviceObject->Flags |= DO_BUS_ENUMERATED_DEVICE;
                status = PipAllocateDeviceNode(
                    deviceObject,
                    &IopRootDeviceNode);

                if (!IopRootDeviceNode) {
                    IoDeleteDevice(deviceObject);
                    IoDeleteDriver(IoPnpDriverObject);
                } else {
                    IopRootDeviceNode->Flags |= DNF_MADEUP |
                                                DNF_ENUMERATED |
                                                DNF_IDS_QUERIED |
                                                DNF_NO_RESOURCE_REQUIRED;

                    IopRootDeviceNode->InstancePath.Buffer = ExAllocatePool( PagedPool,
                                                                             sizeof(REGSTR_VAL_ROOT_DEVNODE));

                    if (IopRootDeviceNode->InstancePath.Buffer != NULL) {
                        IopRootDeviceNode->InstancePath.MaximumLength = sizeof(REGSTR_VAL_ROOT_DEVNODE);
                        IopRootDeviceNode->InstancePath.Length = sizeof(REGSTR_VAL_ROOT_DEVNODE) - sizeof(WCHAR);

                        RtlCopyMemory( IopRootDeviceNode->InstancePath.Buffer,
                                       REGSTR_VAL_ROOT_DEVNODE,
                                       sizeof(REGSTR_VAL_ROOT_DEVNODE));
                    } else {
                        ASSERT(IopRootDeviceNode->InstancePath.Buffer);
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto init_Exit0;
                    }
                    status = IopMapDeviceObjectToDeviceInstance(
                        IopRootDeviceNode->PhysicalDeviceObject,
                        &IopRootDeviceNode->InstancePath);
                    if (!NT_SUCCESS(status)) {
                        goto init_Exit0;
                    }
                    PipSetDevNodeState(IopRootDeviceNode, DeviceNodeStarted, NULL);
                }
            }
        }

        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        //
        // Initialize the kernel mode pnp notification system
        //

        status = PpInitializeNotification();
        if (!NT_SUCCESS(status)) {
            goto init_Exit0;
        }

        IopInitializePlugPlayNotification();

        //
        // Initialize table for holding bus type guid list.
        //

        status = PpBusTypeGuidInitialize();
        if (!NT_SUCCESS(status)) {

            goto init_Exit0;
        }

        //
        // Enumerate the ROOT bus synchronously.
        //

        PipRequestDeviceAction( IopRootDeviceNode->PhysicalDeviceObject,
                                ReenumerateRootDevices,
                                FALSE,
                                0,
                                NULL,
                                NULL);

init_Exit0:

        //
        // If we managed to open the Current Control Set close it
        //

        if (hCurrentControlSet) {
            ZwClose(hCurrentControlSet);
        }

        if (!NT_SUCCESS(status)) {
            ExFreePool(IopPnpScratchBuffer1);
        }

    } else if (Phase == 1) {

        //
        // Collect the necessary firmware tree information.
        //

        MapperProcessFirmwareTree(PpDisableFirmwareMapper);

        //
        // Map this into the root enumerator tree
        //

        MapperConstructRootEnumTree(PpDisableFirmwareMapper);

#if defined(_X86_)

        if (!PpDisableFirmwareMapper) {

            //
            // Now do the PnP BIOS enumerated devnodes.
            //

            status = PnPBiosMapper();

            //
            // If the previous call succeeds, we have a PNPBios, turn any newly
            // created ntdetect COM ports into phantoms
            //
            if (NT_SUCCESS(status)) {
                MapperPhantomizeDetectedComPorts();
            }
        }
        EisaBuildEisaDeviceNode();

#endif

        //
        // We're done with the firmware mapper device list.
        //

        MapperFreeList();


        //
        // Enumerate the ROOT bus synchronously.
        //

        PipRequestDeviceAction( IopRootDeviceNode->PhysicalDeviceObject,
                                ReenumerateRootDevices,
                                FALSE,
                                0,
                                NULL,
                                NULL);

        //
        // Free our scratch buffers and exit.
        //

        ExFreePool(IopPnpScratchBuffer1);

        ApphelpCacheInitialize(LoaderBlock, Phase);

        status = STATUS_SUCCESS;
    } else {

        status = STATUS_INVALID_PARAMETER_2;
    }

    return status;
}

NTSTATUS
PipPnPDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    PnP Driver Object.  In this function, we need to remember the DriverObject.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - is NULL.

Return Value:

   STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER( RegistryPath );

    //
    // File the pointer to our driver object away
    //

    IoPnpDriverObject = DriverObject;

    //
    // Fill in the driver object
    //

    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE)IopPnPAddDevice;
    DriverObject->MajorFunction[ IRP_MJ_PNP ] = IopPnPDispatch;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = IopPowerDispatch;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = IopSystemControlDispatch;

    return STATUS_SUCCESS;

}

INTERFACE_TYPE
PipDetermineDefaultInterfaceType (
    VOID
    )

/*++

Routine Description:

    This routine checks if detection flag is set to enable driver detection.
    The detection will be enabled if there is no PCI bus in the machine and only
    on ALPHA machine.

    FUTURE: Comment should make sense.

Parameters:

    None.

Return Value:

    BOOLEAN value to indicate if detection is enabled.

--*/

{
    NTSTATUS status;
    PVOID p;
    PHAL_BUS_INFORMATION pBusInfo;
    ULONG length, i;
    INTERFACE_TYPE interfaceType = Isa;

    pBusInfo = IopPnpScratchBuffer1;
    length = PNP_LARGE_SCRATCH_BUFFER_SIZE;
    status = HalQuerySystemInformation (
                HalInstalledBusInformation,
                length,
                pBusInfo,
                &length
                );

    if (!NT_SUCCESS(status)) {

        return interfaceType;
    }

    //
    // Check installed bus information to make sure there is no existing Pnp Isa
    // bus extender.
    //

    p = pBusInfo;
    for (i = 0; i < length / sizeof(HAL_BUS_INFORMATION); i++, pBusInfo++) {
        if (pBusInfo->BusType == Isa || pBusInfo->BusType == Eisa) {
            interfaceType = Isa;
            break;
        } else if (pBusInfo->BusType == MicroChannel) {
            interfaceType = MicroChannel;
        }
    }

    return interfaceType;
}

BOOLEAN
PipCheckDependencies(
    IN HANDLE KeyHandle
    )

/*++

Routine Description:

    This routine gets the "DependOnGroup" field for the specified key node
    and determines whether any driver in the group(s) that this entry is
    dependent on has successfully loaded.

Arguments:

    KeyHandle - Supplies a handle to the key representing the driver in
        question.

Return Value:

    The function value is TRUE if the driver should be loaded, otherwise
    FALSE

--*/

{
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING groupName;
    BOOLEAN load;
    ULONG length;
    PWSTR source;
    PTREE_ENTRY treeEntry;

    //
    // Attempt to obtain the "DependOnGroup" key for the specified driver
    // entry.  If one does not exist, then simply mark this driver as being
    // one to attempt to load.  If it does exist, then check to see whether
    // or not any driver in the groups that it is dependent on has loaded
    // and allow it to load.
    //

    if (!NT_SUCCESS( IopGetRegistryValue( KeyHandle, L"DependOnGroup", &keyValueInformation ))) {
        return TRUE;
    }

    length = keyValueInformation->DataLength;

    source = (PWSTR) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);
    load = TRUE;

    while (length) {
        RtlInitUnicodeString( &groupName, source );
        groupName.Length = groupName.MaximumLength;
        treeEntry = PipLookupGroupName( &groupName, FALSE );
        if (treeEntry) {
            if (!treeEntry->DriversLoaded) {
                load = FALSE;
                break;
            }
        }
        length -= groupName.MaximumLength;
        source = (PWSTR) ((PUCHAR) source + groupName.MaximumLength);
    }

    ExFreePool( keyValueInformation );
    return load;
}

PTREE_ENTRY
PipCreateEntry(
    IN PUNICODE_STRING GroupName
    )

/*++

Routine Description:

    This routine creates an entry for the specified group name suitable for
    being inserted into the group name tree.

Arguments:

    GroupName - Specifies the name of the group for the entry.

Return Value:

    The function value is a pointer to the created entry.


--*/

{
    PTREE_ENTRY treeEntry;

    //
    // Allocate and initialize an entry suitable for placing into the group
    // name tree.
    //

    treeEntry = ExAllocatePool( PagedPool,
                                sizeof( TREE_ENTRY ) + GroupName->Length );

    //
    // We return NULL here and what this really implies that
    // we won't be able to determine if drivers for this group
    // was loaded.
    //
    if (!treeEntry) {
        return NULL;
    }

    RtlZeroMemory( treeEntry, sizeof( TREE_ENTRY ) );
    treeEntry->GroupName.Length = GroupName->Length;
    treeEntry->GroupName.MaximumLength = GroupName->Length;
    treeEntry->GroupName.Buffer = (PWCHAR) (treeEntry + 1);
    RtlCopyMemory( treeEntry->GroupName.Buffer,
                   GroupName->Buffer,
                   GroupName->Length );

    return treeEntry;
}

VOID
PipFreeGroupTree(
    PTREE_ENTRY TreeEntry
    )

/*++

Routine Description:

    This routine is invoked to free a node from the group dependency tree.
    It is invoked the first time with the root of the tree, and thereafter
    recursively to walk the tree and remove the nodes.

Arguments:

    TreeEntry - Supplies a pointer to the node to be freed.

Return Value:

    None.

--*/

{
    //
    // Simply walk the tree in ascending order from the bottom up and free
    // each node along the way.
    //

    if (TreeEntry->Left) {
        PipFreeGroupTree( TreeEntry->Left );
    }

    if (TreeEntry->Sibling) {
        PipFreeGroupTree( TreeEntry->Sibling );
    }

    if (TreeEntry->Right) {
        PipFreeGroupTree( TreeEntry->Right );
    }

    //
    // All of the children and siblings for this node have been freed, so
    // now free this node as well.
    //

    ExFreePool( TreeEntry );
}

BOOLEAN
IopInitializeBootDrivers(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    OUT PDRIVER_OBJECT *PreviousDriver
    )

/*++

Routine Description:

    This routine is invoked to initialize the boot drivers that were loaded
    by the OS Loader.  The list of drivers is provided as part of the loader
    parameter block.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block, created
        by the OS Loader.

    Previous Driver - Supplies a variable to receive the address of the
        driver object chain created by initializing the drivers.

Return Value:

    The function value is a BOOLEAN indicating whether or not the boot
    drivers were successfully initialized.

--*/

{
    UNICODE_STRING completeName;
    UNICODE_STRING rawFsName;
    NTSTATUS status;
    PLIST_ENTRY nextEntry;
    PBOOT_DRIVER_LIST_ENTRY bootDriver;
    HANDLE keyHandle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PDRIVER_OBJECT driverObject;
    USHORT i, j;
    PKLDR_DATA_TABLE_ENTRY driverEntry;
    PKLDR_DATA_TABLE_ENTRY dllEntry;
    UNICODE_STRING groupName;
    PTREE_ENTRY treeEntry;
    PDRIVER_INFORMATION driverInfo;
    BOOLEAN textModeSetup = FALSE;
    BOOLEAN bootReinitDriversFound;
    ULONG remotebootcount = 0;

    UNREFERENCED_PARAMETER( PreviousDriver );

    //
    // Initialize the built-in RAW file system driver.
    //

    PiWstrToUnicodeString( &rawFsName, L"\\FileSystem\\RAW" );
    PiWstrToUnicodeString( &completeName, L"" );
    IopInitializeBuiltinDriver(&rawFsName,
                               &completeName,
                               RawInitialize,
                               NULL,
                               FALSE,
                               &driverObject);
    if (!driverObject) {
#if DBG
        DbgPrint( "IOINIT: Failed to initialize RAW filsystem \n" );

#endif

        return FALSE;
    }

    //
    // Determine number of group orders and build a list_entry array to link all the drivers
    // together based on their groups.
    //

    IopGroupIndex = PpInitGetGroupOrderIndex(NULL);
    if (IopGroupIndex == NO_MORE_GROUP) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_FIND_GROUPS_FAILED, NULL);
        return FALSE;
    }

    IopGroupTable = (PLIST_ENTRY) ExAllocatePool(PagedPool, IopGroupIndex * sizeof (LIST_ENTRY));
    if (IopGroupTable == NULL) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_OUT_OF_MEMORY, NULL);
        return FALSE;
    }
    for (i = 0; i < IopGroupIndex; i++) {
        InitializeListHead(&IopGroupTable[i]);
    }

    //
    // Call DllInitialize for driver dependent DLLs.
    //

    nextEntry = LoaderBlock->LoadOrderListHead.Flink;
    while (nextEntry != &LoaderBlock->LoadOrderListHead) {
        dllEntry = CONTAINING_RECORD(nextEntry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        if (dllEntry->Flags & LDRP_DRIVER_DEPENDENT_DLL) {
            (VOID)MmCallDllInitialize(dllEntry, &LoaderBlock->LoadOrderListHead);
        }
        nextEntry = nextEntry->Flink;
    }

    //
    // Allocate pool to store driver's start information.
    // All the driver info records with the same group value will be linked into a list.
    //

    nextEntry = LoaderBlock->BootDriverListHead.Flink;
    while (nextEntry != &LoaderBlock->BootDriverListHead) {
        bootDriver = CONTAINING_RECORD( nextEntry,
                                        BOOT_DRIVER_LIST_ENTRY,
                                        Link );
        driverEntry = bootDriver->LdrEntry;
        driverInfo = (PDRIVER_INFORMATION) ExAllocatePool(
                        PagedPool, sizeof(DRIVER_INFORMATION));
        if (driverInfo) {
            RtlZeroMemory(driverInfo, sizeof(DRIVER_INFORMATION));
            InitializeListHead(&driverInfo->Link);
            driverInfo->DataTableEntry = bootDriver;

            //
            // Open the driver's registry key to find out if this is a
            // filesystem or a driver.
            //

            status = IopOpenRegistryKeyEx( &keyHandle,
                                           (HANDLE)NULL,
                                           &bootDriver->RegistryPath,
                                           KEY_READ
                                           );
            if (!NT_SUCCESS( status )) {
                ExFreePool(driverInfo);
            } else {
                driverInfo->ServiceHandle = keyHandle;
                j = PpInitGetGroupOrderIndex(keyHandle);
                if (j == SETUP_RESERVED_GROUP) {

                    textModeSetup = TRUE;

                    //
                    // Special handling for setupdd.sys
                    //

                    status = IopGetDriverNameFromKeyNode( keyHandle,
                                                          &completeName );
                    if (NT_SUCCESS(status)) {

                        driverInfo->Status = IopInitializeBuiltinDriver(
                                           &completeName,
                                           &bootDriver->RegistryPath,
                                           (PDRIVER_INITIALIZE) (ULONG_PTR) driverEntry->EntryPoint,
                                           driverEntry,
                                           FALSE,
                                           &driverObject);
                        ExFreePool( completeName.Buffer );
                        ZwClose(keyHandle);
                        ExFreePool(driverInfo);
                        if (driverObject) {

                            //
                            // Once we successfully initialized the setupdd.sys, we are ready
                            // to notify it all the root enumerated devices.
                            //

                            PipNotifySetupDevices(IopRootDeviceNode);
                        } else {
                            ExFreePool(IopGroupTable);
                            return FALSE;
                        }
                    }

                } else {
                    driverInfo->TagPosition = PipGetDriverTagPriority(keyHandle);
                    PipInsertDriverList(&IopGroupTable[j], driverInfo);
                }
            }
        }
        nextEntry = nextEntry->Flink;
    }

    //
    // Process each driver base on its group.  The group with lower index number (higher
    // priority) is processed first.
    //

    for (i = 0; i < IopGroupIndex; i++) {
        nextEntry = IopGroupTable[i].Flink;
        while (nextEntry != &IopGroupTable[i]) {

            driverInfo = CONTAINING_RECORD(nextEntry, DRIVER_INFORMATION, Link);
            keyHandle = driverInfo->ServiceHandle;
            bootDriver = driverInfo->DataTableEntry;
            driverEntry = bootDriver->LdrEntry;
            driverInfo->Processed = TRUE;

            //
            // call the driver's driver entry
            //
            // See if this driver has an ObjectName value.  If so, this value
            // overrides the default ("\Driver" or "\FileSystem").
            //

            status = IopGetDriverNameFromKeyNode( keyHandle,
                                                  &completeName );
            if (!NT_SUCCESS( status )) {

#if DBG
                DbgPrint( "IOINIT: Could not get driver name for %wZ\n",
                          &bootDriver->RegistryPath );
#endif // DBG

                driverInfo->Failed = TRUE;
            } else {

                status = IopGetRegistryValue( keyHandle,
                                              REGSTR_VALUE_GROUP,
                                              &keyValueInformation );
                if (NT_SUCCESS( status )) {

                    if (keyValueInformation->DataLength) {
                        groupName.Length = (USHORT) keyValueInformation->DataLength;
                        groupName.MaximumLength = groupName.Length;
                        groupName.Buffer = (PWSTR) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);
                        treeEntry = PipLookupGroupName( &groupName, TRUE );
                    } else {
                        treeEntry = (PTREE_ENTRY) NULL;
                    }
                    ExFreePool( keyValueInformation );
                } else {
                    treeEntry = (PTREE_ENTRY) NULL;
                }

                driverObject = NULL;
                if (PipCheckDependencies( keyHandle )) {
                    //
                    // The driver may already be initialized by IopInitializeBootFilterDriver
                    // if it is boot filter driver.
                    // If not, initialize it.
                    //

                    driverObject = driverInfo->DriverObject;
                    if (driverObject == NULL && !driverInfo->Failed) {

                        driverInfo->Status = IopInitializeBuiltinDriver(
                                           &completeName,
                                           &bootDriver->RegistryPath,
                                           (PDRIVER_INITIALIZE) (ULONG_PTR) driverEntry->EntryPoint,
                                           driverEntry,
                                           FALSE,
                                           &driverObject);
                        //
                        // Pnp might unload the driver before we get a chance to look at this. So take an extra
                        // reference.
                        //
                        if (driverObject) {
                            ObReferenceObject(driverObject);

                            //
                            // If we load the driver because we think it is a legacy driver and
                            // it does not create any device object in its DriverEntry.  We will
                            // unload this driver.
                            //

                            if (!IopIsLegacyDriver(driverObject)) {
                                if (driverObject->DeviceObject == NULL     &&
                                    driverObject->DriverExtension->ServiceKeyName.Buffer &&
                                    !IopIsAnyDeviceInstanceEnabled(&driverObject->DriverExtension->ServiceKeyName, NULL, FALSE)) {
                                    if (textModeSetup && !(driverObject->Flags & DRVO_REINIT_REGISTERED)) {

                                        //
                                        // Clean up but leave driver object.  Because it may be needed later.
                                        // After boot driver phase completes, we will process all the driver objects
                                        // which still have no device to control.
                                        //

                                        IopDriverLoadingFailed(NULL, &driverObject->DriverExtension->ServiceKeyName);
                                    }
                                } else {

                                    //
                                    // Start the devices controlled by the driver and enumerate them
                                    // At this point, we know there is at least one device controlled by the driver.
                                    //

                                    IopDeleteLegacyKey(driverObject);
                                }
                            }
                        }
                    }
                }
                if (driverObject) {
                    if (treeEntry) {
                        treeEntry->DriversLoaded++;
                    }
                    driverInfo->DriverObject = driverObject;

                } else {
                    driverInfo->Failed = TRUE;
                }
                ExFreePool( completeName.Buffer );
            }
            if (!driverInfo->Failed) {

                PipAddDevicesToBootDriver(driverObject);

                //
                // Scan the hardware tree looking for devices which need
                // resources or starting.
                //

                PipRequestDeviceAction( NULL,
                                        ReenumerateBootDevices,
                                        FALSE,
                                        0,
                                        NULL,
                                        NULL);

            }

            //
            // Before processing next boot driver, wait for IoRequestDeviceRemoval complete.
            // The driver to be processed may need the resources being released by
            // IoRequestDeviceRemoval.  (For drivers report detected BOOT device if they fail to
            // get the resources in their DriverEntry.  They will fail and we will bugcheck with
            // inaccessible boot device.)
            //

            if (!PipWaitForBootDevicesDeleted()) {
                HeadlessKernelAddLogEntry(HEADLESS_LOG_WAIT_BOOT_DEVICES_DELETE_FAILED, NULL);
                return FALSE;
            }

            nextEntry = nextEntry->Flink;
        }

        //
        // If we are done with Bus driver group, then it's time to reserved the Hal resources
        // and reserve boot resources
        //

        if (i == BUS_DRIVER_GROUP) {

            //
            // Reserve BOOT configs on Internal bus 0.
            //

            IopAllocateLegacyBootResources(Internal, 0);
            IopAllocateBootResourcesRoutine = IopAllocateBootResources;
            ASSERT(IopInitHalResources == NULL);
            ASSERT(IopInitReservedResourceList == NULL);
            IopBootConfigsReserved = TRUE;

        }
    }

    //
    // If we started a network boot driver, then imitate what DHCP does
    // in sending IOCTLs.
    //

    if (IoRemoteBootClient) {
        //
        // try a hack since TCPIP may not be initialized.  (There is no
        // guarantee that if a device is initialized that the protocols are
        // finished binding.)  So if the call fails, we just sleep for a bit
        // and try again until it works or we fall out of this loop.
        //
        remotebootcount = 0;
        status = IopStartTcpIpForRemoteBoot(LoaderBlock);
        while ( status == STATUS_DEVICE_DOES_NOT_EXIST && remotebootcount < 20) {

            LARGE_INTEGER Delay;

            //
            // sleep for a second and try again. (-1s in 10ns units)
            //
            Delay.LowPart  = 0xff676980 ;
            Delay.HighPart = 0xffffffff ;

            ZwDelayExecution( FALSE, &Delay );

            remotebootcount += 1;
            status = IopStartTcpIpForRemoteBoot(LoaderBlock);
        }

        if (!NT_SUCCESS(status)) {
            KeBugCheckEx( NETWORK_BOOT_INITIALIZATION_FAILED,
                          3,
                          status,
                          0,
                          0 );
        }
    }

    //
    // Scan the hardware tree looking for devices which need
    // resources or starting.
    //
    PnPBootDriversLoaded = TRUE;

    PipRequestDeviceAction(NULL, AssignResources, FALSE, 0, NULL, NULL);

    //
    // If start irps are handled asynchronously, we need to make sure all the boot devices
    // started before continue.
    //

    if (!PipWaitForBootDevicesStarted()) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_WAIT_BOOT_DEVICES_START_FAILED, NULL);
        return FALSE;
    }

    bootReinitDriversFound = IopCallBootDriverReinitializationRoutines();

    //
    // If there were any drivers that registered for boot reinitialization, then
    // we need to wait one more time to make sure we catch any additional
    // devices that were created in response to the reinitialization callback.
    //

    if (bootReinitDriversFound && !PipWaitForBootDevicesStarted()) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_WAIT_BOOT_DEVICES_REINIT_FAILED, NULL);
        return FALSE;
    }

    //
    // Link NT device names to ARC names now that all of the boot drivers
    // have intialized.
    //

    IopCreateArcNames( LoaderBlock );

    //
    // If we're booting from a RAM disk, initialize it now.
    //

    if ( _memicmp( LoaderBlock->ArcBootDeviceName, "ramdisk(0)", 10 ) == 0 ) {

        status = IopStartRamdisk(LoaderBlock);

        // IopStartRamdisk will bugcheck on any failure.
        ASSERT( NT_SUCCESS(status) );

        if (!PipWaitForBootDevicesStarted()) {
            HeadlessKernelAddLogEntry(HEADLESS_LOG_WAIT_BOOT_DEVICES_START_FAILED, NULL);
            return FALSE;
        }
    }

    //
    // Find and mark the boot partition device object so that if a subsequent
    // access or mount of the device during initialization occurs, an more
    // bugcheck can be produced that helps the user understand why the system
    // is failing to boot and run properly.  This occurs when either one of the
    // device drivers or the file system fails to load, or when the file system
    // cannot mount the device for some other reason.
    //

    if (!IopMarkBootPartition( LoaderBlock )) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_MARK_BOOT_PARTITION_FAILED, NULL);
        return FALSE;
    }

    PnPBootDriversInitialized = TRUE;

    //
    // Go thru every driver that we initialized. If it supports AddDevice yet
    // did not create any device objects after we started it, we should unload
    // it (this is the counterpart to the code in pnpenum that unloads
    // unneccessary filters *after* the paging stack is online).
    //
    // We also mark it as failure so text mode setup knows this driver is not
    // actually needed.
    //

    for (i = 0; i < IopGroupIndex; i++) {
        while (IsListEmpty(&IopGroupTable[i]) == FALSE) {


            nextEntry = RemoveHeadList(&IopGroupTable[i]);
            driverInfo = CONTAINING_RECORD(nextEntry, DRIVER_INFORMATION, Link);
            driverObject = driverInfo->DriverObject;

            if (textModeSetup                    &&
                (driverInfo->Failed == FALSE)    &&
                !IopIsLegacyDriver(driverObject) &&
                (driverObject->DeviceObject == NULL) &&
                !(driverObject->Flags & DRVO_REINIT_REGISTERED)) {

                //
                // If failed is not set and it's not a legacy driver and it has no device object
                // tread it as failure case.
                //

                driverInfo->Failed = TRUE;

                if (!(driverObject->Flags & DRVO_UNLOAD_INVOKED)) {
                    driverObject->Flags |= DRVO_UNLOAD_INVOKED;
                    if (driverObject->DriverUnload) {
                        driverObject->DriverUnload(driverObject);
                    }
                    ObMakeTemporaryObject( driverObject );  // Reference taken while inserting into the object table.
                    ObDereferenceObject(driverObject);      // Reference taken when getting driver object pointer.
                }
            }
            if (driverObject) {
                ObDereferenceObject(driverObject);          // Reference taken specifically for text mode setup.
            }

            if (driverInfo->Failed) {
                driverInfo->DataTableEntry->LdrEntry->Flags |= LDRP_FAILED_BUILTIN_LOAD;
            }
            ZwClose(driverInfo->ServiceHandle);
            ExFreePool(driverInfo);
        }
    }

    ExFreePool(IopGroupTable);

    //
    // Initialize the drivers necessary to dump all of physical memory to the
    // disk if the system is configured to do so.
    //


    return TRUE;
}

NTSTATUS
PipAddDevicesToBootDriver(
   IN PDRIVER_OBJECT DriverObject
   )

/*++

Routine Description:

    This functions is used by Pnp manager to inform a boot device driver of
    all the devices it can possibly control.  This routine is for boot
    drivers only.

Parameters:

    DriverObject - Supplies a driver object to receive its boot devices.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status;


    //
    // For each device instance in the driver's service/enum key, we will
    // invoke the driver's AddDevice routine and perform enumeration on
    // the device.
    // Note, we don't acquire registry lock before calling IopApplyFunction
    // routine.  We know this code is for boot driver initialization.  No
    // one else would access the registry Enum key at this time and most
    // important we need the registry lock in other down level routines.
    //

    status = PipApplyFunctionToServiceInstances(
                                NULL,
                                &DriverObject->DriverExtension->ServiceKeyName,
                                KEY_ALL_ACCESS,
                                TRUE,
                                PipAddDevicesToBootDriverWorker,
                                DriverObject,
                                NULL
                                );

    return status;
}

BOOLEAN
PipAddDevicesToBootDriverWorker(
    IN HANDLE DeviceInstanceHandle,
    IN PUNICODE_STRING DeviceInstancePath,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is a callback function for PipApplyFunctionToServiceInstances.
    It is called for each device instance key referenced by a service instance
    value under the specified service's volatile Enum subkey. The purpose of this
    routine is to invoke the AddDevice() entry of a boot driver with the device
    object.

    Note this routine is also used for the devices controlled by a legacy driver.
    If the specified device instance is controlled by a legacy driver this routine
    sets the device node flags.

Arguments:

    DeviceInstanceHandle - Supplies a handle to the registry path (relative to
        HKLM\CCS\System\Enum) to this device instance.

    DeviceInstancePath - Supplies the registry path (relative to HKLM\CCS\System\Enum)
        to this device instance.

    Context - Supplies a pointer to a DRIVER_OBJECT structure.

Return Value:

    TRUE to continue the enumeration.
    FALSE to abort it.

--*/

{
//  PDRIVER_OBJECT driverObject = (PDRIVER_OBJECT)Context;
    PDEVICE_OBJECT physicalDevice;

    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( DeviceInstanceHandle );

    //
    // Reference the physical device object associated with the device instance.
    //

    physicalDevice = IopDeviceObjectFromDeviceInstance(DeviceInstancePath);
    if (!physicalDevice) {
        return TRUE;
    }

    PipRequestDeviceAction( physicalDevice, AddBootDevices, FALSE, 0, NULL, NULL );

    ObDereferenceObject(physicalDevice);
    return TRUE;
}

BOOLEAN
IopInitializeSystemDrivers(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to load and initialize all of the drivers that
    are supposed to be loaded during Phase 1 initialization of the I/O
    system.  This is accomplished by calling the Configuration Manager to
    get a NULL-terminated array of handles to the open keys for each driver
    that is to be loaded, and then loading and initializing the driver.

Arguments:

    None.

Return Value:

    The function value is a BOOLEAN indicating whether or not the drivers
    were successfully loaded and initialized.

--*/

{
    NTSTATUS status, driverEntryStatus;
    PHANDLE driverList;
    PHANDLE savedList;
    HANDLE enumHandle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING groupName, enumName;
    PTREE_ENTRY treeEntry;
    UNICODE_STRING driverName;
    PDRIVER_OBJECT driverObject;
    KEVENT completionEvent;

//    PpReleaseBootDDB();

    KeInitializeEvent( &completionEvent, NotificationEvent, FALSE );

    status = PipRequestDeviceAction( IopRootDeviceNode->PhysicalDeviceObject,
                                     StartSystemDevices,
                                     FALSE,
                                     0,
                                     &completionEvent,
                                     NULL);

    if (NT_SUCCESS(status)) {

        status = KeWaitForSingleObject( &completionEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);
    }

    //
    // Walk thru the service list to load the remaining system start drivers.
    // (Most likely these drivers are software drivers.)
    //

    //
    // Get the list of drivers that are to be loaded during this phase of
    // system initialization, and invoke each driver in turn.  Ensure that
    // the list really exists, otherwise get out now.
    //

    driverList = CmGetSystemDriverList();

    if (driverList != NULL) {

        //
        // Walk the entire list, loading each of the drivers if not already loaded,
        // until there are no more drivers in the list.
        //

        for (savedList = driverList; *driverList; driverList++) {

            //
            // Now check if the driver has been loaded already.
            // get the name of the driver object first ...
            //

            status = IopGetDriverNameFromKeyNode( *driverList,
                                                  &driverName );
            if (NT_SUCCESS( status )) {

                driverObject = IopReferenceDriverObjectByName(&driverName);
                RtlFreeUnicodeString(&driverName);
                if (driverObject) {

                    //
                    // Driver was loaded already.  Dereference the driver object
                    // and skip it.
                    //

                    ObDereferenceObject(driverObject);
                    ZwClose(*driverList);
                    continue;
                }
            }

            //
            // Open registry ServiceKeyName\Enum branch to check if the driver was
            // loaded before but failed.
            //

            PiWstrToUnicodeString(&enumName, REGSTR_KEY_ENUM);
            status = IopOpenRegistryKeyEx( &enumHandle,
                                           *driverList,
                                           &enumName,
                                           KEY_READ
                                           );

            if (NT_SUCCESS( status )) {

                ULONG startFailed = 0;

                status = IopGetRegistryValue(enumHandle, L"INITSTARTFAILED", &keyValueInformation);

                if (NT_SUCCESS( status )) {
                    if (keyValueInformation->DataLength == sizeof(ULONG)) {
                        startFailed = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                    }
                    ExFreePool( keyValueInformation );
                }
                ZwClose(enumHandle);
                if (startFailed != 0) {
                    ZwClose(*driverList);
                    continue;
                }
            }

            //
            // The driver is not loaded yet.  Load it ...
            //

            status = IopGetRegistryValue( *driverList,
                                          REGSTR_VALUE_GROUP,
                                          &keyValueInformation );
            if (NT_SUCCESS( status )) {
                if (keyValueInformation->DataLength) {
                    groupName.Length = (USHORT) keyValueInformation->DataLength;
                    groupName.MaximumLength = groupName.Length;
                    groupName.Buffer = (PWSTR) ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);
                    treeEntry = PipLookupGroupName( &groupName, TRUE );
                } else {
                    treeEntry = (PTREE_ENTRY) NULL;
                }
                ExFreePool( keyValueInformation );
            } else {
                treeEntry = (PTREE_ENTRY) NULL;
            }

            if (PipCheckDependencies( *driverList )) {
                if (NT_SUCCESS( IopLoadDriver( *driverList, TRUE, FALSE, &driverEntryStatus ) )) {
                    if (treeEntry) {
                        treeEntry->DriversLoaded++;
                    }
                }
            } else {
                ZwClose(*driverList);
            }

            //
            // The boot process takes a while loading drivers.   Indicate that
            // progress is being made.
            //

            InbvIndicateProgress();

        }

        //
        // Finally, free the pool that was allocated for the list and return
        // an indicator the load operation worked.
        //

        ExFreePool( (PVOID) savedList );
    }

    PipRequestDeviceAction( IopRootDeviceNode->PhysicalDeviceObject,
                            StartSystemDevices,
                            FALSE,
                            0,
                            NULL,
                            NULL);

    //
    // Mark pnp has completed the driver loading for both system and
    // autoload drivers.
    //
    PnPInitialized = TRUE;

    //
    // We don't need the group order list anymore. Release the cached data
    // associated with it.
    //
    PiInitReleaseCachedGroupInformation();

    //
    // Release the Boot Driver Database information.
    //
    PpReleaseBootDDB();

    //
    // Free the memory allocated to contain the group dependency list.
    //
    if (IopGroupListHead) {
        PipFreeGroupTree( IopGroupListHead );
    }

    return TRUE;
}

PTREE_ENTRY
PipLookupGroupName(
    IN PUNICODE_STRING GroupName,
    IN BOOLEAN Insert
    )

/*++

Routine Description:

    This routine looks up a group entry in the group load tree and either
    returns a pointer to it, or optionally creates the entry and inserts
    it into the tree.

Arguments:

    GroupName - The name of the group to look up, or insert.

    Insert - Indicates whether or not an entry is to be created and inserted
        into the tree if the name does not already exist.

Return Value:

    The function value is a pointer to the entry for the specified group
    name, or NULL.

--*/

{
    PTREE_ENTRY treeEntry;
    PTREE_ENTRY previousEntry;

    //
    // Begin by determining whether or not there are any entries in the tree
    // whatsoever.  If not, and it is OK to insert, then insert this entry
    // into the tree.
    //

    if (!IopGroupListHead) {
        if (!Insert) {
            return (PTREE_ENTRY) NULL;
        } else {
            IopGroupListHead = PipCreateEntry( GroupName );
            return IopGroupListHead;
        }
    }

    //
    // The tree is not empty, so actually attempt to do a lookup.
    //

    treeEntry = IopGroupListHead;

    for (;;) {
        if (GroupName->Length < treeEntry->GroupName.Length) {
            if (treeEntry->Left) {
                treeEntry = treeEntry->Left;
            } else {
                if (!Insert) {
                    return (PTREE_ENTRY) NULL;
                } else {
                    treeEntry->Left = PipCreateEntry( GroupName );
                    return treeEntry->Left;
                }

            }
        } else if (GroupName->Length > treeEntry->GroupName.Length) {
            if (treeEntry->Right) {
                treeEntry = treeEntry->Right;
            } else {
                if (!Insert) {
                    return (PTREE_ENTRY) NULL;
                } else {
                    treeEntry->Right = PipCreateEntry( GroupName );
                    return treeEntry->Right;
                }
            }
        } else {
            if (!RtlEqualUnicodeString( GroupName, &treeEntry->GroupName, TRUE )) {
                previousEntry = treeEntry;
                while (treeEntry->Sibling) {
                    treeEntry = treeEntry->Sibling;
                    if (RtlEqualUnicodeString( GroupName, &treeEntry->GroupName, TRUE )) {
                        return treeEntry;
                    }
                    previousEntry = previousEntry->Sibling;
                }
                if (!Insert) {
                    return (PTREE_ENTRY) NULL;
                } else {
                    previousEntry->Sibling = PipCreateEntry( GroupName );
                    return previousEntry->Sibling;
                }
            } else {
                return treeEntry;
            }
        }
    }
}

USHORT
PipGetDriverTagPriority (
    IN HANDLE ServiceHandle
    )

/*++

Routine Description:

    This routine reads the Tag value of a driver and determine the tag's priority
    among its driver group.

Arguments:

    ServiceHandle - specifies the handle of the driver's service key.

Return Value:

    USHORT for priority.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformationGroup;
    PKEY_VALUE_FULL_INFORMATION keyValueInformationTag;
    PKEY_VALUE_FULL_INFORMATION keyValueInformationGroupOrderList;
    UNICODE_STRING groupName;
    HANDLE handle;
    USHORT index = (USHORT) -1;
    PULONG groupOrder;
    ULONG count, tag;

    //
    // Open System\CurrentControlSet\Control\GroupOrderList
    //

    PiWstrToUnicodeString(&groupName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\GroupOrderList");
    status = IopOpenRegistryKeyEx( &handle,
                                   NULL,
                                   &groupName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS( status )) {
        return index;
    }

    //
    // Read service key's Group value
    //

    status = IopGetRegistryValue (ServiceHandle,
                                  REGSTR_VALUE_GROUP,
                                  &keyValueInformationGroup);
    if (NT_SUCCESS(status)) {

        //
        // Try to read what caller wants.
        //

        if ((keyValueInformationGroup->Type == REG_SZ) &&
            (keyValueInformationGroup->DataLength != 0)) {
            IopRegistryDataToUnicodeString(&groupName,
                                           (PWSTR)KEY_VALUE_DATA(keyValueInformationGroup),
                                           keyValueInformationGroup->DataLength
                                           );
        }
    } else {

        //
        // If we failed to read the Group value, or no Group value...
        //

        ZwClose(handle);
        return index;
    }

    //
    // Read service key's Tag value
    //

    tag = 0;
    status = IopGetRegistryValue (ServiceHandle,
                                  L"Tag",
                                  &keyValueInformationTag);
    if (NT_SUCCESS(status)) {

        //
        // Try to read what caller wants.
        //

        if ((keyValueInformationTag->Type == REG_DWORD) &&
            (keyValueInformationTag->DataLength == sizeof(ULONG))) {
            tag = *(PULONG)KEY_VALUE_DATA(keyValueInformationTag);
        } else {
            status = STATUS_UNSUCCESSFUL;
        }

        ExFreePool(keyValueInformationTag);
    }

    if (!NT_SUCCESS(status))  {

        //
        // If we failed to read the Group value, or no Group value...
        //

        ExFreePool(keyValueInformationGroup);
        ZwClose(handle);
        return index;
    }

    //
    // Read group order list value for the driver's Group
    //

    status = IopGetRegistryValue (handle,
                                  groupName.Buffer,
                                  &keyValueInformationGroupOrderList);
    ExFreePool(keyValueInformationGroup);
    ZwClose(handle);
    if (NT_SUCCESS(status)) {

        //
        // Try to read what caller wants.
        //

        if ((keyValueInformationGroupOrderList->Type == REG_BINARY) &&
            (keyValueInformationGroupOrderList->DataLength >= sizeof(ULONG))) {
            groupOrder = (PULONG)KEY_VALUE_DATA(keyValueInformationGroupOrderList);
            count = *groupOrder;

            ASSERT((count + 1) * sizeof(ULONG) <= keyValueInformationGroupOrderList->DataLength);

            if ((count + 1) * sizeof(ULONG) <= keyValueInformationGroupOrderList->DataLength) {

                groupOrder++;
                for (index = 1; index <= count; index++) {
                    if (tag == *groupOrder) {
                        break;
                    } else {
                        groupOrder++;
                    }
                }
            }
        }
        ExFreePool(keyValueInformationGroupOrderList);
    } else {

        //
        // If we failed to read the Group value, or no Group value...
        //

        return index;
    }
    return index;
}

VOID
PipInsertDriverList (
    IN PLIST_ENTRY ListHead,
    IN PDRIVER_INFORMATION DriverInfo
    )

/*++

Routine Description:

    This routine reads the Tag value of a driver and determine the tag's priority
    among its driver group.

Arguments:

    ServiceHandle - specifies the handle of the driver's service key.

Return Value:

    USHORT for priority.

--*/

{
    PLIST_ENTRY nextEntry;
    PDRIVER_INFORMATION info;

    nextEntry = ListHead->Flink;
    while (nextEntry != ListHead) {
        info = CONTAINING_RECORD(nextEntry, DRIVER_INFORMATION, Link);

        //
        // Scan the driver info list to find the driver whose priority is
        // lower than current driver's.
        // (Lower TagPosition value means higher Priority)
        //

        if (info->TagPosition > DriverInfo->TagPosition) {
            break;
        }
        nextEntry = nextEntry->Flink;
    }

    //
    // Insert the Driver info to the front of the nextEntry
    //

    nextEntry = nextEntry->Blink;
    InsertHeadList(nextEntry, &DriverInfo->Link);
}

VOID
PipNotifySetupDevices (
    PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine notifies setupdd.sys for all the enumerated devices whose
    service have not been setup.

    This routine only gets executed on textmode setup phase.

Parameters:

    DeviceNode - specifies the root of the subtree to be processed.

Return Value:

    None.

--*/

{
    PDEVICE_NODE deviceNode = DeviceNode->Child;
    PDEVICE_OBJECT deviceObject;
    HANDLE handle;
    UNICODE_STRING unicodeString;
    NTSTATUS status;

    while (deviceNode) {
        PipNotifySetupDevices(deviceNode);
        if (deviceNode->ServiceName.Length == 0) {

            //
            // We only notify setupdd the device nodes which do not have service setup yet.
            // It is impossible that at this point, a device has a service setup and
            // setupdd has to change it.
            //

            deviceObject = deviceNode->PhysicalDeviceObject;
            status = IopDeviceObjectToDeviceInstance(deviceObject, &handle, KEY_ALL_ACCESS);
            if (NT_SUCCESS(status)) {

                //
                // Notify setup about the device.
                //

                IopNotifySetupDeviceArrival(deviceObject, handle, TRUE);

                //
                // Finally register the device
                //

                status = PpDeviceRegistration(
                             &deviceNode->InstancePath,
                             TRUE,
                             &unicodeString       // registered ServiceName
                             );

                if (NT_SUCCESS(status)) {
                    deviceNode->ServiceName = unicodeString;
                    if (PipIsDevNodeProblem(deviceNode, CM_PROB_NOT_CONFIGURED)) {
                        PipClearDevNodeProblem(deviceNode);
                    }
                }
                ZwClose(handle);
            }
        }
        deviceNode = deviceNode->Sibling;
    }
}

BOOLEAN
PipWaitForBootDevicesStarted (
    IN VOID
    )

/*++

Routine Description:

    This routine waits for enumeration lock to be released for ALL devices.

Arguments:

    None.

Return Value:

    BOOLEAN.

--*/

{
    NTSTATUS status;

    //
    // Wait on IoInvalidateDeviceRelations event to make sure all the devcies are enumerated
    // before progressing to mark boot partitions.
    //

    status = KeWaitForSingleObject( &PiEnumerationLock,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL );
    if (!NT_SUCCESS(status)) {

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
PipWaitForBootDevicesDeleted (
    IN VOID
    )

/*++

Routine Description:

    This routine waits for IoRequestDeviceRemoval to be completed.

Arguments:

    None.

Return Value:

    BOOLEAN.

--*/

{
    NTSTATUS status;

    //
    // Wait on device removal event to make sure all the deleted devcies are processed
    // before moving on to process next boot driver.
    //

    status = KeWaitForSingleObject( &PiEventQueueEmpty,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL );
    return (BOOLEAN)NT_SUCCESS(status);
}

NTSTATUS
PipLoadBootFilterDriver (
    IN PUNICODE_STRING DriverName,
    IN ULONG GroupIndex,
    OUT PDRIVER_OBJECT *LoadedFilter
    )

/*++

Routine Description:

    This initializes boot filter drivers.

Arguments:

    DriverName - specifies the name of the driver to be initialized.

    GroupIndex - specifies the Driver's group index (could be anything)

Return Value:

    PDRIVER_OBJECT

--*/

{
    PDRIVER_OBJECT driverObject;
    PLIST_ENTRY nextEntry;
    PDRIVER_INFORMATION driverInfo;
    UNICODE_STRING completeName;
    PBOOT_DRIVER_LIST_ENTRY bootDriver;
    PKLDR_DATA_TABLE_ENTRY driverEntry;
    HANDLE keyHandle;
    NTSTATUS status, retStatus;

    retStatus = STATUS_UNSUCCESSFUL;
    *LoadedFilter = NULL;
    if (IopGroupTable == NULL || GroupIndex >= IopGroupIndex) {

        //
        // If we have not reached the boot driver initialization phase or
        // the filter driver is not a boot driver.
        //

        return retStatus;
    }

    //
    // Go thru every driver that we initialized.  If it supports AddDevice entry and
    // did not create any device object after we start it.  We mark it as failure so
    // text mode setup knows this driver is not needed.
    //

    nextEntry = IopGroupTable[GroupIndex].Flink;
    while (nextEntry != &IopGroupTable[GroupIndex]) {

        driverInfo = CONTAINING_RECORD(nextEntry, DRIVER_INFORMATION, Link);
        keyHandle = driverInfo->ServiceHandle;
        status = IopGetDriverNameFromKeyNode(
            keyHandle,
            &completeName);
        if (NT_SUCCESS(status)) {

            if (RtlEqualUnicodeString(DriverName,
                                      &completeName,
                                      TRUE)) {    // case-insensitive
                if (driverInfo->Processed == FALSE) {

                    bootDriver = driverInfo->DataTableEntry;
                    driverEntry = bootDriver->LdrEntry;

                    driverInfo->Status = IopInitializeBuiltinDriver(
                                       &completeName,
                                       &bootDriver->RegistryPath,
                                       (PDRIVER_INITIALIZE) (ULONG_PTR) driverEntry->EntryPoint,
                                       driverEntry,
                                       TRUE,
                                       &driverObject);
                    retStatus = driverInfo->Status;
                    driverInfo->DriverObject = driverObject;
                    driverInfo->Processed = TRUE;
                    //
                    // Pnp might unload the driver before we get a chance to
                    // look at this. So take an extra reference.
                    //
                    if (driverObject) {

                        ObReferenceObject(driverObject);
                        *LoadedFilter = driverObject;
                    } else {

                        driverInfo->Failed = TRUE;
                    }
                } else {

                    retStatus = driverInfo->Status;
                }

                ExFreePool(completeName.Buffer);
                break;
            }
            ExFreePool(completeName.Buffer);
        }
        nextEntry = nextEntry->Flink;
    }

    return retStatus;
}

VOID
IopMarkHalDeviceNode(
    VOID
    )
{
    PDEVICE_NODE deviceNode;

    deviceNode = IopRootDeviceNode->Child;

    while (deviceNode) {

        if ((deviceNode->State == DeviceNodeStarted ||
             deviceNode->State == DeviceNodeStartPostWork ) &&
            !(deviceNode->Flags & DNF_LEGACY_DRIVER)) {

            IopInitHalDeviceNode = deviceNode;
            deviceNode->Flags |= DNF_HAL_NODE;
            break;
        }

        deviceNode = deviceNode->Sibling;
    }
}

NTSTATUS
IopPnpDriverStarted(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ServiceName
    )
{
    NTSTATUS    status = STATUS_SUCCESS;

    if (DriverObject->DeviceObject == NULL && ServiceName->Buffer &&
        !IopIsAnyDeviceInstanceEnabled(ServiceName, NULL, FALSE) &&
        !(DriverObject->Flags & DRVO_REINIT_REGISTERED)) {

        IopDriverLoadingFailed(KeyHandle, NULL);
        status = STATUS_PLUGPLAY_NO_DEVICE;

    } else {

        //
        // Start the devices controlled by the driver and enumerate them
        // At this point, we know there is at least one device controlled by the driver.
        //

        IopDeleteLegacyKey(DriverObject);
    }

    return status;
}

NTSTATUS
PiInitCacheGroupInformation(
    VOID
    )
/*++

Routine Description:

    This routine caches the service group order list. We only need this list
    while we are processing boot start and system start legacy drivers.

Parameters:

    None.

Return Value:

    NTSTATUS.

--*/
{
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING *groupTable, group;
    NTSTATUS status;
    HANDLE handle;
    ULONG count = 0;

    //
    // Open System\CurrentControlSet\Control\ServiceOrderList
    //
    PiWstrToUnicodeString(
        &group,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ServiceGroupOrder"
        );

    status = IopOpenRegistryKeyEx(
        &handle,
        NULL,
        &group,
        KEY_READ
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Read and build a unicode string array containing all the group names.
    //
    status = IopGetRegistryValue(
        handle,
        L"List",
        &keyValueInformation
        );

    ZwClose(handle);

    groupTable = NULL;
    if (NT_SUCCESS(status)) {

        if ((keyValueInformation->Type == REG_MULTI_SZ) &&
            (keyValueInformation->DataLength != 0)) {

            status = PipRegMultiSzToUnicodeStrings(keyValueInformation, &groupTable, &count);
        } else {
            status = STATUS_UNSUCCESSFUL;
        }
        ExFreePool(keyValueInformation);
    }

    if (!NT_SUCCESS(status)) {

        return status;
    }

    PiInitGroupOrderTable = groupTable;
    PiInitGroupOrderTableCount = (USHORT) count;
    return STATUS_SUCCESS;
}

VOID
PiInitReleaseCachedGroupInformation(
    VOID
    )
/*++

Routine Description:

    This routine releases the service group order list cache. It should be
    called just after the system start legacy drivers have been loaded.

Parameters:

    None.

Return Value:

    None.

--*/
{
    ASSERT(PnPInitialized);

    if (PiInitGroupOrderTable) {

        PipFreeUnicodeStringList(
            PiInitGroupOrderTable,
            PiInitGroupOrderTableCount
            );

        PiInitGroupOrderTable = NULL;
        PiInitGroupOrderTableCount = 0;
    }
}

USHORT
PpInitGetGroupOrderIndex(
    IN HANDLE ServiceHandle
    )
/*++

Routine Description:

    This routine reads the Group value of the service key, finds its position
    in the ServiceOrderList. If ServiceHandle is NULL or unrecognized group
    value, it returns a value with max group order + 1.

Parameters:

    ServiceHandle - supplies a handle to the service key.

Return Value:

    group order index.

--*/
{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING group;
    USHORT index;

    PAGED_CODE();

    ASSERT(!PnPInitialized);

    if (PiInitGroupOrderTable == NULL) {

        return NO_MORE_GROUP;
    }

    if (ServiceHandle == NULL) {

        return PiInitGroupOrderTableCount + 1;
    }

    //
    // Read service key's Group value
    //
    status = IopGetRegistryValue(
        ServiceHandle,
        REGSTR_VALUE_GROUP,
        &keyValueInformation
        );

    if (!NT_SUCCESS(status)) {

        //
        // If we failed to read the Group value, or no Group value...
        //
        return PiInitGroupOrderTableCount;
    }

    //
    // Verify type information
    //
    if ((keyValueInformation->Type != REG_SZ) ||
        (keyValueInformation->DataLength == 0)) {

        ASSERT(0);
        ExFreePool(keyValueInformation);
        return PiInitGroupOrderTableCount;
    }

    IopRegistryDataToUnicodeString(
        &group,
        (PWSTR)KEY_VALUE_DATA(keyValueInformation),
        keyValueInformation->DataLength
        );

    for (index = 0; index < PiInitGroupOrderTableCount; index++) {

        if (RtlEqualUnicodeString(&group, &PiInitGroupOrderTable[index], TRUE)) {

            break;
        }
    }

    ExFreePool(keyValueInformation);

    return index;
}

BOOLEAN
PpInitSystem (
    VOID
    )

/*++

Routine Description:

    This function performs initialization of the kernel-mode Plug and Play
    Manager.  It is called during phase 0 and phase 1 initialization.  Its
    function is to dispatch to the appropriate phase initialization routine.

Arguments:

    None.

Return Value:

    TRUE  - Initialization succeeded.

    FALSE - Initialization failed.

--*/

{

    switch ( InitializationPhase ) {

    case 0 :
        return PiInitPhase0();

    case 1 :
        return PiInitPhase1();

    default:
        KeBugCheckEx(UNEXPECTED_INITIALIZATION_CALL, 2, InitializationPhase, 0, 0);
    }
}

BOOLEAN
PiInitPhase0(
    VOID
    )

/*++

Routine Description:

    This function performs Phase 0 initializaion of the Plug and Play Manager
    component of the NT system. It initializes the PnP registry and bus list
    resources, and initializes the bus list head to empty.

Arguments:

    None.

Return Value:

    TRUE  - Initialization succeeded.

    FALSE - Initialization failed.

--*/

{
    //
    // Initialize the device-specific, Plug and Play registry resource.
    //
    ExInitializeResourceLite( &PpRegistryDeviceResource );

    PpInitializeDeviceReferenceTable();

    return TRUE;
}

BOOLEAN
PiInitPhase1(
    VOID
    )

/*++

Routine Description:

    This function performs Phase 0 initializaion of the Plug and Play Manager
    component of the NT system. It initializes the PnP registry and bus list
    resources, and initializes the bus list head to empty.

Arguments:

    None.

Return Value:

    TRUE  - Initialization succeeded.

    FALSE - Initialization failed.

--*/

{
    NTSTATUS status;
    HANDLE hCurrentControlSet, handle;
    UNICODE_STRING unicodeName;
    PKEY_VALUE_FULL_INFORMATION detectionInfo;

    status = IopOpenRegistryKeyEx( &hCurrentControlSet,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSet,
                                   KEY_ALL_ACCESS
                                   );
    if (NT_SUCCESS(status)) {

        PiWstrToUnicodeString(&unicodeName, REGSTR_PATH_CONTROL_PNP);
        status = IopCreateRegistryKeyEx( &handle,
                                         hCurrentControlSet,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL);
        if (NT_SUCCESS(status)) {
            //
            // Check the "DisableFirmwareMapper" value entry to see whether we
            // should skip mapping ntdetect/firmware reported devices (except for
            // COM ports, which we always map).
            //
            status = IopGetRegistryValue(handle,
                                         REGSTR_VALUE_DISABLE_FIRMWARE_MAPPER,
                                         &detectionInfo);
            if (NT_SUCCESS(status)) {

                if (detectionInfo->Type == REG_DWORD && detectionInfo->DataLength == sizeof(ULONG)) {

                    PpDisableFirmwareMapper = (BOOLEAN)*(KEY_VALUE_DATA(detectionInfo));
                }
                ExFreePool(detectionInfo);
            }
            ZwClose(handle);
        }
        ZwClose(hCurrentControlSet);
    }

#if defined(_X86_)

    if (!PpDisableFirmwareMapper) {

        PnPBiosInitializePnPBios();
    }

#endif

    return TRUE;
}

NTSTATUS
IopStartRamdisk(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    ULONG code;
    NTSTATUS status;
    WCHAR buffer[ RAMDISK_MAX_DEVICE_NAME ];
    UNICODE_STRING guidString;
    PLIST_ENTRY listEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR memoryDescriptor = NULL;
    UNICODE_STRING ustring;
    UNICODE_STRING ustring2;
    UNICODE_STRING string;
    RAMDISK_CREATE_INPUT create;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    HANDLE handle = NULL;
    PCHAR options;

    //
    // Find the descriptor for the memory block into which the loader read the
    // disk image.
    //

    for ( listEntry = LoaderBlock->MemoryDescriptorListHead.Flink;
          listEntry != &LoaderBlock->MemoryDescriptorListHead;
          listEntry = listEntry->Flink ) {

        memoryDescriptor = CONTAINING_RECORD(listEntry,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        if (memoryDescriptor->MemoryType == LoaderXIPRom) {
            break;
        }
    }

    if ( listEntry == &LoaderBlock->MemoryDescriptorListHead ) {

        KdPrint(( "IopStartRamdisk: Couldn't find LoaderXIPRom descriptor\n" ));

        code = 1;
        status = STATUS_INVALID_PARAMETER;
        goto failed;
    }

    //
    // Build the IOCTL parameter block.
    //

    RtlZeroMemory( &create, sizeof(create) );

    create.Version = sizeof(create);
    create.DiskType = RAMDISK_TYPE_BOOT_DISK;
    create.BasePage = memoryDescriptor->BasePage;
    create.DriveLetter = L'C';           // ISSUE: Does this need to be configurable?
    create.Options.Fixed = (BOOLEAN)TRUE;
    create.Options.Readonly = (BOOLEAN)FALSE;
    create.Options.NoDriveLetter = (BOOLEAN)FALSE;
    create.Options.Hidden = (BOOLEAN)FALSE;
    create.Options.NoDosDevice = (BOOLEAN)FALSE;

    //
    // Use the well-known boot disk GUID.
    //

    create.DiskGuid = RamdiskBootDiskGuid;

    //
    // Look for RDIMAGEOFFSET and RDIMAGELENGTH load options.
    //

    create.DiskOffset = 0;
    create.DiskLength = memoryDescriptor->PageCount * PAGE_SIZE;

    options = LoaderBlock->LoadOptions;
    if ( options != NULL ) {

        PCHAR option;

        _strupr( options );

        option = strstr( options, "RDIMAGEOFFSET" );
        if ( option != NULL ) {

            option = strstr( option, "=" );
            if ( option != NULL ) {

                create.DiskOffset = atol( option + 1 );
            }
        }

        create.DiskLength -= create.DiskOffset;

        option = strstr( options, "RDIMAGELENGTH" );
        if ( option != NULL ) {

            option = strstr( option, "=" );
            if ( option != NULL ) {

                ULONGLONG length = _atoi64( option + 1 );
                ASSERT( length <= create.DiskLength );

                create.DiskLength = length;
            }
        }
    }

    //
    // Send an IOCTL to ramdisk.sys telling it to create the RAM disk.
    //

    PiWstrToUnicodeString( &string, RAMDISK_DEVICENAME );
    InitializeObjectAttributes( &obja,
                                &string,
                                OBJ_CASE_INSENSITIVE  | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = ZwOpenFile(
                &handle,
                GENERIC_READ | GENERIC_WRITE,
                &obja,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if ( NT_SUCCESS(status) ) {
        status = iosb.Status;
    }
    if ( !NT_SUCCESS(status) ) {

        KdPrint(( "IopStartRamdisk: Error opening %wZ. Error: %x\n", &string, status ));

        code = 2;
        goto failed;
    }

    status = ZwDeviceIoControlFile(
                handle,
                NULL,
                NULL,
                NULL,
                &iosb,
                FSCTL_CREATE_RAM_DISK,
                &create,
                sizeof(create),
                NULL,
                0
                );

    ZwClose( handle );

    if ( NT_SUCCESS(status) ) {
        status = iosb.Status;
    }
    if ( !NT_SUCCESS(status) ) {

        KdPrint(( "IopStartRamdisk: Error creating RAM disk: %x\n", status ));

        code = 3;
        goto failed;
    }

    //
    // Create an ARC name pointing ramdisk(0) to the RAM disk.
    //

    status = RtlStringFromGUID( &create.DiskGuid, &guidString);

    if ( !NT_SUCCESS(status) ) {

        KdPrint(( "IopStartRamdisk: Error creating disk GUID string: %x\n", status ));

        code = 4;
        goto failed;
    }

    StringCbPrintfW(buffer, sizeof(buffer), L"\\Device\\Ramdisk%wZ", &guidString);

    PiWstrToUnicodeString( &ustring, L"\\ArcName\\ramdisk(0)" );
    RtlInitUnicodeString( &ustring2, buffer );

    status = IoCreateSymbolicLink( &ustring, &ustring2 );

    RtlFreeUnicodeString( &guidString );

    if (!NT_SUCCESS(status)) {

        KdPrint(( "IopStartRamdisk: Failed to create arcname symbolic link (%wZ --> %wZ). %x\n",
                    &ustring, &ustring2, status ));

        code = 5;
        goto failed;
    }

    return STATUS_SUCCESS;

failed:

    KeBugCheckEx( RAMDISK_BOOT_INITIALIZATION_FAILED,
                  code,
                  status,
                  0,
                  0 );

} // IopStartRamdisk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpioapi.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpioapi.c

Abstract:

    This module contains the plug-and-play IO system APIs.

Author:

    Shie-Lin Tzong (shielint) 3-Jan-1995
    Andrew Thornton (andrewth) 5-Sept-1996
    Paula Tomlinson (paulat) 1-May-1997

Environment:

    Kernel mode

Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop
#include <stddef.h>
#include <wdmguid.h>

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'oipP')
#endif


//
// Define device state work item.
//

typedef struct _DEVICE_WORK_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PDEVICE_OBJECT DeviceObject;
    PVOID Context;
} DEVICE_WORK_ITEM, *PDEVICE_WORK_ITEM;

NTSTATUS
IopQueueDeviceWorkItem(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN VOID (*WorkerRoutine)(PVOID),
    IN PVOID Context
    );

VOID
IopRequestDeviceEjectWorker(
    PVOID Context
    );

BOOLEAN
IopIsReportedAlready(
    IN HANDLE Handle,
    IN PUNICODE_STRING ServiceName,
    IN PCM_RESOURCE_LIST ResourceList,
    OUT PBOOLEAN MatchingKey
    );

//
// Definitions for IoOpenDeviceRegistryKey
//

#define PATH_CURRENTCONTROLSET_HW_PROFILE_CURRENT TEXT("\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\Current\\System\\CurrentControlSet")
#define PATH_CURRENTCONTROLSET                    TEXT("\\Registry\\Machine\\System\\CurrentControlSet")
#define PATH_ENUM                                 TEXT("Enum\\")
#define PATH_CONTROL_CLASS                        TEXT("Control\\Class\\")
#define PATH_CCS_CONTROL_CLASS                    PATH_CURRENTCONTROLSET TEXT("\\") REGSTR_KEY_CONTROL TEXT("\\") REGSTR_KEY_CLASS
#define MAX_RESTPATH_BUF_LEN            512

//
// Definitions for PpCreateLegacyDeviceIds
//

#define LEGACY_COMPATIBLE_ID_BASE           TEXT("DETECTED")

NTSTATUS
PpCreateLegacyDeviceIds(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DriverName,
    IN PCM_RESOURCE_LIST Resources
    );

//
// An IO_GET_LEGACY_VETO_LIST_CONTEXT structure.
//

typedef struct {
    PWSTR *                     VetoList;
    ULONG                       VetoListLength;
    PPNP_VETO_TYPE              VetoType;
    NTSTATUS *                  Status;
} IO_GET_LEGACY_VETO_LIST_CONTEXT, *PIO_GET_LEGACY_VETO_LIST_CONTEXT;

BOOLEAN
IopAppendLegacyVeto(
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context,
    IN PUNICODE_STRING VetoName
    );
BOOLEAN
IopGetLegacyVetoListDevice(
    IN PDEVICE_NODE DeviceNode,
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    );
BOOLEAN
IopGetLegacyVetoListDeviceNode(
    IN PDEVICE_NODE DeviceNode,
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    );
VOID
IopGetLegacyVetoListDrivers(
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoForwardAndCatchIrp)
#pragma alloc_text(PAGE, IoGetDeviceProperty)
#pragma alloc_text(PAGE, IoGetDmaAdapter)
#pragma alloc_text(PAGE, IoGetLegacyVetoList)
#pragma alloc_text(PAGE, IoIsWdmVersionAvailable)
#pragma alloc_text(PAGE, IoOpenDeviceRegistryKey)
#pragma alloc_text(PAGE, IoReportDetectedDevice)
#pragma alloc_text(PAGE, IoSynchronousInvalidateDeviceRelations)
#pragma alloc_text(PAGE, PpCreateLegacyDeviceIds)
#pragma alloc_text(PAGE, IopAppendLegacyVeto)
#pragma alloc_text(PAGE, IopGetLegacyVetoListDevice)
#pragma alloc_text(PAGE, IopGetLegacyVetoListDeviceNode)
#pragma alloc_text(PAGE, IopGetLegacyVetoListDrivers)
#pragma alloc_text(PAGE, IopIsReportedAlready)
#pragma alloc_text(PAGE, IopOpenDeviceParametersSubkey)
#pragma alloc_text(PAGE, IopOpenOrCreateDeviceRegistryKey)
#pragma alloc_text(PAGE, IopRequestDeviceEjectWorker)
#pragma alloc_text(PAGE, IopResourceRequirementsChanged)
#pragma alloc_text(PAGE, PiGetDeviceRegistryProperty)
#endif // ALLOC_PRAGMA

NTSTATUS
IoGetDeviceProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_REGISTRY_PROPERTY DeviceProperty,
    IN ULONG BufferLength,
    OUT PVOID PropertyBuffer,
    OUT PULONG ResultLength
    )

/*++

Routine Description:

    This routine lets drivers query the registry properties associated with the
    specified device.

Parameters:

    DeviceObject - Supplies the device object whoes registry property is to be
                   returned.  This device object should be the one created by
                   a bus driver.

    DeviceProperty - Specifies what device property to get.

    BufferLength - Specifies the length, in byte, of the PropertyBuffer.

    PropertyBuffer - Supplies a pointer to a buffer to receive property data.

    ResultLength - Supplies a pointer to a variable to receive the size of the
                   property data returned.

ReturnValue:

    Status code that indicates whether or not the function was successful.  If
    PropertyBuffer is not big enough to hold requested data, STATUS_BUFFER_TOO_SMALL
    will be returned and ResultLength will be set to the number of bytes actually
    required.

--*/

{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;
    DEVICE_CAPABILITIES capabilities;
    PWSTR valueName, keyName = NULL;
    ULONG valueType, length, configFlags;
    DEVICE_INSTALL_STATE deviceInstallState;
    POBJECT_NAME_INFORMATION deviceObjectName;
    PWSTR deviceInstanceName;
    PWCHAR enumeratorNameEnd;
    GUID busTypeGuid;

    PAGED_CODE();

    //
    // Initialize out parameters
    //
    *ResultLength = 0;

    if (!IS_PDO(DeviceObject)) {

        if ((DeviceProperty != DevicePropertyInstallState) &&
            ((DeviceProperty != DevicePropertyEnumeratorName) ||
             (NULL == DeviceObject->DeviceObjectExtension->DeviceNode))) {

            //
            // We'll use the verifier to fail anyone who passes in something
            // that is not a PDO *except* for the DevicePropertyInstallState.
            // This is because our check for if something is a PDO really means
            // is this a PDO that PNP knows about.  For the most part these are
            // the same, but the DevicePropertyInstallState will get called by
            // classpnp, for device objects that *it* thinks it reported as
            // PDOs, but PartMgr actually swallowed.  This is a gross exception
            // to make, so PartMgr really should be fixed.
            //
            // The arbiters attempt to retrieve the Enumerator Name property
            // in determining whether "driver shared" resource allocations may
            // be accommodated.  The PDO used may be of the "legacy resource
            // devnode" placeholder variety.  The IS_PDO() macro explicitly
            // disallows these devnodes, so we must special-case this as well,
            // in order to avoid a verifier failure.  Note that our behavior
            // here is correct--we want the get-property call to fail for these
            // legacy resource devnodes.
            //
            PpvUtilFailDriver(
                PPVERROR_DDI_REQUIRES_PDO,
                (PVOID) _ReturnAddress(),
                DeviceObject,
                NULL
                );
        }

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    deviceNode = (PDEVICE_NODE) DeviceObject->DeviceObjectExtension->DeviceNode;

    //
    // Map Device Property to registry value name and value type.
    //
    switch(DeviceProperty) {

    case DevicePropertyPhysicalDeviceObjectName:

        ASSERT (0 == (1 & BufferLength));  // had better be an even length
        //
        // Create a buffer for the Obj manager.
        //
        length = BufferLength + sizeof (OBJECT_NAME_INFORMATION);
        deviceObjectName = (POBJECT_NAME_INFORMATION)ExAllocatePool(
            PagedPool,
            length);
        if (NULL == deviceObjectName) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }
        status = ObQueryNameString (DeviceObject,
                                    deviceObjectName,
                                    length,
                                    ResultLength);
        if (STATUS_INFO_LENGTH_MISMATCH == status) {

            status = STATUS_BUFFER_TOO_SMALL;
        }
        if (NT_SUCCESS (status)) {

            if (deviceObjectName->Name.Length == 0)  {
                //
                // PDO has no NAME, probably it's been deleted
                //
                *ResultLength = 0;
            } else {

                *ResultLength = deviceObjectName->Name.Length + sizeof(UNICODE_NULL);
                if (*ResultLength > BufferLength) {

                    status = STATUS_BUFFER_TOO_SMALL;
                } else {

                    RtlCopyMemory(PropertyBuffer,
                                  deviceObjectName->Name.Buffer,
                                  deviceObjectName->Name.Length);
                    //
                    // NULL terminate.
                    //
                    *(PWCHAR)(((PUCHAR)PropertyBuffer) + deviceObjectName->Name.Length) = L'\0';
                }
            }
        } else {

            *ResultLength -= sizeof(OBJECT_NAME_INFORMATION);
        }

        ExFreePool (deviceObjectName);
        return status;

    case DevicePropertyBusTypeGuid:

        status = PpBusTypeGuidGet(deviceNode->ChildBusTypeIndex, &busTypeGuid);
        if (NT_SUCCESS(status)) {

            *ResultLength = sizeof(GUID);
            if(*ResultLength <= BufferLength) {

                RtlCopyMemory(PropertyBuffer,
                              &busTypeGuid,
                              sizeof(GUID));
            } else {

                status = STATUS_BUFFER_TOO_SMALL;
            }
        }

        return status;

    case DevicePropertyLegacyBusType:

        if (deviceNode->ChildInterfaceType != InterfaceTypeUndefined) {

            *ResultLength = sizeof(INTERFACE_TYPE);
            if(*ResultLength <= BufferLength) {

                *(PINTERFACE_TYPE)PropertyBuffer = deviceNode->ChildInterfaceType;
                status = STATUS_SUCCESS;
            } else {

                status = STATUS_BUFFER_TOO_SMALL;
            }
        } else {

            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

        return status;

    case DevicePropertyBusNumber:
        //
        // Retrieve the property from the parent's devnode field.
        //
        if ((deviceNode->ChildBusNumber & 0x80000000) != 0x80000000) {

            *ResultLength = sizeof(ULONG);
            if(*ResultLength <= BufferLength) {

                *(PULONG)PropertyBuffer = deviceNode->ChildBusNumber;
                status = STATUS_SUCCESS;
            } else {

                status = STATUS_BUFFER_TOO_SMALL;
            }
        } else {

            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

        return status;

    case DevicePropertyEnumeratorName:

        ASSERT (0 == (1 & BufferLength));  // had better be an even length
        deviceInstanceName = deviceNode->InstancePath.Buffer;
        //
        // There should always be a string here, except for (possibly)
        // HTREE\Root\0, but no one should ever be calling us with that PDO
        // anyway.
        //
        ASSERT (deviceInstanceName);
        //
        // We know we're going to find a separator character (\) in the string,
        // so the fact that unicode strings may not be null-terminated isn't
        // a problem.
        //
        enumeratorNameEnd = wcschr(deviceInstanceName, OBJ_NAME_PATH_SEPARATOR);
        ASSERT (enumeratorNameEnd);
        //
        // Compute required length, minus null terminating character.
        //
        length = (ULONG)((PUCHAR)enumeratorNameEnd - (PUCHAR)deviceInstanceName);
        //
        // Store required length in caller-supplied OUT parameter.
        //
        *ResultLength = length + sizeof(UNICODE_NULL);
        if(*ResultLength > BufferLength) {

            status = STATUS_BUFFER_TOO_SMALL;
        } else {

            RtlCopyMemory((PUCHAR)PropertyBuffer, (PUCHAR)deviceInstanceName, length);
            *(PWCHAR)((PUCHAR)PropertyBuffer + length) = UNICODE_NULL;
            status = STATUS_SUCCESS;
        }

        return status;

    case DevicePropertyAddress:

        status = PpIrpQueryCapabilities(DeviceObject, &capabilities);
        if (NT_SUCCESS(status) && (capabilities.Address != 0xFFFFFFFF)) {

            *ResultLength = sizeof(ULONG);
            if(*ResultLength <= BufferLength) {

                *(PULONG)PropertyBuffer = capabilities.Address;
                status = STATUS_SUCCESS;
            } else {

                status = STATUS_BUFFER_TOO_SMALL;
            }
        } else {

            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

        return status;

    case DevicePropertyRemovalPolicy:

        *ResultLength = sizeof(ULONG);
        if(*ResultLength <= BufferLength) {

            PpHotSwapGetDevnodeRemovalPolicy(
                deviceNode,
                TRUE, // Include Registry Override
                (PDEVICE_REMOVAL_POLICY) PropertyBuffer
                );
            status = STATUS_SUCCESS;
        } else {

            status = STATUS_BUFFER_TOO_SMALL;
        }

        return status;

    case DevicePropertyUINumber:

        valueName = REGSTR_VALUE_UI_NUMBER;
        valueType = REG_DWORD;
        break;

    case DevicePropertyLocationInformation:

        valueName = REGSTR_VALUE_LOCATION_INFORMATION;
        valueType = REG_SZ;
        break;

    case DevicePropertyDeviceDescription:

        valueName = REGSTR_VALUE_DEVICE_DESC;
        valueType = REG_SZ;
        break;

    case DevicePropertyHardwareID:

        valueName = REGSTR_VALUE_HARDWAREID;
        valueType = REG_MULTI_SZ;
        break;

    case DevicePropertyCompatibleIDs:

        valueName = REGSTR_VALUE_COMPATIBLEIDS;
        valueType = REG_MULTI_SZ;
        break;

    case DevicePropertyBootConfiguration:

        keyName   = REGSTR_KEY_LOG_CONF;
        valueName = REGSTR_VAL_BOOTCONFIG;
        valueType = REG_RESOURCE_LIST;
        break;

    case DevicePropertyBootConfigurationTranslated:

        return STATUS_NOT_SUPPORTED;
        break;

    case DevicePropertyClassName:

        valueName = REGSTR_VALUE_CLASS;
        valueType = REG_SZ;
        break;

    case DevicePropertyClassGuid:
        valueName = REGSTR_VALUE_CLASSGUID;
        valueType = REG_SZ;
        break;

    case DevicePropertyDriverKeyName:

        valueName = REGSTR_VALUE_DRIVER;
        valueType = REG_SZ;
        break;

    case DevicePropertyManufacturer:

        valueName = REGSTR_VAL_MFG;
        valueType = REG_SZ;
        break;

    case DevicePropertyFriendlyName:

        valueName = REGSTR_VALUE_FRIENDLYNAME;
        valueType = REG_SZ;
        break;

    case DevicePropertyInstallState:

        if (deviceNode == IopRootDeviceNode) {
            //
            // The root devnode is always installed, by definition.  We
            // specifically set it's InstallState here because the
            // CONFIGFLAG_REINSTALL flag will wunfortunately still exist on the
            // root devnode reg key on a running system (we should fix that
            // later).
            //
            deviceInstallState = InstallStateInstalled;
            status = STATUS_SUCCESS;

        } else {
            //
            // For all other devnodes, walk up the devnode tree, retrieving the
            // install state of all ancestors up to (but not including) the root
            // devnode.  We'll stop when we've reached the top of the tree, or
            // when some intermediate device has an "uninstalled" install state.
            //

            valueName = REGSTR_VALUE_CONFIG_FLAGS;
            valueType = REG_DWORD;

            do {
                //
                // Get the ConfigFlags registry value.
                //
                length = sizeof(ULONG);
                status = PiGetDeviceRegistryProperty(
                    deviceNode->PhysicalDeviceObject,
                    valueType,
                    valueName,
                    keyName,
                    (PVOID)&configFlags,
                    &length
                    );

                if (NT_SUCCESS(status)) {
                    //
                    // The install state is just a subset of the device's ConfigFlags
                    //
                    if (configFlags & CONFIGFLAG_REINSTALL) {

                        deviceInstallState = InstallStateNeedsReinstall;

                    } else if (configFlags & CONFIGFLAG_FAILEDINSTALL) {

                        deviceInstallState = InstallStateFailedInstall;

                    } else if (configFlags & CONFIGFLAG_FINISH_INSTALL) {

                        deviceInstallState = InstallStateFinishInstall;
                    } else {

                        deviceInstallState = InstallStateInstalled;
                    }
                } else {
                    deviceInstallState = InstallStateFailedInstall;
                    break;
                }

                deviceNode = deviceNode->Parent;

            } while ((deviceInstallState == InstallStateInstalled) &&
                     (deviceNode != IopRootDeviceNode));
        }

        if (NT_SUCCESS(status)) {

            *ResultLength = sizeof(ULONG);
            if(*ResultLength <= BufferLength) {
                *(PDEVICE_INSTALL_STATE)PropertyBuffer = deviceInstallState;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
        }

        return status;

    default:

        return STATUS_INVALID_PARAMETER_2;
    }
    //
    // Get the registry value.
    //
    *ResultLength = BufferLength;
    status = PiGetDeviceRegistryProperty(
        DeviceObject,
        valueType,
        valueName,
        keyName,
        PropertyBuffer,
        ResultLength
        );

    return status;
}

NTSTATUS
PiGetDeviceRegistryProperty(
    IN      PDEVICE_OBJECT   DeviceObject,
    IN      ULONG            ValueType,
    IN      PWSTR            ValueName,
    IN      PWSTR            KeyName,
    OUT     PVOID            Buffer,
    IN OUT  PULONG           BufferLength
    )
{
    NTSTATUS status;
    HANDLE handle, subKeyHandle;
    UNICODE_STRING unicodeKey;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation = NULL;

    PAGED_CODE();

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulatio
    // portion solves this problem
    //
    PiLockPnpRegistry(TRUE);
    //
    // Based on the PDO specified by caller, find the handle of its device
    // instance registry key.
    //
    status = IopDeviceObjectToDeviceInstance(DeviceObject, &handle, KEY_READ);
    if (NT_SUCCESS(status)) {
        //
        // If the data is stored in a subkey then open this key and close the old one
        //
        if (KeyName) {

            RtlInitUnicodeString(&unicodeKey, KeyName);
            status = IopOpenRegistryKeyEx( &subKeyHandle,
                                           handle,
                                           &unicodeKey,
                                           KEY_READ
                                           );
            if(NT_SUCCESS(status)){

                ZwClose(handle);
                handle = subKeyHandle;
            }
        }
        if (NT_SUCCESS(status)) {
            //
            // Read the registry value of the desired value name
            //
            status = IopGetRegistryValue (handle,
                                          ValueName,
                                          &keyValueInformation);
        }
        //
        // We have finished using the registry so clean up and release our resources
        //
        ZwClose(handle);
    }
    PiUnlockPnpRegistry();
    //
    // If we have been sucessfull in finding the info hand it back to the caller
    //
    if (NT_SUCCESS(status)) {
        //
        // Check that the buffer we have been given is big enough and that the value returned is
        // of the correct registry type
        //
        if (*BufferLength >= keyValueInformation->DataLength) {

            if (keyValueInformation->Type == ValueType) {

                RtlCopyMemory(  Buffer,
                                KEY_VALUE_DATA(keyValueInformation),
                                keyValueInformation->DataLength);
            } else {

               status = STATUS_INVALID_PARAMETER_2;
            }
        } else {

            status = STATUS_BUFFER_TOO_SMALL;
        }
        *BufferLength = keyValueInformation->DataLength;
        ExFreePool(keyValueInformation);
    }

    return status;
}

NTSTATUS
IoOpenDeviceRegistryKey(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN ULONG DevInstKeyType,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DevInstRegKey
    )

/*++

Routine Description:

    This routine returns a handle to an opened registry key that the driver
    may use to store/retrieve configuration information specific to a particular
    device instance.

    The driver must call ZwClose to close the handle returned from this api
    when access is no longer required.

Parameters:

    DeviceObject   - Supples the device object of the physical device instance to
                     open a registry storage key for.  Normally it is a device object
                     created by the hal bus extender.

    DevInstKeyType - Supplies flags specifying which storage key associated with
                     the device instance is to be opened.  May be a combination of
                     the following value:

                     PLUGPLAY_REGKEY_DEVICE - Open a key for storing device specific
                         (driver-independent) information relating to the device instance.
                         The flag may not be specified with PLUGPLAY_REGKEY_DRIVER.

                     PLUGPLAY_REGKEY_DRIVER - Open a key for storing driver-specific
                         information relating to the device instance,  This flag may
                         not be specified with PLUGPLAY_REGKEY_DEVICE.

                     PLUGPLAY_REGKEY_CURRENT_HWPROFILE - If this flag is specified,
                         then a key in the current hardware profile branch will be
                         opened for the specified storage type.  This allows the driver
                         to access configuration information that is hardware profile
                         specific.

    DesiredAccess - Specifies the access mask for the key to be opened.

    DevInstRegKey - Supplies the address of a variable that receives a handle to the
                    opened key for the specified registry storage location.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    //
    // IoOpenDeviceRegistryKey does not support creating a driver key if none
    // exists.  This is for internal use only.
    //
    return IopOpenOrCreateDeviceRegistryKey(PhysicalDeviceObject,
                                            DevInstKeyType,
                                            DesiredAccess,
                                            FALSE,  //  do not create
                                            DevInstRegKey);

}

NTSTATUS
IopOpenOrCreateDeviceRegistryKey(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN ULONG DevInstKeyType,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create,
    OUT PHANDLE DevInstRegKey
    )

/*++

Routine Description:

    This routine returns a handle to an opened registry key that the driver
    may use to store/retrieve configuration information specific to a particular
    device instance.

    The driver must call ZwClose to close the handle returned from this api
    when access is no longer required.

Parameters:

    DeviceObject   - Supples the device object of the physical device instance to
                     open a registry storage key for.  Normally it is a device object
                     created by the hal bus extender.

    DevInstKeyType - Supplies flags specifying which storage key associated with
                     the device instance is to be opened.  May be a combination of
                     the following value:

                     PLUGPLAY_REGKEY_DEVICE - Open a key for storing device specific
                         (driver-independent) information relating to the device instance.
                         The flag may not be specified with PLUGPLAY_REGKEY_DRIVER.

                     PLUGPLAY_REGKEY_DRIVER - Open a key for storing driver-specific
                         information relating to the device instance,  This flag may
                         not be specified with PLUGPLAY_REGKEY_DEVICE.

                     PLUGPLAY_REGKEY_CURRENT_HWPROFILE - If this flag is specified,
                         then a key in the current hardware profile branch will be
                         opened for the specified storage type.  This allows the driver
                         to access configuration information that is hardware profile
                         specific.

    DesiredAccess - Specifies the access mask for the key to be opened.

    Create        - Specifies whether the key should be created if not present (applies
                    only to PLUGPLAY_REGKEY_DRIVER; for PLUGPLAY_REGKEY_DEVICE,
                    a key is always created).

    DevInstRegKey - Supplies the address of a variable that receives a handle to the
                    opened key for the specified registry storage location.

Return Value:

    Status code that indicates whether or not the function was successful.

Notes:

 ** The Create parameter ONLY applies to DevInstKeyType == PLUGPLAY_REGKEY_DRIVER!

   -- For PLUGPLAY_REGKEY_DEVICE, a key is always created, so this parameter
      will be ignored.

   -- A hardware-profile-specific subkey will only be created for

        PLUGPLAY_REGKEY_DRIVER | PLUGPLAY_REGKEY_CURRENT_HWPROFILE

      if a corresponding non-hardware-profile-specific Driver key has already
      been created for the device in the global CurrentControlSet.

      If this routine is needed to create a hardware-profile-specific Driver key
      when no global Driver key exists yet for the device, then you must modify
      the code below to first search for and create an available driver instance
      key in both the global AND hardware profile-specific CurrentControlSet
      branches.

--*/

{

    NTSTATUS status, appendStatus;
    HANDLE hBasePath;
    UNICODE_STRING unicodeBasePath, unicodeRestPath;
    WCHAR   drvInst[GUID_STRING_LEN + 5];
    ULONG   drvInstLength;

    PAGED_CODE();

    //
    // Until SCSIPORT stops passing non PDOs allow the system to boot.
    //
    // ASSERT_PDO(PhysicalDeviceObject);
    //

    //
    // Initialise out parameters
    //

    *DevInstRegKey = NULL;

    //
    // Allocate a buffer to build the RestPath string in
    //

    unicodeRestPath.Buffer = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, MAX_RESTPATH_BUF_LEN);

    if (unicodeRestPath.Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto clean0;
    }

    unicodeRestPath.Length=0;
    unicodeRestPath.MaximumLength=MAX_RESTPATH_BUF_LEN;

    //
    // Select the base path to the CurrentControlSet based on if we are dealing with
    // a hardware profile or not
    //

    if (DevInstKeyType & PLUGPLAY_REGKEY_CURRENT_HWPROFILE) {
        PiWstrToUnicodeString(&unicodeBasePath, PATH_CURRENTCONTROLSET_HW_PROFILE_CURRENT);

    } else {
        PiWstrToUnicodeString(&unicodeBasePath, PATH_CURRENTCONTROLSET);
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //
    PiLockPnpRegistry(TRUE);

    //
    // Open the base registry key
    //

    status = IopOpenRegistryKeyEx( &hBasePath,
                                   NULL,
                                   &unicodeBasePath,
                                   KEY_READ
                                   );

    if(!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Build the RestPath string
    //

    switch (DevInstKeyType) {

    case PLUGPLAY_REGKEY_DEVICE:
    case PLUGPLAY_REGKEY_DEVICE + PLUGPLAY_REGKEY_CURRENT_HWPROFILE:
        {
            PDEVICE_NODE pDeviceNode;

            //
            // Initialise the rest path with Enum\
            //

            appendStatus = RtlAppendUnicodeToString(&unicodeRestPath, PATH_ENUM);
            ASSERT(NT_SUCCESS( appendStatus ));
            //
            // Get the Enumerator\DeviceID\InstanceID path from the DeviceNode
            //

            pDeviceNode = (PDEVICE_NODE) PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;

            //
            // Ensure this is a PDO and not an FDO (only PDO's have a DeviceNode)
            //

            if (pDeviceNode) {
                appendStatus = RtlAppendUnicodeStringToString(&unicodeRestPath, &(pDeviceNode->InstancePath));
                ASSERT(NT_SUCCESS( appendStatus ));
            } else {
                status = STATUS_INVALID_DEVICE_REQUEST;
            }

            break;
        }

    case PLUGPLAY_REGKEY_DRIVER:
    case PLUGPLAY_REGKEY_DRIVER + PLUGPLAY_REGKEY_CURRENT_HWPROFILE:
        {

            HANDLE hDeviceKey;

            //
            // Initialise the rest path with Control\Class\
            //

            appendStatus = RtlAppendUnicodeToString(&unicodeRestPath, PATH_CONTROL_CLASS);
            ASSERT(NT_SUCCESS( appendStatus ));

            //
            // Open the device instance key for this device
            //

            status = IopDeviceObjectToDeviceInstance(PhysicalDeviceObject, &hDeviceKey, KEY_READ);

            if(!NT_SUCCESS(status)){
                goto clean1;
            }

            //
            // See if we have a driver value
            //

            status = IoGetDeviceProperty(PhysicalDeviceObject, DevicePropertyDriverKeyName, sizeof(drvInst), drvInst, &drvInstLength);
            if(NT_SUCCESS(status)){
                //
                // Append <DevInstClass>\<ClassInstanceOrdinal>
                //
                appendStatus = RtlAppendUnicodeToString(&unicodeRestPath, drvInst);
                ASSERT(NT_SUCCESS( appendStatus ));

            } else if ((status == STATUS_OBJECT_NAME_NOT_FOUND) &&
                       Create &&
                       ((DevInstKeyType & PLUGPLAY_REGKEY_CURRENT_HWPROFILE) == 0)) {

                //
                // No Driver value exists for this device yet, but we've been
                // explicitly asked to create one now.
                //
                // NOTE: 01-Dec-2001 : Jim Cavalaris (jamesca)
                //
                // Note that we only do this for the global driver key - not the
                // hardware profile specific one.  If this routine is used to
                // create hardware profile keys also, then you must search for
                // and create an available driver instance key in both the
                // global AND hardware profile-specific CurrentControlSet
                // branches.
                //

                WCHAR classGUID[GUID_STRING_LEN];
                ULONG classGUIDLength;
                HANDLE hClassGUIDKey;

                //
                // See if we have a class GUID value.
                //

                status = IoGetDeviceProperty(PhysicalDeviceObject,
                                             DevicePropertyClassGuid,
                                             sizeof(classGUID),
                                             classGUID,
                                             &classGUIDLength);

                if (NT_SUCCESS(status)) {
                    //
                    // Open or create the key for this device's Class.
                    //
                    appendStatus = RtlAppendUnicodeToString(&unicodeRestPath, classGUID);
                    ASSERT(NT_SUCCESS( appendStatus ));

                    status = IopCreateRegistryKeyEx(&hClassGUIDKey,
                                                    hBasePath,
                                                    &unicodeRestPath,
                                                    KEY_ALL_ACCESS, // need to create
                                                    REG_OPTION_NON_VOLATILE,
                                                    NULL);
                    if (NT_SUCCESS(status)) {

                        ULONG instance;
                        WCHAR instanceOrdinal[5];
                        UNICODE_STRING tempString;
                        HANDLE hDriverInstanceKey;
                        ULONG disposition;

                        for (instance = 0; instance < 9999; instance++) {
                            //
                            // Find the first available class instance key.
                            //
                            StringCbPrintfW(instanceOrdinal, sizeof(instanceOrdinal), TEXT("%04u"), instance);

                            RtlInitUnicodeString(&tempString, instanceOrdinal);

                            hDriverInstanceKey = NULL;

                            status = IopCreateRegistryKeyEx(&hDriverInstanceKey,
                                                            hClassGUIDKey,
                                                            &tempString,
                                                            DesiredAccess,
                                                            REG_OPTION_NON_VOLATILE,
                                                            &disposition);
                            if (NT_SUCCESS(status)) {

                                if (disposition == REG_CREATED_NEW_KEY) {
                                    //
                                    // Set the Driver registry value in the
                                    // device instance key.
                                    //
                                    StringCbPrintfW(drvInst,
                                               sizeof(drvInst),
                                             TEXT("%s\\%s"),
                                             classGUID,
                                             instanceOrdinal);

                                    PiWstrToUnicodeString(&tempString, REGSTR_VALUE_DRIVER);

                                    status = ZwSetValueKey(hDeviceKey,
                                                           &tempString,
                                                           TITLE_INDEX_VALUE,
                                                           REG_SZ,
                                                           drvInst,
                                                           (ULONG)((wcslen(drvInst)+1) * sizeof(WCHAR)));

                                    if (NT_SUCCESS(status)) {
                                        appendStatus = RtlAppendUnicodeToString(&unicodeRestPath, TEXT("\\"));
                                        ASSERT(NT_SUCCESS( appendStatus ));

                                        appendStatus = RtlAppendUnicodeToString(&unicodeRestPath, instanceOrdinal);
                                        ASSERT(NT_SUCCESS( appendStatus ));

                                    } else {
                                        //
                                        // Delete the key we just created.
                                        //
                                        ZwDeleteKey(hDriverInstanceKey);
                                    }

                                    //
                                    // Always close the key we just created, so we
                                    // can open it below for the DesiredAccess of
                                    // the caller.
                                    //
                                    ZwClose(hDriverInstanceKey);

                                    break;
                                }

                                //
                                // Always close the key we just created, so we
                                // can open it below for the DesiredAccess of
                                // the caller.
                                //
                                ZwClose(hDriverInstanceKey);
                            }
                        }

                        if (instance == 9999) {
                            status = STATUS_UNSUCCESSFUL;
                        }

                        ZwClose(hClassGUIDKey);
                    }
                }
            }

            ZwClose(hDeviceKey);

            break;
        }
    default:

        //
        // ISSUE 2001/02/08 ADRIAO - This is parameter #2, not parameter #3!
        //
        status = STATUS_INVALID_PARAMETER_3;
        goto clean2;
    }


    //
    // If we succeeded in building the rest path then open the key and hand it back to the caller
    //

    if (NT_SUCCESS(status)){
        if (DevInstKeyType == PLUGPLAY_REGKEY_DEVICE) {

            status = IopOpenDeviceParametersSubkey(DevInstRegKey,
                                                   hBasePath,
                                                   &unicodeRestPath,
                                                   DesiredAccess);
        } else {

            status = IopCreateRegistryKeyEx( DevInstRegKey,
                                             hBasePath,
                                             &unicodeRestPath,
                                             DesiredAccess,
                                             REG_OPTION_NON_VOLATILE,
                                             NULL
                                             );
        }
    }

    //
    // Free up resources
    //

clean2:
    ZwClose(hBasePath);
clean1:
    PiUnlockPnpRegistry();
    ExFreePool(unicodeRestPath.Buffer);
clean0:
    return status;

}

NTSTATUS
IoSynchronousInvalidateDeviceRelations(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  DEVICE_RELATION_TYPE    Type
    )

/*++

Routine Description:

    This API notifies the system that changes have occurred in the device
    relations of the specified type for the supplied DeviceObject.   All
    cached information concerning the relationships must be invalidated,
    and if needed re-obtained via IRP_MN_QUERY_DEVICE_RELATIONS.

    This routine performs device enumeration synchronously.
    Note, A driver can NOT call this IO api while processing pnp irps AND
    A driver can NOT call this api from any system thread except the system
    threads created by the driver itself.

Parameters:

    DeviceObject - the PDEVICE_OBJECT for which the specified relation type
                   information has been invalidated.  This pointer is valid
                   for the duration of the call.

    Type - specifies the type of the relation being invalidated.

ReturnValue:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_NODE deviceNode;
    NTSTATUS status = STATUS_SUCCESS;
    KEVENT completionEvent;

    PAGED_CODE();

    ASSERT_PDO(DeviceObject);

    switch (Type) {
    case BusRelations:

        if (PnPInitialized) {

            deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

            if (deviceNode->State == DeviceNodeStarted) {

                KeInitializeEvent( &completionEvent, NotificationEvent, FALSE );

                status = PipRequestDeviceAction( DeviceObject,
                                                 ReenumerateDeviceTree,
                                                 FALSE,
                                                 0,
                                                 &completionEvent,
                                                 NULL );

                if (NT_SUCCESS(status)) {

                    status = KeWaitForSingleObject( &completionEvent,
                                                    Executive,
                                                    KernelMode,
                                                    FALSE,
                                                    NULL);
                }
            } else {
                status = STATUS_UNSUCCESSFUL;
            }
        } else {
            status = STATUS_UNSUCCESSFUL;
        }
        break;

    case EjectionRelations:

        //
        // For Ejection relation change, we will ignore it.  We don't keep track
        // the Ejection relation.  We will query the Ejection relation only when
        // we are requested to eject a device.
        //

        status = STATUS_NOT_SUPPORTED;
        break;

    case PowerRelations:


        //
        // Call off to Po code, which will do the right thing
        //
        PoInvalidateDevicePowerRelations(DeviceObject);
        break;
    }
    return status;
}

VOID
IoInvalidateDeviceRelations(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  DEVICE_RELATION_TYPE    Type
    )

/*++

Routine Description:

    This API notifies the system that changes have occurred in the device
    relations of the specified type for the supplied DeviceObject.   All
    cached information concerning the relationships must be invalidated,
    and if needed re-obtained via IRP_MN_QUERY_DEVICE_RELATIONS.

Parameters:

    DeviceObject - the PDEVICE_OBJECT for which the specified relation type
                   information has been invalidated.  This pointer is valid
                   for the duration of the call.

    Type - specifies the type of the relation being invalidated.

ReturnValue:

    none.

--*/

{

    PDEVICE_NODE deviceNode;

    ASSERT_PDO(DeviceObject);

    switch (Type) {
    case BusRelations:
    case SingleBusRelations:

        //
        // If the call was made before PnP completes device enumeration
        // we can safely ignore it.  PnP manager will do it without
        // driver's request.
        //

        deviceNode = (PDEVICE_NODE) DeviceObject->DeviceObjectExtension->DeviceNode;
        if (deviceNode) {

            PipRequestDeviceAction( DeviceObject,
                                    Type == BusRelations ?
                                        ReenumerateDeviceTree : ReenumerateDeviceOnly,
                                    FALSE,
                                    0,
                                    NULL,
                                    NULL );
        }
        break;

    case EjectionRelations:

        //
        // For Ejection relation change, we will ignore it.  We don't keep track
        // the Ejection relation.  We will query the Ejection relation only when
        // we are requested to eject a device.

        break;

    case PowerRelations:

        //
        // Call off to Po code, which will do the right thing
        //
        PoInvalidateDevicePowerRelations(DeviceObject);
        break;
    }
}

VOID
IoRequestDeviceEject(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This API notifies that the device eject button has been pressed. This API must
    be called at IRQL <= DISPATCH_LEVEL.

    This API informs PnP that a device eject has been requested, the device will
    not necessarily be ejected as a result of this API.  The device will only be
    ejected if the drivers associated with it agree to stop and the device is
    successfully powered down.  Note that eject in this context refers to device
    eject, not to media (floppies, cds, tapes) eject.  For example, eject of a
    cd-rom disk drive, not ejection of a cd-rom disk.

Arguments:

    DeviceObject - the PDEVICE_OBJECT for the device whose eject button has
                   been pressed.  This pointer is valid for the duration of
                   the call, if the API wants to keep a copy of it, it
                   should obtain its own reference to the object
                   (ObReferenceObject).

ReturnValue:

    None.

--*/

{
    ASSERT_PDO(DeviceObject);

    IopQueueDeviceWorkItem(DeviceObject, IopRequestDeviceEjectWorker, NULL);
}

VOID
IopRequestDeviceEjectWorker(
    IN PVOID Context
    )
{
    PDEVICE_WORK_ITEM deviceWorkItem = (PDEVICE_WORK_ITEM)Context;
    PDEVICE_OBJECT deviceObject = deviceWorkItem->DeviceObject;

    ExFreePool(deviceWorkItem);

    //
    // Queue the event, we'll return immediately after it's queued.
    //
    PpSetTargetDeviceRemove( deviceObject,
                             TRUE,
                             TRUE,
                             FALSE,
                             TRUE,
                             CM_PROB_HELD_FOR_EJECT,
                             NULL,
                             NULL,
                             NULL,
                             NULL);

    ObDereferenceObject(deviceObject);
}


NTSTATUS
IoReportDetectedDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements OPTIONAL,
    IN BOOLEAN ResourceAssigned,
    IN OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    PnP device drivers call this API to report any device detected.  This routine
    creates a Physical Device object, reference the Physical Device object and
    returns back to the callers.  Once the detected device is reported, the Pnp manager
    considers the device has been fully controlled by the reporting drivers.  Thus it
    will not invoke AddDevice entry and send StartDevice irp to the driver.

    The driver needs to report the resources it used to detect this device such that
    pnp manager can perform duplicates detection on this device.

    The caller must dereference the DeviceObject once it no longer needs it.

Parameters:

    DriverObject - Supplies the driver object of the driver who detected
                   this device.

    ResourceList - Supplies a pointer to the resource list which the driver used
                   to detect the device.

    ResourceRequirements - supplies a pointer to the resource requirements list
                   for the detected device.  This is optional.

    ResourceAssigned - if TRUE, the driver already called IoReportResourceUsage or
                   IoAssignResource to get the ownership of the resources.  Otherwise,
                   the PnP manager will call IoReportResourceUsage to allocate the
                   resources for the driver.

    DeviceObject - if NULL, this routine will create a PDO and return it thru this variable.
                   Otherwise, a PDO is already created and this routine will simply use the supplied
                   PDO.

Return Value:

    Status code that indicates whether or not the function was successful.


--*/

{
    WCHAR buffer[MAX_DEVICE_ID_LEN], *end, *name;
    NTSTATUS status;
    UNICODE_STRING deviceName, instanceName, unicodeName, *serviceName, driverName;
    PDEVICE_NODE deviceNode;
    ULONG length, i = 0, disposition, tmpValue, listSize = 0;
    HANDLE handle = NULL, handle1, logConfHandle = NULL, controlHandle = NULL, enumHandle;
    PCM_RESOURCE_LIST cmResource;
    PWSTR p;
    PDEVICE_OBJECT deviceObject;
    BOOLEAN newlyCreated = FALSE;

    PAGED_CODE();

    if (*DeviceObject) {

        deviceObject = *DeviceObject;

        //
        // The PDO is already known. simply handle the resourcelist and resreq list.
        // This is a hack for NDIS drivers.
        //
        deviceNode = (PDEVICE_NODE)(*DeviceObject)->DeviceObjectExtension->DeviceNode;
        if (!deviceNode) {
            return STATUS_NO_SUCH_DEVICE;
        }
        PiLockPnpRegistry(FALSE);

        //
        // Write ResourceList and ResReq list to the device instance
        //

        status = IopDeviceObjectToDeviceInstance (*DeviceObject,
                                                  &handle,
                                                  KEY_ALL_ACCESS
                                                  );
        if (!NT_SUCCESS(status)) {
            PiUnlockPnpRegistry();
            return status;
        }
        if (ResourceAssigned) {
            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_NO_RESOURCE_AT_INIT);
            tmpValue = 1;
            ZwSetValueKey(handle,
                          &unicodeName,
                          TITLE_INDEX_VALUE,
                          REG_DWORD,
                          &tmpValue,
                          sizeof(tmpValue)
                          );
        }
        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
        status = IopCreateRegistryKeyEx( &logConfHandle,
                                         handle,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
        ZwClose(handle);
        if (NT_SUCCESS(status)) {

            //
            // Write the ResourceList and and ResourceRequirements to the logconf key under
            // device instance key.
            //

            if (ResourceList) {
                PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_BOOTCONFIG);
                ZwSetValueKey(
                          logConfHandle,
                          &unicodeName,
                          TITLE_INDEX_VALUE,
                          REG_RESOURCE_LIST,
                          ResourceList,
                          listSize = IopDetermineResourceListSize(ResourceList)
                          );
            }
            if (ResourceRequirements) {
                PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_BASIC_CONFIG_VECTOR);
                ZwSetValueKey(
                          logConfHandle,
                          &unicodeName,
                          TITLE_INDEX_VALUE,
                          REG_RESOURCE_REQUIREMENTS_LIST,
                          ResourceRequirements,
                          ResourceRequirements->ListSize
                          );
            }
            ZwClose(logConfHandle);
        }
        PiUnlockPnpRegistry();
        if (NT_SUCCESS(status)) {
            goto checkResource;
        } else {
            return status;
        }
    }

    //
    // Normal case: *DeviceObject is NULL
    //

    *DeviceObject = NULL;
    serviceName = &DriverObject->DriverExtension->ServiceKeyName;

    //
    // Special handling for driver object created thru IoCreateDriver.
    // When a builtin driver calls IoReportDetectedDevice, the ServiceKeyName of
    // the driver object is set to \Driver\DriverName.  To create a detected device
    // instance key, we will take only the DriverName.
    //

    if (DriverObject->Flags & DRVO_BUILTIN_DRIVER) {
        p = serviceName->Buffer + (serviceName->Length / sizeof(WCHAR)) - 1;
        driverName.Length = 0;
        while (*p != '\\' && (p != serviceName->Buffer)) {
            p--;
            driverName.Length += sizeof(WCHAR);
        }
        if (p == serviceName->Buffer) {
            return STATUS_UNSUCCESSFUL;
        } else {
            p++;
            driverName.Buffer = p;
            driverName.MaximumLength = driverName.Length + sizeof(WCHAR);
        }
    } else {

        //
        // Before doing anything first perform duplicate detection
        //

        status = IopDuplicateDetection( LegacyBusType,
                                        BusNumber,
                                        SlotNumber,
                                        &deviceNode
                                        );

        if (NT_SUCCESS(status) && deviceNode) {

            deviceObject = deviceNode->PhysicalDeviceObject;

            if (PipAreDriversLoaded(deviceNode) ||
                (PipDoesDevNodeHaveProblem(deviceNode) &&
                 deviceNode->Problem != CM_PROB_NOT_CONFIGURED &&
                 deviceNode->Problem != CM_PROB_REINSTALL &&
                 deviceNode->Problem != CM_PROB_FAILED_INSTALL)) {

                ObDereferenceObject(deviceObject);

                return STATUS_NO_SUCH_DEVICE;
            }

            deviceNode->Flags &= ~DNF_HAS_PROBLEM;
            deviceNode->Problem = 0;

            IopDeleteLegacyKey(DriverObject);
            goto checkResource;
        }

        driverName.Buffer = NULL;
    }

    //
    // Create a PDO
    //

    status = IoCreateDevice( IoPnpDriverObject,
                             sizeof(IOPNP_DEVICE_EXTENSION),
                             NULL,
                             FILE_DEVICE_CONTROLLER,
                             FILE_AUTOGENERATED_DEVICE_NAME,
                             FALSE,
                             &deviceObject );

    if (NT_SUCCESS(status)) {
        deviceObject->Flags |= DO_BUS_ENUMERATED_DEVICE;   // Mark this is a PDO
        status = PipAllocateDeviceNode(deviceObject, &deviceNode);
        if (status != STATUS_SYSTEM_HIVE_TOO_LARGE && deviceNode) {

            //
            // First delete the Legacy_DriverName key and subkeys from Enum\Root, if exits.
            //

            if (!(DriverObject->Flags & DRVO_BUILTIN_DRIVER)) {
                IopDeleteLegacyKey(DriverObject);
            }

            //
            // Create the compatible id list we'll use for this made-up device.
            //

            status = PpCreateLegacyDeviceIds(
                        deviceObject,
                        ((DriverObject->Flags & DRVO_BUILTIN_DRIVER) ?
                            &driverName : serviceName),
                        ResourceList);

            PiLockPnpRegistry(FALSE);
            if(!NT_SUCCESS(status)) {
                goto exit;
            }

            //
            // Create/Open a registry key for the device instance and
            // write the addr of the device object to registry
            //

            if (DriverObject->Flags & DRVO_BUILTIN_DRIVER) {

                name = driverName.Buffer;
            } else {

                name = serviceName->Buffer;
            }
            StringCchPrintfExW(
                buffer, 
                sizeof(buffer) / sizeof(WCHAR), 
                &end, 
                NULL, 
                0, 
                L"ROOT\\%s", 
                name);   
            length = (ULONG)((PBYTE)end - (PBYTE)buffer);
            deviceName.MaximumLength = sizeof(buffer);
            ASSERT(length <= sizeof(buffer) - 10);
            deviceName.Length = (USHORT)length;
            deviceName.Buffer = buffer;

            status = IopOpenRegistryKeyEx( &enumHandle,
                                           NULL,
                                           &CmRegistryMachineSystemCurrentControlSetEnumName,
                                           KEY_ALL_ACCESS
                                           );
            if (!NT_SUCCESS(status)) {
                goto exit;
            }

            status = IopCreateRegistryKeyEx( &handle1,
                                             enumHandle,
                                             &deviceName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_NON_VOLATILE,
                                             &disposition
                                             );

            if (NT_SUCCESS(status)) {

                deviceName.Buffer[deviceName.Length / sizeof(WCHAR)] =
                           OBJ_NAME_PATH_SEPARATOR;
                deviceName.Length += sizeof(UNICODE_NULL);
                length += sizeof(UNICODE_NULL);
                if (disposition != REG_CREATED_NEW_KEY) {

                    for ( ; ; ) {

                        deviceName.Length = (USHORT)length;
                        PiUlongToInstanceKeyUnicodeString(&instanceName,
                                                          buffer + deviceName.Length / sizeof(WCHAR),
                                                          sizeof(buffer) - deviceName.Length,
                                                          i
                                                          );
                        deviceName.Length = (USHORT)(deviceName.Length + instanceName.Length);
                        status = IopCreateRegistryKeyEx( &handle,
                                                         handle1,
                                                         &instanceName,
                                                         KEY_ALL_ACCESS,
                                                         REG_OPTION_NON_VOLATILE,
                                                         &disposition
                                                         );
                        if (NT_SUCCESS(status)) {

                            if (disposition == REG_CREATED_NEW_KEY) {
                                ZwClose(handle1);
                                break;
                            } else {
                                PKEY_VALUE_FULL_INFORMATION keyValueInformation = NULL;
                                BOOLEAN migratedKey = FALSE, matchingKey = FALSE;

                                //
                                // Check if the key exists because it was
                                // explicitly migrated during textmode setup.
                                //
                                status = IopGetRegistryValue(handle,
                                                             REGSTR_VALUE_MIGRATED,
                                                             &keyValueInformation);
                                if (NT_SUCCESS(status)) {
                                    if ((keyValueInformation->Type == REG_DWORD) &&
                                        (keyValueInformation->DataLength == sizeof(ULONG)) &&
                                        ((*(PULONG)KEY_VALUE_DATA(keyValueInformation)) != 0)) {
                                        migratedKey = TRUE;
                                    }
                                    ExFreePool(keyValueInformation);
                                    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_MIGRATED);
                                    ZwDeleteValueKey(handle, &unicodeName);
                                }

                                if (IopIsReportedAlready(handle, serviceName, ResourceList, &matchingKey)) {

                                    ASSERT(matchingKey);

                                    //
                                    // Write the reported resources to registry in case the irq changed
                                    //

                                    PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
                                    status = IopCreateRegistryKeyEx( &logConfHandle,
                                                                     handle,
                                                                     &unicodeName,
                                                                     KEY_ALL_ACCESS,
                                                                     REG_OPTION_NON_VOLATILE,
                                                                     NULL
                                                                     );
                                    if (NT_SUCCESS(status)) {

                                        //
                                        // Write the ResourceList and and ResourceRequirements to the device instance key
                                        //

                                        if (ResourceList) {
                                            PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_BOOTCONFIG);
                                            ZwSetValueKey(
                                                      logConfHandle,
                                                      &unicodeName,
                                                      TITLE_INDEX_VALUE,
                                                      REG_RESOURCE_LIST,
                                                      ResourceList,
                                                      listSize = IopDetermineResourceListSize(ResourceList)
                                                      );
                                        }
                                        if (ResourceRequirements) {
                                            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_BASIC_CONFIG_VECTOR);
                                            ZwSetValueKey(
                                                      logConfHandle,
                                                      &unicodeName,
                                                      TITLE_INDEX_VALUE,
                                                      REG_RESOURCE_REQUIREMENTS_LIST,
                                                      ResourceRequirements,
                                                      ResourceRequirements->ListSize
                                                      );
                                        }
                                        ZwClose(logConfHandle);
                                    }

                                    PiUnlockPnpRegistry();
                                    IoDeleteDevice(deviceObject);
                                    ZwClose(handle1);
                                    deviceObject = IopDeviceObjectFromDeviceInstance(&deviceName);  // Add a reference
                                    ZwClose(handle);
                                    ZwClose(enumHandle);
                                    ASSERT(deviceObject);
                                    if (deviceObject == NULL) {
                                        status = STATUS_UNSUCCESSFUL;
                                        return status;
                                    }
                                    deviceNode = (PDEVICE_NODE)
                                                  deviceObject->DeviceObjectExtension->DeviceNode;

                                    if (PipAreDriversLoaded(deviceNode) ||
                                        (PipDoesDevNodeHaveProblem(deviceNode) &&
                                         deviceNode->Problem != CM_PROB_NOT_CONFIGURED &&
                                         deviceNode->Problem != CM_PROB_REINSTALL &&
                                         deviceNode->Problem != CM_PROB_FAILED_INSTALL)) {

                                        ObDereferenceObject(deviceObject);

                                        return STATUS_NO_SUCH_DEVICE;
                                    }
                                    goto checkResource;

                                } else if (matchingKey && migratedKey) {
                                    //
                                    // We opened an existing key whose Service
                                    // and Resources match those being reported
                                    // for this device. No device is yet
                                    // reported as using this instance, so we'll
                                    // use it, and treat is as a new key.
                                    //
                                    disposition = REG_CREATED_NEW_KEY;
                                    ZwClose(handle1);
                                    break;

                                } else {
                                    i++;
                                    ZwClose(handle);
                                    continue;
                                }
                            }
                        } else {
                            ZwClose(handle1);
                            ZwClose(enumHandle);
                            goto exit;
                        }
                    }
                } else {

                    //
                    // This is a new device key.  So, instance is 0.  Create it.
                    //

                    PiUlongToInstanceKeyUnicodeString(&instanceName,
                                                      buffer + deviceName.Length / sizeof(WCHAR),
                                                      sizeof(buffer) - deviceName.Length,
                                                      i
                                                      );
                    deviceName.Length = (USHORT)(deviceName.Length + instanceName.Length);
                    status = IopCreateRegistryKeyEx( &handle,
                                                     handle1,
                                                     &instanceName,
                                                     KEY_ALL_ACCESS,
                                                     REG_OPTION_NON_VOLATILE,
                                                     &disposition
                                                     );
                    ZwClose(handle1);
                    if (!NT_SUCCESS(status)) {
                        ZwClose(enumHandle);
                        goto exit;
                    }
                    ASSERT(disposition == REG_CREATED_NEW_KEY);
                }
            } else {
                ZwClose(enumHandle);
                goto exit;
            }

            ASSERT(disposition == REG_CREATED_NEW_KEY);
            newlyCreated = TRUE;

            //
            // Initialize new device instance registry key
            //

            if (ResourceAssigned) {
                PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_NO_RESOURCE_AT_INIT);
                tmpValue = 1;
                ZwSetValueKey(handle,
                              &unicodeName,
                              TITLE_INDEX_VALUE,
                              REG_DWORD,
                              &tmpValue,
                              sizeof(tmpValue)
                              );
            }
            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
            logConfHandle = NULL;
            status = IopCreateRegistryKeyEx( &logConfHandle,
                                             handle,
                                             &unicodeName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_NON_VOLATILE,
                                             NULL
                                             );

            ASSERT(status == STATUS_SUCCESS);

            if (NT_SUCCESS(status)) {

                //
                // Write the ResourceList and and ResourceRequirements to the logconf key under
                // device instance key.
                //

                if (ResourceList) {
                    PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_BOOTCONFIG);
                    ZwSetValueKey(
                              logConfHandle,
                              &unicodeName,
                              TITLE_INDEX_VALUE,
                              REG_RESOURCE_LIST,
                              ResourceList,
                              listSize = IopDetermineResourceListSize(ResourceList)
                              );
                }
                if (ResourceRequirements) {
                    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_BASIC_CONFIG_VECTOR);
                    ZwSetValueKey(
                              logConfHandle,
                              &unicodeName,
                              TITLE_INDEX_VALUE,
                              REG_RESOURCE_REQUIREMENTS_LIST,
                              ResourceRequirements,
                              ResourceRequirements->ListSize
                              );
                }
                //ZwClose(logConfHandle);
            }

            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_CONFIG_FLAGS);
            tmpValue = CONFIGFLAG_FINISH_INSTALL;
            ZwSetValueKey(handle,
                          &unicodeName,
                          TITLE_INDEX_VALUE,
                          REG_DWORD,
                          &tmpValue,
                          sizeof(tmpValue)
                          );

            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_LEGACY);
            tmpValue = 0;
            ZwSetValueKey(
                        handle,
                        &unicodeName,
                        TITLE_INDEX_VALUE,
                        REG_DWORD,
                        &tmpValue,
                        sizeof(ULONG)
                        );

            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
            controlHandle = NULL;
            IopCreateRegistryKeyEx( &controlHandle,
                                    handle,
                                    &unicodeName,
                                    KEY_ALL_ACCESS,
                                    REG_OPTION_VOLATILE,
                                    NULL
                                    );

            ASSERT(status == STATUS_SUCCESS);

            if (NT_SUCCESS(status)) {

                PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_DEVICE_REPORTED);
                tmpValue = 1;
                status = ZwSetValueKey(controlHandle,
                                       &unicodeName,
                                       TITLE_INDEX_VALUE,
                                       REG_DWORD,
                                       &tmpValue,
                                       sizeof(ULONG)
                                       );
                status = ZwSetValueKey(handle,
                                       &unicodeName,
                                       TITLE_INDEX_VALUE,
                                       REG_DWORD,
                                       &tmpValue,
                                       sizeof(ULONG)
                                       );

                //ZwClose(controlHandle);
            }

            ZwClose(enumHandle);

            //
            // Create Service value name and set it to the calling driver's service
            // key name.
            //

            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_SERVICE);
            p = (PWSTR)ExAllocatePool(PagedPool, serviceName->Length + sizeof(UNICODE_NULL));
            if (!p) {
                PiUnlockPnpRegistry();
                goto CleanupRegistry;
            }
            RtlCopyMemory(p, serviceName->Buffer, serviceName->Length);
            p[serviceName->Length / sizeof (WCHAR)] = UNICODE_NULL;
            ZwSetValueKey(
                        handle,
                        &unicodeName,
                        TITLE_INDEX_VALUE,
                        REG_SZ,
                        p,
                        serviceName->Length + sizeof(UNICODE_NULL)
                        );
            if (DriverObject->Flags & DRVO_BUILTIN_DRIVER) {
                deviceNode->ServiceName = *serviceName;
            } else {
                ExFreePool(p);
            }

            PiUnlockPnpRegistry();
            //ZwClose(logConfHandle);
            //ZwClose(controlHandle);
            //ZwClose(handle);

            //
            // Register the device for the driver and save the device
            // instance path in device node.
            //

            if (!(DriverObject->Flags & DRVO_BUILTIN_DRIVER)) {
                PpDeviceRegistration( &deviceName,
                                      TRUE,
                                      &deviceNode->ServiceName
                                      );
            }
            status = PipConcatenateUnicodeStrings(&deviceNode->InstancePath, &deviceName, NULL);
            if (NT_SUCCESS(status)) {

                deviceNode->Flags = DNF_MADEUP | DNF_ENUMERATED;

                PipSetDevNodeState(deviceNode, DeviceNodeInitialized, NULL);

                PpDevNodeInsertIntoTree(IopRootDeviceNode, deviceNode);

                //
                // Add an entry into the table to set up a mapping between the DO
                // and the instance path.
                //

                status = IopMapDeviceObjectToDeviceInstance(deviceObject, &deviceNode->InstancePath);
                ASSERT(NT_SUCCESS(status));

                //
                // Add a reference to the DeviceObject for ourself
                //

                ObReferenceObject(deviceObject);

                IopNotifySetupDeviceArrival(deviceObject, NULL, FALSE);

                goto checkResource;
            }
        }
        IoDeleteDevice(deviceObject);
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return status;
checkResource:


    //
    // At this point the *DeviceObject is established.  Check if we need to report resources for
    // the detected device.  If we failed to
    //

    if (ResourceAssigned) {
        //ASSERT(deviceNode->ResourceList == NULL);      // make sure we have not reported resources yet.

        //
        // If the driver specifies it already has acquired the resource.  We will put a flag
        // in the device instance path to not to allocate resources at boot time.  The Driver
        // may do detection and report it again.
        //

        deviceNode->Flags |= DNF_NO_RESOURCE_REQUIRED; // do not need resources for this boot.
        if (ResourceList) {

            //
            // Write the resource list to the reported device instance key.
            //

            listSize = IopDetermineResourceListSize(ResourceList);
            IopWriteAllocatedResourcesToRegistry (deviceNode, ResourceList, listSize);
        }
    } else {
        BOOLEAN conflict;

        if (ResourceList && ResourceList->Count && ResourceList->List[0].PartialResourceList.Count) {
            if (listSize == 0) {
                listSize = IopDetermineResourceListSize(ResourceList);
            }
            cmResource = (PCM_RESOURCE_LIST) ExAllocatePool(PagedPool, listSize);
            if (cmResource) {
                RtlCopyMemory(cmResource, ResourceList, listSize);
                PiWstrToUnicodeString(&unicodeName, PNPMGR_STR_PNP_MANAGER);
                status = IoReportResourceUsageInternal(
                             ArbiterRequestLegacyReported,
                             &unicodeName,                  // DriverClassName OPTIONAL,
                             deviceObject->DriverObject,    // DriverObject,
                             NULL,                          // DriverList OPTIONAL,
                             0,                             // DriverListSize OPTIONAL,
                             deviceNode->PhysicalDeviceObject,
                                                            // DeviceObject OPTIONAL,
                             cmResource,                    // DeviceList OPTIONAL,
                             listSize,                      // DeviceListSize OPTIONAL,
                             FALSE,                         // OverrideConflict,
                             &conflict                      // ConflictDetected
                             );
                ExFreePool(cmResource);
                if (!NT_SUCCESS(status) || conflict) {
                    status = STATUS_CONFLICTING_ADDRESSES;
                    PipSetDevNodeProblem(deviceNode, CM_PROB_NORMAL_CONFLICT);
                }
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
                PipSetDevNodeProblem(deviceNode, CM_PROB_OUT_OF_MEMORY);
            }
        } else {
            ASSERT(ResourceRequirements == NULL);
            deviceNode->Flags |= DNF_NO_RESOURCE_REQUIRED; // do not need resources for this boot.
        }
    }

    if (NT_SUCCESS(status)) {

        IopDoDeferredSetInterfaceState(deviceNode);

        PipSetDevNodeState(deviceNode, DeviceNodeStartPostWork, NULL);

        *DeviceObject = deviceObject;
        if (newlyCreated) {
            if (controlHandle) {
                ZwClose(controlHandle);
            }
            if (logConfHandle) {
                ZwClose(logConfHandle);
            }
            ZwClose(handle);
        }

        //
        // Make sure we enumerate and process this device's children.
        //

        PipRequestDeviceAction(deviceObject, ReenumerateDeviceOnly, FALSE, 0, NULL, NULL);

        return status;

    }
CleanupRegistry:
    IopReleaseDeviceResources(deviceNode, FALSE);
    if (newlyCreated) {
        IoDeleteDevice(deviceObject);
        if (controlHandle) {
            ZwDeleteKey(controlHandle);
        }
        if (logConfHandle) {
            ZwDeleteKey(logConfHandle);
        }
        if (handle) {
            ZwDeleteKey(handle);
        }
    }
    return status;
exit:
    PiUnlockPnpRegistry();
    IoDeleteDevice(*DeviceObject);
    return status;
}

BOOLEAN
IopIsReportedAlready(
    IN HANDLE Handle,
    IN PUNICODE_STRING ServiceName,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PBOOLEAN MatchingKey
    )

/*++

Routine Description:

    This routine determines if the reported device instance is already reported
    or not.

Parameters:

    Handle - Supplies a handle to the reported device instance key.

    ServiceName - supplies a pointer to the unicode service key name.

    ResourceList - supplies a pointer to the reported Resource list.

    MatchingKey - supplies a pointer to a variable to receive whether the
        ServiceName and ResourceList properties for this key match those
        reported.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PKEY_VALUE_FULL_INFORMATION keyValueInfo1 = NULL, keyValueInfo2 = NULL;
    NTSTATUS status;
    UNICODE_STRING unicodeName;
    HANDLE logConfHandle, controlHandle = NULL;
    BOOLEAN returnValue = FALSE;
    PCM_RESOURCE_LIST cmResource = NULL;
    ULONG tmpValue;

    PAGED_CODE();

    //
    // Assume no match unless we determine otherwise.
    //
    *MatchingKey = FALSE;

    //
    // Check if "Service" value matches what the caller passed in.
    //

    status = IopGetRegistryValue(Handle, REGSTR_VALUE_SERVICE, &keyValueInfo1);
    if (NT_SUCCESS(status)) {
        if ((keyValueInfo1->Type == REG_SZ) &&
            (keyValueInfo1->DataLength != 0)) {
            unicodeName.Buffer = (PWSTR)KEY_VALUE_DATA(keyValueInfo1);
            unicodeName.MaximumLength = unicodeName.Length = (USHORT)keyValueInfo1->DataLength;
            if (unicodeName.Buffer[(keyValueInfo1->DataLength / sizeof(WCHAR)) - 1] == UNICODE_NULL) {
                unicodeName.Length -= sizeof(WCHAR);
            }
            if (RtlEqualUnicodeString(ServiceName, &unicodeName, TRUE)) {

                //
                // Next check if resources are the same
                //

                PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
                status = IopOpenRegistryKeyEx( &logConfHandle,
                                               Handle,
                                               &unicodeName,
                                               KEY_READ
                    );
                if (NT_SUCCESS(status)) {
                    status = IopGetRegistryValue(logConfHandle,
                                                 REGSTR_VAL_BOOTCONFIG,
                                                 &keyValueInfo2);
                    ZwClose(logConfHandle);
                    if (NT_SUCCESS(status)) {
                        if ((keyValueInfo2->Type == REG_RESOURCE_LIST) &&
                            (keyValueInfo2->DataLength != 0)) {
                            cmResource = (PCM_RESOURCE_LIST)KEY_VALUE_DATA(keyValueInfo2);
                            if (ResourceList && cmResource &&
                                PipIsDuplicatedDevices(ResourceList, cmResource, NULL, NULL)) {
                                *MatchingKey = TRUE;
                            }
                        }
                    }
                }
                if (!ResourceList && !cmResource) {
                    *MatchingKey = TRUE;
                }
            }
        }
    }

    //
    // If this registry key is for a device reported during the same boot
    // this is not a duplicate.
    //

    PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
    status = IopOpenRegistryKeyEx( &controlHandle,
                                   Handle,
                                   &unicodeName,
                                   KEY_ALL_ACCESS
                                   );
    if (NT_SUCCESS(status)) {
        status = IopGetRegistryValue(controlHandle,
                                     REGSTR_VALUE_DEVICE_REPORTED,
                                     &keyValueInfo1);
        if (NT_SUCCESS(status)) {
            goto exit;
        }

        if (*MatchingKey == TRUE) {

            returnValue = TRUE;

            //
            // Mark this key has been used.
            //

            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_DEVICE_REPORTED);
            tmpValue = 1;
            status = ZwSetValueKey(controlHandle,
                                   &unicodeName,
                                   TITLE_INDEX_VALUE,
                                   REG_DWORD,
                                   &tmpValue,
                                   sizeof(ULONG)
                                   );
            if (!NT_SUCCESS(status)) {
                returnValue = FALSE;
            }
        }
    }

exit:
    if (controlHandle) {
        ZwClose(controlHandle);
    }

    if (keyValueInfo1) {
        ExFreePool(keyValueInfo1);
    }
    if (keyValueInfo2) {
        ExFreePool(keyValueInfo2);
    }
    return returnValue;
}




VOID
IoInvalidateDeviceState(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This API will cause the PnP manager to send the specified PDO an IRP_MN_QUERY_PNP_DEVICE_STATE
    IRP.

Parameters:

    PhysicalDeviceObject - Provides a pointer to the PDO who's state is to be invalidated.

Return Value:

    none.

--*/
{
    PDEVICE_NODE deviceNode;

    ASSERT_PDO(PhysicalDeviceObject);

    //
    // If the call was made before PnP completes device enumeration
    // we can safely ignore it.  PnP manager will do it without
    // driver's request.  If the device was already removed or surprised
    // removed then ignore it as well since this is only valid for started
    // devices.
    //

    deviceNode = (PDEVICE_NODE)PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;

    if (deviceNode->State != DeviceNodeStarted) {
        return;
    }

    PipRequestDeviceAction( PhysicalDeviceObject,
                            RequeryDeviceState,
                            FALSE,
                            0,
                            NULL,
                            NULL);
}


NTSTATUS
IopQueueDeviceWorkItem(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN VOID (*WorkerRoutine)(PVOID),
    IN PVOID Context
    )

/*++

Routine Description:

    This API will cause the PnP manager to send the specified PDO an
    IRP_MN_QUERY_PNP_DEVICE_STATE IRP.

Parameters:

    PhysicalDeviceObject - Provides a pointer to the PDO who's state is to be
    invalidated.

Return Value:

    none.

--*/

{
    PDEVICE_WORK_ITEM deviceWorkItem;

    //
    // Since this routine can be called at DPC level we need to queue
    // a work item and process it when the irql drops.
    //

    deviceWorkItem = ExAllocatePool(NonPagedPool, sizeof(DEVICE_WORK_ITEM));
    if (deviceWorkItem == NULL) {

        //
        // Failed to allocate memory for work item.  Nothing we can do ...
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ObReferenceObject(PhysicalDeviceObject);
    deviceWorkItem->DeviceObject = PhysicalDeviceObject;
    deviceWorkItem->Context = Context;

    ExInitializeWorkItem( &deviceWorkItem->WorkItem,
                          WorkerRoutine,
                          deviceWorkItem);

    //
    // Queue a work item to do the enumeration
    //

    ExQueueWorkItem( &deviceWorkItem->WorkItem, DelayedWorkQueue );

    return STATUS_SUCCESS;
}

//
// Private routines
//
VOID
IopResourceRequirementsChanged(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN BOOLEAN StopRequired
    )

/*++

Routine Description:

    This routine handles request of device resource requirements list change.

Parameters:

    PhysicalDeviceObject - Provides a pointer to the PDO who's state is to be invalidated.

    StopRequired - Supplies a BOOLEAN value to indicate if the resources reallocation needs
                   to be done after device stopped.

Return Value:

    none.

--*/

{
    PAGED_CODE();

    PipRequestDeviceAction( PhysicalDeviceObject,
                            ResourceRequirementsChanged,
                            FALSE,
                            StopRequired,
                            NULL,
                            NULL );
}

BOOLEAN
IoIsWdmVersionAvailable(
    IN UCHAR MajorVersion,
    IN UCHAR MinorVersion
    )

/*++

Routine Description:

    This routine reports whether WDM functionality is available that
    is greater than or equal to the specified major and minor version.

Parameters:

    MajorVersion - Supplies the WDM major version that is required.

    MinorVersion - Supplies the WDM minor version that is required.

Return Value:

    If WDM support is available at _at least_ the requested level, the
    return value is TRUE, otherwise it is FALSE.

--*/

{
    return ((MajorVersion < WDM_MAJORVERSION) ||
            ((MajorVersion == WDM_MAJORVERSION) && (MinorVersion <= WDM_MINORVERSION)));
}

NTKERNELAPI
PDMA_ADAPTER
IoGetDmaAdapter(
    IN PDEVICE_OBJECT PhysicalDeviceObject    OPTIONAL,
    IN PDEVICE_DESCRIPTION DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function returns the appropriate DMA adapter object for the device
    defined in the device description structure.  This code is a wrapper
    which queries the bus interface standard and then calls the returned
    get DMA adapter function.   If an adapter object was not retrieved then
    a legecy function is attempted.

Arguments:

    PhysicalDeviceObject - Optionally, supplies the PDO for the device
        requesting the DMA adapter.  If not supplied, this routine performs the
        function of the non-PnP HalGetDmaAdapter routine.

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
        may be allocated by the device driver.

Return Value:

    A pointer to the requested adapter object or NULL if an adapter could not
    be created.

--*/

{
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    IO_STATUS_BLOCK ioStatusBlock;
    PIO_STACK_LOCATION irpStack;
    BUS_INTERFACE_STANDARD busInterface;
    PDMA_ADAPTER dmaAdapter = NULL;
    PDEVICE_DESCRIPTION deviceDescriptionToUse;
    DEVICE_DESCRIPTION privateDeviceDescription;
    ULONG resultLength;
    PDEVICE_OBJECT targetDevice;

    PAGED_CODE();

    if (PhysicalDeviceObject != NULL) {

        ASSERT_PDO(PhysicalDeviceObject);

        //
        // First off, determine whether or not the caller has requested that we
        // automatically fill in the proper InterfaceType value into the
        // DEVICE_DESCRIPTION structure used in retrieving the DMA adapter object.
        // If so, then retrieve that interface type value into our own copy of
        // the DEVICE_DESCRIPTION buffer.
        //
        if ((DeviceDescription->InterfaceType == InterfaceTypeUndefined) ||
            (DeviceDescription->InterfaceType == PNPBus)) {
            //
            // Make a copy of the caller-supplied device description, so
            // we can modify it to fill in the correct interface type.
            //
            RtlCopyMemory(&privateDeviceDescription,
                          DeviceDescription,
                          sizeof(DEVICE_DESCRIPTION)
                         );

            status = IoGetDeviceProperty(PhysicalDeviceObject,
                                         DevicePropertyLegacyBusType,
                                         sizeof(privateDeviceDescription.InterfaceType),
                                         (PVOID)&(privateDeviceDescription.InterfaceType),
                                         &resultLength
                                        );

            if (!NT_SUCCESS(status)) {

                ASSERT(status == STATUS_OBJECT_NAME_NOT_FOUND);

                //
                // Since the enumerator didn't tell us what interface type to
                // use for this PDO, we'll fall back to our default.  This is
                // ISA for machines where the legacy bus is ISA or EISA, and it
                // is MCA for machines whose legacy bus is MicroChannel.
                //
                privateDeviceDescription.InterfaceType = PnpDefaultInterfaceType;
            }

            //
            // Use our private device description buffer from now on.
            //
            deviceDescriptionToUse = &privateDeviceDescription;

        } else {
            //
            // Use the caller-supplied device description.
            //
            deviceDescriptionToUse = DeviceDescription;
        }

        //
        // Now, query for the BUS_INTERFACE_STANDARD interface from the PDO.
        //
        KeInitializeEvent( &event, NotificationEvent, FALSE );

        targetDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);

        irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                            targetDevice,
                                            NULL,
                                            0,
                                            NULL,
                                            &event,
                                            &ioStatusBlock );

        if (irp == NULL) {
            return NULL;
        }

        RtlZeroMemory( &busInterface, sizeof( BUS_INTERFACE_STANDARD ));

        irpStack = IoGetNextIrpStackLocation( irp );
        irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
        irpStack->Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_BUS_INTERFACE_STANDARD;
        irpStack->Parameters.QueryInterface.Size = sizeof( BUS_INTERFACE_STANDARD );
        irpStack->Parameters.QueryInterface.Version = 1;
        irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) &busInterface;
        irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

        //
        // Initialize the status to error in case the ACPI driver decides not to
        // set it correctly.
        //

        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = IoCallDriver(targetDevice, irp);

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
            status = ioStatusBlock.Status;

        }

        ObDereferenceObject(targetDevice);

        if (NT_SUCCESS( status)) {

            if (busInterface.GetDmaAdapter != NULL) {


                dmaAdapter = busInterface.GetDmaAdapter( busInterface.Context,
                                                         deviceDescriptionToUse,
                                                         NumberOfMapRegisters );

            }

            //
            // Dereference the interface
            //

            busInterface.InterfaceDereference( busInterface.Context );
        }

    } else {
        //
        // The caller didn't specify the PDO, so we'll just use the device
        // description exactly as they specified it (i.e., we can't attempt to
        // make our own determination of what interface type to use).
        //
        deviceDescriptionToUse = DeviceDescription;
    }

    //
    // If there is no DMA adapter, try the legacy mode code.
    //

#if !defined(NO_LEGACY_DRIVERS)

    if (dmaAdapter == NULL) {

        dmaAdapter = HalGetDmaAdapter( PhysicalDeviceObject,
                                       deviceDescriptionToUse,
                                       NumberOfMapRegisters );

    }

#endif // NO_LEGACY_DRIVERS

    return( dmaAdapter );
}

NTSTATUS
IopOpenDeviceParametersSubkey(
    OUT HANDLE *ParamKeyHandle,
    IN  HANDLE ParentKeyHandle,
    IN  PUNICODE_STRING SubKeyString,
    IN  ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine opens or creates a "Device Parameters" subkey of the specified
    ParentKeyHandle.  If this routine creates a new "Device Parameters" subkey,
    it will apply the necessary ACLs to it.

Parameters:

    ParamKeyHandle - Supplies the address of a variable that receives a handle
        to the opened "Device Parameters" subkey.  The caller must call ZwClose
        to close the handle returned from this api when access is no longer
        required.

    ParentKeyHandle - Supplies a handle to the base key off which the path
        specified by the SubStringKey parameter will be opened.

    SubKeyString - Supplies a path to the subkey that should be opened under the
        ParentKeyHandle, such that the resulting key will serve as the parent of
        the "Device Parameters" subkey.

    DesiredAccess - Specifies the access mask for the key to be opened.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS                    status;
    ULONG                       disposition;
    ULONG                       lengthSD;
    PSECURITY_DESCRIPTOR        oldSD = NULL;
    SECURITY_DESCRIPTOR         newSD;
    ACL_SIZE_INFORMATION        aclSizeInfo;
    PACL                        oldDacl;
    PACL                        newDacl = NULL;
    ULONG                       sizeDacl;
    BOOLEAN                     daclPresent, daclDefaulted;
    PACCESS_ALLOWED_ACE         ace;
    ULONG                       aceIndex;
    HANDLE                      deviceKeyHandle;
    UNICODE_STRING              deviceParamString;

    //
    // First try and open the device key
    //
    status = IopOpenRegistryKeyEx( &deviceKeyHandle,
                                   ParentKeyHandle,
                                   SubKeyString,
                                   KEY_WRITE
                                   );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    PiWstrToUnicodeString(&deviceParamString, REGSTR_KEY_DEVICEPARAMETERS);

    status = IopCreateRegistryKeyEx( ParamKeyHandle,
                                     deviceKeyHandle,
                                     &deviceParamString,
                                     DesiredAccess | READ_CONTROL | WRITE_DAC,
                                     REG_OPTION_NON_VOLATILE,
                                     &disposition
                                     );

    ZwClose(deviceKeyHandle);

    if (!NT_SUCCESS(status)) {
        IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                        "IopOpenDeviceParametersSubkey: IopCreateRegistryKeyEx failed, status = %8.8X\n", status));
        return status;
    }

    if (disposition == REG_CREATED_NEW_KEY) {

        //
        // Need to set an ACL on the key if it was created
        //
        //
        // Get the security descriptor from the key so we can add the
        // administrator.
        //
        status = ZwQuerySecurityObject(*ParamKeyHandle,
                                       DACL_SECURITY_INFORMATION,
                                       NULL,
                                       0,
                                       &lengthSD);

        if (status == STATUS_BUFFER_TOO_SMALL) {
            oldSD = ExAllocatePool( PagedPool, lengthSD );

            if (oldSD != NULL) {

                status = ZwQuerySecurityObject(*ParamKeyHandle,
                                               DACL_SECURITY_INFORMATION,
                                               oldSD,
                                               lengthSD,
                                               &lengthSD);
                if (!NT_SUCCESS(status)) {
                    IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                                    "IopOpenDeviceParametersSubkey: ZwQuerySecurityObject failed, status = %8.8X\n", status));
                    goto Cleanup0;
                }
            } else  {

                IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                                "IopOpenDeviceParametersSubkey: Failed to allocate memory, status = %8.8X\n", status));
                status = STATUS_NO_MEMORY;
                goto Cleanup0;
            }
        } else {
           IopDbgPrint((    IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: ZwQuerySecurityObject failed %8.8X\n",status));
           status = STATUS_UNSUCCESSFUL;
           goto Cleanup0;
        }

        status = RtlCreateSecurityDescriptor( (PSECURITY_DESCRIPTOR) &newSD,
                                              SECURITY_DESCRIPTOR_REVISION );
        ASSERT( NT_SUCCESS( status ) );

        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: RtlCreateSecurityDescriptor failed, status = %8.8X\n", status));
            goto Cleanup0;
        }
        //
        // get the current DACL
        //
        status = RtlGetDaclSecurityDescriptor(oldSD, &daclPresent, &oldDacl, &daclDefaulted);

        //
        // RtlGetDaclSecurityDescriptor will return either SUCCESS or a SD VERSION error
        // if latter, then something wrong with ZwQuerySecurityObject
        // or RtlGetDaclSecurityDescriptor changed
        //

        ASSERT(NT_SUCCESS(status));

        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_ERROR_LEVEL,
                            "IopOpenDeviceParametersSubkey: RtlGetDaclSecurityDescriptor failed, status = %8.8X\n", status));
            goto Cleanup0;
        }

        //
        // calculate the size of the new DACL
        //
        if (daclPresent) {

            status = RtlQueryInformationAcl( oldDacl,
                                             &aclSizeInfo,
                                             sizeof(ACL_SIZE_INFORMATION),
                                             AclSizeInformation);


            if (!NT_SUCCESS(status)) {

                IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                                "IopOpenDeviceParametersSubkey: RtlQueryInformationAcl failed, status = %8.8X\n", status));
                goto Cleanup0;
            }

            sizeDacl = aclSizeInfo.AclBytesInUse;
        } else {
            sizeDacl = sizeof(ACL);
            aclSizeInfo.AceCount = 0;
        }

        sizeDacl += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(SeAliasAdminsSid) - sizeof(ULONG);

        //
        // create and initialize the new DACL
        //
        newDacl = ExAllocatePool(PagedPool, sizeDacl);

        if (newDacl == NULL) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: ExAllocatePool failed\n"));
            goto Cleanup0;
        }

        status = RtlCreateAcl(newDacl, sizeDacl, ACL_REVISION);

        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: RtlCreateAcl failed, status = %8.8X\n", status));
            goto Cleanup0;
        }

        //
        // copy the current (original) DACL into this new one
        //
        if (daclPresent) {

            for (aceIndex = 0; aceIndex < aclSizeInfo.AceCount; aceIndex++) {

                status = RtlGetAce(oldDacl, aceIndex, (PVOID *)&ace);

                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                                    "IopOpenDeviceParametersSubkey: RtlGetAce failed, status = %8.8X\n", status));
                    goto Cleanup0;
                }

                //
                // We need to skip copying any ACEs which refer to the Administrator
                // to ensure that our full control ACE is the one and only.
                //
                if ((ace->Header.AceType != ACCESS_ALLOWED_ACE_TYPE &&
                     ace->Header.AceType != ACCESS_DENIED_ACE_TYPE) ||
                     !RtlEqualSid((PSID)&ace->SidStart, SeAliasAdminsSid)) {

                    status = RtlAddAce( newDacl,
                                        ACL_REVISION,
                                        ~0U,
                                        ace,
                                        ace->Header.AceSize
                                        );

                    if (!NT_SUCCESS(status)) {

                        IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                                        "IopOpenDeviceParametersSubkey: RtlAddAce failed, status = %8.8X\n", status));
                        goto Cleanup0;
                    }
                }
            }
        }

        //
        // and my new admin-full ace to this new DACL
        //
        status = RtlAddAccessAllowedAceEx( newDacl,
                                           ACL_REVISION,
                                           CONTAINER_INHERIT_ACE,
                                           KEY_ALL_ACCESS,
                                           SeAliasAdminsSid
                                           );
        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: RtlAddAccessAllowedAceEx failed, status = %8.8X\n", status));
            goto Cleanup0;
        }

        //
        // Set the new DACL in the absolute security descriptor
        //
        status = RtlSetDaclSecurityDescriptor( (PSECURITY_DESCRIPTOR) &newSD,
                                               TRUE,
                                               newDacl,
                                               FALSE
                                               );

        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: RtlSetDaclSecurityDescriptor failed, status = %8.8X\n", status));
            goto Cleanup0;
        }

        //
        // validate the new security descriptor
        //
        status = RtlValidSecurityDescriptor(&newSD);

        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: RtlValidSecurityDescriptor failed, status = %8.8X\n", status));
            goto Cleanup0;
        }


        status = ZwSetSecurityObject( *ParamKeyHandle,
                                      DACL_SECURITY_INFORMATION,
                                      &newSD
                                      );
        if (!NT_SUCCESS(status)) {

            IopDbgPrint((   IOP_IOAPI_WARNING_LEVEL,
                            "IopOpenDeviceParametersSubkey: ZwSetSecurityObject failed, status = %8.8X\n", status));
            goto Cleanup0;
        }
    }

    //
    // If we encounter an error updating the DACL we still return success.
    //

Cleanup0:

    if (oldSD != NULL) {
        ExFreePool(oldSD);
    }

    if (newDacl != NULL) {
        ExFreePool(newDacl);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PpCreateLegacyDeviceIds(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DriverName,
    IN PCM_RESOURCE_LIST Resources
    )
{
    PIOPNP_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PWCHAR buffer, end;

    ULONG length = 0;

    INTERFACE_TYPE interface;
    static const WCHAR* interfaceNames[] ={L"",
                              L"Internal",
                              L"Isa",
                              L"Eisa",
                              L"MicroChannel",
                              L"TurboChannel",
                              L"PCIBus",
                              L"VMEBus",
                              L"NuBus",
                              L"PCMCIABus",
                              L"CBus",
                              L"MPIBus",
                              L"MPSABus",
                              L"ProcessorInternal",
                              L"InternalPowerBus",
                              L"PNPISABus",
                              L"PNPBus",
                              L"Other",
                              L"Root"};


    PAGED_CODE();

    if(Resources != NULL) {

        interface = Resources->List[0].InterfaceType;

        if((interface > MaximumInterfaceType) ||
           (interface < InterfaceTypeUndefined)) {
            interface = MaximumInterfaceType;
        }
    } else {
        interface = Internal;
    }

    interface++;

    //
    // The compatible ID generated will be
    // DETECTED<InterfaceName>\<Driver Name>
    //

    length = (ULONG)(wcslen(LEGACY_COMPATIBLE_ID_BASE) * sizeof(WCHAR));
    length += (ULONG)(wcslen(interfaceNames[interface]) * sizeof(WCHAR));
    length += sizeof(L'\\');
    length += DriverName->Length;
    length += sizeof(UNICODE_NULL);

    length += (ULONG)(wcslen(LEGACY_COMPATIBLE_ID_BASE) * sizeof(WCHAR));
    length += sizeof(L'\\');
    length += DriverName->Length;
    length += sizeof(UNICODE_NULL) * 2;

    buffer = ExAllocatePool(PagedPool, length);
    deviceExtension->CompatibleIdList = buffer;

    if(buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    deviceExtension->CompatibleIdListSize = length;

    RtlZeroMemory(buffer, length);

    StringCchPrintfExW(
        buffer, 
        length / sizeof(WCHAR), 
        &end,
        NULL,
        0,
        L"%ws%ws\\%wZ", 
        LEGACY_COMPATIBLE_ID_BASE,
        interfaceNames[interface],
        DriverName);

    //
    // Adjust the buffer to point to the end and generate the second
    // compatible id string.
    //

    length = (ULONG)(end - buffer);
    buffer = end + 1;

    StringCchPrintfW(buffer, length, L"%ws\\%wZ", LEGACY_COMPATIBLE_ID_BASE, DriverName);

    return STATUS_SUCCESS;
}


BOOLEAN
IopAppendLegacyVeto(
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context,
    IN PUNICODE_STRING VetoName
    )
/*++

Routine Description:

    This routine appends a veto (driver name or device instance path) to the
    veto list.

Parameters:

    Context - An IO_GET_LEGACY_VETO_LIST_CONTEXT pointer.

    VetoName - The name of the driver/device to append to the veto list.

ReturnValue:

    A BOOLEAN which indicates whether the append operation was successful.

--*/
{
    ULONG Length;
    PWSTR Buffer;

    //
    // Compute the length of the (new) veto list.  This is the length of
    // the old veto list + the size of the new veto + the size of the
    // terminating '\0'.
    //

    Length = Context->VetoListLength + VetoName->Length + sizeof (WCHAR);

    //
    // Allocate the new veto list.
    //

    Buffer = ExAllocatePool(
                 NonPagedPool,
                 Length
             );

    //
    // If we succeeded in allocating the new veto list, copy the old
    // veto list to the new list, append the new veto, and finally,
    // append a terminating '\0'.  Otherwise, update the status to
    // indicate an error; IopGetLegacyVetoList will free the veto list
    // before it returns.
    //

    if (Buffer != NULL) {

        if (*Context->VetoList != NULL) {

            RtlCopyMemory(
                Buffer,
                *Context->VetoList,
                Context->VetoListLength
            );

            ExFreePool(*Context->VetoList);

        }

        RtlCopyMemory(
            &Buffer[Context->VetoListLength / sizeof (WCHAR)],
            VetoName->Buffer,
            VetoName->Length
        );

        Buffer[Length / sizeof (WCHAR) - 1] = L'\0';

        *Context->VetoList = Buffer;
        Context->VetoListLength = Length;

        return TRUE;

    } else {

        *Context->Status = STATUS_INSUFFICIENT_RESOURCES;

        return FALSE;

    }
}

BOOLEAN
IopGetLegacyVetoListDevice(
    IN PDEVICE_NODE DeviceNode,
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    )
/*++

Routine Description:

    This routine determines whether the specified device node should be added to
    the veto list, and if so, calls IopAppendLegacyVeto to add it.

Parameters:

    DeviceNode - The device node to be added.

    Context - An IO_GET_LEGACY_VETO_LIST_CONTEXT pointer.

ReturnValue:

    A BOOLEAN value which indicates whether the device node enumeration
    process should be terminated or not.

--*/
{
    PDEVICE_CAPABILITIES DeviceCapabilities;

    //
    // A device node should be added added to the veto list, if it has the
    // NonDynamic capability.
    //

    DeviceCapabilities = IopDeviceNodeFlagsToCapabilities(DeviceNode);

    if (DeviceCapabilities->NonDynamic) {

        //
        // Update the veto type.  If an error occurrs while adding the device
        // node to the veto list, or the caller did not provide a veto list
        // pointer, terminate the enumeration process now.
        //

        *Context->VetoType = PNP_VetoLegacyDevice;

        if (Context->VetoList != NULL) {

            if (!IopAppendLegacyVeto(Context, &DeviceNode->InstancePath)) {
                return FALSE;
            }

        } else {

            return FALSE;

        }

    }

    return TRUE;
}

BOOLEAN
IopGetLegacyVetoListDeviceNode(
    IN PDEVICE_NODE DeviceNode,
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    )
/*++

Routine Description:

    This routine recusively walks the device tree, invoking
    IopGetLegacyVetoListDevice to add device nodes to the veto list
    (as appropriate).

Parameters:

    DeviceNode - The device node.

    Context - An IO_GET_LEGACY_VETO_LIST_CONTEXT pointer.


ReturnValue:

    A BOOLEAN value which indicates whether the device tree enumeration
    process should be terminated or not.

--*/
{
    PDEVICE_NODE Child;

    //
    // Determine whether the device node should be added to the veto
    // list and add it.  If an operation is unsuccessful or we determine
    // the veto type but the caller doesn't need the veto list, then we
    // terminate our search now.
    //

    if (!IopGetLegacyVetoListDevice(DeviceNode, Context)) {
        return FALSE;
    }

    //
    // Call ourselves recursively to enumerate our children.  If while
    // enumerating our children we determine we can terminate the search
    // prematurely, do so.
    //

    for (Child = DeviceNode->Child;
         Child != NULL;
         Child = Child->Sibling) {

        if (!IopGetLegacyVetoListDeviceNode(Child, Context)) {
            return FALSE;
        }

    }

    return TRUE;
}

VOID
IopGetLegacyVetoListDrivers(
    IN PIO_GET_LEGACY_VETO_LIST_CONTEXT Context
    )
{
    PDRIVER_OBJECT driverObject;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING driverString;
    POBJECT_DIRECTORY_INFORMATION dirInfo;
    HANDLE directoryHandle;
    ULONG dirInfoLength, neededLength, dirContext;
    NTSTATUS status;
    BOOLEAN restartScan;

    dirInfoLength = 0;
    dirInfo = NULL;
    restartScan = TRUE;

    //
    // Get handle to \\Driver directory
    //

    PiWstrToUnicodeString(&driverString, L"\\Driver");

    InitializeObjectAttributes(&attributes,
                               &driverString,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL
                               );

    status = ZwOpenDirectoryObject(&directoryHandle,
                                   DIRECTORY_QUERY,
                                   &attributes
                                   );
    if (!NT_SUCCESS(status)) {
        *Context->Status = status;
        return;
    }

    for (;;) {

        //
        // Get info on next object in directory.  If the buffer is too
        // small, reallocate it and try again.  Otherwise, any failure
        // including STATUS_NO_MORE_ENTRIES breaks us out.
        //

        status = ZwQueryDirectoryObject(directoryHandle,
                                        dirInfo,
                                        dirInfoLength,
                                        TRUE,           // force one at a time
                                        restartScan,
                                        &dirContext,
                                        &neededLength);
        if (status == STATUS_BUFFER_TOO_SMALL) {
            dirInfoLength = neededLength;
            if (dirInfo != NULL) {
                ExFreePool(dirInfo);
            }
            dirInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, dirInfoLength);
            if (dirInfo == NULL) {
                *Context->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            status = ZwQueryDirectoryObject(directoryHandle,
                                            dirInfo,
                                            dirInfoLength,
                                            TRUE,       // force one at a time
                                            restartScan,
                                            &dirContext,
                                            &neededLength);
        }
        restartScan = FALSE;

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Have name of object.  Create object path and use
        // ObReferenceObjectByName() to get DriverObject.  This may
        // fail non-fatally if DriverObject has gone away in the interim.
        //

        driverString.MaximumLength = sizeof(L"\\Driver\\") +
            dirInfo->Name.Length;
        driverString.Length = driverString.MaximumLength - sizeof(WCHAR);
        driverString.Buffer = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION,
                                             driverString.MaximumLength);
        if (driverString.Buffer == NULL) {
            *Context->Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        StringCbPrintfW(driverString.Buffer, driverString.MaximumLength, L"\\Driver\\%ws", dirInfo->Name.Buffer);
        status = ObReferenceObjectByName(&driverString,
                                         OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                         NULL,                 // access state
                                         0,                    // access mask
                                         IoDriverObjectType,
                                         KernelMode,
                                         NULL,                 // parse context
                                         &driverObject);

        ExFreePool(driverString.Buffer);

        if (NT_SUCCESS(status)) {
            ASSERT(driverObject->Type == IO_TYPE_DRIVER);
            if (driverObject->Flags & DRVO_LEGACY_RESOURCES) {
                //
                // Update the veto type.  If the caller provided a
                // veto list pointer, add the driver to the veto list.
                // If an error occurs while adding the driver to the
                // veto list, or the caller did not provide a veto
                // list pointer, terminate the driver enumeration now.
                //
                // NOTE: Driver may be loaded but not running,
                // distinction is not made here.


                *Context->VetoType = PNP_VetoLegacyDriver;

                if (Context->VetoList != NULL) {
                    IopAppendLegacyVeto(Context, &dirInfo->Name);
                }
            }
            ObDereferenceObject(driverObject);

            //
            // Early out if we have a veto and the caller didn't want a list or
            // we hit some error already
            //
            if (((*Context->VetoType == PNP_VetoLegacyDriver) &&
                (Context->VetoList == NULL)) ||
                !NT_SUCCESS(*Context->Status)) {
                break;
            }
        }
    }
    if (dirInfo != NULL) {
        ExFreePool(dirInfo);
    }

    ZwClose(directoryHandle);
}

NTSTATUS
IoGetLegacyVetoList(
    OUT PWSTR *VetoList OPTIONAL,
    OUT PPNP_VETO_TYPE VetoType
    )
/*++

Routine Description:

    This routine is used by PNP and PO to determine whether legacy drivers and
    devices are installed in the system.  This routine is conceptually a
    QUERY_REMOVE_DEVICE and QUERY_POWER-like interface for legacy drivers
    and devices.

Parameters:

    VetoList - A pointer to a PWSTR. (Optional)  If specified,
        IoGetLegacyVetoList will allocate a veto list, and return a
        pointer to the veto list in VetoList.

    VetoType - A pointer to a PNP_VETO_TYPE.  If no legacy drivers
        or devices are found in the system, VetoType is assigned
        PNP_VetoTypeUnknown.  If one or more legacy drivers are installed,
        VetoType is assigned PNP_VetoLegacyDriver.  If one or more
        legacy devices are installed, VetoType is assigned
        PNP_VetoLegacyDevice.  VetoType is assigned independent of
        whether a VetoList is created.

ReturnValue:

    An NTSTATUS value indicating whether the IoGetLegacyVetoList() operation
    was successful.

--*/
{
    NTSTATUS Status;
    IO_GET_LEGACY_VETO_LIST_CONTEXT Context;
    UNICODE_STRING UnicodeString;

    PAGED_CODE();

    //
    // Initialize the veto list.
    //

    if (VetoList != NULL) {
        *VetoList = NULL;
    }

    //
    // Initialize the veto type.
    //

    ASSERT(VetoType != NULL);

    *VetoType = PNP_VetoTypeUnknown;

    //
    // Initialize the status.
    //

    Status = STATUS_SUCCESS;

    if (PnPInitialized == FALSE) {

        //
        // Can't touch anything, but nothing is really started either.
        //
        return Status;
    }

    //
    // Initialize our local context.
    //

    Context.VetoList = VetoList;
    Context.VetoListLength = 0;
    Context.VetoType = VetoType;
    Context.Status = &Status;

    //
    // Enumerate all driver objects.  This process can: (1) modify
    // the veto list, (2) modify the veto type and/or (3) modify the
    // status.
    //

    IopGetLegacyVetoListDrivers(&Context);

    //
    // If the driver enumeration process was successful and no legacy
    // drivers were detected, enumerate all device nodes.  The same
    // context values as above may be modified during device enumeration.
    //

    if (NT_SUCCESS(Status)) {

        if (*VetoType == PNP_VetoTypeUnknown) {

            PpDevNodeLockTree(PPL_SIMPLE_READ);

            IopGetLegacyVetoListDeviceNode(
                IopRootDeviceNode,
                &Context
            );

            PpDevNodeUnlockTree(PPL_SIMPLE_READ);
        }

    }

    //
    // If the previous operation(s) was/were successful, and the caller
    // provided a veto list pointer and we have constructed a veto
    // list, terminate the veto list with an empty string, i.e. MULTI_SZ.
    //

    if (NT_SUCCESS(Status)) {

        if (*VetoType != PNP_VetoTypeUnknown) {

            if (VetoList != NULL) {

                PiWstrToUnicodeString(
                    &UnicodeString,
                    L""
                );

                IopAppendLegacyVeto(
                    &Context,
                    &UnicodeString
                );

            }

        }

    }

    //
    // If a previous operation was unsuccessful, free any veto list we may have
    // allocated along the way.
    //

    if (!NT_SUCCESS(Status)) {

        if (VetoList != NULL && *VetoList != NULL) {
            ExFreePool(*VetoList);
            *VetoList = NULL;
        }

    }

    return Status;
}

NTSTATUS
PnpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:

    This function is used to stop further processing on an Irp which has been
    passed to IoForwardAndCatchIrp. It signals a event which has been passed
    in the context parameter to indicate that the Irp processing is complete.
    It then returns STATUS_MORE_PROCESSING_REQUIRED in order to stop processing
    on this Irp.

Arguments:

    DeviceObject -
        Contains the device which set up this completion routine.

    Irp -
        Contains the Irp which is being stopped.

    Event -
        Contains the event which is used to signal that this Irp has been
        completed.

Return Value:

    Returns STATUS_MORE_PROCESSING_REQUIRED in order to stop processing on the
    Irp.

--*/
{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    //
    // This will allow the ForwardAndCatchIrp call to continue on its way.
    //
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    //
    // This will ensure that nothing else touches the Irp, since the original
    // caller has now continued, and the Irp may not exist anymore.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTKERNELAPI
BOOLEAN
IoForwardAndCatchIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used with devices which may be stacked, and may not use
    file objects to communicate.

    Forwards an IRP to the specified driver after initializing the next
    stack location, and regains control of the Irp on completion from that
    driver.

Arguments:

    DeviceObject -
        Contains the device to forward the Irp to.

    Irp -
        Contains the Irp which is being forwarded to the specified driver.

Return Value:

    Returns TRUE if the IRP was forwarded, else FALSE if no stack space
    was available.

--*/
{
    KEVENT Event;

    PAGED_CODE();
    //
    // Ensure that there is another stack location before copying parameters.
    //
    ASSERT(Irp->CurrentLocation > 1);
    if (Irp->CurrentLocation == 1) {
        return FALSE;
    }
    IoCopyCurrentIrpStackLocationToNext(Irp);
    //
    // Set up a completion routine so that the Irp is not actually
    // completed. Thus the caller can get control of the Irp back after
    // this next driver is done with it.
    //
    KeInitializeEvent(&Event, NotificationEvent, FALSE);
    IoSetCompletionRoutine(Irp, PnpCompletionRoutine, &Event, TRUE, TRUE, TRUE);
    if (IoCallDriver(DeviceObject, Irp) == STATUS_PENDING) {
        //
        // Wait for completion which will occur when the CompletionRoutine
        // signals this event. Wait in KernelMode so that the current stack
        // is not paged out, since there is an event object on this stack.
        //
        KeWaitForSingleObject(
            &Event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
    }
    return TRUE;
}

NTSTATUS
IoGetDeviceInstanceName(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PUNICODE_STRING InstanceName
    )
{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;

    ASSERT_PDO(PhysicalDeviceObject);

    deviceNode = PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;

    status = PipConcatenateUnicodeStrings(  InstanceName,
                                            &deviceNode->InstancePath,
                                            NULL);

    return status;
}

VOID
IoControlPnpDeviceActionQueue(
    BOOLEAN Lock
    )
{
    if (Lock) {

        PiLockDeviceActionQueue();
    } else {

        PiUnlockDeviceActionQueue();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpiop.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpiop.h

Abstract:

    This module contains the plug-and-play macros and constants.

Author:

    Shie-Lin Tzong (shielint) 29-Jan-1995
    Andrew Thornton (andrewth) 5-Sept-1996

Environment:

    Kernel mode


Revision History:


--*/

//
// Pool tags
//

#define IOP_DNOD_TAG    'donD'
#define IOP_DNDT_TAG    'tdnD'
#define IOP_DPWR_TAG    'rwPD'

//
// The DEVICE_NODE is really just some extra stuff that we'd like to keep around
// for each physical device object.
// It is seperated from DEVOBJ_EXTENSION because these fields only apply to
// PDO.
//

typedef enum {

    DOCK_NOTDOCKDEVICE,
    DOCK_QUIESCENT,
    DOCK_ARRIVING,
    DOCK_DEPARTING,
    DOCK_EJECTIRP_COMPLETED

} PROFILE_STATUS;

typedef enum {

    PROFILE_IN_PNPEVENT,
    PROFILE_NOT_IN_PNPEVENT,
    PROFILE_PERHAPS_IN_PNPEVENT

} PROFILE_NOTIFICATION_TIME;

typedef struct _PENDING_SET_INTERFACE_STATE {
    LIST_ENTRY      List;
    UNICODE_STRING  LinkName;
} PENDING_SET_INTERFACE_STATE, *PPENDING_SET_INTERFACE_STATE;


typedef enum _UNLOCK_UNLINK_ACTION {
    UnlinkRemovedDeviceNodes,
    UnlinkAllDeviceNodesPendingClose,
    UnlinkOnlyChildDeviceNodesPendingClose
}   UNLOCK_UNLINK_ACTION, *PUNLOCK_UNLINK_ACTION;

typedef enum _PNP_DEVNODE_STATE {
    DeviceNodeUnspecified       = 0x300, // 768
    DeviceNodeUninitialized,             // 769
    DeviceNodeInitialized,               // 770
    DeviceNodeDriversAdded,              // 771
    DeviceNodeResourcesAssigned,         // 772 - Operational state for Added
    DeviceNodeStartPending,              // 773 - Operational state for Added
    DeviceNodeStartCompletion,           // 774 - Operational state for Added
    DeviceNodeStartPostWork,             // 775 - Operational state for Added
    DeviceNodeStarted,                   // 776
    DeviceNodeQueryStopped,              // 777
    DeviceNodeStopped,                   // 778
    DeviceNodeRestartCompletion,         // 779 - Operational state for Stopped
    DeviceNodeEnumeratePending,          // 780 - Operational state for Started
    DeviceNodeEnumerateCompletion,       // 781 - Operational state for Started
    DeviceNodeAwaitingQueuedDeletion,    // 782
    DeviceNodeAwaitingQueuedRemoval,     // 783
    DeviceNodeQueryRemoved,              // 784
    DeviceNodeRemovePendingCloses,       // 785
    DeviceNodeRemoved,                   // 786
    DeviceNodeDeletePendingCloses,       // 787
    DeviceNodeDeleted,                   // 788
    MaxDeviceNodeState                   // 788
}   PNP_DEVNODE_STATE, *PPNP_DEVNODE_STATE;

#define STATE_HISTORY_SIZE  20

typedef struct _DEVICE_NODE *PDEVICE_NODE;
typedef struct _DEVICE_NODE {

    //
    // Pointer to another DEVICE_NODE with the same parent as this one.
    //

    PDEVICE_NODE Sibling;

    //
    // Pointer to the first child of this DEVICE_NODE.
    //

    PDEVICE_NODE Child;

    //
    // Pointer to this DEVICE_NODE's parent.
    //

    PDEVICE_NODE Parent;

    //
    // Pointer to the last child of the device node
    //

    PDEVICE_NODE LastChild;

    //
    // Depth of DEVICE_NODE in the tree, root is 0
    //

    ULONG Level;

    //
    // Power notification order list entry for this device node
    //

    PPO_DEVICE_NOTIFY Notify;

    //
    // State
    //
    PNP_DEVNODE_STATE State;

    //
    // Previous State
    //
    PNP_DEVNODE_STATE PreviousState;

    //
    // Previous State
    //
    PNP_DEVNODE_STATE StateHistory[STATE_HISTORY_SIZE];

    ULONG StateHistoryEntry;

    //
    // Completion status
    //
    NTSTATUS CompletionStatus;

    //
    // Completion status
    //
    PIRP PendingIrp;

    //
    // General flags.
    //

    ULONG Flags;

    //
    // Flags used by user-mode for volatile state which should go away on a
    // reboot or when the device is removed.
    //

    ULONG UserFlags;

    //
    // Problem.  This is set if DNF_HAS_PROBLEM is set in Flags.  Indicates
    // which problem exists and uses the same values as the config manager
    // CM_PROB_*
    //

    ULONG Problem;

    //
    // Pointer to the physical device object that this DEVICE_NODE is associated
    // with.
    //

    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Pointer to the list of resources assigned to the PhysicalDeviceObject.
    // This is the Resource list which is passed to driver's start routine.
    //

    PCM_RESOURCE_LIST ResourceList;

    PCM_RESOURCE_LIST ResourceListTranslated;

    //
    // InstancePath is the path of the instance node in the registry,
    // i.e. <EnumBus>\<DeviceId>\<uniqueid>
    //

    UNICODE_STRING InstancePath;

    //
    // ServiceName is the name of the driver who controls the device. (Not the
    // driver who enumerates/creates the PDO.)  This field is mainly for
    // convenience.
    //

    UNICODE_STRING ServiceName;

    //
    // DuplicatePDO - if the flags have DNF_DUPLICATE set then this fields indicates
    // the duplicate PDO which is enumerated by a bus driver.  N.B. It is possible
    // that DNF_DUPLICATE is set but this field is NULL.  In this case, it means that
    // we know the device is a duplicate of another device and we have not enumerated
    // the DuplicatePDO yet.
    //

    PDEVICE_OBJECT DuplicatePDO;

    //
    // ResourceRequirements
    //

    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements;

    //
    // Information queried from the LEGACY_BUS_INFORMATION irp.
    //

    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;

    //
    // Information queried from the BUS_INFORMATION irp.
    //

    INTERFACE_TYPE ChildInterfaceType;
    ULONG ChildBusNumber;
    USHORT ChildBusTypeIndex;

    //
    // Describes the current removal policy for the device node. This is
    // actually type DEVICE_REMOVAL_POLICY.
    //

    UCHAR RemovalPolicy;

    //
    // Similar to above, but doesn't reflect any registry overrides.
    //

    UCHAR HardwareRemovalPolicy;

    //
    // Linked list of entries that represent each driver that has registered
    // for notification on this devnode. Note: drivers (and user-mode) actually
    // register based on a FILE_OBJECT handle, which is translated into a PDO
    // by sending an IRP_MN_QUERY_DEVICE_RELATIONS for TargetDeviceRelation.
    //

    LIST_ENTRY TargetDeviceNotify;

    //
    // DeviceArbiterList - A list of arbiters registered for this physical device object
    // Note: The Arbiters must be dereferenced when the device node is going away.
    //

    LIST_ENTRY DeviceArbiterList;

    //
    // DeviceTranslatorList - A list of translator for this physical device object
    // NOTE: the Translator must be dereferenced when the devic node is going away.
    //

    LIST_ENTRY DeviceTranslatorList;

    //
    // NoTranslatorMask - the bit position corresponds to resource type
    //   if bit is set, there is no translator for the resource type in this devnode
    //

    USHORT NoTranslatorMask;

    //
    // QueryTranslatorMask - The bit position corresponds to resource type.
    //   if bit is set, the translator for the resource type is queried.
    //

    USHORT QueryTranslatorMask;

    //
    // NoArbiterMask - the bit position corresponds to resource type
    //   if bit is set, there is no arbiter for the resource type in this devnode
    //

    USHORT NoArbiterMask;

    //
    // QueryArbiterMask - The bit position corresponds to resource type.
    //   if bit is set, the arbiter for the resource type is queried.
    //

    USHORT QueryArbiterMask;

    //
    // The following fields are used to track  legacy resource allocation
    // LegacyDeviceNode - The real legacy device node.
    // NextResourceDeviceNode - link all the made-up device nodes which own part of
    //   the resources from LegacyDeviceNode.
    //

    union {
        PDEVICE_NODE LegacyDeviceNode;
        PDEVICE_RELATIONS PendingDeviceRelations;
    } OverUsed1;

    union {
        PDEVICE_NODE NextResourceDeviceNode;
    } OverUsed2;

    //
    // Remember the BootResources for the device
    //

    PCM_RESOURCE_LIST BootResources;

    //
    // When Capabilities have been queried for a device (twice, once before
    // start and once after start) the flags are stored here in the same format
    // as the query capabilities IRP - use IopDeviceNodeFlagsToCapabilities to
    // access.
    //
    ULONG CapabilityFlags;

    //
    // Maintain a list of current dock devices and their SerialNumbers
    //
    struct {
        PROFILE_STATUS  DockStatus;
        LIST_ENTRY      ListEntry;
        PWCHAR          SerialNumber;
    } DockInfo;

    //
    // Maintain a count to determine if either ourselves or any of
    // our children are stopping us from being disableable
    // count = myself (DNUF_NOT_DISABLEABLE) + 1 for each immediate
    // child that has DisableableDepends > 0
    //
    ULONG DisableableDepends;

    //
    // List of pended IoSetDeviceInterfaceState calls.
    // IoSetDeviceInterfaceState adds an entry to this list whenever it is
    // called and we haven't been started yet.  Once we do the start we'll
    // run down the list.
    //
    LIST_ENTRY PendedSetInterfaceState;

    //
    // List of device nodes with same interface type and different bus numbers.
    //
    LIST_ENTRY LegacyBusListEntry;

#if DBG_SCOPE
    ULONG FailureStatus;
    PCM_RESOURCE_LIST PreviousResourceList;
    PIO_RESOURCE_REQUIREMENTS_LIST PreviousResourceRequirements;
#endif

} DEVICE_NODE;


//
// A device Object is a PDO iff it has a non NULL device node (aka set by
// plug and play during a query device relations.
//
#define IS_PDO(d) \
    ((NULL != (d)->DeviceObjectExtension->DeviceNode) && \
    (!(((PDEVICE_NODE)(d)->DeviceObjectExtension->DeviceNode)->Flags & DNF_LEGACY_RESOURCE_DEVICENODE)))

#define ASSERT_PDO(d) \
    do { \
        if (    NULL == (d)->DeviceObjectExtension->DeviceNode || \
                (((PDEVICE_NODE)(d)->DeviceObjectExtension->DeviceNode)->Flags & DNF_LEGACY_RESOURCE_DEVICENODE))  { \
            KeBugCheckEx(PNP_DETECTED_FATAL_ERROR, PNP_ERR_INVALID_PDO, (ULONG_PTR)d, 0, 0); \
        } \
    } \
    while (0)

//
// DNF_MAKEUP - this devnode's device is created and owned by PnP manager
//

#define DNF_MADEUP                                  0x00000001

//
// DNF_DUPLICATE - this devnode's device is a duplicate of another enumerate PDO
//

#define DNF_DUPLICATE                               0x00000002

//
// DNF_HAL_NODE - a flag to indicate which device node is the root node created by
// the hal
//

#define DNF_HAL_NODE                                0x00000004

//
// DNF_REENUMERATE - needs to be reenumerated
//

#define DNF_REENUMERATE                             0x00000008

//
// DNF_ENUMERATED - used to track enumeration in IopEnumerateDevice()
//

#define DNF_ENUMERATED                              0x00000010

//
// Singal that we need to send driver query id irps
//

#define DNF_IDS_QUERIED                             0x00000020

//
// DNF_HAS_BOOT_CONFIG - the device has resource assigned by BIOS.  It is considered
//    pseudo-started and need to participate in rebalance.
//

#define DNF_HAS_BOOT_CONFIG                         0x00000040

//
// DNF_BOOT_CONFIG_RESERVED - Indicates the BOOT resources of the device are reserved.
//

#define DNF_BOOT_CONFIG_RESERVED                    0x00000080

//
// DNF_NO_RESOURCE_REQUIRED - this devnode's device does not require resource.
//

#define DNF_NO_RESOURCE_REQUIRED                    0x00000100

//
// DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED - to distinguished the
//      DeviceNode->ResourceRequirements is a filtered list or not.
//

#define DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED     0x00000200

//
// DNF_RESOURCE_REQUIREMENTS_CHANGED - Indicates the device's resource
//      requirements list has been changed.
//

#define DNF_RESOURCE_REQUIREMENTS_CHANGED           0x00000400

//
// DNF_NON_STOPPED_REBALANC - indicates the device can be restarted with new
//      resources without being stopped.
//

#define DNF_NON_STOPPED_REBALANCE                   0x00000800

//
// The device's controlling driver is a legacy driver
//

#define DNF_LEGACY_DRIVER                           0x00001000

//
// This corresponds to the user-mode CM_PROB_WILL_BE_REMOVED problem value and
// the DN_WILL_BE_REMOVED status flag.
//

#define DNF_HAS_PROBLEM                             0x00002000

//
// DNF_HAS_PRIVATE_PROBLEM - indicates this device reported PNP_DEVICE_FAILED
//  to a IRP_MN_QUERY_PNP_DEVICE_STATE without also reporting
//  PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED.
//

#define DNF_HAS_PRIVATE_PROBLEM                     0x00004000

//
// DNF_HARDWARE_VERIFICATION is set on device nodes that have hardware
// verification (probably via WHQL applet).
//

#define DNF_HARDWARE_VERIFICATION                   0x00008000

//
// DNF_DEVICE_GONE is set when a pdo is no longer returned in a query bus
// relations.  It will then be processed as a surprise remove if started.
// This flag is used to better detect when a device is resurrected, and when
// processing surprise remove, to determine if the devnode should be removed
// from the tree.
//

#define DNF_DEVICE_GONE                             0x00010000

//
// DNF_LEGACY_RESOURCE_DEVICENODE is set for device nodes created for legacy
// resource allocation.
//

#define DNF_LEGACY_RESOURCE_DEVICENODE              0x00020000

//
// DNF_NEEDS_REBALANCE is set for device nodes that trigger rebalance.
//

#define DNF_NEEDS_REBALANCE                         0x00040000

//
// DNF_LOCKED_FOR_EJECT is set on device nodes that are being ejected or are
// related to a device being ejected.
//

#define DNF_LOCKED_FOR_EJECT                        0x00080000

//
// DNF_DRIVER_BLOCKED is set on device nodes that use one or more drivers that
// have been blocked from loading.
//

#define DNF_DRIVER_BLOCKED                          0x00100000

//
// DNF_CHILD_WITH_INVALID_ID is set on device nodes that has one or more children
// that have invalid id(s).
//

#define DNF_CHILD_WITH_INVALID_ID                   0x00200000

//
// This corresponds to the user-mode the DN_WILL_BE_REMOVED status flag.
//

#define DNUF_WILL_BE_REMOVED                        0x00000001

//
// This corresponds to the user-mode DN_NO_SHOW_IN_DM status flag.
//

#define DNUF_DONT_SHOW_IN_UI                        0x00000002

//
// This flag is set when user-mode lets us know that a reboot is required
// for this device.
//

#define DNUF_NEED_RESTART                           0x00000004

//
// This flag is set to let the user-mode know when a device can be disabled
// it is still possible for this to be TRUE, yet disable to fail, as it's
// a polled flag (see also PNP_DEVICE_NOT_DISABLEABLE)
//

#define DNUF_NOT_DISABLEABLE                        0x00000008

//
// Flags used during shutdown when the IO Verifier is trying to remove all
// PNP devices.
//
// DNUF_SHUTDOWN_QUERIED is set when we issue the QueryRemove to a devnode.
//
// DNUF_SHUTDOWN_SUBTREE_DONE is set once we've issued the QueryRemove to all
// a Devnodes descendants.
//
#define DNUF_SHUTDOWN_QUERIED                       0x00000010
#define DNUF_SHUTDOWN_SUBTREE_DONE                  0x00000020

//
// PNP Bugcheck Subcodes
//
#define PNP_ERR_DUPLICATE_PDO                   1
#define PNP_ERR_INVALID_PDO                     2
#define PNP_ERR_BOGUS_ID                        3
#define PNP_ERR_PDO_ENUMERATED_AFTER_DELETION   4
#define PNP_ERR_ACTIVE_PDO_FREED                5

#define PNP_ERR_DEVICE_MISSING_FROM_EJECT_LIST  6
#define PNP_ERR_UNEXPECTED_ADD_RELATION_ERR     7

#define MAX_INSTANCE_PATH_LENGTH    260

typedef NTSTATUS (*PENUM_CALLBACK)(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID Context
    );

//
// Define callback routine for PipApplyFunctionToSubKeys &
// PipApplyFunctionToServiceInstances
//
typedef BOOLEAN (*PIOP_SUBKEY_CALLBACK_ROUTINE) (
    IN     HANDLE,
    IN     PUNICODE_STRING,
    IN OUT PVOID
    );

//
// Define context structures for Start and Add device services
//

#define NO_MORE_GROUP ((USHORT) -1)
#define SETUP_RESERVED_GROUP      0
#define BUS_DRIVER_GROUP          1

typedef struct _ADD_CONTEXT {
    ULONG DriverStartType;
} ADD_CONTEXT, *PADD_CONTEXT;

typedef struct _START_CONTEXT {
    BOOLEAN LoadDriver;
    BOOLEAN NewDevice;
    ADD_CONTEXT AddContext;
} START_CONTEXT, *PSTART_CONTEXT;

//
// Resource translation and allocation related structures
//

typedef enum _RESOURCE_HANDLER_TYPE {
    ResourceHandlerNull,
    ResourceTranslator,
    ResourceArbiter,
    ResourceLegacyDeviceDetection
} RESOURCE_HANDLER_TYPE;

#define PI_MAXIMUM_RESOURCE_TYPE_TRACKED 15

//
// Internal Arbiters tracking structures
// Note the first three fields of PI_RESOURCE_ARBITER_ENTRY and PI_RESOURCE_TRANSLATOR_ENTRY
// must be the same.
//

typedef struct _PI_RESOURCE_ARBITER_ENTRY {
    LIST_ENTRY          DeviceArbiterList;         // Link all the arbiters of a PDO.
    UCHAR               ResourceType;
    PARBITER_INTERFACE  ArbiterInterface;
    ULONG               Level;                     // Level of the owning device.
    LIST_ENTRY          ResourceList;
    LIST_ENTRY          BestResourceList;
    LIST_ENTRY          BestConfig;                // Link all the arbiters which produces the best logconf
    LIST_ENTRY          ActiveArbiterList;         // Link all the arbiters under testing
    UCHAR               State;
    BOOLEAN             ResourcesChanged;
} PI_RESOURCE_ARBITER_ENTRY, *PPI_RESOURCE_ARBITER_ENTRY;

//
// Define PI_RESOURCE_ARBITER_ENTRY state
//

#define PI_ARBITER_HAS_SOMETHING 1
#define PI_ARBITER_TEST_FAILED   2

//
// Internal Translator tracking structures
//

typedef struct _PI_RESOURCE_TRANSLATOR_ENTRY {
    LIST_ENTRY              DeviceTranslatorList;
    UCHAR                   ResourceType;
    PTRANSLATOR_INTERFACE   TranslatorInterface;
    PDEVICE_NODE            DeviceNode;
} PI_RESOURCE_TRANSLATOR_ENTRY, *PPI_RESOURCE_TRANSLATOR_ENTRY;

//
// IOP_RESOURCE_REQUEST
//

#define QUERY_RESOURCE_LIST                0
#define QUERY_RESOURCE_REQUIREMENTS        1

#define REGISTRY_ALLOC_CONFIG              1
#define REGISTRY_FORCED_CONFIG             2
#define REGISTRY_BOOT_CONFIG               4
#define REGISTRY_OVERRIDE_CONFIGVECTOR     1
#define REGISTRY_BASIC_CONFIGVECTOR        2

//
// An array of IOP_RESOURCE_REQUEST structures is used to anchor all the
// devices for which resource rerquirement is being attempted.
//

#define IOP_ASSIGN_RETRY              0x00000008    // Retry resource allocation later
#define IOP_ASSIGN_EXCLUDE            0x00000010    // internal IopAssign flag
#define IOP_ASSIGN_IGNORE             0x00000020    // ignore this request
#define IOP_ASSIGN_NO_REBALANCE       0x00000080    // no rebal if assign fails
#define IOP_ASSIGN_RESOURCES_RELEASED 0x00000100    // resources are released for rebalancing
#define IOP_ASSIGN_KEEP_CURRENT_CONFIG 0x00000200   // Indicate non-stopped rebalance.  We need to
                                                    //   preserved the current config.
#define IOP_ASSIGN_CLEAR_RESOURCE_REQUIREMENTS_CHANGE_FLAG \
                                      0x00000400

typedef struct _IOP_RESOURCE_REQUEST {
    PDEVICE_OBJECT                 PhysicalDevice;
    ULONG                          Flags;
    ARBITER_REQUEST_SOURCE         AllocationType;
    ULONG                          Priority;                   // 0 is highest priority
    ULONG                          Position;                   // used for sorting of entries with same priority
    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements;
    PVOID                          ReqList;                    // PREQ_LIST
    PCM_RESOURCE_LIST              ResourceAssignment;
    PCM_RESOURCE_LIST              TranslatedResourceAssignment;
    NTSTATUS                       Status;
} IOP_RESOURCE_REQUEST, *PIOP_RESOURCE_REQUEST;

//
// Misc
//

//
// Enumeration request type
//

typedef enum _DEVICE_REQUEST_TYPE {
    AddBootDevices,
    AssignResources,
    ClearDeviceProblem,
    ClearEjectProblem,
    HaltDevice,
    ReenumerateBootDevices,
    ReenumerateDeviceOnly,
    ReenumerateDeviceTree,
    ReenumerateRootDevices,
    RequeryDeviceState,
    ResetDevice,
    ResourceRequirementsChanged,
    RestartEnumeration,
    SetDeviceProblem,
    ShutdownPnpDevices,
    StartDevice,
    StartSystemDevices
} DEVICE_REQUEST_TYPE;

#define CmResourceTypeReserved  0xf0



//
// This macro returns the pointer to the beginning of the data
// area of KEY_VALUE_FULL_INFORMATION structure.
// In the macro, k is a pointer to KEY_VALUE_FULL_INFORMATION structure.
//

#define KEY_VALUE_DATA(k) ((PCHAR)(k) + (k)->DataOffset)

//
// Save failure status info.
//

#if DBG_SCOPE
#define SAVE_FAILURE_INFO(DeviceNode, Status) (DeviceNode)->FailureStatus = (Status)
#else
#define SAVE_FAILURE_INFO(DeviceNode, Status)
#endif

BOOLEAN
PipAreDriversLoaded(
    IN PDEVICE_NODE DeviceNode
    );

BOOLEAN
PipIsDevNodeDNStarted(
    IN PDEVICE_NODE DeviceNode
    );

VOID
PipClearDevNodeProblem(
    IN PDEVICE_NODE DeviceNode
    );

VOID
PipSetDevNodeProblem(
    IN PDEVICE_NODE DeviceNode,
    IN ULONG        Problem
    );

#define PipIsRequestPending(devnode)   FALSE

#define PipDoesDevNodeHaveResources(devnode)                        \
        ((devnode)->ResourceList != NULL || (devnode)->BootResources != NULL || \
        ((devnode)->Flags & DNF_HAS_BOOT_CONFIG) != 0)


#define PipDoesDevNodeHaveProblem(devnode)                          \
        ((devnode)->Flags & (DNF_HAS_PROBLEM | DNF_HAS_PRIVATE_PROBLEM))

#define PipIsDevNodeProblem(devnode, problem)                       \
        (((devnode)->Flags & DNF_HAS_PROBLEM) && (devnode)->Problem == (problem))

#define PipIsDevNodeDeleted(d)                                      \
    ((d)->State == DeviceNodeDeletePendingCloses ||(d)->State == DeviceNodeDeleted)

VOID
PipSetDevNodeState(
    IN  PDEVICE_NODE        DeviceNode,
    IN  PNP_DEVNODE_STATE   State,
    OUT PNP_DEVNODE_STATE  *OldState    OPTIONAL
    );

VOID
PipRestoreDevNodeState(
    IN PDEVICE_NODE DeviceNode
    );

BOOLEAN
PipIsProblemReadonly(
    IN  ULONG   Problem
    );

//++
//
// VOID
// IopRegistryDataToUnicodeString(
//     OUT PUNICODE_STRING u,
//     IN  PWCHAR p,
//     IN  ULONG l
//     )
//
//--
#define IopRegistryDataToUnicodeString(u, p, l)  \
    {                                            \
        ULONG len;                               \
                                                 \
        PiRegSzToString((p), (l), &len, NULL);   \
        (u)->Length = (USHORT)len;               \
        (u)->MaximumLength = (USHORT)(l);        \
        (u)->Buffer = (p);                       \
    }

//
// Size of scratch buffer used in this module.
//

#define PNP_SCRATCH_BUFFER_SIZE 512
#define PNP_LARGE_SCRATCH_BUFFER_SIZE (PNP_SCRATCH_BUFFER_SIZE * 8)

//
// Define Device Instance Flags (used by IoQueryDeviceConfiguration apis)
//

#define DEVINSTANCE_FLAG_HWPROFILE_DISABLED 0x1
#define DEVINSTANCE_FLAG_PNP_ENUMERATED 0x2

//
// Define Enumeration Control Flags (used by PipApplyFunctionToSubKeys)
//

#define FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS  0x1
#define FUNCTIONSUBKEY_FLAG_DELETE_SUBKEYS              0x2

//
// The following definitions are used in IoOpenDeviceInstanceKey
//

#define PLUGPLAY_REGKEY_DEVICE  1
#define PLUGPLAY_REGKEY_DRIVER  2
#define PLUGPLAY_REGKEY_CURRENT_HWPROFILE 4

//
// Define device extension for devices reported with IoReportDetectedDevice.
//

typedef struct _IOPNP_DEVICE_EXTENSION {
    PWCHAR CompatibleIdList;
    ULONG CompatibleIdListSize;
} IOPNP_DEVICE_EXTENSION, *PIOPNP_DEVICE_EXTENSION;

//
// Reserve Boot Resources
//

typedef struct _IOP_RESERVED_RESOURCES_RECORD IOP_RESERVED_RESOURCES_RECORD, *PIOP_RESERVED_RESOURCES_RECORD;

struct _IOP_RESERVED_RESOURCES_RECORD {
    PIOP_RESERVED_RESOURCES_RECORD  Next;
    PDEVICE_OBJECT                  DeviceObject;
    PCM_RESOURCE_LIST               ReservedResources;
};

//
// External References
//

//
// Init data
//
extern PVOID IopPnpScratchBuffer1;
extern PCM_RESOURCE_LIST IopInitHalResources;
extern PDEVICE_NODE IopInitHalDeviceNode;
extern PIOP_RESERVED_RESOURCES_RECORD IopInitReservedResourceList;
extern LOGICAL PiCollectVetoedHandles;

//
// Regular data
//

//
// IopRootDeviceNode - the head of the PnP manager's device node tree.
//

extern PDEVICE_NODE IopRootDeviceNode;

//
// IopPnPDriverObject - the madeup driver object for pnp manager
//

extern PDRIVER_OBJECT IopPnPDriverObject;

//
// IopPnPSpinLock - spinlock for Pnp code.
//

extern KSPIN_LOCK IopPnPSpinLock;

//
// IopPnpEnumerationRequestList - a link list of device enumeration requests to worker thread.
//

extern LIST_ENTRY IopPnpEnumerationRequestList;

//
// PiEngineLock - Synchronizes the start/enum and remove engines.
//     (Note that this is a resource as certain acquisition paths are reentrant,
//      specifically those that call IopNotifyPnpWhenChainDereferenced.)
//

extern ERESOURCE PiEngineLock;

//
// IopDeviceTreeLock - performs syncronization on the whole device node tree.
//      IopAcquireEnumerationLock acquires this lock shared then optionally
//                                acquires an exclusive lock on a devnode.
//      IopAcquireDeviceTreeLock acquires this lock exclusive
//

extern ERESOURCE IopDeviceTreeLock;

//
// IopSurpriseRemoveListLock - synchronizes access to the surprise remove list.
//

extern ERESOURCE IopSurpriseRemoveListLock;

//
// PiEventQueueEmpty - Manual reset event which is set when the queue is empty
//

extern KEVENT PiEventQueueEmpty;

//
// PiEnumerationLock - to synchronize IoInvalidateDeviceRelations in boot phase.
//

extern KEVENT PiEnumerationLock;

//
// IopNumberDeviceNodes - Number of outstanding device nodes in the system
//

extern ULONG IopNumberDeviceNodes;

//
// PnPInitialized - A flag to indicate if PnP initialization is completed.
//

extern BOOLEAN PnPInitialized;

//
// PnPBootDriverInitialied
//

extern BOOLEAN PnPBootDriversInitialized;

//
// PnPBootDriverLoaded
//

extern BOOLEAN PnPBootDriversLoaded;

//
// IopBootConfigsReserved - Indicates whether we have reserved BOOT configs or not.
//

extern BOOLEAN IopBootConfigsReserved;

//
// PnpDefaultInterfaceTYpe - Use this if the interface type of resource list is unknown.
//

extern INTERFACE_TYPE PnpDefaultInterfaceType;

//
// IopPendingEjects - List of pending eject requests
//
extern LIST_ENTRY  IopPendingEjects;

//
// IopPendingSurpriseRemovals - List of pending surprise removal requests
//
extern LIST_ENTRY   IopPendingSurpriseRemovals;

extern KSEMAPHORE   PpRegistrySemaphore;

extern BOOLEAN      PpPnpShuttingDown;

BOOLEAN
PipIsDuplicatedDevices(
    IN PCM_RESOURCE_LIST Configuration1,
    IN PCM_RESOURCE_LIST Configuration2,
    IN PHAL_BUS_INFORMATION BusInfo1 OPTIONAL,
    IN PHAL_BUS_INFORMATION BusInfo2 OPTIONAL
    );

NTSTATUS
PipConcatenateUnicodeStrings(
    OUT PUNICODE_STRING Destination,
    IN  PUNICODE_STRING String1,
    IN  PUNICODE_STRING String2  OPTIONAL
    );

NTSTATUS
PipServiceInstanceToDeviceInstance(
    IN  HANDLE ServiceKeyHandle OPTIONAL,
    IN  PUNICODE_STRING ServiceKeyName OPTIONAL,
    IN  ULONG ServiceInstanceOrdinal,
    OUT PUNICODE_STRING DeviceInstanceRegistryPath OPTIONAL,
    OUT PHANDLE DeviceInstanceHandle OPTIONAL,
    IN  ACCESS_MASK DesiredAccess
    );

NTSTATUS
PipCreateMadeupNode(
    IN PUNICODE_STRING ServiceKeyName,
    OUT PHANDLE ReturnedHandle,
    OUT PUNICODE_STRING KeyName,
    OUT PULONG InstanceOrdinal,
    IN BOOLEAN ResourceOwned
    );

NTSTATUS
PipOpenServiceEnumKeys(
    IN PUNICODE_STRING ServiceKeyName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE ServiceHandle OPTIONAL,
    OUT PHANDLE ServiceEnumHandle OPTIONAL,
    IN BOOLEAN CreateEnum
    );

NTSTATUS
IopOpenCurrentHwProfileDeviceInstanceKey(
    OUT PHANDLE Handle,
    IN  PUNICODE_STRING ServiceKeyName,
    IN  ULONG Instance,
    IN  ACCESS_MASK DesiredAccess,
    IN  BOOLEAN Create
    );

NTSTATUS
IopGetDeviceInstanceCsConfigFlags(
    IN PUNICODE_STRING DeviceInstance,
    OUT PULONG CsConfigFlags
    );

NTSTATUS
PipGetServiceInstanceCsConfigFlags(
    IN PUNICODE_STRING ServiceKeyName,
    IN ULONG Instance,
    OUT PULONG CsConfigFlags
    );

NTSTATUS
PipApplyFunctionToSubKeys(
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Flags,
    IN PIOP_SUBKEY_CALLBACK_ROUTINE SubKeyCallbackRoutine,
    IN OUT PVOID Context
    );

NTSTATUS
PipRegMultiSzToUnicodeStrings(
    IN PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    IN PUNICODE_STRING *UnicodeStringList,
    OUT PULONG UnicodeStringCount
    );


NTSTATUS
PipApplyFunctionToServiceInstances(
    IN HANDLE ServiceKeyHandle OPTIONAL,
    IN PUNICODE_STRING ServiceKeyName OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN IgnoreNonCriticalErrors,
    IN PIOP_SUBKEY_CALLBACK_ROUTINE DevInstCallbackRoutine,
    IN OUT PVOID Context,
    OUT PULONG ServiceInstanceOrdinal OPTIONAL
    );

VOID
PipFreeUnicodeStringList(
    IN PUNICODE_STRING UnicodeStringList,
    IN ULONG StringCount
    );

NTSTATUS
PipReadDeviceConfiguration(
    IN HANDLE Handle,
    IN ULONG Flags,
    OUT PCM_RESOURCE_LIST *CmResource,
    OUT PULONG Length
    );

#define PiInitializeEngineLock() \
    ExInitializeResourceLite(&PiEngineLock)

typedef enum {

    PPL_SIMPLE_READ,
    PPL_TREEOP_ALLOW_READS,
    PPL_TREEOP_BLOCK_READS,
    PPL_TREEOP_BLOCK_READS_FROM_ALLOW

} PNP_LOCK_LEVEL;

VOID
PpDevNodeLockTree(
    IN  PNP_LOCK_LEVEL  LockLevel
    );

VOID
PpDevNodeUnlockTree(
    IN  PNP_LOCK_LEVEL  LockLevel
    );

#if DBG
VOID
PpDevNodeAssertLockLevel(
    IN  PNP_LOCK_LEVEL  LockLevel,
    IN  PCSTR           File,
    IN  ULONG           Line
    );

#define PPDEVNODE_ASSERT_LOCK_HELD(Level) \
    PpDevNodeAssertLockLevel(Level, __FILE__, __LINE__)

#else
#define PPDEVNODE_ASSERT_LOCK_HELD(Level)
#endif

VOID
PpDevNodeInsertIntoTree(
    IN PDEVICE_NODE     ParentNode,
    IN PDEVICE_NODE     DeviceNode
    );

VOID
PpDevNodeRemoveFromTree(
    IN PDEVICE_NODE     DeviceNode
    );

NTSTATUS
PipAllocateDeviceNode(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PDEVICE_NODE *DeviceNode
    );

NTSTATUS
PipForAllDeviceNodes(
    IN PENUM_CALLBACK Callback,
    IN PVOID Context
    );

NTSTATUS
PipForDeviceNodeSubtree(
    IN PDEVICE_NODE     DeviceNode,
    IN PENUM_CALLBACK   Callback,
    IN PVOID            Context
    );

ULONG
IopDetermineResourceListSize(
    IN PCM_RESOURCE_LIST ResourceList
    );

PDEVICE_OBJECT
IopDeviceObjectFromDeviceInstance(
    IN PUNICODE_STRING  DeviceInstance
    );

NTSTATUS
IopMapDeviceObjectToDeviceInstance(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PUNICODE_STRING  DeviceInstance
    );

NTSTATUS
IopDeviceObjectToDeviceInstance(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHANDLE DeviceInstanceHandle,
    IN  ACCESS_MASK DesiredAccess
    );

BOOLEAN
IopIsDeviceInstanceEnabled(
    IN HANDLE DeviceInstanceHandle,
    IN PUNICODE_STRING DeviceInstance,
    IN BOOLEAN Disable
    );

BOOLEAN
IopProcessAssignResources(
   IN PDEVICE_NODE DeviceNode,
   IN BOOLEAN Reallocation,
   OUT PBOOLEAN RebalancePerformed
   );

NTSTATUS
IopStartDevice (
    IN PDEVICE_OBJECT TargetDevice
    );

NTSTATUS
IopEjectDevice(
    IN PDEVICE_OBJECT DeviceObject,
    PPENDING_RELATIONS_LIST_ENTRY PendingEntry
    );

VOID
IopCancelPendingEject(
    IN PPENDING_RELATIONS_LIST_ENTRY Entry
    );

NTSTATUS
IopRemoveDevice(
    IN PDEVICE_OBJECT TargetDevice,
    IN ULONG IrpMinorCode
    );

NTSTATUS
IopQueryDeviceRelations(
    IN DEVICE_RELATION_TYPE Relations,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Synchronous,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
IopQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PPNP_DEVICE_STATE DeviceState
    );

NTSTATUS
PipForAllChildDeviceNodes(
    IN PDEVICE_NODE Parent,
    IN PENUM_CALLBACK Callback,
    IN PVOID Context
    );

NTSTATUS
IopCleanupDeviceRegistryValues(
    IN PUNICODE_STRING InstancePath
    );

NTSTATUS
IopQueryDeviceResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ResourceType,
    OUT PVOID *Resource,
    OUT ULONG *Length
    );

NTSTATUS
IopGetDeviceResourcesFromRegistry (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ResourceType,
    IN ULONG Preference,
    OUT PVOID *Resource,
    OUT PULONG Length
    );

VOID
IopResourceRequirementsChanged(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN BOOLEAN StopRequired
    );

NTSTATUS
IopReleaseDeviceResources(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN  ReserveResources
    );

NTSTATUS
IopPnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopPnPDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IopPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

VOID
IopNewDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopFilterResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList,
    IN PCM_RESOURCE_LIST CmList,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *FilteredList,
    OUT PBOOLEAN ExactMatch
    );

NTSTATUS
IopMergeFilteredResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList1,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList2,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *MergedList
    );

NTSTATUS
IopMergeCmResourceLists (
    IN PCM_RESOURCE_LIST List1,
    IN PCM_RESOURCE_LIST List2,
    IN OUT PCM_RESOURCE_LIST *MergedList
    );

PIO_RESOURCE_REQUIREMENTS_LIST
IopCmResourcesToIoResources (
    IN ULONG SlotNumber,
    IN PCM_RESOURCE_LIST CmResourceList,
    IN ULONG Priority
    );

NTSTATUS
IopReportResourceListToPnp(
    IN PDRIVER_OBJECT DriverObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG ListSize,
    IN BOOLEAN Translated
    );

NTSTATUS
IopAllocateResources(
    IN PULONG DeviceCountP,
    IN OUT PIOP_RESOURCE_REQUEST *AssignTablePP,
    IN BOOLEAN Locked,
    IN BOOLEAN DoBootConfigs,
    OUT PBOOLEAN RebalancePerformed
    );

VOID
IopInitializeResourceMap (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
IopReallocateResources(
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
IopWriteResourceList(
    IN HANDLE ResourceMapKey,
    IN PUNICODE_STRING ClassName,
    IN PUNICODE_STRING DriverName,
    IN PUNICODE_STRING DeviceName,
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG ResourceListSize
    );

VOID
IopRemoveResourceListFromPnp(
    IN PLIST_ENTRY ResourceList
    );

NTSTATUS
IopWriteAllocatedResourcesToRegistry (
    IN PDEVICE_NODE DeviceNode,
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG Length
    );

USHORT
PpInitGetGroupOrderIndex(
    IN HANDLE ServiceHandle
    );

VOID
IopDeleteLegacyKey(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IopOpenDeviceParametersSubkey(
    OUT HANDLE *ParamKeyHandle,
    IN  HANDLE ParentKeyHandle,
    IN  PUNICODE_STRING SubKeyString,
    IN  ACCESS_MASK DesiredAccess
    );

NTSTATUS
IopOpenOrCreateDeviceRegistryKey(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN ULONG DevInstKeyType,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create,
    OUT PHANDLE DevInstRegKey
    );

NTSTATUS
PipRequestDeviceAction(
    IN PDEVICE_OBJECT DeviceObject              OPTIONAL,
    IN DEVICE_REQUEST_TYPE RequestType,
    IN BOOLEAN ReorderingBarrier,
    IN ULONG_PTR Argument,
    IN PKEVENT CompletionEvent                  OPTIONAL,
    IN PNTSTATUS CompletionStatus               OPTIONAL
    );

VOID
PipRequestDeviceRemoval(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN      TreeDeletion,
    IN ULONG        Problem
    );

BOOLEAN
PipIsBeingRemovedSafely(
    IN  PDEVICE_NODE    DeviceNode
    );

NTSTATUS
IopRestartDeviceNode(
    IN PDEVICE_NODE DeviceNode
    );

VOID
PpResetProblemDevices(
    IN  PDEVICE_NODE    DeviceNode,
    IN  ULONG           Problem
    );

NTSTATUS
IopDeleteKeyRecursive(
    IN HANDLE SubKeyHandle,
    IN PWCHAR SubKeyName
    );

NTSTATUS
IopQueryLegacyBusInformation (
    IN PDEVICE_OBJECT DeviceObject,
    OUT LPGUID InterfaceGuid           OPTIONAL,
    OUT INTERFACE_TYPE *InterfaceType  OPTIONAL,
    OUT ULONG *BusNumber               OPTIONAL
    );

NTSTATUS
IopBuildRemovalRelationList(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    OUT PNP_VETO_TYPE                  *VetoType,
    OUT PUNICODE_STRING                 VetoName,
    OUT PRELATION_LIST                 *RelationsList
    );

NTSTATUS
IopDeleteLockedDeviceNodes(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PRELATION_LIST                  RelationsList,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN  BOOLEAN                         ProcessIndirectDescendants,
    IN  ULONG                           Problem,
    OUT PNP_VETO_TYPE                  *VetoType                    OPTIONAL,
    OUT PUNICODE_STRING                 VetoName                    OPTIONAL
    );

VOID
IopUnlinkDeviceRemovalRelations(
    IN      PDEVICE_OBJECT          RemovedDeviceObject,
    IN OUT  PRELATION_LIST          RelationsList,
    IN      UNLOCK_UNLINK_ACTION    UnlinkAction
    );

NTSTATUS
IopInvalidateRelationsInList(
    IN  PRELATION_LIST              RelationsList,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE OperationCode,
    IN  BOOLEAN                     OnlyIndirectDescendants,
    IN  BOOLEAN                     RestartDevNode
    );

BOOLEAN
IopQueuePendingEject(
    PPENDING_RELATIONS_LIST_ENTRY Entry
    );

VOID
IopProcessCompletedEject(
    IN PVOID Context
    );

VOID
IopQueuePendingSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PRELATION_LIST List,
    IN ULONG Problem
    );

NTSTATUS
IopUnloadAttachedDriver(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
IopIsAnyDeviceInstanceEnabled(
    IN PUNICODE_STRING ServiceKeyName,
    IN HANDLE ServiceHandle,
    IN BOOLEAN LegacyIncluded
    );

NTSTATUS
IopQueryResourceHandlerInterface(
    IN RESOURCE_HANDLER_TYPE HandlerType,
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR ResourceType,
    IN OUT PVOID *Interface
    );

NTSTATUS
IopQueryReconfiguration(
    IN UCHAR Request,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopLegacyResourceAllocation (
    IN ARBITER_REQUEST_SOURCE AllocationType,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources OPTIONAL
    );

NTSTATUS
IoReportResourceUsageInternal(
    IN ARBITER_REQUEST_SOURCE AllocationType,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    );

NTSTATUS
IopDuplicateDetection (
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    OUT PDEVICE_NODE *DeviceNode
    );

NTSTATUS
PipLoadBootFilterDriver(
    IN PUNICODE_STRING DriverName,
    IN ULONG GroupIndex,
    OUT PDRIVER_OBJECT *LoadedFilter
    );

NTSTATUS
IopQueryAndSaveDeviceNodeCapabilities (
    IN PDEVICE_NODE DeviceNode
    );

VOID
IopIncDisableableDepends(
    IN OUT PDEVICE_NODE DeviceNode
    );

VOID
IopDecDisableableDepends(
    IN OUT PDEVICE_NODE DeviceNode
    );

NTSTATUS
IopQueryDockRemovalInterface(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PDOCK_INTERFACE *DockInterface
    );

#ifndef FIELD_SIZE
#define FIELD_SIZE(type, field) (sizeof(((type *)0)->field))
#endif

#define IopDeviceNodeFlagsToCapabilities(DeviceNode) \
     ((PDEVICE_CAPABILITIES) (((PUCHAR) (&(DeviceNode)->CapabilityFlags)) - \
                              FIELD_OFFSET(DEVICE_CAPABILITIES, Version) - \
                              FIELD_SIZE(DEVICE_CAPABILITIES, Version)))

//
// BOOT allocation related declarations.
//

typedef
NTSTATUS
(*PIO_ALLOCATE_BOOT_RESOURCES_ROUTINE) (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    );

NTSTATUS
IopAllocateBootResources (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    );

NTSTATUS
IopReportBootResources (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    );

NTSTATUS
IopAllocateLegacyBootResources (
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber
    );

extern PIO_ALLOCATE_BOOT_RESOURCES_ROUTINE IopAllocateBootResourcesRoutine;

//
// Legacy Bus information related declarations.
//

extern LIST_ENTRY  IopLegacyBusInformationTable[];

VOID
IopInsertLegacyBusDeviceNode (
    IN PDEVICE_NODE BusDeviceNode,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber
    );

#define IopRemoveLegacyBusDeviceNode(d) RemoveEntryList(&((PDEVICE_NODE)d)->LegacyBusListEntry)

//
// Conflict detection declarations
//

NTSTATUS
IopQueryConflictList(
    PDEVICE_OBJECT                  PhysicalDeviceObject,
    IN      PCM_RESOURCE_LIST               ResourceList,
    IN      ULONG                           ResourceListSize,
    OUT     PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN      ULONG                           ConflictListSize,
    IN      ULONG                           Flags
    );

NTSTATUS
EisaBuildEisaDeviceNode(
    VOID
    );

//
// General utility macros
//

//
// This macros calculates the size in bytes of a constant string
//
//  ULONG
//  IopConstStringSize(
//      IN CONST PWSTR String
//      );
//

#define IopConstStringSize(String)          ( sizeof(String) - sizeof(UNICODE_NULL) )

//
// This macros calculates the number of characters of a constant string
//
//  ULONG
//  IopConstStringLength(
//      IN CONST PWSTR String
//      );
//

#define IopConstStringLength(String)        ( ( sizeof(String) - sizeof(UNICODE_NULL) ) / sizeof(WCHAR) )

//
// Kernel mode notification
//

//
// This macros maps a guid to a hash value based on the number of hash
// buckets we are using.  It does this by treating the  guid as an array of
// 4 ULONGs, suming them and MOD by the number of hash buckets we are using.
//
//  ULONG
//  IopHashGuid(
//      LPGUID Guid
//      );
//

#define IopHashGuid(_Guid) \
            ( ( ((PULONG)_Guid)[0] + ((PULONG)_Guid)[1] + ((PULONG)_Guid)[2] \
                + ((PULONG)_Guid)[3]) % NOTIFY_DEVICE_CLASS_HASH_BUCKETS)



//  This macros abstracts
//
//  VOID
//  IopAcquireNotifyLock(
//      PKGUARDED_MUTEX Lock
//      )

#define IopAcquireNotifyLock(Lock)     KeAcquireGuardedMutex(Lock);

/*
VOID
IopReleaseNotifyLock(
    PKGUARDED_MUTEX Lock
    )
*/
#define IopReleaseNotifyLock(Lock)     KeReleaseGuardedMutex(Lock);


//  BOOLEAN
//  IopCompareGuid(
//      IN LPGUID guid1,
//      IN LPGUID guid2
//      );

#define IopCompareGuid(g1, g2)  ( (g1) == (g2) \
                                    ? TRUE \
                                    : RtlCompareMemory( (g1), (g2), sizeof(GUID) ) == sizeof(GUID) \
                                    )

VOID
IopInitializePlugPlayNotification(
    VOID
    );

NTSTATUS
IopNotifySetupDeviceArrival(
        PDEVICE_OBJECT PhysicalDeviceObject,    // PDO of the device
        HANDLE EnumEntryKey,                    // Handle into the enum branch of the registry for this device
        BOOLEAN InstallDriver                   // Should setup attempt to install a driver
);

NTSTATUS
IopRequestHwProfileChangeNotification(
    IN   LPGUID                      EventGuid,
    IN   PROFILE_NOTIFICATION_TIME   NotificationTime,
    OUT  PPNP_VETO_TYPE              VetoType           OPTIONAL,
    OUT  PUNICODE_STRING             VetoName           OPTIONAL
    );

NTSTATUS
IopNotifyTargetDeviceChange(
    IN  LPCGUID                             EventGuid,
    IN  PDEVICE_OBJECT                      DeviceObject,
    IN  PTARGET_DEVICE_CUSTOM_NOTIFICATION  NotificationStructure   OPTIONAL,
    OUT PDRIVER_OBJECT                     *VetoingDriver
    );

NTSTATUS
IopGetRelatedTargetDevice(
    IN PFILE_OBJECT FileObject,
    OUT PDEVICE_NODE *DeviceNode
    );

NTSTATUS
IopNotifyDeviceClassChange(
    LPGUID EventGuid,
    LPGUID ClassGuid,
    PUNICODE_STRING SymbolicLinkName
    );

NTSTATUS
IopRegisterDeviceInterface(
    IN PUNICODE_STRING DeviceInstanceName,
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING ReferenceString      OPTIONAL,
    IN BOOLEAN UserModeFormat,
    OUT PUNICODE_STRING SymbolicLinkName
    );

NTSTATUS
IopUnregisterDeviceInterface(
    IN PUNICODE_STRING SymbolicLinkName
    );

NTSTATUS
IopRemoveDeviceInterfaces(
    IN PUNICODE_STRING DeviceInstancePath
    );

NTSTATUS
IopDisableDeviceInterfaces(
    IN PUNICODE_STRING DeviceInstancePath
    );

NTSTATUS
IopGetDeviceInterfaces(
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING DevicePath   OPTIONAL,
    IN ULONG Flags,
    IN BOOLEAN UserModeFormat,
    OUT PWSTR *SymbolicLinkList,
    OUT PULONG SymbolicLinkListSize OPTIONAL
    );

NTSTATUS
IopDoDeferredSetInterfaceState(
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
IopProcessSetInterfaceState(
    IN PUNICODE_STRING SymbolicLinkName,
    IN BOOLEAN Enable,
    IN BOOLEAN DeferNotStarted
    );

NTSTATUS
IopReplaceSeperatorWithPound(
    OUT PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

NTSTATUS
IopNotifyHwProfileChange(
    IN  LPGUID           EventGuid,
    OUT PPNP_VETO_TYPE   VetoType    OPTIONAL,
    OUT PUNICODE_STRING  VetoName    OPTIONAL
    );

VOID
IopUncacheInterfaceInformation(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// Notify entry header - all notify entries have these
//

typedef struct _NOTIFY_ENTRY_HEADER {

    //
    // List Entry structure
    //

    LIST_ENTRY ListEntry;

    //
    // Notification event category for this notification entry.
    //

    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;

    //
    // SessionId.
    //
    ULONG SessionId;

    //
    // Session space object to attach to for sending notification.
    //
    PVOID OpaqueSession;

    //
    // Callback routine passed in at registration
    //

    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;

    //
    // Context passed in at registration
    //

    PVOID Context;

    //
    // Driver object of the driver that registered for notifications.  Required
    // so we can dereference it when it unregisters
    //

    PDRIVER_OBJECT DriverObject;

    //
    // RefCount is the number of outstanding pointers to the node and avoids
    // deletion while another notification is taking place
    //

    USHORT RefCount;

    //
    // Unregistered is set if this notification has been unregistered but cannot
    // be removed from the list because other entities are using it
    //

    BOOLEAN Unregistered;

    //
    // Lock is a pointer to the fast mutex which is used to synchronise access
    // to the list this node is a member of and is required so that the correct
    // list can be locked during IoUnregisterPlugPlayNotification.  If no locking
    // is required it is NULL
    //

    PKGUARDED_MUTEX Lock;

} NOTIFY_ENTRY_HEADER, *PNOTIFY_ENTRY_HEADER;


//
// Data to store for each target device registration
//

typedef struct _TARGET_DEVICE_NOTIFY_ENTRY {

    //
    // Header entries
    //

    LIST_ENTRY ListEntry;
    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;
    ULONG SessionId;
    PVOID OpaqueSession;
    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Context;
    PDRIVER_OBJECT DriverObject;
    USHORT RefCount;
    BOOLEAN Unregistered;
    PKGUARDED_MUTEX Lock;

    //
    // FileObject - the file object of the target device we are interested in
    //

    PFILE_OBJECT FileObject;

    //
    // PhysicalDeviceObject -- the PDO upon which this notification is hooked.
    // We need to keep this here, so we can dereference it when the refcount
    // on this notification entry drops to zero.
    //

    PDEVICE_OBJECT PhysicalDeviceObject;

} TARGET_DEVICE_NOTIFY_ENTRY, *PTARGET_DEVICE_NOTIFY_ENTRY;

//
// Data to store for each device class registration
//

typedef struct _DEVICE_CLASS_NOTIFY_ENTRY {

    //
    // Header entries
    //

    LIST_ENTRY ListEntry;
    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;
    ULONG SessionId;
    PVOID OpaqueSession;
    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Context;
    PDRIVER_OBJECT DriverObject;
    USHORT RefCount;
    BOOLEAN Unregistered;
    PKGUARDED_MUTEX Lock;

    //
    // ClassGuid - the guid of the device class we are interested in
    //

    GUID ClassGuid;

} DEVICE_CLASS_NOTIFY_ENTRY, *PDEVICE_CLASS_NOTIFY_ENTRY;

//
// Data to store for registration of the Reserved (ie setupdd.sys) variety
//

typedef struct _SETUP_NOTIFY_DATA {

    //
    // Header entries
    //

    LIST_ENTRY ListEntry;
    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;
    ULONG SessionId;
    PVOID OpaqueSession;
    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Context;
    PDRIVER_OBJECT DriverObject;
    USHORT RefCount;
    BOOLEAN Unregistered;
    PKGUARDED_MUTEX Lock;

} SETUP_NOTIFY_DATA, *PSETUP_NOTIFY_DATA;


//
// Data to store for registration for HardwareProfileChange Events
//

typedef struct _HWPROFILE_NOTIFY_ENTRY {

    //
    // Header entries
    //

    LIST_ENTRY ListEntry;
    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;
    ULONG SessionId;
    PVOID OpaqueSession;
    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Context;
    PDRIVER_OBJECT DriverObject;
    USHORT RefCount;
    BOOLEAN Unregistered;
    PKGUARDED_MUTEX Lock;

} HWPROFILE_NOTIFY_ENTRY, *PHWPROFILE_NOTIFY_ENTRY;

#define PNP_NOTIFICATION_VERSION            1
#define NOTIFY_DEVICE_CLASS_HASH_BUCKETS    13

//
// IopMaxDeviceNodeLevel - Level number of the DeviceNode deepest in the tree
//
extern ULONG       IopMaxDeviceNodeLevel;
extern ULONG       IoDeviceNodeTreeSequence;

//
// Global notification data
//

extern KGUARDED_MUTEX IopDeviceClassNotifyLock;
extern LIST_ENTRY IopDeviceClassNotifyList[];
extern PSETUP_NOTIFY_DATA IopSetupNotifyData;
extern KGUARDED_MUTEX IopTargetDeviceNotifyLock;
extern LIST_ENTRY IopProfileNotifyList;
extern KGUARDED_MUTEX IopHwProfileNotifyLock;

VOID
IopProcessDeferredRegistrations(
    VOID
    );

//
// Generic buffer management
//

typedef struct _BUFFER_INFO {

    //
    // Buffer - pointer to the start of the buffer
    //

    PCHAR Buffer;

    //
    // Current - Pointer to the current position in the buffer
    //

    PCHAR Current;

    //
    // MaxSize - Maximum size of the buffer in bytes
    //

    ULONG MaxSize;

} BUFFER_INFO, *PBUFFER_INFO;

typedef struct _BUS_TYPE_GUID_LIST {

    //
    // Number of allocated guid slots in the table.
    //
    ULONG Count;

    //
    // Number of entries used so far.
    //
    KGUARDED_MUTEX Lock;

    //
    // Array of bus type guids
    //
    GUID Guid[1];

} BUS_TYPE_GUID_LIST, *PBUS_TYPE_GUID_LIST;

//
// List of queried bus type guids
//
extern PBUS_TYPE_GUID_LIST IopBusTypeGuidList;

//
// Arbiter entry points
//

NTSTATUS
IopPortInitialize(
    VOID
    );

NTSTATUS
IopMemInitialize(
    VOID
    );

NTSTATUS
IopIrqInitialize(
    VOID
    );

NTSTATUS
IopDmaInitialize(
    VOID
    );

NTSTATUS
IopBusNumberInitialize(
    VOID
    );

//
// Arbiter state
//

extern ARBITER_INSTANCE IopRootPortArbiter;
extern ARBITER_INSTANCE IopRootMemArbiter;
extern ARBITER_INSTANCE IopRootIrqArbiter;
extern ARBITER_INSTANCE IopRootDmaArbiter;
extern ARBITER_INSTANCE IopRootBusNumberArbiter;

//
// Buffer management routines.
//

NTSTATUS
IopAllocateBuffer(
    IN PBUFFER_INFO Info,
    IN ULONG Size
    );

NTSTATUS
IopResizeBuffer(
    IN PBUFFER_INFO Info,
    IN ULONG NewSize,
    IN BOOLEAN CopyContents
    );

VOID
IopFreeBuffer(
    IN PBUFFER_INFO Info
    );


//
// UnicodeString management routines.
//

NTSTATUS
IopAllocateUnicodeString(
    IN OUT PUNICODE_STRING String,
    IN USHORT Length
    );

//
// Misc.
//

BOOLEAN
PipFixupDeviceId(
    PWCHAR DeviceId,
    ULONG AllowedSeparators
    );

VOID
IopOrphanNotification (
    PDEVICE_NODE DeviceNode
    );

PVOID
PiAllocateCriticalMemory(
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     DeleteType,
    IN  POOL_TYPE                       PoolType,
    IN  SIZE_T                          Size,
    IN  ULONG                           Tag
    );

//
// Warm eject externs and function prototypes
//
extern KEVENT IopWarmEjectLock;
extern PDEVICE_OBJECT IopWarmEjectPdo;

NTSTATUS
IopWarmEjectDevice(
    IN PDEVICE_OBJECT      DeviceToEject,
    IN SYSTEM_POWER_STATE  LightestSleepState
    );

NTSTATUS
IopSystemControlDispatch(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    );

VOID
PiLockDeviceActionQueue(
    VOID
    );

VOID
PiUnlockDeviceActionQueue(
    VOID
    );

//
// This macro takes a value and an alignment and rounds the entry up
// appropriately. The alignment MUST be a power of two!
//
#define ALIGN_UP_ULONG(value, alignment) (((value)+(alignment)-1)&(~(alignment-1)))

#if DBG

#define PP_DEVNODESTATE_NAME(s) ((s >= DeviceNodeUnspecified && s <= MaxDeviceNodeState)? PpStateToNameTable[(s) - DeviceNodeUnspecified] : PpStateToNameTable[0])

extern char *PpStateToNameTable[];

#else

#define PP_DEVNODESTATE_NAME(s)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpevent.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnpevent.c

Abstract:

    Routines dealing with Plug and Play event management/notification.

Author:

    Lonny McMichael (lonnym) 02/14/95
    Paula Tomlinson (paulat) 07/01/96

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop
#include <wdmguid.h>
#include <pnpmgr.h>
#include <pnpsetup.h>

/*
 * Design notes:
 *
 *     When UmPnpMgr needs to initiate an action (which it might do to complete
 * a CmXxx API), it calls NtPlugPlayControl. NtPlugPlayControl then usually
 * invokes one of the PpSetXxx functions. Similarly, if Io routines need to
 * initiate such an action (say due a hardware initiated eject), they call one
 * of the following PpSetXxx functions (or an intermediate):
 *
 * Operations synchronized via the queue
 *     PpSetDeviceClassChange           (async)
 *     PpSetTargetDeviceRemove          (optional event)
 *     PpSetCustomTargetEvent           (optional event)
 *     PpSetHwProfileChangeEvent        (optional event)
 *     PpSetPowerEvent                  (optional event)
 *     PpSetPlugPlayEvent               (async)
 *     PpSetDeviceRemovalSafe           (optional event)
 *     PpSetBlockedDriverEvent          (async)
 *     PpSynchronizeDeviceEventQueue    (sync, enqueues a noop to flush queue)
 *
 * The PpSetXxx functions enqueue items to be processed into the Pnp event
 * queue (via PiInsertEventInQueue). Whenever one of these events are inserted
 * into the queue a worker routine is ensured to be available to process it
 * (PiWalkDeviceList).
 *
 * In general, events processed in PiWalkDeviceList fall into two categories -
 * those that are notifications for user mode (queued by kernel mode), and those
 * that are queued operations.
 *
 * User mode notifications are sent by invoking PiNotifyUserMode. That routine
 * gets UmPnpMgr's attention and copies up a buffer for it to digest. This
 * operation is synchronous, PiNotifyUserMode waits until UmPnpMgr.Dll signals
 * it is done (NtPlugPlayControl calls PiUserResponse) before returning.
 *
 * Queued operations (such as PiProcessQueryRemoveAndEject) may be very involved
 * and could generate other events solely for user mode (via calls to
 * PiNotifyUserMode, PiNotifyUserModeRemoveVetoed). These operations may also
 * need to synchronously call kernel and user mode code that registered for the
 * appropriate events (via the IopNotifyXxx functions).
 *
 */

//
// Pool Tags
//
#define PNP_DEVICE_EVENT_LIST_TAG  'LEpP'
#define PNP_DEVICE_EVENT_ENTRY_TAG 'EEpP'
#define PNP_USER_BLOCK_TAG         'BUpP'
#define PNP_DEVICE_WORK_ITEM_TAG   'IWpP'
#define PNP_POOL_EVENT_BUFFER      'BEpP'

//
// PNP_USER_BLOCK
//
//  The caller block contains info describing the caller of
//  NtGetPlugPlayEvent. There's only one caller block.
//

typedef struct _PNP_USER_BLOCK {
    NTSTATUS                Status;
    ULONG                   Result;
    PPNP_VETO_TYPE          VetoType;
    PUNICODE_STRING         VetoName;
    ERESOURCE               Lock;
    KEVENT                  Registered;
    KEVENT                  NotifyUserEvent;
    KEVENT                  UserResultEvent;
    PVOID                   PoolBuffer;
    ULONG                   PoolUsed;
    ULONG                   PoolSize;
    BOOLEAN                 Deferred;

} PNP_USER_BLOCK, *PPNP_USER_BLOCK;

//
// Local (private) function prototypes
//

NTSTATUS
PiInsertEventInQueue(
    IN PPNP_DEVICE_EVENT_ENTRY DeviceEvent
    );

VOID
PiWalkDeviceList(
    IN PVOID Context
    );

NTSTATUS
PiNotifyUserMode(
    PPNP_DEVICE_EVENT_ENTRY DeviceEvent
    );

NTSTATUS
PiNotifyUserModeDeviceRemoval(
    IN  PPNP_DEVICE_EVENT_ENTRY TemplateDeviceEvent,
    IN  CONST GUID              *EventGuid,
    OUT PPNP_VETO_TYPE          VetoType                OPTIONAL,
    OUT PUNICODE_STRING         VetoName                OPTIONAL
    );

NTSTATUS
PiNotifyUserModeRemoveVetoed(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PNP_VETO_TYPE            VetoType,
    IN PUNICODE_STRING          VetoName        OPTIONAL
    );

NTSTATUS
PiNotifyUserModeRemoveVetoedByList(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PNP_VETO_TYPE            VetoType,
    IN PWSTR                    MultiSzVetoList
    );

NTSTATUS
PiNotifyUserModeKernelInitiatedEject(
    IN  PDEVICE_OBJECT          DeviceObject,
    OUT PNP_VETO_TYPE          *VetoType,
    OUT PUNICODE_STRING         VetoName
    );

NTSTATUS
PiProcessQueryRemoveAndEject(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    );

NTSTATUS
PiProcessTargetDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    );

NTSTATUS
PiProcessCustomDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    );

NTSTATUS
PiResizeTargetDeviceBlock(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent,
    IN PLUGPLAY_DEVICE_DELETE_TYPE DeleteType,
    IN PRELATION_LIST RelationsList,
    IN BOOLEAN ExcludeIndirectRelations
    );

VOID
PiBuildUnsafeRemovalDeviceBlock(
    IN  PPNP_DEVICE_EVENT_ENTRY     OriginalDeviceEvent,
    IN  PRELATION_LIST              RelationsList,
    OUT PPNP_DEVICE_EVENT_ENTRY    *AllocatedDeviceEvent
    );

VOID
PiFinalizeVetoedRemove(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PNP_VETO_TYPE            VetoType,
    IN PUNICODE_STRING          VetoName        OPTIONAL
    );

VOID
LookupGuid(
    IN CONST GUID *Guid,
    IN OUT PCHAR String,
    IN ULONG StringLength
    );

VOID
DumpMultiSz(
    IN PWCHAR MultiSz
    );

VOID
DumpPnpEvent(
    IN PPLUGPLAY_EVENT_BLOCK EventBlock
    );

typedef struct {

    ULONG HandleCount;
    LOGICAL DumpHandles;
    LOGICAL CollectHandles;
    PUNICODE_STRING VetoString;

} ENUM_HANDLES_CONTEXT, *PENUM_HANDLES_CONTEXT;

LOGICAL
PiCollectOpenHandles(
    IN      PDEVICE_OBJECT  *DeviceObjectArray,
    IN      ULONG           ArrayCount,
    IN      LOGICAL         KnownHandleFailure,
    IN OUT  PUNICODE_STRING VetoString
    );

LOGICAL
PiCollectOpenHandlesCallBack(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PEPROCESS       Process,
    IN  PFILE_OBJECT    FileObject,
    IN  HANDLE          HandleId,
    IN  PVOID           Context
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, DumpMultiSz)
#pragma alloc_text(PAGE, DumpPnpEvent)
#pragma alloc_text(PAGE, LookupGuid)
#pragma alloc_text(PAGE, PiCollectOpenHandles)
#pragma alloc_text(PAGE, PiCollectOpenHandlesCallBack)

#pragma alloc_text(PAGE, NtGetPlugPlayEvent)

#pragma alloc_text(PAGE, PiCompareGuid)
#pragma alloc_text(PAGE, PiInsertEventInQueue)
#pragma alloc_text(PAGE, PiNotifyUserMode)
#pragma alloc_text(PAGE, PiNotifyUserModeDeviceRemoval)
#pragma alloc_text(PAGE, PiNotifyUserModeKernelInitiatedEject)
#pragma alloc_text(PAGE, PiNotifyUserModeRemoveVetoed)
#pragma alloc_text(PAGE, PiNotifyUserModeRemoveVetoedByList)
#pragma alloc_text(PAGE, PiProcessCustomDeviceEvent)
#pragma alloc_text(PAGE, PiProcessQueryRemoveAndEject)
#pragma alloc_text(PAGE, PiProcessTargetDeviceEvent)
#pragma alloc_text(PAGE, PiResizeTargetDeviceBlock)
#pragma alloc_text(PAGE, PiBuildUnsafeRemovalDeviceBlock)
#pragma alloc_text(PAGE, PiUserResponse)
#pragma alloc_text(PAGE, PiWalkDeviceList)
#pragma alloc_text(PAGE, PiFinalizeVetoedRemove)

#pragma alloc_text(PAGE, PpCompleteDeviceEvent)
#pragma alloc_text(PAGE, PpInitializeNotification)
#pragma alloc_text(PAGE, PpNotifyUserModeRemovalSafe)
#pragma alloc_text(PAGE, PpSetCustomTargetEvent)
#pragma alloc_text(PAGE, PpSetDeviceClassChange)
#pragma alloc_text(PAGE, PpSetDeviceRemovalSafe)
#pragma alloc_text(PAGE, PpSetHwProfileChangeEvent)
#pragma alloc_text(PAGE, PpSetBlockedDriverEvent)
#pragma alloc_text(PAGE, PpSetPlugPlayEvent)
#pragma alloc_text(PAGE, PpSetPowerEvent)
#pragma alloc_text(PAGE, PpSetPowerVetoEvent)
#pragma alloc_text(PAGE, PpSetTargetDeviceRemove)
#pragma alloc_text(PAGE, PpSynchronizeDeviceEventQueue)
#pragma alloc_text(PAGE, PiAllocateCriticalMemory)
#pragma alloc_text(PAGE, PpSetInvalidIDEvent)
#endif

//
// Global Data
//

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#endif

PPNP_DEVICE_EVENT_LIST  PpDeviceEventList = NULL;
PPNP_USER_BLOCK         PpUserBlock = NULL;
BOOLEAN                 PiUserModeRunning = FALSE;
BOOLEAN                 PiNotificationInProgress = FALSE;
PETHREAD                PpDeviceEventThread = NULL;

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif

KGUARDED_MUTEX          PiNotificationInProgressLock;

LOGICAL                 PiDumpVetoedHandles = FALSE;
LOGICAL                 PiCollectVetoedHandles = FALSE;


NTSTATUS
NtGetPlugPlayEvent(
    IN  HANDLE EventHandle,
    IN  PVOID Context                       OPTIONAL,
    OUT PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN  ULONG EventBufferSize
    )

/*++

Routine Description:

    FRONT-END

    This Plug and Play Manager API allows the user-mode PnP manager to
    receive notification of a (kernel-mode) PnP hardware event.

    THIS API IS ONLY CALLABLE BY THE USER-MODE PNP MANAGER. IF ANY OTHER
    COMPONENT CALLS THIS API, THE DELIVERED EVENT WILL BE LOST TO THE REST
    OF THE OPERATING SYSTEM. FURTHERMORE, THERE IS COMPLEX SYNCHRONIZATION
    BETWEEN THE USER-MODE AND KERNEL-MODE PNP MANAGERS, ANYONE ELSE CALLING
    THIS API WILL EVENTUALLY DEADLOCK THE SYSTEM.

Arguments:

    EventHandle - Supplies an event handle that is signalled when an event
                  is ready to be delivered to user-mode.

    EventBlock - Pointer to a PLUGPLAY_EVENT_BLOCK structure that will receive
                 information on the hardware event that has occurred.

    EventBufferLength - Specifies the size, in bytes, of the EventBuffer field
                        in the PLUGPLAY_EVENT_BLOCK pointed to by EventBlock.

Return Value:

    NTSTATUS code indicating whether or not the function was successful

--*/

{
    NTSTATUS  status;
#if DBG
    CHAR    guidString[256];
#endif

    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(EventHandle);

    PAGED_CODE();

    if (KeGetPreviousMode() != UserMode) {
        //
        // This routine only supports user-mode callers.
        //
        IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                   "NtGetPlugPlayEvent: Only allows user-mode callers\n"));

        return STATUS_ACCESS_DENIED;
    }
    if (!SeSinglePrivilegeCheck(SeTcbPrivilege, UserMode)) {
        //
        // Caller does not have "trusted computer base" privilge.
        //
        IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                   "NtGetPlugPlayEvent: Caller does not have \"trusted computer base\" privilge\n"));

        return STATUS_PRIVILEGE_NOT_HELD;
    }
    //
    // UMPNPMGR is now around.
    //
    PiUserModeRunning = TRUE;
    //
    // If we have not deferred on last call, we need to wait for kernel
    // to make data available.
    //
    status = STATUS_SUCCESS;
    if (!PpUserBlock->Deferred) {

        PpUserBlock->PoolUsed = 0;
        //
        // Tell kernel we have a waiter.
        //
        KeSetEvent(&PpUserBlock->Registered, 0, FALSE);
        //
        // Make it a UserMode wait so the terminate APC will unblock us,
        // and we can leave, which cleans up the thread
        //
        status = KeWaitForSingleObject(&PpUserBlock->NotifyUserEvent,
                                       Executive,
                                       UserMode,
                                       FALSE,
                                       NULL);
    }
    if (!NT_SUCCESS(status) || (status == STATUS_USER_APC) ) {

        return status;
    }
    //
    // Data is now available, validate user buffer size.
    //
    if (EventBufferSize < PpUserBlock->PoolUsed) {
        //
        // If user buffer is too small, then return appropriate status and
        // set the Deferred to TRUE so on the next call, we wont wait on kernel
        // mode (since data was already available).
        //
        PpUserBlock->Deferred = TRUE;

        IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                   "NtGetPlugPlayEvent: User-mode buffer too small for event\n"));

        return STATUS_BUFFER_TOO_SMALL;

    }
    //
    // User buffer is big enough so copy any data on success.
    //
    PpUserBlock->Deferred = FALSE;
    status = PpUserBlock->Status;
    if (NT_SUCCESS(status)) {

        if (PpUserBlock->PoolBuffer) {

#if DBG
            LookupGuid(&((PPLUGPLAY_EVENT_BLOCK)(PpUserBlock->PoolBuffer))->EventGuid, guidString, sizeof(guidString));

            IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                       "NtGetPlugPlayEvent: Returning event - EventGuid = %s\n",
                       guidString));
#endif
            status = PiControlMakeUserModeCallersCopy(
                        &EventBlock,
                        PpUserBlock->PoolBuffer,
                        PpUserBlock->PoolUsed,
                        sizeof(ULONG),
                        UserMode,
                        FALSE);
        } else {

            IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                       "NtGetPlugPlayEvent: Invalid event buffer\n"));
            ASSERT(PpUserBlock->PoolBuffer);

            status = STATUS_UNSUCCESSFUL;
        }
    }

    return status;
} // NtGetPlugPlayEvent

NTSTATUS
PpInitializeNotification(
    VOID
    )

/*++

Routine Description:

    This routine performs initialization required before any of the notification
    events can be processed.  This routine performs init for the master device
    event queue processing.

Parameters:

    None

Return Value:

    Returns a STATUS_Xxx value that indicates whether the function succeeded
    or not.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Allocate and initialize the master device event list.
    //

    PpDeviceEventList = ExAllocatePoolWithTag(NonPagedPool,
                                              sizeof(PNP_DEVICE_EVENT_LIST),
                                              PNP_DEVICE_EVENT_LIST_TAG);
    if (PpDeviceEventList == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean0;
    }

    KeInitializeMutex(&PpDeviceEventList->EventQueueMutex, 0);
    KeInitializeGuardedMutex(&PpDeviceEventList->Lock);
    InitializeListHead(&(PpDeviceEventList->List));
    PpDeviceEventList->Status = STATUS_PENDING;

    //
    // Intialize the PpUserBlock buffer - this buffer contains info about
    // the user-mode caller for NtGetPlugPlayEvent and describes who in user
    // mode we pass the events to.
    //

    PpUserBlock = ExAllocatePoolWithTag(NonPagedPool,
                                        sizeof(PNP_USER_BLOCK),
                                        PNP_USER_BLOCK_TAG);
    if (PpUserBlock == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean0;
    }

    RtlZeroMemory(PpUserBlock, sizeof(PNP_USER_BLOCK));

    PpUserBlock->PoolSize = sizeof (PLUGPLAY_EVENT_BLOCK)+
                            sizeof (PNP_DEVICE_EVENT_ENTRY);
    PpUserBlock->PoolBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                                    PpUserBlock->PoolSize,
                                                    PNP_USER_BLOCK_TAG);
    if (PpUserBlock->PoolBuffer == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        PpUserBlock->PoolSize = 0;
        goto Clean0;
    }

    KeInitializeEvent(&PpUserBlock->Registered, SynchronizationEvent, FALSE);
    KeInitializeEvent(&PpUserBlock->NotifyUserEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent(&PpUserBlock->UserResultEvent, SynchronizationEvent, FALSE);
    ExInitializeResourceLite(&PpUserBlock->Lock);
    // PpUserBlock->Status = STATUS_SUCCESS;
    // PpUserBlock->Result = 0;
    // PpUserBlock->EventBuffer = NULL;
    // PpUserBlock->EventBufferSize = 0;
    // PpUserBlock->PoolUsed = 0;

    KeInitializeGuardedMutex(&PiNotificationInProgressLock);

Clean0:

    return status;

} // PpInitializeNotification


NTSTATUS
PiInsertEventInQueue(
    IN PPNP_DEVICE_EVENT_ENTRY DeviceEvent
    )
{
    PWORK_QUEUE_ITEM workItem;
    NTSTATUS status;

    PAGED_CODE();

    workItem = NULL;
    status = STATUS_SUCCESS;

#if DBG
    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiInsertEventInQueue: Event queued\n"));
    DumpPnpEvent(&DeviceEvent->Data);
#endif

    //
    // Check if a new work item needs to be kicked off. A new work item gets
    // kicked off iff this is the first event in the list.
    //
    KeAcquireGuardedMutex(&PpDeviceEventList->Lock);
    KeAcquireGuardedMutex(&PiNotificationInProgressLock);

    if (!PiNotificationInProgress) {

        workItem = ExAllocatePoolWithTag(NonPagedPool,
                                         sizeof(WORK_QUEUE_ITEM),
                                         PNP_DEVICE_WORK_ITEM_TAG);
        if (workItem) {

            PiNotificationInProgress = TRUE;
            KeClearEvent(&PiEventQueueEmpty);
        } else {

            IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                       "PiInsertEventInQueue: Could not allocate memory to kick off a worker thread\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiInsertEventInQueue: Worker thread already running\n"));
    }
    //
    // Insert the event iff successfull so far.
    //
    InsertTailList(&PpDeviceEventList->List, &DeviceEvent->ListEntry);

    KeReleaseGuardedMutex(&PiNotificationInProgressLock);
    KeReleaseGuardedMutex(&PpDeviceEventList->Lock);
    //
    // Queue the work item if any.
    //
    if (workItem) {

        ExInitializeWorkItem(workItem, PiWalkDeviceList, workItem);
        ExQueueWorkItem(workItem, DelayedWorkQueue);

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiInsertEventInQueue: Kicked off worker thread\n"));
    }

    return status;
}


NTSTATUS
PpSetDeviceClassChange(
    IN CONST GUID *EventGuid,
    IN CONST GUID *ClassGuid,
    IN PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine is called by user-mode pnp manager and drivers (indirectly) to
    submit device interface change events into a serialized asynchronous queue.
    This queue is processed by a work item.

Arguments:

    EventGuid - Indicates what event is triggered has occured.

    ClassGuid - Indicates the class of the device interface that changed.

    SymbolicLinkName - Specifies the symbolic link name associated with the
                interface device.


Return Value:

    None.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG dataSize, totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

#if DBG
    {
        CHAR    eventGuidString[80];
        CHAR    classGuidString[80];

        LookupGuid(EventGuid, eventGuidString, sizeof(eventGuidString));
        LookupGuid(ClassGuid, classGuidString, sizeof(classGuidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PpSetDeviceClassChange: Entered\n    EventGuid = %s\n    ClassGuid = %s\n    SymbolicLinkName = %wZ\n",
                   eventGuidString,
                   classGuidString,
                   SymbolicLinkName));

    }
#endif

    try {

        ASSERT(EventGuid != NULL);
        ASSERT(ClassGuid != NULL);
        ASSERT(SymbolicLinkName != NULL);

        //
        // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
        // we record in the TotalSize field later (the length doesn't count the
        // terminating null but we're already counting the first index into the
        // SymbolicLinkName field so it works out.
        //

        dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) + SymbolicLinkName->Length;
        totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

        deviceEvent = ExAllocatePoolWithTag( PagedPool,
                                             totalSize,
                                             PNP_DEVICE_EVENT_ENTRY_TAG);
        if (deviceEvent == NULL) {
            status = STATUS_NO_MEMORY;
            goto Clean0;
        }

        RtlZeroMemory((PVOID)deviceEvent, totalSize);
        RtlCopyMemory(&deviceEvent->Data.EventGuid, EventGuid, sizeof(GUID));

        deviceEvent->Data.EventCategory = DeviceClassChangeEvent;
        //deviceEvent->Data.Result = NULL;
        //deviceEvent->Data.Flags = 0;
        deviceEvent->Data.TotalSize = dataSize;

        RtlCopyMemory(&deviceEvent->Data.u.DeviceClass.ClassGuid, ClassGuid, sizeof(GUID));
        RtlCopyMemory(&deviceEvent->Data.u.DeviceClass.SymbolicLinkName,
                      SymbolicLinkName->Buffer,
                      SymbolicLinkName->Length);
        deviceEvent->Data.u.DeviceClass.SymbolicLinkName[SymbolicLinkName->Length/sizeof(WCHAR)] = 0x0;

        status = PiInsertEventInQueue(deviceEvent);

Clean0:
        NOTHING;

    } except(PiControlExceptionFilter(GetExceptionInformation())) {

        IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                   "PpSetDeviceClassChange: Exception 0x%08X\n", GetExceptionCode()));
    }

    return status;

} // PpSetDeviceClassChange


NTSTATUS
PpSetCustomTargetEvent(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PKEVENT SyncEvent                           OPTIONAL,
    OUT PULONG Result                               OPTIONAL,
    IN  PDEVICE_CHANGE_COMPLETE_CALLBACK Callback   OPTIONAL,
    IN  PVOID Context                               OPTIONAL,
    IN  PTARGET_DEVICE_CUSTOM_NOTIFICATION NotificationStructure
    )

/*++

Routine Description:

    This routine is called by user-mode pnp manager and drivers (indirectly) to
    submit target device change events into a serialized asynchronous queue.
    This queue is processed by a work item.

Arguments:

    DeviceObject - Indicates the device object for the device that changed.

    SyncEvent - Optionally, specifies a kernel-mode event that will be set when the
            event is finished processing.

    Result - Supplies a pointer to a ULONG that will be filled in with the status
            after the event has actual completed (notification finished and the
            event processed). This value is not used when SyncEvent is NULL and
            is REQUIRED when SyncEvent is supplied.

    NotificationStructure - Specifies the custom Notification to be processed.

Return Value:

    None.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_NODE deviceNode;
    ULONG dataSize, totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    ASSERT(NotificationStructure != NULL);
    ASSERT(DeviceObject != NULL);

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PpSetCustomTargetEvent: DeviceObject = 0x%p, SyncEvent = 0x%p, Result = 0x%p\n",
               DeviceObject,
               SyncEvent,
               Result));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    Callback = 0x%p, Context = 0x%p, NotificationStructure = 0x%p\n",
               Callback,
               Context,
               NotificationStructure));

    if (SyncEvent) {
        ASSERT(Result);
        *Result = STATUS_PENDING;
    }

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //

    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode);

    //
    // This is a custom event block, so build up the PLUGPLAY_EVENT_BLOCK
    // but copy the Notification Structure and put that in the EventBlock
    // so we can dig it out in the handler later
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) + deviceNode->InstancePath.Length + sizeof(UNICODE_NULL);

    //
    // We need to ensure that the Notification structure remains aligned
    // so round up dataSize to a multiple of sizeof(PVOID).
    //

    dataSize += sizeof(PVOID) - 1;
    dataSize &= ~(sizeof(PVOID) - 1);
    dataSize += NotificationStructure->Size;

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool, totalSize, PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)deviceEvent, totalSize);
    deviceEvent->CallerEvent = SyncEvent;
    deviceEvent->Callback = Callback;
    deviceEvent->Context = Context;
    deviceEvent->Data.EventGuid = GUID_PNP_CUSTOM_NOTIFICATION;
    deviceEvent->Data.EventCategory = CustomDeviceEvent;
    deviceEvent->Data.Result = Result;
    deviceEvent->Data.Flags = 0;
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    if (deviceNode->InstancePath.Length != 0) {

        RtlCopyMemory((PVOID)deviceEvent->Data.u.CustomNotification.DeviceIds,
                      (PVOID)deviceNode->InstancePath.Buffer,
                      deviceNode->InstancePath.Length);

        //
        // No need to NUL terminate this string since we initially zeroed the
        // buffer after allocation.
        //
    }

    //
    // Point the custom notification block to the extra space at the
    // end of the allocation
    //

    deviceEvent->Data.u.CustomNotification.NotificationStructure =
         (PVOID)((PUCHAR)deviceEvent + totalSize - NotificationStructure->Size);

    RtlCopyMemory(deviceEvent->Data.u.CustomNotification.NotificationStructure,
                  NotificationStructure,
                  NotificationStructure->Size);

    status = PiInsertEventInQueue(deviceEvent);

    return status;

} // PpSetCustomTargetEvent

NTSTATUS
PpSetTargetDeviceRemove(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  BOOLEAN KernelInitiated,
    IN  BOOLEAN NoRestart,
    IN  BOOLEAN OnlyRestartRelations,
    IN  BOOLEAN DoEject,
    IN  ULONG Problem,
    IN  PKEVENT SyncEvent           OPTIONAL,
    OUT PULONG Result               OPTIONAL,
    OUT PPNP_VETO_TYPE VetoType     OPTIONAL,
    OUT PUNICODE_STRING VetoName    OPTIONAL
    )

/*++

Routine Description:

    This routine is called by user-mode pnp manager and drivers (indirectly) to
    submit target device change events into a serialized asynchronous queue.
    This queue is processed by a work item.

Arguments:

    EventGuid - Indicates what event is triggered has occured.

    DeviceObject - Indicates the device object for the device that changed.

    SyncEvent - Optionally, specifies a kernel-mode event that will be set when the
            event is finished processing.

    Result - Supplies a pointer to a ULONG that will be filled in with the status
            after the event has actual completed (notification finished and the
            event processed). This value is not used when SyncEvent is NULL and
            is REQUIRED when SyncEvent is supplied.

    Flags - Current can be set to the following flags (bitfields)
                TDF_PERFORMACTION
                TDF_DEVICEEJECTABLE.

    NotificationStructure - If present, implies that EventGuid is NULL, and specifies
            a custom Notification to be processed. By definition it cannot be an event of
            type GUID_TARGET_DEVICE_QUERY_REMOVE, GUID_TARGET_DEVICE_REMOVE_CANCELLED, or
            GUID_TARGET_DEVICE_REMOVE_COMPLETE.


Return Value:

    None.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_NODE deviceNode;
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);

    if (SyncEvent) {
        ASSERT(Result);
        *Result = STATUS_PENDING;
    }

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PpSetTargetDeviceRemove: Entered\n"));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    DeviceObject = 0x%p, NoRestart = %d, Problem = %d\n",
               DeviceObject,
               NoRestart,
               Problem));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    SyncEvent = 0x%p, Result = 0x%p\n",
               SyncEvent,
               Result));

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //

    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode);


    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (the length doesn't count the
    // terminating null but we're already counting the first index into the
    // DeviceId field so it works out. Add one more for double-null term.
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK);

    dataSize += deviceNode->InstancePath.Length + sizeof(WCHAR);

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool, totalSize, PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory((PVOID)deviceEvent, totalSize);

    deviceEvent->CallerEvent = SyncEvent;
    deviceEvent->Argument = Problem;
    deviceEvent->VetoType = VetoType;
    deviceEvent->VetoName = VetoName;
    deviceEvent->Data.EventGuid = DoEject ? GUID_DEVICE_EJECT : GUID_DEVICE_QUERY_AND_REMOVE;
    deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
    deviceEvent->Data.Result = Result;

    if (NoRestart) {
        deviceEvent->Data.Flags |= TDF_NO_RESTART;
    }

    if (KernelInitiated) {
        deviceEvent->Data.Flags |= TDF_KERNEL_INITIATED;
    }

    if (OnlyRestartRelations) {
        ASSERT(!NoRestart);
        deviceEvent->Data.Flags |= TDF_ONLY_RESTART_RELATIONS;
    }

    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    if (deviceNode->InstancePath.Length != 0) {

        RtlCopyMemory((PVOID)deviceEvent->Data.u.TargetDevice.DeviceIds,
                    (PVOID)deviceNode->InstancePath.Buffer,
                    deviceNode->InstancePath.Length);
    }

    i = deviceNode->InstancePath.Length/sizeof(WCHAR);
    deviceEvent->Data.u.TargetDevice.DeviceIds[i] = L'\0';

    status = PiInsertEventInQueue(deviceEvent);

    return status;

} // PpSetTargetDeviceRemove


NTSTATUS
PpSetDeviceRemovalSafe(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PKEVENT SyncEvent           OPTIONAL,
    OUT PULONG Result               OPTIONAL
    )

/*++

Routine Description:

    This routine is called to notify user mode a device can be removed. The IO
    system may queue this event when a hardware initiated eject has completed.

Arguments:

    DeviceObject - Indicates the device object for the device that changed.

    SyncEvent - Optionally, specifies a kernel-mode event that will be set when the
            event is finished processing.

    Result - Supplies a pointer to a ULONG that will be filled in with the status
            after the event has actual completed (notification finished and the
            event processed). This value is not used when SyncEvent is NULL and
            is REQUIRED when SyncEvent is supplied.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);

    if (SyncEvent) {
        ASSERT(Result);
        *Result = STATUS_PENDING;
    }

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PpSetDeviceRemovalSafe: Entered\n"));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    DeviceObject = 0x%p, SyncEvent = 0x%p, Result = 0x%p\n",
               DeviceObject,
               SyncEvent,
               Result));

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //

    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode);


    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (the length doesn't count the
    // terminating null but we're already counting the first index into the
    // DeviceId field so it works out. Add one more for double-null term.
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK);

    dataSize += deviceNode->InstancePath.Length + sizeof(WCHAR);

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool, totalSize, PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory((PVOID)deviceEvent, totalSize);

    deviceEvent->CallerEvent = SyncEvent;
    deviceEvent->Argument = 0;
    deviceEvent->VetoType = NULL;
    deviceEvent->VetoName = NULL;
    deviceEvent->Data.EventGuid = GUID_DEVICE_SAFE_REMOVAL;
    deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
    deviceEvent->Data.Result = Result;
    deviceEvent->Data.Flags = 0;

    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    if (deviceNode->InstancePath.Length != 0) {

        RtlCopyMemory((PVOID)deviceEvent->Data.u.TargetDevice.DeviceIds,
                    (PVOID)deviceNode->InstancePath.Buffer,
                    deviceNode->InstancePath.Length);
    }

    i = deviceNode->InstancePath.Length/sizeof(WCHAR);
    deviceEvent->Data.u.TargetDevice.DeviceIds[i] = L'\0';

    status = PiInsertEventInQueue(deviceEvent);

    return status;

} // PpSetDeviceRemovalSafe


NTSTATUS
PpSetHwProfileChangeEvent(
    IN   GUID CONST *EventTypeGuid,
    IN   PKEVENT CompletionEvent    OPTIONAL,
    OUT  PNTSTATUS CompletionStatus OPTIONAL,
    OUT  PPNP_VETO_TYPE VetoType    OPTIONAL,
    OUT  PUNICODE_STRING VetoName   OPTIONAL
    )
{
    ULONG dataSize,totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

#if DBG
    {
        CHAR    eventGuidString[80];

        LookupGuid(EventTypeGuid, eventGuidString, sizeof(eventGuidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PpSetHwProfileChangeEvent: Entered\n    EventGuid = %s\n\n",
                   eventGuidString));
    }
#endif

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    dataSize =  sizeof(PLUGPLAY_EVENT_BLOCK);

    totalSize = dataSize + FIELD_OFFSET (PNP_DEVICE_EVENT_ENTRY,Data);



    deviceEvent = ExAllocatePoolWithTag (PagedPool,
                                          totalSize,
                                          PNP_DEVICE_EVENT_ENTRY_TAG);

    if (NULL == deviceEvent) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Setup the PLUGPLAY_EVENT_BLOCK
    //
    RtlZeroMemory ((PVOID)deviceEvent,totalSize);
    deviceEvent->CallerEvent = CompletionEvent;
    deviceEvent->VetoType = VetoType;
    deviceEvent->VetoName = VetoName;

    deviceEvent->Data.EventCategory = HardwareProfileChangeEvent;
    RtlCopyMemory(&deviceEvent->Data.EventGuid, EventTypeGuid, sizeof(GUID));
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.Result = (PULONG)CompletionStatus;

    status = PiInsertEventInQueue(deviceEvent);

    return status;

} // PpSetHwProfileChangeEvent


NTSTATUS
PpSetBlockedDriverEvent(
    IN   GUID CONST *BlockedDriverGuid
    )

/*++

Routine Description:

    This routine is called to notify user mode of blocked driver events.

Arguments:

    BlockedDriverGuid - Specifies the GUID which identifies the blocked driver.

Return Value:

    Returns the status of inserting the event into the synchronized pnp event
    queue.

--*/

{
    ULONG dataSize, totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    NTSTATUS status;

    PAGED_CODE();

    if (PpPnpShuttingDown) {
        return STATUS_TOO_LATE;
    }

    //
    // Allocate a device event entry.
    //
    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK);
    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Setup the PLUGPLAY_EVENT_BLOCK
    //
    RtlZeroMemory ((PVOID)deviceEvent, totalSize);
    deviceEvent->Data.EventGuid = GUID_DRIVER_BLOCKED;
    deviceEvent->Data.EventCategory = BlockedDriverEvent;
    deviceEvent->Data.TotalSize = dataSize;
    RtlCopyMemory(&deviceEvent->Data.u.BlockedDriverNotification.BlockedDriverGuid,
                  BlockedDriverGuid,
                  sizeof(GUID));

    //
    // Insert the event into the queue.
    //
    status = PiInsertEventInQueue(deviceEvent);

    return status;

} // PpSetBlockedDriverEvent


NTSTATUS
PpSetInvalidIDEvent(
    IN   PUNICODE_STRING ParentInstance
    )
/*++

Routine Description:

    This routine is called to notify user mode when an invalid ID is encountered.

Arguments:

    ParentInstance - Specifies the instance path of the parent of the device with
    invalid ID.

Return Value:

    Returns the status of inserting the event into the synchronized pnp event
    queue.

--*/
{
    ULONG dataSize, totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    NTSTATUS status;

    PAGED_CODE();

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }
    //
    // Allocate a device event entry (note that we have one WCHAR reserved
    // as part of the block structure itself).
    //
    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) + ParentInstance->Length + sizeof(UNICODE_NULL);
    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Setup the PLUGPLAY_EVENT_BLOCK
    //
    RtlZeroMemory ((PVOID)deviceEvent, totalSize);

    deviceEvent->Data.EventGuid = GUID_DEVICE_INVALID_ID;
    deviceEvent->Data.EventCategory = InvalidIDEvent;
    deviceEvent->Data.TotalSize = dataSize;
    RtlCopyMemory(&deviceEvent->Data.u.InvalidIDNotification.ParentId[0],
                  ParentInstance->Buffer,
                  ParentInstance->Length);
    deviceEvent->Data.u.InvalidIDNotification.ParentId[ParentInstance->Length / sizeof(WCHAR)] = UNICODE_NULL;
    deviceEvent->Data.u.InvalidIDNotification.ParentId[(ParentInstance->Length / sizeof(WCHAR)) + 1] = UNICODE_NULL;

    //
    // Insert the event into the queue.
    //
    status = PiInsertEventInQueue(deviceEvent);

    return status;

} // PpSetInvalidIDEvent


NTSTATUS
PpSetPowerEvent(
    IN   ULONG EventCode,
    IN   ULONG EventData,
    IN   PKEVENT CompletionEvent    OPTIONAL,
    OUT  PNTSTATUS CompletionStatus OPTIONAL,
    OUT  PPNP_VETO_TYPE VetoType    OPTIONAL,
    OUT  PUNICODE_STRING VetoName   OPTIONAL
    )
/*++

Routine Description:

    This routine is called to notify user mode of system-wide power events.

Arguments:

    EventCode - Supplies the power event code that is to be communicated
            to user-mode components.

            (Specifically, this event code is actually one of the PBT_APM*
            user-mode power event ids, as defined in sdk\inc\winuser.h.  It is
            typically used as the WPARAM data associated with WM_POWERBROADCAST
            user-mode window messages.  It is supplied to kernel-mode PnP,
            directly from win32k, for the explicit purpose of user-mode power
            event notification.)

    EventData - Specifies additional event-specific data for the specified
            power event id.

            (Specifically, this event data is the LPARAM data for the
            corresponding PBT_APM* user-mode power event id, specified above.)

    CompletionEvent - Optionally, specifies a kernel-mode event that will be set when the
            event is finished processing.

    CompletionStatus - Supplies a pointer to a ULONG that will be filled in with the status
            after the event has actual completed (notification finished and the
            event processed). This value is not used when SyncEvent is NULL and
            is REQUIRED when SyncEvent is supplied.


    VetoType - Optionally, if the specified EventCode is a query-type operation,
            this argument supplies a pointer to an address that will receive the
            type of the vetoing user-mode component, in the event that the
            request is denied.

    VetoName - Optionally, if the specified EventCode is a query-type operation,
            this argument supplies a pointer to a UNICODE_STRING that will
            receive the name of the vetoing user-mode component, in the event
            that the request is denied.


Return Value:

    Returns the status of inserting the event into the synchronized pnp event
    queue.

    For the final status of a synchronous power event, check the value at the
    location specified by CompletionStatus, once the supplied CompletionEvent
    has been set.

--*/

{
    ULONG dataSize,totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PpSetPowerEvent: Entered\n\n") );

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    dataSize =  sizeof(PLUGPLAY_EVENT_BLOCK);

    totalSize = dataSize + FIELD_OFFSET (PNP_DEVICE_EVENT_ENTRY,Data);

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);

    if (NULL == deviceEvent) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //Setup the PLUGPLAY_EVENT_BLOCK
    //
    RtlZeroMemory ((PVOID)deviceEvent,totalSize);
    deviceEvent->CallerEvent = CompletionEvent;
    deviceEvent->VetoType = VetoType;
    deviceEvent->VetoName = VetoName;

    deviceEvent->Data.EventCategory = PowerEvent;
    deviceEvent->Data.EventGuid = GUID_PNP_POWER_NOTIFICATION;
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.Result = (PULONG)CompletionStatus;
    deviceEvent->Data.u.PowerNotification.NotificationCode = EventCode;
    deviceEvent->Data.u.PowerNotification.NotificationData = EventData;

    status = PiInsertEventInQueue(deviceEvent);

    return status;
} // PpSetPowerEvent

NTSTATUS
PpSetPowerVetoEvent(
    IN  POWER_ACTION    VetoedPowerOperation,
    IN  PKEVENT         CompletionEvent         OPTIONAL,
    OUT PNTSTATUS       CompletionStatus        OPTIONAL,
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PNP_VETO_TYPE   VetoType,
    IN  PUNICODE_STRING VetoName                OPTIONAL
    )
/*++

--*/
{
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    PDEVICE_NODE deviceNode;
    PWCHAR vetoData;
    NTSTATUS status;

    if (PpPnpShuttingDown) {

        return STATUS_TOO_LATE;
    }

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //
    ObReferenceObject(DeviceObject);

    //
    // Given the pdo, retrieve the devnode (the device instance string is
    // attached to the devnode in the InstancePath field).
    //

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {

        ObDereferenceObject(DeviceObject);
        return STATUS_INVALID_PARAMETER_2;
    }

    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (because of the first index into
    // the DeviceIdVetoNameBuffer, this is double null terminated).
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) +
               deviceNode->InstancePath.Length +
               (VetoName ? VetoName->Length : 0) +
               sizeof(WCHAR)*2;

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);

    if (deviceEvent == NULL) {

        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)deviceEvent, totalSize);
    deviceEvent->CallerEvent = CompletionEvent;

    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;
    deviceEvent->Data.Result = (PULONG)CompletionStatus;
    deviceEvent->Data.u.VetoNotification.VetoType = VetoType;

    //
    // You can think of this as a MultiSz string where the first entry is the
    // DeviceId for the device being removed, and the next Id's all corrospond
    // to the vetoers.
    //
    RtlCopyMemory(
        deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer,
        deviceNode->InstancePath.Buffer,
        deviceNode->InstancePath.Length
        );

    i = deviceNode->InstancePath.Length;
    deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)] = UNICODE_NULL;

    if (VetoName) {

        vetoData = (&deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)])+1;

        RtlCopyMemory(vetoData, VetoName->Buffer, VetoName->Length);
        vetoData[VetoName->Length/sizeof(WCHAR)] = UNICODE_NULL;
    }

    //
    // No need to NULL terminate the entry after the last one as we prezero'd
    // the buffer. Now set the appropriate GUID so the UI looks right.
    //
    if (VetoedPowerOperation == PowerActionWarmEject) {

        deviceEvent->Data.EventGuid = GUID_DEVICE_WARM_EJECT_VETOED;

    } else if (VetoedPowerOperation == PowerActionHibernate) {

        deviceEvent->Data.EventGuid = GUID_DEVICE_HIBERNATE_VETOED;

    } else {

        deviceEvent->Data.EventGuid = GUID_DEVICE_STANDBY_VETOED;
    }

    deviceEvent->Data.EventCategory = VetoEvent;

    status = PiInsertEventInQueue(deviceEvent);

    return status;
}

VOID
PpSetPlugPlayEvent(
    IN CONST GUID *EventGuid,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine allows kernel mode enumerator to inform Plug and Play Manager
    on the events triggered by enumeration, i.e., DeviceArrived and DeviceRemoved.
    The PnP manager can then inform user-mode about the event.

Arguments:

    EventId - Indicates what event is triggered by enumeration.


Return Value:

    None.

--*/

{
    ULONG       dataSize, totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    ASSERT(EventGuid != NULL);
    ASSERT(DeviceObject != NULL);

#if DBG
    {
        CHAR    eventGuidString[80];

        LookupGuid(EventGuid, eventGuidString, sizeof(eventGuidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PpSetPlugPlayEvent: Entered\n    EventGuid = %s\n",
                   eventGuidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceObject = 0x%p\n",
                   DeviceObject));
    }
#endif

    if (PpPnpShuttingDown) {

        return;
    }

    //
    // Given the pdo, retrieve the devnode (the device instance string is
    // attached to the devnode in the InstancePath field).
    //

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    if (deviceNode == NULL) {
        return;
    }

    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (the length doesn't count the
    // terminating null but we're already counting the first index into the
    // DeviceId field. also include a final terminating null, in case this is
    // a TargetDevice event, where DeviceIds is a multi-sz list).
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) + deviceNode->InstancePath.Length + sizeof(WCHAR);
    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        return;
    }

    RtlZeroMemory((PVOID)deviceEvent, totalSize);
    RtlCopyMemory(&deviceEvent->Data.EventGuid, EventGuid, sizeof(GUID));
    deviceEvent->Data.TotalSize = dataSize;

    if (PiCompareGuid(EventGuid, &GUID_DEVICE_ENUMERATED)) {
        //
        // GUID_DEVICE_ENUMERATED events are device installation requests for
        // user-mode, and are sent using the DeviceInstallEvent event type.
        //
        deviceEvent->Data.EventCategory = DeviceInstallEvent;
        RtlCopyMemory(&deviceEvent->Data.u.InstallDevice.DeviceId,
                      deviceNode->InstancePath.Buffer,
                      deviceNode->InstancePath.Length);
        deviceEvent->Data.u.InstallDevice.DeviceId[deviceNode->InstancePath.Length/sizeof(WCHAR)] = 0x0;

    } else {

        //
        // All other target events are sent using the TargetDeviceChangeEvent
        // event type, and are distinguished by the EventGuid.  Note that
        // DeviceIds is a multi-sz list.
        //
        deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
        RtlCopyMemory(&deviceEvent->Data.u.TargetDevice.DeviceIds,
                      deviceNode->InstancePath.Buffer,
                      deviceNode->InstancePath.Length);
        deviceEvent->Data.u.TargetDevice.DeviceIds[deviceNode->InstancePath.Length/sizeof(WCHAR)] = 0x0;
        deviceEvent->Data.u.TargetDevice.DeviceIds[deviceNode->InstancePath.Length/sizeof(WCHAR)+1] = 0x0;
    }

    //
    // Don't hold a reference count against the DO for these events. This can
    // lead to really annoying Critical Device Database vs. Installation vs.
    // I/O driver refcount races.
    //
    if (PiCompareGuid(EventGuid, &GUID_DEVICE_ENUMERATED) ||
        PiCompareGuid(EventGuid, &GUID_DEVICE_ARRIVAL)) {

        DeviceObject = NULL;

    } else {

        //
        // Reference the device object so it can't go away until after we're
        // done with notification.
        //
        ASSERT(DeviceObject);
        ObReferenceObject(DeviceObject);
    }

    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    PiInsertEventInQueue(deviceEvent);

    return;

} // PpSetPlugPlayEvent

NTSTATUS
PpSynchronizeDeviceEventQueue(
    VOID
    )
{
    NTSTATUS                status;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    KEVENT                  event;
    ULONG                   result;

    PAGED_CODE();

    //
    // Note this is the only queuing function which is valid when PpShuttingDown
    // is TRUE.
    //

    deviceEvent = ExAllocatePoolWithTag( PagedPool,
                                         sizeof(PNP_DEVICE_EVENT_ENTRY),
                                         PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        return STATUS_NO_MEMORY;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    RtlZeroMemory((PVOID)deviceEvent, sizeof(PNP_DEVICE_EVENT_ENTRY));

    deviceEvent->CallerEvent = &event;
    deviceEvent->Data.EventGuid = GUID_DEVICE_NOOP;
    deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
    deviceEvent->Data.Result = &result;
    deviceEvent->Data.TotalSize = sizeof(PLUGPLAY_EVENT_BLOCK);

    status = PiInsertEventInQueue(deviceEvent);

    if (NT_SUCCESS(status)) {
        status = KeWaitForSingleObject( &event,
                                        Executive,
                                        KernelMode,
                                        FALSE,       // not alertable
                                        0);          // infinite
    }

    return status;
}


VOID
PiWalkDeviceList(
    IN PVOID Context
    )

/*++

Routine Description:

    If the master device list contains any device events, empty the list now.
    This is a worker item thread routine (queued by PiPostNotify). We walk the
    list - this will cause the oldest device event on the list to be sent to
    all registered recipients and then the device event will be removed (if at
    least one recipient received it).

    Order Rules:
        Interface Devices - kernel mode first, user-mode second
        Hardware profile changes - user-mode first, kernel-mode second
        Target device changes (query remove, remove) : user-mode first, send
        (cancel remove)        : kernel-mode first, post
        (custom)               : kernel-mode first, post

Arguments:

    NONE.

Return Value:

    NONE.

--*/

{
    NTSTATUS  status;
    PPNP_DEVICE_EVENT_ENTRY  deviceEvent;
    PLIST_ENTRY current;
    UNICODE_STRING tempString;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiWalkDeviceList: Worker thread entered\n"));
    PpDeviceEventThread = PsGetCurrentThread();

    //
    // Empty the device event list, remove entries from the head of the list
    // (deliver oldest entries first).
    //
    // As this function always executes in a system process workitem, we
    // don't have to grab a critical region lock.
    //

    status = KeWaitForSingleObject(&PpDeviceEventList->EventQueueMutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,       // not alertable
                                   0);          // infinite

    if (!NT_SUCCESS(status)) {
        KeAcquireGuardedMutex(&PiNotificationInProgressLock);
        KeSetEvent(&PiEventQueueEmpty, 0, FALSE);
        PiNotificationInProgress = FALSE;
        KeReleaseGuardedMutex(&PiNotificationInProgressLock);
        PpDeviceEventThread = NULL;
        return;
    }

    for ( ; ; ) {

        KeAcquireGuardedMutex(&PpDeviceEventList->Lock);

        if (!IsListEmpty(&PpDeviceEventList->List)) {

            current = RemoveHeadList(&PpDeviceEventList->List);
            KeReleaseGuardedMutex(&PpDeviceEventList->Lock);

            deviceEvent = CONTAINING_RECORD(current,                // address
                                            PNP_DEVICE_EVENT_ENTRY, // type
                                            ListEntry);             // field

#if DBG
            {
                CHAR    guidString[256];

                LookupGuid(&deviceEvent->Data.EventGuid, guidString, sizeof(guidString));

                IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                           "PiWalkDeviceList: Processing queued event - EventGuid = %s\n",
                           guidString));
            }
#endif

            status = STATUS_SUCCESS;
            if (deviceEvent->Data.DeviceObject != NULL) {

                deviceNode = PP_DO_TO_DN((PDEVICE_OBJECT)deviceEvent->Data.DeviceObject);
                if (deviceNode == NULL || PipIsDevNodeDeleted(deviceNode)) {

                    status = STATUS_NO_SUCH_DEVICE;
                }
            }

            if (NT_SUCCESS(status)) {

                switch (deviceEvent->Data.EventCategory) {

                    case DeviceClassChangeEvent: {

                        //
                        // Notify kernel-mode (synchronous).
                        //

                        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                                   "PiWalkDeviceList: DeviceClassChangeEvent - notifying kernel-mode\n"));

                        RtlInitUnicodeString(&tempString, deviceEvent->Data.u.DeviceClass.SymbolicLinkName);
                        IopNotifyDeviceClassChange(&deviceEvent->Data.EventGuid,
                                                   &deviceEvent->Data.u.DeviceClass.ClassGuid,
                                                   &tempString);

                        //
                        // Notify user-mode (synchronous).
                        //

                        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                                   "PiWalkDeviceList: DeviceClassChangeEvent - user kernel-mode\n"));

                        PiNotifyUserMode(deviceEvent);

                        status = STATUS_SUCCESS;
                        break;
                    }


                    case CustomDeviceEvent: {

                        status = PiProcessCustomDeviceEvent(&deviceEvent);
                        break;
                    }

                    case TargetDeviceChangeEvent: {

                        status = PiProcessTargetDeviceEvent(&deviceEvent);
                        break;
                    }

                    case DeviceInstallEvent: {

                        //
                        // Notify user-mode (synchronous).
                        //

                        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                                   "PiWalkDeviceList: DeviceInstallEvent - notifying user-mode\n"));

                        PiNotifyUserMode(deviceEvent);

                        status = STATUS_SUCCESS;
                        break;
                    }

                    case HardwareProfileChangeEvent: {

                        //
                        // Notify user-mode (synchronous).
                        //
                        status = PiNotifyUserMode(deviceEvent);

                        if (NT_SUCCESS(status)) {

                            //
                            // Notify K-Mode
                            //
                            IopNotifyHwProfileChange(&deviceEvent->Data.EventGuid,
                                                     deviceEvent->VetoType,
                                                     deviceEvent->VetoName);
                        }
                        break;
                    }
                    case PowerEvent: {

                        //
                        // Notify user-mode (synchronous).
                        //
                        status = PiNotifyUserMode(deviceEvent);
                        break;
                    }

                    case VetoEvent: {

                        //
                        // Forward onto user-mode.
                        //
                        status = PiNotifyUserMode(deviceEvent);
                        break;
                    }

                    case BlockedDriverEvent: {

                        //
                        // Forward onto user-mode.
                        //
                        status = PiNotifyUserMode(deviceEvent);
                        break;
                    }

                    case InvalidIDEvent: {

                        //
                        // Forward onto user-mode.
                        //
                        status = PiNotifyUserMode(deviceEvent);
                        break;
                    }

                    default: {

                        //
                        // These should never be queued to kernel mode. They are
                        // notifications for user mode, and should only be seen
                        // through the PiNotifyUserModeXxx functions.
                        //
                        ASSERT(0);
                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                }
            }

            if (status != STATUS_PENDING) {

                PpCompleteDeviceEvent(deviceEvent, status);
            }

            //
            // Commit pending registrations after processing each event.
            //
            IopProcessDeferredRegistrations();

        } else {
            KeAcquireGuardedMutex(&PiNotificationInProgressLock);
            KeSetEvent(&PiEventQueueEmpty, 0, FALSE);
            PiNotificationInProgress = FALSE;

            //
            // Commit pending registrations after processing all queued events.
            //
            IopProcessDeferredRegistrations();

            KeReleaseGuardedMutex(&PiNotificationInProgressLock);
            KeReleaseGuardedMutex(&PpDeviceEventList->Lock);
            break;
        }
    }

    if (Context != NULL) {

        ExFreePool(Context);
    }

    PpDeviceEventThread = NULL;
    KeReleaseMutex(&PpDeviceEventList->EventQueueMutex, FALSE);

    return;
} // PiWalkDeviceList


VOID
PpCompleteDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY  DeviceEvent,
    IN     NTSTATUS                 FinalStatus
    )

/*++

Routine Description:


Arguments:

    DeviceEvent     - Event to complete.
    FinalStatus     - Final status for this event.

Return Value:

    NONE.

--*/

{
#if DBG
    CHAR guidString[256];
#endif

    PAGED_CODE();

#if DBG
    LookupGuid(&DeviceEvent->Data.EventGuid, guidString, sizeof(guidString));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PpCompleteDeviceEvent: Completing queued event - EventGuid = %s with %08lx\n",
               guidString,
               FinalStatus));
#endif

    //
    // If synchronous, signal the user-supplied event.
    //

    if (DeviceEvent->CallerEvent) {
        *DeviceEvent->Data.Result = FinalStatus;
        KeSetEvent(DeviceEvent->CallerEvent, 0, FALSE);
    }

    if (DeviceEvent->Callback) {
        DeviceEvent->Callback(DeviceEvent->Context);
    }

    //
    // Release the reference we took for this device object during
    // the PpSetCustomTargetEvent call.
    //
    if (DeviceEvent->Data.DeviceObject != NULL) {
        ObDereferenceObject(DeviceEvent->Data.DeviceObject);
    }

    //
    // Assume device event was delivered successfully, get rid of it.
    //

    ExFreePool(DeviceEvent);
    return;
} // PpCompleteDeviceEvent


NTSTATUS
PiNotifyUserMode(
    PPNP_DEVICE_EVENT_ENTRY DeviceEvent
    )

/*++

Routine Description:

    This routine dispatches the device event to user-mode for processing.

Arguments:

    DeviceEvent - Data describing what change and how.

Return Value:

    Retuns an NTSTATUS value.

--*/

{
    NTSTATUS status = STATUS_SUCCESS, status1 = STATUS_SUCCESS;

    PAGED_CODE();

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiNotifyUserMode: Entered\n"));

    //
    // First make sure user-mode is up and running before attempting to deliver
    // an event. If not running yet, skip user-mode for this event.
    //

    if (PiUserModeRunning) {


        //
        // User-mode notification is a single-shot model, once user-mode is
        // running, I need to wait until user-mode is ready to take the next
        // event (i.e, wait until we're sitting in another NtGetPlugPlayEvent
        // call).
        //

        status1 = KeWaitForSingleObject(&PpUserBlock->Registered,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        ASSERT (PpUserBlock->Deferred == FALSE);


        //
        // Change the status after the wait.
        //
        PpUserBlock->Status = STATUS_SUCCESS;

        if (NT_SUCCESS(status1)) {

            IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                       "PiNotifyUserMode: User-mode ready\n"));

            //
            // Make sure we can handle it in the pool buffer and copy it out
            //
            if (PpUserBlock->PoolSize <  DeviceEvent->Data.TotalSize) {
                //
                //Allocate a new block (well, conceptually grow the block)
                // only when it's not big enough, so that we know we've always got
                // room for normal events, and in the very low memory case, we can
                // fail custom events, but keep the system running
                //
                PVOID pHold;


                pHold = ExAllocatePoolWithTag(NonPagedPool,
                                              DeviceEvent->Data.TotalSize,
                                              PNP_POOL_EVENT_BUFFER);

                if (!pHold) {
                    IopDbgPrint((IOP_IOEVENT_ERROR_LEVEL,
                               "PiNotifyUserMode: Out of NonPagedPool!!\n"));

                    PpUserBlock->Status = STATUS_INSUFFICIENT_RESOURCES;
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
                PpUserBlock->PoolSize = DeviceEvent->Data.TotalSize;

                ExFreePool (PpUserBlock->PoolBuffer );
                PpUserBlock->PoolBuffer = pHold;

            }

            PpUserBlock->PoolUsed = DeviceEvent->Data.TotalSize;
            RtlCopyMemory(PpUserBlock->PoolBuffer,
                          &DeviceEvent->Data,
                          PpUserBlock->PoolUsed);

        }

        //
        // Veto information is only propogated where needed, ie
        // QUERY_REMOVE's, Profile change requests and PowerEvents.
        //
        if (PiCompareGuid(&DeviceEvent->Data.EventGuid,
                          &GUID_TARGET_DEVICE_QUERY_REMOVE) ||
            PiCompareGuid(&DeviceEvent->Data.EventGuid,
                          &GUID_HWPROFILE_QUERY_CHANGE) ||
            PiCompareGuid(&DeviceEvent->Data.EventGuid,
                          &GUID_DEVICE_KERNEL_INITIATED_EJECT) ||
            (DeviceEvent->Data.EventCategory == PowerEvent)) {

            PpUserBlock->VetoType = DeviceEvent->VetoType;
            PpUserBlock->VetoName = DeviceEvent->VetoName;
        } else {
            PpUserBlock->VetoType = NULL;
            PpUserBlock->VetoName = NULL;
        }

        //
        // Set the system event that causes NtGetPlugPlayEvent to return to caller.
        //

        KeSetEvent(&PpUserBlock->NotifyUserEvent, 0, FALSE);

        //
        // Wait until we get an answer back from user-mode.
        //
        // ADRIAO N.B. 2002/03/24 - This checks for Kernel mode alerts???
        //                          Bizarre!
        //

        status1 = KeWaitForSingleObject(&PpUserBlock->UserResultEvent,
                                        Executive,
                                        KernelMode,
                                        TRUE,
                                        NULL);

        //
        // Check the result from this user-mode notification.
        //

        if (status1 == STATUS_ALERTED || status1 == STATUS_SUCCESS) {
            if (!PpUserBlock->Result) {

                //
                // For query-remove case, any errors are treated as a
                // failure during notification (since it may result in our
                // inability to let a registered caller vote in the query-remove)
                // and the PpUserBlock->Result is set accordingly.
                //

                //
                // Note! User mode ONLY returns a 0 or !0 response.
                // if 1 then it succeeded.
                //

                status = STATUS_UNSUCCESSFUL;
            }
        }

        PpUserBlock->VetoType = NULL;
        PpUserBlock->VetoName = NULL;
    }

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiNotifyUserMode: User-mode returned, status = 0x%08X, status1 = 0x%08X, Result = 0x%08X\n",
               status,
               status1,
               PpUserBlock->Result));

    return status;

} // PiNotifyUserMode



VOID
PiUserResponse(
    IN ULONG            Response,
    IN PNP_VETO_TYPE    VetoType,
    IN LPWSTR           VetoName,
    IN ULONG            VetoNameLength
    )

/*++

Routine Description:

    This routine is called when user-mode pnp manager is signalling that it's
    done processing an event; the result of the event processing is passed in
    the Response parameter.

Arguments:

    Response - Result of event processing in user-mode.

Return Value:

    None.

--*/

{
    UNICODE_STRING vetoString;

    PAGED_CODE();

    PpUserBlock->Result = Response;

    if (PpUserBlock->VetoType != NULL) {
        *PpUserBlock->VetoType = VetoType;
    }

    if (PpUserBlock->VetoName != NULL)  {
        ASSERT(VetoNameLength == (USHORT)VetoNameLength);

        vetoString.MaximumLength = (USHORT)VetoNameLength;
        vetoString.Length = (USHORT)VetoNameLength;
        vetoString.Buffer = VetoName;
        RtlCopyUnicodeString(PpUserBlock->VetoName, &vetoString);
    }

    KeSetEvent(&PpUserBlock->UserResultEvent, 0, FALSE);

} // PiUserResponse


NTSTATUS
PiNotifyUserModeDeviceRemoval(
    IN  PPNP_DEVICE_EVENT_ENTRY TemplateDeviceEvent,
    IN  CONST GUID              *EventGuid,
    OUT PPNP_VETO_TYPE          VetoType                OPTIONAL,
    OUT PUNICODE_STRING         VetoName                OPTIONAL
    )
/*++

Routine Description:

    This routine tells user mode to perform a specific device removal
    operation.

Arguments:

    TemplateDeviceEvent - Device event containing information about the
                          intended event (includes a list of devices.) The
                          event is temporarily used by this function, and is
                          restored before this function returns.

    EventGuid - Points to the event user mode should process:
        GUID_TARGET_DEVICE_QUERY_REMOVE
        GUID_TARGET_DEVICE_REMOVE_CANCELLED
        GUID_DEVICE_REMOVE_PENDING
        GUID_TARGET_DEVICE_REMOVE_COMPLETE
        GUID_DEVICE_SURPRISE_REMOVAL

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;
    GUID oldGuid;
    PPNP_VETO_TYPE oldVetoType;
    PUNICODE_STRING oldVetoName;
#if DBG
    CHAR guidString[256];
#endif

    PAGED_CODE();

#if DBG
    LookupGuid(EventGuid, guidString, sizeof(guidString));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiNotifyUserModeDeviceRemoval: %s - notifying user-mode\n",
               guidString));
#endif

    //
    // Save the old guid so we can use the template without making a copy. We
    // preserve it so that the removal veto UI can use the original event GUID
    // to let the UI differentiate disables from ejects, etc.
    //
    RtlCopyMemory(&oldGuid, &TemplateDeviceEvent->Data.EventGuid, sizeof(GUID));

    //
    // Do the same with the vetoname and vetobuffer.
    //
    oldVetoType = TemplateDeviceEvent->VetoType;
    oldVetoName = TemplateDeviceEvent->VetoName;

    //
    // Copy in the new data.
    //
    RtlCopyMemory(&TemplateDeviceEvent->Data.EventGuid, EventGuid, sizeof(GUID));
    TemplateDeviceEvent->VetoType = VetoType;
    TemplateDeviceEvent->VetoName = VetoName;

    //
    // Send it.
    //
    status = PiNotifyUserMode(TemplateDeviceEvent);

    //
    // Restore the old info.
    //
    RtlCopyMemory(&TemplateDeviceEvent->Data.EventGuid, &oldGuid, sizeof(GUID));
    TemplateDeviceEvent->VetoType = oldVetoType;
    TemplateDeviceEvent->VetoName = oldVetoName;

    return status;
}

NTSTATUS
PiNotifyUserModeKernelInitiatedEject(
    IN  PDEVICE_OBJECT          DeviceObject,
    OUT PNP_VETO_TYPE          *VetoType,
    OUT PUNICODE_STRING         VetoName
    )

/*++

Routine Description:

    This routine is called to notify user mode a device has a kenel-mode
    initated eject outstanding. UmPnpMgr might decide to veto the event if
    a user with the appropriate permissions hasn't logged on locally.

Arguments:

    DeviceObject - Indicates the device object is to be ejected.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //

    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode);

    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (the length doesn't count the
    // terminating null but we're already counting the first index into the
    // DeviceId field so it works out. Add one more for double-null term.
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK);

    dataSize += deviceNode->InstancePath.Length + sizeof(WCHAR);

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool, totalSize, PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        ObDereferenceObject(DeviceObject);
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory((PVOID)deviceEvent, totalSize);

    deviceEvent->CallerEvent = NULL;
    deviceEvent->Argument = 0;
    deviceEvent->VetoType = VetoType;
    deviceEvent->VetoName = VetoName;
    deviceEvent->Data.EventGuid = GUID_DEVICE_KERNEL_INITIATED_EJECT;
    deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
    deviceEvent->Data.Result = 0;
    deviceEvent->Data.Flags = 0;

    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    if (deviceNode->InstancePath.Length != 0) {

        RtlCopyMemory((PVOID)deviceEvent->Data.u.TargetDevice.DeviceIds,
                    (PVOID)deviceNode->InstancePath.Buffer,
                    deviceNode->InstancePath.Length);
    }

    i = deviceNode->InstancePath.Length/sizeof(WCHAR);

    deviceEvent->Data.u.TargetDevice.DeviceIds[i] = L'\0';

    status = PiNotifyUserMode(deviceEvent);

    ExFreePool(deviceEvent);

    ObDereferenceObject(DeviceObject);

    return status;

} // PiNotifyUserModeKernelInitiatedEject

NTSTATUS
PiNotifyUserModeRemoveVetoed(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PNP_VETO_TYPE            VetoType,
    IN PUNICODE_STRING          VetoName        OPTIONAL
    )
/*++

--*/
{
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    PDEVICE_NODE deviceNode;
    PWCHAR vetoData;
    NTSTATUS status;

    //
    // This device should be locked during this operation, but all good designs
    // includes healthy doses of paranoia.
    //
    ObReferenceObject(DeviceObject);

    //
    // Given the pdo, retrieve the devnode (the device instance string is
    // attached to the devnode in the InstancePath field).
    //
    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INVALID_PARAMETER_1;
    }

    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (because of the first index into
    // the DeviceIdVetoNameBuffer, this is double null terminated).
    //
    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) +
               deviceNode->InstancePath.Length +
               (VetoName ? VetoName->Length : 0) +
               sizeof(WCHAR)*2;

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);

    if (deviceEvent == NULL) {

        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)deviceEvent, totalSize);
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;
    deviceEvent->Data.u.VetoNotification.VetoType = VetoType;

    //
    // You can think of this as a MultiSz string where the first entry is the
    // DeviceId for the device being removed, and the next Id's all corrospond
    // to the vetoers.
    //
    RtlCopyMemory(
        deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer,
        deviceNode->InstancePath.Buffer,
        deviceNode->InstancePath.Length
        );

    i = deviceNode->InstancePath.Length;
    deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)] = UNICODE_NULL;

    if (VetoName) {

        vetoData = (&deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)])+1;

        RtlCopyMemory(vetoData, VetoName->Buffer, VetoName->Length);
        vetoData[VetoName->Length/sizeof(WCHAR)] = UNICODE_NULL;
    }

    //
    // No need to NULL terminate the entry after the last one as we prezero'd
    // the buffer. Now set the appropriate GUID so the UI looks right.
    //
    if (PiCompareGuid(&VetoedDeviceEvent->Data.EventGuid, &GUID_DEVICE_EJECT)) {

        deviceEvent->Data.EventGuid = GUID_DEVICE_EJECT_VETOED;

    } else {

        ASSERT(PiCompareGuid(&VetoedDeviceEvent->Data.EventGuid, &GUID_DEVICE_QUERY_AND_REMOVE));
        deviceEvent->Data.EventGuid = GUID_DEVICE_REMOVAL_VETOED;
    }

    deviceEvent->Data.EventCategory = VetoEvent;

    status = PiNotifyUserMode(deviceEvent);

    ExFreePool(deviceEvent);

    ObDereferenceObject(DeviceObject);
    return status;
}

NTSTATUS
PiNotifyUserModeRemoveVetoedByList(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PNP_VETO_TYPE            VetoType,
    IN PWSTR                    MultiSzVetoList
    )
/*++

--*/
{
    ULONG dataSize, totalSize, i, vetoListLength;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    PDEVICE_NODE deviceNode;
    PWCHAR vetoData;
    NTSTATUS status;

    //
    // This device should be locked during this operation, but all good designs
    // includes healthy doses of paranoia.
    //
    ObReferenceObject(DeviceObject);

    //
    // Given the pdo, retrieve the devnode (the device instance string is
    // attached to the devnode in the InstancePath field).
    //

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INVALID_PARAMETER_1;
    }

    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (because of the first index into
    // the DeviceIdVetoNameBuffer, this is double null terminated).
    //

    for(vetoData = MultiSzVetoList; *vetoData; vetoData += vetoListLength) {

        vetoListLength = (ULONG)(wcslen(vetoData) + 1);
    }

    vetoListLength = ((ULONG)(vetoData - MultiSzVetoList))*sizeof(WCHAR);

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK) +
               deviceNode->InstancePath.Length +
               vetoListLength +
               sizeof(WCHAR);

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool,
                                        totalSize,
                                        PNP_DEVICE_EVENT_ENTRY_TAG);

    if (deviceEvent == NULL) {

        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)deviceEvent, totalSize);
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;
    deviceEvent->Data.u.VetoNotification.VetoType = VetoType;

    //
    // You can think of this as a MultiSz string where the first entry is the
    // DeviceId for the device being removed, and the next Id's all corrospond
    // to the vetoers.
    //
    RtlCopyMemory(
        deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer,
        deviceNode->InstancePath.Buffer,
        deviceNode->InstancePath.Length
        );

    i = deviceNode->InstancePath.Length;
    deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)] = UNICODE_NULL;

    vetoData = (&deviceEvent->Data.u.VetoNotification.DeviceIdVetoNameBuffer[i/sizeof(WCHAR)])+1;

    RtlCopyMemory(vetoData, MultiSzVetoList, vetoListLength);
    vetoData[vetoListLength/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // No need to NULL terminate the entry after the last one as we prezero'd
    // the buffer. Now set the appropriate GUID so the UI looks right.
    //
    if (PiCompareGuid(&VetoedDeviceEvent->Data.EventGuid, &GUID_DEVICE_EJECT)) {

        deviceEvent->Data.EventGuid = GUID_DEVICE_EJECT_VETOED;

    } else {

        ASSERT(PiCompareGuid(&VetoedDeviceEvent->Data.EventGuid, &GUID_DEVICE_QUERY_AND_REMOVE));
        deviceEvent->Data.EventGuid = GUID_DEVICE_REMOVAL_VETOED;
    }

    deviceEvent->Data.EventCategory = VetoEvent;

    status = PiNotifyUserMode(deviceEvent);

    ExFreePool(deviceEvent);

    ObDereferenceObject(DeviceObject);
    return status;
}

NTSTATUS
PpNotifyUserModeRemovalSafe(
    IN  PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called to notify user mode a device can be removed. This
    is similar to PpSetDeviceRemovalSafe except that we are already in a
    kernel mode PnP device event we must complete, from which this function
    will piggyback a notification up to just user mode.

Arguments:

    DeviceObject - Indicates the device object is ready for removal.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;
    ULONG dataSize, totalSize, i;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);

    //
    // Reference the device object so it can't go away until after we're
    // done with notification.
    //

    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode);


    //
    // Calculate the size of the PLUGPLAY_EVENT_BLOCK, this is the size that
    // we record in the TotalSize field later (the length doesn't count the
    // terminating null but we're already counting the first index into the
    // DeviceId field so it works out. Add one more for double-null term.
    //

    dataSize = sizeof(PLUGPLAY_EVENT_BLOCK);

    dataSize += deviceNode->InstancePath.Length + sizeof(WCHAR);

    totalSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) + dataSize;

    deviceEvent = ExAllocatePoolWithTag(PagedPool, totalSize, PNP_DEVICE_EVENT_ENTRY_TAG);
    if (deviceEvent == NULL) {
        ObDereferenceObject(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory((PVOID)deviceEvent, totalSize);

    deviceEvent->CallerEvent = NULL;
    deviceEvent->Argument = 0;
    deviceEvent->VetoType = NULL;
    deviceEvent->VetoName = NULL;
    deviceEvent->Data.EventGuid = GUID_DEVICE_SAFE_REMOVAL;
    deviceEvent->Data.EventCategory = TargetDeviceChangeEvent;
    deviceEvent->Data.Result = 0;
    deviceEvent->Data.Flags = 0;

    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->Data.DeviceObject = (PVOID)DeviceObject;

    if (deviceNode->InstancePath.Length != 0) {

        RtlCopyMemory((PVOID)deviceEvent->Data.u.TargetDevice.DeviceIds,
                    (PVOID)deviceNode->InstancePath.Buffer,
                    deviceNode->InstancePath.Length);
    }

    i = deviceNode->InstancePath.Length/sizeof(WCHAR);

    deviceEvent->Data.u.TargetDevice.DeviceIds[i] = L'\0';

    status = PiNotifyUserMode(deviceEvent);

    ExFreePool(deviceEvent);

    ObDereferenceObject(DeviceObject);

    return status;

} // PpNotifyUserModeRemovalSafe


NTSTATUS
PiProcessQueryRemoveAndEject(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    )

/*++

Routine Description:

    This routine processes the various flavours of remove: Eject, SurpriseRemove,
    Remove, and QueryRemove.

    Eject
        Retrieve bus, removal, and eject relations.
        Do queries on all relations
        Send IRP_MN_REMOVE_DEVICE to all the relations.
        Queue the pending eject

        Once the eject happens
            Reenumerate all the indirect relation's parents

    SurpriseRemove
        Retrieve bus, removal, and eject relations.
        Send IRP_MN_SURPRISE_REMOVAL to all the direct relations.
        Notify everyone that the device is gone.
        Reenumerate the parents of all the indirect relations.
        Remove the indirect relations from the relations list.
        Queue the pending surprise removal.

        Once the last handle is closed.

            Send IRP_MN_REMOVE_DEVICE to all the direct relations.

    RemoveFailedDevice
        Retrieve bus and removal relations.
        Notify everyone that the device is going.
        Reenumerate the parents of all the indirect relations.
        Remove the indirect relations from the relations list.
        Queue as a pending surprise removal.

        Once the last handle is closed.

            Send IRP_MN_REMOVE_DEVICE to all the direct relations.

    RemoveUnstartedFailedDevice
        Retrieve bus relations.
        Notify everyone that the device is going.
        Send IRP_MN_REMOVE_DEVICE to all the direct relations.

    Remove
        Use the relations from the last QueryRemove or retrieve new bus, removal,
        and eject relations if the device wasn't already QueryRemoved.
        Send IRP_MN_REMOVE_DEVICE to all the relations.

Arguments:

    Response - Result of event processing in user-mode.

Return Value:

    NTSTATUS code.

--*/

{
    PPNP_DEVICE_EVENT_ENTRY         deviceEvent;
    PPNP_DEVICE_EVENT_ENTRY         surpriseRemovalEvent;
    PLUGPLAY_DEVICE_DELETE_TYPE     deleteType;
    PPENDING_RELATIONS_LIST_ENTRY   pendingRelations;
    PNP_VETO_TYPE                   vetoType;
    PDEVICE_OBJECT                  deviceObject, relatedDeviceObject;
    PDEVICE_OBJECT                 *pdoList;
    PDEVICE_NODE                    deviceNode, relatedDeviceNode;
    PRELATION_LIST                  relationsList;
    ULONG                           relationCount;
    NTSTATUS                        status;
    ULONG                           marker;
    BOOLEAN                         directDescendant;
    PDEVICE_OBJECT                  vetoingDevice = NULL;
    PDRIVER_OBJECT                  vetoingDriver = NULL;
    LONG                            index;
    BOOLEAN                         possibleProfileChangeInProgress = FALSE;
    BOOLEAN                         subsumingProfileChange = FALSE;
    BOOLEAN                         hotEjectSupported;
    BOOLEAN                         warmEjectSupported;
    BOOLEAN                         excludeIndirectRelations;
    UNICODE_STRING                  singleVetoListItem;
    PWSTR                           vetoList;
    UNICODE_STRING                  internalVetoString;
    PWSTR                           internalVetoBuffer;
    PDOCK_INTERFACE                 dockInterface = NULL;

    PAGED_CODE();

    deviceEvent = *DeviceEvent;
    deviceObject = (PDEVICE_OBJECT)deviceEvent->Data.DeviceObject;
    deviceNode = deviceObject->DeviceObjectExtension->DeviceNode;
    surpriseRemovalEvent = NULL;

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    if (PiCompareGuid(&deviceEvent->Data.EventGuid, &GUID_DEVICE_EJECT)) {

        deleteType = EjectDevice;

    } else if (deviceEvent->Data.Flags & TDF_KERNEL_INITIATED) {

        if (!(deviceNode->Flags & DNF_ENUMERATED)) {

            ASSERT(deviceNode->State == DeviceNodeAwaitingQueuedDeletion);

            if ((deviceNode->PreviousState == DeviceNodeStarted) ||
                (deviceNode->PreviousState == DeviceNodeStopped) ||
                (deviceNode->PreviousState == DeviceNodeStartPostWork) ||
                (deviceNode->PreviousState == DeviceNodeRestartCompletion)) {

                deleteType = SurpriseRemoveDevice;

            } else {
                deleteType = RemoveDevice;
            }
        } else {

            ASSERT(deviceNode->State == DeviceNodeAwaitingQueuedRemoval);

            if ((deviceNode->PreviousState == DeviceNodeStarted) ||
                (deviceNode->PreviousState == DeviceNodeStopped) ||
                (deviceNode->PreviousState == DeviceNodeStartPostWork) ||
                (deviceNode->PreviousState == DeviceNodeRestartCompletion)) {

                deleteType = RemoveFailedDevice;
            } else {
                deleteType = RemoveUnstartedFailedDevice;
            }
        }

    } else {

        deleteType = QueryRemoveDevice;
    }

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessQueryRemoveAndEject: Remove type %x\n", deleteType));

    if (deleteType == QueryRemoveDevice || deleteType == EjectDevice) {

        if (deviceNode->Flags & DNF_LEGACY_DRIVER) {

            IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                       "PiProcessQueryRemoveAndEject: Vetoed by legacy driver\n"));
            PiFinalizeVetoedRemove(
                deviceEvent,
                PNP_VetoLegacyDevice,
                &deviceNode->InstancePath
                );

            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }
    }

    if (deleteType == QueryRemoveDevice && deviceEvent->Argument == CM_PROB_DISABLED) {

        //
        // if we're trying to remove the device to disable the device
        //
        if (deviceNode->DisableableDepends > 0) {

            IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                       "PiProcessQueryRemoveAndEject: Device is non-disableable\n"));
            //
            // we should have caught this before (in usermode PnP)
            // but a rare scenario can exist where the device becomes non-disableable
            // There is still a potential gap, if the device hasn't got around
            // to marking itself as non-disableable yet
            //
            PiFinalizeVetoedRemove(
                deviceEvent,
                PNP_VetoNonDisableable,
                &deviceNode->InstancePath
                );

            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }
    }

    //
    // Allocate room for a possible veto buffer.
    //
    internalVetoBuffer = (PWSTR) PiAllocateCriticalMemory(
        deleteType,
        PagedPool,
        MAX_VETO_NAME_LENGTH * sizeof(WCHAR),
        'rcpP'
        );

    if (internalVetoBuffer == NULL) {

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiProcessQueryRemoveAndEject: Vetoed due to failure to allocate vetobuffer\n"));
        PiFinalizeVetoedRemove(
            deviceEvent,
            PNP_VetoTypeUnknown,
            NULL
            );

        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        return STATUS_PLUGPLAY_QUERY_VETOED;
    }

    //
    // Preinit the veto information
    //
    vetoType = PNP_VetoTypeUnknown;
    internalVetoString.MaximumLength = MAX_VETO_NAME_LENGTH;
    internalVetoString.Length = 0;
    internalVetoString.Buffer = internalVetoBuffer;

    if (deleteType == EjectDevice) {

        if (deviceNode->Flags & DNF_LOCKED_FOR_EJECT) {

            IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                       "PiProcessQueryRemoveAndEject: Device already being ejected\n"));
            //
            // Either this node or one of its ancestors is already being ejected.
            //
            ExFreePool(internalVetoBuffer);
            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_SUCCESS;
        }

        if (deviceEvent->Data.Flags & TDF_KERNEL_INITIATED) {

            //
            // Check permissions.
            //
            status = PiNotifyUserModeKernelInitiatedEject(
                deviceObject,
                &vetoType,
                &internalVetoString
                );

            if (!NT_SUCCESS(status)) {

                IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                           "PiProcessQueryRemoveAndEject: Kernel initiated eject vetoed by user mode\n"));
                PiFinalizeVetoedRemove(
                    deviceEvent,
                    vetoType,
                    &internalVetoString
                    );

                ExFreePool(internalVetoBuffer);
                PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
                return STATUS_PLUGPLAY_QUERY_VETOED;
            }
        }

        if ((deviceNode->DockInfo.DockStatus == DOCK_DEPARTING) ||
            (deviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED)) {

            IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                       "PiProcessQueryRemoveAndEject: Dock already being ejected\n"));
            //
            // We already have an eject queued against this device. Don't allow
            // another eject to break into the middle of a queue/cancel warm
            // eject sequence.
            //
            ExFreePool(internalVetoBuffer);
            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_SUCCESS;
        }

        //
        // What types of ejection can we do? (warm/hot)
        //
        if (!IopDeviceNodeFlagsToCapabilities(deviceNode)->Removable) {

            //
            // This device is neither ejectable, nor even removable.
            //
            IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                       "PiProcessQueryRemoveAndEject: Device not removable\n"));
            PiFinalizeVetoedRemove(
                deviceEvent,
                PNP_VetoIllegalDeviceRequest,
                &deviceNode->InstancePath
                );

            ExFreePool(internalVetoBuffer);
            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }
    }

    if ((deleteType == QueryRemoveDevice) && (!PipAreDriversLoaded(deviceNode))) {

        //
        // The device doesn't have an FDO.
        //
        status = STATUS_SUCCESS;
        if ((deviceNode->State == DeviceNodeInitialized) ||
            (deviceNode->State == DeviceNodeRemoved)) {

            //
            // The rules are:
            // 1) !TDF_NO_RESTART means clear the devnode and get it ready
            //    as long as the problem is user resettable. Ignore the passed
            //    in problem code (probably either CM_PROB_WILL_BE_REMOVED or
            //    CM_PROB_DEVICE_NOT_THERE), as it means nothing.
            // 2) TDF_NO_RESTART means change the problem code over if you can.
            //    If the problem code is not user resettable, the problem code
            //    won't change.
            //

            //
            // In all cases we try to clear the problem.
            //
            if (PipDoesDevNodeHaveProblem(deviceNode)) {

                if (!PipIsProblemReadonly(deviceNode->Problem)) {

                    PipClearDevNodeProblem(deviceNode);
                }
            }

            if (!PipDoesDevNodeHaveProblem(deviceNode)) {

                if (!(deviceEvent->Data.Flags & TDF_NO_RESTART))  {

                    //
                    // This is a reset attempt. Mark the devnode so that it
                    // comes online next enumeration.
                    //
                    IopRestartDeviceNode(deviceNode);

                } else {

                    //
                    // We're changing or setting problem codes. Note that the
                    // device is still in DeviceNodeInitialized or
                    // DeviceNodeRemoved.
                    //
                    PipSetDevNodeProblem(deviceNode, deviceEvent->Argument);
                }

            } else {

                //
                // The problem is fixed, so the devnode state is immutable
                // as far as user mode is concerned. Here we fail the call
                // if we can't bring the devnode back online. We always succeed
                // the call if it was an attempt to change the code, as the
                // user either wants to prepare the device for ejection (done),
                // or wants to disable it (as good as done.)
                //
                if (!(deviceEvent->Data.Flags & TDF_NO_RESTART))  {

                    status = STATUS_INVALID_PARAMETER;
                }
            }
        }

        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        ExFreePool(internalVetoBuffer);
        return status;
    }

    status = IopBuildRemovalRelationList( deviceObject,
                                          deleteType,
                                          &vetoType,
                                          &internalVetoString,
                                          &relationsList);
    if (!NT_SUCCESS(status)) {

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiProcessQueryRemoveAndEject: Failed to build removal relations\n"));
        PiFinalizeVetoedRemove(
            deviceEvent,
            vetoType,
            &internalVetoString
            );

        ExFreePool(internalVetoBuffer);
        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        return STATUS_PLUGPLAY_QUERY_VETOED;
    }

    ASSERT(relationsList != NULL);

    //
    // Resize the event buffer and add these device instance strings to the
    // list to notify.
    //
    relationCount = IopGetRelationsCount( relationsList );
    ASSERT(!IopGetRelationsTaggedCount( relationsList ));

    //
    // PdoList will become a list of devices that must be queried. This is
    // a subset of all the devices that might disappear, all of which appear
    // in the relations list.
    //
    pdoList = (PDEVICE_OBJECT *) PiAllocateCriticalMemory(
        deleteType,
        NonPagedPool,
        relationCount * sizeof(PDEVICE_OBJECT),
        'rcpP'
        );

    if (pdoList != NULL) {

        relationCount = 0;
        marker = 0;
        while (IopEnumerateRelations( relationsList,
                                      &marker,
                                      &relatedDeviceObject,
                                      &directDescendant,
                                      NULL,
                                      TRUE)) {

            //
            // Here is a list of what operations retrieve what relations,
            // who they query, and who/how they notify.
            //
            // Operation                    Relations    Queries   Notifies
            // ---------                    ---------    -------   --------
            // EjectDevice                  Ejection     Everyone  Everyone (Remove)
            // SurpriseRemoveDevice         Ejection     NA        Descendants (SurpriseRemove)
            // RemoveDevice                 Ejection     NA        Descendants (Remove)
            // RemoveFailedDevice           Removal      NA        Descendants (SurpriseRemove)
            // RemoveUnstartedFailedDevice  Removal      NA        Descendants (Remove)
            // QueryRemoveDevice            Removal      Everyone  Everyone (Remove)
            //
            //
            // N.B.
            //     We do not send SurpriseRemove's to removal relations.
            // While doing so might seem to be the correct behavior, many
            // drivers do not handle this well. Simply reenumerating the
            // parents of the removal relations works much better. Similarly
            // ejection relations have their parents reenumerated (which
            // makes sense, as they are speculative in nature anyway).
            //
            //      If we get in a case where a *parent* of a dock gets
            // into the RemoveFailedDevice case (ie, failed restart,
            // responded to QueryDeviceState with Removed, etc), then we
            // will be shortly losing the children when we stop the parent.
            // However, we want to eject the dock child, not just remove it
            // as starting and ejecting are symmetric here. Note that
            // currently the only such parent would be the root ACPI devnode.
            //
            //      Ejection relations of a device (eg dock) that has been
            // surprise removed are not notified that they *may* have been
            // pulled (remember, ejection relations are speculative). We
            // will notify only DirectDescendants and queue an enumeration
            // on every parent of the ejection relations.  If they really
            // disappeared, they will get their notification, albeit a bit
            // later than some of the other devices in the tree.
            //
            if (directDescendant || deleteType == EjectDevice || deleteType == QueryRemoveDevice) {

                relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                //
                // PiProcessQueryRemoveAndEject will be called twice for
                // the dock during an eject. Once with EjectDevice, and
                // after the dock is listed as missing once more with
                // RemoveDevice. We don't want to start a profile change
                // for RemoveDevice as we are already in one, and we would
                // deadlock if we tried. We don't start one for QueryRemove
                // either as the dock isn't *physically* going away.
                //
                ASSERT(relatedDeviceNode->DockInfo.DockStatus != DOCK_ARRIVING);
                if (deleteType != RemoveDevice &&
                    deleteType != QueryRemoveDevice) {

                    if (relatedDeviceNode->DockInfo.DockStatus == DOCK_QUIESCENT) {

                        possibleProfileChangeInProgress = TRUE;

                    } else if (relatedDeviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

                        subsumingProfileChange = TRUE;
                    }
                }

                relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                if (deleteType == QueryRemoveDevice || deleteType == EjectDevice) {

                    if (relatedDeviceNode->Flags & DNF_LEGACY_DRIVER) {

                        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                                   "PiProcessQueryRemoveAndEject: Vetoed by legacy driver relation\n"));
                        PiFinalizeVetoedRemove(
                            deviceEvent,
                            PNP_VetoLegacyDevice,
                            &relatedDeviceNode->InstancePath
                            );

                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }

                    if (relatedDeviceNode->State == DeviceNodeRemovePendingCloses) {

                        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                                   "PiProcessQueryRemoveAndEject: Vetoed due to device in DeviceNodeRemovePendingCloses\n"));
                        PiFinalizeVetoedRemove(
                            deviceEvent,
                            PNP_VetoOutstandingOpen,
                            &relatedDeviceNode->InstancePath
                            );

                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }

                }

                pdoList[ relationCount++ ] = relatedDeviceObject;
            }
        }

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(status)) {

        if ((deleteType == SurpriseRemoveDevice ||
             deleteType == RemoveFailedDevice ||
             deleteType == RemoveUnstartedFailedDevice ||
             deleteType == RemoveDevice)) {

            excludeIndirectRelations = TRUE;

        } else {
            excludeIndirectRelations = FALSE;
        }

        status = PiResizeTargetDeviceBlock( DeviceEvent,
                                            deleteType,
                                            relationsList,
                                            excludeIndirectRelations );

        deviceEvent = *DeviceEvent;


        if (deleteType == SurpriseRemoveDevice) {

            PiBuildUnsafeRemovalDeviceBlock(
                deviceEvent,
                relationsList,
                &surpriseRemovalEvent
                );
        }
    }

    if (!NT_SUCCESS(status)) {

        IopFreeRelationList(relationsList);

        if (pdoList) {

            ExFreePool(pdoList);
        }

        ExFreePool(internalVetoBuffer);

        PiFinalizeVetoedRemove(
            deviceEvent,
            PNP_VetoTypeUnknown,
            NULL
            );

        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        return status;
    }

    //
    // We may need to take the hardware profile change semaphore, and also
    // broadcast a hardware profile change request...
    //
    if (possibleProfileChangeInProgress) {

        PpProfileBeginHardwareProfileTransition(subsumingProfileChange);

        //
        // Walk the list of docks who are going to disappear and mark them as
        // in profile transition.
        //
        for (index = relationCount - 1; index >= 0; index--) {

            relatedDeviceObject = pdoList[ index ];
            relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

            ASSERT(relatedDeviceNode->DockInfo.DockStatus != DOCK_ARRIVING);
            if (relatedDeviceNode->DockInfo.DockStatus == DOCK_QUIESCENT) {

                PpProfileIncludeInHardwareProfileTransition(
                    relatedDeviceNode,
                    DOCK_DEPARTING
                    );
            }
        }

        //
        // We can only be in one of the following deleteType situations
        //
        // 1) EjectDevice          - Good, normal ejection request by our user
        //                           (we are using EjectionRelations)
        //
        // 2) SurpriseRemoveDevice - Someone yanked the dock out.
        //                           (we are using EjectionRelations)
        //
        // 3) RemoveFailedDevice   - A start failed after a stop on a parent or
        //                           even our device. This case is not handled
        //                           correctly. We assert for now, and we
        //                           maroon the dock, ie lose it's devnode but
        //                           the dock stays physically present and is
        //                           in the users eye's unejectable.
        //
        // 4) RemoveDevice         - This occurs in three cases:
        //                              a) A removed device is disappearing.
        //                              b) A device is being removed but has not
        //                                 been started.
        //                              c) A device has failed start.
        //
        //                           We pass through case a) during a normal
        //                           ejection and as part of a profile
        //                           transition begun earlier. c) is similar
        //                           to a) but the transition was begun by the
        //                           start code. For case b) we don't want to
        //                           turn it into an eject, as the OS might be
        //                           removing our parent as a normal part of
        //                           setup, and we wouldn't want to undock then
        //                           (and we probably aren't changing profiles
        //                           anyway).
        //
        // 5) QueryRemoveDevice      This should never be the case here per the
        //                           explicit veto in the IopEnumerateRelations
        //                           code above.
        //

        //
        // RemoveFailedDevice is a PathTrap - the only parent of a dock is
        // the ACPI root devnode right now. We shouldn't get into that case.
        //
        ASSERT(deleteType != QueryRemoveDevice &&
               deleteType != RemoveFailedDevice);

        if (deleteType == EjectDevice) {

            //
            // Are there any legacy drivers in the system?
            //
            status = IoGetLegacyVetoList(&vetoList, &vetoType);

            if (NT_SUCCESS(status) &&
                (vetoType != PNP_VetoTypeUnknown)) {

                IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                           "PiProcessQueryRemoveAndEject: Vetoed due to presence of a legacy driver\n"));
                //
                // Release any docks in profile transition
                //
                PpProfileCancelHardwareProfileTransition();

                IopFreeRelationList(relationsList);

                //
                // Failure occured, notify user mode as appropriate, or fill in
                // the veto buffer.
                //
                if (deviceEvent->VetoType != NULL) {

                    *deviceEvent->VetoType = vetoType;
                }

                if (deviceEvent->VetoName == NULL) {

                    //
                    // If there is not a VetoName passed in then call user mode
                    // to display the eject veto notification to the user.
                    //
                    PiNotifyUserModeRemoveVetoedByList(
                        deviceEvent,
                        deviceObject,
                        vetoType,
                        vetoList
                        );

                } else {

                    //
                    //     The veto data in the PNP_DEVICE_EVENT_ENTRY block is
                    // a UNICODE_STRING field. Since that type of data structure
                    // cannot handle Multi-Sz data, we cull the information down
                    // to one entry here.
                    //
                    RtlCopyUnicodeString(deviceEvent->VetoName, &singleVetoListItem);
                    RtlInitUnicodeString(&singleVetoListItem, vetoList);
                }

                ExFreePool(vetoList);
                ExFreePool(pdoList);
                ExFreePool(internalVetoBuffer);

                PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
                return STATUS_PLUGPLAY_QUERY_VETOED;
            }

            //
            // Broadcast the query for a profile change against our current
            // list of docks in transition...
            //
            status = PpProfileQueryHardwareProfileChange(
                subsumingProfileChange,
                PROFILE_IN_PNPEVENT,
                &vetoType,
                &internalVetoString
                );

            if (!NT_SUCCESS(status)) {

                IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                           "PiProcessQueryRemoveAndEject: Vetoed due to failed HW profile change\n"));
                //
                // Release any docks in profile transition
                //
                PpProfileCancelHardwareProfileTransition();

                IopFreeRelationList(relationsList);

                PiFinalizeVetoedRemove(
                    deviceEvent,
                    vetoType,
                    &internalVetoString
                    );

                ExFreePool(pdoList);
                ExFreePool(internalVetoBuffer);

                PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
                return STATUS_PLUGPLAY_QUERY_VETOED;
            }
        }
    }

    if (deleteType == QueryRemoveDevice || deleteType == EjectDevice) {

        //
        // Send query notification to user-mode.
        //

        status = PiNotifyUserModeDeviceRemoval(
            deviceEvent,
            &GUID_TARGET_DEVICE_QUERY_REMOVE,
            &vetoType,
            &internalVetoString
            );

        if (NT_SUCCESS(status)) {

            IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                       "PiProcessQueryRemoveAndEject: QUERY_REMOVE - notifying kernel-mode\n"));

            //
            // Send query notification to kernel-mode drivers.
            //

            for (index = 0; index < (LONG)relationCount; index++) {

                relatedDeviceObject = pdoList[ index ];

                status = IopNotifyTargetDeviceChange( &GUID_TARGET_DEVICE_QUERY_REMOVE,
                                                      relatedDeviceObject,
                                                      NULL,
                                                      &vetoingDriver);

                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                               "PiProcessQueryRemoveAndEject: Vetoed due to driver failing QR notification\n"));
                    vetoType = PNP_VetoDriver;

                    if (vetoingDriver != NULL) {

                        RtlCopyUnicodeString(&internalVetoString, &vetoingDriver->DriverName);

                    } else {

                        RtlInitUnicodeString(&internalVetoString, NULL);
                    }

                    for (index--; index >= 0; index--) {
                        relatedDeviceObject = pdoList[ index ];

                        IopNotifyTargetDeviceChange( &GUID_TARGET_DEVICE_REMOVE_CANCELLED,
                                                     relatedDeviceObject,
                                                     NULL,
                                                     NULL);

                    }
                    break;
                }
            }

            if (NT_SUCCESS(status)) {
                //
                // If we haven't already performed the action yet (a query remove
                // to the target device, in this case), then do it now.
                //

                IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                           "PiProcessQueryRemoveAndEject: QueryRemove DevNodes\n"));

                status = IopDeleteLockedDeviceNodes(deviceObject,
                                                    relationsList,
                                                    QueryRemoveDevice,
                                                    TRUE,
                                                    0,
                                                    &vetoType,
                                                    &internalVetoString);
                if (NT_SUCCESS(status)) {
                    //
                    // Everyone has been notified and had a chance to close their handles.
                    // Since no one has vetoed it yet, let's see if there are any open
                    // references.
                    //

                    if (IopNotifyPnpWhenChainDereferenced( pdoList, relationCount, TRUE, &vetoingDevice )) {

                        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                                   "PiProcessQueryRemoveAndEject: Vetoed due to open handles against the device\n"));

                        vetoType = PNP_VetoOutstandingOpen;

                        if (!PiCollectOpenHandles(pdoList, relationCount, FALSE, &internalVetoString)) {

                            if (vetoingDevice != NULL) {

                                relatedDeviceNode = (PDEVICE_NODE)vetoingDevice->DeviceObjectExtension->DeviceNode;

                                ASSERT(relatedDeviceNode != NULL);

                                RtlCopyUnicodeString(&internalVetoString, &relatedDeviceNode->InstancePath);

                            } else {

                                RtlInitUnicodeString(&internalVetoString, NULL);
                            }
                        }

                        //
                        // Send cancel remove to the target devices.
                        //

                        IopDeleteLockedDeviceNodes(deviceObject,
                                                   relationsList,
                                                   CancelRemoveDevice,
                                                   TRUE,
                                                   0,
                                                   NULL,
                                                   NULL);

                        status = STATUS_UNSUCCESSFUL;
                    }

                } else if (vetoType == PNP_VetoDevice) {

                    PiCollectOpenHandles(pdoList, relationCount, FALSE, &internalVetoString);
                }

                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                               "PiProcessQueryRemoveAndEject: Vetoed due someone in the stack failed QR\n"));
                    //
                    // Send cancel notification to kernel-mode drivers.
                    //

                    for (index = relationCount - 1; index >= 0; index--) {

                        relatedDeviceObject = pdoList[ index ];

                        IopNotifyTargetDeviceChange( &GUID_TARGET_DEVICE_REMOVE_CANCELLED,
                                                     relatedDeviceObject,
                                                     NULL,
                                                     NULL);
                    }
                }
            }

            if (!NT_SUCCESS(status)) {

                IopDbgPrint((IOP_IOEVENT_WARNING_LEVEL,
                           "PiProcessQueryRemoveAndEject: Vetoed by \"%wZ\" (type 0x%x)\n",
                           &internalVetoString,
                           vetoType));

                PiFinalizeVetoedRemove(
                    deviceEvent,
                    vetoType,
                    &internalVetoString
                    );

                //
                // A driver vetoed the query remove, go back and send
                // cancels to user-mode (cancels already sent to drivers
                // that received the query).
                //
                PiNotifyUserModeDeviceRemoval(
                    deviceEvent,
                    &GUID_TARGET_DEVICE_REMOVE_CANCELLED,
                    NULL,
                    NULL
                    );
            }

        } else {

            IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                       "PiProcessQueryRemoveAndEject: Vetoed due to UM failing QR\n"));

            PiFinalizeVetoedRemove(
                deviceEvent,
                vetoType,
                &internalVetoString
                );
        }

        if (!NT_SUCCESS(status)) {

            //
            // Broadcast a cancel HW profile change event if appropriate.
            //
            if (possibleProfileChangeInProgress) {

                //
                // Release any docks in profile transition. We also broadcast
                // the cancel.
                //
                PpProfileCancelHardwareProfileTransition();
            }

            //
            // User-mode vetoed the request (cancels already sent
            // to user-mode callers that received the query).
            //
            IopFreeRelationList(relationsList);

            ExFreePool(pdoList);
            ExFreePool(internalVetoBuffer);

            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }

    } else if (deleteType == SurpriseRemoveDevice || deleteType == RemoveFailedDevice) {

        //
        // Send IRP_MN_SURPRISE_REMOVAL, IopDeleteLockDeviceNodes ignores
        // indirect descendants for SurpriseRemoveDevice.
        //
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiProcessQueryRemoveAndEject: QueryRemove DevNodes\n"));

        IopDeleteLockedDeviceNodes( deviceObject,
                                    relationsList,
                                    SurpriseRemoveDevice,
                                    FALSE,
                                    0,
                                    NULL,
                                    NULL);
    }

    //
    // Notify user-mode and drivers that a remove is happening. User-mode
    // sees this as a remove pending if it's user initiated, we don't give
    // them the "remove" until it's actually gone.
    //
    if (deleteType != SurpriseRemoveDevice) {

        //
        // ISSUE - 2000/08/20 - ADRIAO: Busted message path
        //     We send GUID_DEVICE_REMOVE_PENDING to devices that are already
        // dead in the case of RemoveFailedDevice.
        //
        PiNotifyUserModeDeviceRemoval(
            deviceEvent,
            &GUID_DEVICE_REMOVE_PENDING,
            NULL,
            NULL
            );

    } else {

        if (surpriseRemovalEvent) {

            PiNotifyUserModeDeviceRemoval(
                surpriseRemovalEvent,
                &GUID_DEVICE_SURPRISE_REMOVAL,
                NULL,
                NULL
                );

            ExFreePool(surpriseRemovalEvent);
        }

        PiNotifyUserModeDeviceRemoval(
            deviceEvent,
            &GUID_TARGET_DEVICE_REMOVE_COMPLETE,
            NULL,
            NULL
            );
    }

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessQueryRemoveAndEject: REMOVE_COMPLETE - notifying kernel-mode\n"));

    for (index = 0; index < (LONG)relationCount; index++) {

        relatedDeviceObject = pdoList[ index ];

        status = IopNotifyTargetDeviceChange( &GUID_TARGET_DEVICE_REMOVE_COMPLETE,
                                              relatedDeviceObject,
                                              NULL,
                                              NULL);

        ASSERT(NT_SUCCESS(status));
    }

    if (deleteType == RemoveDevice ||
        deleteType == RemoveFailedDevice ||
        deleteType == SurpriseRemoveDevice) {

        //
        // For these operations indirect relations are speculative.
        //
        // So for each of the indirect relations, invalidate their parents and
        // remove them from the relations list.
        //

        IopInvalidateRelationsInList( relationsList, deleteType, TRUE, FALSE );

        IopRemoveIndirectRelationsFromList( relationsList );
    }

    if (deleteType == RemoveFailedDevice ||
        deleteType == SurpriseRemoveDevice) {

        //
        // We've sent the surprise remove IRP to the original device and all its
        // direct descendants.  We've also notified user-mode.
        //

        //
        // Unlock the device relations list.
        //
        // Note there could be a potential race condition here between
        // unlocking the devnodes in the relation list and completing the
        // execution of IopNotifyPnpWhenChainDereferenced.  If an enumeration
        // takes places (we've unlocked the devnode) before the eventual remove
        // is sent then problems could occur.
        //
        // This is prevented by the setting of DNF_REMOVE_PENDING_CLOSES when
        // we sent the IRP_MN_SURPRISE_REMOVAL.
        //
        // We do need to do it prior to calling IopQueuePendingSurpriseRemoval
        // since we lose ownership of the relation list in that call.  Also
        // IopNotifyPnpWhenChainDereferenced may cause the relation list to be
        // freed before it returns.
        //
        // If this is a RemoveFailedDevice then we don't want to remove the
        // device node from the tree but we do want to remove children without
        // resources.
        //

        IopUnlinkDeviceRemovalRelations( deviceObject,
                                         relationsList,
                                         deleteType == SurpriseRemoveDevice ?
                                             UnlinkAllDeviceNodesPendingClose :
                                             UnlinkOnlyChildDeviceNodesPendingClose);

        //
        // Add the relation list to a list of pending surprise removals.
        //
        IopQueuePendingSurpriseRemoval( deviceObject, relationsList, deviceEvent->Argument );

        //
        // Release the engine lock *before* IopNotifyPnpWhenChainDereferenced,
        // as it may call back into us...
        //
        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        IopNotifyPnpWhenChainDereferenced( pdoList, relationCount, FALSE, NULL );

        ExFreePool(pdoList);
        ExFreePool(internalVetoBuffer);

        return STATUS_SUCCESS;
    }

    if (deviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

        status = IopQueryDockRemovalInterface(
            deviceObject,
            &dockInterface
            );

        if (dockInterface) {

            //
            // Make sure updates don't occur on removes during an ejection.
            // We may change this to PDS_UPDATE_ON_EJECT *after* the remove
            // IRPs go through (as only then do we know our power
            // constraints)
            //
            dockInterface->ProfileDepartureSetMode(
                dockInterface->Context,
                PDS_UPDATE_ON_INTERFACE
                );
        }
    }

    //
    // Send the remove to the devnode tree.
    //

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessQueryRemoveAndEject: RemoveDevice DevNodes\n"));

    status = IopDeleteLockedDeviceNodes(deviceObject,
                                        relationsList,
                                        RemoveDevice,
                                        (BOOLEAN)(deleteType == QueryRemoveDevice || deleteType == EjectDevice),
                                        deviceEvent->Argument,
                                        NULL,
                                        NULL);

    hotEjectSupported =
        (BOOLEAN) IopDeviceNodeFlagsToCapabilities(deviceNode)->EjectSupported;

    warmEjectSupported =
        (BOOLEAN) IopDeviceNodeFlagsToCapabilities(deviceNode)->WarmEjectSupported;

    if (deleteType != EjectDevice) {

        if (!(deviceEvent->Data.Flags & TDF_NO_RESTART)) {

            //
            // Set a flag to let kernel-mode know we'll be wanting to
            // restart these devnodes, eventually.
            //

            marker = 0;
            while (IopEnumerateRelations( relationsList,
                                          &marker,
                                          &relatedDeviceObject,
                                          NULL,
                                          NULL,
                                          TRUE)) {

                relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                if (relatedDeviceNode &&
                    relatedDeviceNode->State == DeviceNodeRemoved &&
                    PipIsDevNodeProblem(relatedDeviceNode, CM_PROB_WILL_BE_REMOVED)) {

                    if (!(deviceEvent->Data.Flags & TDF_ONLY_RESTART_RELATIONS) || 
                        deviceObject != relatedDeviceObject) {

                        PipClearDevNodeProblem(relatedDeviceNode);

                        IopRestartDeviceNode(relatedDeviceNode);
                    }
                }
            }
        }

        //
        // Unlock the device relations list.
        //
        IopUnlinkDeviceRemovalRelations( deviceObject,
                                         relationsList,
                                         UnlinkRemovedDeviceNodes );

        IopFreeRelationList(relationsList);

    } else if (hotEjectSupported || warmEjectSupported) {

        //
        // From this point on we cannot return any sort of failure without
        // going through IopEjectDevice or cancelling any outstanding profile
        // change.
        //

        //
        // Set a flag to let kernel-mode know we'll be wanting to
        // restart these devnodes, eventually.
        //

        marker = 0;
        while (IopEnumerateRelations( relationsList,
                                      &marker,
                                      &relatedDeviceObject,
                                      NULL,
                                      NULL,
                                      TRUE)) {

            relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

            if (relatedDeviceNode)  {

                relatedDeviceNode->Flags |= DNF_LOCKED_FOR_EJECT;
            }
        }

        IopUnlinkDeviceRemovalRelations( deviceObject,
                                         relationsList,
                                         UnlinkRemovedDeviceNodes );

        //
        // Send the eject
        //
        pendingRelations = ExAllocatePool( NonPagedPool, sizeof(PENDING_RELATIONS_LIST_ENTRY) );

        if (pendingRelations == NULL) {

            //
            // It's cleanup time. Free up everything that matters
            //
            if (dockInterface) {

                dockInterface->ProfileDepartureSetMode(
                    dockInterface->Context,
                    PDS_UPDATE_DEFAULT
                    );

                dockInterface->InterfaceDereference(dockInterface->Context);
            }

            ExFreePool(pdoList);
            ExFreePool(internalVetoBuffer);

            if (possibleProfileChangeInProgress) {

                //
                // Release any docks in profile transition. We also broadcast
                // the cancel.
                //
                PpProfileCancelHardwareProfileTransition();
            }

            //
            // This will bring back online the devices that were held offline
            // for the duration of the undock.
            //
            IopInvalidateRelationsInList(relationsList, deleteType, FALSE, TRUE);

            //
            // Free the relations list
            //
            IopFreeRelationList(relationsList);

            //
            // Let the user know we were unable to process the request.
            //
            PiFinalizeVetoedRemove(
                deviceEvent,
                PNP_VetoTypeUnknown,
                NULL
                );

            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }

        //
        // Fill out the pending eject information.
        //
        ObReferenceObject(deviceObject);
        pendingRelations->DeviceEvent = deviceEvent;
        pendingRelations->DeviceObject = deviceObject;
        pendingRelations->RelationsList = relationsList;
        pendingRelations->ProfileChangingEject = possibleProfileChangeInProgress;
        pendingRelations->DisplaySafeRemovalDialog =
            (BOOLEAN)(deviceEvent->VetoName == NULL);
        pendingRelations->DockInterface = dockInterface;

        //
        // Now that we've removed all the devices that won't be present
        // in the new hardware profile state (eg batteries, etc),
        //
        status = PoGetLightestSystemStateForEject(
            possibleProfileChangeInProgress,
            hotEjectSupported,
            warmEjectSupported,
            &pendingRelations->LightestSleepState
            );

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_INSUFFICIENT_POWER) {

                PiFinalizeVetoedRemove(
                    deviceEvent,
                    PNP_VetoInsufficientPower,
                    NULL
                    );

            } else {

                IopDbgPrint((IOP_IOEVENT_WARNING_LEVEL,
                           "PiProcessQueryRemoveAndEject: Vetoed by power system (%x)\n",
                           status));

                PiFinalizeVetoedRemove(
                    deviceEvent,
                    PNP_VetoTypeUnknown,
                    NULL
                    );
            }

            //
            // We'll complete this one ourselves thank you.
            //
            pendingRelations->DeviceEvent = NULL;
            pendingRelations->DisplaySafeRemovalDialog = FALSE;

            //
            // Release any profile transitions.
            //
            InitializeListHead( &pendingRelations->Link );
            IopProcessCompletedEject((PVOID) pendingRelations);

            ExFreePool(pdoList);
            ExFreePool(internalVetoBuffer);

            PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
            return STATUS_PLUGPLAY_QUERY_VETOED;
        }

        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

        //
        // Completion routine for the eject IRP handles display of the
        // safe removal dialog and completion of the event. Returning
        // STATUS_PENDING does let other events get processed though.
        //
        IopEjectDevice( deviceObject, pendingRelations );

        ExFreePool(pdoList);
        ExFreePool(internalVetoBuffer);

        return STATUS_PENDING;

    } else {

        //
        // All docks must be hot or warm ejectable.
        //
        ASSERT(!dockInterface);

        //
        // Unlock the device relations list.
        //
        IopUnlinkDeviceRemovalRelations( deviceObject,
                                         relationsList,
                                         UnlinkRemovedDeviceNodes );

        IopFreeRelationList(relationsList);

        //
        // This hardware supports neither hot nor warm eject, but it is
        // removable. It can therefore be thought of as a "user assisted" hot
        // eject. In this case we do *not* want to wait around for the user to
        // "complete the eject" and then put up the message. So we piggyback a
        // safe removal notification while UmPnPMgr is alert and waiting in
        // user mode, and the user gets the dialog now.
        //
        if (deviceEvent->VetoName == NULL) {

            PpNotifyUserModeRemovalSafe(deviceObject);
        }
    }

    if (deleteType == RemoveDevice) {

        //
        // Notify user-mode one last time that everything is actually done.
        //
        PiNotifyUserModeDeviceRemoval(
            deviceEvent,
            &GUID_TARGET_DEVICE_REMOVE_COMPLETE,
            NULL,
            NULL
            );
    }

    ExFreePool(pdoList);

    if (dockInterface) {

        dockInterface->ProfileDepartureSetMode(
            dockInterface->Context,
            PDS_UPDATE_DEFAULT
            );

        dockInterface->InterfaceDereference(dockInterface->Context);
    }

    ExFreePool(internalVetoBuffer);
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
    return STATUS_SUCCESS;
}


NTSTATUS
PiProcessTargetDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    )

/*++

Routine Description:

    This routine processes each type of event in the target device category.
    These events may have been initiated by either user-mode or kernel mode.

Arguments:

    deviceEvent - Data describing the type of target device event and the
            target device itself.


Return Value:

    None.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    deviceEvent = *DeviceEvent;

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessTargetDeviceEvent: Entered\n"));

    //-----------------------------------------------------------------
    // QUERY and REMOVE
    //-----------------------------------------------------------------

    if (PiCompareGuid(&deviceEvent->Data.EventGuid,
                      &GUID_DEVICE_QUERY_AND_REMOVE)) {

        status = PiProcessQueryRemoveAndEject(DeviceEvent);

    }

    //-----------------------------------------------------------------
    // EJECT
    //-----------------------------------------------------------------

    else if (PiCompareGuid(&deviceEvent->Data.EventGuid,
                           &GUID_DEVICE_EJECT)) {

        status = PiProcessQueryRemoveAndEject(DeviceEvent);

    }

    //-----------------------------------------------------------------
    // ARRIVAL
    //-----------------------------------------------------------------

    else if (PiCompareGuid(&deviceEvent->Data.EventGuid,
                           &GUID_DEVICE_ARRIVAL)) {

        //
        // Notify user-mode (not drivers) that an arrival just happened.
        //

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiProcessTargetDeviceEvent: ARRIVAL - notifying user-mode\n"));

        PiNotifyUserMode(deviceEvent);
    }

    //-----------------------------------------------------------------
    // NO-OP REQUEST (to flush device event queue)
    //-----------------------------------------------------------------

    else if (PiCompareGuid(&deviceEvent->Data.EventGuid,
                           &GUID_DEVICE_NOOP)) {

        status = STATUS_SUCCESS;

    }

    //-----------------------------------------------------------------
    // SAFE REMOVAL NOTIFICATION
    //-----------------------------------------------------------------

    else if (PiCompareGuid(&deviceEvent->Data.EventGuid, &GUID_DEVICE_SAFE_REMOVAL)) {

        //
        // Notify user-mode (and nobody else) that it is now safe to remove
        // someone.
        //

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "PiProcessTargetDeviceEvent: SAFE_REMOVAL - notifying user-mode\n"));

        PiNotifyUserMode(deviceEvent);
    }

    return status;

} // PiProcessTargetDeviceEvent


NTSTATUS
PiProcessCustomDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent
    )

/*++

Routine Description:

    This routine processes each type of event in the custom device category.
    These events may have been initiated by either user-mode or kernel mode.

Arguments:

    deviceEvent - Data describing the type of custom device event and the
            target device itself.


Return Value:

    None.

--*/

{
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;
    PTARGET_DEVICE_CUSTOM_NOTIFICATION  customNotification;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    deviceEvent = *DeviceEvent;

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessCustomDeviceEvent: Entered\n"));

    ASSERT(PiCompareGuid(&deviceEvent->Data.EventGuid,
                         &GUID_PNP_CUSTOM_NOTIFICATION));

    deviceObject = (PDEVICE_OBJECT)deviceEvent->Data.DeviceObject;
    customNotification = (PTARGET_DEVICE_CUSTOM_NOTIFICATION)deviceEvent->Data.u.CustomNotification.NotificationStructure;

    //
    // Notify user-mode that something just happened.
    //

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessCustomDeviceEvent: CUSTOM_NOTIFICATION - notifying user-mode\n"));

    PiNotifyUserMode(deviceEvent);

    //
    // Notify K-mode
    //

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PiProcessCustomDeviceEvent: CUSTOM_NOTIFICATION - notifying kernel-mode\n"));

    IopNotifyTargetDeviceChange( &customNotification->Event,
                                 deviceObject,
                                 customNotification,
                                 NULL);

    return STATUS_SUCCESS;

} // PiProcessCustomDeviceEvent


NTSTATUS
PiResizeTargetDeviceBlock(
    IN OUT PPNP_DEVICE_EVENT_ENTRY *DeviceEvent,
    IN PLUGPLAY_DEVICE_DELETE_TYPE DeleteType,
    IN PRELATION_LIST RelationsList,
    IN BOOLEAN ExcludeIndirectRelations
    )
/*++

Routine Description:

    This routine takes the passed in device event block and resizes it to
    hold a multisz list of device instance strings in the DeviceIds field.
    This list includes the original target device id plus the device id
    for all the device objects in the specified DeviceRelations struct.

Arguments:

    DeviceEvent - On entry, contains the original device event block, on
            return it contains the newly allocated device event block and
            a complete list of related device id strings.

    DeviceRelations - structure that contains a list of related device objects.

Return Value:

    NTSTATUS value.

--*/
{
    PDEVICE_NODE relatedDeviceNode;
    PDEVICE_OBJECT relatedDeviceObject;
    ULONG newSize, currentSize;
    PPNP_DEVICE_EVENT_ENTRY newDeviceEvent;
    LPWSTR targetDevice, p;
    ULONG marker;
    BOOLEAN directDescendant;

    PAGED_CODE();

    if (RelationsList == NULL) {
        return STATUS_SUCCESS;  // nothing to do
    }

    targetDevice = (*DeviceEvent)->Data.u.TargetDevice.DeviceIds;

    //
    // Calculate the size of the PNP_DEVICE_EVENT_ENTRY block
    //

    currentSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) +
                  (*DeviceEvent)->Data.TotalSize;

    newSize = currentSize;
    newSize -= (ULONG)((wcslen(targetDevice)+1) * sizeof(WCHAR));

    marker = 0;
    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &relatedDeviceObject,
                                  &directDescendant,
                                  NULL,
                                  FALSE)) {

        if (!ExcludeIndirectRelations || directDescendant) {

            relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

            if (relatedDeviceNode != NULL) {
                if (relatedDeviceNode->InstancePath.Length != 0) {
                    newSize += relatedDeviceNode->InstancePath.Length + sizeof(WCHAR);
                }
            }
        }
    }

    ASSERT(newSize >= currentSize);

    if (newSize == currentSize) {

        return STATUS_SUCCESS;

    } else if (newSize < currentSize) {

        newSize = currentSize;
    }

    newDeviceEvent = (PPNP_DEVICE_EVENT_ENTRY) PiAllocateCriticalMemory(
        DeleteType,
        PagedPool,
        newSize,
        PNP_DEVICE_EVENT_ENTRY_TAG
        );

    if (newDeviceEvent == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)newDeviceEvent, newSize);

    //
    // Copy the old buffer into the new buffer, it's only the new stuff at the
    // end that changes.
    //

    RtlCopyMemory(newDeviceEvent, *DeviceEvent, currentSize);

    //
    // Update the size of the PLUGPLAY_EVENT_BLOCK
    //
    newDeviceEvent->Data.TotalSize = newSize - FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data);

    //
    // Add device instance string for each device relation to the list.
    // Leave the target device first in the list, and skip it during the
    // enumeration below.
    //

    marker = 0;
    p = newDeviceEvent->Data.u.TargetDevice.DeviceIds + wcslen(targetDevice) + 1;
    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &relatedDeviceObject,
                                  &directDescendant,
                                  NULL,
                                  FALSE)) {

        if ((relatedDeviceObject != newDeviceEvent->Data.DeviceObject) &&
            (!ExcludeIndirectRelations || directDescendant)) {

            relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

            if (relatedDeviceNode != NULL) {
                if (relatedDeviceNode->InstancePath.Length != 0) {
                    RtlCopyMemory(p,
                                  relatedDeviceNode->InstancePath.Buffer,
                                  relatedDeviceNode->InstancePath.Length);
                    p += relatedDeviceNode->InstancePath.Length / sizeof(WCHAR) + 1;
                }
            }
        }
    }

    *p = UNICODE_NULL;

    ExFreePool(*DeviceEvent);
    *DeviceEvent = newDeviceEvent;

    return STATUS_SUCCESS;

} // PiResizeTargetDeviceBlock


VOID
PiBuildUnsafeRemovalDeviceBlock(
    IN  PPNP_DEVICE_EVENT_ENTRY     OriginalDeviceEvent,
    IN  PRELATION_LIST              RelationsList,
    OUT PPNP_DEVICE_EVENT_ENTRY    *AllocatedDeviceEvent
    )
/*++

Routine Description:

    This routine builds a device event block to send to user mode in case of
    unsafe removal.

Arguments:

    OriginalDeviceEvent - Contains the original device event block.

    RelationList - structure that contains a list of related device objects.

    AllocatedDeviceEvent - Receives the new device event, NULL on error or
                           no entries.

Return Value:

    None.

--*/
{
    PDEVICE_NODE relatedDeviceNode;
    PDEVICE_OBJECT relatedDeviceObject;
    ULONG dataSize, eventSize, headerSize;
    PPNP_DEVICE_EVENT_ENTRY newDeviceEvent;
    LPWSTR targetDevice, p;
    ULONG marker;
    BOOLEAN directDescendant;

    PAGED_CODE();

    //
    // Preinit
    //
    *AllocatedDeviceEvent = NULL;

    if (RelationsList == NULL) {

        return;  // nothing to do
    }

    targetDevice = OriginalDeviceEvent->Data.u.TargetDevice.DeviceIds;

    //
    // Calculate the size of the PNP_DEVICE_EVENT_ENTRY block
    //
    dataSize = 0;

    marker = 0;
    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &relatedDeviceObject,
                                  &directDescendant,
                                  NULL,
                                  FALSE)) {

        if (!directDescendant) {

            continue;
        }

        relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

        if ((relatedDeviceNode == NULL) ||
            PipIsBeingRemovedSafely(relatedDeviceNode)) {

            continue;
        }

        if (relatedDeviceNode->InstancePath.Length != 0) {
            dataSize += relatedDeviceNode->InstancePath.Length + sizeof(WCHAR);
        }
    }

    if (dataSize == 0) {

        //
        // No entries, bail.
        //
        return;
    }

    //
    // Add the terminating MultiSz NULL.
    //
    dataSize += sizeof(WCHAR);

    headerSize = FIELD_OFFSET(PNP_DEVICE_EVENT_ENTRY, Data) +
                 FIELD_OFFSET(PLUGPLAY_EVENT_BLOCK, u);

    eventSize = dataSize + headerSize;

    //
    // If we can't get memory, there simply won't be a message sent.
    //
    newDeviceEvent = ExAllocatePoolWithTag(
        PagedPool,
        eventSize,
        PNP_DEVICE_EVENT_ENTRY_TAG
        );

    if (newDeviceEvent == NULL) {

        return;
    }

    RtlZeroMemory((PVOID)newDeviceEvent, eventSize);

    //
    // Copy the header into the new buffer.
    //
    RtlCopyMemory(newDeviceEvent, OriginalDeviceEvent, headerSize);

    //
    // Update the size of the PLUGPLAY_EVENT_BLOCK
    //
    newDeviceEvent->Data.TotalSize = dataSize + FIELD_OFFSET(PLUGPLAY_EVENT_BLOCK, u);

    //
    // Add device instance string for each device relation to the list.
    //

    marker = 0;
    p = newDeviceEvent->Data.u.TargetDevice.DeviceIds;
    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &relatedDeviceObject,
                                  &directDescendant,
                                  NULL,
                                  FALSE)) {

        if (!directDescendant) {

            continue;
        }

        relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

        if ((relatedDeviceNode == NULL) ||
            PipIsBeingRemovedSafely(relatedDeviceNode)) {

            continue;
        }

        if (relatedDeviceNode->InstancePath.Length != 0) {

            RtlCopyMemory(p,
                          relatedDeviceNode->InstancePath.Buffer,
                          relatedDeviceNode->InstancePath.Length);
            p += relatedDeviceNode->InstancePath.Length / sizeof(WCHAR) + 1;
        }
    }

    *p = UNICODE_NULL;

    *AllocatedDeviceEvent = newDeviceEvent;

    return;

} // PiBuildUnsafeRemovalDeviceBlock


VOID
PiFinalizeVetoedRemove(
    IN PPNP_DEVICE_EVENT_ENTRY  VetoedDeviceEvent,
    IN PNP_VETO_TYPE            VetoType,
    IN PUNICODE_STRING          VetoName        OPTIONAL
    )
/*++

Routine Description:

    This routine takes care of updating the event results with the veto
    information, puts up UI if neccessary, and dumps failure information to
    the debugger for debugging purposes.

Arguments:

    VetoedDeviceEvent - Data describing the device event failed.

    VetoType - The veto code best describing why the operation failed.

    VetoName - A unicode string appropriate to the veto code that describes
               the vetoer.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT deviceObject;
#if DBG
    PUNICODE_STRING devNodeName;
    const char *failureReason;
#endif

    deviceObject = (PDEVICE_OBJECT) VetoedDeviceEvent->Data.DeviceObject;

#if DBG
    devNodeName = &((PDEVICE_NODE) deviceObject->DeviceObjectExtension->DeviceNode)->InstancePath;

    switch(VetoType) {

        case PNP_VetoTypeUnknown:
            failureReason = "for unspecified reason";
            break;

        case PNP_VetoLegacyDevice:
            failureReason = "due to legacy device";
            break;

        case PNP_VetoPendingClose:

            //
            // ADRIAO N.B. 07/10/2000 - I believe this case is vestigal...
            //
            ASSERT(0);
            failureReason = "due to pending close";
            break;

        case PNP_VetoWindowsApp:
            failureReason = "due to windows application";
            break;

        case PNP_VetoWindowsService:
            failureReason = "due to service";
            break;

        case PNP_VetoOutstandingOpen:
            failureReason = "due to outstanding handles on device";
            break;

        case PNP_VetoDevice:
            failureReason = "by device";
            break;

        case PNP_VetoDriver:
            failureReason = "by driver";
            break;

        case PNP_VetoIllegalDeviceRequest:
            failureReason = "as the request was invalid for the device";
            break;

        case PNP_VetoInsufficientPower:
            failureReason = "because there would be insufficient system power to continue";
            break;

        case PNP_VetoNonDisableable:
            failureReason = "due to non-disableable device";
            break;

        case PNP_VetoLegacyDriver:
            failureReason = "due to legacy driver";
            break;

        case PNP_VetoInsufficientRights:
            failureReason = "insufficient permissions";
            break;

        default:
            ASSERT(0);
            failureReason = "due to uncoded reason";
            break;
    }

    if (VetoName != NULL) {

        IopDbgPrint((IOP_IOEVENT_WARNING_LEVEL,
            "PiFinalizeVetoedRemove: Removal of %wZ vetoed %s %wZ.\n",
            devNodeName,
            failureReason,
            VetoName
            ));

    } else {

        IopDbgPrint((IOP_IOEVENT_WARNING_LEVEL,
            "PiFinalizeVetoedRemove: Removal of %wZ vetoed %s.\n",
            devNodeName,
            failureReason
            ));
    }

#endif

    //
    // Update the vetoType field if the caller is interested.
    //
    if (VetoedDeviceEvent->VetoType != NULL) {

        *VetoedDeviceEvent->VetoType = VetoType;
    }

    //
    // The VetoName field tells us whether UI should be displayed (if NULL,
    // kernel mode UI is implicitely requested.)
    //
    if (VetoedDeviceEvent->VetoName != NULL) {

        if (VetoName != NULL) {

            RtlCopyUnicodeString(VetoedDeviceEvent->VetoName, VetoName);
        }

    } else {

        //
        // If there is not a VetoName passed in then call user mode to display the
        // eject veto notification to the user
        //
        PiNotifyUserModeRemoveVetoed(
            VetoedDeviceEvent,
            deviceObject,
            VetoType,
            VetoName
            );
    }
}


BOOLEAN
PiCompareGuid(
    CONST GUID *Guid1,
    CONST GUID *Guid2
    )
/*++

Routine Description:

    This routine compares two guids.

Arguments:

    Guid1 - First guid to compare

    Guid2 - Second guid to compare

Return Value:

    Returns TRUE if the guids are equal and FALSE if they're different.

--*/
{
    PAGED_CODE();

    if (RtlCompareMemory((PVOID)Guid1, (PVOID)Guid2, sizeof(GUID)) == sizeof(GUID)) {
        return TRUE;
    }
    return FALSE;

} // PiCompareGuid


PVOID
PiAllocateCriticalMemory(
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     DeleteType,
    IN  POOL_TYPE                       PoolType,
    IN  SIZE_T                          Size,
    IN  ULONG                           Tag
    )
/*++

Routine Description:

    This function allocates memory and never fails if the DeleteType isn't
    QueryRemoveDevice or EjectDevice. This function will disappear in the next
    version of the PnP engine as we will instead requeue failed operations
    (which will also result in a second attempt to allocate the memory) or
    preallocate the required memory when bringing new devnode's into the world.

Arguments:

    DeleteType - Operation (EjectDevice, SurpriseRemoveDevice, ...)

    PoolType - PagedPool, NonPagedPool

    Size - Size

    Tag - Allocation tag

Return Value:

    Allocation, NULL due to insufficient resources.

--*/
{
    PVOID memory;
    LARGE_INTEGER timeOut;

    PAGED_CODE();

    //
    // Retries only have a hope of succeeding if we are at PASSIVE_LEVEL
    //
    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    while(1) {

        memory = ExAllocatePoolWithTag(PoolType, Size, Tag);

        if (memory ||
            (DeleteType == QueryRemoveDevice) ||
            (DeleteType == EjectDevice)) {

            //
            // Either we got memory or the op was failable. Get out of here.
            //
            break;
        }

        //
        // We're stuck until more memory comes along. Let some other
        // threads run before we get another shot...
        //
        timeOut.QuadPart = Int32x32To64( 1, -10000 );
        KeDelayExecutionThread(KernelMode, FALSE, &timeOut);
    }

    return memory;
}


struct  {
    CONST GUID *Guid;
    PCHAR   Name;
}   EventGuidTable[] =  {
    { &GUID_HWPROFILE_QUERY_CHANGE,         "GUID_HWPROFILE_QUERY_CHANGE" },
    { &GUID_HWPROFILE_CHANGE_CANCELLED,     "GUID_HWPROFILE_CHANGE_CANCELLED" },
    { &GUID_HWPROFILE_CHANGE_COMPLETE,      "GUID_HWPROFILE_CHANGE_COMPLETE" },
    { &GUID_DEVICE_INTERFACE_ARRIVAL,       "GUID_DEVICE_INTERFACE_ARRIVAL" },
    { &GUID_DEVICE_INTERFACE_REMOVAL,       "GUID_DEVICE_INTERFACE_REMOVAL" },
    { &GUID_TARGET_DEVICE_QUERY_REMOVE,     "GUID_TARGET_DEVICE_QUERY_REMOVE" },
    { &GUID_TARGET_DEVICE_REMOVE_CANCELLED, "GUID_TARGET_DEVICE_REMOVE_CANCELLED" },
    { &GUID_TARGET_DEVICE_REMOVE_COMPLETE,  "GUID_TARGET_DEVICE_REMOVE_COMPLETE" },
    { &GUID_PNP_CUSTOM_NOTIFICATION,        "GUID_PNP_CUSTOM_NOTIFICATION" },
    { &GUID_DEVICE_ARRIVAL,                 "GUID_DEVICE_ARRIVAL" },
    { &GUID_DEVICE_ENUMERATED,              "GUID_DEVICE_ENUMERATED" },
    { &GUID_DEVICE_ENUMERATE_REQUEST,       "GUID_DEVICE_ENUMERATE_REQUEST" },
    { &GUID_DEVICE_START_REQUEST,           "GUID_DEVICE_START_REQUEST" },
    { &GUID_DEVICE_REMOVE_PENDING,          "GUID_DEVICE_REMOVE_PENDING" },
    { &GUID_DEVICE_QUERY_AND_REMOVE,        "GUID_DEVICE_QUERY_AND_REMOVE" },
    { &GUID_DEVICE_EJECT,                   "GUID_DEVICE_EJECT" },
    { &GUID_DEVICE_NOOP,                    "GUID_DEVICE_NOOP" },
    { &GUID_DEVICE_SURPRISE_REMOVAL,        "GUID_DEVICE_SURPRISE_REMOVAL" },
    { &GUID_DEVICE_SAFE_REMOVAL,            "GUID_DEVICE_SAFE_REMOVAL" },
    { &GUID_DEVICE_EJECT_VETOED,            "GUID_DEVICE_EJECT_VETOED" },
    { &GUID_DEVICE_REMOVAL_VETOED,          "GUID_DEVICE_REMOVAL_VETOED" },
};
#define EVENT_GUID_TABLE_SIZE   (sizeof(EventGuidTable) / sizeof(EventGuidTable[0]))

VOID
LookupGuid(
    IN CONST GUID *Guid,
    IN OUT PCHAR String,
    IN ULONG StringLength
    )
{
    int    i;

    PAGED_CODE();

    for (i = 0; i < EVENT_GUID_TABLE_SIZE; i++) {
        if (PiCompareGuid(Guid, EventGuidTable[i].Guid)) {
            strncpy(String, EventGuidTable[i].Name, StringLength - 1);
            String[StringLength - 1] = '\0';
            return;
        }
    }

    StringCchPrintfA( String, StringLength, "%08X-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X",
               Guid->Data1,
               Guid->Data2,
               Guid->Data3,
               Guid->Data4[0],
               Guid->Data4[1],
               Guid->Data4[2],
               Guid->Data4[3],
               Guid->Data4[4],
               Guid->Data4[5],
               Guid->Data4[6],
               Guid->Data4[7] );
}

VOID
DumpMultiSz(
    IN PWCHAR MultiSz
    )
{
    PWCHAR  p = MultiSz;
    ULONG   length;

    PAGED_CODE();

    while (*p) {
        length = (ULONG)wcslen(p);
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "        %S\n", p));

        p += length + 1;
    }
}

VOID
DumpPnpEvent(
    IN PPLUGPLAY_EVENT_BLOCK EventBlock
    )
{
    CHAR    guidString[256];

    PAGED_CODE();

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "PlugPlay Event Block @ 0x%p\n", EventBlock));

    LookupGuid(&EventBlock->EventGuid, guidString, sizeof(guidString));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    EventGuid = %s\n", guidString));

    IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
               "    DeviceObject = 0x%p\n", EventBlock->DeviceObject));

    switch (EventBlock->EventCategory) {
    case HardwareProfileChangeEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    HardwareProfileChangeEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));

        break;

    case TargetDeviceChangeEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    TargetDeviceChangeEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceIds:\n"));

        DumpMultiSz( EventBlock->u.TargetDevice.DeviceIds );
        break;

    case DeviceClassChangeEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceClassChangeEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));

        LookupGuid(&EventBlock->u.DeviceClass.ClassGuid, guidString, sizeof(guidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    ClassGuid = %s\n",
                   guidString));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    SymbolicLinkName = %S\n",
                   EventBlock->u.DeviceClass.SymbolicLinkName));
        break;

    case CustomDeviceEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    CustomDeviceEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    NotificationStructure = 0x%p\n    DeviceIds:\n",
                   EventBlock->u.CustomNotification.NotificationStructure));

        DumpMultiSz( EventBlock->u.CustomNotification.DeviceIds );
        break;

    case DeviceInstallEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceInstallEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));

        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceId = %S\n", EventBlock->u.InstallDevice.DeviceId));

        break;

    case DeviceArrivalEvent:
        IopDbgPrint((IOP_IOEVENT_INFO_LEVEL,
                   "    DeviceArrivalEvent, Result = 0x%p, Flags = 0x%08X, TotalSize = %d\n",
                   EventBlock->Result,
                   EventBlock->Flags,
                   EventBlock->TotalSize));
        break;
    }

}


LOGICAL
PiCollectOpenHandles(
    IN      PDEVICE_OBJECT  *DeviceObjectArray,
    IN      ULONG           ArrayCount,
    IN      LOGICAL         KnownHandleFailure,
    IN OUT  PUNICODE_STRING VetoString
    )
/*++

Routine Description:

    This helper routine finds any handles opened against the passed in array of
    device objects to either the veto string, the debugger console, or neither.

Arguments:

    DeviceObjectArray - Array of Physical Device Objects.

    ArrayCount - Number of device objects in the passed in array

    KnownHandleFailure - TRUE if the removal was vetoed due to open handles,
                         FALSE if not.

    VetoString - String to populate with veto information if told. This data is
                 not currently "sanitized" enough to be user-readable.

Return Value:

    TRUE if veto information populated, FALSE otherwise.

--*/
{
    ULONG i;
    LOGICAL collectHandles, dumpHandles;
    ENUM_HANDLES_CONTEXT enumContext;

    //
    // If we have enabled the dumping flag, or the user ran oh.exe, spit all
    // handles on a veto to the debugger.
    //
    dumpHandles =
        (PiDumpVetoedHandles ||
        ((NtGlobalFlag & FLG_MAINTAIN_OBJECT_TYPELIST) != 0));

    if (dumpHandles) {

        DbgPrint("Beginning handle dump:\n");

        if (!KnownHandleFailure) {

            DbgPrint("  (Failed Query-Remove - *Might* by due to leaked handles)\n");
        }
    }

    collectHandles = PiCollectVetoedHandles;

    if (!(collectHandles || dumpHandles)) {

        return FALSE;
    }

    VetoString->Length = 0;
    ASSERT(VetoString->MaximumLength >= sizeof(WCHAR));
    *VetoString->Buffer = UNICODE_NULL;

    enumContext.DumpHandles = dumpHandles;
    enumContext.CollectHandles = collectHandles;
    enumContext.VetoString = VetoString;
    enumContext.HandleCount = 0;

    for(i=0; i<ArrayCount; i++) {

        PpHandleEnumerateHandlesAgainstPdoStack(
            DeviceObjectArray[i],
            PiCollectOpenHandlesCallBack,
            (PVOID) &enumContext
            );
    }

    if (dumpHandles) {

        DbgPrint("Dump complete - %d total handles found.\n", enumContext.HandleCount);
    }

    return FALSE;
}


LOGICAL
PiCollectOpenHandlesCallBack(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PEPROCESS       Process,
    IN  PFILE_OBJECT    FileObject,
    IN  HANDLE          HandleId,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This helper routine for PiCollectOpenHandlesCallBack. It gets called
    back for each handle opened against a given device object.

Arguments:

    DeviceObject - Device Object handle was against. Will be valid (referenced)

    Process - Process handle was against. Will be valid (referenced)

    FileObject - File object pertaining to handle - might not be valid

    HandleId - Handle relating to open device - might not be valid

    Context - Context passed in to PpHandleEnumerateHandlesAgainstPdoStack.

Return Value:

    TRUE if the enumeration should be stopped, FALSE otherwise.

--*/
{
    PENUM_HANDLES_CONTEXT enumContext;
    WCHAR localBuf[23]; // "PPPPPPPPPP.0xHHHHHHHH_\0"
    HRESULT result;
    PWSTR endString;

    enumContext = (PENUM_HANDLES_CONTEXT) Context;

    if (enumContext->DumpHandles) {

        //
        // Display the handle.
        //
        DbgPrint(
            "  DeviceObject:%p ProcessID:%dT FileObject:%p Handle:%dT\n",
            DeviceObject,
            Process->UniqueProcessId,
            FileObject,
            HandleId
            );
    }

    if (enumContext->CollectHandles) {

        result = StringCbPrintfW(
            localBuf,
            sizeof(localBuf),
            L"%dT.0x%08x ",
            (ULONG)(ULONG_PTR)Process->UniqueProcessId,
            (ULONG)(ULONG_PTR)HandleId
            );

        if (SUCCEEDED(result)) {

            result = StringCbCatExW(
                enumContext->VetoString->Buffer,
                enumContext->VetoString->MaximumLength,
                localBuf,
                &endString,
                NULL,
                STRSAFE_NO_TRUNCATION
                );

            if (SUCCEEDED(result)) {

                enumContext->VetoString->Length = (USHORT)
                    (endString - enumContext->VetoString->Buffer)*sizeof(WCHAR);
            }
        }
    }

    enumContext->HandleCount++;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpirp.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnpirp.c

Abstract:

    This module contains IRP related routines.

Author:

    Shie-Lin Tzong (shielint) 13-Sept-1996

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#define FAULT_INJECT_INVALID_ID DBG

#if DBG_SCOPE

#define PnpIrpStatusTracking(Status, IrpCode, Device)                    \
    if (PnpIrpMask & (1 << IrpCode)) {                                   \
        if (!NT_SUCCESS(Status) || Status == STATUS_PENDING) {           \
            DbgPrint(" ++ %s Driver ( %wZ ) return status %08lx\n",      \
                     IrpName[IrpCode],                                   \
                     &Device->DriverObject->DriverName,                  \
                     Status);                                            \
        }                                                                \
    }

ULONG PnpIrpMask;
PCHAR IrpName[] = {
    "IRP_MN_START_DEVICE - ",                 // 0x00
    "IRP_MN_QUERY_REMOVE_DEVICE - ",          // 0x01
    "IRP_MN_REMOVE_DEVICE - ",                // 0x02
    "IRP_MN_CANCEL_REMOVE_DEVICE - ",         // 0x03
    "IRP_MN_STOP_DEVICE - ",                  // 0x04
    "IRP_MN_QUERY_STOP_DEVICE - ",            // 0x05
    "IRP_MN_CANCEL_STOP_DEVICE - ",           // 0x06
    "IRP_MN_QUERY_DEVICE_RELATIONS - ",       // 0x07
    "IRP_MN_QUERY_INTERFACE - ",              // 0x08
    "IRP_MN_QUERY_CAPABILITIES - ",           // 0x09
    "IRP_MN_QUERY_RESOURCES - ",              // 0x0A
    "IRP_MN_QUERY_RESOURCE_REQUIREMENTS - ",  // 0x0B
    "IRP_MN_QUERY_DEVICE_TEXT - ",            // 0x0C
    "IRP_MN_FILTER_RESOURCE_REQUIREMENTS - ", // 0x0D
    "INVALID_IRP_CODE - ",                    //
    "IRP_MN_READ_CONFIG - ",                  // 0x0F
    "IRP_MN_WRITE_CONFIG - ",                 // 0x10
    "IRP_MN_EJECT - ",                        // 0x11
    "IRP_MN_SET_LOCK - ",                     // 0x12
    "IRP_MN_QUERY_ID - ",                     // 0x13
    "IRP_MN_QUERY_PNP_DEVICE_STATE - ",       // 0x14
    "IRP_MN_QUERY_BUS_INFORMATION - ",        // 0x15
    "IRP_MN_DEVICE_USAGE_NOTIFICATION - ",    // 0x16
    NULL
};
#else
#define PnpIrpStatusTracking(Status, IrpCode, Device)
#endif

//
// Internal definitions
//

typedef struct _DEVICE_COMPLETION_CONTEXT {
    PDEVICE_NODE DeviceNode;
    ERESOURCE_THREAD Thread;
    ULONG IrpMinorCode;
#if DBG
    PVOID Id;
#endif
} DEVICE_COMPLETION_CONTEXT, *PDEVICE_COMPLETION_CONTEXT;

typedef struct _LOCK_MOUNTABLE_DEVICE_CONTEXT{
    PDEVICE_OBJECT MountedDevice;
    PDEVICE_OBJECT FsDevice;
} LOCK_MOUNTABLE_DEVICE_CONTEXT, *PLOCK_MOUNTABLE_DEVICE_CONTEXT;

//
// Internal references
//

NTSTATUS
IopDeviceEjectComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PDEVICE_OBJECT
IopFindMountableDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

PDEVICE_OBJECT
IopLockMountedDeviceForRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IrpMinorCode,
    OUT PLOCK_MOUNTABLE_DEVICE_CONTEXT Context
    );

VOID
IopUnlockMountedDeviceForRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IrpMinorCode,
    IN PLOCK_MOUNTABLE_DEVICE_CONTEXT Context
    );

NTSTATUS
IopFilterResourceRequirementsCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResReqList,
    OUT PVOID *Information
    );

//
// External reference
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopSynchronousCall)
#pragma alloc_text(PAGE, IopStartDevice)
#pragma alloc_text(PAGE, IopEjectDevice)
#pragma alloc_text(PAGE, IopCancelPendingEject)
#pragma alloc_text(PAGE, IopRemoveDevice)
//#pragma alloc_text(PAGE, IopQueryDeviceRelations)
#pragma alloc_text(PAGE, IopQueryDeviceResources)
#pragma alloc_text(PAGE, IopQueryDockRemovalInterface)
#pragma alloc_text(PAGE, IopQueryLegacyBusInformation)
#pragma alloc_text(PAGE, IopQueryResourceHandlerInterface)
#pragma alloc_text(PAGE, IopQueryReconfiguration)
#pragma alloc_text(PAGE, IopFindMountableDevice)
#pragma alloc_text(PAGE, IopFilterResourceRequirementsCall)
#pragma alloc_text(PAGE, IopQueryDeviceState)
#pragma alloc_text(PAGE, IopIncDisableableDepends)
#pragma alloc_text(PAGE, IopDecDisableableDepends)
#pragma alloc_text(PAGE, PpIrpQueryDeviceText)
#pragma alloc_text(PAGE, PpIrpQueryID)
#pragma alloc_text(PAGE, PpIrpQueryResourceRequirements)
#pragma alloc_text(PAGE, PpIrpQueryCapabilities)
#pragma alloc_text(PAGE, PpIrpQueryBusInformation)
#endif  // ALLOC_PRAGMA

NTSTATUS
IopSynchronousCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION TopStackLocation,
    OUT PULONG_PTR Information
    )

/*++

Routine Description:

    This function sends a synchronous irp to the top level device
    object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies the device object of the device being removed.

    TopStackLocation - Supplies a pointer to the parameter block for the irp.

    Information - Supplies a pointer to a variable to receive the returned
                  information of the irp.

Return Value:

    NTSTATUS code.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK statusBlock;
    KEVENT event;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    deviceObject = IoGetAttachedDevice(DeviceObject);

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
    if (irp == NULL){

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SPECIALIRP_WATERMARK_IRP(irp, IRP_SYSTEM_RESTRICTED);

    //
    // Initialize it to failure.
    //

    irp->IoStatus.Status = statusBlock.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = statusBlock.Information = 0;

    //
    // Set the pointer to the status block and initialized event.
    //

    KeInitializeEvent( &event,
                       SynchronizationEvent,
                       FALSE );

    irp->UserIosb = &statusBlock;
    irp->UserEvent = &event;

    //
    // Set the address of the current thread
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Queue this irp onto the current thread
    //

    IopQueueThreadIrp(irp);

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Copy in the caller-supplied stack location contents
    //

    *irpSp = *TopStackLocation;

    //
    // Call the driver
    //

    status = IoCallDriver(deviceObject, irp);

    PnpIrpStatusTracking(status, TopStackLocation->MinorFunction, deviceObject);

    //
    // If a driver returns STATUS_PENDING, we will wait for it to complete
    //

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = statusBlock.Status;
    }

    if (Information != NULL) {
        *Information = statusBlock.Information;
    }

    ASSERT(status != STATUS_PENDING);

    return status;
}

NTSTATUS
IopStartDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This function sends a start device irp to the top level device
    object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies the pointer to the device object of the device
                   being removed.

Return Value:

    NTSTATUS code.

--*/

{
    IO_STACK_LOCATION irpSp;
    PDEVICE_NODE deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_START_DEVICE;

    //
    // Set the pointers for the raw and translated resource lists
    //

    irpSp.Parameters.StartDevice.AllocatedResources = deviceNode->ResourceList;
    irpSp.Parameters.StartDevice.AllocatedResourcesTranslated = deviceNode->ResourceListTranslated;

    status = IopSynchronousCall(DeviceObject, &irpSp, NULL);

    return status;
}

NTSTATUS
IopEjectDevice(
    IN      PDEVICE_OBJECT                  DeviceObject,
    IN OUT  PPENDING_RELATIONS_LIST_ENTRY   PendingEntry
    )

/*++

Routine Description:

    This function sends an eject device irp to the top level device
    object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies a pointer to the device object of the device being
                   removed.

Return Value:

    NTSTATUS code.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PIRP irp;

    PAGED_CODE();

    if (PendingEntry->LightestSleepState != PowerSystemWorking) {

        //
        // We have to warm eject.
        //
        if (PendingEntry->DockInterface) {

            PendingEntry->DockInterface->ProfileDepartureSetMode(
                PendingEntry->DockInterface->Context,
                PDS_UPDATE_ON_EJECT
                );
        }

        PendingEntry->EjectIrp = NULL;

        InitializeListHead( &PendingEntry->Link );

        IopQueuePendingEject(PendingEntry);

        ExInitializeWorkItem( &PendingEntry->WorkItem,
                              IopProcessCompletedEject,
                              PendingEntry);

        ExQueueWorkItem( &PendingEntry->WorkItem, DelayedWorkQueue );
        return STATUS_SUCCESS;
    }

    if (PendingEntry->DockInterface) {

        //
        // Notify dock that now is a good time to update it's hardware profile.
        //
        PendingEntry->DockInterface->ProfileDepartureSetMode(
            PendingEntry->DockInterface->Context,
            PDS_UPDATE_ON_INTERFACE
            );

        PendingEntry->DockInterface->ProfileDepartureUpdate(
            PendingEntry->DockInterface->Context
            );

        if (PendingEntry->DisplaySafeRemovalDialog) {

            PpNotifyUserModeRemovalSafe(DeviceObject);
            PendingEntry->DisplaySafeRemovalDialog = FALSE;
        }
    }

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    deviceObject = IoGetAttachedDeviceReference(DeviceObject);

    //
    // Allocate an I/O Request Packet (IRP) for this device removal operation.
    //

    irp = IoAllocateIrp( (CCHAR) (deviceObject->StackSize), FALSE );
    if (!irp) {

        PendingEntry->EjectIrp = NULL;

        InitializeListHead( &PendingEntry->Link );

        IopQueuePendingEject(PendingEntry);

        ExInitializeWorkItem( &PendingEntry->WorkItem,
                              IopProcessCompletedEject,
                              PendingEntry);

        ExQueueWorkItem( &PendingEntry->WorkItem, DelayedWorkQueue );

        ObDereferenceObject(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SPECIALIRP_WATERMARK_IRP(irp, IRP_SYSTEM_RESTRICTED);

    //
    // Initialize it to failure.
    //

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location in the packet.  This location
    // will be used to pass the function codes and parameters to the first
    // driver.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_EJECT;

    //
    // Fill in the IRP according to this request.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;
    irp->UserIosb = NULL;
    irp->UserEvent = NULL;

    PendingEntry->EjectIrp = irp;
    PendingEntry->Lock = IRPLOCK_CANCELABLE;

    IopQueuePendingEject(PendingEntry);

    IoSetCompletionRoutine(irp,
                           IopDeviceEjectComplete,
                           PendingEntry,       /* Completion context */
                           TRUE,               /* Invoke on success  */
                           TRUE,               /* Invoke on error    */
                           TRUE                /* Invoke on cancel   */
                           );

    status = IoCallDriver( deviceObject, irp );

    ObDereferenceObject(deviceObject);
    return status;
}

NTSTATUS
IopDeviceEjectComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PPENDING_RELATIONS_LIST_ENTRY entry = (PPENDING_RELATIONS_LIST_ENTRY)Context;
    IRPLOCK oldState;

    UNREFERENCED_PARAMETER( DeviceObject );

    ASSERT(entry->EjectIrp == Irp);

    //
    // Indicate the IRP has been completed. After this point, the IRP may be
    // freed.
    //
    oldState = InterlockedExchange((PLONG) &entry->Lock, IRPLOCK_COMPLETED);

    //
    // Queue a work item to finish up the eject.  We queue a work item because
    // we are probably running at dispatch level in some random context.
    //

    ExInitializeWorkItem( &entry->WorkItem,
                          IopProcessCompletedEject,
                          entry);

    ExQueueWorkItem( &entry->WorkItem, DelayedWorkQueue );

    if (oldState != IRPLOCK_CANCEL_STARTED) {

        //
        // The oldstate was either IRPLOCK_CANCELABLE, or
        // IRPLOCK_CANCEL_COMPLETE.
        //
        IoFreeIrp( Irp );

    } else {

        //
        // The IRP is actively being cancelled. When the cancelling routine
        // tries to change the state, it will find out it owns the IRP cleanup.
        //
        NOTHING;
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

}

VOID
IopCancelPendingEject(
    IN PPENDING_RELATIONS_LIST_ENTRY Entry
    )
/*++

Routine Description:

    This function safely cancels a pending eject. The caller must ensure
    relation list containing the IRP lock is valid throughout the duration
    of this call. The IRP is not gauranteed to have been completed by the
    time this call returns.

Parameters:

    Entry - Relation list containing the eject IRP to cancel.

Return Value:

    None.

--*/
{
    if (Entry->EjectIrp == NULL) {

        return;
    }

    if (InterlockedExchange((PLONG) &Entry->Lock, IRPLOCK_CANCEL_STARTED) == IRPLOCK_CANCELABLE) {

        //
        // We got it to the IRP before it was completed. We can cancel
        // the IRP without fear of losing it, as the completion routine
        // won't let go of the IRP until we say so.
        //
        IoCancelIrp(Entry->EjectIrp);

        //
        // Release the completion routine. If it already got there,
        // then we need to handle post-processing ourselves. Otherwise we got
        // through IoCancelIrp before the IRP completed entirely.
        //
        if (InterlockedExchange((PLONG) &Entry->Lock, IRPLOCK_CANCEL_COMPLETE) == IRPLOCK_COMPLETED) {

            //
            // Free the IRP.
            //
            IoFreeIrp(Entry->EjectIrp);
        }

    } else {

        //
        // The entry was completed, meaning the IRP is gone.
        //
        NOTHING;
    }
}

NTSTATUS
IopRemoveDevice (
    IN PDEVICE_OBJECT TargetDevice,
    IN ULONG IrpMinorCode
    )

/*++

Routine Description:

    This function sends a requested DeviceRemoval related irp to the top level device
    object which roots on TargetDevice.  If there is a VPB associated with the
    TargetDevice, the corresponding filesystem's VDO will be used.  Otherwise
    the irp will be sent directly to the target device/ or its assocated device
    object.

Parameters:

    TargetDevice - Supplies the device object of the device being removed.

    Operation - Specifies the operation requested.
        The following IRP codes are used with IRP_MJ_DEVICE_CHANGE for removing
        devices:
            IRP_MN_QUERY_REMOVE_DEVICE
            IRP_MN_CANCEL_REMOVE_DEVICE
            IRP_MN_REMOVE_DEVICE
            IRP_MN_EJECT
Return Value:

    NTSTATUS code.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;

    BOOLEAN isMountable = FALSE;
    PDEVICE_OBJECT mountedDevice;

    LOCK_MOUNTABLE_DEVICE_CONTEXT lockContext;

    PAGED_CODE();

    ASSERT(IrpMinorCode == IRP_MN_QUERY_REMOVE_DEVICE ||
           IrpMinorCode == IRP_MN_CANCEL_REMOVE_DEVICE ||
           IrpMinorCode == IRP_MN_REMOVE_DEVICE ||
           IrpMinorCode == IRP_MN_SURPRISE_REMOVAL ||
           IrpMinorCode == IRP_MN_EJECT);

    if (IrpMinorCode == IRP_MN_REMOVE_DEVICE ||
        IrpMinorCode == IRP_MN_QUERY_REMOVE_DEVICE) {
        IopUncacheInterfaceInformation(TargetDevice);
    }

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = (UCHAR)IrpMinorCode;

    //
    // Check to see if there's a VPB anywhere in the device stack.  If there
    // is then we'll have to lock the stack. This is to make sure that the VPB
    // does not go away while the operation is in the file system and that no
    // one new can mount on the device if the FS decides to bail out.
    //

    mountedDevice = IopFindMountableDevice(TargetDevice);

    if (mountedDevice != NULL) {

        //
        // This routine will cause any mount operations on the VPB to fail.
        // It will also release the VPB spinlock.
        //

        mountedDevice = IopLockMountedDeviceForRemove(TargetDevice,
                                                      IrpMinorCode,
                                                      &lockContext);

        isMountable = TRUE;

    } else {
        ASSERTMSG("Mass storage device does not have VPB - this is odd",
                  !((TargetDevice->Type == FILE_DEVICE_DISK) ||
                    (TargetDevice->Type == FILE_DEVICE_CD_ROM) ||
                    (TargetDevice->Type == FILE_DEVICE_TAPE) ||
                    (TargetDevice->Type == FILE_DEVICE_VIRTUAL_DISK)));

        mountedDevice = TargetDevice;
    }

    //
    // Make the call and return.
    //

    if (IrpMinorCode == IRP_MN_SURPRISE_REMOVAL || IrpMinorCode == IRP_MN_REMOVE_DEVICE) {
        //
        // if device was not disableable, we cleanup the tree
        // and debug-trace that we surprise-removed a non-disableable device
        //
        PDEVICE_NODE deviceNode = TargetDevice->DeviceObjectExtension->DeviceNode;

        if (deviceNode->UserFlags & DNUF_NOT_DISABLEABLE) {
            //
            // this device was marked as disableable, update the depends
            // before this device disappears
            // (by momentarily marking this node as disableable)
            //
            deviceNode->UserFlags &= ~DNUF_NOT_DISABLEABLE;
            IopDecDisableableDepends(deviceNode);
        }
    }

    status = IopSynchronousCall(mountedDevice, &irpSp, NULL);
    IopDbgPrint((IOP_INFO_LEVEL, "IopRemoveDevice: MinorCode = %d, Status = %08x\n", IrpMinorCode, status));

    if (isMountable) {

        IopUnlockMountedDeviceForRemove(TargetDevice,
                                        IrpMinorCode,
                                        &lockContext);

        //
        // Successful query should follow up with invalidation of all volumes
        // which have been on this device but which are not currently mounted.
        //

        if ((IrpMinorCode == IRP_MN_QUERY_REMOVE_DEVICE || 
                IrpMinorCode == IRP_MN_SURPRISE_REMOVAL) && 
            NT_SUCCESS( status )) {

            status = IopInvalidateVolumesForDevice( TargetDevice );
        }
    }

    if (IrpMinorCode == IRP_MN_REMOVE_DEVICE) {
        ((PDEVICE_NODE)TargetDevice->DeviceObjectExtension->DeviceNode)->Flags &=
            ~(DNF_LEGACY_DRIVER | DNF_REENUMERATE);
    }

    return status;
}


PDEVICE_OBJECT
IopLockMountedDeviceForRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IrpMinorCode,
    OUT PLOCK_MOUNTABLE_DEVICE_CONTEXT Context
    )

/*++

Routine Description:

    This routine will scan up the device stack and mark each unmounted VPB it
    finds with the VPB_REMOVE_PENDING bit (or clear it in the case of cancel)
    and increment (or decrement in the case of cancel) the reference count
    in the VPB.  This is to ensure that no new file system can get mounted on
    the device stack while the remove operation is in place.

    The search will terminate once all the attached device objects have been
    marked, or once a mounted device object has been marked.

Arguments:

    DeviceObject - the PDO we are attempting to remove

    IrpMinorCode - the remove-type operation we are going to perform

    Context - a context block which must be passed in to the unlock operation

Return Value:

    A pointer to the device object stack which the remove request should be
    sent to.  If a mounted file system was found, this will be the lowest
    file system device object in the mounted stack.  Otherwise this will be
    the PDO which was passed in.

--*/

{
    PVPB vpb;

    PDEVICE_OBJECT device = DeviceObject;
    PDEVICE_OBJECT fsDevice = NULL;

    KIRQL oldIrql;

    RtlZeroMemory(Context, sizeof(LOCK_MOUNTABLE_DEVICE_CONTEXT));
    Context->MountedDevice = DeviceObject;

    do {

        //
        // Walk up each device object in the stack.  For each one, if a VPB
        // exists, grab the database resource exclusive followed by the
        // device lock.  Then acquire the Vpb spinlock and perform the
        // appropriate magic on the device object.
        //

        //
        // NOTE - Its unfortunate that the locking order includes grabbing
        // the device specific lock first followed by the global lock.
        //

        if(device->Vpb != NULL) {

            //
            // Grab the device lock.  This will ensure that there are no mount
            // or verify operations in progress.
            //

            KeWaitForSingleObject(&(device->DeviceLock),
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            //
            // Now set the remove pending flag, which will prevent new mounts
            // from occuring on this stack once the current (if existant)
            // filesystem dismounts. Filesystems will preserve the flag across
            // vpb swaps.
            //

            IoAcquireVpbSpinLock(&oldIrql);

            vpb = device->Vpb;

            ASSERT(vpb != NULL);

            switch(IrpMinorCode) {

                case IRP_MN_QUERY_REMOVE_DEVICE:
                case IRP_MN_SURPRISE_REMOVAL:
                case IRP_MN_REMOVE_DEVICE: {

                    vpb->Flags |= VPB_REMOVE_PENDING;
                    break;
                }

                case IRP_MN_CANCEL_REMOVE_DEVICE: {

                    vpb->Flags &= ~VPB_REMOVE_PENDING;
                    break;
                }

                default:
                    break;
            }

            //
            // Note the device object that has the filesystem stack attached.
            // We must remember the vpb we referenced that had the fs because
            // it may be swapped off of the storage device during a dismount
            // operation.
            //

            if(vpb->Flags & VPB_MOUNTED) {

                Context->MountedDevice = device;
                fsDevice = vpb->DeviceObject;
            }

            Context->FsDevice = fsDevice;

            IoReleaseVpbSpinLock(oldIrql);

            //
            // Bump the fs device handle count. This prevent the filesystem filter stack
            // from being torn down while a PNP IRP is in progress.
            //

            if (fsDevice) {
                IopIncrementDeviceObjectHandleCount(fsDevice);
            }

            KeSetEvent(&(device->DeviceLock), IO_NO_INCREMENT, FALSE);

            //
            // Stop if we hit a device with a mounted filesystem.
            //

            if (NULL != fsDevice) {

                //
                // We found and setup a mounted device.  Time to return.
                //

                break;
            }
        }

        oldIrql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
        device = device->AttachedDevice;
        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, oldIrql );

    } while (device != NULL);

    if(fsDevice != NULL) {

        return fsDevice;
    }

    return Context->MountedDevice;
}

VOID
IopUnlockMountedDeviceForRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IrpMinorCode,
    IN PLOCK_MOUNTABLE_DEVICE_CONTEXT Context
    )
{
    PDEVICE_OBJECT device = DeviceObject;

    do {

        KIRQL oldIrql;

        //
        // Walk up each device object in the stack.  For each one, if a VPB
        // exists, grab the database resource exclusive followed by the
        // device lock.  Then acquire the Vpb spinlock and perform the
        // appropriate magic on the device object.
        //

        //
        // NOTE - It's unfortunate that the locking order includes grabing
        // the device specific lock first followed by the global lock.
        //

        if (device->Vpb != NULL) {

            //
            // Grab the device lock.  This will ensure that there are no mount
            // or verify operations in progress, which in turn will ensure
            // that any mounted file system won't go away.
            //

            KeWaitForSingleObject(&(device->DeviceLock),
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            //
            // Now decrement the reference count in the VPB.  If the remove
            // pending flag has been set in the VPB (if this is a QUERY or a
            // REMOVE) then even on a dismount no new file system will be
            // allowed onto the device.
            //

            IoAcquireVpbSpinLock(&oldIrql);

            if (IrpMinorCode == IRP_MN_REMOVE_DEVICE) {

                device->Vpb->Flags &= ~VPB_REMOVE_PENDING;
            }

            IoReleaseVpbSpinLock(oldIrql);

            KeSetEvent(&(device->DeviceLock), IO_NO_INCREMENT, FALSE);
        }

        //
        // Continue up the chain until we know we hit the device the fs
        // mounted on, if any.
        //

        if (Context->MountedDevice == device) {

            //
            // Decrement the fs device handle count. This prevented the filesystem filter stack
            // from being torn down while a PNP IRP is in progress.
            //

            if (Context->FsDevice) {
                IopDecrementDeviceObjectHandleCount(Context->FsDevice);
            }
            break;

        } else {

            oldIrql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
            device = device->AttachedDevice;
            KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, oldIrql );
        }

    } while (device != NULL);

    return;
}


PDEVICE_OBJECT
IopFindMountableDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine will scan up the device stack and find a device which could
    finds with the VPB_REMOVE_PENDING bit (or clear it in the case of cancel)
    and increment (or decrement in the case of cancel) the reference count
    in the VPB.  This is to ensure that no new file system can get mounted on
    the device stack while the remove operation is in place.

    The search will terminate once all the attached device objects have been
    marked, or once a mounted device object has been marked.

Arguments:

    DeviceObject - the PDO we are attempting to remove

    IrpMinorCode - the remove-type operation we are going to perform

    Context - a context block which must be passed in to the unlock operation

Return Value:

    A pointer to the device object stack which the remove request should be
    sent to.  If a mounted file system was found, this will be the lowest
    file system device object in the mounted stack.  Otherwise this will be
    the PDO which was passed in.

--*/

{
    PDEVICE_OBJECT mountableDevice = DeviceObject;

    while (mountableDevice != NULL) {

        if ((mountableDevice->Flags & DO_DEVICE_HAS_NAME) &&
           (mountableDevice->Vpb != NULL)) {

            return mountableDevice;
        }

        mountableDevice = mountableDevice->AttachedDevice;
    }

    return NULL;
}

NTSTATUS
IopQueryDeviceRelations(
    IN DEVICE_RELATION_TYPE Relations,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Synchronous,
    OUT PDEVICE_RELATIONS *DeviceRelations
    )

/*++

Routine Description:

    This routine sends query device relation irp to the specified device object.

Parameters:

    Relations - specifies the type of relation interested.

    DeviceObjet - Supplies the device object of the device being queried.

    AsyncOk - Specifies if we can perform Async QueryDeviceRelations

    DeviceRelations - Supplies a pointer to a variable to receive the returned
                      relation information. This must be freed by the caller.

Return Value:

    NTSTATUS code.

--*/

{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PDEVICE_NODE deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

    UNREFERENCED_PARAMETER (Synchronous);

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;

    //
    // Set the pointer to the resource list
    //

    irpSp.Parameters.QueryDeviceRelations.Type = Relations;

    //
    // Make the call and return.
    //
    status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)DeviceRelations);

    if (Relations == BusRelations) {

        deviceNode->CompletionStatus = status;

        PipSetDevNodeState( deviceNode, DeviceNodeEnumerateCompletion, NULL );

        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
IopQueryDeviceResources (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ResourceType,
    OUT PVOID *Resource,
    OUT ULONG *Length
    )

/*++

Routine Description:

    This routine sends irp to queries resources or resource requirements list
    of the specified device object.

    If the device object is a detected device, its resources will be read from
    registry.  Otherwise, an irp is sent to the bus driver to query its resources.

Parameters:

    DeviceObject - Supplies the device object of the device being queries.

    ResourceType - 0 for device resources and 1 for resource requirements list.

    Resource - Supplies a pointer to a variable to receive the returned resources

    Length - Supplies a pointer to a variable to receive the length of the returned
             resources or resource requirements list.

Return Value:

    NTSTATUS code.

--*/
{
    IO_STACK_LOCATION irpSp;
    PDEVICE_NODE deviceNode;
    NTSTATUS status;
    PIO_RESOURCE_REQUIREMENTS_LIST resReqList, newResources;
    ULONG junk;
    PCM_RESOURCE_LIST cmList;
    PIO_RESOURCE_REQUIREMENTS_LIST filteredList, mergedList;
    BOOLEAN exactMatch;

    PAGED_CODE();

#if DBG

    if ((ResourceType != QUERY_RESOURCE_LIST) &&
        (ResourceType != QUERY_RESOURCE_REQUIREMENTS)) {

        ASSERT(0);
        return STATUS_INVALID_PARAMETER_2;
    }
#endif

    *Resource = NULL;
    *Length = 0;

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    deviceNode = (PDEVICE_NODE) DeviceObject->DeviceObjectExtension->DeviceNode;

    if (ResourceType == QUERY_RESOURCE_LIST) {

        //
        // caller is asked for RESOURCE_LIST.  If this is a madeup device, we will
        // read it from registry.  Otherwise, we ask drivers.
        //

        if (deviceNode->Flags & DNF_MADEUP) {

            status = IopGetDeviceResourcesFromRegistry(
                             DeviceObject,
                             ResourceType,
                             REGISTRY_ALLOC_CONFIG + REGISTRY_FORCED_CONFIG + REGISTRY_BOOT_CONFIG,
                             Resource,
                             Length);
            if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
                status = STATUS_SUCCESS;
            }
            return status;
        } else {
            irpSp.MinorFunction = IRP_MN_QUERY_RESOURCES;
            irpSp.MajorFunction = IRP_MJ_PNP;
            status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)Resource);
            if (status == STATUS_NOT_SUPPORTED) {

                //
                // If driver doesn't implement this request, it
                // doesn't consume any resources.
                //

                *Resource = NULL;
                status = STATUS_SUCCESS;
            }
            if (NT_SUCCESS(status)) {
                *Length = IopDetermineResourceListSize((PCM_RESOURCE_LIST)*Resource);
            }
            return status;
        }
    } else {

        //
        // Caller is asked for resource requirements list.  We will check:
        // if there is a ForcedConfig, it will be converted to resource requirements
        //     list and return.  Otherwise,
        // If there is an OVerrideConfigVector, we will use it as our
        //     FilterConfigVector.  Otherwise we ask driver for the config vector and
        //     use it as our FilterConfigVector.
        //     Finaly, we pass the FilterConfigVector to driver stack to let drivers
        //     filter the requirements.
        //

        status = IopGetDeviceResourcesFromRegistry(
                         DeviceObject,
                         QUERY_RESOURCE_LIST,
                         REGISTRY_FORCED_CONFIG,
                         Resource,
                         &junk);
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
            status = IopGetDeviceResourcesFromRegistry(
                             DeviceObject,
                             QUERY_RESOURCE_REQUIREMENTS,
                             REGISTRY_OVERRIDE_CONFIGVECTOR,
                             &resReqList,
                             &junk);
            if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
                if (deviceNode->Flags & DNF_MADEUP) {
                    status = IopGetDeviceResourcesFromRegistry(
                                     DeviceObject,
                                     QUERY_RESOURCE_REQUIREMENTS,
                                     REGISTRY_BASIC_CONFIGVECTOR,
                                     &resReqList,
                                     &junk);
                    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
                        status = STATUS_SUCCESS;
                        resReqList = NULL;
                    }
                } else {

                    //
                    // We are going to ask the bus driver ...
                    //

                    if (deviceNode->ResourceRequirements) {
                        ASSERT(deviceNode->Flags & DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED);
                        resReqList = ExAllocatePool(PagedPool, deviceNode->ResourceRequirements->ListSize);
                        if (resReqList) {
                            RtlCopyMemory(resReqList,
                                         deviceNode->ResourceRequirements,
                                         deviceNode->ResourceRequirements->ListSize
                                         );
                            status = STATUS_SUCCESS;
                        } else {
                            return STATUS_NO_MEMORY;
                        }
                    } else {
                        status = PpIrpQueryResourceRequirements(DeviceObject, &resReqList);
                        if (status == STATUS_NOT_SUPPORTED) {

                            ASSERT(resReqList == NULL);
                            resReqList = NULL;
                            //
                            // If driver doesn't implement this request, it
                            // doesn't require any resources.
                            //
                            status = STATUS_SUCCESS;
                        }
                    }
                }
                if (!NT_SUCCESS(status)) {
                    return status;
                }
            }

            //
            // For devices with boot config, we need to filter the resource requirements
            // list against boot config.
            //

            status = IopGetDeviceResourcesFromRegistry(
                             DeviceObject,
                             QUERY_RESOURCE_LIST,
                             REGISTRY_BOOT_CONFIG,
                             &cmList,
                             &junk);
            if (NT_SUCCESS(status) &&
                (!cmList || cmList->Count == 0 || cmList->List[0].InterfaceType != PCIBus)) {
                status = IopFilterResourceRequirementsList (
                             resReqList,
                             cmList,
                             &filteredList,
                             &exactMatch);
                if (cmList) {
                    ExFreePool(cmList);
                }
                if (!NT_SUCCESS(status)) {
                    if (resReqList) {
                        ExFreePool(resReqList);
                    }
                    return status;
                } else {

                    //
                    // For non-root-enumerated devices, we merge filtered config with basic config
                    // vectors to form a new res req list.  For root-enumerated devices, we don't
                    // consider Basic config vector.
                    //

                    if (!(deviceNode->Flags & DNF_MADEUP) &&
                        (exactMatch == FALSE || resReqList->AlternativeLists > 1)) {
                        status = IopMergeFilteredResourceRequirementsList (
                                 filteredList,
                                 resReqList,
                                 &mergedList
                                 );
                        if (resReqList) {
                            ExFreePool(resReqList);
                        }
                        if (filteredList) {
                            ExFreePool(filteredList);
                        }
                        if (NT_SUCCESS(status)) {
                            resReqList = mergedList;
                        } else {
                            return status;
                        }
                    } else {
                        if (resReqList) {
                            ExFreePool(resReqList);
                        }
                        resReqList = filteredList;
                    }
                }
            }

        } else {
            ASSERT(NT_SUCCESS(status));

            //
            // We have Forced Config.  Convert it to resource requirements and return it.
            //

            if (*Resource) {
                resReqList = IopCmResourcesToIoResources (0, (PCM_RESOURCE_LIST)*Resource, LCPRI_FORCECONFIG);
                ExFreePool(*Resource);
                if (resReqList) {
                    *Resource = (PVOID)resReqList;
                    *Length = resReqList->ListSize;
                } else {
                    *Resource = NULL;
                    *Length = 0;
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    return status;
                }
            } else {
                resReqList = NULL;
            }
        }

        //
        // If we are here, we have a resource requirements list for drivers to examine ...
        // NOTE: Per Lonny's request, we let drivers filter ForcedConfig
        //

        status = IopFilterResourceRequirementsCall(
            DeviceObject,
            resReqList,
            &newResources
            );

        if (NT_SUCCESS(status)) {
            UNICODE_STRING unicodeName;
            HANDLE handle, handlex;

#if DBG
            if (newResources == NULL && resReqList) {
                DbgPrint("PnpMgr: Non-NULL resource requirements list filtered to NULL\n");
            }
#endif
            if (newResources) {

                *Length = newResources->ListSize;
                ASSERT(*Length);

                //
                // Make our own copy of the allocation. We do this so that the
                // verifier doesn't believe the driver has leaked memory if
                // unloaded.
                //

                *Resource = (PVOID) ExAllocatePool(PagedPool, *Length);
                if (*Resource == NULL) {

                    ExFreePool(newResources);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                RtlCopyMemory(*Resource, newResources, *Length);
                ExFreePool(newResources);

            } else {
                *Length = 0;
                *Resource = NULL;
            }

            //
            // Write filtered res req to registry
            //

            status = IopDeviceObjectToDeviceInstance(DeviceObject, &handlex, KEY_ALL_ACCESS);
            if (NT_SUCCESS(status)) {
                PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
                status = IopOpenRegistryKeyEx( &handle,
                                               handlex,
                                               &unicodeName,
                                               KEY_READ
                                               );
                if (NT_SUCCESS(status)) {
                    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_FILTERED_CONFIG_VECTOR);
                    ZwSetValueKey(handle,
                                  &unicodeName,
                                  TITLE_INDEX_VALUE,
                                  REG_RESOURCE_REQUIREMENTS_LIST,
                                  *Resource,
                                  *Length
                                  );
                    ZwClose(handle);
                    ZwClose(handlex);
                }
            }

        } else {

            //
            // NTRAID #61058-2001/01/05 - ADRIAO
            //     We might want to consider bubbling up
            // non-STATUS_NOT_SUPPORTED failure codes and fail the entire
            // devnode if one is seen.
            //
            ASSERT(status == STATUS_NOT_SUPPORTED);
            *Resource = resReqList;
            if (resReqList) {
                *Length = resReqList->ListSize;
            } else {
                *Length = 0;
            }
        }
        return STATUS_SUCCESS;
    }
}

NTSTATUS
IopQueryResourceHandlerInterface(
    IN RESOURCE_HANDLER_TYPE HandlerType,
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR ResourceType,
    IN OUT PVOID *Interface
    )

/*++

Routine Description:

    This routine queries the specified DeviceObject for the specified ResourceType
    resource translator.

Parameters:

    HandlerType - specifies Arbiter or Translator

    DeviceObject - Supplies a pointer to the Device object to be queried.

    ResourceType - Specifies the desired type of translator.

    Interface - supplies a variable to receive the desired interface.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PINTERFACE interface;
    USHORT size;
    GUID interfaceType;
    PDEVICE_NODE deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

    PAGED_CODE();

    //
    // If this device object is created by pnp mgr for legacy resource allocation,
    // skip it.
    //

    if ((deviceNode->DuplicatePDO == (PDEVICE_OBJECT) DeviceObject->DriverObject) ||
        !(DeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE)) {
        return STATUS_NOT_SUPPORTED;
    }

    switch (HandlerType) {
    case ResourceTranslator:
        size = sizeof(TRANSLATOR_INTERFACE) + 4;  // Pnptest
        //size = sizeof(TRANSLATOR_INTERFACE);
        interfaceType = GUID_TRANSLATOR_INTERFACE_STANDARD;
        break;

    case ResourceArbiter:
        size = sizeof(ARBITER_INTERFACE);
        interfaceType = GUID_ARBITER_INTERFACE_STANDARD;
        break;

    case ResourceLegacyDeviceDetection:
        size = sizeof(LEGACY_DEVICE_DETECTION_INTERFACE);
        interfaceType = GUID_LEGACY_DEVICE_DETECTION_STANDARD;
        break;

    default:
        return STATUS_INVALID_PARAMETER;
    }

    interface = (PINTERFACE) ExAllocatePool(PagedPool, size);
    if (interface == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(interface, size);
    interface->Size = size;

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    //
    // Set the pointer to the resource list
    //

    irpSp.Parameters.QueryInterface.InterfaceType = &interfaceType;
    irpSp.Parameters.QueryInterface.Size = interface->Size;
    irpSp.Parameters.QueryInterface.Version = interface->Version = 0;
    irpSp.Parameters.QueryInterface.Interface = interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = (PVOID) (ULONG_PTR) ResourceType;

    //
    // Make the call and return.
    //

    status = IopSynchronousCall(DeviceObject, &irpSp, NULL);
    if (NT_SUCCESS(status)) {

        switch (HandlerType) {

        case ResourceTranslator:
            if (    ((PTRANSLATOR_INTERFACE)interface)->TranslateResources == NULL ||
                    ((PTRANSLATOR_INTERFACE)interface)->TranslateResourceRequirements == NULL) {

                IopDbgPrint((IOP_ERROR_LEVEL,
                             "!devstack %p returned success for IRP_MN_QUERY_INTERFACE (GUID_TRANSLATOR_INTERFACE_STANDARD) but did not fill in the required data\n",
                             DeviceObject));
                ASSERT(!NT_SUCCESS(status));
                status = STATUS_UNSUCCESSFUL;
            }
            break;

        case ResourceArbiter:
            if (((PARBITER_INTERFACE)interface)->ArbiterHandler == NULL) {

                IopDbgPrint((IOP_ERROR_LEVEL,
                             "!devstack %p returned success for IRP_MN_QUERY_INTERFACE (GUID_ARBITER_INTERFACE_STANDARD) but did not fill in the required data\n",
                             DeviceObject));
                ASSERT(!NT_SUCCESS(status));
                status = STATUS_UNSUCCESSFUL;
            }
            break;

        case ResourceLegacyDeviceDetection:
            if (((PLEGACY_DEVICE_DETECTION_INTERFACE)interface)->LegacyDeviceDetection == NULL) {

                IopDbgPrint((IOP_ERROR_LEVEL,
                             "!devstack %p returned success for IRP_MN_QUERY_INTERFACE (GUID_LEGACY_DEVICE_DETECTION_STANDARD) but did not fill in the required data\n",
                             DeviceObject));
                ASSERT(!NT_SUCCESS(status));
                status = STATUS_UNSUCCESSFUL;
            }
            break;

        default:
            //
            // This should never happen.
            //
            IopDbgPrint((IOP_ERROR_LEVEL,
                         "IopQueryResourceHandlerInterface: Possible stack corruption\n"));
            ASSERT(0);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    if (NT_SUCCESS(status)) {

        *Interface = interface;
     } else {

         ExFreePool(interface);
     }

    return status;
}

NTSTATUS
IopQueryReconfiguration(
    IN UCHAR Request,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine queries the specified DeviceObject for the specified ResourceType
    resource translator.

Parameters:

    HandlerType - specifies Arbiter or Translator

    DeviceObject - Supplies a pointer to the Device object to be queried.

    ResourceType - Specifies the desired type of translator.

    Interface - supplies a variable to receive the desired interface.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PDEVICE_NODE deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

    PAGED_CODE();

    switch (Request) {
    case IRP_MN_QUERY_STOP_DEVICE:

        if (deviceNode->State != DeviceNodeStarted) {

            IopDbgPrint((   IOP_RESOURCE_ERROR_LEVEL,
                            "An attempt made to send IRP_MN_QUERY_STOP_DEVICE to an unstarted device %wZ!\n",
                            &deviceNode->InstancePath));
            ASSERT(0);
            return STATUS_UNSUCCESSFUL;
        }
        break;

    case IRP_MN_STOP_DEVICE:
        //
        // Fall through
        //
        if (deviceNode->State != DeviceNodeQueryStopped) {

            IopDbgPrint((   IOP_RESOURCE_ERROR_LEVEL,
                            "An attempt made to send IRP_MN_STOP_DEVICE to an unqueried device %wZ!\n",
                            &deviceNode->InstancePath));
            ASSERT(0);
            return STATUS_UNSUCCESSFUL;
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        if (    deviceNode->State != DeviceNodeQueryStopped &&
                deviceNode->State != DeviceNodeStarted) {

            IopDbgPrint((   IOP_RESOURCE_ERROR_LEVEL,
                            "An attempt made to send IRP_MN_CANCEL_STOP_DEVICE to an unqueried\\unstarted device %wZ!\n",
                            &deviceNode->InstancePath));
            ASSERT(0);
            return STATUS_UNSUCCESSFUL;
        }
        break;

    default:
        ASSERT(0);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = Request;

    //
    // Make the call and return.
    //

    status = IopSynchronousCall(DeviceObject, &irpSp, NULL);
    return status;
}

NTSTATUS
IopQueryLegacyBusInformation (
    IN PDEVICE_OBJECT DeviceObject,
    OUT LPGUID InterfaceGuid,          OPTIONAL
    OUT INTERFACE_TYPE *InterfaceType, OPTIONAL
    OUT ULONG *BusNumber               OPTIONAL
    )

/*++

Routine Description:

    This routine queries the specified DeviceObject for its legacy bus
    information.

Parameters:

    DeviceObject - The device object to be queried.

    InterfaceGuid = Supplies a pointer to receive the device's interface type
        GUID.

    Interface = Supplies a pointer to receive the device's interface type.

    BusNumber = Supplies a pointer to receive the device's bus number.

Return Value:

    Returns NTSTATUS.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PLEGACY_BUS_INFORMATION busInfo;

    PAGED_CODE();

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_LEGACY_BUS_INFORMATION;

    //
    // Make the call and return.
    //

    status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)&busInfo);
    if (NT_SUCCESS(status)) {

        if (busInfo == NULL) {

            //
            // The device driver LIED to us.  Bad, bad, bad device driver.
            //

            PDEVICE_NODE deviceNode;

            deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode;

            if (deviceNode && deviceNode->Parent && deviceNode->Parent->ServiceName.Buffer) {

                DbgPrint("*** IopQueryLegacyBusInformation - Driver %wZ returned STATUS_SUCCESS\n", &deviceNode->Parent->ServiceName);
                DbgPrint("    for IRP_MN_QUERY_LEGACY_BUS_INFORMATION, and a NULL POINTER.\n");
            }

            ASSERT(busInfo != NULL);

        } else {
            if (ARGUMENT_PRESENT(InterfaceGuid)) {
                *InterfaceGuid = busInfo->BusTypeGuid;
            }
            if (ARGUMENT_PRESENT(InterfaceType)) {
                *InterfaceType = busInfo->LegacyBusType;
            }
            if (ARGUMENT_PRESENT(BusNumber)) {
                *BusNumber = busInfo->BusNumber;
            }
            ExFreePool(busInfo);
        }
    }
    return status;
}

NTSTATUS
IopQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PPNP_DEVICE_STATE DeviceState
    )

/*++

Routine Description:

    This routine sends query device state irp to the specified device object.

Parameters:

    DeviceObjet - Supplies the device object of the device being queried.

Return Value:

    NTSTATUS code.

--*/

{
    IO_STACK_LOCATION irpSp;
    ULONG_PTR stateValue;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_PNP_DEVICE_STATE;

    //
    // Make the call.
    //

    status = IopSynchronousCall(DeviceObject, &irpSp, &stateValue);

    //
    // Now perform the appropriate action based on the returned state
    //

    if (NT_SUCCESS(status)) {

        *DeviceState = (PNP_DEVICE_STATE)stateValue;
    }

    return status;
}


VOID
IopIncDisableableDepends(
    IN OUT PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    Increments the DisableableDepends field of this devicenode
    and potentially every parent device node up the tree
    A parent devicenode is only incremented if the child in question
    is incremented from 0 to 1

Parameters:

    DeviceNode - Supplies the device node where the depends is to be incremented

Return Value:

    none.

--*/
{

    while (DeviceNode != NULL) {

        LONG newval;

        newval = InterlockedIncrement((PLONG)&DeviceNode->DisableableDepends);
        if (newval != 1) {
            //
            // we were already non-disableable, so we don't have to bother parent
            //
            break;
        }

        DeviceNode = DeviceNode ->Parent;

    }

}


VOID
IopDecDisableableDepends(
    IN OUT PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    Decrements the DisableableDepends field of this devicenode
    and potentially every parent device node up the tree
    A parent devicenode is only decremented if the child in question
    is decremented from 1 to 0

Parameters:

    DeviceNode - Supplies the device node where the depends is to be decremented

Return Value:

    none.

--*/
{

    while (DeviceNode != NULL) {

        LONG newval;

        newval = InterlockedDecrement((PLONG)&DeviceNode->DisableableDepends);
        if (newval != 0) {
            //
            // we are still non-disableable, so we don't have to bother parent
            //
            break;
        }

        DeviceNode = DeviceNode ->Parent;

    }

}

NTSTATUS
IopFilterResourceRequirementsCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResReqList OPTIONAL,
    OUT PVOID *Information
    )

/*++

Routine Description:

    This function sends a synchronous filter resource requirements irp to the
    top level device object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies the device object of the device being removed.

    ResReqList   - Supplies a pointer to the resource requirements requiring
                   filtering.

    Information  - Supplies a pointer to a variable that receives the returned
                   information of the irp.

Return Value:

    NTSTATUS code.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK statusBlock;
    KEVENT event;
    NTSTATUS status;
    PULONG_PTR returnInfo = (PULONG_PTR)Information;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    deviceObject = IoGetAttachedDevice(DeviceObject);

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
    if (irp == NULL){

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SPECIALIRP_WATERMARK_IRP(irp, IRP_SYSTEM_RESTRICTED);

    //
    // Initialize it to success. This is a special hack for WDM (ie 9x)
    // compatibility. The driver verifier is in on this one.
    //

    if (ResReqList) {

        irp->IoStatus.Status = statusBlock.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = statusBlock.Information = (ULONG_PTR) ResReqList;

    } else {

        irp->IoStatus.Status = statusBlock.Status = STATUS_NOT_SUPPORTED;
    }

    //
    // Set the pointer to the status block and initialized event.
    //

    KeInitializeEvent( &event,
                       SynchronizationEvent,
                       FALSE );

    irp->UserIosb = &statusBlock;
    irp->UserEvent = &event;

    //
    // Set the address of the current thread
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Queue this irp onto the current thread
    //

    IopQueueThreadIrp(irp);

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Setup the stack location contents
    //

    irpSp->MinorFunction = IRP_MN_FILTER_RESOURCE_REQUIREMENTS;
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList = ResReqList;

    //
    // Call the driver
    //

    status = IoCallDriver(deviceObject, irp);

    PnpIrpStatusTracking(status, IRP_MN_FILTER_RESOURCE_REQUIREMENTS, deviceObject);

    //
    // If a driver returns STATUS_PENDING, we will wait for it to complete
    //

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = statusBlock.Status;
    }

    *returnInfo = (ULONG_PTR) statusBlock.Information;

    return status;
}

NTSTATUS
IopQueryDockRemovalInterface(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PDOCK_INTERFACE *DockInterface
    )

/*++

Routine Description:

    This routine queries the specified DeviceObject for the dock removal
    interface. We use this interface to send pseudo-remove's. We use this
    to solve the removal orderings problem.

Parameters:

    DeviceObject - Supplies a pointer to the Device object to be queried.

    Interface - supplies a variable to receive the desired interface.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PINTERFACE interface;
    USHORT size;
    GUID interfaceType;

    PAGED_CODE();

    size = sizeof(DOCK_INTERFACE);
    interfaceType = GUID_DOCK_INTERFACE;
    interface = (PINTERFACE) ExAllocatePool(PagedPool, size);
    if (interface == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(interface, size);
    interface->Size = size;

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    //
    // Set the pointer to the resource list
    //

    irpSp.Parameters.QueryInterface.InterfaceType = &interfaceType;
    irpSp.Parameters.QueryInterface.Size = interface->Size;
    irpSp.Parameters.QueryInterface.Version = interface->Version = 0;
    irpSp.Parameters.QueryInterface.Interface = interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Make the call and return.
    //

    status = IopSynchronousCall(DeviceObject, &irpSp, NULL);
    if (NT_SUCCESS(status)) {
        *DockInterface = (PDOCK_INTERFACE) interface;
    } else {
        ExFreePool(interface);
    }
    return status;
}

NTSTATUS
PpIrpQueryDeviceText(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_TEXT_TYPE DeviceTextType,
    IN LCID POINTER_ALIGNMENT LocaleId,
    OUT PWCHAR *DeviceText
   )

/*++

Routine Description:

    This routine will issue IRP_MN_QUERY_DEVICE_TEXT to the DeviceObject
    to retrieve its specified device text. If this routine fails,
    DeviceText will be set to NULL.


Arguments:

    DeviceObject - The device object the request should be sent to.

    DeviceTextType - Text type to be queried.

    LocaleId - LCID specifying the locale for the requested text.

    DeviceText - Receives the device text returned by the driver if any.
    Caller is expected to free the storage for DeviceText on success.

Return Value:

    NTSTATUS.

--*/

{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(DeviceTextType == DeviceTextDescription || DeviceTextType == DeviceTextLocationInformation);

    *DeviceText = NULL;

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_TEXT;

    irpSp.Parameters.QueryDeviceText.DeviceTextType = DeviceTextType;
    irpSp.Parameters.QueryDeviceText.LocaleId = LocaleId;

    status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)DeviceText);

    ASSERT(NT_SUCCESS(status) || (*DeviceText == NULL));

    if (NT_SUCCESS(status)) {

        if(*DeviceText == NULL) {

            status = STATUS_NOT_SUPPORTED;
        }
    } else {

        *DeviceText = NULL;
    }

    return status;
}

NTSTATUS
PpIrpQueryResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
   )

/*++

Routine Description:

    This routine will issue IRP_MN_QUERY_RESOURCE_REQUIREMENTS to the
    DeviceObject to retrieve its resource requirements. If this routine
    failes, Requirements will be set to NULL.

Arguments:

    DeviceObject - The device object the request should be sent to.

    Requirements - Receives the requirements returned by the driver if any.
    The caller is expected to free the storage for Requirements on success.

Return Value:

    NTSTATUS.

--*/

{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PAGED_CODE();

    *Requirements = NULL;

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_RESOURCE_REQUIREMENTS;

    status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)Requirements);

    ASSERT(NT_SUCCESS(status) || (*Requirements == NULL));

    if (NT_SUCCESS(status)) {

        if(*Requirements == NULL) {

            status = STATUS_NOT_SUPPORTED;
        }
    } else {

        *Requirements = NULL;
    }

    return status;
}

#if FAULT_INJECT_INVALID_ID
//
// Fault injection for invalid IDs
//
ULONG PiFailQueryID = 0;
#endif

NTSTATUS
PpIrpQueryID(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IDType,
    OUT PWCHAR *ID
    )

/*++

Routine Description:

    This routine will issue IRP_MN_QUERY_ID to the DeviceObject
    to retrieve the specified ID. If this routine fails, ID will
    be set to NULL.

Arguments:

    DeviceObject - The device object the request should be sent to.

    IDType - Type of ID to be queried.

    ID - Receives the ID returned by the driver if any. The caller
    is expected to free the storage for ID on success.

Return Value:

    NTSTATUS.

--*/

{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(IDType == BusQueryDeviceID || IDType == BusQueryInstanceID ||
           IDType == BusQueryHardwareIDs || IDType == BusQueryCompatibleIDs ||
           IDType == BusQueryDeviceSerialNumber);

    *ID = NULL;

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_ID;

    irpSp.Parameters.QueryId.IdType = IDType;

    status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)ID);

    ASSERT(NT_SUCCESS(status) || (*ID == NULL));

    if (NT_SUCCESS(status)) {

        if(*ID == NULL) {

            status = STATUS_NOT_SUPPORTED;
        }
    } else {

        *ID = NULL;
    }

#if FAULT_INJECT_INVALID_ID
    //
    // Fault injection for invalid IDs
    //
    if (*ID){

        static LARGE_INTEGER seed = {0};

        if(seed.LowPart == 0) {

            KeQuerySystemTime(&seed);
        }

        if(PnPBootDriversInitialized && PiFailQueryID && RtlRandom(&seed.LowPart) % 10 > 7) {

            **ID = L',';
        }
    }
#endif

    return status;
}

NTSTATUS
PpIrpQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDEVICE_CAPABILITIES Capabilities
    )

/*++

Routine Description:

    This routine will issue IRP_MN_QUERY_CAPABILITIES to the DeviceObject
    to retrieve the pnp device capabilities.
    Should only be called twice - first from PipProcessNewDeviceNode,
    and second from IopQueryAndSaveDeviceNodeCapabilities, called after
    device is started.
    If you consider calling this, see if DeviceNode->CapabilityFlags does
    what you need instead (accessed via IopDeviceNodeFlagsToCapabilities(...).

Arguments:

    DeviceObject - The device object the request should be sent to.

    Capabilities - A capabilities structure to be filled in by the driver.

Return Value:

    NTSTATUS.

--*/

{
    IO_STACK_LOCATION irpStack;

    PAGED_CODE();

    RtlZeroMemory(Capabilities, sizeof(DEVICE_CAPABILITIES));
    Capabilities->Size = sizeof(DEVICE_CAPABILITIES);
    Capabilities->Version = 1;
    Capabilities->Address = Capabilities->UINumber = (ULONG)-1;

    RtlZeroMemory(&irpStack, sizeof(IO_STACK_LOCATION));

    irpStack.MajorFunction = IRP_MJ_PNP;
    irpStack.MinorFunction = IRP_MN_QUERY_CAPABILITIES;

    irpStack.Parameters.DeviceCapabilities.Capabilities = Capabilities;

    return IopSynchronousCall(DeviceObject, &irpStack, NULL);
}

NTSTATUS
PpIrpQueryBusInformation(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PPNP_BUS_INFORMATION *BusInfo
    )

/*++

Routine Description:

    This routine queries bus information. If this routine fails, BusInfo
    will be set to NULL.

Parameters:

    DeviceObject - Pointer to the Device object to be queried.

    BusInfo - Receives the bus information returned by the driver if any.
    The caller is expected to free the storage for BusInfo on success.

Return Value:

    NTSTATUS.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    *BusInfo = NULL;

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_BUS_INFORMATION;

    status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)BusInfo);
    if (NT_SUCCESS(status)) {

        if (BusInfo == NULL) {
            //
            // The device driver LIED to us.  Bad, bad, bad device driver.
            //
            deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode;
            if (deviceNode && deviceNode->Parent && deviceNode->Parent->ServiceName.Buffer) {

                DbgPrint("*** IopQueryPnpBusInformation - Driver %wZ returned STATUS_SUCCESS\n", &deviceNode->Parent->ServiceName);
                DbgPrint("    for IRP_MN_QUERY_BUS_INFORMATION, and a NULL POINTER.\n");
            }

            ASSERT(BusInfo != NULL);
            status = STATUS_NOT_SUPPORTED;
        }
    } else {

        *BusInfo = NULL;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpirq.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnpirq.c

Abstract:

    Root IRQ arbiter

Author:

    Andy Thornton (andrewth) 04/17/97

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// Constants
//

#define MAX_ULONGLONG           ((ULONGLONG) -1)

//
// Prototypes
//

NTSTATUS
IopIrqInitialize(
    VOID
    );

NTSTATUS
IopIrqUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
IopIrqPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
IopIrqScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
IopIrqUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

NTSTATUS
IopIrqTranslateOrdering(
    OUT PIO_RESOURCE_DESCRIPTOR Target,
    IN PIO_RESOURCE_DESCRIPTOR Source
    );

BOOLEAN
IopIrqFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );


//
// Make everything pageable
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IopIrqInitialize)
#pragma alloc_text(PAGE, IopIrqUnpackRequirement)
#pragma alloc_text(PAGE, IopIrqPackResource)
#pragma alloc_text(PAGE, IopIrqScoreRequirement)
#pragma alloc_text(PAGE, IopIrqUnpackResource)
#pragma alloc_text(PAGE, IopIrqTranslateOrdering)
#pragma alloc_text(PAGE, IopIrqFindSuitableRange)
#endif // ALLOC_PRAGMA

//
// Implementation
//
#if !defined(NO_LEGACY_DRIVERS)
NTSTATUS
IopIrqTranslateOrdering(
    OUT PIO_RESOURCE_DESCRIPTOR Target,
    IN PIO_RESOURCE_DESCRIPTOR Source
    )

/*

Routine Description:

    This routine is called during arbiter initialization to translate the
    orderings.

Parameters:

    Target - Place to put the translated descriptor

    Source - Descriptor to translate

Return Value:

    Status code

*/

{

    KIRQL level;
    KAFFINITY affinity;

    PAGED_CODE();

    //
    // Copy the source to the target
    //

    *Target = *Source;

    if (Source->Type != CmResourceTypeInterrupt) {
        return STATUS_SUCCESS;
    }

    //
    // Translate the vector
    //


    ARB_PRINT(
        2,
        ("Translating Vector 0x%x-0x%x =>",
        Source->u.Interrupt.MinimumVector,
        Source->u.Interrupt.MaximumVector
        ));

    Target->u.Interrupt.MinimumVector =
        HalGetInterruptVector(Isa,
                              0,
                              Source->u.Interrupt.MinimumVector,
                              Source->u.Interrupt.MinimumVector,
                              &level,
                              &affinity
                              );

    if (affinity == 0) {
        ARB_PRINT(2,("Translation failed\n"));
        *Target = *Source;
        return STATUS_SUCCESS;
    }

    Target->u.Interrupt.MaximumVector =
        HalGetInterruptVector(Isa,
                              0,
                              Source->u.Interrupt.MaximumVector,
                              Source->u.Interrupt.MaximumVector,
                              &level,
                              &affinity
                              );

    if (affinity == 0) {
        ARB_PRINT(2,("Translation failed\n"));
        *Target = *Source;
        return STATUS_SUCCESS;
    }

    ARB_PRINT(
        2,
        ("0x%x-0x%x\n",
        Target->u.Interrupt.MinimumVector,
        Target->u.Interrupt.MaximumVector
        ));


    return STATUS_SUCCESS;
}
#endif // NO_LEGACY_DRIVERS

NTSTATUS
IopIrqInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the arbiter

Parameters:

    None

Return Value:

    None

--*/

{

    IopRootIrqArbiter.UnpackRequirement = IopIrqUnpackRequirement;
    IopRootIrqArbiter.PackResource      = IopIrqPackResource;
    IopRootIrqArbiter.UnpackResource    = IopIrqUnpackResource;
    IopRootIrqArbiter.ScoreRequirement  = IopIrqScoreRequirement;

    return ArbInitializeArbiterInstance(&IopRootIrqArbiter,
                                        NULL,     // Indicates ROOT arbiter
                                        CmResourceTypeInterrupt,
                                        L"RootIRQ",
                                        L"Root",
#if defined(NO_LEGACY_DRIVERS)
                                        NULL
#else
                                        IopIrqTranslateOrdering
#endif // NO_LEGACY_DRIVERS
                                        );
}

//
// Arbiter callbacks
//

NTSTATUS
IopIrqUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    ARB_PRINT(2,
                ("Unpacking IRQ requirement %p => 0x%I64x-0x%I64x\n",
                Descriptor,
                (ULONGLONG) Descriptor->u.Interrupt.MinimumVector,
                (ULONGLONG) Descriptor->u.Interrupt.MaximumVector
                ));

    *Minimum = (ULONGLONG) Descriptor->u.Interrupt.MinimumVector;
    *Maximum = (ULONGLONG) Descriptor->u.Interrupt.MaximumVector;
    *Length = 1;
    *Alignment = 1;

    return STATUS_SUCCESS;

}

LONG
IopIrqScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.

Arguments:

    Descriptor - The descriptor describing the requirement to score.


Return Value:

    The score.

--*/

{
    LONG score;

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    score = Descriptor->u.Interrupt.MaximumVector -
        Descriptor->u.Interrupt.MinimumVector + 1;

    ARB_PRINT(2,
                ("Scoring IRQ resource %p => %i\n",
                Descriptor,
                score
                ));

    return score;
}

NTSTATUS
IopIrqPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Start < ((ULONG)-1));
    ASSERT(Requirement);
    ASSERT(Requirement->Type == CmResourceTypeInterrupt);

    ARB_PRINT(2,
                ("Packing IRQ resource %p => 0x%I64x\n",
                Descriptor,
                Start
                ));

    Descriptor->Type = CmResourceTypeInterrupt;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.Interrupt.Vector = (ULONG) Start;
    Descriptor->u.Interrupt.Level = (ULONG) Start;
    Descriptor->u.Interrupt.Affinity = 0xFFFFFFFF;

    return STATUS_SUCCESS;
}

NTSTATUS
IopIrqUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Start - Pointer to where the start value should be unpacked to.

    End - Pointer to where the end value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/


{

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    *Start = Descriptor->u.Interrupt.Vector;
    *Length = 1;

    ARB_PRINT(2,
                ("Unpacking IRQ resource %p => 0x%I64x\n",
                Descriptor,
                *Start
                ));

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpmemio.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnpmemio.c

Abstract:

    Root IO Port and Memory arbiter

Author:

    Andy Thornton (andrewth) 04/17/97

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#define BUGFEST_HACKS

//
// Constants
//

#define MAX_ULONGLONG           ((ULONGLONG) -1)
#define MAX_ALIAS_PORT          0x0000FFFF

typedef struct _PORT_ARBITER_EXTENSION {

    PRTL_RANGE_LIST Aliases;
    PRTL_RANGE_LIST PossibleAliases;
    RTL_RANGE_LIST RangeLists[2];

} PORT_ARBITER_EXTENSION, *PPORT_ARBITER_EXTENSION;

//
// Prototypes
//

VOID
IopPortBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

BOOLEAN
IopPortGetNextAlias(
    ULONG IoDescriptorFlags,
    ULONGLONG LastAlias,
    PULONGLONG NextAlias
    );

BOOLEAN
IopPortFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
IopMemFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );


NTSTATUS
IopGenericUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
IopGenericPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
IopGenericScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
IopGenericUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

BOOLEAN
IopPortIsAliasedRangeAvailable(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
IopMemInitialize(
    VOID
    );

VOID
IopPortAddAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
IopTranslateBusAddress(
    IN PHYSICAL_ADDRESS SourceAddress,
    IN UCHAR SourceResourceType,
    OUT PPHYSICAL_ADDRESS TargetAddress,
    OUT PUCHAR TargetResourceType
    );


//
// Make everything pageable
//

#ifdef ALLOC_PRAGMA

NTSTATUS
IopGenericTranslateOrdering(
    OUT PIO_RESOURCE_DESCRIPTOR Target,
    IN PIO_RESOURCE_DESCRIPTOR Source
    );
#pragma alloc_text(PAGE, IopGenericTranslateOrdering)
#pragma alloc_text(PAGE, IopPortInitialize)
#pragma alloc_text(PAGE, IopMemInitialize)
#pragma alloc_text(PAGE, IopGenericUnpackRequirement)
#pragma alloc_text(PAGE, IopGenericPackResource)
#pragma alloc_text(PAGE, IopGenericScoreRequirement)
#pragma alloc_text(PAGE, IopGenericUnpackResource)
#pragma alloc_text(PAGE, IopPortBacktrackAllocation)
#pragma alloc_text(PAGE, IopPortFindSuitableRange)
#pragma alloc_text(PAGE, IopMemFindSuitableRange)
#pragma alloc_text(PAGE, IopPortGetNextAlias)
#pragma alloc_text(PAGE, IopPortAddAllocation)
#pragma alloc_text(PAGE, IopPortIsAliasedRangeAvailable)
#pragma alloc_text(PAGE, IopTranslateBusAddress)
#endif // ALLOC_PRAGMA


#define ADDRESS_SPACE_MEMORY                0x0
#define ADDRESS_SPACE_PORT                  0x1
#define ADDRESS_SPACE_USER_MEMORY           0x2
#define ADDRESS_SPACE_USER_PORT             0x3
#define ADDRESS_SPACE_DENSE_MEMORY          0x4
#define ADDRESS_SPACE_USER_DENSE_MEMORY     0x6

NTSTATUS
IopTranslateBusAddress(
    IN PHYSICAL_ADDRESS SourceAddress,
    IN UCHAR SourceResourceType,
    OUT PPHYSICAL_ADDRESS TargetAddress,
    OUT PUCHAR TargetResourceType
    )
/*++

Routine Description:

    This routine translates addresses.

Parameters:

    SourceAddress - The address to translate

    ResourceType - The resource type (IO or Memory) we are translaing.  If the
        address space changes from IO->Memory this will be updated.

    TargetAddress - Pointer to where the target should be translated to.

Return Value:

    STATUS_SUCCESS or an error status

--*/

{
    ULONG sourceAddressSpace, targetAddressSpace;
    BOOLEAN translated;

    PAGED_CODE();

    //
    // Select the appropriate address space
    //

    if (SourceResourceType == CmResourceTypeMemory) {
        sourceAddressSpace = ADDRESS_SPACE_MEMORY;
    } else if (SourceResourceType == CmResourceTypePort) {
        sourceAddressSpace = ADDRESS_SPACE_PORT;
    } else {
        return STATUS_INVALID_PARAMETER;
    }

    ARB_PRINT(
        2,
        ("Translating %s address 0x%I64x => ",
        SourceResourceType == CmResourceTypeMemory ? "Memory" : "I/O",
        SourceAddress.QuadPart
       ));

    //
    // HACKHACK Ask the HAL to translate on ISA bus - if we can't then just
    // don't translate because this must be a PCI system so the root arbiters
    // don't do much (Yes it's a steaming hack but it'll work for beta 1)
    //

    targetAddressSpace = sourceAddressSpace;
    translated = HalTranslateBusAddress(
                     Isa,
                     0,
                     SourceAddress,
                     &targetAddressSpace,
                     TargetAddress
                     );

    if (!translated) {
        ARB_PRINT(2,("Translation failed!\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Update the resource type in the target if we have gone from Io to Memory
    //


    //
    // BUBBUG - update the length for IO -> Memory (Dense vs Sparse)
    // I think the answer is dense -> spares is multiply length by 32
    //

    if (targetAddressSpace == ADDRESS_SPACE_MEMORY
    ||  targetAddressSpace == ADDRESS_SPACE_USER_MEMORY
    ||  targetAddressSpace == ADDRESS_SPACE_DENSE_MEMORY
    ||  targetAddressSpace == ADDRESS_SPACE_USER_DENSE_MEMORY) {
        *TargetResourceType = CmResourceTypeMemory;
    } else if (targetAddressSpace == ADDRESS_SPACE_PORT
           ||  targetAddressSpace == ADDRESS_SPACE_USER_PORT) {
        *TargetResourceType = CmResourceTypePort;
    } else {
        ASSERT(0 && "Translation has returned an unknown address space");
        return STATUS_INVALID_PARAMETER;
    }

    ARB_PRINT(
        2,
        ("%s address 0x%I64x\n",
        *TargetResourceType == CmResourceTypeMemory ? "Memory" : "I/O",
        TargetAddress->QuadPart
        ));

    return STATUS_SUCCESS;

}


NTSTATUS
IopGenericTranslateOrdering(
    OUT PIO_RESOURCE_DESCRIPTOR Target,
    IN PIO_RESOURCE_DESCRIPTOR Source
    )

/*

Routine Description:

    This routine is called during arbiter initialization to translate the
    orderings.

Parameters:

    Target - Place to put the translated descriptor

    Source - Descriptor to translate

Return Value:

    STATUS_SUCCESS



*/

{
    NTSTATUS status;
    UCHAR initialResourceType, minResourceType, maxResourceType;
    PAGED_CODE();


    *Target = *Source;

    if (Source->Type != CmResourceTypeMemory
    && Source->Type != CmResourceTypePort) {
        return STATUS_SUCCESS;
    }

    initialResourceType = Source->Type;

    //
    // Translate the minimum
    //

    status = IopTranslateBusAddress(Source->u.Generic.MinimumAddress,
                                    initialResourceType,
                                    &Target->u.Generic.MinimumAddress,
                                    &minResourceType
                                    );

    if (NT_SUCCESS(status)) {

        //
        // Translate the maximum iff we could translate the minimum
        //

        status = IopTranslateBusAddress(Source->u.Generic.MaximumAddress,
                                        initialResourceType,
                                        &Target->u.Generic.MaximumAddress,
                                        &maxResourceType
                                        );

        if (NT_SUCCESS(status)) {
            ASSERT(minResourceType == maxResourceType);
            Target->Type = minResourceType;
            return STATUS_SUCCESS;
        }
    }

    //
    // If we couldn't translate both ends of the range then we want to skip this
    // range - set its type to CmResourceTypeNull
    //

    ASSERT (!NT_SUCCESS(status));
    Target->Type = CmResourceTypeNull;

    return STATUS_SUCCESS;

}

//
// Implementation
//

NTSTATUS
IopPortInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the arbiter

Parameters:

    None

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    // Fill in the non-default action handlers
    //

    IopRootPortArbiter.FindSuitableRange    = IopPortFindSuitableRange;
    IopRootPortArbiter.AddAllocation        = IopPortAddAllocation;
    IopRootPortArbiter.BacktrackAllocation  = IopPortBacktrackAllocation;

    IopRootPortArbiter.UnpackRequirement    = IopGenericUnpackRequirement;
    IopRootPortArbiter.PackResource         = IopGenericPackResource;
    IopRootPortArbiter.UnpackResource       = IopGenericUnpackResource;
    IopRootPortArbiter.ScoreRequirement     = IopGenericScoreRequirement;

    return ArbInitializeArbiterInstance(&IopRootPortArbiter,
                                        NULL,     // Indicates ROOT arbiter
                                        CmResourceTypePort,
                                        L"RootPort",
                                        L"Root",
                                        IopGenericTranslateOrdering
                                        );

}

NTSTATUS
IopMemInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the arbiter

Parameters:

    None

Return Value:

    None

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    IopRootMemArbiter.UnpackRequirement = IopGenericUnpackRequirement;
    IopRootMemArbiter.PackResource      = IopGenericPackResource;
    IopRootMemArbiter.UnpackResource    = IopGenericUnpackResource;
    IopRootMemArbiter.ScoreRequirement  = IopGenericScoreRequirement;

    IopRootMemArbiter.FindSuitableRange    = IopMemFindSuitableRange;

    status = ArbInitializeArbiterInstance(&IopRootMemArbiter,
                                          NULL,     // Indicates ROOT arbiter
                                          CmResourceTypeMemory,
                                          L"RootMemory",
                                          L"Root",
                                          IopGenericTranslateOrdering
                                          );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Allocate the first page of physical memory as the firmware uses it and
    // doesn't report it as so Mm doesn't reuse it.
    //

    status = RtlAddRange(IopRootMemArbiter.Allocation,
                         0,
                         PAGE_SIZE - 1,
                         0, // RangeAttributes
                         0, // Flags
                         NULL,
                         NULL
                         );
    return status;

}


//
// Arbiter callbacks
//

NTSTATUS
IopGenericUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypePort
           || Descriptor->Type == CmResourceTypeMemory);


    *Minimum = (ULONGLONG) Descriptor->u.Generic.MinimumAddress.QuadPart;
    *Maximum = (ULONGLONG) Descriptor->u.Generic.MaximumAddress.QuadPart;
    *Length = Descriptor->u.Generic.Length;
    *Alignment = Descriptor->u.Generic.Alignment;

    //
    // Fix the broken hardware that reports 0 alignment
    //

    if (*Alignment == 0) {
        *Alignment = 1;
    }

    //
    // Fix broken INF's that report they support 24bit memory > 0xFFFFFF
    //

    if (Descriptor->Type == CmResourceTypeMemory
    && Descriptor->Flags & CM_RESOURCE_MEMORY_24
    && Descriptor->u.Memory.MaximumAddress.QuadPart > 0xFFFFFF) {
        *Maximum = 0xFFFFFF;
    }

    ARB_PRINT(2,
                ("Unpacking %s requirement %p => 0x%I64x-0x%I64x length 0x%x alignment 0x%x\n",
                Descriptor->Type == CmResourceTypePort ? "port" : "memory",
                Descriptor,
                *Minimum,
                *Maximum,
                *Length,
                *Alignment
                ));

    return STATUS_SUCCESS;

}

LONG
IopGenericScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.

Arguments:

    Descriptor - The descriptor describing the requirement to score.


Return Value:

    The score.

--*/

{
    LONG score;
    ULONGLONG start, end;
    LONGLONG bigscore;
    ULONG alignment;

    PAGED_CODE();

#define MAX_SCORE MAXLONG

    ASSERT(Descriptor);
    ASSERT((Descriptor->Type == CmResourceTypePort) ||
           (Descriptor->Type == CmResourceTypeMemory));

    alignment = Descriptor->u.Generic.Alignment;

    //
    // Fix the broken hardware that reports 0 alignment
    // Since this is not a PCI device, set the alignment to 1.
    //
    //

    if (alignment == 0) {
        alignment = 1;
    }



    start = ALIGN_ADDRESS_UP(
                Descriptor->u.Generic.MinimumAddress.QuadPart,
                alignment
                );

    end = Descriptor->u.Generic.MaximumAddress.QuadPart;

    //
    // The score is the number of possible allocations that could be made
    // given the alignment and length constraints
    //

    bigscore = (((end - Descriptor->u.Generic.Length + 1) - start)
                    / alignment) + 1;

    score = (LONG)bigscore;
    if (bigscore < 0) {
        score = -1;
    } else if (bigscore > MAX_SCORE) {
        score = MAX_SCORE;
    }

    ARB_PRINT(2,
                ("Scoring port resource %p(0x%I64x-0x%I64x) => %i\n",
                Descriptor->Type == CmResourceTypePort ? "port" : "memory",
                Descriptor,
                Descriptor->u.Generic.MinimumAddress.QuadPart,
                end,
                score
                ));

    return score;
}

NTSTATUS
IopGenericPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{

    PAGED_CODE();
    ASSERT(Descriptor);
    ASSERT(Requirement);
    ASSERT(Requirement->Type == CmResourceTypePort
           || Requirement->Type == CmResourceTypeMemory);

    Descriptor->Type = Requirement->Type;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.Generic.Start.QuadPart = Start;
    Descriptor->u.Generic.Length = Requirement->u.Generic.Length;

    ARB_PRINT(2,
                ("Packing %s resource %p => 0x%I64x length 0x%x\n",
                Descriptor->Type == CmResourceTypePort ? "port" : "memory",
                Descriptor,
                Descriptor->u.Port.Start.QuadPart,
                Descriptor->u.Port.Length
                ));

    return STATUS_SUCCESS;
}

NTSTATUS
IopGenericUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.

Arguments:

    Descriptor - The descriptor describing the resource to unpack.

    Start - Pointer to where the start value should be unpacked to.

    Length - Pointer to where the length value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{

    PAGED_CODE();
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypePort
           || Descriptor->Type == CmResourceTypeMemory);

    *Start = Descriptor->u.Generic.Start.QuadPart;
    *Length = Descriptor->u.Generic.Length;

    ARB_PRINT(2,
                ("Unpacking %s resource %p => 0x%I64x Length 0x%x\n",
                Descriptor->Type == CmResourceTypePort ? "port" : "memory",
                Descriptor,
                *Start,
                *Length
                ));

    return STATUS_SUCCESS;

}
#if 0
NTSTATUS
IopPortRetestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )

/*++

Routine Description:

    This providesa port specific implementation of the RetestAllocation action
    which takes into account ISA aliases and adds them where appropriate.
    It walks the arbitration list and updates the possible allocation to reflect
    the allocation entries of the list.  For these entries to be valid
    TestAllocation must have been performed on this arbitration list.

Parameters:

    Arbiter - The arbiter instance data for the arbiter being called.

    ArbitrationList - A list of ARBITER_LIST_ENTRY entries which contain the
        requirements and associated devices.  TestAllocation for this arbiter
        should have been called on this list.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    PARBITER_LIST_ENTRY current;
    PIO_RESOURCE_DESCRIPTOR alternative;
    ULONGLONG start;
    ULONG length;

    PAGED_CODE();

    //
    // Copy the current allocation and reserved
    //

    ARB_PRINT(3, ("Retest: Copy current allocation\n"));
    status = RtlCopyRangeList(Arbiter->PossibleAllocation, Arbiter->Allocation);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Free all the resources currently allocated to all the devices we
    // are arbitrating for
    //

    FOR_ALL_IN_LIST(ARBITER_LIST_ENTRY, ArbitrationList, current) {

        ARB_PRINT(2, ("Retest: Delete 0x%08x's resources\n", current->PhysicalDeviceObject));

        status = RtlDeleteOwnersRanges(Arbiter->PossibleAllocation,
                                       (PVOID) current->PhysicalDeviceObject
                                       );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }
    }

    //
    // Copy the previous allocation into the range list
    //

    FOR_ALL_IN_LIST(ARBITER_LIST_ENTRY, ArbitrationList, current) {

        ASSERT(current->Assignment);

        status = Arbiter->UnpackResource(current->Assignment,
                                         &start,
                                         &length
                                         );

        ASSERT(NT_SUCCESS(status));

        //
        // If we had a requirement for length 0 then that will be seen as
        // end == start - 1 here so don't attempt to add the range - it will
        // fail!
        //

        if (length != 0) {

            status = RtlAddRange(
                Arbiter->PossibleAllocation,
                start,
                start + length - 1,
                0,
                RTL_RANGE_LIST_ADD_IF_CONFLICT +
                    (current->Assignment->ShareDisposition == CmResourceShareShared ?
                        RTL_RANGE_LIST_ADD_SHARED : 0),
                NULL,
                current->PhysicalDeviceObject
                );

            ASSERT(NT_SUCCESS(status));

            //
            // Retireve the alternative from which the assignment was chosen from
            // then
            //

            alternative = current->SelectedAlternative;

            //
            // Add the aliases
            //

            if (alternative->Flags & CM_RESOURCE_PORT_10_BIT_DECODE
            || alternative->Flags & CM_RESOURCE_PORT_12_BIT_DECODE) {

                ULONGLONG alias = start;
                BOOLEAN shared = current->Assignment->ShareDisposition ==
                                     CmResourceShareShared;

                ARB_PRINT(3, ("Adding aliases\n"));

                while (IopPortGetNextAlias(alternative->Flags,
                                           alias,
                                           &alias)) {

                    status = RtlAddRange(
                                 Arbiter->PossibleAllocation,
                                 alias,
                                 alias + length - 1,
                                 ARBITER_RANGE_ALIAS,
                                 RTL_RANGE_LIST_ADD_IF_CONFLICT +
                                    (shared ? RTL_RANGE_LIST_SHARED_OK : 0),
                                 NULL,
                                 current->PhysicalDeviceObject
                                 );

                    //
                    // We have already checked if these ranges are available
                    // so we should not fail...
                    //

                    ASSERT(NT_SUCCESS(status));
                }
            }
        }
    }

    return status;

cleanup:

    RtlFreeRangeList(Arbiter->PossibleAllocation);
    return status;
}
#endif
VOID
IopPortBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )

/*++

Routine Description:

    This routine is called from AllocateEntry if the possible solution
    (State->Start - State->End) does not allow us to allocate resources to
    the rest of the devices being considered.  It deletes the ranges that were
    added to Arbiter->PossibleAllocation by AddAllocation including those
    associated with ISA aliases.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/


{

    NTSTATUS status;
    ULONGLONG alias = State->Start;

    PAGED_CODE();

    //
    // Delete the aliases
    //

    ARB_PRINT(2, ("\t\tDeleting aliases\n"));

    while (IopPortGetNextAlias(State->CurrentAlternative->Flags,
                               alias,
                               &alias)) {

        status = RtlDeleteRange(
                     Arbiter->PossibleAllocation,
                     alias,
                     alias + State->CurrentAlternative->Length - 1,
                     State->Entry->PhysicalDeviceObject
                     );

        //
        // We should not fail...
        //

        ASSERT(NT_SUCCESS(status));
    }

    //
    // Now call the original function to delete the base range
    //

    ArbBacktrackAllocation(Arbiter, State);

}


BOOLEAN
IopPortFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry once we have decided where we want
    to allocate from.  It tries to find a free range that matches the
    requirements in State while restricting its possible solutions to the range
    State->Start to State->CurrentMaximum.  On success State->Start and
    State->End represent this range.  Conflicts with ISA aliases are considered.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if we found a range, FALSE otherwise.

--*/
{
    NTSTATUS status;
    UCHAR userFlagsMask = 0;

    PAGED_CODE();

    //
    // If we are asking for zero ports then trivially succeed with the minimum
    // value
    //

    if (State->CurrentAlternative->Length == 0) {
        State->End = State->Start;
        return TRUE;
    }

    //
    // For legacy requests from IoAssignResources (directly or by way of
    // HalAssignSlotResources) or IoReportResourceUsage we consider preallocated
    // resources to be available for backward compatibility reasons.
    //
    // If we are allocating a devices boot config then we consider all other
    // boot configs to be available.
    //

    if (State->Entry->RequestSource == ArbiterRequestLegacyReported
        || State->Entry->RequestSource == ArbiterRequestLegacyAssigned
        || State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {

        userFlagsMask = ARBITER_RANGE_BOOT_ALLOCATED;
    }

    //
    // Try to satisfy the request
    //

    while (State->CurrentMinimum <= State->CurrentMaximum) {

        //
        // Select the first free alternative from the current alternative
        //

        status = RtlFindRange(
                     Arbiter->PossibleAllocation,
                     State->CurrentMinimum,
                     State->CurrentMaximum,
                     State->CurrentAlternative->Length,
                     State->CurrentAlternative->Alignment,
                     State->CurrentAlternative->Flags &
                        ARBITER_ALTERNATIVE_FLAG_SHARED ?
                            RTL_RANGE_LIST_SHARED_OK : 0,
                     userFlagsMask,
                     Arbiter->ConflictCallbackContext,
                     Arbiter->ConflictCallback,
                     &State->Start
                     );


        //
        // Did we find a range and if not can we override any conflict
        //
        if (NT_SUCCESS(status)
        || Arbiter->OverrideConflict(Arbiter, State)) {

            State->End = State->Start + State->CurrentAlternative->Length - 1;

            //
            // Check if the aliases are available
            //
            if (IopPortIsAliasedRangeAvailable(Arbiter, State)) {

                //
                // We found a suitable range so return
                //

                return TRUE;

            } else {

                //
                // This range's aliases arn't available so try the next range
                //

                State->Start += State->CurrentAlternative->Length;

                continue;
            }
        } else {

            //
            // We couldn't find a base range
            //

            break;
        }
    }

    return FALSE;
}



BOOLEAN
IopPortGetNextAlias(
    ULONG IoDescriptorFlags,
    ULONGLONG LastAlias,
    PULONGLONG NextAlias
    )
/*++

Routine Description:

    This routine calculates the next alias of an IO port up to MAX_ALIAS_PORT.

Arguments:

    IoDescriptorFlags - The flags from the requirement descriptor indicating the
        type of alias if any.

    LastAlias - The alias previous to this one.

    NextAlias - Point to where the next alias should be returned

Return Value:

    TRUE if we found an alias, FALSE otherwise.

--*/

{
    ULONGLONG next;

    PAGED_CODE();

    if (IoDescriptorFlags & CM_RESOURCE_PORT_10_BIT_DECODE) {
        next = LastAlias + (((ULONGLONG)1) << 10);
    } else if (IoDescriptorFlags & CM_RESOURCE_PORT_12_BIT_DECODE) {
        next = LastAlias + (((ULONGLONG)1) << 12);
    } else {

        //
        // There are no aliases
        //

        return FALSE;
    }

    //
    // Check that we are below the maximum aliased port
    //

    if (next > MAX_ALIAS_PORT) {
        return FALSE;
    } else {
        *NextAlias = next;
        return TRUE;
    }
}


VOID
IopPortAddAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    This routine is called from AllocateEntry once we have found a possible
    solution (State->Start - State->End).  It adds the ranges that will not be
    available if we commit to this solution to Arbiter->PossibleAllocation.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    ULONGLONG alias;

    PAGED_CODE();

    ASSERT(Arbiter);
    ASSERT(State);

    status = RtlAddRange(Arbiter->PossibleAllocation,
                 State->Start,
                 State->End,
                 State->RangeAttributes,
                 RTL_RANGE_LIST_ADD_IF_CONFLICT +
                    (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED
                        ? RTL_RANGE_LIST_ADD_SHARED : 0),
                 NULL,
                 State->Entry->PhysicalDeviceObject
                 );

    ASSERT(NT_SUCCESS(status));

    //
    // Add any aliases
    //

    alias = State->Start;
    ARB_PRINT(2, ("Adding aliases\n"));

    while (IopPortGetNextAlias(State->CurrentAlternative->Descriptor->Flags,
                             alias,
                             &alias)) {

        status = RtlAddRange(Arbiter->PossibleAllocation,
                     alias,
                     alias + State->CurrentAlternative->Length - 1,
                     (UCHAR) (State->RangeAttributes | ARBITER_RANGE_ALIAS),
                     RTL_RANGE_LIST_ADD_IF_CONFLICT +
                        (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED
                            ? RTL_RANGE_LIST_ADD_SHARED : 0),
                     NULL,
                     State->Entry->PhysicalDeviceObject
                     );

        //
        // We have already checked if these ranges are available
        // so we should not fail...
        //

        ASSERT(NT_SUCCESS(status));
    }
}


BOOLEAN
IopPortIsAliasedRangeAvailable(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    This routine determines if the range (Start-(Length-1)) is available taking
    into account any aliases.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if the range is available, FALSE otherwise.

--*/

{
    //
    // NTRAID #61146-2000/03/31-andrewth Root IO arbiter don't deal with aliases
    //
    // This is only an issue on machines where the root arbiters are called upon
    // to arbitrated aliased ranges - this means a pure ISA machine with no PCI.
    // I hope we won't support these soon and the root arbiters can be made a
    // lot worse.
    //

#if defined(BUGFEST_HACKS)

    UNREFERENCED_PARAMETER( Arbiter );
    UNREFERENCED_PARAMETER( State );

    PAGED_CODE();

    //
    // For the purposes of the Bug^H^H^HPlugFest don't mind is aliases conflict
    // with any devices but still add them...
    //
    return TRUE;
#else
    NTSTATUS status;
    ULONGLONG alias = State->Start;
    BOOLEAN aliasAvailable;
    UCHAR userFlagsMask = 0;

    PAGED_CODE();

    //
    // For legacy requests from IoAssignResources (directly or by way of
    // HalAssignSlotResources) or IoReportResourceUsage we consider preallocated
    // resources to be available for backward compatibility reasons.
    //
    if (State->Entry->RequestSource == ArbiterRequestLegacyReported
        || State->Entry->RequestSource == ArbiterRequestLegacyAssigned) {

        userFlagsMask |= ARBITER_RANGE_BOOT_ALLOCATED;
    }

    while (IopPortGetNextAlias(State->CurrentAlternative->Descriptor->Flags,
                             alias,
                             &alias)) {

        status = RtlIsRangeAvailable(
                     Arbiter->PossibleAllocation,
                     alias,
                     alias + State->CurrentAlternative->Length - 1,
                     State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED ?
                        RTL_RANGE_LIST_SHARED_OK : 0,
                     userFlagsMask,
                     Arbiter->ConflictCallbackContext,
                     Arbiter->ConflictCallback,
                     &aliasAvailable
                     );

        ASSERT(NT_SUCCESS(status));

        if (!aliasAvailable) {

            ARBITER_ALLOCATION_STATE tempState;

            //
            // Check if we allow this conflict by calling OverrideConflict -
            // we will need to falsify ourselves an allocation state first
            //

            RtlCopyMemory(&tempState, State, sizeof(ARBITER_ALLOCATION_STATE));

            tempState.CurrentMinimum = alias;
            tempState.CurrentMaximum = alias + State->CurrentAlternative->Length - 1;

            if (Arbiter->OverrideConflict(Arbiter, &tempState)) {
                //
                // We decided this conflict was ok so contine checking the rest
                // of the aliases
                //

                continue;

            }

            //
            // An alias isn't available - get another possibility
            //

            ARB_PRINT(2,
                        ("\t\tAlias 0x%x-0x%x not available\n",
                        alias,
                        alias + State->CurrentAlternative->Length - 1
                        ));

            return FALSE;
        }
    }

    return TRUE;
#endif
}

BOOLEAN
IopMemFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry once we have decided where we want
    to allocate from.  It tries to find a free range that matches the
    requirements in State while restricting its possible solutions to the range
    State->Start to State->CurrentMaximum.  On success State->Start and
    State->End represent this range.  Conflicts between boot configs are allowed

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if we found a range, FALSE otherwise.

--*/
{
    //
    // If this was a boot config then consider other boot configs to be
    // available
    //

    if (State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {
        State->RangeAvailableAttributes |= ARBITER_RANGE_BOOT_ALLOCATED;
    }

    //
    // Do the default thing
    //

    return ArbFindSuitableRange(Arbiter, State);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpmgrp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpmgrp.h

Abstract:

    This module contains the private structure definitions and APIs used by
    the NT I/O system.

Author:

    Nar Ganapathy (narg) 1-Jan-1999


Revision History:

--*/

#ifndef _PNPMGRP_
#define _PNPMGRP_

#ifndef FAR
#define FAR
#endif

#define RTL_USE_AVL_TABLES 0

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4706)   // assignment within conditional expression

#include "ntos.h"
#include "zwapi.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "windef.h"
#include "winerror.h"

#include "strsafe.h"

#include "iopcmn.h"

#include "ppmacro.h"
#include "ppdebug.h"
#include "pnpi.h"
#include "arbiter.h"
#include "dockintf.h"
#include "pnprlist.h"

#include "ioverifier.h"
#include "iofileutil.h"
#include "pnpiop.h"
#include "pphotswap.h"
#include "ppprofile.h"
#include "pphandle.h"
#include "ppvutil.h"
#include "ppdrvdb.h"
#include "ppcddb.h"

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'  pP')
#undef ExAllocatePoolWithQuota
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'  pP')
#endif


#endif // _PNPMGRP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpmap.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnpmap.c

Abstract:

    This module contains the code that translates the device info returned from
    the PnP BIOS into root enumerated devices.

Author:

    Robert B. Nelson (RobertN) 22-Sep-1997

Environment:

    Kernel mode

Revision History :

--*/

#include "pnpmgrp.h"
#pragma hdrstop
#include "pnpcvrt.h"
#include "pbios.h"

#if defined(_X86_)

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'PpaM')
#endif

#define DECODE_FLAGS ( CM_RESOURCE_PORT_10_BIT_DECODE | \
                       CM_RESOURCE_PORT_12_BIT_DECODE | \
                       CM_RESOURCE_PORT_16_BIT_DECODE | \
                       CM_RESOURCE_PORT_POSITIVE_DECODE )

#if UMODETEST
#define MULTIFUNCTION_KEY_NAME L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\TestSystem\\MultifunctionAdapter"
#define ENUMROOT_KEY_NAME L"\\Registry\\Machine\\System\\TestControlSet\\Enum\\Root"
#else
#define MULTIFUNCTION_KEY_NAME L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter"
#define ENUMROOT_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum\\Root"
#endif

#define BIOSINFO_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Biosinfo\\PNPBios"
#define DISABLENODES_VALUE_NAME L"DisableNodes"
#define DECODEINFO_VALUE_NAME L"FullDecodeChipsetOverride"

#define INSTANCE_ID_PREFIX      L"PnPBIOS_"

#define DEFAULT_STRING_SIZE     80
#define DEFAULT_VALUE_SIZE      80

#define DEFAULT_DEVICE_DESCRIPTION  L"Unknown device class"


#define EXCLUSION_ENTRY(a)  { a, sizeof(a) - sizeof(UNICODE_NULL) }

typedef struct  _EXCLUDED_PNPNODE  {
    PWCHAR  Id;
    ULONG   IdLength;
} EXCLUDED_PNPNODE, *PEXCLUDED_PNPNODE;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const EXCLUDED_PNPNODE ExcludedDevices[] =  {
    EXCLUSION_ENTRY(L"*PNP03"),     // Keyboards
    EXCLUSION_ENTRY(L"*PNP0A"),     // PCI Busses
    EXCLUSION_ENTRY(L"*PNP0E"),     // PCMCIA Busses
    EXCLUSION_ENTRY(L"*PNP0F"),     // Mice
    EXCLUSION_ENTRY(L"*IBM3780"),   // IBM Trackpoint Mouse
    EXCLUSION_ENTRY(L"*IBM3781")    // IBM Trackpoint Mouse
};

#define EXCLUDED_DEVICES_COUNT  (sizeof(ExcludedDevices) / sizeof(ExcludedDevices[0]))

const EXCLUDED_PNPNODE ExcludeIfDisabled[] = {
    EXCLUSION_ENTRY(L"*PNP0C01"),   // Motherboard resources
    EXCLUSION_ENTRY(L"*PNP0C02")    // Motherboard resources
};

#define EXCLUDE_DISABLED_COUNT  (sizeof(ExcludeIfDisabled) / sizeof(ExcludeIfDisabled[0]))

typedef struct _CLASSDATA {
    ULONG   Value;
    PWCHAR  Description;
} CLASSDATA;

const CLASSDATA Class1Descriptions[] = {
    { 0x0000, L"SCSI Controller" },
    { 0x0100, L"IDE Controller" },
    { 0x0200, L"Floppy Controller" },
    { 0x0300, L"IPI Controller" },
    { 0x0400, L"RAID Controller" },
    { 0x8000, L"Other Mass Storage" }
};

const CLASSDATA Class2Descriptions[] = {
    { 0x0000, L"Ethernet" },
    { 0x0100, L"Token ring" },
    { 0x0200, L"FDDI" },
    { 0x0300, L"ATM" },
    { 0x8000, L"Other network" }
};

const CLASSDATA Class3Descriptions[] = {
    { 0x0000, L"VGA" },
    { 0x0001, L"SVGA" },
    { 0x0100, L"XGA" },
    { 0x8000, L"Other display" }
};

const CLASSDATA Class4Descriptions[] = {
    { 0x0000, L"Video device" },
    { 0x0100, L"Audio device" },
    { 0x8000, L"Other multimedia" }
};

const CLASSDATA Class5Descriptions[] = {
    { 0x0000, L"RAM memory" },
    { 0x0100, L"Flash memory" },
    { 0x8000, L"Other memory" }
};

const CLASSDATA Class6Descriptions[] = {
    { 0x0000, L"HOST / PCI" },
    { 0x0100, L"PCI / ISA" },
    { 0x0200, L"PCI / EISA" },
    { 0x0300, L"PCI / MCA" },
    { 0x0400, L"PCI / PCI" },
    { 0x0500, L"PCI / PCMCIA" },
    { 0x0600, L"NuBus" },
    { 0x0700, L"Cardbus" },
    { 0x8000, L"Other bridge" }
};

const CLASSDATA Class7Descriptions[] = {
    { 0x0000, L"XT Serial" },
    { 0x0001, L"16450" },
    { 0x0002, L"16550" },
    { 0x0100, L"Parallel output only" },
    { 0x0101, L"BiDi Parallel" },
    { 0x0102, L"ECP 1.x parallel" },
    { 0x8000, L"Other comm" }
};

const CLASSDATA Class8Descriptions[] = {
    { 0x0000, L"Generic 8259" },
    { 0x0001, L"ISA PIC" },
    { 0x0002, L"EISA PIC" },
    { 0x0100, L"Generic 8237" },
    { 0x0101, L"ISA DMA" },
    { 0x0102, L"EISA DMA" },
    { 0x0200, L"Generic 8254" },
    { 0x0201, L"ISA timer" },
    { 0x0202, L"EISA timer" },
    { 0x0300, L"Generic RTC" },
    { 0x0301, L"ISA RTC" },
    { 0x8000, L"Other system device" }
};

const CLASSDATA Class9Descriptions[] = {
    { 0x0000, L"Keyboard" },
    { 0x0100, L"Digitizer" },
    { 0x0200, L"Mouse" },
    { 0x8000, L"Other input" }
};

const CLASSDATA Class10Descriptions[] = {
    { 0x0000, L"Generic dock" },
    { 0x8000, L"Other dock" },
};

const CLASSDATA Class11Descriptions[] = {
    { 0x0000, L"386" },
    { 0x0100, L"486" },
    { 0x0200, L"Pentium" },
    { 0x1000, L"Alpha" },
    { 0x4000, L"Co-processor" }
};

const CLASSDATA Class12Descriptions[] = {
    { 0x0000, L"Firewire" },
    { 0x0100, L"Access bus" },
    { 0x0200, L"SSA" },
    { 0x8000, L"Other serial bus" }
};

#define CLASSLIST_ENTRY(a)   { a, sizeof(a) / sizeof(a[0]) }

struct _CLASS_DESCRIPTIONS_LIST  {

    CLASSDATA const*Descriptions;
    ULONG      Count;

}   const ClassDescriptionsList[] =  {
    { NULL, 0 },
    CLASSLIST_ENTRY( Class1Descriptions ),
    CLASSLIST_ENTRY( Class2Descriptions ),
    CLASSLIST_ENTRY( Class3Descriptions ),
    CLASSLIST_ENTRY( Class4Descriptions ),
    CLASSLIST_ENTRY( Class5Descriptions ),
    CLASSLIST_ENTRY( Class6Descriptions ),
    CLASSLIST_ENTRY( Class7Descriptions ),
    CLASSLIST_ENTRY( Class8Descriptions ),
    CLASSLIST_ENTRY( Class9Descriptions ),
    CLASSLIST_ENTRY( Class10Descriptions ),
    CLASSLIST_ENTRY( Class11Descriptions ),
    CLASSLIST_ENTRY( Class12Descriptions )

};

#define CLASSLIST_COUNT  ( sizeof(ClassDescriptionsList) / sizeof(ClassDescriptionsList[0]) )

typedef struct _BIOS_DEVNODE_INFO  {
    WCHAR   ProductId[10];  // '*' + 7 char ID + NUL + NUL for REG_MULTI_SZ
    UCHAR   Handle;         // BIOS Node # / Handle
    UCHAR   TypeCode[3];
    USHORT  Attributes;
    PWSTR   Replaces;       // Instance ID of Root enumerated device being replaced

    PCM_RESOURCE_LIST               BootConfig;
    ULONG                           BootConfigLength;
    PIO_RESOURCE_REQUIREMENTS_LIST  BasicConfig;
    ULONG                           BasicConfigLength;
    PWSTR                           CompatibleIDs;  // REG_MULTI_SZ list of compatible IDs (including ProductId)
    ULONG                           CompatibleIDsLength;
    BOOLEAN                         FirmwareDisabled; // determined that it's disabled by firmware

}   BIOS_DEVNODE_INFO, *PBIOS_DEVNODE_INFO;

NTSTATUS
PbBiosResourcesToNtResources (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PUCHAR *BiosData,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *ReturnedList,
    OUT PULONG ReturnedLength
    );

VOID
PnPBiosExpandProductId(
    PUCHAR CompressedId,
    PWCHAR ProductIDStr
    );

NTSTATUS
PnPBiosIoResourceListToCmResourceList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResourceList,
    OUT PCM_RESOURCE_LIST *CmResourceList,
    OUT ULONG *CmResourceListSize
    );

NTSTATUS
PnPBiosExtractCompatibleIDs(
    IN  PUCHAR *DevNodeData,
    IN  ULONG DevNodeDataLength,
    OUT PWSTR *CompatibleIDs,
    OUT ULONG *CompatibleIDsLength
    );

NTSTATUS
PnPBiosTranslateInfo(
    IN VOID *BiosInfo,
    IN ULONG BiosInfoLength,
    OUT PBIOS_DEVNODE_INFO *DevNodeInfoList,
    OUT ULONG *NumberNodes
    );

LONG
PnPBiosFindMatchingDevNode(
    IN PWCHAR MapperName,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    );

NTSTATUS
PnPBiosEliminateDupes(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    );

PWCHAR
PnPBiosGetDescription(
    IN PBIOS_DEVNODE_INFO DevNodeInfoEntry
    );

NTSTATUS
PnPBiosWriteInfo(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    );

VOID
PnPBiosCopyIoDecode(
    IN HANDLE EnumRootKey,
    IN PBIOS_DEVNODE_INFO DevNodeInfo
    );

NTSTATUS
PnPBiosFreeDevNodeInfo(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    );

NTSTATUS
PnPBiosCheckForHardwareDisabled(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResourceList,
    IN OUT PBOOLEAN Disabled
    );

BOOLEAN
PnPBiosCheckForExclusion(
    IN EXCLUDED_PNPNODE const* ExclusionArray,
    IN ULONG ExclusionCount,
    IN PWCHAR PnpDeviceName,
    IN PWCHAR PnpCompatIds
    );

VOID
PpFilterNtResource (
    IN PWCHAR PnpDeviceName,
    PIO_RESOURCE_REQUIREMENTS_LIST ResReqList
    );

NTSTATUS
ComPortDBAdd(
    IN  HANDLE  DeviceParamKey,
    IN  PWSTR   PortName
    );

BOOLEAN
PnPBiosIgnoreNode (
    PWCHAR PnpID,
    PWCHAR excludeNodes
    );
PKEY_VALUE_FULL_INFORMATION
PnPGetBiosInfoValue(
    PWCHAR ValueName
    );
NTSTATUS
PnPBiosCopyDeviceParamKey(
    IN HANDLE EnumRootKey,
    IN PWCHAR SourcePath,
    IN PWCHAR DestinationPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PnPBiosExpandProductId)
#pragma alloc_text(INIT, PnPBiosIgnoreNode)
#pragma alloc_text(INIT, PnPGetBiosInfoValue)
#pragma alloc_text(INIT, PnPBiosIoResourceListToCmResourceList)
#pragma alloc_text(INIT, PnPBiosExtractCompatibleIDs)
#pragma alloc_text(INIT, PnPBiosTranslateInfo)
#pragma alloc_text(INIT, PnPBiosFindMatchingDevNode)
#pragma alloc_text(INIT, PnPBiosEliminateDupes)
#pragma alloc_text(INIT, PnPBiosGetDescription)
#pragma alloc_text(INIT, PnPBiosCopyDeviceParamKey)
#pragma alloc_text(INIT, PnPBiosWriteInfo)
#pragma alloc_text(INIT, PnPBiosCopyIoDecode)
#pragma alloc_text(INIT, PnPBiosFreeDevNodeInfo)
#pragma alloc_text(INIT, PnPBiosCheckForHardwareDisabled)
#pragma alloc_text(INIT, PnPBiosCheckForExclusion)
#pragma alloc_text(INIT, PnPBiosMapper)
#pragma alloc_text(INIT, PpFilterNtResource)
#pragma alloc_text(PAGE, PnPBiosGetBiosInfo)
#endif

NTSTATUS
PnPBiosGetBiosInfo(
    OUT PVOID *BiosInfo,
    OUT ULONG *BiosInfoLength
    )
/*++

Routine Description:

    This function retrieves the PnP BIOS info accumulated by NTDETECT.COM and
    placed in the registry.

Arguments:

    BiosInfo - Set to a dynamically allocated block of information retrieved
        from the PnP BIOS by NTDETECT.  This block should be freed using
        ExFreePool.  The contents of the block are the PnP BIOS
        Installation Check Structure followed by the DevNode Structures reported
        by the BIOS.  The detailed format is documented in the PnP BIOS spec.

    BiosInfoLength - Length of the block whose address is stored in BiosInfo.


Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    UNICODE_STRING                  multifunctionKeyName, biosKeyName, valueName;
    HANDLE                          multifunctionKey = NULL, biosKey = NULL;
    PKEY_BASIC_INFORMATION          keyBasicInfo = NULL;
    ULONG                           keyBasicInfoLength;
    PKEY_VALUE_PARTIAL_INFORMATION  valueInfo = NULL;
    ULONG                           valueInfoLength;
    ULONG                           returnedLength;
    PCM_FULL_RESOURCE_DESCRIPTOR    biosValue;
    ULONG                           index;
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    //
    // The PnP BIOS info is written to one of the subkeys under
    // MULTIFUNCTION_KEY_NAME.  The appropriate key is determined by
    // enumerating the subkeys and using the first one which has a value named
    // "Identifier" that is "PNP BIOS".
    //
    PiWstrToUnicodeString(&multifunctionKeyName, MULTIFUNCTION_KEY_NAME);
    status = IopOpenRegistryKeyEx( &multifunctionKey,
                                   NULL,
                                   &multifunctionKeyName,
                                   KEY_READ
                                   );
    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                    "Could not open %S, status = %8.8X\n",
                    MULTIFUNCTION_KEY_NAME,
                    status) );

        return STATUS_UNSUCCESSFUL;
    }
    //
    // Allocate memory for key names returned from ZwEnumerateKey and values
    // returned from ZwQueryValueKey.
    //
    keyBasicInfoLength = sizeof(KEY_BASIC_INFORMATION) + DEFAULT_STRING_SIZE;
    keyBasicInfo = ExAllocatePool(PagedPool, keyBasicInfoLength + sizeof(UNICODE_NULL));

    if (keyBasicInfo == NULL)  {

        ZwClose( multifunctionKey );

        return STATUS_NO_MEMORY;
    }

    valueInfoLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + DEFAULT_STRING_SIZE;
    valueInfo = ExAllocatePool(PagedPool, valueInfoLength);

    if (valueInfo == NULL)  {

        ExFreePool( keyBasicInfo );

        ZwClose( multifunctionKey );

        return STATUS_NO_MEMORY;
    }
    //
    // Enumerate each key under HKLM\HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter
    // to locate the one representing the PnP BIOS information.
    //
    for (index = 0; ; index++) {

        status = ZwEnumerateKey( multifunctionKey,   // handle of key to enumerate
                                 index,              // index of subkey to enumerate
                                 KeyBasicInformation,
                                 keyBasicInfo,
                                 keyBasicInfoLength,
                                 &returnedLength);

        if (!NT_SUCCESS(status)) {

            if (status != STATUS_NO_MORE_ENTRIES)  {

                IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                            "Could not enumerate under key %S, status = %8.8X\n",
                            MULTIFUNCTION_KEY_NAME,
                            status) );
            }

            break;
        }

        //
        // We found a subkey, NUL terminate the name and open the subkey.
        //
        keyBasicInfo->Name[ keyBasicInfo->NameLength / 2 ] = L'\0';

        RtlInitUnicodeString(&biosKeyName, keyBasicInfo->Name);
        status = IopOpenRegistryKeyEx( &biosKey,
                                       multifunctionKey,
                                       &biosKeyName,
                                       KEY_READ
                                       );

        if (!NT_SUCCESS(status)) {

            IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                        "Could not open registry key %S\\%S, status = %8.8X\n",
                        MULTIFUNCTION_KEY_NAME,
                        keyBasicInfo->Name,
                        status) );
            break;
        }

        //
        // Now we need to check the Identifier value in the subkey to see if
        // it is PNP BIOS.
        //
        PiWstrToUnicodeString(&valueName, L"Identifier");
        status = ZwQueryValueKey( biosKey,
                                  &valueName,
                                  KeyValuePartialInformation,
                                  valueInfo,
                                  valueInfoLength,
                                  &returnedLength);


        // lets see if its the PNP BIOS identifier
        if (NT_SUCCESS(status)) {

            if (wcscmp((PWSTR)valueInfo->Data, L"PNP BIOS") == 0) {

                //
                // We found the PnP BIOS subkey, retrieve the BIOS info which
                // is stored in the "Configuration Data" value.
                //
                // We'll start off with our default value buffer and increase
                // its size if necessary.
                //

                PiWstrToUnicodeString(&valueName, L"Configuration Data");

                status = ZwQueryValueKey( biosKey,
                                          &valueName,
                                          KeyValuePartialInformation,
                                          valueInfo,
                                          valueInfoLength,
                                          &returnedLength);

                if (!NT_SUCCESS(status)) {

                    if (status == STATUS_BUFFER_TOO_SMALL || status == STATUS_BUFFER_OVERFLOW) {

                        //
                        // The default buffer was too small, free it and reallocate
                        // it to the required size.
                        //
                        ExFreePool( valueInfo );

                        valueInfoLength = returnedLength;
                        valueInfo = ExAllocatePool( PagedPool, valueInfoLength );

                        if (valueInfo != NULL)  {

                            status = ZwQueryValueKey( biosKey,
                                                      &valueName,
                                                      KeyValuePartialInformation,
                                                      valueInfo,
                                                      valueInfoLength,
                                                      &returnedLength );
                        } else {

                            status = STATUS_NO_MEMORY;
                        }
                    }
                }

                if (NT_SUCCESS(status)) {

                    //
                    // We now have the PnP BIOS data but it is buried inside
                    // the resource structures.  Do some consistency checks and
                    // then extract it into its own buffer.
                    //

                    ASSERT(valueInfo->Type == REG_FULL_RESOURCE_DESCRIPTOR);

                    biosValue = (PCM_FULL_RESOURCE_DESCRIPTOR)valueInfo->Data;

                    //
                    // The WMI folks added another list so we should search for
                    // the PnPBIOS one, but for now the BIOS one is always
                    // first.
                    //

                    *BiosInfoLength = biosValue->PartialResourceList.PartialDescriptors[0].u.DeviceSpecificData.DataSize;
                    *BiosInfo = ExAllocatePool(PagedPool, *BiosInfoLength);

                    if (*BiosInfo != NULL) {

                        RtlCopyMemory( *BiosInfo,
                                       &biosValue->PartialResourceList.PartialDescriptors[1],
                                       *BiosInfoLength );

                        status = STATUS_SUCCESS;

                    } else {

                        *BiosInfoLength = 0;

                        status = STATUS_NO_MEMORY;
                    }

                } else {

                    IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                                "Error retrieving %S\\%S\\Configuration Data, status = %8.8X\n",
                                MULTIFUNCTION_KEY_NAME,
                                keyBasicInfo->Name,
                                status) );
                }

                //
                // We found the PnP BIOS entry, so close the key handle and
                // return.
                //

                ZwClose(biosKey);

                break;
            }
        }

        //
        // That wasn't it so close this handle and try the next subkey.
        //
        ZwClose(biosKey);
    }

    //
    // Cleanup the dynamically allocated temporary buffers.
    //

    if (valueInfo != NULL) {

        ExFreePool(valueInfo);
    }

    if (keyBasicInfo != NULL) {

        ExFreePool(keyBasicInfo);
    }

    ZwClose(multifunctionKey);

    return status;
}

VOID
PnPBiosExpandProductId(
    PUCHAR CompressedId,
    PWCHAR ProductIDStr
    )
/*++

Routine Description:

    This function expands a PnP Device ID from the 4 byte compressed form into
    an 7 character unicode string.  The string is then NUL terminated.

Arguments:

    CompressedId - Pointer to the 4 byte compressed Device ID as defined in the
        PnP Specification.

    ProductIDStr - Pointer to the 16 byte buffer in which the unicode string
        version of the ID is placed.


Return Value:

    NONE.

--*/
{
    static const CHAR HexDigits[] = "0123456789ABCDEF";

    ProductIDStr[0] = (CompressedId[0] >> 2) + 0x40;
    ProductIDStr[1] = (((CompressedId[0] & 0x03) << 3) | (CompressedId[1] >> 5)) + 0x40;
    ProductIDStr[2] = (CompressedId[1] & 0x1f) + 0x40;
    ProductIDStr[3] = HexDigits[CompressedId[2] >> 4];
    ProductIDStr[4] = HexDigits[CompressedId[2] & 0x0F];
    ProductIDStr[5] = HexDigits[CompressedId[3] >> 4];
    ProductIDStr[6] = HexDigits[CompressedId[3] & 0x0F];
    ProductIDStr[7] = 0x00;
}

BOOLEAN
PnPBiosIgnoreNode (
    PWCHAR PnpID,
    PWCHAR excludeNodes
    )
{
    BOOLEAN bRet=FALSE;
    ULONG   keyLen;
    PWCHAR  pTmp;

    ASSERT(excludeNodes);

    //
    //excludeNodes is multi-sz, so walk through each one and check it.
    //
    pTmp=excludeNodes;

    while (*pTmp != '\0') {

        keyLen = (ULONG)wcslen(pTmp);

        if (RtlCompareMemory(PnpID,pTmp,keyLen*sizeof (WCHAR)) == keyLen*sizeof (WCHAR)) {

            bRet=TRUE;
            break;
        }
        pTmp = pTmp + keyLen + 1;

    }


    return bRet;
}

PKEY_VALUE_FULL_INFORMATION
PnPGetBiosInfoValue(
    PWCHAR ValueName
    )
{
    UNICODE_STRING biosKeyName;
    HANDLE  biosKey;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION info;

    info = NULL;
    PiWstrToUnicodeString(&biosKeyName, BIOSINFO_KEY_NAME);
    status = IopOpenRegistryKeyEx( &biosKey,
                                   NULL,
                                   &biosKeyName,
                                   KEY_READ
                                   );

    if (NT_SUCCESS(status)) {

        IopGetRegistryValue (biosKey, ValueName, &info);
        ZwClose (biosKey);
    }

    return info;
}

BOOLEAN
PnPBiosCheckForExclusion(
    IN EXCLUDED_PNPNODE const*Exclusions,
    IN ULONG  ExclusionCount,
    IN PWCHAR PnpDeviceName,
    IN PWCHAR PnpCompatIds
    )
{
    PWCHAR idPtr;
    ULONG exclusionIndex;

    for (exclusionIndex = 0; exclusionIndex < ExclusionCount; exclusionIndex++) {

        idPtr = PnpDeviceName;

        if (RtlCompareMemory( idPtr,
                              Exclusions[ exclusionIndex ].Id,
                              Exclusions[ exclusionIndex ].IdLength) != Exclusions[ exclusionIndex ].IdLength )  {

            idPtr = PnpCompatIds;

            if (idPtr != NULL)  {

                while (*idPtr != '\0') {

                    if (RtlCompareMemory( idPtr,
                                          Exclusions[ exclusionIndex ].Id,
                                          Exclusions[ exclusionIndex ].IdLength) == Exclusions[ exclusionIndex ].IdLength )  {

                        break;
                    }

                    idPtr += 9;
                }

                if (*idPtr == '\0') {

                    idPtr = NULL;
                }
            }
        }

        if (idPtr != NULL)  {

            break;
        }
    }

    if (exclusionIndex < ExclusionCount) {

        return TRUE;
    }

    return FALSE;
}

NTSTATUS
PnPBiosIoResourceListToCmResourceList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResourceList,
    OUT PCM_RESOURCE_LIST *CmResourceList,
    OUT ULONG *CmResourceListSize
    )
/*++

Routine Description:

    Converts an IO_RESOURCE_REQUIREMENTS_LIST into a CM_RESOURCE_LIST.  This
    routine is used to convert the list of resources currently being used by a
    device into a form suitable for writing to the BootConfig registry value.

Arguments:

    IoResourceList - Pointer to the input list.

    CmResourceList - Pointer to a PCM_RESOURCE_LIST which is set to the
        dynamically allocated and filled in using the data from IoResourceList.

    CmResourceListSize - Pointer to a variable which is set to the size in bytes
        of the dynamically allocated *CmResourceList.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    PCM_PARTIAL_RESOURCE_LIST       partialList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;
    PIO_RESOURCE_DESCRIPTOR         ioDescriptor;
    ULONG                           descIndex;

    //
    // Since this routine is only used to translate the allocated resources
    // returned by the PnP BIOS, we can assume that there is only 1 alternative
    // list
    //

    ASSERT(IoResourceList->AlternativeLists == 1);

    //
    // Calculate the size of the translated list and allocate memory for it.
    //
    *CmResourceListSize = sizeof(CM_RESOURCE_LIST) +
                          (IoResourceList->AlternativeLists - 1) * sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                          (IoResourceList->List[0].Count - 1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

    *CmResourceList = ExAllocatePool( PagedPool, *CmResourceListSize );

    if (*CmResourceList == NULL) {

        *CmResourceListSize = 0;

        return STATUS_NO_MEMORY;
    }

    //
    // Copy the header info from the requirements list to the resource list.
    //
    (*CmResourceList)->Count = 1;

    (*CmResourceList)->List[ 0 ].InterfaceType = IoResourceList->InterfaceType;
    (*CmResourceList)->List[ 0 ].BusNumber = IoResourceList->BusNumber;

    partialList = &(*CmResourceList)->List[ 0 ].PartialResourceList;

    partialList->Version = IoResourceList->List[ 0 ].Version;
    partialList->Revision = IoResourceList->List[ 0 ].Revision;
    partialList->Count = 0;

    //
    // Translate each resource descriptor, currently we only handle ports,
    // memory, interrupts, and dma.  The current implementation of the routine
    // which converts from ISA PnP Resource data to IO_RESOURCE_REQUIREMENTS
    // won't generate any other descriptor types given the data returned from
    // the BIOS.
    //

    partialDescriptor = &partialList->PartialDescriptors[ 0 ];
    for (descIndex = 0; descIndex < IoResourceList->List[ 0 ].Count; descIndex++) {

        ioDescriptor = &IoResourceList->List[ 0 ].Descriptors[ descIndex ];

        switch (ioDescriptor->Type) {

        case CmResourceTypePort:
            partialDescriptor->u.Port.Start = ioDescriptor->u.Port.MinimumAddress;
            partialDescriptor->u.Port.Length = ioDescriptor->u.Port.Length;
            break;

        case CmResourceTypeInterrupt:
            if (ioDescriptor->u.Interrupt.MinimumVector == (ULONG)2 ) {
                *CmResourceListSize -= sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                continue;
            }
            partialDescriptor->u.Interrupt.Level = ioDescriptor->u.Interrupt.MinimumVector;
            partialDescriptor->u.Interrupt.Vector = ioDescriptor->u.Interrupt.MinimumVector;
            partialDescriptor->u.Interrupt.Affinity = ~0ul;
            break;

        case CmResourceTypeMemory:
            partialDescriptor->u.Memory.Start = ioDescriptor->u.Memory.MinimumAddress;
            partialDescriptor->u.Memory.Length = ioDescriptor->u.Memory.Length;
            break;

        case CmResourceTypeDma:
            partialDescriptor->u.Dma.Channel = ioDescriptor->u.Dma.MinimumChannel;
            partialDescriptor->u.Dma.Port = 0;
            partialDescriptor->u.Dma.Reserved1 = 0;
            break;

        default:
            IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                        "Unexpected ResourceType (%d) in I/O Descriptor\n",
                        ioDescriptor->Type) );
            break;
        }

        partialDescriptor->Type = ioDescriptor->Type;
        partialDescriptor->ShareDisposition = ioDescriptor->ShareDisposition;
        partialDescriptor->Flags = ioDescriptor->Flags;
        partialDescriptor++;

        partialList->Count++;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PnPBiosExtractCompatibleIDs(
    IN  PUCHAR *DevNodeData,
    IN  ULONG DevNodeDataLength,
    OUT PWSTR *CompatibleIDs,
    OUT ULONG *CompatibleIDsLength
    )
{
    PWCHAR  idPtr;
    PUCHAR  currentPtr, endPtr;
    UCHAR   tagName;
    ULONG   increment;
    ULONG   compatibleCount;

    endPtr = &(*DevNodeData)[DevNodeDataLength];

    compatibleCount = 0;

    for (currentPtr = *DevNodeData; currentPtr < endPtr; currentPtr += increment) {

        tagName = *currentPtr;

        if (tagName == TAG_COMPLETE_END)  {

            break;
        }

        //
        // Determine the size of the BIOS resource descriptor
        //

        if (!(tagName & LARGE_RESOURCE_TAG)) {
            increment = (USHORT)(tagName & SMALL_TAG_SIZE_MASK);
            increment++;     // length of small tag
            tagName &= SMALL_TAG_MASK;
        } else {
            increment = *(USHORT UNALIGNED *)(&currentPtr[1]);
            increment += 3;     // length of large tag
        }

        if (tagName == TAG_COMPATIBLE_ID) {

            compatibleCount++;
        }
    }

    if (compatibleCount == 0) {
        *CompatibleIDs = NULL;
        *CompatibleIDsLength = 0;

        return STATUS_SUCCESS;
    }

    *CompatibleIDsLength = (compatibleCount * 9 + 1) * sizeof(WCHAR);
    *CompatibleIDs = ExAllocatePool(PagedPool, *CompatibleIDsLength);

    if (*CompatibleIDs == NULL)  {

        *CompatibleIDsLength = 0;
        return STATUS_NO_MEMORY;
    }

    idPtr = *CompatibleIDs;

    for (currentPtr = *DevNodeData; currentPtr < endPtr; currentPtr += increment) {

        tagName = *currentPtr;

        if (tagName == TAG_COMPLETE_END)  {

            break;
        }

        //
        // Determine the size of the BIOS resource descriptor
        //

        if (!(tagName & LARGE_RESOURCE_TAG)) {
            increment = (USHORT)(tagName & SMALL_TAG_SIZE_MASK);
            increment++;     // length of small tag
            tagName &= SMALL_TAG_MASK;
        } else {
            increment = *(USHORT UNALIGNED *)(&currentPtr[1]);
            increment += 3;     // length of large tag
        }

        if (tagName == TAG_COMPATIBLE_ID) {

            *idPtr = '*';
            PnPBiosExpandProductId(&currentPtr[1], &idPtr[1]);
            idPtr += 9;
        }
    }

    *idPtr++ = '\0';  // Extra NUL for REG_MULTI_SZ
    *CompatibleIDsLength = (ULONG)(idPtr - *CompatibleIDs) * sizeof(WCHAR);

    return STATUS_SUCCESS;
}

NTSTATUS
PnPBiosTranslateInfo(
    IN VOID *BiosInfo,
    IN ULONG BiosInfoLength,
    OUT PBIOS_DEVNODE_INFO *DevNodeInfoList,
    OUT ULONG *NumberNodes
    )
/*++

Routine Description:

    Translates the devnode info retrieved from the BIOS.

Arguments:

    BiosInfo - The PnP BIOS Installation Check Structure followed by the
        DevNode Structures reported by the BIOS.  The detailed format is
        documented in the PnP BIOS spec.

    BiosInfoLength - Length in bytes of the block whose address is stored in
        BiosInfo.

    DevNodeInfoList - Dynamically allocated array of BIOS_DEVNODE_INFO
        structures, one for each device reported by the BIOS.  The information
        supplied by the BIOS: device ID, type, current resources, and supported
        configurations is converted into a more useful format.  For example the
        current resource allocation is converted from ISA PnP descriptors into
        an IO_RESOURCE_REQUIREMENTS_LIST and then into a CM_RESOURCE_LIST for
        storing into the BootConfig registry value.

    NumberNodes - Number of BIOS_DEVNODE_INFO elements pointed to by
        DevNodeInfoList.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    PCM_PNP_BIOS_INSTALLATION_CHECK biosInstallCheck;
    PCM_PNP_BIOS_DEVICE_NODE        devNodeHeader;
    PBIOS_DEVNODE_INFO              devNodeInfo;

    PIO_RESOURCE_REQUIREMENTS_LIST  tempResReqList;

    PUCHAR                          currentPtr;
    LONG                            lengthRemaining;

    LONG                            remainingNodeLength;

    ULONG                           numNodes;
    ULONG                           nodeIndex;
    PUCHAR                          configPtr;
    ULONG                           configListLength;
    NTSTATUS                        status;
    ULONG                           convertFlags = 0;
    PKEY_VALUE_FULL_INFORMATION     fullValueInfo;

    //
    // Make sure the data is at least large enough to hold the BIOS Installation
    // Check structure and check that the PnP signature is correct.
    //
    if (BiosInfoLength < sizeof(CM_PNP_BIOS_INSTALLATION_CHECK)) {

        IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                    "BiosInfoLength (%d) is smaller than sizeof(PNPBIOS_INSTALLATION_CHECK) (%d)\n",
                    BiosInfoLength,
                    sizeof(CM_PNP_BIOS_INSTALLATION_CHECK)) );

        return STATUS_UNSUCCESSFUL;
    }

    biosInstallCheck = (PCM_PNP_BIOS_INSTALLATION_CHECK)BiosInfo;

    if (biosInstallCheck->Signature[0] != '$' ||
        biosInstallCheck->Signature[1] != 'P' ||
        biosInstallCheck->Signature[2] != 'n' ||
        biosInstallCheck->Signature[3] != 'P') {

        return STATUS_UNSUCCESSFUL;
    }
    //
    // First scan the data and count the devnodes to determine the size of our
    // allocated data structures.
    //
    currentPtr = (PUCHAR)BiosInfo + biosInstallCheck->Length;
    lengthRemaining = BiosInfoLength - biosInstallCheck->Length;

    for (numNodes = 0; lengthRemaining > sizeof(CM_PNP_BIOS_DEVICE_NODE); numNodes++) {

        devNodeHeader = (PCM_PNP_BIOS_DEVICE_NODE)currentPtr;

        if (devNodeHeader->Size > lengthRemaining) {

            IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                        "Node # %d, invalid size (%d), length remaining (%d)\n",
                        devNodeHeader->Node,
                        devNodeHeader->Size,
                        lengthRemaining) );

            return STATUS_UNSUCCESSFUL;
        }

        currentPtr += devNodeHeader->Size;
        lengthRemaining -= devNodeHeader->Size;
    }

    //
    // Allocate the list of translated devnodes.
    //
    devNodeInfo = ExAllocatePool( PagedPool, numNodes * sizeof(BIOS_DEVNODE_INFO) );

    if (devNodeInfo == NULL) {

        return STATUS_NO_MEMORY;
    }

    //
    // Should we force all fixed IO decodes to 16bit?
    //
    fullValueInfo = PnPGetBiosInfoValue(DECODEINFO_VALUE_NAME);
    if (fullValueInfo) {

        if (fullValueInfo->Type == REG_DWORD && 
            fullValueInfo->DataLength == sizeof(ULONG) && 
            *(PULONG)((PUCHAR)fullValueInfo + fullValueInfo->DataOffset)) {

            convertFlags |= PPCONVERTFLAG_FORCE_FIXED_IO_16BIT_DECODE;
        }
        ExFreePool(fullValueInfo);
    }
    //
    // Now scan the data translating the info for each devnode into an entry in
    // our devNodeInfo array.
    //

    currentPtr = (PUCHAR)BiosInfo + biosInstallCheck->Length;
    lengthRemaining = BiosInfoLength - biosInstallCheck->Length;

    for (nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {

        devNodeHeader = (PCM_PNP_BIOS_DEVICE_NODE)currentPtr;

        if (devNodeHeader->Size > lengthRemaining) {

            IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                        "Node # %d, invalid size (%d), length remaining (%d)\n",
                        devNodeHeader->Node,
                        devNodeHeader->Size,
                        lengthRemaining) );

            break;
        }

        //
        // We use the Product ID field as the DeviceID key name.  So we insert
        // an initial asterisk so we don't have to copy and mangle it later.
        //
        devNodeInfo[nodeIndex].ProductId[0] = '*';

        PnPBiosExpandProductId((PUCHAR)&devNodeHeader->ProductId, &devNodeInfo[nodeIndex].ProductId[1]);

        devNodeInfo[nodeIndex].ProductId[9] = '\0';  // Extra NUL for REG_MULTI_SZ

        //
        // The handle is used as part of the Instance ID
        devNodeInfo[nodeIndex].Handle = devNodeHeader->Node;

        //
        // The type code and attributes aren't currently used but are copied
        // for completeness.
        //
        RtlCopyMemory( &devNodeInfo[nodeIndex].TypeCode,
                       devNodeHeader->DeviceType,
                       sizeof(devNodeInfo[nodeIndex].TypeCode) );

        devNodeInfo[nodeIndex].Attributes = devNodeHeader->DeviceAttributes;

        //
        // Replaces will eventually be set to the path of the Firmware
        // Enumerated devnode which duplicates this one (if a duplicate exists).
        //
        devNodeInfo[nodeIndex].Replaces = NULL;

        //
        // CompatibleIDs will be set to the list of compatible IDs.
        //
        devNodeInfo[nodeIndex].CompatibleIDs = NULL;

        //
        // Convert the allocated resources from ISA PnP resource descriptor
        // format to an IO_RESOURCE_REQUIREMENTS_LIST.
        //
        configPtr = currentPtr + sizeof(*devNodeHeader);
        remainingNodeLength = devNodeHeader->Size - sizeof(*devNodeHeader);

        devNodeInfo[nodeIndex].BootConfig = NULL;
        devNodeInfo[nodeIndex].FirmwareDisabled = FALSE;

        status = PpBiosResourcesToNtResources( 0,            /* BusNumber */
                                               0,            /* SlotNumber */
                                               &configPtr,   /* BiosData */
                                               convertFlags, /* ConvertFlags */
                                               &tempResReqList, /* ReturnedList */
                                               &configListLength);    /* ReturnedLength */

        remainingNodeLength = devNodeHeader->Size - (LONG)(configPtr - (PUCHAR)devNodeHeader);

        if (NT_SUCCESS( status )) {

            if (tempResReqList != NULL) {

                PpFilterNtResource (
                    devNodeInfo[nodeIndex].ProductId,
                    tempResReqList
                );

                //
                // Now we need to convert from a IO_RESOURCE_REQUIREMENTS_LIST to a
                // CM_RESOURCE_LIST.
                //
                status = PnPBiosIoResourceListToCmResourceList( tempResReqList,
                                                                &devNodeInfo[nodeIndex].BootConfig,
                                                                &devNodeInfo[nodeIndex].BootConfigLength);

                status = PnPBiosCheckForHardwareDisabled(tempResReqList,&devNodeInfo[nodeIndex].FirmwareDisabled);
                ExFreePool( tempResReqList );
            }

        } else {

            IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                        "Error converting allocated resources for devnode # %d, status = %8.8X\n",
                        devNodeInfo[nodeIndex].Handle,
                        status) );
        }

        //
        // Convert the supported resource configurations from ISA PnP resource
        // descriptor format to an IO_RESOURCE_REQUIREMENTS_LIST.
        //
        status = PpBiosResourcesToNtResources( 0,            /* BusNumber */
                                               0,            /* SlotNumber */
                                               &configPtr,   /* BiosData */
                                               convertFlags | PPCONVERTFLAG_SET_RESTART_LCPRI, /* ConvertFlags */
                                               &devNodeInfo[nodeIndex].BasicConfig, /* ReturnedList */
                                               &devNodeInfo[nodeIndex].BasicConfigLength );  /* ReturnedLength */

        remainingNodeLength = devNodeHeader->Size - (LONG)(configPtr - (PUCHAR)devNodeHeader);

        if (!NT_SUCCESS( status )) {

            devNodeInfo[nodeIndex].BasicConfig = NULL;

            IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                        "Error converting allowed resources for devnode # %d, status = %8.8X\n",
                        devNodeInfo[nodeIndex].Handle,
                        status) );
        } else {

            PpFilterNtResource (
                devNodeInfo[nodeIndex].ProductId,
                devNodeInfo[nodeIndex].BasicConfig
            );
        }

        //
        // Convert the list of compatible IDs if present
        //

        ASSERT(remainingNodeLength >= 0);

        status = PnPBiosExtractCompatibleIDs( &configPtr,       // BiosData
                                              (ULONG)remainingNodeLength,
                                              &devNodeInfo[nodeIndex].CompatibleIDs,
                                              &devNodeInfo[nodeIndex].CompatibleIDsLength );

        currentPtr += devNodeHeader->Size;
        lengthRemaining -= devNodeHeader->Size;

    }

    *DevNodeInfoList = devNodeInfo;
    *NumberNodes = numNodes;
    return STATUS_SUCCESS;
}

LONG
PnPBiosFindMatchingDevNode(
    IN PWCHAR MapperName,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    )
/*++

Routine Description:

    Given a list of resources this routine finds an entry in the
    DevNodeInfoList whose BootConfig resources match.  A match is defined as
    having at least overlapping I/O Ports or Memory Ranges.  If ResourceList doesn't
    include any I/O Ports or Memory Ranges then a match is defined as exactly
    the same interrupts and/or DMA channels.

    This routine is used to find PnP BIOS reported devices which match devices
    created by the Firmware Mapper.

Arguments:

    ResourceList - Pointer to CM_RESOURCE_LIST describing the resources
        currently used by the device for which a match is being searched.

    DevNodeInfoList - Array of BIOS_DEVNODE_INFO structures, one for each device
        reported by the BIOS.

    NumberNodes - Number of BIOS_DEVNODE_INFO elements pointed to by
        DevNodeInfoList.


Return Value:

    Index of the entry in DevNodeInfoList whose BootConfig matches the resources
    listed in ResourceList.  If no matching entry is found then -1 is returned.

--*/
{
    PCM_PARTIAL_RESOURCE_LIST       sourceList;
    PCM_PARTIAL_RESOURCE_LIST       targetList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR sourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR targetDescriptor;
    ULONG                           nodeIndex, sourceIndex, targetIndex;
    LONG                            firstMatch = -1;
    LONG                            bestMatch = -1;
    ULONG                           numResourcesMatch;
    ULONG                           score, possibleScore = 0, bestScore = 0;
    PWCHAR                          idPtr;
    BOOLEAN                         idsMatch;
    BOOLEAN                         bestIdsMatch = FALSE;

#if DEBUG_DUP_MATCH
    CHAR                            sourceMapping[256];
    CHAR                            targetMapping[256];
#endif

    //
    // In order to simplify the problem we assume there is only one list.  This
    // assumption holds true in the BootConfig structures generated by the
    // current firmware mapper.
    //
    ASSERT( ResourceList->Count == 1 );

    sourceList = &ResourceList->List[0].PartialResourceList;

#if DEBUG_DUP_MATCH
    //
    // For debugging purposes we keep track of which resource entries map to
    // each other.  These relationships are stored in a fixed CHAR array, thus
    // the restriction on the number of descriptors.
    //
    ASSERT( sourceList->Count < 255 );
#endif

    //
    // Loop through each devnode and try and match it to the source resource
    // list.
    //
    for (nodeIndex = 0; nodeIndex < NumberNodes; nodeIndex++) {

        if (DevNodeInfoList[ nodeIndex ].BootConfig == NULL) {

            continue;
        }

        //
        // We found at least one potential match.  Let's double check if
        // the PNP ids also match.  We use a lack of ID match to disqualify
        // entries which don't match at least I/O ports or memory.
        //

        idPtr = DevNodeInfoList[ nodeIndex ].ProductId;

        if (RtlCompareMemory( idPtr, MapperName, 12 ) != 12) {

            idPtr = DevNodeInfoList[ nodeIndex ].CompatibleIDs;

            if (idPtr != NULL) {

                while (*idPtr != '\0') {

                    if (RtlCompareMemory( idPtr, MapperName, 12 ) == 12) {

                        break;
                    }

                    idPtr += 9;
                }

                if (*idPtr == '\0') {

                    idPtr = NULL;
                }
            }
        }

        idsMatch = (BOOLEAN)(idPtr != NULL);

        ASSERT( DevNodeInfoList[ nodeIndex ].BootConfig->Count == 1 );

        targetList = &DevNodeInfoList[ nodeIndex ].BootConfig->List[0].PartialResourceList;

#if DEBUG_DUP_MATCH
        RtlFillMemory( sourceMapping, sizeof(sourceMapping), -1 );
        RtlFillMemory( targetMapping, sizeof(targetMapping), -1 );
#endif

        numResourcesMatch = 0;
        possibleScore = 0;
        score = 0;

        //
        // Loop through each source descriptor (resource) and try and match it
        // to one of this devnode's descriptors.
        //

        for (sourceIndex = 0; sourceIndex < sourceList->Count; sourceIndex++) {

            sourceDescriptor = &sourceList->PartialDescriptors[sourceIndex];

            //
            // We are recalculating the possible score unnecessarily each time
            // we process a devnode.  We might save a small amount of time by
            // looping through the source descriptors once at the beginning but
            // its not clear it would make all that much difference given the
            // few devices reported by the BIOS.
            //

            switch (sourceDescriptor->Type) {

            case CmResourceTypePort:
                possibleScore += 0x1100;
                break;

            case CmResourceTypeInterrupt:
                possibleScore += 0x0001;
                break;

            case CmResourceTypeMemory:
                possibleScore += 0x1100;
                break;

            case CmResourceTypeDma:
                possibleScore += 0x0010;
                break;

            default:
                continue;
            }

            //
            // Try to find a resource in the target devnode which matches the
            // current source resource.
            //
            for (targetIndex = 0; targetIndex < targetList->Count; targetIndex++) {

                targetDescriptor = &targetList->PartialDescriptors[targetIndex];

                if (sourceDescriptor->Type == targetDescriptor->Type) {
                    switch (sourceDescriptor->Type) {
                    case CmResourceTypePort:
                        if ((sourceDescriptor->u.Port.Start.LowPart + sourceDescriptor->u.Port.Length) <=
                             targetDescriptor->u.Port.Start.LowPart ||
                            (targetDescriptor->u.Port.Start.LowPart + targetDescriptor->u.Port.Length) <=
                             sourceDescriptor->u.Port.Start.LowPart) {
                            continue;
                        }
                        if (sourceDescriptor->u.Port.Start.LowPart ==
                                targetDescriptor->u.Port.Start.LowPart &&
                            sourceDescriptor->u.Port.Length ==
                                targetDescriptor->u.Port.Length) {

                            score += 0x1100;

                        } else {

                            IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                                        "Overlapping port resources, source = %4.4X-%4.4X, target = %4.4X-%4.4X\n",
                                        sourceDescriptor->u.Port.Start.LowPart,
                                        sourceDescriptor->u.Port.Start.LowPart + sourceDescriptor->u.Port.Length - 1,
                                        targetDescriptor->u.Port.Start.LowPart,
                                        targetDescriptor->u.Port.Start.LowPart + targetDescriptor->u.Port.Length - 1) );

                            score += 0x1000;

                        }
                        break;

                    case CmResourceTypeInterrupt:
                        if (sourceDescriptor->u.Interrupt.Level !=
                            targetDescriptor->u.Interrupt.Level) {
                            continue;
                        }
                        score += 0x0001;
                        break;

                    case CmResourceTypeMemory:
                        if ((sourceDescriptor->u.Memory.Start.LowPart + sourceDescriptor->u.Memory.Length) <=
                             targetDescriptor->u.Memory.Start.LowPart ||
                            (targetDescriptor->u.Memory.Start.LowPart + targetDescriptor->u.Memory.Length) <=
                             sourceDescriptor->u.Memory.Start.LowPart) {

                            continue;
                        }
                        if (sourceDescriptor->u.Memory.Start.LowPart ==
                                targetDescriptor->u.Memory.Start.LowPart &&
                            sourceDescriptor->u.Memory.Length ==
                                targetDescriptor->u.Memory.Length) {

                            score += 0x1100;

                        } else {

                            score += 0x1000;

                        }
                        break;

                    case CmResourceTypeDma:
                        if (sourceDescriptor->u.Dma.Channel !=
                            targetDescriptor->u.Dma.Channel) {

                            continue;
                        }
                        score += 0x0010;
                        break;

                    }
                    break;
                }
            }

            if (targetIndex < targetList->Count) {
#if DEBUG_DUP_MATCH
                sourceMapping[sourceIndex] = (CHAR)targetIndex;
                targetMapping[targetIndex] = (CHAR)sourceIndex;
#endif
                numResourcesMatch++;
            }
        }

        if (numResourcesMatch != 0) {
            if (firstMatch == -1) {
                firstMatch = nodeIndex;
            }

            if ((score > bestScore) || (score == bestScore && !bestIdsMatch && idsMatch))  {
                bestScore = score;
                bestMatch = nodeIndex;
                bestIdsMatch = idsMatch;
            }
        }
    }

    if (bestMatch != -1) {

        if (bestScore == possibleScore) {

            IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                        "Perfect match, score = %4.4X, possible = %4.4X, index = %d\n",
                        bestScore,
                        possibleScore,
                        bestMatch) );

            if (possibleScore < 0x1000 && !bestIdsMatch) {

                bestMatch = -1;

            }

        } else if (possibleScore > 0x1000 && bestScore >= 0x1000) {

            IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                        "Best match is close enough, score = %4.4X, possible = %4.4X, index = %d\n",
                        bestScore,
                        possibleScore,
                        bestMatch) );

        } else  {

            IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                        "Best match is less than threshold, score = %4.4X, possible = %4.4X, index = %d\n",
                        bestScore,
                        possibleScore,
                        bestMatch) );

            bestMatch = -1;

        }
    }

    return bestMatch;
}

NTSTATUS
PnPBiosEliminateDupes(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    )
/*++

Routine Description:

    This routine enumerates the Firmware Mapper generated devices under
    Enum\Root.  Those that match entries in DevNodeInfoList have their registry
    key name stored in the DevNodeInfoList entry so that the Firmare Mapper
    instance may be removed later.

Arguments:

    DevNodeInfoList - Array of BIOS_DEVNODE_INFO structures, one for each device
        reported by the BIOS.

    NumberNodes - Number of BIOS_DEVNODE_INFO elements pointed to by
        DevNodeInfoList.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    UNICODE_STRING                  enumRootKeyName, valueName;
    HANDLE                          enumRootKey;
    PKEY_BASIC_INFORMATION          deviceBasicInfo = NULL;
    ULONG                           deviceBasicInfoLength;
    UNICODE_STRING                  deviceKeyName;
    HANDLE                          deviceKey = NULL;
    PKEY_BASIC_INFORMATION          instanceBasicInfo = NULL;
    ULONG                           instanceBasicInfoLength;
    WCHAR                           logConfStr[DEFAULT_STRING_SIZE];
    UNICODE_STRING                  logConfKeyName;
    HANDLE                          logConfKey = NULL;

    PKEY_VALUE_PARTIAL_INFORMATION  valueInfo = NULL;
    ULONG                           valueInfoLength;
    ULONG                           returnedLength;

    ULONG                           deviceIndex, instanceIndex;
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;

    PiWstrToUnicodeString(&enumRootKeyName, ENUMROOT_KEY_NAME);

    status = IopOpenRegistryKeyEx( &enumRootKey,
                                   NULL,
                                   &enumRootKeyName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                    "Could not open registry key %S, status = %8.8X\n",
                    ENUMROOT_KEY_NAME,
                    status) );

        return STATUS_UNSUCCESSFUL;
    }

    deviceBasicInfoLength = sizeof(KEY_BASIC_INFORMATION) + DEFAULT_STRING_SIZE;
    deviceBasicInfo = ExAllocatePool(PagedPool, deviceBasicInfoLength);

    instanceBasicInfoLength = sizeof(KEY_BASIC_INFORMATION) + DEFAULT_STRING_SIZE;
    instanceBasicInfo = ExAllocatePool(PagedPool, instanceBasicInfoLength);

    valueInfoLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + DEFAULT_STRING_SIZE;
    valueInfo = ExAllocatePool(PagedPool, valueInfoLength);

    if (deviceBasicInfo != NULL && instanceBasicInfo != NULL && valueInfo != NULL) {

        for (deviceIndex = 0; ; deviceIndex++) {

            status = ZwEnumerateKey( enumRootKey,
                                     deviceIndex,
                                     KeyBasicInformation,
                                     deviceBasicInfo,
                                     deviceBasicInfoLength,
                                     &returnedLength);

            if (!NT_SUCCESS(status)) {

                if (status == STATUS_BUFFER_TOO_SMALL ||
                    status == STATUS_BUFFER_OVERFLOW) {

                    continue;

                } else if (status != STATUS_NO_MORE_ENTRIES)  {

                    IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                                "Could not enumerate under key %S, status = %8.8X\n",
                                ENUMROOT_KEY_NAME,
                                status) );
                } else {
                    status = STATUS_SUCCESS;
                }
                break;
            }

            if (deviceBasicInfo->Name[0] != '*') {
                continue;
            }

            deviceBasicInfo->Name[ deviceBasicInfo->NameLength / 2 ] = L'\0';
            RtlInitUnicodeString(&deviceKeyName, deviceBasicInfo->Name);

            status = IopOpenRegistryKeyEx( &deviceKey,
                                           enumRootKey,
                                           &deviceKeyName,
                                           KEY_READ
                                           );

            if (!NT_SUCCESS(status)) {

                IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                            "Could not open registry key %S\\%S, status = %8.8X\n",
                            ENUMROOT_KEY_NAME,
                            deviceBasicInfo->Name,
                            status) );
                break;
            }

            for (instanceIndex = 0; ; instanceIndex++) {

                status = ZwEnumerateKey( deviceKey,
                                         instanceIndex,
                                         KeyBasicInformation,
                                         instanceBasicInfo,
                                         instanceBasicInfoLength,
                                         &returnedLength);

                if (!NT_SUCCESS(status)) {

                    if (status == STATUS_BUFFER_TOO_SMALL ||
                        status == STATUS_BUFFER_OVERFLOW) {

                        continue;

                    } else if (status != STATUS_NO_MORE_ENTRIES)  {
                        IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                                    "Could not enumerate under key %S\\%S, status = %8.8X\n",
                                    ENUMROOT_KEY_NAME,
                                    deviceBasicInfo->Name,
                                    status) );
                    } else {
                        status = STATUS_SUCCESS;
                    }
                    break;
                }

                if (RtlCompareMemory( instanceBasicInfo->Name,
                                      INSTANCE_ID_PREFIX,
                                      sizeof(INSTANCE_ID_PREFIX) - sizeof(UNICODE_NULL)
                                      ) == (sizeof(INSTANCE_ID_PREFIX) - sizeof(UNICODE_NULL))) {

                    continue;
                }

                instanceBasicInfo->Name[ instanceBasicInfo->NameLength / 2 ] = L'\0';

                RtlCopyMemory( logConfStr,
                               instanceBasicInfo->Name,
                               instanceBasicInfo->NameLength );

                logConfStr[ instanceBasicInfo->NameLength / 2 ] = L'\\';

                RtlCopyMemory( &logConfStr[ instanceBasicInfo->NameLength / 2 + 1 ],
                               REGSTR_KEY_LOGCONF,
                               sizeof(REGSTR_KEY_LOGCONF) );

                RtlInitUnicodeString( &logConfKeyName, logConfStr );

                status = IopOpenRegistryKeyEx( &logConfKey,
                                               deviceKey,
                                               &logConfKeyName,
                                               KEY_READ
                                               );

                if (!NT_SUCCESS(status)) {

                    IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                                "Could not open registry key %S\\%S\\%S, status = %8.8X\n",
                                ENUMROOT_KEY_NAME,
                                deviceBasicInfo->Name,
                                logConfStr,
                                status) );
                    continue;
                }

                PiWstrToUnicodeString( &valueName, REGSTR_VAL_BOOTCONFIG );

                status = ZwQueryValueKey( logConfKey,
                                          &valueName,
                                          KeyValuePartialInformation,
                                          valueInfo,
                                          valueInfoLength,
                                          &returnedLength );

                if (!NT_SUCCESS(status)) {

                    if (status == STATUS_BUFFER_TOO_SMALL || status == STATUS_BUFFER_OVERFLOW) {

                        ExFreePool( valueInfo );

                        valueInfoLength = returnedLength;
                        valueInfo = ExAllocatePool( PagedPool, valueInfoLength );

                        if (valueInfo != NULL) {

                            status = ZwQueryValueKey( logConfKey,
                                                      &valueName,
                                                      KeyValuePartialInformation,
                                                      valueInfo,
                                                      valueInfoLength,
                                                      &returnedLength );
                        } else {
                            IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                                        "Error allocating memory for %S\\%S\\LogConf\\BootConfig value\n",
                                        ENUMROOT_KEY_NAME,
                                        deviceBasicInfo->Name) );
                            valueInfoLength = 0;
                            status = STATUS_NO_MEMORY;

                            break;
                        }

                    } else {
                        IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                                    "Error retrieving %S\\%S\\LogConf\\BootConfig size, status = %8.8X\n",
                                    ENUMROOT_KEY_NAME,
                                    deviceBasicInfo->Name,
                                    status) );

                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                if (NT_SUCCESS( status )) {
                    PCM_RESOURCE_LIST   resourceList;
                    LONG                matchingIndex;

                    resourceList = (PCM_RESOURCE_LIST)valueInfo->Data;

                    matchingIndex = PnPBiosFindMatchingDevNode( deviceBasicInfo->Name,
                                                                resourceList,
                                                                DevNodeInfoList,
                                                                NumberNodes );

                    if (matchingIndex != -1) {

                        DevNodeInfoList[ matchingIndex ].Replaces = ExAllocatePool( PagedPool,
                                                                                    deviceBasicInfo->NameLength + instanceBasicInfo->NameLength + 2 * sizeof(UNICODE_NULL));

                        if (DevNodeInfoList[ matchingIndex ].Replaces != NULL) {

                            RtlCopyMemory( DevNodeInfoList[ matchingIndex ].Replaces,
                                           deviceBasicInfo->Name,
                                           deviceBasicInfo->NameLength );

                            DevNodeInfoList[ matchingIndex ].Replaces[ deviceBasicInfo->NameLength / 2 ] = '\\';

                            RtlCopyMemory( &DevNodeInfoList[ matchingIndex ].Replaces[ deviceBasicInfo->NameLength / 2 + 1 ],
                                           instanceBasicInfo->Name,
                                           instanceBasicInfo->NameLength );

                            DevNodeInfoList[ matchingIndex ].Replaces[ (deviceBasicInfo->NameLength + instanceBasicInfo->NameLength) / 2 + 1 ] = '\0';

                            IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                                        "Match found: %S\\%S%d replaces %S\n",
                                        DevNodeInfoList[ matchingIndex ].ProductId,
                                        INSTANCE_ID_PREFIX,
                                        DevNodeInfoList[ matchingIndex ].Handle,
                                        DevNodeInfoList[ matchingIndex ].Replaces) );
                        } else {
                            IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                                        "Error allocating memory for %S\\%S%d\\Replaces\n",
                                        DevNodeInfoList[ matchingIndex ].ProductId,
                                        INSTANCE_ID_PREFIX,
                                        DevNodeInfoList[ matchingIndex ].Handle) );
                        }
                    } else {
                        IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                                    "No matching PnP Bios DevNode found for FW Enumerated device %S\\%S\n",
                                    deviceBasicInfo->Name,
                                    instanceBasicInfo->Name) );
                    }
                } else {
                    IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                                "Error retrieving %S\\%S\\%S\\BootConfig, status = %8.8X\n",
                                ENUMROOT_KEY_NAME,
                                deviceBasicInfo->Name,
                                logConfStr,
                                status) );
                }

                ZwClose(logConfKey);

                logConfKey = NULL;
            }

            ZwClose(deviceKey);

            deviceKey = NULL;
        }
    } else {
        status = STATUS_NO_MEMORY;
    }

    if (valueInfo != NULL) {
        ExFreePool(valueInfo);
    }

    if (instanceBasicInfo != NULL) {
        ExFreePool(instanceBasicInfo);
    }

    if (deviceBasicInfo != NULL) {
        ExFreePool(deviceBasicInfo);
    }

    if (logConfKey != NULL) {
        ZwClose(logConfKey);
    }

    if (deviceKey != NULL) {
        ZwClose(deviceKey);
    }

    ZwClose(enumRootKey);

    return status;
}

PWCHAR
PnPBiosGetDescription(
    IN PBIOS_DEVNODE_INFO DevNodeInfoEntry
    )
{
    ULONG       class, subClass;
    LONG        index;
    CLASSDATA   const*classDescriptions;
    LONG        descriptionCount;

    class = DevNodeInfoEntry->TypeCode[0];
    subClass = (DevNodeInfoEntry->TypeCode[1] << 8) | DevNodeInfoEntry->TypeCode[2];

    if (class > 0 && class < CLASSLIST_COUNT) {

        classDescriptions = ClassDescriptionsList[ class ].Descriptions;
        descriptionCount = ClassDescriptionsList[ class ].Count;

        //
        // The last description entry is the default so there is no use
        // comparing it, if we get that far just use it.
        //
        for (index = 0; index < (descriptionCount - 1); index++) {

            if (subClass == classDescriptions[ index ].Value)  {

                break;
            }
        }

        return classDescriptions[ index ].Description;
    }

    return DEFAULT_DEVICE_DESCRIPTION;
}

NTSTATUS
PnPBiosCopyDeviceParamKey(
    IN HANDLE EnumRootKey,
    IN PWCHAR SourcePath,
    IN PWCHAR DestinationPath
    )
/*++

Routine Description:

    Copy the Device Parameters key from the firmware mapper node in
    DevNodeInfo->Replaces to the BIOS mapper node represented by DevNodeInfo.

Arguments:

    EnumRootKey - Handle to Enum\Root.

    SourcePath - Instance path of FW Mapper node relative to Enum\Root.

    DestinationKey - Handle to destination instance key.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    NTSTATUS                    status;
    UNICODE_STRING              sourceInstanceKeyName;
    HANDLE                      sourceInstanceKey = NULL;
    UNICODE_STRING              deviceParamKeyName;
    HANDLE                      sourceDeviceParamKey = NULL;
    HANDLE                      destinationDeviceParamKey = NULL;
    UNICODE_STRING              destinationInstanceKeyName;
    PKEY_VALUE_FULL_INFORMATION valueFullInfo = NULL;
    ULONG                       valueFullInfoLength;
    ULONG                       resultLength;
    UNICODE_STRING              valueName;
    ULONG                       index;

    RtlInitUnicodeString( &sourceInstanceKeyName, SourcePath );
    status = IopOpenRegistryKeyEx( &sourceInstanceKey,
                                   EnumRootKey,
                                   &sourceInstanceKeyName,
                                   KEY_ALL_ACCESS
                                   );
    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                    "PnPBiosCopyDeviceParamKey() - Could not open source instance key %S, status = %8.8X\n",
                    SourcePath,
                    status) );

        return status;
    }

    PiWstrToUnicodeString(&deviceParamKeyName, REGSTR_KEY_DEVICEPARAMETERS);
    status = IopOpenRegistryKeyEx( &sourceDeviceParamKey,
                                   sourceInstanceKey,
                                   &deviceParamKeyName,
                                   KEY_ALL_ACCESS
                                   );
    if (!NT_SUCCESS(status)) {

        if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

            IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                        "PnPBiosCopyDeviceParamKey() - Could not open source device parameter key %S\\%S, status = %8.8X\n",
                        SourcePath,
                        deviceParamKeyName.Buffer,
                        status) );
        }

        goto Cleanup;
    }

    RtlInitUnicodeString(&destinationInstanceKeyName, DestinationPath);
    status = IopOpenDeviceParametersSubkey( &destinationDeviceParamKey,
                                            EnumRootKey,
                                            &destinationInstanceKeyName,
                                            KEY_ALL_ACCESS );
    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                    "PnPBiosCopyDeviceParamKey() - Could not open destination device parameter key %S\\%S, status = %8.8X\n",
                    DestinationPath,
                    REGSTR_KEY_DEVICEPARAMETERS,
                    status) );

        goto Cleanup;
    }

    valueFullInfoLength = sizeof(KEY_VALUE_FULL_INFORMATION) + DEFAULT_STRING_SIZE + DEFAULT_VALUE_SIZE;
    valueFullInfo = ExAllocatePool(PagedPool, valueFullInfoLength);

    if (valueFullInfo == NULL) {

        goto Cleanup;
    }

    for (index = 0; ; index++) {

        status = ZwEnumerateValueKey( sourceDeviceParamKey,
                                      index,
                                      KeyValueFullInformation,
                                      valueFullInfo,
                                      valueFullInfoLength,
                                      &resultLength );
        if (NT_SUCCESS(status)) {

            UNICODE_STRING  sourcePathString;
            UNICODE_STRING  serialPrefixString;
            UNICODE_STRING  portNameString;

            valueName.Length = (USHORT)valueFullInfo->NameLength;
            valueName.MaximumLength = valueName.Length;
            valueName.Buffer = valueFullInfo->Name;

            RtlInitUnicodeString(&sourcePathString, SourcePath);
            PiWstrToUnicodeString(&serialPrefixString, L"*PNP0501");

            if (sourcePathString.Length > serialPrefixString.Length) {

                sourcePathString.Length = serialPrefixString.Length;
            }

            if (RtlCompareUnicodeString(&sourcePathString, &serialPrefixString, TRUE) == 0) {

                PiWstrToUnicodeString(&portNameString, L"DosDeviceName");

                if (    valueName.Length == 16 &&
                        RtlCompareUnicodeString(&valueName, &portNameString, TRUE) == 0)  {
                    //
                    // ComPortDBRemove(SourcePath, &unicodeValue);
                    //
                    ComPortDBAdd(destinationDeviceParamKey, (PWSTR)((PUCHAR)valueFullInfo + valueFullInfo->DataOffset));
                    continue;
                }
            }
            status = ZwSetValueKey( destinationDeviceParamKey,
                                    &valueName,
                                    valueFullInfo->TitleIndex,
                                    valueFullInfo->Type,
                                    (PUCHAR)valueFullInfo + valueFullInfo->DataOffset,
                                    valueFullInfo->DataLength );
        } else {

            if (status == STATUS_BUFFER_OVERFLOW) {

                ExFreePool(valueFullInfo);

                valueFullInfoLength = resultLength;
                valueFullInfo = ExAllocatePool(PagedPool, valueFullInfoLength);

                if (valueFullInfo == NULL) {

                    status = STATUS_NO_MEMORY;
                } else {

                    index--;
                    continue;
                }
            } else if (status != STATUS_NO_MORE_ENTRIES)  {

                IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                            "Could not enumerate under key %S\\%S, status = %8.8X\n",
                            SourcePath,
                            deviceParamKeyName.Buffer,
                            status) );
            } else {

                status = STATUS_SUCCESS;
            }

            break;
        }
    }

Cleanup:

    if (sourceInstanceKey != NULL) {

        ZwClose(sourceInstanceKey);
    }

    if (sourceDeviceParamKey != NULL) {

        ZwClose(sourceDeviceParamKey);
    }

    if (destinationDeviceParamKey != NULL) {

        ZwClose(destinationDeviceParamKey);
    }

    if (valueFullInfo != NULL) {

        ExFreePool(valueFullInfo);
    }

    return status;
}

NTSTATUS
PnPBiosWriteInfo(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    )
/*++

Routine Description:

    Creates an entry under Enum\Root for each DevNodeInfoList element.  Also
    removes any duplicate entries which were created by the Firmware Mapper.

    Note: Currently entries for the Keyboard, Mouse, and PCI bus are ignored.

Arguments:

    DevNodeInfoList - Array of BIOS_DEVNODE_INFO structures, one for each device
        reported by the BIOS.

    NumberNodes - Number of BIOS_DEVNODE_INFO elements pointed to by
        DevNodeInfoList.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    PKEY_VALUE_FULL_INFORMATION     excludeList = NULL;
    UNICODE_STRING                  enumRootKeyName;
    HANDLE                          enumRootKey;
    WCHAR                           instanceNameStr[DEFAULT_STRING_SIZE];
    UNICODE_STRING                  instanceKeyName;
    HANDLE                          instanceKey;
    UNICODE_STRING                  controlKeyName;
    HANDLE                          controlKey;
    UNICODE_STRING                  logConfKeyName;
    HANDLE                          logConfKey;
    UNICODE_STRING                  valueName;
    ULONG                           dwordValue;
    ULONG                           disposition;
    PWCHAR                          descriptionStr;
    ULONG                           descriptionStrLength;
    ULONG                           nodeIndex;
    NTSTATUS                        status;
    BOOLEAN                         isNewDevice;

    PiWstrToUnicodeString(&enumRootKeyName, ENUMROOT_KEY_NAME);
    status = IopOpenRegistryKeyEx( &enumRootKey,
                                   NULL,
                                   &enumRootKeyName,
                                   KEY_ALL_ACCESS
                                   );
    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                    "Could not open registry key %S, status = %8.8X\n",
                    ENUMROOT_KEY_NAME,
                    status) );

        return STATUS_UNSUCCESSFUL;
    }
    //
    // Reasons why a node might be excluded (i.e not enumerated)
    // * included in ExcludedDevices array (non-conditional)
    // * included in CCS\Control\BiosInfo\PnpBios\DisableNodes via biosinfo.inf
    // * resources are disabled and device is included in the
    //   ExcludeIfDisabled array
    //
    excludeList = PnPGetBiosInfoValue(DISABLENODES_VALUE_NAME);
    for (nodeIndex = 0; nodeIndex < NumberNodes; nodeIndex++) {

        //
        // Check if this node is in the 'ignore on this machine' list.
        //

        if ( excludeList &&
             PnPBiosIgnoreNode( &DevNodeInfoList[ nodeIndex ].ProductId[1],
                                (PWCHAR)((PUCHAR)excludeList+excludeList->DataOffset))) {

            continue;
        }

        // Checking for nodes we always exclude
        if ( PnPBiosCheckForExclusion( ExcludedDevices,
                                       EXCLUDED_DEVICES_COUNT,
                                       DevNodeInfoList[ nodeIndex ].ProductId,
                                       DevNodeInfoList[ nodeIndex ].CompatibleIDs)) {
            //
            // If we are skipping the device, we need to first copy the decode
            // info that the BIOS supplied to the ntdetected device's Boot
            // Config which was generated by the FW mapper.
            //
            PnPBiosCopyIoDecode( enumRootKey, &DevNodeInfoList[ nodeIndex ] );

            //
            // Skip excluded devices, ie busses, mice and keyboards for now.
            //

            continue;
        }

        // Checking for nodes we exclude if disabled
        if ( DevNodeInfoList[ nodeIndex ].FirmwareDisabled &&
             PnPBiosCheckForExclusion( ExcludeIfDisabled,
                                       EXCLUDE_DISABLED_COUNT,
                                       DevNodeInfoList[ nodeIndex ].ProductId,
                                       NULL)) {
            continue;
        }

        StringCbPrintfW( 
            instanceNameStr,
            sizeof(instanceNameStr),
            L"%s\\%s%d",
            DevNodeInfoList[ nodeIndex ].ProductId,
            INSTANCE_ID_PREFIX,
            DevNodeInfoList[ nodeIndex ].Handle);
        instanceNameStr[(sizeof(instanceNameStr) / sizeof(instanceNameStr[0])) - 1] = UNICODE_NULL;

        RtlInitUnicodeString(&instanceKeyName, instanceNameStr);
        status = IopCreateRegistryKeyEx( &instanceKey,
                                         enumRootKey,
                                         &instanceKeyName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         &disposition
                                         );
        if (NT_SUCCESS(status))  {
            //
            // If the key already exists because it was explicitly migrated
            // during textmode setup, we should still consider it a "new key".
            //
            if (disposition != REG_CREATED_NEW_KEY) {

                PKEY_VALUE_FULL_INFORMATION keyValueInformation;
                UNICODE_STRING unicodeString;

                status = IopGetRegistryValue(instanceKey,
                                             REGSTR_VALUE_MIGRATED,
                                             &keyValueInformation);
                if (NT_SUCCESS(status)) {

                    if ((keyValueInformation->Type == REG_DWORD) &&
                        (keyValueInformation->DataLength == sizeof(ULONG)) &&
                        ((*(PULONG)KEY_VALUE_DATA(keyValueInformation)) != 0)) {

                        disposition = REG_CREATED_NEW_KEY;
                    }
                    ExFreePool(keyValueInformation);

                    PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_MIGRATED);
                    ZwDeleteValueKey(instanceKey, &unicodeString);
                }
            }

            isNewDevice = (BOOLEAN)(disposition == REG_CREATED_NEW_KEY);
            if (isNewDevice) {

                PiWstrToUnicodeString( &valueName, L"DeviceDesc" );
                descriptionStr = PnPBiosGetDescription( &DevNodeInfoList[ nodeIndex ] );
                descriptionStrLength = (ULONG)(wcslen(descriptionStr) * 2 + sizeof(UNICODE_NULL));

                status = ZwSetValueKey( instanceKey,
                                        &valueName,
                                        0,
                                        REG_SZ,
                                        descriptionStr,
                                        descriptionStrLength );
            }

            dwordValue = 1;
            PiWstrToUnicodeString(&valueName, REGSTR_VAL_FIRMWAREIDENTIFIED);
            status = ZwSetValueKey( instanceKey,
                                    &valueName,
                                    0,
                                    REG_DWORD,
                                    &dwordValue,
                                    sizeof(dwordValue) );

            if (isNewDevice)  {

                PiWstrToUnicodeString( &valueName, REGSTR_VALUE_HARDWAREID);
                status = ZwSetValueKey( instanceKey,
                                        &valueName,
                                        0,
                                        REG_MULTI_SZ,
                                        DevNodeInfoList[ nodeIndex ].ProductId,
                                        sizeof(DevNodeInfoList[nodeIndex].ProductId));

                if (DevNodeInfoList[ nodeIndex ].CompatibleIDs != NULL) {

                    PiWstrToUnicodeString( &valueName, REGSTR_VALUE_COMPATIBLEIDS);
                    status = ZwSetValueKey( instanceKey,
                                            &valueName,
                                            0,
                                            REG_MULTI_SZ,
                                            DevNodeInfoList[ nodeIndex ].CompatibleIDs,
                                            DevNodeInfoList[ nodeIndex ].CompatibleIDsLength);
                }
            }

            PiWstrToUnicodeString( &valueName, L"Replaces" );

            if (DevNodeInfoList[ nodeIndex ].Replaces != NULL) {

                status = ZwSetValueKey( instanceKey,
                                        &valueName,
                                        0,
                                        REG_SZ,
                                        DevNodeInfoList[ nodeIndex ].Replaces,
                                        (ULONG)(wcslen(DevNodeInfoList[ nodeIndex ].Replaces) * 2 + sizeof(UNICODE_NULL)) );

            } else if (!isNewDevice) {

                status = ZwDeleteValueKey( instanceKey,
                                           &valueName );
            }

            PiWstrToUnicodeString( &controlKeyName, REGSTR_KEY_DEVICECONTROL );
            status = IopCreateRegistryKeyEx( &controlKey,
                                             instanceKey,
                                             &controlKeyName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_VOLATILE,
                                             NULL
                                             );
            if (NT_SUCCESS(status))  {

                dwordValue = 1;
                PiWstrToUnicodeString( &valueName, REGSTR_VAL_FIRMWAREMEMBER );
                status = ZwSetValueKey( controlKey,
                                        &valueName,
                                        0,
                                        REG_DWORD,
                                        &dwordValue,
                                        sizeof(dwordValue) );

                dwordValue = DevNodeInfoList[ nodeIndex ].Handle;
                PiWstrToUnicodeString(&valueName, L"PnpBiosDeviceHandle");
                status = ZwSetValueKey( controlKey,
                                        &valueName,
                                        0,
                                        REG_DWORD,
                                        &dwordValue,
                                        sizeof(dwordValue) );

                dwordValue = DevNodeInfoList[ nodeIndex ].FirmwareDisabled;
                PiWstrToUnicodeString(&valueName, REGSTR_VAL_FIRMWAREDISABLED);
                status = ZwSetValueKey( controlKey,
                                        &valueName,
                                        0,
                                        REG_DWORD,
                                        &dwordValue,
                                        sizeof(dwordValue) );
                ZwClose(controlKey);

            } else {

                IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                            "Could not open registry key %S\\%S\\%S\\Control, status = %8.8X\n",
                            ENUMROOT_KEY_NAME,
                            DevNodeInfoList[ nodeIndex ].ProductId,
                            instanceNameStr,
                            status) );

                ZwClose( instanceKey );
                status = STATUS_UNSUCCESSFUL;

                goto Cleanup;
            }

            PiWstrToUnicodeString(&logConfKeyName, REGSTR_KEY_LOGCONF);
            status = IopCreateRegistryKeyEx( &logConfKey,
                                           instanceKey,
                                           &logConfKeyName,
                                           KEY_ALL_ACCESS,
                                           REG_OPTION_NON_VOLATILE,
                                           NULL
                                           );

            if (NT_SUCCESS(status))  {

                if (DevNodeInfoList[nodeIndex].BootConfig != NULL) {

                    PiWstrToUnicodeString(&valueName, REGSTR_VAL_BOOTCONFIG);
                    status = ZwSetValueKey( logConfKey,
                                            &valueName,
                                            0,
                                            REG_RESOURCE_LIST,
                                            DevNodeInfoList[ nodeIndex ].BootConfig,
                                            DevNodeInfoList[ nodeIndex ].BootConfigLength );
                }

                if (DevNodeInfoList[nodeIndex].BasicConfig != NULL) {

                    PiWstrToUnicodeString(&valueName, REGSTR_VAL_BASICCONFIGVECTOR);
                    status = ZwSetValueKey( logConfKey,
                                            &valueName,
                                            0,
                                            REG_RESOURCE_REQUIREMENTS_LIST,
                                            DevNodeInfoList[nodeIndex].BasicConfig,
                                            DevNodeInfoList[nodeIndex].BasicConfigLength );

                }

                ZwClose(logConfKey);

            } else {

                IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                            "Could not open registry key %S\\%S\\%S\\LogConf, status = %8.8X\n",
                            ENUMROOT_KEY_NAME,
                            DevNodeInfoList[nodeIndex].ProductId,
                            instanceNameStr,
                            status) );

                ZwClose( instanceKey );
                status = STATUS_UNSUCCESSFUL;

                goto Cleanup;
            }
            //
            // If we are replacing a FW Mapper devnode we need to copy the
            // Device Parameters subkey.
            //
            if (isNewDevice && DevNodeInfoList[nodeIndex].Replaces != NULL) {

                status = PnPBiosCopyDeviceParamKey( enumRootKey,
                                                    DevNodeInfoList[nodeIndex].Replaces,
                                                    instanceNameStr );
            }

            ZwClose(instanceKey);

        } else {

            IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                        "Could not open registry key %S\\%S\\%S, status = %8.8X\n",
                        ENUMROOT_KEY_NAME,
                        DevNodeInfoList[ nodeIndex ].ProductId,
                        instanceNameStr,
                        status) );

            ZwClose(instanceKey);
            status = STATUS_UNSUCCESSFUL;

            goto Cleanup;
        }

        //
        // Now check if the entry just written duplicates one written by the
        // Firmware Mapper.  If it does then remove the Firmware Mapper entry.
        //

        if (DevNodeInfoList[nodeIndex].Replaces != NULL) {

            IopDeleteKeyRecursive(enumRootKey, DevNodeInfoList[nodeIndex].Replaces);

        }
    }
    status = STATUS_SUCCESS;

 Cleanup:

    ZwClose(enumRootKey);

    if (excludeList) {

        ExFreePool (excludeList);
    }

    return status;
}
VOID
PnPBiosCopyIoDecode(
    IN HANDLE EnumRootKey,
    IN PBIOS_DEVNODE_INFO DevNodeInfo
    )
{
    WCHAR                           logConfKeyNameStr[DEFAULT_STRING_SIZE];
    UNICODE_STRING                  logConfKeyName;
    HANDLE                          logConfKey;
    UNICODE_STRING                  valueName;
    PKEY_VALUE_PARTIAL_INFORMATION  valueInfo = NULL;
    ULONG                           valueInfoLength;
    ULONG                           returnedLength;
    NTSTATUS                        status;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;
    ULONG                           index;
    USHORT                          flags;

    if (DevNodeInfo->Replaces == NULL || DevNodeInfo->BootConfig == NULL) {
        //
        // If we didn't find a FW Mapper created devnode then there is nothing
        // to do.
        //
        return;
    }
    //
    // Search through the Boot Config and see if the device's I/O ports are
    // 16 bit decode.
    //
    ASSERT(DevNodeInfo->BootConfig->Count == 1);

    partialResourceList = &DevNodeInfo->BootConfig->List[0].PartialResourceList;
    partialDescriptor = &partialResourceList->PartialDescriptors[0];

    flags = (USHORT)~0;
    for ( index = 0; index < partialResourceList->Count; index++ ) {

        if (partialDescriptor->Type == CmResourceTypePort) {

            if (flags == (USHORT)~0) {

                flags = partialDescriptor->Flags & DECODE_FLAGS;
            } else {

                ASSERT(flags == (partialDescriptor->Flags & DECODE_FLAGS));
            }
        }
        partialDescriptor++;
    }

    if (!(flags & (CM_RESOURCE_PORT_16_BIT_DECODE | CM_RESOURCE_PORT_POSITIVE_DECODE)))  {

        return;
    }

    StringCbPrintfW(
        logConfKeyNameStr,
        sizeof(logConfKeyNameStr),
        L"%s\\%s",
        DevNodeInfo->Replaces,
        REGSTR_KEY_LOGCONF);
    logConfKeyNameStr[(sizeof(logConfKeyNameStr) / sizeof(logConfKeyNameStr[0])) - 1] = UNICODE_NULL;

    RtlInitUnicodeString(&logConfKeyName, logConfKeyNameStr);
    status = IopCreateRegistryKeyEx( &logConfKey,
                                     EnumRootKey,
                                     &logConfKeyName,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL);
    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                    "Could not open registry key %S\\%S\\%S, status = %8.8X\n",
                    ENUMROOT_KEY_NAME,
                    DevNodeInfo->Replaces,
                    REGSTR_KEY_LOGCONF,
                    status) );
        return;
    }

    valueInfoLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + DEFAULT_STRING_SIZE;
    valueInfo = ExAllocatePool(PagedPool, valueInfoLength);

    if (valueInfo == NULL)  {

        ZwClose(logConfKey);
        return;
    }

    PiWstrToUnicodeString(&valueName, REGSTR_VAL_BOOTCONFIG);
    status = ZwQueryValueKey( logConfKey,
                              &valueName,
                              KeyValuePartialInformation,
                              valueInfo,
                              valueInfoLength,
                              &returnedLength);
    if (!NT_SUCCESS(status)) {

        if (status == STATUS_BUFFER_TOO_SMALL || status == STATUS_BUFFER_OVERFLOW) {
            //
            // The default buffer was too small, free it and reallocate
            // it to the required size.
            //
            ExFreePool(valueInfo);

            valueInfoLength = returnedLength;
            valueInfo = ExAllocatePool(PagedPool, valueInfoLength);
            if (valueInfo != NULL)  {

                status = ZwQueryValueKey( logConfKey,
                                          &valueName,
                                          KeyValuePartialInformation,
                                          valueInfo,
                                          valueInfoLength,
                                          &returnedLength );

                if (!NT_SUCCESS(status)) {

                    IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                                "Could not query registry value %S\\%S\\LogConf\\BootConfig, status = %8.8X\n",
                                ENUMROOT_KEY_NAME,
                                DevNodeInfo->Replaces,
                                status) );

                    ExFreePool(valueInfo);
                    ZwClose(logConfKey);
                    return;
                }
            } else {

                IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                            "Could not allocate memory for BootConfig value\n"
                            ) );
                ZwClose(logConfKey);
                return;
            }
        }
    }
    partialResourceList = &((PCM_RESOURCE_LIST)valueInfo->Data)->List[0].PartialResourceList;
    partialDescriptor = &partialResourceList->PartialDescriptors[0];
    for ( index = 0; index < partialResourceList->Count; index++ ) {

        if (partialDescriptor->Type == CmResourceTypePort) {

            partialDescriptor->Flags &= ~DECODE_FLAGS;
            partialDescriptor->Flags |= flags;
        }
        partialDescriptor++;
    }
    status = ZwSetValueKey( logConfKey,
                            &valueName,
                            0,
                            REG_RESOURCE_LIST,
                            valueInfo->Data,
                            valueInfo->DataLength );

    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                    "Could not set registry value %S\\%S\\LogConf\\BootConfig, status = %8.8X\n",
                    ENUMROOT_KEY_NAME,
                    DevNodeInfo->Replaces,
                    status) );
    }

    ExFreePool(valueInfo);
    ZwClose(logConfKey);
}

NTSTATUS
PnPBiosCheckForHardwareDisabled(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResourceList,
    IN OUT PBOOLEAN Disabled
    )
/*++

Routine Description:

    If this device has been assigned one or more resources, and each resource has a length of zero, then it is
    hardware disabled.

Arguments:

    IoResourceList - Resource obtained from BIOS that we're about to map to a CmResourceList

    Disabled - Set to TRUE if the device is deemed to be disabled

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    BOOLEAN parsedResource;
    PIO_RESOURCE_DESCRIPTOR ioDescriptor;
    ULONG descIndex;
    //
    // Since this routine is only used to translate the allocated resources
    // returned by the PnP BIOS, we can assume that there is only 1 alternative
    // list
    //
    ASSERT(IoResourceList->AlternativeLists == 1);
    ASSERT(Disabled != NULL);

    *Disabled = FALSE;
    parsedResource = FALSE;
    //
    // Translate each resource descriptor, currently we only handle ports,
    // memory, interrupts, and dma.  The current implementation of the routine
    // which converts from ISA PnP Resource data to IO_RESOURCE_REQUIREMENTS
    // won't generate any other descriptor types given the data returned from
    // the BIOS.
    //
    for (descIndex = 0; descIndex < IoResourceList->List[0].Count; descIndex++) {

        ioDescriptor = &IoResourceList->List[0].Descriptors[descIndex];

        switch (ioDescriptor->Type) {

        case CmResourceTypePort:

            if (ioDescriptor->u.Port.Length) {

                return STATUS_SUCCESS;
            }
            parsedResource = TRUE;
            break;

        case CmResourceTypeInterrupt:

            if (ioDescriptor->u.Interrupt.MinimumVector != (ULONG)(-1)) {

                return STATUS_SUCCESS;
            }
            parsedResource = TRUE;
            break;

        case CmResourceTypeMemory:

            if (ioDescriptor->u.Memory.Length) {

                return STATUS_SUCCESS;
            }
            parsedResource = TRUE;
            break;

        case CmResourceTypeDma:

            if (ioDescriptor->u.Dma.MinimumChannel != (ULONG)(-1)) {

                return STATUS_SUCCESS;
            }
            parsedResource = TRUE;
            break;

        default:

            IopDbgPrint( (IOP_MAPPER_WARNING_LEVEL,
                        "Unexpected ResourceType (%d) in I/O Descriptor\n",
                        ioDescriptor->Type) );
            break;
        }
    }

    if (parsedResource) {
        //
        // at least one empty resource, no non-empty resources
        //
        *Disabled = TRUE;
    }

    return STATUS_SUCCESS;

}

NTSTATUS
PnPBiosFreeDevNodeInfo(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    )
/*++

Routine Description:

    Free the dynamically allocated DevNodeInfoList as well as any dynamically
    allocated dependent structures.

Arguments:

    DevNodeInfoList - Array of BIOS_DEVNODE_INFO structures, one for each device
        reported by the BIOS.

    NumberNodes - Number of BIOS_DEVNODE_INFO elements pointed to by
        DevNodeInfoList.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    ULONG   nodeIndex;

    for (nodeIndex = 0; nodeIndex < NumberNodes; nodeIndex++) {

        if (DevNodeInfoList[nodeIndex].Replaces != NULL) {

            ExFreePool(DevNodeInfoList[nodeIndex].Replaces);
        }

        if (DevNodeInfoList[nodeIndex].CompatibleIDs != NULL) {

            ExFreePool(DevNodeInfoList[nodeIndex].CompatibleIDs);
        }

        if (DevNodeInfoList[nodeIndex].BootConfig != NULL) {

            ExFreePool(DevNodeInfoList[nodeIndex].BootConfig);
        }

        if (DevNodeInfoList[nodeIndex].BasicConfig != NULL) {

            ExFreePool(DevNodeInfoList[nodeIndex].BasicConfig);
        }
    }

    ExFreePool(DevNodeInfoList);

    return STATUS_SUCCESS;
}

NTSTATUS
PnPBiosMapper()
/*++

Routine Description:

    Map the information provided from the PnP BIOS and stored in the registry by
    NTDETECT into root enumerated devices.

Arguments:

    NONE

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    PCM_RESOURCE_LIST   biosInfo;
    ULONG               length;
    NTSTATUS            status;
    PBIOS_DEVNODE_INFO  devNodeInfoList;
    ULONG               numberNodes;

    ASSERT(!PpDisableFirmwareMapper);
    if (PpDisableFirmwareMapper) {

        return STATUS_UNSUCCESSFUL;
    }

    status = PnPBiosGetBiosInfo(&biosInfo, &length);
    if (!NT_SUCCESS(status)) {

        return status;
    }

    status = PnPBiosTranslateInfo( biosInfo,
                                   length,
                                   &devNodeInfoList,
                                   &numberNodes);
    ExFreePool( biosInfo );
    if (!NT_SUCCESS(status)) {

        return status;
    }

    status = PnPBiosEliminateDupes(devNodeInfoList, numberNodes);
    if (NT_SUCCESS(status)) {

        status = PnPBiosWriteInfo(devNodeInfoList, numberNodes);
    }

    PnPBiosFreeDevNodeInfo(devNodeInfoList, numberNodes);

    return status;
}

VOID
PpFilterNtResource (
    IN PWCHAR PnpDeviceName,
    PIO_RESOURCE_REQUIREMENTS_LIST ResReqList
)
{
    PIO_RESOURCE_LIST ioResourceList;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptors;
    ULONG i, j;

    if (ResReqList == NULL) {

        return;
    }

    if (RtlCompareMemory(PnpDeviceName,
                         L"*PNP06",
                         sizeof(L"*PNP06") - sizeof(WCHAR)) ==
                         sizeof(L"*PNP06") - sizeof(WCHAR)) {

        ioResourceList = ResReqList->List;
        for (j = 0; j < ResReqList->AlternativeLists; j++) {

            ioResourceDescriptors = ioResourceList->Descriptors;

            for (i = 0; i < ioResourceList->Count; i++) {

                if (ioResourceDescriptors[i].Type == CmResourceTypePort) {
                    //
                    // some bios asks for 1 too many io port for ide channel
                    //
                    if ((ioResourceDescriptors[i].u.Port.Length == 2) &&
                            (ioResourceDescriptors[i].u.Port.MaximumAddress.QuadPart ==
                            (ioResourceDescriptors[i].u.Port.MinimumAddress.QuadPart + 1))) {

                            ioResourceDescriptors[i].u.Port.Length = 1;
                            ioResourceDescriptors[i].u.Port.MaximumAddress =
                                ioResourceDescriptors[i].u.Port.MinimumAddress;
                    }
                }
            }
            ioResourceList = (PIO_RESOURCE_LIST) (ioResourceDescriptors + ioResourceList->Count);
        }
    }
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnprlist.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnprlist.c

Abstract:

    This module contains routines to manipulate relations list.  Relation lists
    are used by Plug and Play during the processing of device removal and
    ejection.

    These routines are all pageable and can't be called at raised IRQL or with
    a spinlock held.

Author:

    Robert Nelson (robertn) Apr, 1998.

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'lrpP')
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopAddRelationToList)
#pragma alloc_text(PAGE, IopAllocateRelationList)
#pragma alloc_text(PAGE, IopCompressRelationList)
#pragma alloc_text(PAGE, IopEnumerateRelations)
#pragma alloc_text(PAGE, IopFreeRelationList)
#pragma alloc_text(PAGE, IopGetRelationsCount)
#pragma alloc_text(PAGE, IopGetRelationsTaggedCount)
#pragma alloc_text(PAGE, IopIsRelationInList)
#pragma alloc_text(PAGE, IopMergeRelationLists)
#pragma alloc_text(PAGE, IopRemoveIndirectRelationsFromList)
#pragma alloc_text(PAGE, IopRemoveRelationFromList)
#pragma alloc_text(PAGE, IopSetAllRelationsTags)
#pragma alloc_text(PAGE, IopSetRelationsTag)
#endif

#define RELATION_FLAGS              0x00000003

#define RELATION_FLAG_TAGGED        0x00000001
#define RELATION_FLAG_DESCENDANT    0x00000002

NTSTATUS
IopAddRelationToList(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DirectDescendant,
    IN BOOLEAN Tagged
    )

/*++

Routine Description:

    Adds an element to a relation list.

    If this is the first DeviceObject of a particular level then a new
    RELATION_LIST_ENTRY will be allocated.

    This routine should only be called on an uncompressed relation list,
    otherwise it is likely that STATUS_INVALID_PARAMETER will be returned.

Arguments:

    List                Relation list to which the DeviceObject is added.

    DeviceObject        DeviceObject to be added to List.  It must be a
                        PhysicalDeviceObject (PDO).

    DirectDescendant    Indicates whether DeviceObject is a direct descendant of
                        the original target device of this remove.

    Tagged              Indicates whether DeviceObject should be tagged in List.

Return Value:

    STATUS_SUCCESS

        The DeviceObject was added successfully.

    STATUS_OBJECT_NAME_COLLISION

        The DeviceObject already exists in the relation list.

    STATUS_INSUFFICIENT_RESOURCES

        There isn't enough PagedPool available to allocate a new
        RELATION_LIST_ENTRY.

    STATUS_INVALID_PARAMETER

        The level of the DEVICE_NODE associated with DeviceObject is less than
        FirstLevel or greater than the MaxLevel.

    STATUS_NO_SUCH_DEVICE

        DeviceObject is not a PhysicalDeviceObject (PDO), it doesn't have a
        DEVICE_NODE associated with it.

--*/

{
    PDEVICE_NODE            deviceNode;
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    ULONG                   index;
    ULONG                   flags;

    PAGED_CODE();

    flags = 0;

    if (Tagged) {
        Tagged = 1;
        flags |= RELATION_FLAG_TAGGED;
    }

    if (DirectDescendant) {
        flags |= RELATION_FLAG_DESCENDANT;
    }

    if ((deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode) != NULL) {
        level = deviceNode->Level;

        //
        // Since this routine is called with the DeviceNode Tree locked and
        // List is initially allocated with enough entries to hold the deepest
        // DEVICE_NODE this ASSERT should never fire.  If it does then either
        // the tree is changing or we were given a compressed list.
        //
        ASSERT(List->FirstLevel <= level && level <= List->MaxLevel);

        if (List->FirstLevel <= level && level <= List->MaxLevel) {

            if ((entry = List->Entries[ level - List->FirstLevel ]) == NULL) {

                //
                // This is the first DeviceObject of its level, allocate a new
                // RELATION_LIST_ENTRY.
                //
                entry = ExAllocatePool( PagedPool,
                                        sizeof(RELATION_LIST_ENTRY) +
                                        IopNumberDeviceNodes * sizeof(PDEVICE_OBJECT));

                if (entry == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                //
                // We always allocate enough Devices to hold the whole tree as
                // a simplification.  Since each entry is a PDEVICE_OBJECT and
                // there is generally under 50 devices on a machine this means
                // under 1K for each entry.  The excess space will be freed when
                // the list is compressed.
                //
                entry->Count = 0;
                entry->MaxCount = IopNumberDeviceNodes;

                List->Entries[ level - List->FirstLevel ] = entry;
            }

            //
            // There should always be room for a DeviceObject since the Entry is
            // initially dimensioned large enough to hold all the DEVICE_NODES
            // in the system.
            //
            ASSERT(entry->Count < entry->MaxCount);

            if (entry->Count < entry->MaxCount) {
                //
                // Search the list to see if DeviceObject has already been
                // added.
                //
                for (index = 0; index < entry->Count; index++) {
                    if (((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAGS) == (ULONG_PTR)DeviceObject) {

                        //
                        // DeviceObject already exists in the list.  However
                        // the Direct Descendant flag may differ.  We will
                        // override it if DirectDescendant is TRUE.  This could
                        // happen if we merged two relation lists.

                        if (DirectDescendant) {
                            entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] | RELATION_FLAG_DESCENDANT);
                        }

                        return STATUS_OBJECT_NAME_COLLISION;
                    }
                }
            } else {
                //
                // There isn't room in the Entry for another DEVICE_OBJECT, the
                // list has probably already been compressed.
                //
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Take out a reference on DeviceObject, we will release it when we
            // free the list or remove the DeviceObject from the list.
            //
            ObReferenceObject( DeviceObject );
            IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL, 
                         "%wZ added as a relation %s\n", 
                         &deviceNode->InstancePath, 
                         (DirectDescendant)? "(direct descendant)" : ""));

            entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)DeviceObject | flags);
            entry->Count++;

            List->Count++;
            List->TagCount += Tagged;

            return STATUS_SUCCESS;
        } else {
            //
            // There isn't an Entry available for the level of this
            // DEVICE_OBJECT, the list has probably already been compressed.
            //

            return STATUS_INVALID_PARAMETER;
        }
    } else {
        //
        // DeviceObject is not a PhysicalDeviceObject (PDO).
        //
        return STATUS_NO_SUCH_DEVICE;
    }
}

PRELATION_LIST
IopAllocateRelationList(
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode
    )

/*++

Routine Description:

    Allocate a new Relations List.  The list is initially sized large enough to
    hold the deepest DEVICE_NODE encountered since the system started.

Arguments:

    OperationCode - Type of operation the relation list is being allocated for.

Return Value:

    Newly allocated list if enough PagedPool is available, otherwise NULL.

--*/

{
    PRELATION_LIST  list;
    ULONG           maxLevel;
    ULONG           listSize;

    PAGED_CODE();

    //
    // Level number of the deepest DEVICE_NODE allocated since the system
    // started.
    //
    maxLevel = IopMaxDeviceNodeLevel;
    listSize = sizeof(RELATION_LIST) + maxLevel * sizeof(PRELATION_LIST_ENTRY);

    list = (PRELATION_LIST) PiAllocateCriticalMemory(
        OperationCode,
        PagedPool,
        listSize,
        'rcpP'
        );

    if (list != NULL) {

        RtlZeroMemory(list, listSize);
        // list->FirstLevel = 0;
        // list->Count = 0;
        // list->Tagged = 0;
        list->MaxLevel = maxLevel;
    }

    return list;
}

NTSTATUS
IopCompressRelationList(
    IN OUT PRELATION_LIST *List
    )

/*++

Routine Description:

    Compresses the relation list by reallocating the list and all the entries so
    that they a just large enough to hold their current contents.

    Once a list has been compressed IopAddRelationToList and
    IopMergeRelationLists targetting this list are both likely to fail.

Arguments:

    List    Relation List to compress.

Return Value:

    STATUS_SUCCESS

        The list was compressed.  Although this routine does allocate memory and
        the allocation can fail, the routine itself will never fail.  Since the
        memory we are allocating is always smaller then the memory it is
        replacing we just keep the old memory if the allocation fails.

--*/

{
    PRELATION_LIST          oldList, newList;
    PRELATION_LIST_ENTRY    oldEntry, newEntry;
    ULONG                   lowestLevel;
    ULONG                   highestLevel;
    ULONG                   index;

    PAGED_CODE();

    oldList = *List;

    //
    // Initialize lowestLevel and highestLevel with illegal values chosen so
    // that the first real entry will override them.
    //
    lowestLevel = oldList->MaxLevel;
    highestLevel = oldList->FirstLevel;

    //
    // Loop through the list looking for allocated entries.
    //
    for (index = 0; index <= (oldList->MaxLevel - oldList->FirstLevel); index++) {

        if ((oldEntry = oldList->Entries[ index ]) != NULL) {
            //
            // This entry is allocated, update lowestLevel and highestLevel if
            // necessary.
            //
            if (lowestLevel > index) {
                lowestLevel = index;
            }

            if (highestLevel < index) {
                highestLevel = index;
            }

            if (oldEntry->Count < oldEntry->MaxCount) {

                //
                // This entry is only partially full.  Allocate a new entry
                // which is just the right size to hold the current number of
                // PDEVICE_OBJECTs.
                //
                newEntry = ExAllocatePool( PagedPool,
                                           sizeof(RELATION_LIST_ENTRY) +
                                           (oldEntry->Count - 1) * sizeof(PDEVICE_OBJECT));

                if (newEntry != NULL) {

                    //
                    // Initialize Count and MaxCount to the number of
                    // PDEVICE_OBJECTs in the old entry.
                    //
                    newEntry->Count = oldEntry->Count;
                    newEntry->MaxCount = oldEntry->Count;

                    //
                    // Copy the PDEVICE_OBJECTs from the old entry to the new
                    // one.
                    //
                    RtlCopyMemory( newEntry->Devices,
                                   oldEntry->Devices,
                                   oldEntry->Count * sizeof(PDEVICE_OBJECT));

                    //
                    // Free the old entry and store the new entry in the list.
                    //
                    ExFreePool( oldEntry );

                    oldList->Entries[ index ] = newEntry;
                }
            }
        }
    }

    //
    // Assert that the old list isn't empty.
    //
    ASSERT(lowestLevel <= highestLevel);

    if (lowestLevel > highestLevel) {
        //
        // The list is empty - we shouldn't get asked to compress an empty list
        // but lets do it anyways.
        //
        lowestLevel = 0;
        highestLevel = 0;
    }

    //
    // Check if the old list had unused entries at the beginning or the end of
    // the Entries array.
    //
    if (lowestLevel != oldList->FirstLevel || highestLevel != oldList->MaxLevel) {

        //
        // Allocate a new List with just enough Entries to hold those between
        // FirstLevel and MaxLevel inclusive.
        //
        newList = ExAllocatePool( PagedPool,
                                  sizeof(RELATION_LIST) +
                                  (highestLevel - lowestLevel) * sizeof(PRELATION_LIST_ENTRY));

        if (newList != NULL) {
            //
            // Copy the old list to the new list and return it to the caller.
            //
            newList->Count = oldList->Count;
            newList->TagCount = oldList->TagCount;
            newList->FirstLevel = lowestLevel;
            newList->MaxLevel = highestLevel;

            RtlCopyMemory( newList->Entries,
                           &oldList->Entries[ lowestLevel ],
                           (highestLevel - lowestLevel + 1) * sizeof(PRELATION_LIST_ENTRY));

            ExFreePool( oldList );

            *List = newList;
        }
    }

    return STATUS_SUCCESS;
}

BOOLEAN
IopEnumerateRelations(
    IN      PRELATION_LIST  List,
    IN OUT  PULONG          Marker,
    OUT     PDEVICE_OBJECT *DeviceObject,
    OUT     BOOLEAN        *DirectDescendant    OPTIONAL,
    OUT     BOOLEAN        *Tagged              OPTIONAL,
    IN      BOOLEAN         Reverse
    )
/*++

Routine Description:

    Enumerates the relations in a list.

Arguments:

    List                Relation list to be enumerated.

    Marker              Cookie used to maintain current place in the list.  It
                        must be initialized to 0 the first time
                        IopEnumerateRelations is called.

    DeviceObject        Returned Relation.

    DirectDescendant    If specified then it is set if the relation is a direct
                        descendant of the original target device of this remove.

    Tagged              If specified then it is set if the relation is tagged
                        otherwise it is cleared.

    Reverse             Direction of traversal, TRUE means from deepest to
                        closest to the root, FALSE means from the root down.

                        If Reverse changes on a subsequent call then the
                        previously enumerated relation is skipped.  For example,
                        given the sequence A, B, C, D, E.  If
                        IopEnumerateRelations is called thrice with Reverse set
                        to FALSE and then called repeatedly with Reverse set to
                        TRUE until it returns FALSE, the sequence would be: A,
                        B, C, B, A.

                        Once the end has been reached it is not possible to
                        change directions.

Return Value:

    TRUE - DeviceObject and optionally Tagged have been set to the next
           relation.

    FALSE - There are no more relations.

--*/
{
    PRELATION_LIST_ENTRY    entry;
    LONG                    levelIndex;
    ULONG                   entryIndex;

    PAGED_CODE();

    //
    // The basic assumptions of our use of Marker is that there will never be
    // more than 16M DeviceNodes at any one level and that the tree will never
    // be more than 127 deep.
    //
    // The format of Marker is
    //      Bit 31      = Valid (used to distinguish the initial call
    //      Bit 30-24   = Current index into entries
    //      Bit 23-0    = Current index into devices, 0xFFFFFF means last
    //
    if (*Marker == ~0U) {
        //
        // We've reached the end.
        //
        return FALSE;
    }

    if (*Marker == 0) {
        //
        // This is the initial call to IopEnumerateRelations
        //
        if (Reverse) {
            //
            // Initialize levelIndex to the last element of Entries
            //
            levelIndex = List->MaxLevel - List->FirstLevel;
        } else {
            //
            // Initialize levelIndex to the first element of Entries
            //
            levelIndex = 0;
        }
        //
        // Initialize entryIndex to unknown element of Devices.  If we are going
        // in reverse then this will appear to be beyond the last element and
        // we'll adjust it the last one.  If we are going forward then this will
        // appear to be just prior to the first element so when we increment it,
        // it will become zero.
        //
        entryIndex = ~0U;
    } else {
        //
        // Bit 31 is our valid bit, used to distinguish level 0, device 0 from
        // the first time call.
        //
        ASSERT(*Marker & ((ULONG)1 << 31));
        //
        // Current level stored in bits 30-24.
        //
        levelIndex = (*Marker >> 24) & 0x7F;
        //
        // Current device stored in bits 23-0.
        //
        entryIndex = *Marker & 0x00FFFFFF;
    }

    if (Reverse) {
        //
        // We are traversing the list bottom up, from the deepest device towards
        // the root.
        //
        for ( ; levelIndex >= 0; levelIndex--) {

            //
            // Since the Entries array can be sparse find the next allocated
            // Entry.
            //
            if ((entry = List->Entries[ levelIndex ]) != NULL) {

                if (entryIndex > entry->Count) {
                    //
                    // entryIndex (the current one) is greater than Count, this
                    // will be the case where it is 0xFFFFFF, in other words
                    // unspecified.  Adjust it so that it is one past the last
                    // one in this Entry.
                    //
                    entryIndex = entry->Count;
                }

                if (entryIndex > 0) {

                    //
                    // The current entry is beyond the first entry so the next
                    // entry (which is the one we are looking for is immediately
                    // prior, adjust entryIndex.
                    //
                    entryIndex--;

                    //
                    // Get the device object and remove the tag.
                    //
                    *DeviceObject = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ entryIndex ] & ~RELATION_FLAGS);

                    if (Tagged != NULL) {
                        //
                        // The caller is interested in the tag value.
                        //
                        *Tagged = (BOOLEAN)((ULONG_PTR)entry->Devices[ entryIndex ] & RELATION_FLAG_TAGGED);
                    }

                    if (DirectDescendant != NULL) {
                        //
                        // The caller is interested in the DirectDescendant value.
                        //
                        *DirectDescendant = (BOOLEAN)((ULONG_PTR)entry->Devices[ entryIndex ] & RELATION_FLAG_DESCENDANT);
                    }

                    //
                    // Update the marker (info for current device)
                    //
                    *Marker = ((ULONG)1 << 31) | (levelIndex << 24) | (entryIndex & 0x00FFFFFF);

                    return TRUE;
                }
            }

            //
            // The current device object has been deleted or the current
            // device object is the first one in this Entry.
            // We need to continue to search backwards through the other
            // Entries.
            //
            entryIndex = ~0U;
        }
    } else {
        for ( ; levelIndex <= (LONG)(List->MaxLevel - List->FirstLevel); levelIndex++) {

            //
            // Since the Entries array can be sparse find the next allocated
            // Entry.
            //
            if ((entry = List->Entries[ levelIndex ]) != NULL) {

                //
                // entryIndex is the index of the current device or 0xFFFFFFFF
                // if this is the first time we have been called or the current
                // current device is the last one in its Entry.  Increment the
                // index to point to the next device.
                //
                entryIndex++;

                if (entryIndex < entry->Count) {

                    //
                    // The next device is within this entry.
                    //
                    //
                    // Get the device object and remove the tag.
                    //
                    *DeviceObject = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ entryIndex ] & ~RELATION_FLAGS);

                    if (Tagged != NULL) {
                        //
                        // The caller is interested in the tag value.
                        //
                        *Tagged = (BOOLEAN)((ULONG_PTR)entry->Devices[ entryIndex ] & RELATION_FLAG_TAGGED);
                    }

                    if (DirectDescendant != NULL) {
                        //
                        // The caller is interested in the DirectDescendant value.
                        //
                        *DirectDescendant = (BOOLEAN)((ULONG_PTR)entry->Devices[ entryIndex ] & RELATION_FLAG_DESCENDANT);
                    }

                    //
                    // Update the marker (info for current device)
                    //
                    *Marker = ((ULONG)1 << 31) | (levelIndex << 24) | (entryIndex & 0x00FFFFFF);

                    return TRUE;
                }
            }

            //
            // The current device has been removed or we have processed the
            // last device in the current entry.
            // Set entryIndex so that it is just before the first device in
            // the next entry.  Continue the search looking for the next
            // allocated Entry.
            //
            entryIndex = ~0U;
        }
    }

    //
    // We are at the end of the list
    //
    *Marker = ~0U;
    *DeviceObject = NULL;

    if (Tagged != NULL) {
        *Tagged = FALSE;
    }

    if (DirectDescendant != NULL) {
        *DirectDescendant = FALSE;
    }

    return FALSE;
}

VOID
IopFreeRelationList(
    IN PRELATION_LIST List
    )
/*++

Routine Description:

    Free a relation list allocated by IopAllocateRelationList.

Arguments:

    List    The list to be freed.

Return Value:

    NONE.

--*/
{
    PRELATION_LIST_ENTRY    entry;
    ULONG                   levelIndex;
    ULONG                   entryIndex;

    PAGED_CODE();

    //
    // Search the list looking for allocated Entries.
    //
    for (levelIndex = 0; levelIndex <= (List->MaxLevel - List->FirstLevel); levelIndex++) {

        if ((entry = List->Entries[ levelIndex ]) != NULL) {
            //
            // This entry has been allocated.
            //
            for (entryIndex = 0; entryIndex < entry->Count; entryIndex++) {
                //
                // Dereference all the Devices in the entry.
                //
                ObDereferenceObject((PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ entryIndex ] & ~RELATION_FLAGS));
            }
            //
            // Free the Entry.
            //
            ExFreePool( entry );
        }
    }

    //
    // Free the list.  It isn't necessary to dereference the DeviceObject that
    // was the original target that caused the list to be created.  This
    // DeviceObject is also in one of the Entries and its reference is taken
    // and released there.
    //
    ExFreePool( List );
}

ULONG
IopGetRelationsCount(
    PRELATION_LIST List
    )

/*++

Routine Description:

    Returns the total number of relations (Device Objects) in all the entries.

Arguments:

    List    Relation List.

Return Value:

    Count of relations (Device Objects).

--*/

{
    PAGED_CODE();

    return List->Count;
}

ULONG
IopGetRelationsTaggedCount(
    PRELATION_LIST List
    )

/*++

Routine Description:

    Returns the total number of relations (Device Objects) in all the entries
    which are tagged.

Arguments:

    List    Relation List.

Return Value:

    Count of tagged relations (Device Objects).

--*/

{
    PAGED_CODE();

    return List->TagCount;
}

BOOLEAN
IopIsRelationInList(
    PRELATION_LIST List,
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Checks if a relation (Device Object) exists in the specified relation list.

Arguments:

    List            Relation list to check.

    DeviceObject    Relation to be checked.


Return Value:

    TRUE

        Relation exists.

    FALSE

        Relation is not in the list.

--*/

{
    PDEVICE_NODE            deviceNode;
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    ULONG                   index;

    PAGED_CODE();

    if ((deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode) != NULL) {
        //
        // The device object is a PDO.
        //
        level = deviceNode->Level;

        if (List->FirstLevel <= level && level <= List->MaxLevel) {
            //
            // The level is within the range of levels stored in this list.
            //
            if ((entry = List->Entries[ level - List->FirstLevel ]) != NULL) {
                //
                // There is an Entry for this level.
                //
                for (index = 0; index < entry->Count; index++) {
                    //
                    // For each Device in the entry, compare it to the given
                    // DeviceObject
                    if (((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAGS) == (ULONG_PTR)DeviceObject) {
                        //
                        // It matches
                        //
                        return TRUE;
                    }
                }
            }
        }
    }

    //
    // It wasn't a PDO
    //      or the level wasn't in the range of levels in this list
    //      or there are no DeviceObjects at the same level in this list
    //      or the DeviceObject isn't in the Entry for its level in this list
    //
    return FALSE;
}

NTSTATUS
IopMergeRelationLists(
    IN OUT PRELATION_LIST TargetList,
    IN PRELATION_LIST SourceList,
    IN BOOLEAN Tagged
    )

/*++

Routine Description:

    Merges two relation lists by copying all the relations from the source list
    to the target list.  Source list remains unchanged.

Arguments:

    TargetList  List to which the relations from Sourcelist are added.

    SourceList  List of relations to be added to TargetList.

    Tagged      TRUE if relations from SourceList should be tagged when added to
                TargetList.  If FALSE then relations added from SourceList are
                untagged.

Return Value:

    STATUS_SUCCESS

        All the relations in SourceList were added to TargetList successfully.

    STATUS_OBJECT_NAME_COLLISION

        One of the relations in SourceList already exists in TargetList.  This
        is a fatal error and TargetList may already have some of the relations
        from SourceList added.  This could be dealt with more gracefully if
        necessary but the current callers of IopMergeRelationLists avoid this
        situation.

    STATUS_INSUFFICIENT_RESOURCES

        There isn't enough PagedPool available to allocate a new
        RELATION_LIST_ENTRY.

    STATUS_INVALID_PARAMETER

        The level of one of the relations in SourceList is less than FirstLevel
        or greater than the MaxLevel.  This is a fatal error and TargetList may
        already have some of the relations from SourceList added.  The only way
        this could happen is if the tree lock isn't held or if TargetList has
        been compressed by IopCompressRelationList.  Both situations would be
        bugs in the caller.

    STATUS_NO_SUCH_DEVICE

        One of the relations in SourceList is not a PhysicalDeviceObject (PDO),
        it doesn't have a DEVICE_NODE associated with it.  This is a fatal error
        and TargetList may already have some of the relations from SourceList
        added.  This should never happen since it was a PDO when it was added to
        SourceList.


--*/

{
    PRELATION_LIST_ENTRY    entry;
    LONG                    levelIndex;
    LONG                    entryIndex;
    LONG                    change;
    LONG                    maxIndex;
    NTSTATUS                status;
    NTSTATUS                finalStatus;

    PAGED_CODE();

    finalStatus = STATUS_SUCCESS;
    change      = 1;
    levelIndex = 0;
    maxIndex    = SourceList->MaxLevel - SourceList->FirstLevel;
    for ( ; ; ) {
        //
        // Stop at maxIndex if moving forward or at 0 otherwise.
        //
        if (    (change == 1 && levelIndex > maxIndex) ||
                (change == -1 && levelIndex < 0)) {
            break;
        }
        entry = SourceList->Entries[levelIndex];
        if (entry) {
            entryIndex = (change == 1)? 0 : entry->Count - 1;
            for ( ; ; ) {
                if (change == 1) {
                    //
                    // Stop if we added all DOs in this entry.
                    //
                    if (entryIndex >= (LONG)entry->Count) {
                        break;
                    }
                    //
                    // For each Device in the Entry, add it to the target List.
                    //
                    status = IopAddRelationToList( TargetList,
                                                   (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[entryIndex] & ~RELATION_FLAGS),
                                                   FALSE,
                                                   Tagged);
                    if (!NT_SUCCESS(status)) {
                        //
                        // We need to undo the damage on failure by unwinding and removing DOs we added..
                        //
                        finalStatus = status;
                        change = -1;
                    }
                } else {
                    //
                    // Stop at 0 if we are unwinding.
                    //
                    if (entryIndex < 0) {
                        break;
                    }
                    status = IopRemoveRelationFromList( TargetList,
                                                        (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[entryIndex] & ~RELATION_FLAGS));
                    ASSERT(NT_SUCCESS(status));
                }
                entryIndex += change;
            }
        }
        levelIndex += change;
    }

    return finalStatus;
}

NTSTATUS
IopRemoveIndirectRelationsFromList(
    IN PRELATION_LIST List
    )

/*++

Routine Description:

    Removes all the relations without the DirectDescendant flag from a relation
    list.

Arguments:

    List    List from which to remove the relations.


Return Value:

    STATUS_SUCCESS

        The relations were removed successfully.

--*/

{
    PDEVICE_OBJECT          deviceObject;
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    LONG                    index;

    PAGED_CODE();

    //
    // For each Entry in the list.
    //
    for (level = List->FirstLevel; level <= List->MaxLevel; level++) {

        //
        // If the entry is allocated.
        //
        if ((entry = List->Entries[ level - List->FirstLevel ]) != NULL) {

            //
            // For each Device in the list.
            //
            for (index = entry->Count - 1; index >= 0; index--) {
                if (!((ULONG_PTR)entry->Devices[ index ] & RELATION_FLAG_DESCENDANT)) {

                    deviceObject = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAGS);

                    ObDereferenceObject( deviceObject );

                    if ((ULONG_PTR)entry->Devices[ index ] & RELATION_FLAG_TAGGED) {
                        List->TagCount--;
                    }

                    if (index < ((LONG)entry->Count - 1)) {

                        RtlMoveMemory( &entry->Devices[ index ],
                                        &entry->Devices[ index + 1 ],
                                        (entry->Count - index - 1) * sizeof(PDEVICE_OBJECT));
                    }

                    if (--entry->Count == 0) {
                        List->Entries[ level - List->FirstLevel ] = NULL;
                        ExFreePool(entry);
                    }

                    List->Count--;
                }
            }
        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS
IopRemoveRelationFromList(
    PRELATION_LIST List,
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Removes a relation from a relation list.

Arguments:

    List            List from which to remove the relation.

    DeviceObject    Relation to remove.

Return Value:

    STATUS_SUCCESS

        The relation was removed successfully.

    STATUS_NO_SUCH_DEVICE

        The relation doesn't exist in the list.

--*/

{
    PDEVICE_NODE            deviceNode;
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    LONG                    index;

    PAGED_CODE();

    if ((deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode) != NULL) {
        level = deviceNode->Level;

        ASSERT(List->FirstLevel <= level && level <= List->MaxLevel);

        if (List->FirstLevel <= level && level <= List->MaxLevel) {
            if ((entry = List->Entries[ level - List->FirstLevel ]) != NULL) {
                for (index = entry->Count - 1; index >= 0; index--) {
                    if (((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAGS) == (ULONG_PTR)DeviceObject) {

                        ObDereferenceObject( DeviceObject );

                        if (((ULONG_PTR)entry->Devices[ index ] & RELATION_FLAG_TAGGED) != 0) {
                            List->TagCount--;
                        }
                        if (index < ((LONG)entry->Count - 1)) {

                            RtlMoveMemory( &entry->Devices[ index ],
                                           &entry->Devices[ index + 1 ],
                                           (entry->Count - index - 1) * sizeof(PDEVICE_OBJECT));
                        }

                        if (--entry->Count == 0) {
                            List->Entries[ level - List->FirstLevel ] = NULL;
                            ExFreePool(entry);
                        }

                        List->Count--;

                        return STATUS_SUCCESS;
                    }
                }
            }
        }
    }
    return STATUS_NO_SUCH_DEVICE;
}

VOID
IopSetAllRelationsTags(
    PRELATION_LIST List,
    BOOLEAN Tagged
    )

/*++

Routine Description:

    Tags or untags all the relations in a relations list.

Arguments:

    List    Relation list containing relations to be tagged or untagged.

    Tagged  TRUE if the relations should be tagged, FALSE if they are to be
            untagged.

Return Value:

    NONE

--*/

{
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    ULONG                   index;

    PAGED_CODE();

    //
    // For each Entry in the list.
    //
    for (level = List->FirstLevel; level <= List->MaxLevel; level++) {

        //
        // If the entry is allocated.
        //
        if ((entry = List->Entries[ level - List->FirstLevel ]) != NULL) {

            //
            // For each Device in the list.
            //
            for (index = 0; index < entry->Count; index++) {

                //
                // Set or clear the tag based on the argument Tagged.
                //
                if (Tagged) {
                    entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] | RELATION_FLAG_TAGGED);
                } else {
                    entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAG_TAGGED);
                }
            }
        }
    }

    //
    // If we are setting the tags then update the TagCount to the number of
    // relations in the list.  Otherwise reset it to zero.
    //
    List->TagCount = Tagged ? List->Count : 0;
}

NTSTATUS
IopSetRelationsTag(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Tagged
    )

/*++

Routine Description:

    Sets or clears a tag on a specified relation in a relations list.  This
    routine is also used by some callers to determine if a relation exists in
    a list and if so to set the tag.

Arguments:

    List            List containing relation to be tagged or untagged.

    DeviceObject    Relation to be tagged or untagged.

    Tagged          TRUE if relation is to be tagged, FALSE if it is to be
                    untagged.

Return Value:

    STATUS_SUCCESS

        The relation was tagged successfully.

    STATUS_NO_SUCH_DEVICE

        The relation doesn't exist in the list.

--*/

{
    PDEVICE_NODE            deviceNode;
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    LONG                    index;

    PAGED_CODE();

    if ((deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode) != NULL) {
        //
        // DeviceObject is a PhysicalDeviceObject (PDO), get its level.
        //
        level = deviceNode->Level;

        if (List->FirstLevel <= level && level <= List->MaxLevel) {
            //
            // The level is within the range of levels in this List.
            //
            if ((entry = List->Entries[ level - List->FirstLevel ]) != NULL) {
                //
                // The Entry for this level is allocated.  Search each device
                // in the Entry looking for a match.
                //
                for (index = entry->Count - 1; index >= 0; index--) {

                    if (((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAGS) == (ULONG_PTR)DeviceObject) {

                        //
                        // We found a match
                        //
                        if ((ULONG_PTR)entry->Devices[ index ] & RELATION_FLAG_TAGGED) {
                            //
                            // The relation is already tagged so to simplify the
                            // logic below decrement the TagCount.  We'll
                            // increment it later if the caller still wants it
                            // to be tagged.
                            //
                            List->TagCount--;
                        }

                        if (Tagged) {
                            //
                            // Set the tag and increment the number of tagged
                            // relations.
                            //
                            entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] | RELATION_FLAG_TAGGED);
                            List->TagCount++;
                        } else {
                            //
                            // Clear the tag.
                            //
                            entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAG_TAGGED);
                        }

                        return STATUS_SUCCESS;
                    }
                }
            }
        }
    }

    //
    // It wasn't a PDO
    //      or the level wasn't in the range of levels in this list
    //      or there are no DeviceObjects at the same level in this list
    //      or the DeviceObject isn't in the Entry for its level in this list
    //
    return STATUS_NO_SUCH_DEVICE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnppower.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnppower.c

Abstract:

    This file contains the routines that integrate PnP and Power

Author:

    Adrian J. Oney (AdriaO) 01-19-1999

Revision History:

    Modified for nt kernel.

--*/

#include "pnpmgrp.h"

//
// Internal References
//

PWCHAR
IopCaptureObjectName (
    IN PVOID    Object
    );

VOID
IopFreePoDeviceNotifyListHead (
    PLIST_ENTRY ListHead
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopWarmEjectDevice)
#pragma alloc_text(PAGELK, IoBuildPoDeviceNotifyList)
#pragma alloc_text(PAGELK, IoFreePoDeviceNotifyList)
#pragma alloc_text(PAGELK, IopFreePoDeviceNotifyListHead)
#pragma alloc_text(PAGELK, IoGetPoNotifyParent)
#pragma alloc_text(PAGELK, IoMovePoNotifyChildren)
#pragma alloc_text(PAGELK, IopCaptureObjectName)
#endif

NTSTATUS
IoBuildPoDeviceNotifyList (
    IN OUT PPO_DEVICE_NOTIFY_ORDER  Order
    )
{
    PLIST_ENTRY             link;
    PPO_DEVICE_NOTIFY       notify, parentnotify;
    PDEVICE_NODE            node;
    PDEVICE_NODE            parent;
    LONG                    maxLevel, level;
    UCHAR                   orderLevel;
    LIST_ENTRY              RebaseList;
    ULONG                   i;

    //
    // Block PnP operations like rebalance.
    //
    PiLockDeviceActionQueue();

    RtlZeroMemory(Order, sizeof (*Order));
    //
    // This is used as a token to remember that we have locked DeviceActionQueue
    //
    Order->DevNodeSequence = IoDeviceNodeTreeSequence;
    for (i=0; i <= PO_ORDER_MAXIMUM; i++) {
        KeInitializeEvent(&Order->OrderLevel[i].LevelReady,
                          NotificationEvent,
                          FALSE);
        InitializeListHead(&Order->OrderLevel[i].WaitSleep);
        InitializeListHead(&Order->OrderLevel[i].ReadySleep);
        InitializeListHead(&Order->OrderLevel[i].Pending);
        InitializeListHead(&Order->OrderLevel[i].Complete);
        InitializeListHead(&Order->OrderLevel[i].ReadyS0);
        InitializeListHead(&Order->OrderLevel[i].WaitS0);
    }

    InitializeListHead(&RebaseList);

    //
    // Allocate notification structures for all nodes, and determine
    // maximum depth.
    //
    level = -1;
    node = IopRootDeviceNode;
    while (node->Child) {
        node = node->Child;
        level += 1;
    }

    //
    // ADRIAO 01/12/1999 N.B. -
    //
    // Note that we include devices without the started flag. However, two
    // things prevent us from excluding devices that aren't started:
    // 1) We must be able to send power messages to a device we are warm
    //    undocking.
    // 2) Many devices may not be started, that is no guarentee they are in D3!
    //    For example, they could easily have a boot config, and PNP still
    //    relies heavily on BIOS boot configs to keep us from placing hardware
    //    ontop of other devices with boot configs we haven't found or started
    //    yet!
    //

    maxLevel = level;
    while (node != IopRootDeviceNode) {
        notify = ExAllocatePoolWithTag (
                      NonPagedPool,
                      sizeof(PO_DEVICE_NOTIFY),
                      IOP_DPWR_TAG
                      );

        if (!notify) {
            //
            // Reset the DevNodeSequence since we have failed and returning with the DeviceActionQueue unlocked.
            //
            Order->DevNodeSequence = 0;
            PiUnlockDeviceActionQueue();
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory (notify, sizeof(PO_DEVICE_NOTIFY));
        ASSERT(node->Notify == NULL) ;
        node->Notify = notify;
        notify->Node = node;
        notify->DeviceObject = node->PhysicalDeviceObject;
        notify->TargetDevice = IoGetAttachedDevice(node->PhysicalDeviceObject);
        notify->DriverName   = IopCaptureObjectName(notify->TargetDevice->DriverObject);
        notify->DeviceName   = IopCaptureObjectName(notify->TargetDevice);
        ObReferenceObject (notify->DeviceObject);
        ObReferenceObject (notify->TargetDevice);

        orderLevel   = 0;

        if (notify->TargetDevice->DeviceType != FILE_DEVICE_SCREEN &&
            notify->TargetDevice->DeviceType != FILE_DEVICE_VIDEO) {
            orderLevel |= PO_ORDER_NOT_VIDEO;
        }

        if (notify->TargetDevice->Flags & DO_POWER_PAGABLE) {
            orderLevel |= PO_ORDER_PAGABLE;
        }

        //
        // If this is a level 0 node it's in the root.  Look for
        // non-bus stuff in the root as those guys need to be re-based
        // below everything else.
        //


        notify->OrderLevel = orderLevel;

        //
        // If the node is root-enumerated, put it on the rebase list so
        // we can mark all its children later.
        // If the node is a leaf node it is ready to receive Sx irps.
        // If it has children, it must wait for its children to complete their Sx irps.
        //
        //
        if ((level == 0)  &&
            (node->InterfaceType != Internal) &&
            !(node->Flags & DNF_HAL_NODE)) {
            InsertHeadList(&RebaseList, &notify->Link);
        } else {
            ++Order->OrderLevel[orderLevel].DeviceCount;
            if (node->Child == NULL) {
                InsertHeadList(&Order->OrderLevel[orderLevel].ReadySleep, &notify->Link);
            } else {
                InsertHeadList(&Order->OrderLevel[orderLevel].WaitSleep, &notify->Link);
            }
        }
        //
        // Next node
        //

        if (node->Sibling) {
            node = node->Sibling;
            while (node->Child) {
                node = node->Child;
                level += 1;
                if (level > maxLevel) {
                    maxLevel = level;
                }
            }

        } else {
            node = node->Parent;
            level -= 1;
        }
    }

    //
    // Rebase anything on the rebase list to be after the normal pnp stuff
    //

    while (!IsListEmpty(&RebaseList)) {
        link = RemoveHeadList(&RebaseList);
        notify = CONTAINING_RECORD (link, PO_DEVICE_NOTIFY, Link);

        //
        // Rebase this node
        //

        node = notify->Node;
        notify->OrderLevel |= PO_ORDER_ROOT_ENUM;

        ++Order->OrderLevel[notify->OrderLevel].DeviceCount;
        if (node->Child == NULL) {
            InsertHeadList(&Order->OrderLevel[notify->OrderLevel].ReadySleep, &notify->Link);
        } else {
            InsertHeadList(&Order->OrderLevel[notify->OrderLevel].WaitSleep, &notify->Link);
        }
        //
        // Now rebase all the node's children
        //

        parent = node;
        while (node->Child) {
            node = node->Child;
        }

        while (node != parent) {
            notify = node->Notify;
            if (notify) {
                RemoveEntryList(&notify->Link);
                --Order->OrderLevel[notify->OrderLevel].DeviceCount;
                notify->OrderLevel |= PO_ORDER_ROOT_ENUM;
                ++Order->OrderLevel[notify->OrderLevel].DeviceCount;
                if (node->Child == NULL) {
                    InsertHeadList(&Order->OrderLevel[notify->OrderLevel].ReadySleep, &notify->Link);
                } else {
                    InsertHeadList(&Order->OrderLevel[notify->OrderLevel].WaitSleep, &notify->Link);
                }
            }

            // next node
            if (node->Sibling) {
                node = node->Sibling;
                while (node->Child) {
                    node = node->Child;
                }
            } else {
                node = node->Parent;
            }
        }
    }

    //
    // make one more pass through all the notify devices in order to count
    // the children of each parent. It would be nice if the PNP engine kept
    // track of the number of children in the devnode, but until that is done,
    // we need this second pass.
    //
    // Also make sure that each node's parent is an order level >= its children.
    //
    node = IopRootDeviceNode;
    while (node->Child) {
        node = node->Child;
    }
    while (node != IopRootDeviceNode) {
        if (node->Parent != IopRootDeviceNode) {
            parentnotify = node->Parent->Notify;
            parentnotify->ChildCount++;
            parentnotify->ActiveChild++;
            if (parentnotify->OrderLevel > node->Notify->OrderLevel) {

                //
                // The parent is a higher order level than its child. Move the
                // parent down to the same order as its child
                //
                RemoveEntryList(&parentnotify->Link);
                --Order->OrderLevel[parentnotify->OrderLevel].DeviceCount;
                parentnotify->OrderLevel = node->Notify->OrderLevel;
                ++Order->OrderLevel[parentnotify->OrderLevel].DeviceCount;
                InsertHeadList(&Order->OrderLevel[parentnotify->OrderLevel].WaitSleep, &parentnotify->Link);
            }
        }

        //
        // Next node
        //

        if (node->Sibling) {
            node = node->Sibling;
            while (node->Child) {
                node = node->Child;
            }
        } else {
            node = node->Parent;
        }
    }

    Order->WarmEjectPdoPointer = &IopWarmEjectPdo;

    //
    // The engine lock is release when the notify list is freed
    //

    return STATUS_SUCCESS;
}


PVOID
IoGetPoNotifyParent(
    IN PPO_DEVICE_NOTIFY Notify
    )
/*++

Routine Description:

    Returns the notify structure of the specified device's parent.

Arguments:

    Notify - Supplies the child device

Return Value:

    Parent's notify structure if present
    NULL if there is no parent

--*/

{
    PDEVICE_NODE Node;

    Node = Notify->Node;
    if (Node->Parent != IopRootDeviceNode) {
        return(Node->Parent->Notify);
    } else {
        return(NULL);
    }
}


VOID
IoMovePoNotifyChildren(
    IN PPO_DEVICE_NOTIFY Notify,
    IN PPO_DEVICE_NOTIFY_ORDER Order
    )
/*++

Routine Description:

    Removes any children of the supplied device that are at the
    same orderlevel as the supplied parent and reinserts them
    on the ReadyS0 list.

Arguments:

    Notify - Supplies the device notify structure

    Orderr - Supplies the device notification order structure

Return Value:

    None

--*/

{
    PDEVICE_NODE Node;
    PDEVICE_NODE Child;
    PPO_DEVICE_NOTIFY ChildNotify;
    PPO_NOTIFY_ORDER_LEVEL Level;

    Node = Notify->Node;
    Child = Node->Child;
    while (Child) {
        ChildNotify = Child->Notify;
        if (ChildNotify->OrderLevel == Notify->OrderLevel) {
            RemoveEntryList(&ChildNotify->Link);
            Level = &Order->OrderLevel[ChildNotify->OrderLevel];
            InsertTailList(&Level->ReadyS0, &ChildNotify->Link);
        }
        Child = Child->Sibling;
    }


}

VOID
IopFreePoDeviceNotifyListHead (
    PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY             Link;
    PPO_DEVICE_NOTIFY       Notify;
    PDEVICE_NODE            Node;

    while (!IsListEmpty(ListHead)) {
        Link = RemoveHeadList(ListHead);
        Notify = CONTAINING_RECORD (Link, PO_DEVICE_NOTIFY, Link);

        Node = (PDEVICE_NODE) Notify->Node;
        Node->Notify = NULL;

        ObDereferenceObject (Notify->DeviceObject);
        ObDereferenceObject (Notify->TargetDevice);
        if (Notify->DeviceName) {
            ExFreePool (Notify->DeviceName);
        }
        if (Notify->DriverName) {
            ExFreePool (Notify->DriverName);
        }
        ExFreePool(Notify);
    }
}

VOID
IoFreePoDeviceNotifyList (
    IN OUT PPO_DEVICE_NOTIFY_ORDER  Order
    )
{
    ULONG i;

    if (Order->DevNodeSequence) {

        Order->DevNodeSequence = 0;

        PiUnlockDeviceActionQueue();
    }

    //
    // Free the resources from the notify list
    //
    for (i=0; i <= PO_ORDER_MAXIMUM; i++) {
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].WaitSleep);
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].ReadySleep);
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].Pending);
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].Complete);
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].ReadyS0);
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].WaitS0);
    }

}


PWCHAR
IopCaptureObjectName (
    IN PVOID    Object
    )
{
    NTSTATUS                    Status;
    UCHAR                       Buffer[512];
    POBJECT_NAME_INFORMATION    ObName;
    ULONG                       len;
    PWCHAR                      Name;

    ObName = (POBJECT_NAME_INFORMATION) Buffer;
    Status = ObQueryNameString (
                Object,
                ObName,
                sizeof (Buffer),
                &len
                );

    Name = NULL;
    if (NT_SUCCESS(Status) && ObName->Name.Buffer) {
        Name = ExAllocatePoolWithTag (
                    NonPagedPool,
                    ObName->Name.Length + sizeof(WCHAR),
                    IOP_DPWR_TAG
                    );

        if (Name) {
            RtlCopyMemory(Name, ObName->Name.Buffer, ObName->Name.Length);
            Name[ObName->Name.Length/sizeof(WCHAR)] = UNICODE_NULL;
        }
    }

    return Name;
}

NTSTATUS
IopWarmEjectDevice(
   IN PDEVICE_OBJECT       DeviceToEject,
   IN SYSTEM_POWER_STATE   LightestSleepState
   )
/*++

Routine Description:

    This function is invoked to initiate a warm eject. The eject progresses
    from S1 to the passed in lightest sleep state.

Arguments:

    DeviceToEject       - The device to eject

    LightestSleepState  - The lightest S state (at least S1) that the device
                          may be ejected in. This might be S4 if we are truely
                          low on power.

Return Value:

    NTSTATUS value.

--*/
{
    NTSTATUS       status;

    PAGED_CODE();

    //
    // Acquire the warm eject device lock. A warm eject requires we enter a
    // specific S-state, and two different devices may have conflicting options.
    // Therefore only one is allowed to occur at once.
    //
    // Note that this function is called in the context of a work item, so we
    // don't have to worry about suspend attacks.
    //
    status = KeWaitForSingleObject(
        &IopWarmEjectLock,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    ASSERT(status == STATUS_SUCCESS) ;

    //
    // Acquire engine lock. We are not allowed to set or clear this field
    // unless we are under this lock.
    //
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Set the current Pdo to eject.
    //
    ASSERT(IopWarmEjectPdo == NULL);
    IopWarmEjectPdo = DeviceToEject;

    //
    // Release the engine lock.
    //
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Attempt to invalidate Po's cached notification list. This should cause
    // IoBuildPoDeviceNotifyList to be called at which time it will in theory
    // pickup the above placed warm eject Pdo.
    //
    // ADRIAO NOTE 01/07/1999 -
    //     Actually, this whole IoDeviceNodeTreeSequence stuff isn't neccessary.
    // PnP will make no changes to the tree while the device tree lock is owned,
    // and it's owned for the duration of a power notification.
    //
    IoDeviceNodeTreeSequence++;

    //
    // Sleep...
    //
    // ADRIAO NOTE 2002/03/31 - Note that this is invoked in the system context,
    //                          not winlogon. This means that the invoking user
    //                          will not have his SeShutdownPrivilege checked.
    //                          However, SeLoadUnloadDriver was checked, which
    //                          itself is synonomous with Admin.
    //
    status = NtInitiatePowerAction(
        PowerActionWarmEject,
        LightestSleepState,
        POWER_ACTION_QUERY_ALLOWED |
        POWER_ACTION_UI_ALLOWED,
        FALSE // Asynchronous == FALSE
        );


    //
    // Tell someone if we didn't succeed.
    //
    // Don't throw UI on every failure because some failures
    // have been handled already (e.g. a specific device veto'ing
    // the action).  Therefore, we'll check some specific error codes.
    //
    if( status == STATUS_PRIVILEGE_NOT_HELD ) {

        //
        // Intentionally ignore the return code here.  We don't 
        // want to step on our 'status' variable, and besides, there's
        // not much we could here on failure anyway.
        //
        PpSetPowerVetoEvent( PowerActionWarmEject,
                             NULL,
                             NULL,
                             DeviceToEject,
                             PNP_VetoInsufficientRights,
                             NULL );

    }


    //
    // Acquire the engine lock. We are not allowed to set or clear this field
    // unless we are under this lock.
    //
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Clear the current PDO to eject, and see if the Pdo was actually picked
    // up.
    //
    if (IopWarmEjectPdo) {

        if (NT_SUCCESS(status)) {

            //
            // If our device wasn't picked up, the return of
            // NtInitiatePowerAction should *not* be successful!
            //
            ASSERT(0);
            status = STATUS_UNSUCCESSFUL;
        }

        IopWarmEjectPdo = NULL;
    }

    //
    // Release the engine lock.
    //
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Release the warm eject device lock
    //
    KeSetEvent(
        &IopWarmEjectLock,
        IO_NO_INCREMENT,
        FALSE
        );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpres.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpres.c

Abstract:

    This module contains the plug-and-play resource allocation and translation
    routines

Author:

    Shie-Lin Tzong (shielint) 1-Mar-1997

Environment:

    Kernel mode

Revision History:

    25-Sept-1998    SantoshJ    Made IopAssign non-recursive.
    01-Oct-1998     SantoshJ    Replaced "complex (broken)" hypercube code and
                                replaced with cascading counters. Simple,
                                faster, smaller code.
                                Added timeouts to IopAssign.
                                Added more self-debugging capability by
                                generating more meaningful debug spew.
    03-Feb-1999     SantoshJ    Do allocation one device at a time.
                                Do devices with BOOT config before others.
                                Optimize IopFindBusDeviceNode.
    22-Feb-2000     SantoshJ    Add level field to arbiter entry. Arbiter list
                                gets sorted by depth so there is no need to
                                walk the tree while calling arbiters.
    01-Mar-2000     SantoshJ    Added look-up table for legacy interface and
                                bus numbers. Avoids walking the device tree.
    13-Mar-2000     SantoshJ    Cleaned up BOOT allocation related code.
    16-Mar-2000     SantoshJ    Replaced all individual references to
                                PpRegistrySemaphore with IopXXXResourceManager
                                macro.
    17-Mar-2000     SantoshJ    Replaced all debug prints with IopDbgPrint
    20-Mar-2000     SantoshJ    Removed redundant fields from internal data
                                structures.
    21-Mar-2000     SantoshJ    Cleaned up all definitions, MACROs etc.

 --*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// CONSTANT defintions.
//
//
// Set this to 1 for maximum instrumentation.
//
#define MAXDBG                              0

#if MAX_DBG
#define MAX_ASSERT    ASSERT
#else
#define MAX_ASSERT
#endif
//
// Timeout value for IopFindBestConfiguration in milliseconds.
//
#define FIND_BEST_CONFIGURATION_TIMEOUT     5000
//
// Tag used for memory allocation.
//
#define PNP_RESOURCE_TAG                    'erpP'
//
// Forward typedefs.
//
typedef struct _REQ_DESC
    REQ_DESC, *PREQ_DESC;
typedef struct _REQ_LIST
    REQ_LIST, *PREQ_LIST;
typedef struct _REQ_ALTERNATIVE
    REQ_ALTERNATIVE, *PREQ_ALTERNATIVE, **PPREQ_ALTERNATIVE;
typedef struct _DUPLICATE_DETECTION_CONTEXT
    DUPLICATE_DETECTION_CONTEXT, *PDUPLICATE_DETECTION_CONTEXT;
typedef struct _IOP_POOL
    IOP_POOL, *PIOP_POOL;
//
// Structure definitions.
//
// REQ_LIST represents a list of logical configurations within the
// IO_RESOURCE_REQUIREMENTS_LIST.
//
struct _REQ_LIST {
    INTERFACE_TYPE          InterfaceType;
    ULONG                   BusNumber;
    PIOP_RESOURCE_REQUEST   Request;                // Owning request
    PPREQ_ALTERNATIVE       SelectedAlternative;    // Alternative selected
    PPREQ_ALTERNATIVE       BestAlternative;        // Best alternative
    ULONG                   AlternativeCount;       // AlternativeTable length
    PREQ_ALTERNATIVE        AlternativeTable[1];    // Variable length
};
//
// REQ_ALTERNATIVE represents a logical configuration.
//
struct _REQ_ALTERNATIVE {
    ULONG       Priority;               // Priority for this configuration
    ULONG       Position;               // Used for sorting if Priority is identical
    PREQ_LIST   ReqList;                // List containing this configuration
    ULONG       ReqAlternativeIndex;    // Index within the table in the list
    ULONG       DescCount;              // Entry count for DescTable
    PREQ_DESC   DescTable[1];           // Variable length
};
//
// REQ_DESC represents a resource descriptor within a logical configuration.
//
struct _REQ_DESC {
    INTERFACE_TYPE                  InterfaceType;
    ULONG                           BusNumber;
    BOOLEAN                         ArbitrationRequired;
    UCHAR                           Reserved[3];
    PREQ_ALTERNATIVE                ReqAlternative;
    ULONG                           ReqDescIndex;
    PREQ_DESC                       TranslatedReqDesc;
    ARBITER_LIST_ENTRY              AlternativeTable;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  Allocation;
    ARBITER_LIST_ENTRY              BestAlternativeTable;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  BestAllocation;
    ULONG                           DevicePrivateCount; // DevicePrivate info
    PIO_RESOURCE_DESCRIPTOR         DevicePrivate;      // per LogConf
    union {
        PPI_RESOURCE_ARBITER_ENTRY      Arbiter;    // In original REQ_DESC
        PPI_RESOURCE_TRANSLATOR_ENTRY   Translator; // In translated REQ_DESC
    } u;
};
//
// Duplicate_detection_Context
//
struct _DUPLICATE_DETECTION_CONTEXT {
    PCM_RESOURCE_LIST   TranslatedResources;
    PDEVICE_NODE        Duplicate;
};
//
// Pool
//
struct _IOP_POOL {
    PUCHAR  PoolStart;
    ULONG   PoolSize;
};
#if DBG_SCOPE

typedef struct {
    PDEVICE_NODE                    devnode;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  resource;
} PNPRESDEBUGTRANSLATIONFAILURE;

#endif  // DBG_SCOPE
//
// MACROS
//
// Reused device node fields.
//
#define NextDeviceNode                      Sibling
#define PreviousDeviceNode                  Child
//
// Call this macro to block other resource allocations and releases in the
// system.
//
#define IopLockResourceManager() {      \
    KeEnterCriticalRegion();            \
    KeWaitForSingleObject(              \
        &PpRegistrySemaphore,           \
        DelayExecution,                 \
        KernelMode,                     \
        FALSE,                          \
        NULL);                          \
}
//
// Unblock other resource allocations and releases in the system.
//
#define IopUnlockResourceManager() {    \
    KeReleaseSemaphore(                 \
        &PpRegistrySemaphore,           \
        0,                              \
        1,                              \
        FALSE);                         \
    KeLeaveCriticalRegion();            \
}
//
// Initialize arbiter entry.
//
#define IopInitializeArbiterEntryState(a) {         \
    (a)->ResourcesChanged   = FALSE;                \
    (a)->State              = 0;                    \
    InitializeListHead(&(a)->ActiveArbiterList);    \
    InitializeListHead(&(a)->BestConfig);           \
    InitializeListHead(&(a)->ResourceList);         \
    InitializeListHead(&(a)->BestResourceList);     \
}

#define IS_TRANSLATED_REQ_DESC(r)   (!((r)->ReqAlternative))
//
// Pool management MACROs
//
#define IopInitPool(Pool,Start,Size) {      \
    (Pool)->PoolStart   = (Start);          \
    (Pool)->PoolSize    = (Size);           \
    RtlZeroMemory(Start, Size);             \
}
#define IopAllocPool(M,P,S) {                                       \
    *(M)            = (PVOID)(P)->PoolStart;                        \
    ASSERT((P)->PoolStart + (S) <= (P)->PoolStart + (P)->PoolSize); \
    (P)->PoolStart  += (S);                                         \
}
//
// IopReleaseBootResources can only be called for non ROOT enumerated devices
//
#define IopReleaseBootResources(DeviceNode) {                       \
    ASSERT(((DeviceNode)->Flags & DNF_MADEUP) == 0);                \
    IopReleaseResourcesInternal(DeviceNode);                        \
    (DeviceNode)->Flags &= ~DNF_HAS_BOOT_CONFIG;                    \
    (DeviceNode)->Flags &= ~DNF_BOOT_CONFIG_RESERVED;               \
    if ((DeviceNode)->BootResources) {                              \
        ExFreePool((DeviceNode)->BootResources);                    \
        (DeviceNode)->BootResources = NULL;                         \
    }                                                               \
}
//
// Debug support
//
#ifdef POOL_TAGGING

#undef ExAllocatePool
#define ExAllocatePool(a,b)         ExAllocatePoolWithTag(a,b,PNP_RESOURCE_TAG)

#endif // POOL_TAGGING

#if MAXDBG

#define ExAllocatePoolAT(a,b)       ExAllocatePoolWithTag(a,b,'0rpP')
#define ExAllocatePoolRD(a,b)       ExAllocatePoolWithTag(a,b,'1rpP')
#define ExAllocatePoolCMRL(a,b)     ExAllocatePoolWithTag(a,b,'2rpP')
#define ExAllocatePoolCMRR(a,b)     ExAllocatePoolWithTag(a,b,'3rpP')
#define ExAllocatePoolAE(a,b)       ExAllocatePoolWithTag(a,b,'4rpP')
#define ExAllocatePoolTE(a,b)       ExAllocatePoolWithTag(a,b,'5rpP')
#define ExAllocatePoolPRD(a,b)      ExAllocatePoolWithTag(a,b,'6rpP')
#define ExAllocatePoolIORD(a,b)     ExAllocatePoolWithTag(a,b,'7rpP')
#define ExAllocatePool1RD(a,b)      ExAllocatePoolWithTag(a,b,'8rpP')
#define ExAllocatePoolPDO(a,b)      ExAllocatePoolWithTag(a,b,'9rpP')
#define ExAllocatePoolIORR(a,b)     ExAllocatePoolWithTag(a,b,'ArpP')
#define ExAllocatePoolIORL(a,b)     ExAllocatePoolWithTag(a,b,'BrpP')
#define ExAllocatePoolIORRR(a,b)    ExAllocatePoolWithTag(a,b,'CrpP')

#else  // MAXDBG

#define ExAllocatePoolAT(a,b)       ExAllocatePool(a,b)
#define ExAllocatePoolRD(a,b)       ExAllocatePool(a,b)
#define ExAllocatePoolCMRL(a,b)     ExAllocatePool(a,b)
#define ExAllocatePoolCMRR(a,b)     ExAllocatePool(a,b)
#define ExAllocatePoolAE(a,b)       ExAllocatePool(a,b)
#define ExAllocatePoolTE(a,b)       ExAllocatePool(a,b)
#define ExAllocatePoolPRD(a,b)      ExAllocatePool(a,b)
#define ExAllocatePoolIORD(a,b)     ExAllocatePool(a,b)
#define ExAllocatePool1RD(a,b)      ExAllocatePool(a,b)
#define ExAllocatePoolPDO(a,b)      ExAllocatePool(a,b)
#define ExAllocatePoolIORR(a,b)     ExAllocatePool(a,b)
#define ExAllocatePoolIORL(a,b)     ExAllocatePool(a,b)
#define ExAllocatePoolIORRR(a,b)    ExAllocatePool(a,b)

#endif // MAXDBG

#if DBG_SCOPE

#define IopStopOnTimeout()                  (IopUseTimeout)

VOID
IopDumpResourceDescriptor (
    IN PCHAR Indent,
    IN PIO_RESOURCE_DESCRIPTOR Desc
    );

VOID
IopDumpResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResources
    );

VOID
IopDumpCmResourceDescriptor (
    IN PCHAR Indent,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Desc
    );

VOID
IopDumpCmResourceList (
    IN PCM_RESOURCE_LIST CmList
    );

VOID
IopCheckDataStructuresWorker (
    IN PDEVICE_NODE Device
    );

VOID
IopCheckDataStructures (
    IN PDEVICE_NODE DeviceNode
    );

#define IopRecordTranslationFailure(d,s) {              \
    if (PnpResDebugTranslationFailureCount) {           \
        PnpResDebugTranslationFailureCount--;           \
        PnpResDebugTranslationFailure->devnode = d;     \
        PnpResDebugTranslationFailure->resource = s;    \
        PnpResDebugTranslationFailure++;                \
    }                                                   \
}

#else

#define IopStopOnTimeout()                  1
#define IopRecordTranslationFailure(d,s)
#define IopDumpResourceRequirementsList(x)
#define IopDumpResourceDescriptor(x,y)
#define IopDumpCmResourceList(c)
#define IopDumpCmResourceDescriptor(i,d)
#define IopCheckDataStructures(x)

#endif // DBG_SCOPE
//
// Internal/Forward function references
//
VOID
IopRemoveLegacyDeviceNode (
    IN PDEVICE_OBJECT   DeviceObject OPTIONAL,
    IN PDEVICE_NODE     LegacyDeviceNode
    );

NTSTATUS
IopFindLegacyDeviceNode (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    OUT PDEVICE_NODE *LegacyDeviceNode,
    OUT PDEVICE_OBJECT *LegacyPDO
    );

NTSTATUS
IopGetResourceRequirementsForAssignTable (
    IN  PIOP_RESOURCE_REQUEST   RequestTable,
    IN  PIOP_RESOURCE_REQUEST   RequestTableEnd,
    OUT PULONG                  DeviceCount
    );

NTSTATUS
IopResourceRequirementsListToReqList(
    IN PIOP_RESOURCE_REQUEST Request,
    OUT PVOID *ResReqList
    );

VOID
IopRearrangeReqList (
    IN PREQ_LIST ReqList
    );

VOID
IopRearrangeAssignTable (
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN ULONG Count
    );

int
__cdecl
IopCompareReqAlternativePriority (
    const void *arg1,
    const void *arg2
    );

int
__cdecl
IopCompareResourceRequestPriority(
    const void *arg1,
    const void *arg2
    );

VOID
IopBuildCmResourceLists(
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN PIOP_RESOURCE_REQUEST AssignTableEnd
    );

VOID
IopBuildCmResourceList (
    IN PIOP_RESOURCE_REQUEST AssignEntry
    );

NTSTATUS
IopSetupArbiterAndTranslators(
    IN PREQ_DESC ReqDesc
    );

BOOLEAN
IopFindResourceHandlerInfo(
    IN RESOURCE_HANDLER_TYPE    HandlerType,
    IN PDEVICE_NODE             DeviceNode,
    IN UCHAR                    ResourceType,
    OUT PVOID                   *HandlerEntry
    );

NTSTATUS
IopParentToRawTranslation(
    IN OUT PREQ_DESC ReqDesc
    );

NTSTATUS
IopChildToRootTranslation(
    IN PDEVICE_NODE DeviceNode,  OPTIONAL
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ARBITER_REQUEST_SOURCE ArbiterRequestSource,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
IopTranslateAndAdjustReqDesc(
    IN PREQ_DESC ReqDesc,
    IN PPI_RESOURCE_TRANSLATOR_ENTRY TranslatorEntry,
    OUT PREQ_DESC *TranslatedReqDesc
    );

NTSTATUS
IopCallArbiter(
    PPI_RESOURCE_ARBITER_ENTRY ArbiterEntry,
    ARBITER_ACTION Command,
    PVOID Input1,
    PVOID Input2,
    PVOID Input3
    );

NTSTATUS
IopFindResourcesForArbiter (
    IN PDEVICE_NODE DeviceNode,
    IN UCHAR ResourceType,
    OUT ULONG *Count,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *CmDesc
    );

VOID
IopReleaseResourcesInternal (
    IN PDEVICE_NODE DeviceNode
    );

VOID
IopReleaseResources (
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
IopRestoreResourcesInternal (
    IN PDEVICE_NODE DeviceNode
    );

VOID
IopSetLegacyDeviceInstance (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_NODE DeviceNode
    );

PCM_RESOURCE_LIST
IopCombineLegacyResources (
    IN PDEVICE_NODE DeviceNode
    );

BOOLEAN
IopNeedToReleaseBootResources(
    IN PDEVICE_NODE DeviceNode,
    IN PCM_RESOURCE_LIST AllocatedResources
    );

VOID
IopReleaseFilteredBootResources(
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN PIOP_RESOURCE_REQUEST AssignTableEnd
    );

NTSTATUS
IopQueryConflictListInternal(
    PDEVICE_OBJECT        PhysicalDeviceObject,
    IN PCM_RESOURCE_LIST  ResourceList,
    IN ULONG              ResourceListSize,
    OUT PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN ULONG              ConflictListSize,
    IN ULONG              Flags
    );

NTSTATUS
IopQueryConflictFillConflicts(
    PDEVICE_OBJECT              PhysicalDeviceObject,
    IN ULONG                    ConflictCount,
    IN PARBITER_CONFLICT_INFO   ConflictInfoList,
    OUT PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN ULONG                    ConflictListSize,
    IN ULONG                    Flags
    );

NTSTATUS
IopQueryConflictFillString(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PWSTR            Buffer,
    IN OUT PULONG       Length,
    IN OUT PULONG       Flags
    );

BOOLEAN
IopEliminateBogusConflict(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PDEVICE_OBJECT   ConflictDeviceObject
    );

VOID
IopQueryRebalance (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG Phase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    );

VOID
IopQueryRebalanceWorker (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG RebalancePhase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    );

VOID
IopTestForReconfiguration (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG RebalancePhase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    );

NTSTATUS
IopRebalance (
    IN ULONG AssignTableCont,
    IN PIOP_RESOURCE_REQUEST AssignTable
    );

NTSTATUS
IopTestConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    );

NTSTATUS
IopRetestConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    );

NTSTATUS
IopCommitConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    );

VOID
IopSelectFirstConfiguration (
    IN      PIOP_RESOURCE_REQUEST    RequestTable,
    IN      ULONG                    RequestTableCount,
    IN OUT  PLIST_ENTRY              ActiveArbiterList
    );

BOOLEAN
IopSelectNextConfiguration (
    IN      PIOP_RESOURCE_REQUEST    RequestTable,
    IN      ULONG                    RequestTableCount,
    IN OUT  PLIST_ENTRY              ActiveArbiterList
    );

VOID
IopCleanupSelectedConfiguration (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    RequestTableCount
    );

ULONG
IopComputeConfigurationPriority (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    RequestTableCount
    );

VOID
IopSaveRestoreConfiguration (
    IN      PIOP_RESOURCE_REQUEST   RequestTable,
    IN      ULONG                   RequestTableCount,
    IN OUT  PLIST_ENTRY             ArbiterList,
    IN      BOOLEAN                 Save
    );

VOID
IopAddRemoveReqDescs (
    IN      PREQ_DESC   *ReqDescTable,
    IN      ULONG       ReqDescCount,
    IN OUT  PLIST_ENTRY ActiveArbiterList,
    IN      BOOLEAN     Add
    );

NTSTATUS
IopFindBestConfiguration (
    IN      PIOP_RESOURCE_REQUEST   RequestTable,
    IN      ULONG                   RequestTableCount,
    IN OUT  PLIST_ENTRY             ActiveArbiterList
    );

PDEVICE_NODE
IopFindLegacyBusDeviceNode (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber
    );

NTSTATUS
IopAllocateBootResourcesInternal (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    );

NTSTATUS
IopBootAllocation (
    IN PREQ_LIST ReqList
    );

PCM_RESOURCE_LIST
IopCreateCmResourceList(
    IN PCM_RESOURCE_LIST ResourceList,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG   BusNumber,
    OUT PCM_RESOURCE_LIST *RemainingList
    );

PCM_RESOURCE_LIST
IopCombineCmResourceList(
    IN PCM_RESOURCE_LIST ResourceListA,
    IN PCM_RESOURCE_LIST ResourceListB
    );

VOID
IopFreeReqAlternative (
    IN PREQ_ALTERNATIVE ReqAlternative
    );

VOID
IopFreeReqList (
    IN PREQ_LIST ReqList
    );

VOID
IopFreeResourceRequirementsForAssignTable(
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN PIOP_RESOURCE_REQUEST AssignTableEnd
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IopAllocateResources)
#pragma alloc_text(PAGE, IopReleaseDeviceResources)
#pragma alloc_text(PAGE, IopGetResourceRequirementsForAssignTable)
#pragma alloc_text(PAGE, IopResourceRequirementsListToReqList)
#pragma alloc_text(PAGE, IopRearrangeReqList)
#pragma alloc_text(PAGE, IopRearrangeAssignTable)
#pragma alloc_text(PAGE, IopBuildCmResourceLists)
#pragma alloc_text(PAGE, IopBuildCmResourceList)
#pragma alloc_text(PAGE, IopSetupArbiterAndTranslators)
#pragma alloc_text(PAGE, IopUncacheInterfaceInformation)
#pragma alloc_text(PAGE, IopFindResourceHandlerInfo)
#pragma alloc_text(PAGE, IopParentToRawTranslation)
#pragma alloc_text(PAGE, IopChildToRootTranslation)
#pragma alloc_text(PAGE, IopTranslateAndAdjustReqDesc)
#pragma alloc_text(PAGE, IopCallArbiter)
#pragma alloc_text(PAGE, IopFindResourcesForArbiter)
#pragma alloc_text(PAGE, IopLegacyResourceAllocation)
#pragma alloc_text(PAGE, IopFindLegacyDeviceNode)
#pragma alloc_text(PAGE, IopRemoveLegacyDeviceNode)
#pragma alloc_text(PAGE, IopDuplicateDetection)
#pragma alloc_text(PAGE, IopReleaseResourcesInternal)
#pragma alloc_text(PAGE, IopRestoreResourcesInternal)
#pragma alloc_text(PAGE, IopSetLegacyDeviceInstance)
#pragma alloc_text(PAGE, IopCombineLegacyResources)
#pragma alloc_text(PAGE, IopReleaseResources)
#pragma alloc_text(PAGE, IopReallocateResources)
#pragma alloc_text(PAGE, IopReleaseFilteredBootResources)
#pragma alloc_text(PAGE, IopNeedToReleaseBootResources)
#pragma alloc_text(PAGE, IopQueryConflictList)
#pragma alloc_text(PAGE, IopQueryConflictListInternal)
#pragma alloc_text(PAGE, IopQueryConflictFillConflicts)
#pragma alloc_text(PAGE, IopQueryConflictFillString)
#pragma alloc_text(PAGE, IopCompareReqAlternativePriority)
#pragma alloc_text(PAGE, IopCompareResourceRequestPriority)
#pragma alloc_text(PAGE, IopQueryRebalance)
#pragma alloc_text(PAGE, IopQueryRebalanceWorker)
#pragma alloc_text(PAGE, IopTestForReconfiguration)
#pragma alloc_text(PAGE, IopRebalance)
#pragma alloc_text(PAGE, IopTestConfiguration)
#pragma alloc_text(PAGE, IopRetestConfiguration)
#pragma alloc_text(PAGE, IopCommitConfiguration)
#pragma alloc_text(PAGE, IopSelectFirstConfiguration)
#pragma alloc_text(PAGE, IopSelectNextConfiguration)
#pragma alloc_text(PAGE, IopCleanupSelectedConfiguration)
#pragma alloc_text(PAGE, IopComputeConfigurationPriority)
#pragma alloc_text(PAGE, IopSaveRestoreConfiguration)
#pragma alloc_text(PAGE, IopAddRemoveReqDescs)
#pragma alloc_text(PAGE, IopFindBestConfiguration)
#pragma alloc_text(PAGE, IopInsertLegacyBusDeviceNode)
#pragma alloc_text(PAGE, IopFindLegacyBusDeviceNode)
#pragma alloc_text(PAGE, IopAllocateBootResources)
#pragma alloc_text(INIT, IopReportBootResources)
#pragma alloc_text(INIT, IopAllocateLegacyBootResources)
#pragma alloc_text(PAGE, IopAllocateBootResourcesInternal)
#pragma alloc_text(PAGE, IopBootAllocation)
#pragma alloc_text(PAGE, IopCreateCmResourceList)
#pragma alloc_text(PAGE, IopCombineCmResourceList)
#pragma alloc_text(PAGE, IopFreeReqAlternative)
#pragma alloc_text(PAGE, IopFreeReqList)
#pragma alloc_text(PAGE, IopFreeResourceRequirementsForAssignTable)
#if DBG_SCOPE

#pragma alloc_text(PAGE, IopCheckDataStructures)
#pragma alloc_text(PAGE, IopCheckDataStructuresWorker)
#pragma alloc_text(PAGE, IopDumpResourceRequirementsList)
#pragma alloc_text(PAGE, IopDumpResourceDescriptor)
#pragma alloc_text(PAGE, IopDumpCmResourceDescriptor)
#pragma alloc_text(PAGE, IopDumpCmResourceList)

#endif  // DBG_SCOPE

#endif // ALLOC_PRAGMA
//
// External references
//
extern const WCHAR IopWstrTranslated[];
extern const WCHAR IopWstrRaw[];
//
// GLOBAL variables
//
PIOP_RESOURCE_REQUEST   PiAssignTable;
ULONG                   PiAssignTableCount;
PDEVICE_NODE            IopLegacyDeviceNode;    // Head of list of made-up
                                                // devicenodes used for legacy
                                                // allocation.
                                                // IoAssignResources &
                                                // IoReportResourceUsage
#if DBG_SCOPE

ULONG
    PnpResDebugTranslationFailureCount = 32;  // get count in both this line and the next.
PNPRESDEBUGTRANSLATIONFAILURE
    PnpResDebugTranslationFailureArray[32];
PNPRESDEBUGTRANSLATIONFAILURE
    *PnpResDebugTranslationFailure = PnpResDebugTranslationFailureArray;
ULONG IopUseTimeout = 0;

#endif  // DBG_SCOPE

NTSTATUS
IopAllocateResources(
    IN PULONG                       RequestCount,
    IN OUT PIOP_RESOURCE_REQUEST    *Request,
    IN BOOLEAN                      ResourceManagerLocked,
    IN BOOLEAN                      DoBootConfigs,
    OUT PBOOLEAN                    RebalancePerformed
    )

/*++

Routine Description:

    For each AssignTable entry, this routine queries device's IO resource requirements
    list and converts it to our internal REQ_LIST format; calls worker routine to perform
    the resources assignment.

Parameters:

    AssignTable - supplies a pointer to the first entry of a IOP_RESOURCE_REQUEST table.

    AssignTableEnd - supplies a pointer to the end of IOP_RESOURCE_REQUEST table.

    Locked - Indicates whether the PpRegistrySemaphore is acquired by the caller.

    DoBootConfigs - Indicates whether we should assign BOOT configs.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS                status;
    PIOP_RESOURCE_REQUEST   requestTable;
    PIOP_RESOURCE_REQUEST   requestTableEnd;
    ULONG                   deviceCount;
    BOOLEAN                 attemptRebalance;
    PIOP_RESOURCE_REQUEST   requestEntry;
    LIST_ENTRY              activeArbiterList;

    PAGED_CODE();

    //
    // Lock the resource manager if the caller has not locked already.
    // This is to serialize allocations and releases of resources from the
    // arbiters.
    //
    if (!ResourceManagerLocked) {

        IopLockResourceManager();
    }
    requestTable    = *Request;
    requestTableEnd = requestTable + (deviceCount = *RequestCount);
    status = IopGetResourceRequirementsForAssignTable(requestTable, requestTableEnd, &deviceCount);
    if (deviceCount) {

        attemptRebalance = ((*RequestCount == 1) && (requestTable->Flags & IOP_ASSIGN_NO_REBALANCE))? FALSE : TRUE;
        if (DoBootConfigs) {

            if (!IopBootConfigsReserved) {

                //
                // Process devices with boot config. If there are none, process others.
                //
                for (requestEntry = requestTable; requestEntry < requestTableEnd; requestEntry++) {

                    PDEVICE_NODE    deviceNode;

                    deviceNode = PP_DO_TO_DN(requestEntry->PhysicalDevice);
                    if (deviceNode->Flags & DNF_HAS_BOOT_CONFIG) {

                        break;
                    }
                }
                if (requestEntry != requestTableEnd) {

                    //
                    // There is at least one device with boot config.
                    //
                    for (requestEntry = requestTable; requestEntry < requestTableEnd; requestEntry++) {

                        PDEVICE_NODE    deviceNode;

                        deviceNode = PP_DO_TO_DN(requestEntry->PhysicalDevice);
                        if (    !(requestEntry->Flags & IOP_ASSIGN_IGNORE) &&
                                !(deviceNode->Flags & DNF_HAS_BOOT_CONFIG) &&
                                requestEntry->ResourceRequirements) {

                            IopDbgPrint((IOP_RESOURCE_INFO_LEVEL, "Delaying non BOOT config device %wZ...\n", &deviceNode->InstancePath));
                            requestEntry->Flags |= IOP_ASSIGN_IGNORE;
                            requestEntry->Status = STATUS_RETRY;
                            deviceCount--;
                        }
                    }
                }
            }
            if (deviceCount) {

                if (deviceCount != (*RequestCount)) {
                    //
                    // Move the uninteresting devices to the end of the table.
                    //
                    for (requestEntry = requestTable; requestEntry < requestTableEnd; ) {

                        IOP_RESOURCE_REQUEST temp;

                        if (!(requestEntry->Flags & IOP_ASSIGN_IGNORE)) {

                            requestEntry++;
                            continue;
                        }
                        temp = *requestEntry;
                        *requestEntry = *(requestTableEnd - 1);
                        *(requestTableEnd - 1) = temp;
                        requestTableEnd--;
                    }
                }
                ASSERT((ULONG)(requestTableEnd - requestTable) == deviceCount);
                //
                // Sort the AssignTable
                //
                IopRearrangeAssignTable(requestTable, deviceCount);
                //
                // Try one device at a time.
                //
                for (requestEntry = requestTable; requestEntry < requestTableEnd; requestEntry++) {

                    PDEVICE_NODE    deviceNode;

                    deviceNode = PP_DO_TO_DN(requestEntry->PhysicalDevice);
                    IopDbgPrint((IOP_RESOURCE_INFO_LEVEL, "Trying to allocate resources for %ws.\n", deviceNode->InstancePath.Buffer));
                    status = IopFindBestConfiguration(requestEntry, 1, &activeArbiterList);
                    if (NT_SUCCESS(status)) {
                        //
                        // Ask the arbiters to commit this configuration.
                        //
                        status = IopCommitConfiguration(&activeArbiterList);
                        if (NT_SUCCESS(status)) {

                            IopBuildCmResourceLists(requestEntry, requestEntry + 1);
                            break;
                        } else {

                            requestEntry->Status = STATUS_CONFLICTING_ADDRESSES;
                        }
                    } else if (status == STATUS_INSUFFICIENT_RESOURCES) {

                        IopDbgPrint((
                            IOP_RESOURCE_WARNING_LEVEL,
                            "IopAllocateResource: Failed to allocate Pool.\n"));
                        break;

                    } else if (attemptRebalance) {

                        IopDbgPrint((IOP_RESOURCE_INFO_LEVEL, "IopAllocateResources: Initiating REBALANCE...\n"));

                        deviceNode->Flags |= DNF_NEEDS_REBALANCE;
                        status = IopRebalance(1, requestEntry);
                        deviceNode->Flags &= ~DNF_NEEDS_REBALANCE;
                        if (!NT_SUCCESS(status)) {

                            requestEntry->Status = STATUS_CONFLICTING_ADDRESSES;
                        } else if (RebalancePerformed) {

                            *RebalancePerformed = TRUE;
                            break;
                        }
                    } else {

                        requestEntry->Status = STATUS_CONFLICTING_ADDRESSES;
                    }
                }
                //
                // If we ran out of memory, then set the appropriate status
                // on remaining devices. On success, set STATUS_RETRY on the
                // rest so we will attempt allocation again after the current
                // device is started.
                //
                if (NT_SUCCESS(status)) {

                    requestEntry++;
                }
                for (; requestEntry < requestTableEnd; requestEntry++) {

                    if (status == STATUS_INSUFFICIENT_RESOURCES) {

                        requestEntry->Status = STATUS_INSUFFICIENT_RESOURCES;
                    } else {

                        requestEntry->Status = STATUS_RETRY;
                        requestEntry->Flags |= IOP_ASSIGN_IGNORE;
                    }
                }

                for (requestEntry = requestTable; requestEntry < requestTableEnd; requestEntry++) {

                    if (requestEntry->Flags & (IOP_ASSIGN_IGNORE | IOP_ASSIGN_RETRY)) {

                        continue;
                    }
                    if (    requestEntry->Status == STATUS_SUCCESS &&
                            requestEntry->AllocationType == ArbiterRequestPnpEnumerated) {

                        IopReleaseFilteredBootResources(requestEntry, requestEntry + 1);
                    }
                    if ((requestEntry->Flags & IOP_ASSIGN_EXCLUDE) || requestEntry->ResourceAssignment == NULL) {

                        requestEntry->Status = STATUS_CONFLICTING_ADDRESSES;
                    }
                }
            } else {

                status = STATUS_UNSUCCESSFUL;
            }
        } else {
            //
            // Only process devices with no requirements.
            //
            for (requestEntry = requestTable; requestEntry < requestTableEnd; requestEntry++) {

                PDEVICE_NODE    deviceNode;

                deviceNode = PP_DO_TO_DN(requestEntry->PhysicalDevice);
                if (NT_SUCCESS(requestEntry->Status) && requestEntry->ResourceRequirements == NULL) {

                    IopDbgPrint((IOP_RESOURCE_INFO_LEVEL, "IopAllocateResources: Processing no resource requiring device %wZ\n", &deviceNode->InstancePath));
                } else {

                    IopDbgPrint((IOP_RESOURCE_INFO_LEVEL, "IopAllocateResources: Ignoring resource consuming device %wZ\n", &deviceNode->InstancePath));
                    requestEntry->Flags |= IOP_ASSIGN_IGNORE;
                    requestEntry->Status = STATUS_RETRY;
                }
            }
        }
        IopFreeResourceRequirementsForAssignTable(requestTable, requestTableEnd);
    }
    if (!ResourceManagerLocked) {

        IopUnlockResourceManager();
    }

    return status;
}

NTSTATUS
IopReleaseDeviceResources (
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN ReserveResources
    )

/*++

Routine Description:

    This routine releases the resources assigned to a device.

Arguments:

    DeviceNode          - Device whose resources are to be released.

    ReserveResources    - TRUE specifies that the BOOT config needs to be
                          reserved (after re-query).

Return Value:

    Final status code.


--*/
{
    NTSTATUS            status;
    PCM_RESOURCE_LIST   cmResource;
    ULONG               cmLength;
    UNICODE_STRING      unicodeName;
    HANDLE              logConfHandle;
    HANDLE              handle;

    PAGED_CODE();

    if (    !DeviceNode->ResourceList &&
            !(DeviceNode->Flags & DNF_BOOT_CONFIG_RESERVED)) {

        return STATUS_SUCCESS;
    }
    cmResource  = NULL;
    cmLength    = 0;
    //
    // If needed, re-query for BOOT configs. We need to do this BEFORE we
    // release the BOOT config (otherwise ROOT devices cannot report BOOT
    // config).
    //
    if (ReserveResources && !(DeviceNode->Flags & DNF_MADEUP)) {
        //
        // First query for new BOOT config (order important for ROOT devices).
        //
        status = IopQueryDeviceResources(
                    DeviceNode->PhysicalDeviceObject,
                    QUERY_RESOURCE_LIST,
                    &cmResource,
                    &cmLength);
        if (!NT_SUCCESS(status)) {

            cmResource  = NULL;
            cmLength    = 0;
        }
    }
    //
    // Release resources for this device.
    //
    status = IopLegacyResourceAllocation(
                ArbiterRequestUndefined,
                IoPnpDriverObject,
                DeviceNode->PhysicalDeviceObject,
                NULL,
                NULL);
    if (!NT_SUCCESS(status)) {

        return status;
    }
    //
    // Request reallocation of resources for conflicting devices.
    //
    PipRequestDeviceAction(NULL, AssignResources, FALSE, 0, NULL, NULL);
    //
    // If needed, re-query and reserve current BOOT config for this device.
    // We always rereserve the boot config (ie DNF_MADEUP root enumerated
    // and IoReportDetected) devices in IopLegacyResourceAllocation.
    //
    if (ReserveResources && !(DeviceNode->Flags & DNF_MADEUP)) {

        ASSERT(DeviceNode->BootResources == NULL);

        logConfHandle = NULL;
        status = IopDeviceObjectToDeviceInstance(
                    DeviceNode->PhysicalDeviceObject,
                    &handle,
                    KEY_ALL_ACCESS);
        if (NT_SUCCESS(status)) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
            status = IopCreateRegistryKeyEx(
                        &logConfHandle,
                        handle,
                        &unicodeName,
                        KEY_ALL_ACCESS,
                        REG_OPTION_NON_VOLATILE,
                        NULL);
            ZwClose(handle);
            if (!NT_SUCCESS(status)) {

                logConfHandle = NULL;
            }
        }
        if (logConfHandle) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_BOOTCONFIG);

            PiLockPnpRegistry(FALSE);

            if (cmResource) {

                ZwSetValueKey(
                    logConfHandle,
                    &unicodeName,
                    TITLE_INDEX_VALUE,
                    REG_RESOURCE_LIST,
                    cmResource,
                    cmLength);
            } else {

                ZwDeleteValueKey(logConfHandle, &unicodeName);
            }

            PiUnlockPnpRegistry();
            ZwClose(logConfHandle);
        }
        //
        // Reserve any remaining BOOT config.
        //
        if (cmResource) {

            DeviceNode->Flags |= DNF_HAS_BOOT_CONFIG;
            //
            // This device consumes BOOT resources.  Reserve its boot resources
            //
            (*IopAllocateBootResourcesRoutine)(
                ArbiterRequestPnpEnumerated,
                DeviceNode->PhysicalDeviceObject,
                DeviceNode->BootResources = cmResource);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopGetResourceRequirementsForAssignTable (
    IN  PIOP_RESOURCE_REQUEST   RequestTable,
    IN  PIOP_RESOURCE_REQUEST   RequestTableEnd,
    OUT PULONG                  DeviceCount
    )

/*++

Routine Description:

    This function gets resource requirements for entries in the request table.

Parameters:

    RequestTable    - Start of request table.

    RequestTableEnd - End of request table.

    DeviceCount     - Gets number of devices with non-NULL requirements.

Return Value:

    STATUS_SUCCESS if we got one non-NULL requirement, else STATUS_UNSUCCESSFUL.

--*/

{
    PIOP_RESOURCE_REQUEST           request;
    NTSTATUS                        status;
    PDEVICE_NODE                    deviceNode;
    ULONG                           length;
    PIO_RESOURCE_REQUIREMENTS_LIST  filteredList;
    BOOLEAN                         exactMatch;
    PREQ_LIST                       reqList;

    PAGED_CODE();

    *DeviceCount = 0;
    for (   request = RequestTable;
            request < RequestTableEnd;
            request++) {
        //
        // Skip uninteresting entries.
        //
        request->ReqList = NULL;
        if (request->Flags & IOP_ASSIGN_IGNORE) {

            continue;
        }
        request->ResourceAssignment             = NULL;
        request->TranslatedResourceAssignment   = NULL;
        deviceNode                              = PP_DO_TO_DN(
                                                    request->PhysicalDevice);
        if (    (deviceNode->Flags & DNF_RESOURCE_REQUIREMENTS_CHANGED) &&
                deviceNode->ResourceRequirements) {

            ExFreePool(deviceNode->ResourceRequirements);
            deviceNode->ResourceRequirements = NULL;
            deviceNode->Flags &= ~DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED;
            //
            // Mark that caller needs to clear DNF_RESOURCE_REQUIREMENTS_CHANGED
            // flag on success.
            //
            request->Flags |= IOP_ASSIGN_CLEAR_RESOURCE_REQUIREMENTS_CHANGE_FLAG;
        }
        if (!request->ResourceRequirements) {

            if (    deviceNode->ResourceRequirements &&
                    !(deviceNode->Flags & DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED)) {

                IopDbgPrint((   IOP_RESOURCE_VERBOSE_LEVEL,
                                "Resource requirements list already exists for "
                                "%wZ\n",
                                &deviceNode->InstancePath));

                request->ResourceRequirements   = deviceNode->ResourceRequirements;
                request->AllocationType         = ArbiterRequestPnpEnumerated;
            } else {

                IopDbgPrint((   IOP_RESOURCE_INFO_LEVEL,
                                "Query Resource requirements list for %wZ...\n",
                                &deviceNode->InstancePath));

                status = IopQueryDeviceResources(
                            request->PhysicalDevice,
                            QUERY_RESOURCE_REQUIREMENTS,
                            &request->ResourceRequirements,
                            &length);
                if (    !NT_SUCCESS(status) ||
                        !request->ResourceRequirements) {
                    //
                    // Success with NULL ResourceRequirements means no resource
                    // required.
                    //
                    request->Flags  |= IOP_ASSIGN_IGNORE;
                    request->Status = status;
                    continue;
                }
                if (deviceNode->ResourceRequirements) {

                    ExFreePool(deviceNode->ResourceRequirements);
                    deviceNode->Flags &= ~DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED;
                }
                deviceNode->ResourceRequirements = request->ResourceRequirements;
            }
        }
        //
        // For non-stop case, even though the res req list has changed, we need
        // to guarantee that it will get its current setting, even if the new
        // requirements do not cover the current setting.
        //
        if (request->Flags & IOP_ASSIGN_KEEP_CURRENT_CONFIG) {

            ASSERT(
                deviceNode->ResourceRequirements ==
                    request->ResourceRequirements);
            status = IopFilterResourceRequirementsList(
                         request->ResourceRequirements,
                         deviceNode->ResourceList,
                         &filteredList,
                         &exactMatch);
            if (NT_SUCCESS(status)) {
                //
                // No need to free the original request->ResourceRequirements
                // since its cached in deviceNode->ResourceRequirements.
                //
                request->ResourceRequirements = filteredList;
            } else {
                //
                // Clear the flag so we dont free request->ResourceRequirements.
                //
                request->Flags &= ~IOP_ASSIGN_KEEP_CURRENT_CONFIG;
            }
        }
        IopDumpResourceRequirementsList(request->ResourceRequirements);
        //
        // Convert the requirements list to our internal representation.
        //
        status = IopResourceRequirementsListToReqList(
                        request,
                        &request->ReqList);
        if (NT_SUCCESS(status) && request->ReqList) {

            reqList = (PREQ_LIST)request->ReqList;
            //
            // Sort the list such that higher priority alternatives are placed
            // in the front of the list.
            //
            IopRearrangeReqList(reqList);
            if (reqList->BestAlternative) {
                //
                // Requests from less flexible devices get higher priority.
                //
                request->Priority = (reqList->AlternativeCount < 3)?
                                        0 : reqList->AlternativeCount;
                request->Status = status;
                (*DeviceCount)++;
                continue;
            }
            //
            // This device has no soft configuration.
            //
            IopFreeResourceRequirementsForAssignTable(request, request + 1);
            status = STATUS_DEVICE_CONFIGURATION_ERROR;
        }

        request->Status = status;
        request->Flags  |= IOP_ASSIGN_IGNORE;
    }

    return (*DeviceCount)? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

NTSTATUS
IopResourceRequirementsListToReqList(
    IN  PIOP_RESOURCE_REQUEST   Request,
    OUT PVOID                   *ResReqList
    )

/*++

Routine Description:

    This routine processes the input Io resource requirements list and
    generates an internal REQ_LIST and its related structures.

Parameters:

    IoResources - supplies a pointer to the Io resource requirements List.

    PhysicalDevice - supplies a pointer to the physical device object requesting
            the resources.

    ReqList - supplies a pointer to a variable to receive the returned REQ_LIST.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PIO_RESOURCE_REQUIREMENTS_LIST  ioResources;
    LONG                            ioResourceListCount;
    PIO_RESOURCE_LIST               ioResourceList;
    PIO_RESOURCE_DESCRIPTOR         ioResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR         ioResourceDescriptorEnd;
    PIO_RESOURCE_DESCRIPTOR         firstDescriptor;
    PUCHAR                          coreEnd;
    BOOLEAN                         noAlternativeDescriptor;
    ULONG                           reqDescAlternativeCount;
    ULONG                           alternativeDescriptorCount;
    ULONG                           reqAlternativeCount;
    PREQ_LIST                       reqList;
    INTERFACE_TYPE                  interfaceType;
    ULONG                           busNumber;
    NTSTATUS                        status;
    NTSTATUS                        failureStatus;
    NTSTATUS                        finalStatus;

    PAGED_CODE();

    *ResReqList = NULL;
    //
    // Make sure there is some resource requirement to be converted.
    //
    ioResources         = Request->ResourceRequirements;
    ioResourceListCount = (LONG)ioResources->AlternativeLists;
    if (ioResourceListCount == 0) {

        IopDbgPrint((
            IOP_RESOURCE_INFO_LEVEL,
            "No ResReqList to convert to ReqList\n"));
        return STATUS_SUCCESS;
    }
    //
    // ***** Phase 1 *****
    //
    // Parse the requirements list to validate it and determine the sizes of
    // internal structures.
    //
    ioResourceList              = ioResources->List;
    coreEnd                     = (PUCHAR)ioResources + ioResources->ListSize;
    reqDescAlternativeCount     = 0;
    alternativeDescriptorCount  = 0;
    while (--ioResourceListCount >= 0) {

        ioResourceDescriptor    = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;
        if (ioResourceDescriptor == ioResourceDescriptorEnd) {
            //
            // An alternative list with zero descriptor count.
            //
            return STATUS_SUCCESS;
        }
        //
        // Perform sanity check. On failure, simply return failure status.
        //
        if (    ioResourceDescriptor > ioResourceDescriptorEnd ||
                (PUCHAR)ioResourceDescriptor > coreEnd ||
                (PUCHAR)ioResourceDescriptorEnd > coreEnd) {
            //
            // The structure header is invalid (excluding the variable length
            // Descriptors array) or,
            // IoResourceDescriptorEnd is the result of arithmetic overflow or,
            // the descriptor array is outside of the valid memory.
            //
            IopDbgPrint((IOP_RESOURCE_ERROR_LEVEL, "Invalid ResReqList\n"));
            goto InvalidParameter;
        }
        if (ioResourceDescriptor->Type == CmResourceTypeConfigData) {

            ioResourceDescriptor++;
        }
        firstDescriptor         = ioResourceDescriptor;
        noAlternativeDescriptor = TRUE;
        while (ioResourceDescriptor < ioResourceDescriptorEnd) {

            switch (ioResourceDescriptor->Type) {
            case CmResourceTypeConfigData:

                 IopDbgPrint((
                    IOP_RESOURCE_ERROR_LEVEL,
                    "Invalid ResReq list !!!\n"
                    "\tConfigData descriptors are per-LogConf and should be at "
                    "the beginning of an AlternativeList\n"));
                 goto InvalidParameter;

            case CmResourceTypeDevicePrivate:

                 while (    ioResourceDescriptor < ioResourceDescriptorEnd &&
                            ioResourceDescriptor->Type == CmResourceTypeDevicePrivate) {

                     if (ioResourceDescriptor == firstDescriptor) {

                        IopDbgPrint((
                            IOP_RESOURCE_ERROR_LEVEL,
                            "Invalid ResReq list !!!\n"
                            "\tThe first descriptor of a LogConf can not be a "
                            "DevicePrivate descriptor.\n"));
                        goto InvalidParameter;
                     }
                     reqDescAlternativeCount++;
                     ioResourceDescriptor++;
                 }
                 noAlternativeDescriptor = TRUE;
                 break;

            default:

                reqDescAlternativeCount++;
                //
                // For non-arbitrated resource type, set its Option to preferred
                // such that we won't get confused.
                //
                if (    (ioResourceDescriptor->Type & CmResourceTypeNonArbitrated) ||
                        ioResourceDescriptor->Type == CmResourceTypeNull) {

                    if (ioResourceDescriptor->Type == CmResourceTypeReserved) {

                        reqDescAlternativeCount--;
                    }
                    ioResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
                    ioResourceDescriptor++;
                    noAlternativeDescriptor = TRUE;
                    break;
                }
                if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {

                    if (noAlternativeDescriptor) {

                        IopDbgPrint((
                            IOP_RESOURCE_ERROR_LEVEL,
                            "Invalid ResReq list !!!\n"
                            "\tAlternative descriptor without Default or "
                            "Preferred descriptor.\n"));
                       goto InvalidParameter;
                    }
                    alternativeDescriptorCount++;
                } else {

                    noAlternativeDescriptor = FALSE;
                }
                ioResourceDescriptor++;
                break;
            }
        }
        ASSERT(ioResourceDescriptor == ioResourceDescriptorEnd);
        ioResourceList = (PIO_RESOURCE_LIST)ioResourceDescriptorEnd;
    }
    //
    // ***** Phase 2 *****
    //
    // Allocate structures and initialize them according to caller's Io ResReq list.
    //
    {
        ULONG               reqDescCount;
        IOP_POOL            reqAlternativePool;
        IOP_POOL            reqDescPool;
        ULONG               reqListPoolSize;
        ULONG               reqAlternativePoolSize;
        ULONG               reqDescPoolSize;
        PUCHAR              poolStart;
        ULONG               poolSize;
        IOP_POOL            outerPool;
        PREQ_ALTERNATIVE    reqAlternative;
        PPREQ_ALTERNATIVE   reqAlternativePP;
        ULONG               reqAlternativeIndex;
        PREQ_DESC           reqDesc;
        PREQ_DESC           *reqDescPP;
        ULONG               reqDescIndex;
        PARBITER_LIST_ENTRY arbiterListEntry;
#if DBG_SCOPE

        PPREQ_ALTERNATIVE   reqAlternativeEndPP;

#endif
        failureStatus           = STATUS_UNSUCCESSFUL;
        finalStatus             = STATUS_SUCCESS;
        ioResourceList          = ioResources->List;
        ioResourceListCount     = ioResources->AlternativeLists;
        reqAlternativeCount     = ioResourceListCount;
        reqDescCount            = reqDescAlternativeCount -
                                    alternativeDescriptorCount;
        reqDescPoolSize         = reqDescCount * sizeof(REQ_DESC);
        reqAlternativePoolSize  = reqAlternativeCount *
                                    (sizeof(REQ_ALTERNATIVE) +
                                        (reqDescCount - 1) *
                                            sizeof(PREQ_DESC));
        reqListPoolSize         = sizeof(REQ_LIST) +
                                    (reqAlternativeCount - 1) *
                                        sizeof(PREQ_ALTERNATIVE);
        poolSize = reqListPoolSize + reqAlternativePoolSize + reqDescPoolSize;
        if (!(poolStart = ExAllocatePoolRD(PagedPool | POOL_COLD_ALLOCATION, poolSize))) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }
        //
        // Initialize the main pool.
        //
        IopInitPool(&outerPool, poolStart, poolSize);
        //
        // First part of the pool is used by REQ_LIST.
        //
        IopAllocPool(&reqList, &outerPool, reqListPoolSize);
        //
        // Second part of the main pool is used by REQ_ALTERNATIVEs.
        //
        IopAllocPool(&poolStart, &outerPool, reqAlternativePoolSize);
        IopInitPool(&reqAlternativePool, poolStart, reqAlternativePoolSize);
        //
        // Last part of the main pool is used by REQ_DESCs.
        //
        IopAllocPool(&poolStart, &outerPool, reqDescPoolSize);
        IopInitPool(&reqDescPool, poolStart, reqDescPoolSize);
        if (ioResources->InterfaceType == InterfaceTypeUndefined) {

            interfaceType = PnpDefaultInterfaceType;
        } else {

            interfaceType = ioResources->InterfaceType;
        }
        busNumber = ioResources->BusNumber;
        //
        // Initialize REQ_LIST.
        //
        reqList->AlternativeCount       = reqAlternativeCount;
        reqList->Request                = Request;
        reqList->BusNumber              = busNumber;
        reqList->InterfaceType          = interfaceType;
        reqList->SelectedAlternative    = NULL;
        //
        // Initialize memory for REQ_ALTERNATIVEs.
        //
        reqAlternativePP = reqList->AlternativeTable;
        RtlZeroMemory(
            reqAlternativePP,
            reqAlternativeCount * sizeof(PREQ_ALTERNATIVE));
#if DBG_SCOPE
        reqAlternativeEndPP = reqAlternativePP + reqAlternativeCount;
#endif
        reqAlternativeIndex = 0;
        while (--ioResourceListCount >= 0) {

            ioResourceDescriptor    = ioResourceList->Descriptors;
            ioResourceDescriptorEnd = ioResourceDescriptor +
                                        ioResourceList->Count;
            IopAllocPool(
                &reqAlternative,
                &reqAlternativePool,
                FIELD_OFFSET(REQ_ALTERNATIVE, DescTable));
            ASSERT(reqAlternativePP < reqAlternativeEndPP);
            *reqAlternativePP++ = reqAlternative;
            reqAlternative->ReqList             = reqList;
            reqAlternative->ReqAlternativeIndex = reqAlternativeIndex++;
            reqAlternative->DescCount           = 0;
            //
            // First descriptor of CmResourceTypeConfigData contains priority
            // information.
            //
            if (ioResourceDescriptor->Type == CmResourceTypeConfigData) {

                reqAlternative->Priority = ioResourceDescriptor->u.ConfigData.Priority;
                ioResourceDescriptor++;
            } else {

                reqAlternative->Priority = LCPRI_NORMAL;
            }
            reqDescPP = reqAlternative->DescTable;
            reqDescIndex = 0;
            while (ioResourceDescriptor < ioResourceDescriptorEnd) {

                if (ioResourceDescriptor->Type == CmResourceTypeReserved) {

                    interfaceType = ioResourceDescriptor->u.DevicePrivate.Data[0];
                    if (interfaceType == InterfaceTypeUndefined) {

                        interfaceType = PnpDefaultInterfaceType;
                    }
                    busNumber = ioResourceDescriptor->u.DevicePrivate.Data[1];
                    ioResourceDescriptor++;
                } else {
                    //
                    // Allocate and initialize REQ_DESC.
                    //
                    IopAllocPool(&reqDesc, &reqDescPool, sizeof(REQ_DESC));
                    reqAlternative->DescCount++;
                    *reqDescPP++                    = reqDesc;
                    reqDesc->ReqAlternative         = reqAlternative;
                    reqDesc->TranslatedReqDesc      = reqDesc;
                    reqDesc->ReqDescIndex           = reqDescIndex++;
                    reqDesc->DevicePrivateCount     = 0;
                    reqDesc->DevicePrivate          = NULL;
                    reqDesc->InterfaceType          = interfaceType;
                    reqDesc->BusNumber              = busNumber;
                    reqDesc->ArbitrationRequired    =
                        (ioResourceDescriptor->Type & CmResourceTypeNonArbitrated ||
                            ioResourceDescriptor->Type == CmResourceTypeNull)?
                                FALSE : TRUE;
                    //
                    // Allocate and initialize arbiter entry for this REQ_DESC.
                    //
                    IopAllocPool(&poolStart, &reqAlternativePool, sizeof(PVOID));
                    ASSERT((PREQ_DESC*)poolStart == (reqDescPP - 1));
                    arbiterListEntry = &reqDesc->AlternativeTable;
                    InitializeListHead(&arbiterListEntry->ListEntry);
                    arbiterListEntry->AlternativeCount      = 0;
                    arbiterListEntry->Alternatives          = ioResourceDescriptor;
                    arbiterListEntry->PhysicalDeviceObject  = Request->PhysicalDevice;
                    arbiterListEntry->RequestSource         = Request->AllocationType;
                    arbiterListEntry->WorkSpace             = 0;
                    arbiterListEntry->InterfaceType         = interfaceType;
                    arbiterListEntry->SlotNumber            = ioResources->SlotNumber;
                    arbiterListEntry->BusNumber             = ioResources->BusNumber;
                    arbiterListEntry->Assignment            = &reqDesc->Allocation;
                    arbiterListEntry->Result                = ArbiterResultUndefined;
                    arbiterListEntry->Flags =
                            (reqAlternative->Priority != LCPRI_BOOTCONFIG)?
                                0 : ARBITER_FLAG_BOOT_CONFIG;
                    if (reqDesc->ArbitrationRequired) {
                        //
                        // The BestAlternativeTable and BestAllocation are not initialized.
                        // They will be initialized when needed.

                        //
                        // Initialize the Cm partial resource descriptor to NOT_ALLOCATED.
                        //
                        reqDesc->Allocation.Type = CmResourceTypeMaximum;

                        ASSERT((ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) == 0);

                        arbiterListEntry->AlternativeCount++;
                        ioResourceDescriptor++;
                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {

                            if (ioResourceDescriptor->Type == CmResourceTypeDevicePrivate) {

                                reqDesc->DevicePrivate = ioResourceDescriptor;
                                while ( ioResourceDescriptor < ioResourceDescriptorEnd &&
                                        ioResourceDescriptor->Type == CmResourceTypeDevicePrivate) {

                                    reqDesc->DevicePrivateCount++;
                                    ioResourceDescriptor++;
                                }
                                break;
                            }
                            if (!(ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE)) {

                                break;
                            }
                            arbiterListEntry->AlternativeCount++;
                            ioResourceDescriptor++;
                        }
                        //
                        // Next query Arbiter and Translator interfaces for the
                        // resource descriptor.
                        //
                        status = IopSetupArbiterAndTranslators(reqDesc);
                        if (!NT_SUCCESS(status)) {

                            IopDbgPrint((
                                IOP_RESOURCE_ERROR_LEVEL, "Unable to setup "
                                "Arbiter and Translators\n"));
                            reqAlternativeIndex--;
                            reqAlternativePP--;
                            reqList->AlternativeCount--;
                            IopFreeReqAlternative(reqAlternative);
                            failureStatus = status;
                            break;
                        }
                    } else {

                        reqDesc->Allocation.Type    = ioResourceDescriptor->Type;
                        reqDesc->Allocation.ShareDisposition =
                            ioResourceDescriptor->ShareDisposition;
                        reqDesc->Allocation.Flags   = ioResourceDescriptor->Flags;
                        reqDesc->Allocation.u.DevicePrivate.Data[0] =
                            ioResourceDescriptor->u.DevicePrivate.Data[0];
                        reqDesc->Allocation.u.DevicePrivate.Data[1] =
                            ioResourceDescriptor->u.DevicePrivate.Data[1];
                        reqDesc->Allocation.u.DevicePrivate.Data[2] =
                            ioResourceDescriptor->u.DevicePrivate.Data[2];
                        ioResourceDescriptor++;
                    }
                }
                if (ioResourceDescriptor >= ioResourceDescriptorEnd) {

                    break;
                }
            }
            ioResourceList = (PIO_RESOURCE_LIST)ioResourceDescriptorEnd;
        }
        if (reqAlternativeIndex == 0) {

            finalStatus = failureStatus;
            IopFreeReqList(reqList);
        }
    }

    if (finalStatus == STATUS_SUCCESS) {

        *ResReqList = reqList;
    }
    return finalStatus;

InvalidParameter:

    return STATUS_INVALID_PARAMETER;
}

int
__cdecl
IopCompareReqAlternativePriority (
    const void *arg1,
    const void *arg2
    )

/*++

Routine Description:

    This function is used in C run time sort. It compares the priority of
    REQ_ALTERNATIVE in arg1 and arg2.

Parameters:

    arg1    - LHS PREQ_ALTERNATIVE

    arg2    - RHS PREQ_ALTERNATIVE

Return Value:

    < 0 if arg1 < arg2
    = 0 if arg1 = arg2
    > 0 if arg1 > arg2

--*/

{
    PREQ_ALTERNATIVE ra1 = *(PPREQ_ALTERNATIVE)arg1;
    PREQ_ALTERNATIVE ra2 = *(PPREQ_ALTERNATIVE)arg2;

    PAGED_CODE();

    if (ra1->Priority == ra2->Priority) {

        if (ra1->Position > ra2->Position) {

            return 1;
        } else if (ra1->Position < ra2->Position) {

            return -1;
        } else {

            ASSERT(0);
            if ((ULONG_PTR)ra1 < (ULONG_PTR)ra2) {

                return -1;
            } else {

                return 1;
            }
        }
    }
    if (ra1->Priority > ra2->Priority) {

        return 1;
    } else {

        return -1;
    }
}

int
__cdecl
IopCompareResourceRequestPriority (
    const void *arg1,
    const void *arg2
    )

/*++

    This function is used in C run time sort. It compares the priority of
    IOP_RESOURCE_REQUEST in arg1 and arg2.

Parameters:

    arg1    - LHS PIOP_RESOURCE_REQUEST

    arg2    - RHS PIOP_RESOURCE_REQUEST

Return Value:

    < 0 if arg1 < arg2
    = 0 if arg1 = arg2
    > 0 if arg1 > arg2

--*/

{
    PIOP_RESOURCE_REQUEST rr1 = (PIOP_RESOURCE_REQUEST)arg1;
    PIOP_RESOURCE_REQUEST rr2 = (PIOP_RESOURCE_REQUEST)arg2;

    PAGED_CODE();

    if (rr1->Priority == rr2->Priority) {

        if (rr1->Position > rr2->Position) {

            return 1;
        } else if (rr1->Position < rr2->Position) {

            return -1;
        } else {

            ASSERT(0);
            if ((ULONG_PTR)rr1 < (ULONG_PTR)rr2) {

                return -1;
            } else {

                return 1;
            }
        }
    }
    if (rr1->Priority > rr2->Priority) {

        return 1;
    } else {

        return -1;
    }
}

VOID
IopRearrangeReqList (
    IN PREQ_LIST ReqList
    )

/*++

Routine Description:

    This routine sorts the REQ_LIST in ascending priority order of
    REQ_ALTERNATIVES.

Parameters:

    ReqList - Pointer to the REQ_LIST to be sorted.

Return Value:

    None.

--*/

{
    PPREQ_ALTERNATIVE alternative;
    PPREQ_ALTERNATIVE lastAlternative;
    ULONG i;

    PAGED_CODE();

    if (ReqList->AlternativeCount > 1) {

        for (i = 0; i < ReqList->AlternativeCount; i++) {

            ReqList->AlternativeTable[i]->Position = i;
        }
        qsort(
            (void *)ReqList->AlternativeTable,
            ReqList->AlternativeCount,
            sizeof(PREQ_ALTERNATIVE),
            IopCompareReqAlternativePriority);
    }
    //
    // Set the BestAlternative so that we try alternatives with
    // priority <= LCPRI_LASTSOFTCONFIG.
    //
    alternative = &ReqList->AlternativeTable[0];
    for (   lastAlternative = alternative + ReqList->AlternativeCount;
            alternative < lastAlternative;
            alternative++) {

        if ((*alternative)->Priority > LCPRI_LASTSOFTCONFIG) {

            break;
        }
    }

    if (alternative == &ReqList->AlternativeTable[0]) {

        PDEVICE_NODE deviceNode;

        deviceNode = PP_DO_TO_DN(ReqList->Request->PhysicalDevice);
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Invalid priorities in the logical configs for %wZ\n",
            &deviceNode->InstancePath));
        ReqList->BestAlternative = NULL;
    } else {

        ReqList->BestAlternative = alternative;
    }
}

VOID
IopRearrangeAssignTable (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    Count
    )

/*++

Routine Description:

    This routine sorts the resource requirements table in ascending priority
    order.

Parameters:

    RequestTable    - Table of resources requests to be sorted.

    Count           - Length of the RequestTable.

Return Value:

    None.

--*/

{
    ULONG   i;

    PAGED_CODE();

    if (Count > 1) {

        if (PpCallerInitializesRequestTable == FALSE) {

            for (i = 0; i < Count; i++) {

                RequestTable[i].Position = i;
            }
        }
        qsort(
            (void *)RequestTable,
            Count,
            sizeof(IOP_RESOURCE_REQUEST),
            IopCompareResourceRequestPriority);
    }
}

VOID
IopBuildCmResourceList (
    IN PIOP_RESOURCE_REQUEST AssignEntry
    )
/*++

Routine Description:

    This routine walks REQ_LIST of the AssignEntry to build a corresponding
    Cm Resource lists.  It also reports the resources to ResourceMap.

Parameters:

    AssignEntry - Supplies a pointer to an IOP_ASSIGN_REQUEST structure

Return Value:

    None.  The ResourceAssignment in AssignEntry is initialized.

--*/

{
    NTSTATUS status;
    HANDLE resourceMapKey;
    PDEVICE_OBJECT physicalDevice;
    PREQ_LIST reqList = AssignEntry->ReqList;
    PREQ_ALTERNATIVE reqAlternative;
    PREQ_DESC reqDesc, reqDescx;
    PIO_RESOURCE_DESCRIPTOR privateData;
    ULONG count = 0, size, i;
    PCM_RESOURCE_LIST cmResources, cmResourcesRaw;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullResource, cmFullResourceRaw;
    PCM_PARTIAL_RESOURCE_LIST cmPartialList, cmPartialListRaw;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptor, cmDescriptorRaw, assignment, tAssignment;
#if DBG_SCOPE
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptorEnd, cmDescriptorEndRaw;
#endif

    PAGED_CODE();

    //
    // Determine the size of the CmResourceList
    //
    reqAlternative = *reqList->SelectedAlternative;
    for (i = 0; i < reqAlternative->DescCount; i++) {

        reqDesc = reqAlternative->DescTable[i];
        count += reqDesc->DevicePrivateCount + 1;
    }

    size = sizeof(CM_RESOURCE_LIST) + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * (count - 1);
    cmResources = (PCM_RESOURCE_LIST) ExAllocatePoolCMRL(PagedPool, size);
    if (!cmResources) {
        //
        // If we can not find memory, the resources will not be committed by arbiter.
        //
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not enough memory to build Translated CmResourceList\n"));

        AssignEntry->Status = STATUS_INSUFFICIENT_RESOURCES;
        AssignEntry->ResourceAssignment = NULL;
        AssignEntry->TranslatedResourceAssignment = NULL;
        return;
    }
    cmResourcesRaw = (PCM_RESOURCE_LIST) ExAllocatePoolCMRR(PagedPool, size);
    if (!cmResourcesRaw) {

        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not enough memory to build Raw CmResourceList\n"));

        ExFreePool(cmResources);
        AssignEntry->Status = STATUS_INSUFFICIENT_RESOURCES;
        AssignEntry->ResourceAssignment = NULL;
        AssignEntry->TranslatedResourceAssignment = NULL;
        return;
    }
    cmResources->Count = 1;
    cmFullResource = cmResources->List;
    //
    // The CmResourceList we build here does not distinguish the
    // Interface Type on descriptor level.  This should be fine because
    // for IoReportResourceUsage we ignore the CmResourceList we build
    // here.
    //
    cmFullResource->InterfaceType = reqList->InterfaceType;
    cmFullResource->BusNumber = reqList->BusNumber;
    cmPartialList = &cmFullResource->PartialResourceList;
    cmPartialList->Version = 1;
    cmPartialList->Revision = 1;
    cmPartialList->Count = count;
    cmDescriptor = cmPartialList->PartialDescriptors;
#if DBG_SCOPE
    cmDescriptorEnd = cmDescriptor + count;
#endif
    cmResourcesRaw->Count = 1;
    cmFullResourceRaw = cmResourcesRaw->List;
    cmFullResourceRaw->InterfaceType = reqList->InterfaceType;
    cmFullResourceRaw->BusNumber = reqList->BusNumber;
    cmPartialListRaw = &cmFullResourceRaw->PartialResourceList;
    cmPartialListRaw->Version = 1;
    cmPartialListRaw->Revision = 1;
    cmPartialListRaw->Count = count;
    cmDescriptorRaw = cmPartialListRaw->PartialDescriptors;
#if DBG_SCOPE
    cmDescriptorEndRaw = cmDescriptorRaw + count;
#endif

    for (i = 0; i < reqAlternative->DescCount; i++) {

        reqDesc = reqAlternative->DescTable[i];

        if (reqDesc->ArbitrationRequired) {
            //
            // Get raw assignment and copy it to our raw resource list
            //
            reqDescx = reqDesc->TranslatedReqDesc;
            if (reqDescx->AlternativeTable.Result != ArbiterResultNullRequest) {

                status = IopParentToRawTranslation(reqDescx);
                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((
                        IOP_RESOURCE_WARNING_LEVEL,
                        "Parent To Raw translation failed\n"));
                    ExFreePool(cmResources);
                    ExFreePool(cmResourcesRaw);
                    AssignEntry->Status = STATUS_INSUFFICIENT_RESOURCES;
                    AssignEntry->ResourceAssignment = NULL;
                    return;
                }
                assignment = reqDesc->AlternativeTable.Assignment;
            } else {
                assignment = reqDescx->AlternativeTable.Assignment;
            }
            *cmDescriptorRaw = *assignment;
            cmDescriptorRaw++;

            //
            // Translate assignment and copy it to our translated resource list
            //
            if (reqDescx->AlternativeTable.Result != ArbiterResultNullRequest) {
                status = IopChildToRootTranslation(
                            PP_DO_TO_DN(reqDesc->AlternativeTable.PhysicalDeviceObject),
                            reqDesc->InterfaceType,
                            reqDesc->BusNumber,
                            reqDesc->AlternativeTable.RequestSource,
                            &reqDesc->Allocation,
                            &tAssignment
                            );
                if (!NT_SUCCESS(status)) {
                    IopDbgPrint((
                        IOP_RESOURCE_WARNING_LEVEL,
                        "Child to Root translation failed\n"));
                    ExFreePool(cmResources);
                    ExFreePool(cmResourcesRaw);
                    AssignEntry->Status = STATUS_INSUFFICIENT_RESOURCES;
                    AssignEntry->ResourceAssignment = NULL;
                    return;
                }
                *cmDescriptor = *tAssignment;
                ExFreePool(tAssignment);
            } else {
                *cmDescriptor = *(reqDescx->AlternativeTable.Assignment);
            }
            cmDescriptor++;

        } else {
            *cmDescriptorRaw = reqDesc->Allocation;
            *cmDescriptor = reqDesc->Allocation;
            cmDescriptorRaw++;
            cmDescriptor++;
        }

        //
        // Next copy the device private descriptors to CmResourceLists
        //

        count = reqDesc->DevicePrivateCount;
        privateData = reqDesc->DevicePrivate;
        while (count != 0) {

            cmDescriptor->Type = cmDescriptorRaw->Type = CmResourceTypeDevicePrivate;
            cmDescriptor->ShareDisposition = cmDescriptorRaw->ShareDisposition =
                         CmResourceShareDeviceExclusive;
            cmDescriptor->Flags = cmDescriptorRaw->Flags = privateData->Flags;
            RtlMoveMemory(&cmDescriptorRaw->u.DevicePrivate,
                          &privateData->u.DevicePrivate,
                          sizeof(cmDescriptorRaw->u.DevicePrivate.Data)
                          );
            RtlMoveMemory(&cmDescriptor->u.DevicePrivate,
                          &privateData->u.DevicePrivate,
                          sizeof(cmDescriptor->u.DevicePrivate.Data)
                          );
            privateData++;
            cmDescriptorRaw++;
            cmDescriptor++;
            count--;
            ASSERT(cmDescriptorRaw <= cmDescriptorEndRaw);
            ASSERT(cmDescriptor <= cmDescriptorEnd);
        }
        ASSERT(cmDescriptor <= cmDescriptorEnd);
        ASSERT(cmDescriptorRaw <= cmDescriptorEndRaw);

    }

    //
    // report assigned resources to ResourceMap
    //

    physicalDevice = AssignEntry->PhysicalDevice;

    //
    // Open ResourceMap key
    //

    status = IopCreateRegistryKeyEx( &resourceMapKey,
                                     (HANDLE) NULL,
                                     &CmRegistryMachineHardwareResourceMapName,
                                     KEY_READ | KEY_WRITE,
                                     REG_OPTION_VOLATILE,
                                     NULL
                                     );
    if (NT_SUCCESS(status )) {
        WCHAR DeviceBuffer[256];
        POBJECT_NAME_INFORMATION NameInformation;
        ULONG NameLength;
        UNICODE_STRING UnicodeClassName;
        UNICODE_STRING UnicodeDriverName;
        UNICODE_STRING UnicodeDeviceName;

        PiWstrToUnicodeString(&UnicodeClassName, PNPMGR_STR_PNP_MANAGER);

        PiWstrToUnicodeString(&UnicodeDriverName, REGSTR_KEY_PNP_DRIVER);

        NameInformation = (POBJECT_NAME_INFORMATION) DeviceBuffer;
        status = ObQueryNameString( physicalDevice,
                                    NameInformation,
                                    sizeof( DeviceBuffer ),
                                    &NameLength );
        if (NT_SUCCESS(status)) {
            NameInformation->Name.MaximumLength = sizeof(DeviceBuffer) - sizeof(OBJECT_NAME_INFORMATION);
            if (NameInformation->Name.Length == 0) {
                NameInformation->Name.Buffer = (PVOID)((ULONG_PTR)DeviceBuffer + sizeof(OBJECT_NAME_INFORMATION));
            }

            UnicodeDeviceName = NameInformation->Name;
            RtlAppendUnicodeToString(&UnicodeDeviceName, IopWstrRaw);

            //
            // IopWriteResourceList should remove all the device private and device
            // specifiec descriptors.
            //

            status = IopWriteResourceList(
                         resourceMapKey,
                         &UnicodeClassName,
                         &UnicodeDriverName,
                         &UnicodeDeviceName,
                         cmResourcesRaw,
                         size
                         );
            if (NT_SUCCESS(status)) {
                UnicodeDeviceName = NameInformation->Name;
                RtlAppendUnicodeToString (&UnicodeDeviceName, IopWstrTranslated);
                status = IopWriteResourceList(
                             resourceMapKey,
                             &UnicodeClassName,
                             &UnicodeDriverName,
                             &UnicodeDeviceName,
                             cmResources,
                             size
                             );
            }
        }
        ZwClose(resourceMapKey);
    }
    AssignEntry->ResourceAssignment = cmResourcesRaw;
    AssignEntry->TranslatedResourceAssignment = cmResources;
}

VOID
IopBuildCmResourceLists(
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN PIOP_RESOURCE_REQUEST AssignTableEnd
    )

/*++

Routine Description:

    For each AssignTable entry, this routine queries device's IO resource requirements
    list and converts it to our internal REQ_LIST format.

Parameters:

    AssignTable - supplies a pointer to the first entry of a IOP_RESOURCE_REQUEST table.

    AssignTableEnd - supplies a pointer to the end of IOP_RESOURCE_REQUEST table.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PIOP_RESOURCE_REQUEST assignEntry;
    PDEVICE_OBJECT physicalDevice;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    //
    // Go thru each entry, for each Physical device object, we build a CmResourceList
    // from its ListOfAssignedResources.
    //
    for (assignEntry = AssignTable; assignEntry < AssignTableEnd; ++assignEntry) {

        assignEntry->ResourceAssignment = NULL;
        if (assignEntry->Flags & IOP_ASSIGN_IGNORE || assignEntry->Flags & IOP_ASSIGN_RETRY) {

            continue;
        }
        if (assignEntry->Flags & IOP_ASSIGN_EXCLUDE) {

            assignEntry->Status = STATUS_UNSUCCESSFUL;
            continue;
        }
        assignEntry->Status = STATUS_SUCCESS;

        IopBuildCmResourceList (assignEntry);

        if (assignEntry->ResourceAssignment) {

            physicalDevice = assignEntry->PhysicalDevice;
            deviceNode = PP_DO_TO_DN(physicalDevice);
            IopWriteAllocatedResourcesToRegistry(
                  deviceNode,
                  assignEntry->ResourceAssignment,
                  IopDetermineResourceListSize(assignEntry->ResourceAssignment)
                  );

            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Building CM resource lists for %ws...\n",
                deviceNode->InstancePath.Buffer));

            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Raw resources "));

            IopDumpCmResourceList(assignEntry->ResourceAssignment);

            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Translated resources "));

            IopDumpCmResourceList(assignEntry->TranslatedResourceAssignment);
        }
    }
}

BOOLEAN
IopNeedToReleaseBootResources(
    IN PDEVICE_NODE DeviceNode,
    IN PCM_RESOURCE_LIST AllocatedResources
    )

/*++

Routine Description:

    This routine checks the AllocatedResources against boot allocated resources.
    If the allocated resources do not cover all the resource types in boot resources,
    in another words some types of boot resources have not been released by arbiter,
    we will return TRUE to indicate we need to release the boot resources manually.

Parameters:

    DeviceNode -  A device node

    AllocatedResources - the resources assigned to the devicenode by arbiters.

Return Value:

    TRUE or FALSE.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc_a, cmFullDesc_b;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptor_a, cmDescriptor_b;
    ULONG size_a, size_b, i, j, k;
    BOOLEAN returnValue = FALSE, found;
    PCM_RESOURCE_LIST bootResources;

    PAGED_CODE();

    bootResources = DeviceNode->BootResources;
    if (AllocatedResources->Count == 1 && bootResources && bootResources->Count != 0) {

        cmFullDesc_a = &AllocatedResources->List[0];
        cmFullDesc_b = &bootResources->List[0];
        for (i = 0; i < bootResources->Count; i++) {

            cmDescriptor_b = &cmFullDesc_b->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < cmFullDesc_b->PartialResourceList.Count; j++) {

                size_b = 0;
                switch (cmDescriptor_b->Type) {
                
                case CmResourceTypeNull:
                    break;

                case CmResourceTypeDeviceSpecific:
                     size_b = cmDescriptor_b->u.DeviceSpecificData.DataSize;
                     break;

                default:
                     if (cmDescriptor_b->Type < CmResourceTypeMaximum) {

                         found = FALSE;
                         cmDescriptor_a = &cmFullDesc_a->PartialResourceList.PartialDescriptors[0];
                         for (k = 0; k < cmFullDesc_a->PartialResourceList.Count; k++) {

                             size_a = 0;
                             if (cmDescriptor_a->Type == CmResourceTypeDeviceSpecific) {

                                 size_a = cmDescriptor_a->u.DeviceSpecificData.DataSize;
                             } else if (cmDescriptor_b->Type == cmDescriptor_a->Type) {

                                 found = TRUE;
                                 break;
                             }
                             cmDescriptor_a++;
                             cmDescriptor_a = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor_a + size_a);
                         }
                         if (found == FALSE) {

                             returnValue = TRUE;
                             goto exit;
                         }
                     }
                }
                cmDescriptor_b++;
                cmDescriptor_b = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor_b + size_b);
            }
            cmFullDesc_b = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDescriptor_b;
        }
    }

exit:

    return returnValue;
}

VOID
IopReleaseFilteredBootResources(
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN PIOP_RESOURCE_REQUEST AssignTableEnd
    )

/*++

Routine Description:

    For each AssignTable entry, this routine checks if we need to manually release the device's
    boot resources.

Parameters:

    AssignTable - supplies a pointer to the first entry of a IOP_RESOURCE_REQUEST table.

    AssignTableEnd - supplies a pointer to the end of IOP_RESOURCE_REQUEST table.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PIOP_RESOURCE_REQUEST assignEntry;
    PDEVICE_OBJECT physicalDevice;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    //
    // Go thru each entry, for each Physical device object, we build a CmResourceList
    // from its ListOfAssignedResources.
    //

    for (assignEntry = AssignTable; assignEntry < AssignTableEnd; ++assignEntry) {

        if (assignEntry->ResourceAssignment) {

            physicalDevice = assignEntry->PhysicalDevice;
            deviceNode = PP_DO_TO_DN(physicalDevice);
            //
            // Release the device's boot resources if desired
            // (If a driver filters its res req list and removes some boot resources, after arbiter satisfies
            // the new res req list, the filtered out boot resources do not get
            // released by arbiters.  Because they no longer passed to arbiters. )
            // I am not 100% sure we should release the filtered boot resources.  But that's what arbiters try
            // to achieve.  So, we will do it.
            //
            if (IopNeedToReleaseBootResources(deviceNode, assignEntry->ResourceAssignment)) {

                IopReleaseResourcesInternal(deviceNode);
                //
                // Since we released some resources, try to satisfy devices
                // with resource conflict.
                //
                PipRequestDeviceAction(NULL, AssignResources, FALSE, 0, NULL, NULL);

                IopAllocateBootResourcesInternal(
                        ArbiterRequestPnpEnumerated,
                        physicalDevice,
                        assignEntry->ResourceAssignment);
                deviceNode->Flags &= ~DNF_BOOT_CONFIG_RESERVED;  // Keep DeviceNode->BootResources
                deviceNode->ResourceList = assignEntry->ResourceAssignment;

                status = IopRestoreResourcesInternal(deviceNode);
                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((
                        IOP_RESOURCE_WARNING_LEVEL,
                        "Possible boot conflict on %ws\n",
                        deviceNode->InstancePath.Buffer));
                    ASSERT(status == STATUS_SUCCESS);

                    assignEntry->Flags = IOP_ASSIGN_EXCLUDE;
                    assignEntry->Status = status;

                    ExFreePool(assignEntry->ResourceAssignment);
                    assignEntry->ResourceAssignment = NULL;
                }
                deviceNode->ResourceList = NULL;
            }
        }
    }
}

NTSTATUS
IopSetupArbiterAndTranslators(
    IN PREQ_DESC ReqDesc
    )

/*++

Routine Description:

    This routine searches the arbiter and translators which arbitrates and translate
    the resources for the specified device.  This routine tries to find all the
    translator on the path of current device node to root device node

Parameters:

    ReqDesc - supplies a pointer to REQ_DESC which contains all the required information

Return Value:

    NTSTATUS value to indicate success or failure.

--*/

{
    PLIST_ENTRY listHead;
    PPI_RESOURCE_ARBITER_ENTRY arbiterEntry;
    PDEVICE_OBJECT deviceObject = ReqDesc->AlternativeTable.PhysicalDeviceObject;
    PDEVICE_NODE deviceNode;
    PREQ_DESC reqDesc = ReqDesc, translatedReqDesc;
    BOOLEAN found, arbiterFound = FALSE, restartedAlready;
    BOOLEAN  searchTranslator = TRUE, translatorFound = FALSE;
    NTSTATUS status;
    PPI_RESOURCE_TRANSLATOR_ENTRY translatorEntry;
    UCHAR resourceType = ReqDesc->TranslatedReqDesc->AlternativeTable.Alternatives->Type;
    PINTERFACE interface;
    USHORT resourceMask;

    if ((ReqDesc->AlternativeTable.RequestSource == ArbiterRequestHalReported) &&
        (ReqDesc->InterfaceType == Internal)) {

        // Trust hal if it says internal bus.

        restartedAlready = TRUE;
    } else {
        restartedAlready = FALSE;
    }

    //
    // If ReqDesc contains DeviceObject, this is for regular resources allocation
    // or boot resources preallocation.  Otherwise, it is for resources reservation.
    //

    if (deviceObject && ReqDesc->AlternativeTable.RequestSource != ArbiterRequestHalReported) {
        deviceNode = PP_DO_TO_DN(deviceObject);
        // We want to start with the deviceNode instead of its parent.  Because the
        // deviceNode may provide a translator interface.
        // deviceNode = deviceNode->Parent;
    } else {

        //
        // For resource reservation, we always need to find the arbiter and translators
        // so set the device node to Root.
        //

        deviceNode = IopRootDeviceNode;
    }
    while (deviceNode) {
        if ((deviceNode == IopRootDeviceNode) && (translatorFound == FALSE)) {

            //
            // If we reach the root and have not find any translator, the device is on the
            // wrong way.
            //

            if (restartedAlready == FALSE) {
                restartedAlready = TRUE;

                deviceNode = IopFindLegacyBusDeviceNode (
                                 ReqDesc->InterfaceType,
                                 ReqDesc->BusNumber
                                 );

                //
                // If we did not find a PDO, try again with InterfaceType == Isa. This allows
                // drivers that request Internal to get resources even if there is no PDO
                // that is Internal. (but if there is an Internal PDO, they get that one)
                //

                if ((deviceNode == IopRootDeviceNode) &&
                    (ReqDesc->ReqAlternative->ReqList->InterfaceType == Internal)) {
                    deviceNode = IopFindLegacyBusDeviceNode(
                                 Isa,
                                 0
                                 );
                }

                //if ((PVOID)deviceNode == deviceObject->DeviceObjectExtension->DeviceNode) {
                //    deviceNode = IopRootDeviceNode;
                //} else {
                    continue;
                //}
            }
        }

        //
        // Check is there an arbiter for the device node?
        //   if yes, set up ReqDesc->u.Arbiter and set ArbiterFound to true.
        //   else move up to the parent of current device node.
        //

        if ((arbiterFound == FALSE) && (deviceNode->PhysicalDeviceObject != deviceObject)) {
            found = IopFindResourceHandlerInfo(
                               ResourceArbiter,
                               deviceNode,
                               resourceType,
                               &arbiterEntry);
            if (found == FALSE) {

                //
                // no information found on arbiter.  Try to query translator interface ...
                //

                if (resourceType <= PI_MAXIMUM_RESOURCE_TYPE_TRACKED) {
                    resourceMask = 1 << resourceType;
                } else {
                    resourceMask = 0;
                }
                status = IopQueryResourceHandlerInterface(ResourceArbiter,
                                                          deviceNode->PhysicalDeviceObject,
                                                          resourceType,
                                                          &interface);
                deviceNode->QueryArbiterMask |= resourceMask;
                if (!NT_SUCCESS(status)) {
                    deviceNode->NoArbiterMask |= resourceMask;
                    if (resourceType <= PI_MAXIMUM_RESOURCE_TYPE_TRACKED) {
                        found = TRUE;
                    } else {
                        interface = NULL;
                    }
                }
                if (found == FALSE) {
                    arbiterEntry = (PPI_RESOURCE_ARBITER_ENTRY)ExAllocatePoolAE(
                                       PagedPool | POOL_COLD_ALLOCATION,
                                       sizeof(PI_RESOURCE_ARBITER_ENTRY));
                    if (!arbiterEntry) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        return status;
                    }
                    IopInitializeArbiterEntryState(arbiterEntry);
                    InitializeListHead(&arbiterEntry->DeviceArbiterList);
                    arbiterEntry->ResourceType      = resourceType;
                    arbiterEntry->Level             = deviceNode->Level;
                    listHead = &deviceNode->DeviceArbiterList;
                    InsertTailList(listHead, &arbiterEntry->DeviceArbiterList);
                    arbiterEntry->ArbiterInterface = (PARBITER_INTERFACE)interface;
                    if (!interface) {

                        //
                        // if interface is NULL we really don't have translator.
                        //

                        arbiterEntry = NULL;
                    }
                }
            }

            //
            // If there is an desired resourcetype arbiter in the device node, make sure
            // it handle this resource requriements.
            //

            if (arbiterEntry) {
                arbiterFound = TRUE;
                if (arbiterEntry->ArbiterInterface->Flags & ARBITER_PARTIAL) {

                    //
                    // If the arbiter is partial, ask if it handles the resources
                    // if not, goto its parent.
                    //

                    status = IopCallArbiter(
                                arbiterEntry,
                                ArbiterActionQueryArbitrate,
                                ReqDesc->TranslatedReqDesc,
                                NULL,
                                NULL
                                );
                    if (!NT_SUCCESS(status)) {
                        arbiterFound = FALSE;
                    }
                }
            }
            if (arbiterFound) {
                ReqDesc->u.Arbiter = arbiterEntry;

                //
                // Initialize the arbiter entry
                //

                arbiterEntry->State = 0;
                arbiterEntry->ResourcesChanged = FALSE;
            }

        }

        if (searchTranslator) {
            //
            // First, check if there is a translator for the device node?
            // If yes, translate the req desc and link it to the front of ReqDesc->TranslatedReqDesc
            // else do nothing.
            //

            found = IopFindResourceHandlerInfo(
                        ResourceTranslator,
                        deviceNode,
                        resourceType,
                        &translatorEntry);

            if (found == FALSE) {

                //
                // no information found on translator.  Try to query translator interface ...
                //

                if (resourceType <= PI_MAXIMUM_RESOURCE_TYPE_TRACKED) {
                    resourceMask = 1 << resourceType;
                } else {
                    resourceMask = 0;
                }
                status = IopQueryResourceHandlerInterface(ResourceTranslator,
                                                          deviceNode->PhysicalDeviceObject,
                                                          resourceType,
                                                          &interface);
                deviceNode->QueryTranslatorMask |= resourceMask;
                if (!NT_SUCCESS(status)) {
                    deviceNode->NoTranslatorMask |= resourceMask;
                    if (resourceType <= PI_MAXIMUM_RESOURCE_TYPE_TRACKED) {
                        found = TRUE;
                    } else {
                        interface = NULL;
                    }
                }
                if (found == FALSE) {
                    translatorEntry = (PPI_RESOURCE_TRANSLATOR_ENTRY)ExAllocatePoolTE(
                                       PagedPool | POOL_COLD_ALLOCATION,
                                       sizeof(PI_RESOURCE_TRANSLATOR_ENTRY));
                    if (!translatorEntry) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        return status;
                    }
                    translatorEntry->ResourceType = resourceType;
                    InitializeListHead(&translatorEntry->DeviceTranslatorList);
                    translatorEntry->TranslatorInterface = (PTRANSLATOR_INTERFACE)interface;
                    translatorEntry->DeviceNode = deviceNode;
                    listHead = &deviceNode->DeviceTranslatorList;
                    InsertTailList(listHead, &translatorEntry->DeviceTranslatorList);
                    if (!interface) {

                        //
                        // if interface is NULL we really don't have translator.
                        //

                        translatorEntry = NULL;
                    }
                }
            }
            if (translatorEntry) {
                translatorFound = TRUE;
            }
            if ((arbiterFound == FALSE) && translatorEntry) {

                //
                // Find a translator to translate the req desc ... Translate it and link it to
                // the front of ReqDesc->TranslatedReqDesc such that the first in the list is for
                // the Arbiter to use.
                //

                reqDesc = ReqDesc->TranslatedReqDesc;
                status = IopTranslateAndAdjustReqDesc(
                              reqDesc,
                              translatorEntry,
                              &translatedReqDesc);
                if (NT_SUCCESS(status)) {
                    ASSERT(translatedReqDesc);
                    resourceType = translatedReqDesc->AlternativeTable.Alternatives->Type;
                    translatedReqDesc->TranslatedReqDesc = ReqDesc->TranslatedReqDesc;
                    ReqDesc->TranslatedReqDesc = translatedReqDesc;
                    //
                    // If the translator is non-hierarchial and performs a complete
                    // translation to root (eg ISA interrups for PCI devices) then
                    // don't pass translations to parent.
                    //

                    if (status == STATUS_TRANSLATION_COMPLETE) {
                        searchTranslator = FALSE;
                    }
                } else {
                    IopDbgPrint((
                        IOP_RESOURCE_INFO_LEVEL,
                        "resreq list TranslationAndAdjusted failed\n"
                        ));
                    return status;
                }
            }

        }

        //
        // Move up to current device node's parent
        //

        deviceNode = deviceNode->Parent;
    }

    if (arbiterFound) {

        return STATUS_SUCCESS;
    } else {
        //
        // We should BugCheck in this case.
        //
        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "can not find resource type %x arbiter\n",
            resourceType));

        ASSERT(arbiterFound);

        return STATUS_RESOURCE_TYPE_NOT_FOUND;
    }

}

VOID
IopUncacheInterfaceInformation (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This function removes all the cached translators and arbiters information
    from the device object.

Parameters:

    DeviceObject - Supplies the device object of the device being removed.

Return Value:

    None.

--*/

{
    PDEVICE_NODE                    deviceNode;
    PLIST_ENTRY                     listHead;
    PLIST_ENTRY                     nextEntry;
    PLIST_ENTRY                     entry;
    PPI_RESOURCE_TRANSLATOR_ENTRY   translatorEntry;
    PPI_RESOURCE_ARBITER_ENTRY      arbiterEntry;
    PINTERFACE                      interface;

    deviceNode = PP_DO_TO_DN(DeviceObject);
    //
    // Dereference all the arbiters on this PDO.
    //
    listHead    = &deviceNode->DeviceArbiterList;
    nextEntry   = listHead->Flink;
    while (nextEntry != listHead) {

        entry           = nextEntry;
        arbiterEntry    = CONTAINING_RECORD(
                            entry,
                            PI_RESOURCE_ARBITER_ENTRY,
                            DeviceArbiterList);

        interface = (PINTERFACE)arbiterEntry->ArbiterInterface;
        if (interface != NULL) {

            (interface->InterfaceDereference)(interface->Context);
            ExFreePool(interface);
        }
        nextEntry = entry->Flink;
        ExFreePool(entry);
    }
    //
    // Dereference all the translators on this PDO.
    //
    listHead    = &deviceNode->DeviceTranslatorList;
    nextEntry   = listHead->Flink;
    while (nextEntry != listHead) {
        entry           = nextEntry;
        translatorEntry = CONTAINING_RECORD(
                            entry,
                            PI_RESOURCE_TRANSLATOR_ENTRY,
                            DeviceTranslatorList);
        interface = (PINTERFACE)translatorEntry->TranslatorInterface;
        if (interface != NULL) {

            (interface->InterfaceDereference)(interface->Context);
            ExFreePool(interface);
        }
        nextEntry = entry->Flink;
        ExFreePool(entry);
    }
    InitializeListHead(&deviceNode->DeviceArbiterList);
    InitializeListHead(&deviceNode->DeviceTranslatorList);
    deviceNode->NoArbiterMask       = 0;
    deviceNode->QueryArbiterMask    = 0;
    deviceNode->NoTranslatorMask    = 0;
    deviceNode->QueryTranslatorMask = 0;
}

BOOLEAN
IopFindResourceHandlerInfo (
    IN  RESOURCE_HANDLER_TYPE    HandlerType,
    IN  PDEVICE_NODE             DeviceNode,
    IN  UCHAR                    ResourceType,
    OUT PVOID                   *HandlerEntry
    )

/*++

Routine Description:

    This routine finds the desired resource handler interface for the specified
    resource type in the specified Device node.

Parameters:

    HandlerType     - Specifies the type of handler needed.

    DeviceNode      - Specifies the devicenode on which to search for handler.

    ResourceType    - Specifies the type of resource.

    HandlerEntry    - Supplies a pointer to a variable to receive the handler.

Return Value:

    TRUE + non-NULL HandlerEntry : Found handler info and there is a handler
    TRUE + NULL HandlerEntry     : Found handler info but there is NO handler
    FALSE + NULL HandlerEntry    : No handler info found

--*/
{
    USHORT                      resourceMask;
    USHORT                      noHandlerMask;
    USHORT                      queryHandlerMask;
    PLIST_ENTRY                 listHead;
    PLIST_ENTRY                 entry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;

    *HandlerEntry   = NULL;
    switch (HandlerType) {
    case ResourceArbiter:

        noHandlerMask       = DeviceNode->NoArbiterMask;
        queryHandlerMask    = DeviceNode->QueryArbiterMask;
        listHead            = &DeviceNode->DeviceArbiterList;
        break;

    case ResourceTranslator:

        noHandlerMask       = DeviceNode->NoTranslatorMask;
        queryHandlerMask    = DeviceNode->QueryTranslatorMask;
        listHead            = &DeviceNode->DeviceTranslatorList;
        break;

    default:

        return FALSE;
    }
    resourceMask    = 1 << ResourceType;
    if (noHandlerMask & resourceMask) {
        //
        // There is no desired handler for the resource type.
        //
        return TRUE;
    }
    if (    (queryHandlerMask & resourceMask) ||
            ResourceType > PI_MAXIMUM_RESOURCE_TYPE_TRACKED) {

        entry = listHead->Flink;
        while (entry != listHead) {

            arbiterEntry = CONTAINING_RECORD(
                                entry,
                                PI_RESOURCE_ARBITER_ENTRY,
                                DeviceArbiterList);
            if (arbiterEntry->ResourceType == ResourceType) {

                if (    ResourceType <= PI_MAXIMUM_RESOURCE_TYPE_TRACKED ||
                        arbiterEntry->ArbiterInterface) {

                    *HandlerEntry = arbiterEntry;
                }
                return TRUE;
            }
            entry = entry->Flink;
        }
        if (queryHandlerMask & resourceMask) {
            //
            // There must be one.
            //
            ASSERT(entry != listHead);
        }
    }

    return FALSE;
}

NTSTATUS
IopParentToRawTranslation(
    IN OUT PREQ_DESC ReqDesc
    )

/*++

Routine Description:

    This routine translates an CmPartialResourceDescriptors
    from their translated form to their raw counterparts..

Parameters:

    ReqDesc - supplies a translated ReqDesc to be translated back to its raw form

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    PTRANSLATOR_INTERFACE translator;
    NTSTATUS status = STATUS_SUCCESS;
    PREQ_DESC rawReqDesc;

    if (ReqDesc->AlternativeTable.AlternativeCount == 0 ||

        ReqDesc->Allocation.Type == CmResourceTypeMaximum) {
        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "Invalid ReqDesc for parent-to-raw translation.\n"));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // If this ReqDesc is the raw reqDesc then we are done.
    // Else call its translator to translate the resource and leave the result
    // in its raw (next level) reqdesc.
    //

    if (IS_TRANSLATED_REQ_DESC(ReqDesc)) {
        rawReqDesc = ReqDesc->TranslatedReqDesc;
        translator = ReqDesc->u.Translator->TranslatorInterface;
        status = (translator->TranslateResources)(
                      translator->Context,
                      ReqDesc->AlternativeTable.Assignment,
                      TranslateParentToChild,
                      rawReqDesc->AlternativeTable.AlternativeCount,
                      rawReqDesc->AlternativeTable.Alternatives,
                      rawReqDesc->AlternativeTable.PhysicalDeviceObject,
                      rawReqDesc->AlternativeTable.Assignment
                      );
        if (NT_SUCCESS(status)) {

            //
            // If the translator is non-hierarchial and performs a complete
            // translation to root (eg ISA interrups for PCI devices) then
            // don't pass translations to parent.
            //

            ASSERT(status != STATUS_TRANSLATION_COMPLETE);
            status = IopParentToRawTranslation(rawReqDesc);
        }
    }
    return status;
}

NTSTATUS
IopChildToRootTranslation(
    IN PDEVICE_NODE DeviceNode, OPTIONAL
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ARBITER_REQUEST_SOURCE ArbiterRequestSource,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *Target
    )

/*++

Routine Description:

    This routine translates a CmPartialResourceDescriptors from
    their intermediate translated form to their final translated form.
    The translated CM_PARTIAL_RESOURCE_DESCRIPTOR is returned via Target variable.

    The caller is responsible to release the translated descriptor.

Parameters:

    DeviceNode - Specified the device object.  If The DeviceNode is specified,
                 the InterfaceType and BusNumber are ignored and we will
                 use DeviceNode as a starting point to find various translators to
                 translate the Source descriptor.  If DeviceNode is not specified,
                 the InterfaceType and BusNumber must be specified.

    InterfaceType, BusNumber - must be supplied if DeviceNode is not specified.

    Source - A pointer to the resource descriptor to be translated.

    Target - Supplies an address to receive the translated resource descriptor.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE currentDeviceNode;
    PLIST_ENTRY listHead, nextEntry;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR target, source, tmp;
    PPI_RESOURCE_TRANSLATOR_ENTRY translatorEntry;
    PTRANSLATOR_INTERFACE translator;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN done = FALSE, foundTranslator = FALSE, restartedAlready;

    if (ArbiterRequestSource == ArbiterRequestHalReported) {
       restartedAlready = TRUE;
    } else {
       restartedAlready = FALSE;
    }

    source = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ExAllocatePoolPRD(
                         PagedPool | POOL_COLD_ALLOCATION,
                         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                         );
    if (source == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    target = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ExAllocatePoolPRD(
                         PagedPool,
                         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                         );
    if (target == NULL) {
        ExFreePool(source);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    *source = *Source;

    //
    // Move up to current device node's parent to start translation
    //

    if (!ARGUMENT_PRESENT(DeviceNode)) {
        currentDeviceNode = IopFindLegacyBusDeviceNode (InterfaceType, BusNumber);
        deviceObject = NULL;
    } else {
        // We want to start with the deviceNode instead of its parent.  Because the
        // deviceNode may provide a translator interface.
        currentDeviceNode = DeviceNode;
        deviceObject = DeviceNode->PhysicalDeviceObject;
    }
    while (currentDeviceNode && !done) {

        if ((currentDeviceNode == IopRootDeviceNode) && (foundTranslator == FALSE)) {
            if (restartedAlready == FALSE) {
                restartedAlready = TRUE;
                currentDeviceNode = IopFindLegacyBusDeviceNode (InterfaceType, BusNumber);

                //
                // If we did not find a PDO, try again with InterfaceType == Isa. This allows
                // drivers that request Internal to get resources even if there is no PDO
                // that is Internal. (but if there is an Internal PDO, they get that one)
                //

                if ((currentDeviceNode == IopRootDeviceNode) && (InterfaceType == Internal)) {
                    currentDeviceNode = IopFindLegacyBusDeviceNode(Isa, 0);
                }

                continue;
            }
        }
        //
        // First, check if there is a translator for the device node?
        // If yes, translate the req desc and link it to the front of ReqDesc->TranslatedReqDesc
        // else do nothing.
        //

        listHead = &currentDeviceNode->DeviceTranslatorList;
        nextEntry = listHead->Flink;
        for (; nextEntry != listHead; nextEntry = nextEntry->Flink) {
            translatorEntry = CONTAINING_RECORD(nextEntry, PI_RESOURCE_TRANSLATOR_ENTRY, DeviceTranslatorList);
            if (translatorEntry->ResourceType == Source->Type) {
                translator = translatorEntry->TranslatorInterface;
                if (translator != NULL) {

                    //
                    // Find a translator to translate the req desc ... Translate it and link it to
                    // the front of ReqDesc->TranslatedReqDesc.
                    //

                    status = (translator->TranslateResources) (
                                  translator->Context,
                                  source,
                                  TranslateChildToParent,
                                  0,
                                  NULL,
                                  deviceObject,
                                  target
                                  );
                    if (NT_SUCCESS(status)) {
                        tmp = source;
                        source = target;
                        target = tmp;

                        //
                        // If the translator is non-hierarchial and performs a complete
                        // translation to root (eg ISA interrups for PCI devices) then
                        // don't pass translations to parent.
                        //

                        if (status == STATUS_TRANSLATION_COMPLETE) {
                            done = TRUE;
                        }

                    } else {

                        if(DeviceNode) {

                            IopDbgPrint((
                                IOP_RESOURCE_ERROR_LEVEL,
                                "Child to Root Translation failed\n"
                                "        DeviceNode %08x (PDO %08x)\n"
                                "        Resource Type %02x Data %08x %08x %08x\n",
                                DeviceNode,
                                DeviceNode->PhysicalDeviceObject,
                                source->Type,
                                source->u.DevicePrivate.Data[0],
                                source->u.DevicePrivate.Data[1],
                                source->u.DevicePrivate.Data[2]
                                ));
                            IopRecordTranslationFailure(DeviceNode, *source);
                        }
                        goto exit;
                    }
                }
                break;
            }
        }

        //
        // Move up to current device node's parent
        //

        currentDeviceNode = currentDeviceNode->Parent;
    }
    *Target = source;
    ExFreePool(target);
    return status;
exit:
    ExFreePool(source);
    ExFreePool(target);
    return status;
}

NTSTATUS
IopTranslateAndAdjustReqDesc(
    IN PREQ_DESC ReqDesc,
    IN PPI_RESOURCE_TRANSLATOR_ENTRY TranslatorEntry,
    OUT PREQ_DESC *TranslatedReqDesc
    )

/*++

Routine Description:

    This routine translates and adjusts ReqDesc IoResourceDescriptors to
    their translated and adjusted form.

Parameters:

    ReqDesc - supplies a pointer to the REQ_DESC to be translated.

    TranslatorEntry - supplies a pointer to the translator infor structure.

    TranslatedReqDesc - supplies a pointer to a variable to receive the
                        translated REQ_DESC.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    ULONG i, total = 0, *targetCount;
    PTRANSLATOR_INTERFACE translator = TranslatorEntry->TranslatorInterface;
    PIO_RESOURCE_DESCRIPTOR ioDesc, *target, tIoDesc;
    PREQ_DESC tReqDesc;
    PARBITER_LIST_ENTRY arbiterEntry;
    NTSTATUS status = STATUS_UNSUCCESSFUL, returnStatus = STATUS_SUCCESS;
    BOOLEAN reqTranslated = FALSE;

    if (ReqDesc->AlternativeTable.AlternativeCount == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    *TranslatedReqDesc = NULL;

    target = (PIO_RESOURCE_DESCRIPTOR *) ExAllocatePoolIORD(
                           PagedPool | POOL_COLD_ALLOCATION,
                           sizeof(PIO_RESOURCE_DESCRIPTOR) * ReqDesc->AlternativeTable.AlternativeCount
                           );
    if (target == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not Enough memory to perform resreqlist adjustment\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(target, sizeof(PIO_RESOURCE_DESCRIPTOR) * ReqDesc->AlternativeTable.AlternativeCount);

    targetCount = (PULONG) ExAllocatePool(
                           PagedPool | POOL_COLD_ALLOCATION,
                           sizeof(ULONG) * ReqDesc->AlternativeTable.AlternativeCount
                           );
    if (targetCount == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not Enough memory to perform resreqlist adjustment\n"));
        ExFreePool(target);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(targetCount, sizeof(ULONG) * ReqDesc->AlternativeTable.AlternativeCount);

    //
    // Determine the number of IO_RESOURCE_DESCRIPTORs after translation.
    //

    ioDesc = ReqDesc->AlternativeTable.Alternatives;
    for (i = 0; i < ReqDesc->AlternativeTable.AlternativeCount; i++) {
        status = (translator->TranslateResourceRequirements)(
                           translator->Context,
                           ioDesc,
                           ReqDesc->AlternativeTable.PhysicalDeviceObject,
                           &targetCount[i],
                           &target[i]
                           );
        if (!NT_SUCCESS(status) || targetCount[i] == 0) {
            IopDbgPrint((
                IOP_RESOURCE_WARNING_LEVEL,
                "Translator failed to adjust resreqlist\n"));
            target[i] = ioDesc;
            targetCount[i] = 0;
            total++;
        } else {
            total += targetCount[i];
            reqTranslated = TRUE;
        }
        ioDesc++;
        if (NT_SUCCESS(status) && (returnStatus != STATUS_TRANSLATION_COMPLETE)) {
            returnStatus = status;
        }
    }

    if (!reqTranslated) {

        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Failed to translate any requirement for %ws!\n",
            PP_DO_TO_DN(ReqDesc->AlternativeTable.PhysicalDeviceObject)->InstancePath.Buffer));
        returnStatus = status;
    }

    //
    // Allocate memory for the adjusted/translated resources descriptors
    //

    tIoDesc = (PIO_RESOURCE_DESCRIPTOR) ExAllocatePoolIORD(
                           PagedPool | POOL_COLD_ALLOCATION,
                           total * sizeof(IO_RESOURCE_DESCRIPTOR));
    if (!tIoDesc) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not Enough memory to perform resreqlist adjustment\n"));
        returnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    tReqDesc = (PREQ_DESC) ExAllocatePool1RD (PagedPool | POOL_COLD_ALLOCATION, sizeof(REQ_DESC));
    if (tReqDesc == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not Enough memory to perform resreqlist adjustment\n"));
        ExFreePool(tIoDesc);
        returnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Create and initialize a new REQ_DESC for the translated/adjusted io resources
    //

    RtlCopyMemory(tReqDesc, ReqDesc, sizeof(REQ_DESC));

    //
    // Set the translated req desc's ReqAlternative to NULL to indicated this
    // is not the original req desc.
    //

    tReqDesc->ReqAlternative = NULL;

    tReqDesc->u.Translator = TranslatorEntry;
    tReqDesc->TranslatedReqDesc = NULL;
    arbiterEntry = &tReqDesc->AlternativeTable;
    InitializeListHead(&arbiterEntry->ListEntry);
    arbiterEntry->AlternativeCount = total;
    arbiterEntry->Alternatives = tIoDesc;
    arbiterEntry->Assignment = &tReqDesc->Allocation;

    ioDesc = ReqDesc->AlternativeTable.Alternatives;
    for (i = 0; i < ReqDesc->AlternativeTable.AlternativeCount; i++) {
        if (targetCount[i] != 0) {
            RtlCopyMemory(tIoDesc, target[i], targetCount[i] * sizeof(IO_RESOURCE_DESCRIPTOR));
            tIoDesc += targetCount[i];
        } else {

            //
            // Make it become impossible to satisfy.
            //

            RtlCopyMemory(tIoDesc, ioDesc, sizeof(IO_RESOURCE_DESCRIPTOR));
            switch (tIoDesc->Type) {
            case CmResourceTypePort:
            case CmResourceTypeMemory:
                tIoDesc->u.Port.MinimumAddress.LowPart = 2;
                tIoDesc->u.Port.MinimumAddress.HighPart = 0;
                tIoDesc->u.Port.MaximumAddress.LowPart = 1;
                tIoDesc->u.Port.MaximumAddress.HighPart = 0;
                break;
            case CmResourceTypeBusNumber:
                tIoDesc->u.BusNumber.MinBusNumber = 2;
                tIoDesc->u.BusNumber.MaxBusNumber = 1;
                break;

            case CmResourceTypeInterrupt:
                tIoDesc->u.Interrupt.MinimumVector = 2;
                tIoDesc->u.Interrupt.MaximumVector = 1;
                break;

            case CmResourceTypeDma:
                tIoDesc->u.Dma.MinimumChannel = 2;
                tIoDesc->u.Dma.MaximumChannel = 1;
                break;
            default:
                ASSERT(0);
                break;
            }
            tIoDesc += 1;
        }
        ioDesc++;

    }

#if DBG_SCOPE
    //
    // Verify the adjusted resource descriptors are valid
    //

    ioDesc = arbiterEntry->Alternatives;
    ASSERT((ioDesc->Option & IO_RESOURCE_ALTERNATIVE) == 0);
    ioDesc++;
    for (i = 1; i < total; i++) {
        ASSERT(ioDesc->Option & IO_RESOURCE_ALTERNATIVE);
        ioDesc++;
    }
#endif
    *TranslatedReqDesc = tReqDesc;
exit:
    for (i = 0; i < ReqDesc->AlternativeTable.AlternativeCount; i++) {
        if (targetCount[i] != 0) {
            ASSERT(target[i]);
            ExFreePool(target[i]);
        }
    }
    ExFreePool(target);
    ExFreePool(targetCount);
    return returnStatus;
}

NTSTATUS
IopCallArbiter(
    PPI_RESOURCE_ARBITER_ENTRY ArbiterEntry,
    ARBITER_ACTION Command,
    PVOID Input1,
    PVOID Input2,
    PVOID Input3
    )

/*++

Routine Description:

    This routine builds a Parameter block from Input structure and calls specified
    arbiter to carry out the Command.

Parameters:

    ArbiterEntry - Supplies a pointer to our PI_RESOURCE_ARBITER_ENTRY such that
                   we know everything about the arbiter.

    Command - Supplies the Action code for the arbiter.

    Input - Supplies a PVOID pointer to a structure.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    ARBITER_PARAMETERS parameters;
    PARBITER_INTERFACE arbiterInterface = ArbiterEntry->ArbiterInterface;
    NTSTATUS status;
    PARBITER_LIST_ENTRY arbiterListEntry;
    LIST_ENTRY listHead;
    PVOID *ExtParams;

    switch (Command) {
    case ArbiterActionTestAllocation:
    case ArbiterActionRetestAllocation:

        //
        // For ArbiterActionTestAllocation, the Input is a pointer to the doubly
        // linked list of ARBITER_LIST_ENTRY's.
        //

        parameters.Parameters.TestAllocation.ArbitrationList = (PLIST_ENTRY)Input1;
        parameters.Parameters.TestAllocation.AllocateFromCount = (ULONG)((ULONG_PTR)Input2);
        parameters.Parameters.TestAllocation.AllocateFrom =
                                            (PCM_PARTIAL_RESOURCE_DESCRIPTOR)Input3;
        status = (arbiterInterface->ArbiterHandler)(
                      arbiterInterface->Context,
                      Command,
                      &parameters
                      );
        break;

    case ArbiterActionBootAllocation:

        //
        // For ArbiterActionBootAllocation, the input is a pointer to the doubly
        // linked list of ARBITER_LIST_ENTRY'S.
        //

        parameters.Parameters.BootAllocation.ArbitrationList = (PLIST_ENTRY)Input1;

        status = (arbiterInterface->ArbiterHandler)(
                      arbiterInterface->Context,
                      Command,
                      &parameters
                      );
        break;

    case ArbiterActionQueryArbitrate:

        //
        // For QueryArbiter, the input is a pointer to REQ_DESC
        //

        arbiterListEntry = &((PREQ_DESC)Input1)->AlternativeTable;
        ASSERT(IsListEmpty(&arbiterListEntry->ListEntry));
        listHead = arbiterListEntry->ListEntry;
        arbiterListEntry->ListEntry.Flink = arbiterListEntry->ListEntry.Blink = &listHead;
        parameters.Parameters.QueryArbitrate.ArbitrationList = &listHead;
        status = (arbiterInterface->ArbiterHandler)(
                      arbiterInterface->Context,
                      Command,
                      &parameters
                      );
        arbiterListEntry->ListEntry = listHead;
        break;

    case ArbiterActionCommitAllocation:
    case ArbiterActionWriteReservedResources:

        //
        // Commit, Rollback and WriteReserved do not have parmater.
        //

        status = (arbiterInterface->ArbiterHandler)(
                      arbiterInterface->Context,
                      Command,
                      NULL
                      );
        break;

    case ArbiterActionQueryAllocatedResources:
        status = STATUS_NOT_IMPLEMENTED;
        break;

    case ArbiterActionQueryConflict:
        //
        // For QueryConflict
        // Ex0 is PDO
        // Ex1 is PIO_RESOURCE_DESCRIPTOR
        // Ex2 is PULONG
        // Ex3 is PARBITER_CONFLICT_INFO *
        ExtParams = (PVOID*)Input1;

        parameters.Parameters.QueryConflict.PhysicalDeviceObject = (PDEVICE_OBJECT)ExtParams[0];
        parameters.Parameters.QueryConflict.ConflictingResource = (PIO_RESOURCE_DESCRIPTOR)ExtParams[1];
        parameters.Parameters.QueryConflict.ConflictCount = (PULONG)ExtParams[2];
        parameters.Parameters.QueryConflict.Conflicts = (PARBITER_CONFLICT_INFO *)ExtParams[3];
        status = (arbiterInterface->ArbiterHandler)(
                      arbiterInterface->Context,
                      Command,
                      &parameters
                      );
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
        break;
    }

    return status;
}

NTSTATUS
IopFindResourcesForArbiter (
    IN PDEVICE_NODE DeviceNode,
    IN UCHAR ResourceType,
    OUT ULONG *Count,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *CmDesc
    )

/*++

Routine Description:

    This routine returns the resources required by the ResourceType arbiter in DeviceNode.

Parameters:

    DeviceNode -specifies the device node whose ResourceType arbiter is requesting for resources

    ResourceType - specifies the resource type

    Count - specifies a pointer to a varaible to receive the count of Cm descriptors returned

    CmDesc - specifies a pointer to a varibble to receive the returned cm descriptor.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PIOP_RESOURCE_REQUEST assignEntry;
    PREQ_ALTERNATIVE reqAlternative;
    PREQ_DESC reqDesc;
    ULONG i, count = 0;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptor;

    *Count = 0;
    *CmDesc = NULL;

    if (DeviceNode->State == DeviceNodeStarted) {
        return STATUS_SUCCESS;
    }

    //
    // Find this device node's IOP_RESOURCE_REQUEST structure first
    //

    for (assignEntry = PiAssignTable + PiAssignTableCount - 1;
         assignEntry >= PiAssignTable;
         assignEntry--) {
        if (assignEntry->PhysicalDevice == DeviceNode->PhysicalDeviceObject) {
            break;
        }
    }
    if (assignEntry < PiAssignTable) {
        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "Rebalance: No resreqlist for Arbiter? Can not find Arbiter assign"
            " table entry\n"));
        return STATUS_UNSUCCESSFUL;
    }

    reqAlternative = *((PREQ_LIST)assignEntry->ReqList)->SelectedAlternative;
    for (i = 0; i < reqAlternative->DescCount; i++) {
        reqDesc = reqAlternative->DescTable[i]->TranslatedReqDesc;
        if (reqDesc->Allocation.Type == ResourceType) {
            count++;
        }
    }

    cmDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ExAllocatePoolPRD(
                       PagedPool,
                       sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * count
                       );
    if (!cmDescriptor) {

        //
        // If we can not find memory, the resources will not be committed by arbiter.
        //

        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Rebalance: Not enough memory to perform rebalance\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *Count = count;
    *CmDesc = cmDescriptor;

    for (i = 0; i < reqAlternative->DescCount; i++) {
        reqDesc = reqAlternative->DescTable[i]->TranslatedReqDesc;
        if (reqDesc->Allocation.Type == ResourceType) {
            *cmDescriptor = reqDesc->Allocation;
            cmDescriptor++;
        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS
IopRestoreResourcesInternal (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine reassigns the released resources for device specified by DeviceNode.

Parameters:

    DeviceNode - specifies the device node whose resources are goint to be released.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    IOP_RESOURCE_REQUEST requestTable;
    NTSTATUS status;
    LIST_ENTRY  activeArbiterList;

    if (DeviceNode->ResourceList == NULL) {
        return STATUS_SUCCESS;
    }
    requestTable.ResourceRequirements =
        IopCmResourcesToIoResources (0, DeviceNode->ResourceList, LCPRI_FORCECONFIG);
    if (requestTable.ResourceRequirements == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not enough memory to clean up rebalance failure\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    requestTable.Priority = 0;
    requestTable.Flags = 0;
    requestTable.AllocationType = ArbiterRequestPnpEnumerated;
    requestTable.PhysicalDevice = DeviceNode->PhysicalDeviceObject;
    requestTable.ReqList = NULL;
    requestTable.ResourceAssignment = NULL;
    requestTable.TranslatedResourceAssignment = NULL;
    requestTable.Status = 0;

    //
    // rebuild internal representation of the resource requirements list
    //

    status = IopResourceRequirementsListToReqList(
                    &requestTable,
                    &requestTable.ReqList);

    if (!NT_SUCCESS(status) || requestTable.ReqList == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "Not enough memory to restore previous resources\n"));
        ExFreePool (requestTable.ResourceRequirements);
        return status;
    } else {
        PREQ_LIST reqList;

        reqList = (PREQ_LIST)requestTable.ReqList;

        //
        // Sort the ReqList such that the higher priority Alternative list are
        // placed in the front of the list.
        //

        IopRearrangeReqList(reqList);
        if (reqList->BestAlternative == NULL) {

            IopFreeResourceRequirementsForAssignTable(&requestTable, (&requestTable) + 1);
            return STATUS_DEVICE_CONFIGURATION_ERROR;

        }
    }

    status = IopFindBestConfiguration(&requestTable, 1, &activeArbiterList);
    IopFreeResourceRequirementsForAssignTable(&requestTable, (&requestTable) + 1);
    if (NT_SUCCESS(status)) {
        //
        // Ask the arbiters to commit this configuration.
        //
        status = IopCommitConfiguration(&activeArbiterList);
    }
    if (!NT_SUCCESS(status)) {
        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "IopRestoreResourcesInternal: BOOT conflict for %ws\n",
            DeviceNode->InstancePath.Buffer));
    }
    if (requestTable.ResourceAssignment) {
        ExFreePool(requestTable.ResourceAssignment);
    }
    if (requestTable.TranslatedResourceAssignment) {
        ExFreePool(requestTable.TranslatedResourceAssignment);
    }
    IopWriteAllocatedResourcesToRegistry (
        DeviceNode,
        DeviceNode->ResourceList,
        IopDetermineResourceListSize(DeviceNode->ResourceList)
        );
    return status;
}

VOID
IopReleaseResourcesInternal (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine releases the assigned resources for device specified by DeviceNode.
    Note, this routine does not reset the resource related fields in DeviceNode structure.

Parameters:

    DeviceNode - specifies the device node whose resources are goint to be released.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_NODE device;
    PLIST_ENTRY listHead, listEntry;
    PPI_RESOURCE_ARBITER_ENTRY arbiterEntry;
    ARBITER_LIST_ENTRY arbiterListEntry;
    INTERFACE_TYPE interfaceType;
    ULONG busNumber, listCount, i, j, size;
    PCM_RESOURCE_LIST resourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
    BOOLEAN search = TRUE;
#if DBG_SCOPE
    NTSTATUS status;
#endif

    InitializeListHead(&arbiterListEntry.ListEntry);
    arbiterListEntry.AlternativeCount = 0;
    arbiterListEntry.Alternatives = NULL;
    arbiterListEntry.PhysicalDeviceObject = DeviceNode->PhysicalDeviceObject;
    arbiterListEntry.Flags = 0;
    arbiterListEntry.WorkSpace = 0;
    arbiterListEntry.Assignment = NULL;
    arbiterListEntry.RequestSource = ArbiterRequestPnpEnumerated;

    resourceList = DeviceNode->ResourceList;
    if (resourceList == NULL) {
        resourceList = DeviceNode->BootResources;
    }
    if (resourceList && resourceList->Count > 0) {
        listCount = resourceList->Count;
        cmFullDesc = &resourceList->List[0];
    } else {
        listCount = 1;
        resourceList = NULL;
        cmFullDesc = NULL;
    }
    for (i = 0; i < listCount; i++) {

        if (resourceList) {
            interfaceType = cmFullDesc->InterfaceType;
            busNumber = cmFullDesc->BusNumber;
            if (interfaceType == InterfaceTypeUndefined) {
                interfaceType = PnpDefaultInterfaceType;
            }
        } else {
            interfaceType = PnpDefaultInterfaceType;
            busNumber = 0;
        }

        device = DeviceNode->Parent;
        while (device) {
            if ((device == IopRootDeviceNode) && search) {
                device = IopFindLegacyBusDeviceNode (
                                 interfaceType,
                                 busNumber
                                 );

                //
                // If we did not find a PDO, try again with InterfaceType == Isa. This allows
                // drivers that request Internal to get resources even if there is no PDO
                // that is Internal. (but if there is an Internal PDO, they get that one)
                //

                if ((device == IopRootDeviceNode) && (interfaceType == Internal)) {
                    device = IopFindLegacyBusDeviceNode(Isa, 0);
                }
                search = FALSE;

            }
            listHead = &device->DeviceArbiterList;
            listEntry = listHead->Flink;
            while (listEntry != listHead) {
                arbiterEntry = CONTAINING_RECORD(listEntry, PI_RESOURCE_ARBITER_ENTRY, DeviceArbiterList);
                if (arbiterEntry->ArbiterInterface != NULL) {
                    search = FALSE;
                    ASSERT(IsListEmpty(&arbiterEntry->ResourceList));
                    InitializeListHead(&arbiterEntry->ResourceList);  // Recover from assert
                    InsertTailList(&arbiterEntry->ResourceList, &arbiterListEntry.ListEntry);
    #if DBG_SCOPE
                    status =
    #endif
                    IopCallArbiter(arbiterEntry,
                                   ArbiterActionTestAllocation,
                                   &arbiterEntry->ResourceList,
                                   NULL,
                                   NULL
                                   );
    #if DBG_SCOPE
                    ASSERT(status == STATUS_SUCCESS);
                    status =
    #endif
                    IopCallArbiter(arbiterEntry,
                                   ArbiterActionCommitAllocation,
                                   NULL,
                                   NULL,
                                   NULL
                                   );
    #if DBG_SCOPE
                    ASSERT(status == STATUS_SUCCESS);
    #endif
                    RemoveEntryList(&arbiterListEntry.ListEntry);
                    InitializeListHead(&arbiterListEntry.ListEntry);
                }
                listEntry = listEntry->Flink;
            }
            device = device->Parent;
        }

        //
        // If there are more than 1 list, move to next list
        //

        if (listCount > 1) {
            cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
                size = 0;
                switch (cmPartDesc->Type) {
                case CmResourceTypeDeviceSpecific:
                     size = cmPartDesc->u.DeviceSpecificData.DataSize;
                     break;
                }
                cmPartDesc++;
                cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
            }
            cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
        }
    }

    IopWriteAllocatedResourcesToRegistry(DeviceNode, NULL, 0);
}

NTSTATUS
IopFindLegacyDeviceNode (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    OUT PDEVICE_NODE *LegacyDeviceNode,
    OUT PDEVICE_OBJECT *LegacyPDO
    )

/*++

Routine Description:

    This routine searches for the device node and device object created for legacy resource
    allocation for the DriverObject and DeviceObject.

Parameters:

    DriverObject - specifies the driver object doing the legacy allocation.

    DeviceObject - specifies the device object.

    LegacyDeviceNode - receives the pointer to the legacy device node if found.

    LegacyDeviceObject - receives the pointer to the legacy device object if found.


Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    PDEVICE_NODE    deviceNode;

    ASSERT(LegacyDeviceNode && LegacyPDO);


    //
    // Use the device object if it exists.
    //

    if (DeviceObject) {

        deviceNode = PP_DO_TO_DN(DeviceObject);
        if (deviceNode) {

            *LegacyPDO = DeviceObject;
            *LegacyDeviceNode = deviceNode;
            status = STATUS_SUCCESS;

        } else if (!(DeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE)) {

            status = PipAllocateDeviceNode(DeviceObject, &deviceNode);
            if (deviceNode) {

                if (status == STATUS_SYSTEM_HIVE_TOO_LARGE) {

                    IopDestroyDeviceNode(deviceNode);
                } else {

                    deviceNode->Flags |= DNF_LEGACY_RESOURCE_DEVICENODE;
                    IopSetLegacyDeviceInstance (DriverObject, deviceNode);
                    *LegacyPDO = DeviceObject;
                    *LegacyDeviceNode = deviceNode;
                    status = STATUS_SUCCESS;
                }
            } else {

                IopDbgPrint((
                    IOP_RESOURCE_ERROR_LEVEL,
                    "Failed to allocate device node for PDO %08X\n",
                    DeviceObject));
                status = STATUS_INSUFFICIENT_RESOURCES;

            }

        } else {

            IopDbgPrint((
                IOP_RESOURCE_ERROR_LEVEL,
                "%08X PDO without a device node!\n",
                DeviceObject));
            ASSERT(PP_DO_TO_DN(DeviceObject));

        }

    } else {

        //
        // Search our list of legacy device nodes.
        //

        for (   deviceNode = IopLegacyDeviceNode;
                deviceNode && deviceNode->DuplicatePDO != (PDEVICE_OBJECT)DriverObject;
                deviceNode = deviceNode->NextDeviceNode);

        if (deviceNode) {

            *LegacyPDO = deviceNode->PhysicalDeviceObject;
            *LegacyDeviceNode = deviceNode;
            status = STATUS_SUCCESS;

        } else {

            PDEVICE_OBJECT  pdo;

            //
            // We are seeing this for the first time.
            // Create a madeup device node.
            //

            status = IoCreateDevice( IoPnpDriverObject,
                                     sizeof(IOPNP_DEVICE_EXTENSION),
                                     NULL,
                                     FILE_DEVICE_CONTROLLER,
                                     FILE_AUTOGENERATED_DEVICE_NAME,
                                     FALSE,
                                     &pdo);

            if (NT_SUCCESS(status)) {

                pdo->Flags |= DO_BUS_ENUMERATED_DEVICE;
                status = PipAllocateDeviceNode(pdo, &deviceNode);
                if (status != STATUS_SYSTEM_HIVE_TOO_LARGE && deviceNode) {

                    //
                    // Change driver object to the caller even though the owner
                    // of the pdo is IoPnpDriverObject.  This is to support
                    // DriverExclusive for legacy interface.
                    //

                    pdo->DriverObject = DriverObject;
                    deviceNode->Flags = DNF_MADEUP | DNF_LEGACY_RESOURCE_DEVICENODE;

                    PipSetDevNodeState(deviceNode, DeviceNodeInitialized, NULL);

                    deviceNode->DuplicatePDO = (PDEVICE_OBJECT)DriverObject;
                    IopSetLegacyDeviceInstance (DriverObject, deviceNode);

                    //
                    // Add it to our list of legacy device nodes rather than adding it to the HW tree.
                    //

                    deviceNode->NextDeviceNode = IopLegacyDeviceNode;
                    if (IopLegacyDeviceNode) {

                        IopLegacyDeviceNode->PreviousDeviceNode = deviceNode;

                    }
                    IopLegacyDeviceNode = deviceNode;
                    *LegacyPDO = pdo;
                    *LegacyDeviceNode = deviceNode;

                } else {

                    IopDbgPrint((
                        IOP_RESOURCE_ERROR_LEVEL,
                        "Failed to allocate device node for PDO %08X\n",
                        pdo));
                    IoDeleteDevice(pdo);
                    status = STATUS_INSUFFICIENT_RESOURCES;

                }

            } else {

                IopDbgPrint((
                    IOP_RESOURCE_ERROR_LEVEL,
                    "IoCreateDevice failed with status %08X\n",
                    status));

            }
        }
    }

    return status;
}

VOID
IopRemoveLegacyDeviceNode (
    IN PDEVICE_OBJECT   DeviceObject OPTIONAL,
    IN PDEVICE_NODE     LegacyDeviceNode
    )

/*++

Routine Description:

    This routine removes the device node and device object created for legacy resource
    allocation for the DeviceObject.

Parameters:

    DeviceObject - specifies the device object.

    LegacyDeviceNode - receives the pointer to the legacy device node if found.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    ASSERT(LegacyDeviceNode);


    if (!DeviceObject) {

        if (LegacyDeviceNode->DuplicatePDO) {

            LegacyDeviceNode->DuplicatePDO = NULL;
            if (LegacyDeviceNode->PreviousDeviceNode) {

                LegacyDeviceNode->PreviousDeviceNode->NextDeviceNode = LegacyDeviceNode->NextDeviceNode;

            }

            if (LegacyDeviceNode->NextDeviceNode) {

                LegacyDeviceNode->NextDeviceNode->PreviousDeviceNode = LegacyDeviceNode->PreviousDeviceNode;

            }

            if (IopLegacyDeviceNode == LegacyDeviceNode) {

                IopLegacyDeviceNode = LegacyDeviceNode->NextDeviceNode;

            }

        } else {

            IopDbgPrint((
                IOP_RESOURCE_ERROR_LEVEL,
                "%ws does not have a duplicate PDO\n",
                LegacyDeviceNode->InstancePath.Buffer));
            ASSERT(LegacyDeviceNode->DuplicatePDO);
            return;

        }
    }

    if (!(DeviceObject && (DeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE))) {

        PDEVICE_NODE    resourceDeviceNode;
        PDEVICE_OBJECT  pdo;

        for (   resourceDeviceNode = (PDEVICE_NODE)LegacyDeviceNode->OverUsed1.LegacyDeviceNode;
                resourceDeviceNode;
                resourceDeviceNode = resourceDeviceNode->OverUsed2.NextResourceDeviceNode) {

                if (resourceDeviceNode->OverUsed2.NextResourceDeviceNode == LegacyDeviceNode) {

                    resourceDeviceNode->OverUsed2.NextResourceDeviceNode = LegacyDeviceNode->OverUsed2.NextResourceDeviceNode;
                    break;

                }
        }

        LegacyDeviceNode->Parent = LegacyDeviceNode->Sibling =
            LegacyDeviceNode->Child = LegacyDeviceNode->LastChild = NULL;

        //
        // Delete the dummy PDO and device node.
        //

        pdo = LegacyDeviceNode->PhysicalDeviceObject;
        LegacyDeviceNode->Flags &= ~DNF_LEGACY_RESOURCE_DEVICENODE;
        IopDestroyDeviceNode(LegacyDeviceNode);

        if (!DeviceObject) {

            pdo->DriverObject = IoPnpDriverObject;
            IoDeleteDevice(pdo);
        }
    }
}


VOID
IopSetLegacyResourcesFlag(
    IN PDRIVER_OBJECT DriverObject
    )
{
    KIRQL irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    //
    // Once tainted, a driver can never lose it's legacy history
    // (unless unloaded). This is because the device object
    // field is optional, and we don't bother counting here...
    //
    DriverObject->Flags |= DRVO_LEGACY_RESOURCES;
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
}


NTSTATUS
IopLegacyResourceAllocation (
    IN ARBITER_REQUEST_SOURCE AllocationType,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources OPTIONAL
    )

/*++

Routine Description:

    This routine handles legacy interface IoAssignResources and IoReportResourcesUsage,
    It converts the request to call IopAllocateResources.

Parameters:

    AllocationType - Allocation type for the legacy request.

    DriverObject - Driver object doing the legacy allocation.

    DeviceObject - Device object.

    ResourceRequirements - Legacy resource requirements. If NULL, caller want to free resources.

    AllocatedResources - Pointer to a variable that receives pointer to allocated resources.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_OBJECT      pdo;
    PDEVICE_NODE        deviceNode;
    PDEVICE_NODE        legacyDeviceNode;
    NTSTATUS            status;
    PCM_RESOURCE_LIST   combinedResources;

    ASSERT(DriverObject);

    //
    // Grab the IO registry semaphore to make sure no other device is
    // reporting it's resource usage while we are searching for conflicts.
    //

    IopLockResourceManager();
    status = IopFindLegacyDeviceNode(DriverObject, DeviceObject, &deviceNode, &pdo);
    if (NT_SUCCESS(status)) {

        legacyDeviceNode = NULL;
        if (!deviceNode->Parent && ResourceRequirements) {

            //
            // Make IopRootDeviceNode the bus pdo so we will search the right bus pdo
            // on resource descriptor level.
            //

            if (ResourceRequirements->InterfaceType == InterfaceTypeUndefined) {

                ResourceRequirements->InterfaceType = PnpDefaultInterfaceType;

            }
            deviceNode->Parent = IopRootDeviceNode;

        }

        //
        // Release resources for this device node.
        //

        if (    (!ResourceRequirements && deviceNode->Parent) ||
                deviceNode->ResourceList ||
                deviceNode->BootResources) {

            IopReleaseResources(deviceNode);
        }

        if (ResourceRequirements) {

            IOP_RESOURCE_REQUEST    requestTable;
            IOP_RESOURCE_REQUEST    *requestTablep;
            ULONG                   count;

            //
            // Try to allocate these resource requirements.
            //

            count = 1;
            RtlZeroMemory(&requestTable, sizeof(IOP_RESOURCE_REQUEST));
            requestTable.ResourceRequirements = ResourceRequirements;
            requestTable.PhysicalDevice = pdo;
            requestTable.Flags = IOP_ASSIGN_NO_REBALANCE;
            requestTable.AllocationType =  AllocationType;

            requestTablep = &requestTable;
            IopAllocateResources(&count, &requestTablep, TRUE, TRUE, NULL);

            status = requestTable.Status;
            if (NT_SUCCESS(status)) {

                deviceNode->ResourceListTranslated = requestTable.TranslatedResourceAssignment;
                count = IopDetermineResourceListSize((*AllocatedResources) ? *AllocatedResources : requestTable.ResourceAssignment);
                deviceNode->ResourceList = ExAllocatePoolIORL(PagedPool, count);
                if (deviceNode->ResourceList) {

                    if (*AllocatedResources) {

                        //
                        // We got called from IoReportResourceUsage.
                        //

                        ASSERT(requestTable.ResourceAssignment);
                        ExFreePool(requestTable.ResourceAssignment);

                    } else {

                        //
                        // We got called from IoAssignResources.
                        //

                        *AllocatedResources = requestTable.ResourceAssignment;

                    }
                    RtlCopyMemory(deviceNode->ResourceList, *AllocatedResources, count);
                    legacyDeviceNode = (PDEVICE_NODE)deviceNode->OverUsed1.LegacyDeviceNode;

                } else {

                    deviceNode->ResourceList = requestTable.ResourceAssignment;
                    IopReleaseResources(deviceNode);
                    status = STATUS_INSUFFICIENT_RESOURCES;

                }
            }

            //
            // Remove the madeup PDO and device node if there was some error.
            //

            if (!NT_SUCCESS(status)) {

                IopRemoveLegacyDeviceNode(DeviceObject, deviceNode);

            }

        } else {

            //
            // Caller wants to release resources.
            //

            legacyDeviceNode = (PDEVICE_NODE)deviceNode->OverUsed1.LegacyDeviceNode;
            IopRemoveLegacyDeviceNode(DeviceObject, deviceNode);

        }

        if (NT_SUCCESS(status)) {

            if (legacyDeviceNode) {

                //
                // After the resource is modified, update the allocated resource list
                // for the Root\Legacy_xxxx\0000 device instance.
                //

                combinedResources = IopCombineLegacyResources(legacyDeviceNode);
                if (combinedResources) {

                    IopWriteAllocatedResourcesToRegistry(   legacyDeviceNode,
                                                            combinedResources,
                                                            IopDetermineResourceListSize(combinedResources));
                    ExFreePool(combinedResources);
                }
            }

            if (AllocationType != ArbiterRequestPnpDetected) {

                //
                // Modify the DRVOBJ flags.
                //
                if (ResourceRequirements) {

                    IopSetLegacyResourcesFlag(DriverObject);
                }
            }
        }
    }
    IopUnlockResourceManager();

    return status;
}

NTSTATUS
IopDuplicateDetection (
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    OUT PDEVICE_NODE *DeviceNode
    )

/*++

Routine Description:

    This routine searches for the bus device driver for a given legacy device,
    sends a query interface IRP for legacy device detection, and if the driver
    implements this interface, requests the PDO for the given legacy device.

Parameters:

    LegacyBusType - The legacy device's interface type.

    BusNumber - The legacy device's bus number.

    SlotNumber - The legacy device's slot number.

    DeviceNode - specifies a pointer to a variable to receive the duplicated device node

Return Value:

    NTSTATUS code.

--*/

{
    PDEVICE_NODE deviceNode;
    PDEVICE_OBJECT busDeviceObject;
    PLEGACY_DEVICE_DETECTION_INTERFACE interface;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;

    UNREFERENCED_PARAMETER(SlotNumber);
    //
    // Initialize return parameter to "not found".
    //
    *DeviceNode = NULL;
    //
    // Search the device tree for the bus of the legacy device.
    //
    deviceNode = IopFindLegacyBusDeviceNode(
                     LegacyBusType,
                     BusNumber);
    //
    // Either a bus driver does not exist (or more likely, the legacy bus
    // type and bus number were unspecified).  Either way, we can't make
    // any further progress.
    //
    if (deviceNode == NULL) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // We found the legacy device's bus driver.  Query it to determine
    // whether it implements the LEGACY_DEVICE_DETECTION interface.
    //

    busDeviceObject = deviceNode->PhysicalDeviceObject;
    status = IopQueryResourceHandlerInterface(
                 ResourceLegacyDeviceDetection,
                 busDeviceObject,
                 0,
                 (PINTERFACE *)&interface);
    //
    // If it doesn't, we're stuck.
    //
    if (!NT_SUCCESS(status) || interface == NULL) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }
    //
    // Invoke the bus driver's legacy device detection method.
    //
    status = (*interface->LegacyDeviceDetection)(
                 interface->Context,
                 LegacyBusType,
                 BusNumber,
                 SlotNumber,
                 &deviceObject);
    //
    // If it found a legacy device, update the return parameter.
    //
    if (NT_SUCCESS(status) && deviceObject != NULL) {

        *DeviceNode = PP_DO_TO_DN(deviceObject);

        status = STATUS_SUCCESS;
    } else {

        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    //
    // Free the interface.
    //
    (*interface->InterfaceDereference)(interface->Context);

    ExFreePool(interface);

    return status;
}

VOID
IopSetLegacyDeviceInstance (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine sets the Root\Legacy_xxxx\0000 device instance path to the
    madeup PDO (i.e. DeviceNode) which is created only for legacy resource allocation.
    This routine also links the madeup PDO to the Root\Legacy_xxxx\0000 device node
    to keep track what resources are assigned to the driver which services the
    root\legacy_xxxx\0000 device.

Parameters:

    P1 -

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    UNICODE_STRING instancePath, rootString;
    HANDLE handle;
    PDEVICE_NODE legacyDeviceNode;
    PDEVICE_OBJECT legacyPdo;

    PAGED_CODE();

    DeviceNode->OverUsed1.LegacyDeviceNode = 0;
    instancePath.Length = 0;
    instancePath.Buffer = NULL;

    status = PipServiceInstanceToDeviceInstance (
                 NULL,
                 &DriverObject->DriverExtension->ServiceKeyName,
                 0,
                 &instancePath,
                 &handle,
                 KEY_READ
                 );
    if (NT_SUCCESS(status) && (instancePath.Length != 0)) {
        PiWstrToUnicodeString(&rootString, L"ROOT\\LEGACY");
        if (RtlPrefixUnicodeString(&rootString, &instancePath, TRUE) == FALSE) {
            RtlFreeUnicodeString(&instancePath);
        } else {
            DeviceNode->InstancePath = instancePath;
            legacyPdo = IopDeviceObjectFromDeviceInstance (&instancePath);
            if (legacyPdo) {
                legacyDeviceNode = PP_DO_TO_DN(legacyPdo);
                DeviceNode->OverUsed2.NextResourceDeviceNode =
                    legacyDeviceNode->OverUsed2.NextResourceDeviceNode;
                legacyDeviceNode->OverUsed2.NextResourceDeviceNode = DeviceNode;
                DeviceNode->OverUsed1.LegacyDeviceNode = legacyDeviceNode;
            }
        }
        ZwClose(handle);
    }
}

PCM_RESOURCE_LIST
IopCombineLegacyResources (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine sets the Root\Legacy_xxxx\0000 device instance path to the
    madeup PDO (i.e. DeviceNode) which is created only for legacy resource allocation.
    This routine also links the madeup PDO to the Root\Legacy_xxxx\0000 device node
    to keep track what resources are assigned to the driver which services the
    root\legacy_xxxx\0000 device.

Parameters:

    DeviceNode - The legacy device node whose resources need to be combined.

Return Value:

    Return the combined resource list.

--*/

{
    PCM_RESOURCE_LIST combinedList = NULL;
    PDEVICE_NODE devNode = DeviceNode;
    ULONG size = 0;
    PUCHAR p;

    PAGED_CODE();

    if (DeviceNode) {

        //
        // First determine how much memory is needed for the new combined list.
        //

        while (devNode) {
            if (devNode->ResourceList) {
                size += IopDetermineResourceListSize(devNode->ResourceList);
            }
            devNode = (PDEVICE_NODE)devNode->OverUsed2.NextResourceDeviceNode;
        }
        if (size != 0) {
            combinedList = (PCM_RESOURCE_LIST) ExAllocatePoolCMRL(PagedPool, size);
            devNode = DeviceNode;
            if (combinedList) {
                combinedList->Count = 0;
                p = (PUCHAR)combinedList;
                p += sizeof(ULONG);  // Skip Count
                while (devNode) {
                    if (devNode->ResourceList) {
                        size = IopDetermineResourceListSize(devNode->ResourceList);
                        if (size != 0) {
                            size -= sizeof(ULONG);
                            RtlCopyMemory(
                                p,
                                devNode->ResourceList->List,
                                size
                                );
                            p += size;
                            combinedList->Count += devNode->ResourceList->Count;
                        }
                    }
                    devNode = (PDEVICE_NODE)devNode->OverUsed2.NextResourceDeviceNode;
                }
            }
        }
    }
    return combinedList;
}

VOID
IopReleaseResources (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    IopReleaseResources releases resources owned by the device and release
    the memory pool.  We also release the cached resource requirements list.
    If the device is a root enumerated device with BOOT config, we will preallocate
    boot config resources for this device.

    NOTE, this is a routine INTERNAL to this file.  NO one should call this function
    outside of this file.  Outside of this file, IopReleaseDeviceResources should be
    used.

Arguments:

    DeviceNode - Supplies a pointer to the device node.object.  If present, caller wants to

Return Value:

    None.

--*/
{

    //
    // Release the resources owned by the device
    //

    IopReleaseResourcesInternal(DeviceNode);

#if DBG_SCOPE

    if (DeviceNode->PreviousResourceList) {
        ExFreePool(DeviceNode->PreviousResourceList);
        DeviceNode->PreviousResourceList = NULL;
    }
    if (DeviceNode->PreviousResourceRequirements) {
        ExFreePool(DeviceNode->PreviousResourceRequirements);
        DeviceNode->PreviousResourceRequirements = NULL;
    }
#endif

    if (DeviceNode->ResourceList) {

#if DBG_SCOPE
        if (!NT_SUCCESS(DeviceNode->FailureStatus)) {
            DeviceNode->PreviousResourceList = DeviceNode->ResourceList;
        } else {
            ExFreePool(DeviceNode->ResourceList);
        }
#else
        ExFreePool(DeviceNode->ResourceList);
#endif

        DeviceNode->ResourceList = NULL;
    }
    if (DeviceNode->ResourceListTranslated) {
        ExFreePool(DeviceNode->ResourceListTranslated);
        DeviceNode->ResourceListTranslated = NULL;
    }

    //
    // If this device is a root enumerated device, preallocate its BOOT resources
    //

    if ((DeviceNode->Flags & (DNF_MADEUP | DNF_DEVICE_GONE)) == DNF_MADEUP) {
        if (DeviceNode->Flags & DNF_HAS_BOOT_CONFIG && DeviceNode->BootResources) {
            IopAllocateBootResourcesInternal(ArbiterRequestPnpEnumerated,
                                            DeviceNode->PhysicalDeviceObject,
                                            DeviceNode->BootResources);
        }
    } else {
        DeviceNode->Flags &= ~(DNF_HAS_BOOT_CONFIG | DNF_BOOT_CONFIG_RESERVED);
        if (DeviceNode->BootResources) {
            ExFreePool(DeviceNode->BootResources);
            DeviceNode->BootResources = NULL;
        }
    }
}

VOID
IopReallocateResources(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    This routine performs the real work for IoInvalidateDeviceState - ResourceRequirementsChanged.

Arguments:

    DeviceNode - Supplies a pointer to the device node.

Return Value:

    None.

--*/
{
    IOP_RESOURCE_REQUEST requestTable, *requestTablep;
    ULONG deviceCount, oldFlags;
    NTSTATUS status;
    LIST_ENTRY  activeArbiterList;

    PAGED_CODE();

    //
    // Grab the IO registry semaphore to make sure no other device is
    // reporting it's resource usage while we are searching for conflicts.
    //

    IopLockResourceManager();

    //
    // Check the flags after acquiring the semaphore.
    //

    if (DeviceNode->Flags & DNF_RESOURCE_REQUIREMENTS_CHANGED) {
        //
        // Save the flags which we may have to restore in case of failure.
        //

        oldFlags = DeviceNode->Flags & DNF_NO_RESOURCE_REQUIRED;
        DeviceNode->Flags &= ~DNF_NO_RESOURCE_REQUIRED;

        if (DeviceNode->Flags & DNF_NON_STOPPED_REBALANCE) {

            //
            // Set up parameters to call real routine
            //

            RtlZeroMemory(&requestTable, sizeof(IOP_RESOURCE_REQUEST));
            requestTable.PhysicalDevice = DeviceNode->PhysicalDeviceObject;
            requestTablep = &requestTable;
            requestTable.Flags |= IOP_ASSIGN_NO_REBALANCE + IOP_ASSIGN_KEEP_CURRENT_CONFIG;

            status = IopGetResourceRequirementsForAssignTable(  requestTablep,
                                                                requestTablep + 1,
                                                                &deviceCount);
            if (deviceCount) {

                //
                // Release the current resources to the arbiters.
                // Memory for ResourceList is not released.
                //

                if (DeviceNode->ResourceList) {

                    IopReleaseResourcesInternal(DeviceNode);
                }

                //
                // Try to do the assignment.
                //

                status = IopFindBestConfiguration(
                            requestTablep,
                            deviceCount,
                            &activeArbiterList);
                if (NT_SUCCESS(status)) {
                    //
                    // Ask the arbiters to commit this configuration.
                    //
                    status = IopCommitConfiguration(&activeArbiterList);
                }
                if (NT_SUCCESS(status)) {

                    DeviceNode->Flags &= ~(DNF_RESOURCE_REQUIREMENTS_CHANGED | DNF_NON_STOPPED_REBALANCE);

                    IopBuildCmResourceLists(requestTablep, requestTablep + 1);

                    //
                    // We need to release the pool space for ResourceList and ResourceListTranslated.
                    // Because the earlier IopReleaseResourcesInternal does not release the pool.
                    //

                    if (DeviceNode->ResourceList) {

                        ExFreePool(DeviceNode->ResourceList);

                    }
                    if (DeviceNode->ResourceListTranslated) {

                        ExFreePool(DeviceNode->ResourceListTranslated);

                    }

                    DeviceNode->ResourceList = requestTablep->ResourceAssignment;
                    DeviceNode->ResourceListTranslated = requestTablep->TranslatedResourceAssignment;

                    ASSERT(DeviceNode->State == DeviceNodeStarted);

                    status = IopStartDevice(DeviceNode->PhysicalDeviceObject);

                    if (!NT_SUCCESS(status)) {

                        PipRequestDeviceRemoval(DeviceNode, FALSE, CM_PROB_NORMAL_CONFLICT);
                    }

                } else {

                    NTSTATUS restoreResourcesStatus;

                    restoreResourcesStatus = IopRestoreResourcesInternal(DeviceNode);
                    if (!NT_SUCCESS(restoreResourcesStatus)) {

                        ASSERT(NT_SUCCESS(restoreResourcesStatus));
                        PipRequestDeviceRemoval(DeviceNode, FALSE, CM_PROB_NEED_RESTART);
                    }
                }

                IopFreeResourceRequirementsForAssignTable(requestTablep, requestTablep + 1);
            }

        } else {

            //
            // The device needs to be stopped to change resources.
            //

            status = IopRebalance(0, NULL);

        }

        //
        // Restore the flags in case of failure.
        //

        if (!NT_SUCCESS(status)) {

            DeviceNode->Flags &= ~DNF_NO_RESOURCE_REQUIRED;
            DeviceNode->Flags |= oldFlags;

        }

    } else {

        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "Resource requirements not changed in "
            "IopReallocateResources, returning error!\n"));
    }

    IopUnlockResourceManager();
}

NTSTATUS
IopQueryConflictList(
    PDEVICE_OBJECT        PhysicalDeviceObject,
    IN PCM_RESOURCE_LIST  ResourceList,
    IN ULONG              ResourceListSize,
    OUT PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN ULONG              ConflictListSize,
    IN ULONG              Flags
    )
/*++

Routine Description:

    This routine performs the querying of device conflicts
    returning data in ConflictList

Arguments:

    PhysicalDeviceObject PDO of device to Query
    ResourceList      CM resource list containing single resource to query
    ResourceListSize  Size of ResourceList
    ConflictList      Conflict list to fill query details in
    ConflictListSize  Size of buffer that we can fill with Conflict information
    Flags             Currently unused (zero) for future passing of flags

Return Value:

    Should be success in most cases

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IopLockResourceManager();

    status = IopQueryConflictListInternal(PhysicalDeviceObject, ResourceList, ResourceListSize, ConflictList, ConflictListSize, Flags);

    IopUnlockResourceManager();

    return status;
}



BOOLEAN
IopEliminateBogusConflict(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PDEVICE_OBJECT   ConflictDeviceObject
    )
/*++

Routine Description:

    Determine if we're really conflicting with ourselves
    if this is the case, we ignore it

Arguments:

    PhysicalDeviceObject  PDO we're performing the test for
    ConflictDeviceObject  The object we've determined is conflicting

Return Value:

    TRUE to eliminate the conflict

--*/
{
    PDEVICE_NODE deviceNode;
    PDRIVER_OBJECT driverObject;
    KIRQL           irql;
    PDEVICE_OBJECT  attachedDevice;

    //
    // simple cases
    //
    if (PhysicalDeviceObject == NULL || ConflictDeviceObject == NULL) {
        return FALSE;
    }
    //
    // if ConflictDeviceObject is on PDO's stack, this is a non-conflict
    // nb at least PDO has to be checked
    //
    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    for (attachedDevice = PhysicalDeviceObject;
         attachedDevice;
         attachedDevice = attachedDevice->AttachedDevice) {

        if (attachedDevice == ConflictDeviceObject) {
            KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
            return TRUE;
        }
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    //
    // legacy case
    //
    deviceNode = PP_DO_TO_DN(PhysicalDeviceObject);
    ASSERT(deviceNode);
    if (deviceNode->Flags & DNF_LEGACY_DRIVER) {
        //
        // hmmm, let's see if our ConflictDeviceObject is resources associated with a legacy device
        //
        if (ConflictDeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE) {
            //
            // if not, we have a legacy conflicting with non-legacy, we're interested!
            //
            return FALSE;
        }
        //
        // FDO, report driver name
        //
        driverObject = ConflictDeviceObject->DriverObject;
        if(driverObject == NULL) {
            //
            // should not be NULL
            //
            ASSERT(driverObject);
            return FALSE;
        }
        //
        // compare deviceNode->Service with driverObject->Service
        //
        if (deviceNode->ServiceName.Length != 0 &&
            deviceNode->ServiceName.Length == driverObject->DriverExtension->ServiceKeyName.Length &&
            RtlCompareUnicodeString(&deviceNode->ServiceName,&driverObject->DriverExtension->ServiceKeyName,TRUE)==0) {
            //
            // the driver's service name is the same that this PDO is associated with
            // by ignoring it we could end up ignoring conflicts of simular types of legacy devices
            // but since these have to be hand-config'd anyhow, it's prob better than having false conflicts
            //
            return TRUE;
        }

    }
    return FALSE;
}


NTSTATUS
IopQueryConflictFillString(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PWSTR            Buffer,
    IN OUT PULONG       Length,
    IN OUT PULONG       Flags
    )
/*++

Routine Description:

    Obtain string or string-length for details of conflicting device

Arguments:

    DeviceObject        Device object we want Device-Instance-String or Service Name
    Buffer              Buffer to Fill, NULL if we just want length
    Length              Filled with length of Buffer, including terminated NULL (Words)
    Flags               Apropriate flags set describing what the string represents

Return Value:

    Should be success in most cases

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_NODE deviceNode;
    PDRIVER_OBJECT driverObject;
    PUNICODE_STRING infoString = NULL;
    ULONG MaxLength = 0;        // words
    ULONG ReqLength = 0;        // words
    ULONG flags = 0;

    PAGED_CODE();

    if (Length != NULL) {
        MaxLength = *Length;
    }

    if (Flags != NULL) {
        flags = *Flags;
    }

    if (DeviceObject == NULL) {
        //
        // unknown
        //
        goto final;

    }

    if ((DeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE) == 0 ) {
        //
        // FDO, report driver name
        //
        driverObject = DeviceObject->DriverObject;
        if(driverObject == NULL) {
            //
            // should not be NULL
            //
            ASSERT(driverObject);
            goto final;
        }
        infoString = & (driverObject->DriverName);
        flags |= PNP_CE_LEGACY_DRIVER;
        goto final;
    }

    //
    // we should in actual fact have a PDO
    //
    if (DeviceObject->DeviceObjectExtension == NULL) {
        //
        // should not be NULL
        //
        ASSERT(DeviceObject->DeviceObjectExtension);
        goto final;
    }

    deviceNode = PP_DO_TO_DN(DeviceObject);
    if (deviceNode == NULL) {
        //
        // should not be NULL
        //
        ASSERT(deviceNode);
        goto final;
    }

    if (deviceNode == IopRootDeviceNode) {
        //
        // owned by root device
        //
        flags |= PNP_CE_ROOT_OWNED;

    } else if (deviceNode -> Parent == NULL) {
        //
        // faked out PDO - must be legacy device
        //
        driverObject = (PDRIVER_OBJECT)(deviceNode->DuplicatePDO);
        if(driverObject == NULL) {
            //
            // should not be NULL
            //
            ASSERT(driverObject);
            goto final;
        }
        infoString = & (driverObject->DriverName);
        flags |= PNP_CE_LEGACY_DRIVER;
        goto final;
    }

    //
    // we should be happy with what we have
    //
    infoString = &deviceNode->InstancePath;

final:

    if (infoString != NULL) {
        //
        // we have a string to copy
        //
        if ((Buffer != NULL) && (MaxLength*sizeof(WCHAR) > infoString->Length)) {
            RtlCopyMemory(Buffer, infoString->Buffer, infoString->Length);
        }
        ReqLength += infoString->Length / sizeof(WCHAR);
    }

    if ((Buffer != NULL) && (MaxLength > ReqLength)) {
        Buffer[ReqLength] = 0;
    }

    ReqLength++;

    if (Length != NULL) {
        *Length = ReqLength;
    }
    if (Flags != NULL) {
        *Flags = flags;
    }

    return status;
}


NTSTATUS
IopQueryConflictFillConflicts(
    PDEVICE_OBJECT                  PhysicalDeviceObject,
    IN ULONG                        ConflictCount,
    IN PARBITER_CONFLICT_INFO       ConflictInfoList,
    OUT PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN ULONG                        ConflictListSize,
    IN ULONG                        Flags
    )
/*++

Routine Description:

    Fill ConflictList with information on as many conflicts as possible

Arguments:

    PhysicalDeviceObject The PDO we're performing the test on
    ConflictCount       Number of Conflicts.
    ConflictInfoList    List of conflicting device info, can be NULL if ConflictCount is 0
    ConflictList        Structure to fill in with conflicts
    ConflictListSize    Size of Conflict List
    Flags               if non-zero, dummy conflict is created

Return Value:

    Should be success in most cases

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ConflictListIdealSize;
    ULONG ConflictListCount;
    ULONG Index;
    ULONG ConflictIndex;
    ULONG EntrySize;
    ULONG ConflictStringsOffset;
    ULONG stringSize;
    ULONG stringTotalSize;
    ULONG DummyCount;
    PPLUGPLAY_CONTROL_CONFLICT_STRINGS ConfStrings;

    PAGED_CODE();

    //
    // determine how many conflicts we can
    //
    // for each conflict
    // translate to bus/resource/address in respect to conflicting device
    // add to conflict list
    //
    //

    //
    // preprocessing - given our ConflictInfoList and ConflictCount
    // remove any that appear to be bogus - ie, that are the same device that we are testing against
    // this stops mostly legacy issues
    //
    for(Index = 0;Index < ConflictCount; Index++) {
        if (IopEliminateBogusConflict(PhysicalDeviceObject,ConflictInfoList[Index].OwningObject)) {

            IopDbgPrint((
                IOP_RESOURCE_VERBOSE_LEVEL,
                "IopQueryConflictFillConflicts: eliminating \"identical\" PDO"
                " %08x conflicting with self (%08x)\n",
                ConflictInfoList[Index].OwningObject,
                PhysicalDeviceObject));
            //
            // move the last listed conflict into this space
            //
            if (Index+1 < ConflictCount) {
                RtlCopyMemory(&ConflictInfoList[Index],&ConflictInfoList[ConflictCount-1],sizeof(ARBITER_CONFLICT_INFO));
            }
            //
            // account for deleting this item
            //
            ConflictCount--;
            Index--;
        }
    }

    //
    // preprocessing - in our conflict list, we may have PDO's for legacy devices, and resource nodes for the same
    // or other duplicate entities (we only ever want to report a conflict once, even if there's multiple conflicting ranges)
    //

  RestartScan:

    for(Index = 0;Index < ConflictCount; Index++) {
        if (ConflictInfoList[Index].OwningObject != NULL) {

            ULONG Index2;

            for (Index2 = Index+1; Index2 < ConflictCount; Index2++) {
                if (IopEliminateBogusConflict(ConflictInfoList[Index].OwningObject,ConflictInfoList[Index2].OwningObject)) {
                    //
                    // Index2 is considered a dup of Index
                    //

                    IopDbgPrint((
                        IOP_RESOURCE_VERBOSE_LEVEL,
                        "IopQueryConflictFillConflicts: eliminating \"identical\" PDO"
                        " %08x conflicting with PDO %08x\n",
                        ConflictInfoList[Index2].OwningObject,
                        ConflictInfoList[Index].OwningObject));
                    //
                    // move the last listed conflict into this space
                    //
                    if (Index2+1 < ConflictCount) {
                        RtlCopyMemory(&ConflictInfoList[Index2],&ConflictInfoList[ConflictCount-1],sizeof(ARBITER_CONFLICT_INFO));
                    }
                    //
                    // account for deleting this item
                    //
                    ConflictCount--;
                    Index2--;
                } else if (IopEliminateBogusConflict(ConflictInfoList[Index2].OwningObject,ConflictInfoList[Index].OwningObject)) {
                    //
                    // Index is considered a dup of Index2 (some legacy case)
                    //
                    IopDbgPrint((
                        IOP_RESOURCE_VERBOSE_LEVEL,
                        "IopQueryConflictFillConflicts: eliminating \"identical\" PDO"
                        " %08x conflicting with PDO %08x\n",
                        ConflictInfoList[Index2].OwningObject,
                        ConflictInfoList[Index].OwningObject));
                    //
                    // move the one we want (Index2) into the space occupied by Index
                    //
                    RtlCopyMemory(&ConflictInfoList[Index],&ConflictInfoList[Index2],sizeof(ARBITER_CONFLICT_INFO));
                    //
                    // move the last listed conflict into the space we just created
                    //
                    if (Index2+1 < ConflictCount) {
                        RtlCopyMemory(&ConflictInfoList[Index2],&ConflictInfoList[ConflictCount-1],sizeof(ARBITER_CONFLICT_INFO));
                    }
                    //
                    // account for deleting this item
                    //
                    ConflictCount--;
                    //
                    // but as this is quirky, restart the scan
                    //
                    goto RestartScan;
                }
            }
        }
    }

    //
    // preprocessing - if we have any known reported conflicts, don't report back any unknown
    //

    for(Index = 0;Index < ConflictCount; Index++) {
        //
        // find first unknown
        //
        if (ConflictInfoList[Index].OwningObject == NULL) {
            //
            // eliminate all other unknowns
            //

            ULONG Index2;

            for (Index2 = Index+1; Index2 < ConflictCount; Index2++) {
                if (ConflictInfoList[Index2].OwningObject == NULL) {

                    IopDbgPrint((
                        IOP_RESOURCE_VERBOSE_LEVEL,
                        "IopQueryConflictFillConflicts: eliminating extra"
                        " unknown\n"));
                    //
                    // move the last listed conflict into this space
                    //
                    if (Index2+1 < ConflictCount) {
                        RtlCopyMemory(&ConflictInfoList[Index2],&ConflictInfoList[ConflictCount-1],sizeof(ARBITER_CONFLICT_INFO));
                    }
                    //
                    // account for deleting this item
                    //
                    ConflictCount--;
                    Index2--;
                }
            }

            if(ConflictCount != 1) {

                IopDbgPrint((
                    IOP_RESOURCE_VERBOSE_LEVEL,
                    "IopQueryConflictFillConflicts: eliminating first unknown\n"
                    ));
                //
                // there were others, so ignore the unknown
                //
                if (Index+1 < ConflictCount) {
                    RtlCopyMemory(&ConflictInfoList[Index],&ConflictInfoList[ConflictCount-1],sizeof(ARBITER_CONFLICT_INFO));
                }
                ConflictCount --;
            }

            break;
        }
    }

    //
    // set number of actual and listed conflicts
    //

    ConflictListIdealSize = (sizeof(PLUGPLAY_CONTROL_CONFLICT_LIST) - sizeof(PLUGPLAY_CONTROL_CONFLICT_ENTRY)) + sizeof(PLUGPLAY_CONTROL_CONFLICT_STRINGS);
    ConflictListCount = 0;
    stringTotalSize = 0;
    DummyCount = 0;

    ASSERT(ConflictListSize >= ConflictListIdealSize); // we should have checked to see if buffer is at least this big

    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "IopQueryConflictFillConflicts: Detected %d conflicts\n",
        ConflictCount));

    //
    // estimate sizes
    //
    if (Flags) {
        //
        // flags entry required (ie resource not available for some specified reason)
        //
        stringSize = 1; // null-length string
        DummyCount ++;
        EntrySize = sizeof(PLUGPLAY_CONTROL_CONFLICT_ENTRY);
        EntrySize += sizeof(WCHAR) * stringSize;

        if((ConflictListIdealSize+EntrySize) <= ConflictListSize) {
            //
            // we can fit this one in
            //
            ConflictListCount++;
            stringTotalSize += stringSize;
        }
        ConflictListIdealSize += EntrySize;
    }
    //
    // report conflicts
    //
    for(Index = 0; Index < ConflictCount; Index ++) {

        stringSize = 0;
        IopQueryConflictFillString(ConflictInfoList[Index].OwningObject,NULL,&stringSize,NULL);

        //
        // account for entry
        //
        EntrySize = sizeof(PLUGPLAY_CONTROL_CONFLICT_ENTRY);
        EntrySize += sizeof(WCHAR) * stringSize;

        if((ConflictListIdealSize+EntrySize) <= ConflictListSize) {
            //
            // we can fit this one in
            //
            ConflictListCount++;
            stringTotalSize += stringSize;
        }
        ConflictListIdealSize += EntrySize;
    }

    ConflictList->ConflictsCounted = ConflictCount+DummyCount; // number of conflicts detected including any dummy conflict
    ConflictList->ConflictsListed = ConflictListCount;         // how many we could fit in
    ConflictList->RequiredBufferSize = ConflictListIdealSize;  // how much buffer space to supply on next call

    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "IopQueryConflictFillConflicts: Listing %d conflicts\n",
        ConflictListCount));
    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "IopQueryConflictFillConflicts: Need %08x bytes to list all conflicts\n",
        ConflictListIdealSize));

    ConfStrings = (PPLUGPLAY_CONTROL_CONFLICT_STRINGS)&(ConflictList->ConflictEntry[ConflictListCount]);
    ConfStrings->NullDeviceInstance = (ULONG)(-1);
    ConflictStringsOffset = 0;

    for(ConflictIndex = 0; ConflictIndex < DummyCount; ConflictIndex++) {
        //
        // flags entry required (ie resource not available for some specified reason)
        //
        if (Flags && ConflictIndex == 0) {
            ConflictList->ConflictEntry[ConflictIndex].DeviceInstance = ConflictStringsOffset;
            ConflictList->ConflictEntry[ConflictIndex].DeviceFlags = Flags;
            ConflictList->ConflictEntry[ConflictIndex].ResourceType = 0;
            ConflictList->ConflictEntry[ConflictIndex].ResourceStart = 0;
            ConflictList->ConflictEntry[ConflictIndex].ResourceEnd = 0;
            ConflictList->ConflictEntry[ConflictIndex].ResourceFlags = 0;

            ConfStrings->DeviceInstanceStrings[ConflictStringsOffset] = 0; // null string
            stringTotalSize --;
            ConflictStringsOffset ++;
            IopDbgPrint((
                IOP_RESOURCE_VERBOSE_LEVEL,
                "IopQueryConflictFillConflicts: Listing flags %08x\n",
                Flags));
        }
    }
    //
    // get/fill in details for all those we can fit into the buffer
    //
    for(Index = 0; ConflictIndex < ConflictListCount ; Index ++, ConflictIndex++) {

        ASSERT(Index < ConflictCount);
        //
        // assign conflict information
        //
        ConflictList->ConflictEntry[ConflictIndex].DeviceInstance = ConflictStringsOffset;
        ConflictList->ConflictEntry[ConflictIndex].DeviceFlags = 0;
        ConflictList->ConflictEntry[ConflictIndex].ResourceType = 0; // NYI
        ConflictList->ConflictEntry[ConflictIndex].ResourceStart = (ULONGLONG)(1); // for now, return totally invalid range (1-0)
        ConflictList->ConflictEntry[ConflictIndex].ResourceEnd = 0;
        ConflictList->ConflictEntry[ConflictIndex].ResourceFlags = 0;

        //
        // fill string details
        //
        stringSize = stringTotalSize;
        IopQueryConflictFillString(ConflictInfoList[Index].OwningObject,
                                    &(ConfStrings->DeviceInstanceStrings[ConflictStringsOffset]),
                                    &stringSize,
                                    &(ConflictList->ConflictEntry[ConflictIndex].DeviceFlags));
        stringTotalSize -= stringSize;
        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "IopQueryConflictFillConflicts: Listing \"%S\"\n",
            &(ConfStrings->DeviceInstanceStrings[ConflictStringsOffset])));
        ConflictStringsOffset += stringSize;
    }

    //
    // another NULL at end of strings (this is accounted for in the PPLUGPLAY_CONTROL_CONFLICT_STRINGS structure)
    //
    ConfStrings->DeviceInstanceStrings[ConflictStringsOffset] = 0;

    //Clean0:
    ;
    return status;
}

NTSTATUS
IopQueryConflictListInternal(
    PDEVICE_OBJECT        PhysicalDeviceObject,
    IN PCM_RESOURCE_LIST  ResourceList,
    IN ULONG              ResourceListSize,
    OUT PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN ULONG              ConflictListSize,
    IN ULONG              Flags
    )
/*++

Routine Description:

    Version of IopQueryConflictList without the locking

--*/
{
    NTSTATUS status;
    PDEVICE_NODE deviceNode;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResources;
    PREQ_LIST reqList;
    PREQ_DESC reqDesc, reqDescTranslated;
    PPI_RESOURCE_ARBITER_ENTRY arbiterEntry;
    PREQ_ALTERNATIVE RA;
    PPREQ_ALTERNATIVE reqAlternative;
    ULONG ConflictCount;
    PARBITER_CONFLICT_INFO ConflictInfoList;
    PIO_RESOURCE_DESCRIPTOR ConflictDesc = NULL;
    ULONG ReqDescCount;
    PREQ_DESC *ReqDescTable;
    PIO_RESOURCE_REQUIREMENTS_LIST pIoReqList;
    PVOID ExtParams[4];
    IOP_RESOURCE_REQUEST request;

    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(ResourceListSize);

    PAGED_CODE();

    ASSERT(PhysicalDeviceObject);
    ASSERT(ResourceList);
    ASSERT(ResourceListSize >= sizeof(CM_RESOURCE_LIST));
    ASSERT(ResourceList->Count == 1);
    ASSERT(ResourceList->List[0].PartialResourceList.Count == 1);
    ASSERT(ConflictList);
    ASSERT(ConflictListSize >= MIN_CONFLICT_LIST_SIZE);
    //
    // Initialize locals so we can cleanup on the way out.
    //
    ioResources = NULL;
    reqList = NULL;
    //
    // Pre-initialize returned data.
    //
    ConflictList->ConflictsCounted = 0;
    ConflictList->ConflictsListed = 0;
    ConflictList->RequiredBufferSize = MIN_CONFLICT_LIST_SIZE;
    //
    // Retrieve the devnode from the PDO
    //
    deviceNode = PP_DO_TO_DN(PhysicalDeviceObject);
    if (!deviceNode) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }
    //
    // Validate resource type.
    //
    switch(ResourceList->List[0].PartialResourceList.PartialDescriptors[0].Type) {
    
        case CmResourceTypePort:
        case CmResourceTypeMemory:
            if(ResourceList->List[0].PartialResourceList.PartialDescriptors[0].u.Generic.Length == 0) {
                //
                // Zero length resource can never conflict.
                //
                status = STATUS_SUCCESS;
                goto Clean0;
            }
            break;

        case CmResourceTypeInterrupt:
        case CmResourceTypeDma:
            break;

        default:
            ASSERT(0);
            status = STATUS_INVALID_PARAMETER;
            goto Clean0;
    }
    //
    // Get the interface type from the devnode.
    //
    pIoReqList = deviceNode->ResourceRequirements;
    if (deviceNode->ChildInterfaceType != InterfaceTypeUndefined) {

        ResourceList->List[0].InterfaceType = deviceNode->ChildInterfaceType;
    } else if (pIoReqList && pIoReqList->InterfaceType != InterfaceTypeUndefined) {

        ResourceList->List[0].InterfaceType = pIoReqList->InterfaceType;
    } else {
        //
        // If we get here, something is wrong with resource picker UI.
        //
        MAX_ASSERT(0);
        ResourceList->List[0].InterfaceType = PnpDefaultInterfaceType;
    }
    //
    // Map certain interface types to default one.
    //
    if (ResourceList->List[0].InterfaceType == PCMCIABus) {

        ResourceList->List[0].InterfaceType = PnpDefaultInterfaceType;
    }
    //
    // Get the bus number from the devnode.
    //
    if (deviceNode->ChildBusNumber != (ULONG)-1) {

        ResourceList->List[0].BusNumber = deviceNode->ChildBusNumber;
    } else if (pIoReqList && pIoReqList->BusNumber != (ULONG)-1) {

        ResourceList->List[0].BusNumber = pIoReqList->BusNumber;
    } else {
        //
        // If we get here, something is wrong with resource picker UI.
        //
        MAX_ASSERT(0);
        ResourceList->List[0].BusNumber = 0;
    }
    //
    // Convert CM Resource List to an IO Resource Requirements List.
    //
    ioResources = IopCmResourcesToIoResources(0, ResourceList, LCPRI_FORCECONFIG);
    if (!ioResources) {

        status = STATUS_INVALID_PARAMETER;
        goto Clean0;
    }
    //
    // Convert IO Resource Requirements List to Req List so we can call the arbiters.
    //
    request.AllocationType = ArbiterRequestUndefined;
    request.ResourceRequirements = ioResources;
    request.PhysicalDevice = PhysicalDeviceObject;
    status = IopResourceRequirementsListToReqList(
                    &request,
                    &reqList);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    if (reqList == NULL) {

        MAX_ASSERT(0);
        status = STATUS_INVALID_PARAMETER;
        goto Clean0;
    }
    reqAlternative = reqList->AlternativeTable;
    RA = *reqAlternative;
    reqList->SelectedAlternative = reqAlternative;

    ReqDescCount = RA->DescCount;
    ReqDescTable = RA->DescTable;
    //
    // We should only get one descriptor.
    //
    if (ReqDescCount != 1) {

        status = STATUS_INVALID_PARAMETER;
        goto Clean0;
    }
    reqDesc = *ReqDescTable;
    if (!reqDesc->ArbitrationRequired) {

        status = STATUS_INVALID_PARAMETER;
        goto Clean0;
    }
    reqDescTranslated = reqDesc->TranslatedReqDesc;
    arbiterEntry = reqDesc->u.Arbiter;
    ASSERT(arbiterEntry);
    //
    // The descriptor of interest - translated, first non-special alternative 
    // in the table.
    //
    ConflictDesc = reqDescTranslated->AlternativeTable.Alternatives;
    if( ConflictDesc->Type == CmResourceTypeConfigData || 
        ConflictDesc->Type == CmResourceTypeReserved) {

        ConflictDesc++;
    }
    //
    // Call the arbiter to get the actual conflict information.
    // 
    ConflictCount = 0;
    ConflictInfoList = NULL;

    ExtParams[0] = PhysicalDeviceObject;
    ExtParams[1] = ConflictDesc;
    ExtParams[2] = &ConflictCount;
    ExtParams[3] = &ConflictInfoList;
    status = IopCallArbiter(
                arbiterEntry, 
                ArbiterActionQueryConflict, 
                ExtParams, 
                NULL, 
                NULL);
    if (NT_SUCCESS(status)) {
        //
        // Get the conflict information.
        //
        status = IopQueryConflictFillConflicts(
                    PhysicalDeviceObject,
                    ConflictCount,
                    ConflictInfoList,
                    ConflictList,
                    ConflictListSize,
                    0);
        if(ConflictInfoList != NULL) {

            ExFreePool(ConflictInfoList);
        }

    } else if(status == STATUS_RANGE_NOT_FOUND) {
        //
        // fill in with flag indicating bad range (this means range is not available)
        // ConflictInfoList should not be allocated
        //
        status = IopQueryConflictFillConflicts(
                    NULL,
                    0,
                    NULL,
                    ConflictList,
                    ConflictListSize,
                    PNP_CE_TRANSLATE_FAILED);
    }

Clean0:
    //
    // Clean up.
    //
    IopCheckDataStructures(IopRootDeviceNode);

    if (ioResources) {

        ExFreePool(ioResources);
    }
    if (reqList) {

        IopFreeReqList(reqList);
    }

    return status;
}

/*++

    SECTION = REBALANCE.

    Description:

        This section contains code that implements functions to performa
        resource rebalance.

--*/

VOID
IopQueryRebalance (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG Phase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    )

/*++

Routine Description:

    This routine walks hardware tree depth first.  For each device node it visits,
    it call IopQueryReconfigureDevice to query-stop device for resource
    reconfiguration.

    Note, Under rebalancing situation, all the participated devices will be asked to
    stop.  Even they support non-stopped rebalancing.

Parameters:

    DeviceNode - supplies a pionter a device node which is the root of the tree to
                 be tested.

    Phase - Supplies a value to specify the phase of the rebalance.

    RebalanceCount - supplies a pointer to a variable to receive the number of devices
                 participating the rebalance.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT *deviceList, *deviceTable, *device;
    ULONG count;
    PDEVICE_NODE deviceNode;


    //
    // Call worker routine to get a list of devices to be rebalanced.
    //

    deviceTable = *DeviceTable;
    IopQueryRebalanceWorker (DeviceNode, Phase, RebalanceCount, DeviceTable);

    count = *RebalanceCount;
    if (count != 0 && Phase == 0) {

        //
        // At phase 0, we did not actually query-stop the device.
        // We need to do it now.
        //

        deviceList = (PDEVICE_OBJECT *)ExAllocatePoolPDO(PagedPool, count * sizeof(PDEVICE_OBJECT));
        if (deviceList == NULL) {
            *RebalanceCount = 0;
            return;
        }
        RtlCopyMemory(deviceList, deviceTable, sizeof(PDEVICE_OBJECT) * count);

        //
        // Rebuild the returned device list
        //

        *RebalanceCount = 0;
        *DeviceTable = deviceTable;
        for (device = deviceList; device < (deviceList + count); device++) {
            deviceNode = PP_DO_TO_DN(*device);
            IopQueryRebalanceWorker (deviceNode, 1, RebalanceCount, DeviceTable);
        }
        ExFreePool(deviceList);
    }
    return;
}

VOID
IopQueryRebalanceWorker (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG Phase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    )

/*++

Routine Description:

    This routine walks hardware tree depth first.  For each device node it visits,
    it call IopQueryReconfigureDevice to query-stop and stop device for resource
    reconfiguration.

Parameters:

    DeviceNode - supplies a pionter a device node which is the root of the tree to
                 be tested.

    Phase - Supplies a value to specify the phase of the rebalance.

    RebalanceCount - supplies a pointer to a variable to receive the number of devices
                 participating the rebalance.

Return Value:

    None.

--*/

{
    PDEVICE_NODE node;

    ASSERT(DeviceNode);

    //
    // We dont include following in rebalance
    //  a. non-started devices
    //  b. devices with problem
    //  c. devices with legacy driver
    //
    if (    DeviceNode == NULL ||
            DeviceNode->State != DeviceNodeStarted ||
            PipDoesDevNodeHaveProblem(DeviceNode) ||
            (DeviceNode->Flags & DNF_LEGACY_DRIVER)) {

        return;
    }
    //
    // Recursively test the entire subtree.
    //
    for (node = DeviceNode->Child; node; node = node->Sibling) {

        IopQueryRebalanceWorker(node, Phase, RebalanceCount, DeviceTable);
    }
    //
    // Test the root of the subtree.
    //
    IopTestForReconfiguration(DeviceNode, Phase, RebalanceCount, DeviceTable);
}

VOID
IopTestForReconfiguration (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG Phase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    )


/*++

Routine Description:

    This routine query-stops a device which is started and owns resources.
    Note the resources for the device are not released at this point.

Parameters:

    DeviceNode - supplies a pointer to the device node to be tested for reconfiguration.

    Phase - Supplies a value to specify the phase of the rebalance.

    RebalanceCount - supplies a pointer to a variable to receive the number of devices
                 participating the rebalance.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_NODE nodex;
    NTSTATUS status;
    BOOLEAN addToList = FALSE;

    if (Phase == 0) {

        //
        // At phase zero, this routine only wants to find out which devices's resource
        // requirements lists chagned.  No one actually gets stopped.
        //

        if ((DeviceNode->Flags & DNF_RESOURCE_REQUIREMENTS_CHANGED) &&
            !(DeviceNode->Flags & DNF_NON_STOPPED_REBALANCE) ) {

            //
            // It's too hard to handle non-stop rebalancing devices during rebalance.
            // So, We will skip it.
            //

            addToList = TRUE;
        } else {

            if (DeviceNode->State == DeviceNodeStarted) {
                status = IopQueryReconfiguration (IRP_MN_QUERY_STOP_DEVICE, DeviceNode->PhysicalDeviceObject);
                if (NT_SUCCESS(status)) {
                    if (status == STATUS_RESOURCE_REQUIREMENTS_CHANGED) {

                        //
                        // If we find out a device's resource requirements changed this way,
                        // it will be stopped and reassigned resources even if it supports
                        // non-stopped rebalance.
                        //

                        DeviceNode->Flags |= DNF_RESOURCE_REQUIREMENTS_CHANGED;
                        addToList = TRUE;
                    }
                }
                IopQueryReconfiguration (IRP_MN_CANCEL_STOP_DEVICE, DeviceNode->PhysicalDeviceObject);
            }
        }
        if (addToList) {
            *RebalanceCount = *RebalanceCount + 1;
            **DeviceTable = DeviceNode->PhysicalDeviceObject;
            *DeviceTable = *DeviceTable + 1;
        }
    } else {

        //
        // Phase 1
        //

        if (DeviceNode->State == DeviceNodeStarted) {

            //
            // Make sure all the resources required children of the DeviceNode are stopped.
            //

            nodex = DeviceNode->Child;
            while (nodex) {
                if (nodex->State == DeviceNodeUninitialized ||
                    nodex->State == DeviceNodeInitialized ||
                    nodex->State == DeviceNodeDriversAdded ||
                    nodex->State == DeviceNodeQueryStopped ||
                    nodex->State == DeviceNodeRemovePendingCloses ||
                    nodex->State == DeviceNodeRemoved ||
                    (nodex->Flags & DNF_NEEDS_REBALANCE)) {
                    nodex = nodex->Sibling;
                } else {
                    break;
                }
            }

            if (nodex) {

                //
                // If any resource required child of the DeviceNode is not stopped,
                // we won't ask the DeviceNode to stop.
                //

                IopDbgPrint((
                    IOP_RESOURCE_INFO_LEVEL,
                    "Rebalance: Child %ws not stopped for %ws\n",
                    nodex->InstancePath.Buffer,
                    DeviceNode->InstancePath.Buffer));
                return;
            }
        } else if (DeviceNode->State != DeviceNodeDriversAdded ||
                   !(DeviceNode->Flags & DNF_HAS_BOOT_CONFIG) ||
                    (DeviceNode->Flags & DNF_MADEUP)) {

            //
            // The device is not started and has no boot config.  There is no need to query-stop it.
            // Or if the device has BOOT config but there is no driver installed for it.  We don't query
            // stop it. (There may be legacy drivers are using the resources.)
            // We also don't want to query stop root enumerated devices (for performance reason.)
            //

            return;
        }

        status = IopQueryReconfiguration (IRP_MN_QUERY_STOP_DEVICE, DeviceNode->PhysicalDeviceObject);
        if (NT_SUCCESS(status)) {
            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Rebalance: %ws succeeded QueryStop\n",
                DeviceNode->InstancePath.Buffer));

            if (DeviceNode->State == DeviceNodeStarted) {

                PipSetDevNodeState(DeviceNode, DeviceNodeQueryStopped, NULL);

                *RebalanceCount = *RebalanceCount + 1;
                **DeviceTable = DeviceNode->PhysicalDeviceObject;

                //
                // Add a reference to the device object such that it won't disapear during rebalance.
                //

                ObReferenceObject(DeviceNode->PhysicalDeviceObject);
                *DeviceTable = *DeviceTable + 1;
            } else {

                //
                // We need to release the device's prealloc boot config.  This device will NOT
                // participate in resource rebalancing.
                //

                ASSERT(DeviceNode->Flags & DNF_HAS_BOOT_CONFIG);
                status = IopQueryReconfiguration (IRP_MN_STOP_DEVICE, DeviceNode->PhysicalDeviceObject);
                ASSERT(NT_SUCCESS(status));
                IopReleaseBootResources(DeviceNode);

                //
                // Reset BOOT CONFIG flags.
                //

                DeviceNode->Flags &= ~(DNF_HAS_BOOT_CONFIG + DNF_BOOT_CONFIG_RESERVED);
            }
        } else {
            IopQueryReconfiguration (IRP_MN_CANCEL_STOP_DEVICE, DeviceNode->PhysicalDeviceObject);
        }
    }

}

NTSTATUS
IopRebalance(
    IN ULONG AssignTableCount,
    IN PIOP_RESOURCE_REQUEST AssignTable
    )
/*++

Routine Description:

    This routine performs rebalancing operation.  There are two rebalance phases:
    In the phase 0, we only consider the devices whoes resource requirements changed
    and their children; in phase 1, we consider anyone who succeeds the query-stop.

Parameters:

    AssignTableCount,
    AssignTable - Supplies the number of origianl AssignTableCout and AssignTable which
                  triggers the rebalance operation.

        (if AssignTableCount == 0, we are processing device state change.)

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    ULONG i;
    PIOP_RESOURCE_REQUEST table = NULL, tableEnd, newEntry;
    PIOP_RESOURCE_REQUEST requestTable = NULL, requestTableEnd, entry1, entry2;
    ULONG phase0RebalanceCount = 0, rebalanceCount = 0, deviceCount;
    NTSTATUS status;
    PDEVICE_OBJECT *deviceTable, *deviceTablex;
    PDEVICE_NODE deviceNode;
    ULONG rebalancePhase = 0;
    LIST_ENTRY  activeArbiterList;

    //
    // Query all the device nodes to see who are willing to participate the rebalance
    // process.
    //

    deviceTable = (PDEVICE_OBJECT *) ExAllocatePoolPDO(
                      PagedPool,
                      sizeof(PDEVICE_OBJECT) * IopNumberDeviceNodes);
    if (deviceTable == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Rebalance: Not enough memory to perform rebalance\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


tryAgain:
    deviceTablex = deviceTable + phase0RebalanceCount;

    //
    // Walk device node tree depth-first to query-stop and stop devices.
    // At this point the resources of the stopped devices are not released yet.
    // Also, the leaf nodes are in the front of the device table and non leaf nodes
    // are at the end of the table.
    //

    IopQueryRebalance (IopRootDeviceNode, rebalancePhase, &rebalanceCount, &deviceTablex);
    if (rebalanceCount == 0) {

        //
        // If no one is interested and we are not processing resources req change,
        // move to next phase.
        //

        if (rebalancePhase == 0 && AssignTableCount != 0) {
            rebalancePhase = 1;
            goto tryAgain;
        }
        IopDbgPrint((
            IOP_RESOURCE_INFO_LEVEL,
            "Rebalance: No device participates in rebalance phase %x\n",
            rebalancePhase));
        ExFreePool(deviceTable);
        deviceTable = NULL;
        status = STATUS_UNSUCCESSFUL;
        goto exit;
    }
    if (rebalanceCount == phase0RebalanceCount) {
        //
        // Phase 0 failed and no new device participates. failed the rebalance.
        //
        status = STATUS_UNSUCCESSFUL;
        goto exit;
    }
    if (rebalancePhase == 0) {

        phase0RebalanceCount = rebalanceCount;
    }
    //
    // Allocate pool for the new reconfiguration requests and the original requests.
    //
    table = (PIOP_RESOURCE_REQUEST) ExAllocatePoolIORR(
                 PagedPool,
                 sizeof(IOP_RESOURCE_REQUEST) * (AssignTableCount + rebalanceCount));
    if (table == NULL) {

        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Rebalance: Not enough memory to perform rebalance\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    tableEnd = table + AssignTableCount + rebalanceCount;
    //
    // Build a new resource request table.  The original requests will be at the beginning
    // of the table and new requests (reconfigured devices) are at the end.
    // After the new request table is built, the leaf nodes will be in front of the table,
    // and non leaf nodes will be close to the end of the table.  This is for optimization.
    //

    //
    // Copy the original request to the front of our new request table.
    //

    if (AssignTableCount != 0) {
        RtlCopyMemory(table, AssignTable, sizeof(IOP_RESOURCE_REQUEST) * AssignTableCount);
    }

    //
    // Initialize all the new entries of our new request table,
    //

    newEntry = table + AssignTableCount;
    RtlZeroMemory(newEntry, sizeof(IOP_RESOURCE_REQUEST) * rebalanceCount);
    for (i = 0, deviceTablex = deviceTable; i < rebalanceCount; i++, deviceTablex++) {
        newEntry[i].AllocationType = ArbiterRequestPnpEnumerated;
        newEntry[i].PhysicalDevice = *deviceTablex;
    }

    status = IopGetResourceRequirementsForAssignTable(
                 newEntry,
                 tableEnd ,
                 &deviceCount);
    if (deviceCount == 0) {
         IopDbgPrint((
             IOP_RESOURCE_WARNING_LEVEL,
             "Rebalance: GetResourceRequirementsForAssignTable failed\n"));
         goto exit;
    }

    //
    // Process the AssignTable to remove any entry which is marked as IOP_ASSIGN_IGNORE
    //

    if (deviceCount != rebalanceCount) {

        deviceCount += AssignTableCount;
        requestTable = (PIOP_RESOURCE_REQUEST) ExAllocatePoolIORR(
                             PagedPool,
                             sizeof(IOP_RESOURCE_REQUEST) * deviceCount
                             );
        if (requestTable == NULL) {
            IopFreeResourceRequirementsForAssignTable(newEntry, tableEnd);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
        for (entry1 = table, entry2 = requestTable; entry1 < tableEnd; entry1++) {

            if (!(entry1->Flags & IOP_ASSIGN_IGNORE)) {

                *entry2 = *entry1;
                entry2++;
            } else {

                ASSERT(entry1 >= newEntry);
            }
        }
        requestTableEnd = requestTable + deviceCount;
    } else {
        requestTable = table;
        requestTableEnd = tableEnd;
        deviceCount += AssignTableCount;
    }
    //
    // Assign the resources. If we succeed, or if
    // there is a memory shortage return immediately.
    //
    status = IopFindBestConfiguration(
                requestTable,
                deviceCount,
                &activeArbiterList);
    if (NT_SUCCESS(status)) {
        //
        // If the rebalance succeeded, we need to restart all the reconfigured devices.
        // For the original devices, we will return and let IopAllocateResources to deal
        // with them.
        //

        IopBuildCmResourceLists(requestTable, requestTableEnd);

        //
        // Copy the new status back to the original AssignTable.
        //

        if (AssignTableCount != 0) {
            RtlCopyMemory(AssignTable, requestTable, sizeof(IOP_RESOURCE_REQUEST) * AssignTableCount);
        }
        //
        // free resource requirements we allocated while here
        //
        IopFreeResourceRequirementsForAssignTable(requestTable+AssignTableCount, requestTableEnd);

        if (table != requestTable) {

            //
            // If we switched request table ... copy the contents of new table back to
            // the old table.
            //

            for (entry1 = table, entry2 = requestTable; entry2 < requestTableEnd;) {

                if (entry1->Flags & IOP_ASSIGN_IGNORE) {
                    entry1++;
                    continue;
                }
                *entry1 = *entry2;
                if (entry2->Flags & IOP_ASSIGN_EXCLUDE) {
                    entry1->Status = STATUS_CONFLICTING_ADDRESSES;
                }
                entry2++;
                entry1++;
            }
        }
        //
        // Go thru the origianl request table to stop each query-stopped/reconfigured device.
        //
        for (entry1 = newEntry; entry1 < tableEnd; entry1++) {

            deviceNode = PP_DO_TO_DN(entry1->PhysicalDevice);
            if (NT_SUCCESS(entry1->Status)) {

                IopDbgPrint((
                    IOP_RESOURCE_INFO_LEVEL,
                    "STOPPING %wZ during REBALANCE\n",
                    &deviceNode->InstancePath));
                IopQueryReconfiguration(
                    IRP_MN_STOP_DEVICE,
                    entry1->PhysicalDevice);

                PipSetDevNodeState(deviceNode, DeviceNodeStopped, NULL);
            } else {

                IopQueryReconfiguration(
                    IRP_MN_CANCEL_STOP_DEVICE,
                    entry1->PhysicalDevice);

                PipRestoreDevNodeState(deviceNode);
            }
        }

        //
        // Ask the arbiters to commit this configuration.
        //
        status = IopCommitConfiguration(&activeArbiterList);
        //
        // Go thru the origianl request table to start each stopped/reconfigured device.
        //

        for (entry1 = tableEnd - 1; entry1 >= newEntry; entry1--) {
            deviceNode = PP_DO_TO_DN(entry1->PhysicalDevice);

            if (NT_SUCCESS(entry1->Status)) {

                //
                // We need to release the pool space for ResourceList and ResourceListTranslated.
                // Because the earlier IopReleaseResourcesInternal does not release the pool.
                //

                if (deviceNode->ResourceList) {
                    ExFreePool(deviceNode->ResourceList);
                }
                deviceNode->ResourceList = entry1->ResourceAssignment;
                if (deviceNode->ResourceListTranslated) {
                    ExFreePool(deviceNode->ResourceListTranslated);
                }
                deviceNode->ResourceListTranslated = entry1->TranslatedResourceAssignment;
                if (deviceNode->ResourceList == NULL) {
                    deviceNode->Flags |= DNF_NO_RESOURCE_REQUIRED;
                }
                if (entry1->Flags & IOP_ASSIGN_CLEAR_RESOURCE_REQUIREMENTS_CHANGE_FLAG) {

                    //
                    // If we are processing the resource requirements change request,
                    // clear its related flags.
                    //

                    deviceNode->Flags &= ~(DNF_RESOURCE_REQUIREMENTS_CHANGED | DNF_NON_STOPPED_REBALANCE);
                }
            }
        }
        status = STATUS_SUCCESS;
    } else {

        //
        // Rebalance failed. Free our internal representation of the rebalance
        // candidates' resource requirements lists.
        //

        IopFreeResourceRequirementsForAssignTable(requestTable + AssignTableCount, requestTableEnd);
        if (rebalancePhase == 0) {
            rebalancePhase++;
            if (requestTable) {
                ExFreePool(requestTable);
            }
            if (table && (table != requestTable)) {
                ExFreePool(table);
            }
            table = requestTable = NULL;
            goto tryAgain;
        }

        for (entry1 = newEntry; entry1 < tableEnd; entry1++) {

            IopQueryReconfiguration (
                IRP_MN_CANCEL_STOP_DEVICE,
                entry1->PhysicalDevice);
            deviceNode = PP_DO_TO_DN(entry1->PhysicalDevice);

            PipRestoreDevNodeState(deviceNode);
        }
    }
    //
    // Finally release the references of the reconfigured device objects
    //
    for (deviceTablex = (deviceTable + rebalanceCount - 1);
         deviceTablex >= deviceTable;
         deviceTablex--) {
         ObDereferenceObject(*deviceTablex);
    }
    ExFreePool(deviceTable);
    deviceTable = NULL;

exit:

    if (!NT_SUCCESS(status) && deviceTable) {

        //
        // If we failed before trying to perform resource assignment,
        // we will end up here.
        //

        IopDbgPrint((
            IOP_RESOURCE_INFO_LEVEL,
            "Rebalance: Rebalance failed\n"));

        //
        // Somehow we failed to start the rebalance operation.
        // We will cancel the query-stop request for the query-stopped devices bredth first.
        //

        for (deviceTablex = (deviceTable + rebalanceCount - 1);
             deviceTablex >= deviceTable;
             deviceTablex--) {

             deviceNode = PP_DO_TO_DN(*deviceTablex);
             IopQueryReconfiguration (IRP_MN_CANCEL_STOP_DEVICE, *deviceTablex);
             PipRestoreDevNodeState(deviceNode);
             ObDereferenceObject(*deviceTablex);
        }
    }
    if (deviceTable) {
        ExFreePool(deviceTable);
    }
    if (requestTable) {
        ExFreePool(requestTable);
    }
    if (table && (table != requestTable)) {
        ExFreePool(table);
    }
    return status;
}

/*++

    SECTION = OUTER ARBITRATION LOOP.

    Description:

        This section contains code that implements functions to call arbiters
        and come up with the best possible configuration.
--*/

NTSTATUS
IopTestConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    )

/*++

Routine Description:

    This routine calls the arbiters in the specified list for TestAllocation.

Parameters:

    ArbiterList - Head of list of arbiters to be called.

Return Value:

    STATUS_SUCCESS if all arbiters succeed, else first failure code.

--*/

{

    NTSTATUS                    status;
    PLIST_ENTRY                 listEntry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    ARBITER_PARAMETERS          p;
    PARBITER_INTERFACE          arbiterInterface;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    for (   listEntry = ArbiterList->Flink;
            listEntry != ArbiterList;
            listEntry = listEntry->Flink) {

        arbiterEntry = CONTAINING_RECORD(
                            listEntry,
                            PI_RESOURCE_ARBITER_ENTRY,
                            ActiveArbiterList);
        ASSERT(IsListEmpty(&arbiterEntry->ResourceList) == FALSE);
        if (arbiterEntry->ResourcesChanged == FALSE) {

            if (arbiterEntry->State & PI_ARBITER_TEST_FAILED) {
                //
                // If the resource requirements are the same and
                // it failed before, return failure.
                //
                status = STATUS_UNSUCCESSFUL;
                break;
            }
        } else {

            arbiterInterface = arbiterEntry->ArbiterInterface;
            //
            // Call the arbiter to test the new configuration.
            //
            p.Parameters.TestAllocation.ArbitrationList     =
                                                    &arbiterEntry->ResourceList;
            p.Parameters.TestAllocation.AllocateFromCount   = 0;
            p.Parameters.TestAllocation.AllocateFrom        = NULL;
            status = arbiterInterface->ArbiterHandler(
                                            arbiterInterface->Context,
                                            ArbiterActionTestAllocation,
                                            &p);
            if (NT_SUCCESS(status)) {

                arbiterEntry->State &= ~PI_ARBITER_TEST_FAILED;
                arbiterEntry->State |= PI_ARBITER_HAS_SOMETHING;
                arbiterEntry->ResourcesChanged = FALSE;
            } else {
                //
                // This configuration does not work
                // (no need to try other arbiters).
                //
                arbiterEntry->State |= PI_ARBITER_TEST_FAILED;
                break;
            }
        }
    }

    return status;
}

NTSTATUS
IopRetestConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    )

/*++

Routine Description:

    This routine calls the arbiters in the specified list for RetestAllocation.

Parameters:

    ArbiterList - Head of list of arbiters to be called.

Return Value:

    STATUS_SUCCESS if all arbiters succeed, else first failure code.

--*/

{
    NTSTATUS                    retestStatus;
    PLIST_ENTRY                 listEntry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    ARBITER_PARAMETERS          p;
    PARBITER_INTERFACE          arbiterInterface;

    PAGED_CODE();

    retestStatus = STATUS_UNSUCCESSFUL;
    listEntry    = ArbiterList->Flink;
    while (listEntry != ArbiterList) {

        arbiterEntry = CONTAINING_RECORD(
                        listEntry,
                        PI_RESOURCE_ARBITER_ENTRY,
                        ActiveArbiterList);
        listEntry = listEntry->Flink;
        if (arbiterEntry->ResourcesChanged == FALSE) {

            continue;
        }
        ASSERT(IsListEmpty(&arbiterEntry->ResourceList) == FALSE);
        arbiterInterface = arbiterEntry->ArbiterInterface;
        //
        // Call the arbiter to retest the configuration.
        //
        p.Parameters.RetestAllocation.ArbitrationList     =
                                                    &arbiterEntry->ResourceList;
        p.Parameters.RetestAllocation.AllocateFromCount   = 0;
        p.Parameters.RetestAllocation.AllocateFrom        = NULL;
        retestStatus = arbiterInterface->ArbiterHandler(
                                            arbiterInterface->Context,
                                            ArbiterActionRetestAllocation,
                                            &p);
        if (!NT_SUCCESS(retestStatus)) {

            break;
        }
    }

    ASSERT(NT_SUCCESS(retestStatus));

    return retestStatus;
}

NTSTATUS
IopCommitConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    )

/*++

Routine Description:

    This routine calls the arbiters in the specified list for CommitAllocation.

Parameters:

    ArbiterList - Head of list of arbiters to be called.

Return Value:

    STATUS_SUCCESS if all arbiters succeed, else first failure code.

--*/

{
    NTSTATUS                    commitStatus;
    PLIST_ENTRY                 listEntry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    PARBITER_INTERFACE          arbiterInterface;

    PAGED_CODE();

    commitStatus = STATUS_SUCCESS;
    listEntry    = ArbiterList->Flink;
    while (listEntry != ArbiterList) {

        arbiterEntry = CONTAINING_RECORD(
                        listEntry,
                        PI_RESOURCE_ARBITER_ENTRY,
                        ActiveArbiterList);
        listEntry = listEntry->Flink;
        ASSERT(IsListEmpty(&arbiterEntry->ResourceList) == FALSE);
        arbiterInterface = arbiterEntry->ArbiterInterface;
        //
        // Call the arbiter to commit the configuration.
        //
        commitStatus = arbiterInterface->ArbiterHandler(
                            arbiterInterface->Context,
                            ArbiterActionCommitAllocation,
                            NULL);
        IopInitializeArbiterEntryState(arbiterEntry);
        if (!NT_SUCCESS(commitStatus)) {

            break;
        }
    }

    ASSERT(NT_SUCCESS(commitStatus));

    IopCheckDataStructures(IopRootDeviceNode);
    return commitStatus;
}

VOID
IopSelectFirstConfiguration (
    IN      PIOP_RESOURCE_REQUEST    RequestTable,
    IN      ULONG                    RequestTableCount,
    IN OUT  PLIST_ENTRY              ActiveArbiterList
    )

/*++

Routine Description:

    This routine selects the first possible configuration and adds the
    descriptors to their corresponding arbiter lists. The arbiters used are
    linked into the list of active arbiters.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

    ActiveArbiterList   - Head of list which contains arbiters used for the
        first selected configuration.

Return Value:

    None.

--*/

{
    ULONG               tableIndex;
    PREQ_ALTERNATIVE    reqAlternative;
    PREQ_LIST           reqList;

    PAGED_CODE();
    //
    // For each entry in the request table, set the first configuration
    // as the selected configuration.
    // Update the arbiters with all the descriptors in the selected
    // configuration.
    //
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList                         = RequestTable[tableIndex].ReqList;
        reqList->SelectedAlternative    = &reqList->AlternativeTable[0];
        reqAlternative                  = *(reqList->SelectedAlternative);
        IopAddRemoveReqDescs(
            reqAlternative->DescTable,
            reqAlternative->DescCount,
            ActiveArbiterList,
            TRUE);
    }
}

BOOLEAN
IopSelectNextConfiguration (
    IN      PIOP_RESOURCE_REQUEST    RequestTable,
    IN      ULONG                    RequestTableCount,
    IN OUT  PLIST_ENTRY              ActiveArbiterList
    )

/*++

Routine Description:

    This routine selects the next possible configuration and adds the
    descriptors to their corresponding arbiter lists. The arbiters used are
    linked into the list of active arbiters.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

    ActiveArbiterList   - Head of list which contains arbiters used for the
        currently selected configuration.

Return Value:

    FALSE if this the currently selected configuration is the last possible,
    else TRUE.

--*/

{
    ULONG               tableIndex;
    PREQ_ALTERNATIVE    reqAlternative;
    PREQ_LIST           reqList;

    PAGED_CODE();
    //
    // Remove all the descriptors from the currently selected alternative
    // for the first entry in the request table.
    // Update the selected configuration to the next possible.
    // Reset the selected configuration to the first possible one if
    // all configurations have been tried and go to the next entry
    // in the request table.
    //
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList         = RequestTable[tableIndex].ReqList;
        reqAlternative  = *(reqList->SelectedAlternative);
        IopAddRemoveReqDescs(
            reqAlternative->DescTable,
            reqAlternative->DescCount,
            NULL,
            FALSE);
        if (++reqList->SelectedAlternative < reqList->BestAlternative) {

            break;
        }
        reqList->SelectedAlternative = &reqList->AlternativeTable[0];
    }
    //
    // We are done if there is no next possible configuration.
    //
    if (tableIndex == RequestTableCount) {

        return FALSE;
    }
    //
    // For each entry in the request table, add all the descriptors in
    // the currently selected alternative.
    //
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList         = RequestTable[tableIndex].ReqList;
        reqAlternative  = *(reqList->SelectedAlternative);
        IopAddRemoveReqDescs(
            reqAlternative->DescTable,
            reqAlternative->DescCount,
            ActiveArbiterList,
            TRUE);
        if (reqList->SelectedAlternative != &reqList->AlternativeTable[0]) {

            break;
        }
    }

    return TRUE;
}

VOID
IopCleanupSelectedConfiguration (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    RequestTableCount
    )

/*++

Routine Description:

    This routine removes the descriptors from their corresponding arbiter
    lists.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

Return Value:

    None.

--*/

{
    ULONG               tableIndex;
    PREQ_ALTERNATIVE    reqAlternative;
    PREQ_LIST           reqList;

    PAGED_CODE();
    //
    // For each entry in the request table, remove all the descriptors
    // from the currently selected alternative.
    //
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList         = RequestTable[tableIndex].ReqList;
        reqAlternative  = *(reqList->SelectedAlternative);
        IopAddRemoveReqDescs(
            reqAlternative->DescTable,
            reqAlternative->DescCount,
            NULL,
            FALSE);
    }
}

ULONG
IopComputeConfigurationPriority (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    RequestTableCount
    )

/*++

Routine Description:

    This routine computes the overall priority of the set of selected
    configurations for all requests in the request table.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

Return Value:

    Computed priority for this configuration.

--*/

{
    ULONG               tableIndex;
    ULONG               priority;
    PREQ_ALTERNATIVE    reqAlternative;
    PREQ_LIST           reqList;

    PAGED_CODE();
    //
    // Compute the current configurations overall priority
    // as the sum of the priorities of currently selected
    // configuration in the request table.
    //
    priority = 0;
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList         = RequestTable[tableIndex].ReqList;
        reqAlternative  = *(reqList->SelectedAlternative);
        priority        += reqAlternative->Priority;
    }

    return priority;
}

VOID
IopSaveRestoreConfiguration (
    IN      PIOP_RESOURCE_REQUEST   RequestTable,
    IN      ULONG                   RequestTableCount,
    IN OUT  PLIST_ENTRY             ArbiterList,
    IN      BOOLEAN                 Save
    )

/*++

Routine Description:

    This routine saves\restores the currently selected configuration.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

    ArbiterList         - Head of list which contains arbiters used for the
                          currently selected configuration.

    Save                - Specifies if the configuration is to be saved or
                          restored.

Return Value:

    None.

--*/

{
    ULONG                       tableIndex;
    PREQ_ALTERNATIVE            reqAlternative;
    PREQ_DESC                   reqDesc;
    PREQ_DESC                   *reqDescpp;
    PREQ_DESC                   *reqDescTableEnd;
    PLIST_ENTRY                 listEntry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    PREQ_LIST                   reqList;

    PAGED_CODE();

    IopDbgPrint((
        IOP_RESOURCE_TRACE_LEVEL,
        "%s configuration\n",
        (Save)? "Saving" : "Restoring"));
    //
    // For each entry in the request table, save information for
    // following RETEST.
    //
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList                     = RequestTable[tableIndex].ReqList;
        if (Save) {

            reqList->BestAlternative        = reqList->SelectedAlternative;
        } else {

            reqList->SelectedAlternative    = reqList->BestAlternative;
        }
        reqAlternative              = *(reqList->BestAlternative);
        reqDescTableEnd             = reqAlternative->DescTable +
                                        reqAlternative->DescCount;
        for (   reqDescpp = reqAlternative->DescTable;
                reqDescpp < reqDescTableEnd;
                reqDescpp++) {

            if ((*reqDescpp)->ArbitrationRequired == FALSE) {

                continue;
            }
            //
            // Save\restore information for the descriptor.
            //
            reqDesc = (*reqDescpp)->TranslatedReqDesc;
            if (Save == TRUE) {

                reqDesc->BestAlternativeTable  = reqDesc->AlternativeTable;
                reqDesc->BestAllocation        = reqDesc->Allocation;
            } else {

                reqDesc->AlternativeTable  = reqDesc->BestAlternativeTable;
                reqDesc->Allocation        = reqDesc->BestAllocation;
            }
        }
    }
    //
    // For each entry in the currently active arbiter list,
    // save information for following RETEST.
    //
    listEntry = ArbiterList->Flink;
    while (listEntry != ArbiterList) {
        arbiterEntry = CONTAINING_RECORD(
                        listEntry,
                        PI_RESOURCE_ARBITER_ENTRY,
                        ActiveArbiterList);
        if (Save == TRUE) {
            arbiterEntry->BestResourceList  = arbiterEntry->ResourceList;
            arbiterEntry->BestConfig        = arbiterEntry->ActiveArbiterList;
        } else {
            arbiterEntry->ResourceList      = arbiterEntry->BestResourceList;
            arbiterEntry->ActiveArbiterList = arbiterEntry->BestConfig;
        }
        listEntry = listEntry->Flink;
    }
}

VOID
IopAddRemoveReqDescs (
    IN      PREQ_DESC   *ReqDescTable,
    IN      ULONG       ReqDescCount,
    IN OUT  PLIST_ENTRY ActiveArbiterList,
    IN      BOOLEAN     Add
    )

/*++

Routine Description:

    This routine adds\removes the descriptors to\from the arbiter lists. It
    also updates the list of arbiters involved.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

    ActiveArbiterList   - Head of list which contains arbiters used for the
                          currently selected configuration.

    Add                 - Specifies if the descriptors are to be added or
                          removed.

Return Value:

    None.

--*/

{
    ULONG                       tableIndex;
    PREQ_DESC                   reqDesc;
    PREQ_DESC                   reqDescTranslated;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    PREQ_ALTERNATIVE            reqAlternative;
    PREQ_LIST                   reqList;
    PDEVICE_NODE                deviceNode;

    PAGED_CODE();

    if (ReqDescCount == 0) {

        return;
    }

    reqList         = ReqDescTable[0]->ReqAlternative->ReqList;
    reqAlternative  = *reqList->SelectedAlternative;
    deviceNode      = PP_DO_TO_DN(reqList->Request->PhysicalDevice);
    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "%s %d/%d req alt %s the arbiters for %wZ\n",
        (Add)? "Adding" : "Removing",
        reqAlternative->ReqAlternativeIndex + 1,
        reqList->AlternativeCount,
        (Add)? "to" : "from",
        &deviceNode->InstancePath));
    for (tableIndex = 0; tableIndex < ReqDescCount; tableIndex++) {

        reqDesc = ReqDescTable[tableIndex];
        if (reqDesc->ArbitrationRequired == FALSE) {

            continue;
        }
        arbiterEntry = reqDesc->u.Arbiter;
        ASSERT(arbiterEntry);
        if (arbiterEntry->State & PI_ARBITER_HAS_SOMETHING) {

            arbiterEntry->State &= ~PI_ARBITER_HAS_SOMETHING;
            arbiterEntry->ArbiterInterface->ArbiterHandler(
                                    arbiterEntry->ArbiterInterface->Context,
                                    ArbiterActionRollbackAllocation,
                                    NULL);
        }
        arbiterEntry->ResourcesChanged  = TRUE;
        reqDescTranslated               = reqDesc->TranslatedReqDesc;
        if (Add == TRUE) {

            InitializeListHead(&reqDescTranslated->AlternativeTable.ListEntry);
            InsertTailList(
                &arbiterEntry->ResourceList,
                &reqDescTranslated->AlternativeTable.ListEntry);
            if (IsListEmpty(&arbiterEntry->ActiveArbiterList)) {

                PLIST_ENTRY                 listEntry;
                PPI_RESOURCE_ARBITER_ENTRY  entry;
                //
                // Insert the entry into the sorted list
                // (sorted by depth in the tree).
                //
                for (   listEntry = ActiveArbiterList->Flink;
                        listEntry != ActiveArbiterList;
                        listEntry = listEntry->Flink) {

                    entry = CONTAINING_RECORD(
                                listEntry,
                                PI_RESOURCE_ARBITER_ENTRY,
                                ActiveArbiterList);
                    if (entry->Level >= arbiterEntry->Level) {

                        break;
                    }
                }
                arbiterEntry->ActiveArbiterList.Flink   = listEntry;
                arbiterEntry->ActiveArbiterList.Blink   = listEntry->Blink;
                listEntry->Blink->Flink = &arbiterEntry->ActiveArbiterList;
                listEntry->Blink        = &arbiterEntry->ActiveArbiterList;
            }
        } else {

            ASSERT(IsListEmpty(&arbiterEntry->ResourceList) == FALSE);
            RemoveEntryList(&reqDescTranslated->AlternativeTable.ListEntry);
            InitializeListHead(&reqDescTranslated->AlternativeTable.ListEntry);
            if (IsListEmpty(&arbiterEntry->ResourceList)) {

                RemoveEntryList(&arbiterEntry->ActiveArbiterList);
                InitializeListHead(&arbiterEntry->ActiveArbiterList);
            }
        }
    }
}

NTSTATUS
IopFindBestConfiguration (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    RequestTableCount,
    IN OUT PLIST_ENTRY          ActiveArbiterList
    )

/*++

Routine Description:

    This routine attempts to satisfy the resource requests for all the entries
    in the request table. It also attempts to find the best possible overall
    solution.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

Return Value:

    Final status.

--*/

{
    LIST_ENTRY      bestArbiterList;
    LARGE_INTEGER   startTime;
    LARGE_INTEGER   currentTime;
    ULONG           timeDiff;
    NTSTATUS        status;
    ULONG           priority;
    ULONG           bestPriority;

    PAGED_CODE();
    //
    // Initialize the arbiter lists used during the search for the best
    // configuration.
    //
    InitializeListHead(ActiveArbiterList);
    InitializeListHead(&bestArbiterList);
    //
    // Start the search from the first possible configuration.
    // Possible configurations are already sorted by priority.
    //
    IopSelectFirstConfiguration(
        RequestTable,
        RequestTableCount,
        ActiveArbiterList);
    //
    // Search for all configurations that work, updating
    // the best configuration until we have tried all
    // possible configurations or timeout has expired.
    //
    KeQuerySystemTime(&startTime);
    bestPriority = (ULONG)-1;
    do {
        //
        // Test the arbiters for this combination.
        //
        status = IopTestConfiguration(ActiveArbiterList);
        if (NT_SUCCESS(status)) {
            //
            // Since the configurations are sorted, we dont need to try others
            // if there is only one entry in the request table.
            //
            bestArbiterList = *ActiveArbiterList;
            if (RequestTableCount == 1) {

                break;
            }
            //
            // Save this configuration if it is better than the best one found
            // so far.
            //
            priority = IopComputeConfigurationPriority(
                            RequestTable,
                            RequestTableCount);
            if (priority < bestPriority) {

                bestPriority = priority;
                IopSaveRestoreConfiguration(
                    RequestTable,
                    RequestTableCount,
                    ActiveArbiterList,
                    TRUE);
            }
        }
        //
        // Check if timeout has expired.
        //
        KeQuerySystemTime(&currentTime);
        timeDiff = (ULONG)((currentTime.QuadPart - startTime.QuadPart) / 10000);
        if (timeDiff >= FIND_BEST_CONFIGURATION_TIMEOUT) {

            IopDbgPrint((
                IOP_RESOURCE_WARNING_LEVEL,
                "IopFindBestConfiguration: Timeout expired"));
            if (IopStopOnTimeout()) {

                IopDbgPrint((
                    IOP_RESOURCE_WARNING_LEVEL,
                    ", terminating search!\n"));
                IopCleanupSelectedConfiguration(
                    RequestTable,
                    RequestTableCount);
                break;
            } else {
                //
                // Re-initialize start time so we spew only every timeout
                // interval.
                //
                startTime = currentTime;
                IopDbgPrint((IOP_RESOURCE_WARNING_LEVEL, "\n"));
           }
        }
        //
        // Select the next possible combination of configurations.
        //
    } while (IopSelectNextConfiguration(
                RequestTable,
                RequestTableCount,
                ActiveArbiterList) == TRUE);
    //
    // Check if we found any working configuration.
    //
    if (IsListEmpty(&bestArbiterList)) {

        status = STATUS_UNSUCCESSFUL;
    } else {

        status = STATUS_SUCCESS;
        //
        // Restore the saved configuration.
        //
        if (RequestTableCount != 1) {

            *ActiveArbiterList = bestArbiterList;
            IopSaveRestoreConfiguration(
                RequestTable,
                RequestTableCount,
                ActiveArbiterList,
                FALSE);
            //
            // Retest this configuration since this may not be the
            // last one tested.
            //
            status = IopRetestConfiguration(ActiveArbiterList);
        }
    }

    return status;
}

/*++

    SECTION = LEGACY BUS INFORMATION TABLE.

    Description:

        This section contains code that implements functions to maintain and
        access the table of Legacy Bus Information.

--*/

VOID
IopInsertLegacyBusDeviceNode (
    IN PDEVICE_NODE     BusDeviceNode,
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber
    )

/*++

Routine Description:

    This routine inserts the specified BusDeviceNode in the table according to
    its InterfaceType and BusNumber.

Parameters:

    BusDeviceNode   - Device with the specified InterfaceType and BusNumber.

    InterfaceType   - Specifies the bus devicenode's interface type.

    BusNumber       - Specifies the bus devicenode's bus number.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT(InterfaceType < MaximumInterfaceType && InterfaceType > InterfaceTypeUndefined);
    if (    InterfaceType < MaximumInterfaceType &&
            InterfaceType > InterfaceTypeUndefined &&
            InterfaceType != PNPBus) {

        PLIST_ENTRY listEntry;
        //
        // Eisa == Isa.
        //
        if (InterfaceType == Eisa) {

            InterfaceType = Isa;
        }
        IopLockResourceManager();
        listEntry = IopLegacyBusInformationTable[InterfaceType].Flink;
        while (listEntry != &IopLegacyBusInformationTable[InterfaceType]) {

            PDEVICE_NODE deviceNode = CONTAINING_RECORD(
                                        listEntry,
                                        DEVICE_NODE,
                                        LegacyBusListEntry);
            if (deviceNode->BusNumber == BusNumber) {

                if (deviceNode != BusDeviceNode) {
                    //
                    // There better not be two bus devicenodes with same
                    // interface and bus number.
                    //
                    IopDbgPrint((
                        IOP_RESOURCE_ERROR_LEVEL,
                        "Identical legacy bus devicenodes with "
                        "interface=%08X & bus=%08X...\n"
                        "\t%wZ\n"
                        "\t%wZ\n",
                        InterfaceType,
                        BusNumber,
                        &deviceNode->InstancePath,
                        &BusDeviceNode->InstancePath));
                }
                IopUnlockResourceManager();
                return;
            } else if (deviceNode->BusNumber > BusNumber) {

                break;
            }
            listEntry = listEntry->Flink;
        }
        //
        // Insert the new devicenode before the one with the higher bus number.
        //
        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "IopInsertLegacyBusDeviceNode: Inserting %wZ with "
            "interface=%08X & bus=%08X into the legacy bus information table\n",
            &BusDeviceNode->InstancePath,
            InterfaceType, BusNumber));
        BusDeviceNode->LegacyBusListEntry.Blink = listEntry->Blink;
        BusDeviceNode->LegacyBusListEntry.Flink = listEntry;
        listEntry->Blink->Flink = &BusDeviceNode->LegacyBusListEntry;
        listEntry->Blink        = &BusDeviceNode->LegacyBusListEntry;
        IopUnlockResourceManager();
    }
}

PDEVICE_NODE
IopFindLegacyBusDeviceNode (
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber
    )

/*++

Routine Description:

    This routine finds the bus devicenode with the specified InterfaceType
    and BusNumber.

Parameters:

    InterfaceType   - Specifies the bus devicenode's interface type.

    BusNumber       - Specifies the bus devicenode's bus number.

Return Value:

    A pointer to the bus devicenode.

--*/

{
    PDEVICE_NODE busDeviceNode;

    PAGED_CODE();

    busDeviceNode = IopRootDeviceNode;
    if (    InterfaceType < MaximumInterfaceType &&
            InterfaceType > InterfaceTypeUndefined &&
            InterfaceType != PNPBus) {

        PLIST_ENTRY listEntry;
        //
        // Eisa == Isa.
        //
        if (InterfaceType == Eisa) {

            InterfaceType = Isa;
        }
        //
        // Search our table...
        //
        listEntry = IopLegacyBusInformationTable[InterfaceType].Flink;
        while (listEntry != &IopLegacyBusInformationTable[InterfaceType]) {

            PDEVICE_NODE deviceNode = CONTAINING_RECORD(
                                        listEntry,
                                        DEVICE_NODE,
                                        LegacyBusListEntry);
            if (deviceNode->BusNumber == BusNumber) {
                //
                // Return the bus devicenode matching the bus number and
                // interface.
                //
                busDeviceNode = deviceNode;
                break;
            } else if (deviceNode->BusNumber > BusNumber) {
                //
                // We are done since our list of bus numbers is sorted.
                //
                break;
            }
            listEntry = listEntry->Flink;
        }
    }
    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "IopFindLegacyBusDeviceNode() Found %wZ with "
        "interface=%08X & bus=%08X\n",
        &busDeviceNode->InstancePath,
        InterfaceType,
        BusNumber));

    return busDeviceNode;
}

/*++

    SECTION = BOOT CONFIG.

    Description:

        This section contains code that implements BOOT config allocation and
        release.

--*/

NTSTATUS
IopAllocateBootResources (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    )

/*++

Routine Description:

    This routine allocates boot resources.
    Before all Boot Bux Extenders are processed, this routine is called only
    for non-madeup devices since arbiters for their boot resources should
    already be initialized by the time the time they got enumerated.
    After all Boot Bus Extenders are processed, this routine is used for all
    boot allocations.

Parameters:

    ArbiterRequestSource    - Source of this resource request.

    DeviceObject            - If non-NULL, the boot resources are
        pre-allocated. These resources will not be given out until they are
        released to the arbiters. If NULL, the boot resources get reserved and
        may be given out if there is no other choice.

    BootResources           - Supplies a pointer to the BOOT resources. If
        DeviceObject is NULL, caller should release this pool.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    NTSTATUS    status;

    PAGED_CODE();

    IopDbgPrint((
        IOP_RESOURCE_INFO_LEVEL,
        "Allocating boot resources...\n"));
    //
    // Claim the lock so no other resource allocations\releases can take place.
    //
    IopLockResourceManager();
    //
    // Call the function that does the real work.
    //
    status = IopAllocateBootResourcesInternal(
                ArbiterRequestSource,
                DeviceObject,
                BootResources);
    //
    // Unblock other resource allocations\releases.
    //
    IopUnlockResourceManager();

    return status;
}

NTSTATUS
IopReportBootResources (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    )

/*++

Routine Description:

    This routine is used to report boot resources.
    This routine gets called before all Boot Bus Extenders are processed. It
    calls the actual allocation function for non-madeup devices. For others,
    it delays the allocation. The postponed allocations take place when the
    arbiters come online by calling IopAllocateLegacyBootResources. Once all
    Boot Bus Extenders are processed, the calls get routed to
    IopAllocateBootResources directly.

Parameters:

    ArbiterRequestSource    - Source of this resource request.

    DeviceObject            - If non-NULL, the boot resources are
        pre-allocated. These resources will not be given out until they are
        released to the arbiters. If NULL, the boot resources get reserved and
        may be given out if there is no other choice.

    BootResources           - Supplies a pointer to the BOOT resources. If
        DeviceObject is NULL, caller should release this pool.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    ULONG                           size;
    PDEVICE_NODE                    deviceNode;
    PIOP_RESERVED_RESOURCES_RECORD  resourceRecord;

    IopDbgPrint((
        IOP_RESOURCE_INFO_LEVEL,
        "Reporting boot resources...\n"));
    if ((size = IopDetermineResourceListSize(BootResources)) == 0) {

        return STATUS_SUCCESS;
    }
    if (DeviceObject) {

        deviceNode = PP_DO_TO_DN(DeviceObject);
        ASSERT(deviceNode);
        if (!(deviceNode->Flags & DNF_MADEUP)) {
            //
            // Allocate BOOT configs for non-madeup devices right away.
            //
            return IopAllocateBootResources(
                    ArbiterRequestSource,
                    DeviceObject,
                    BootResources);
        }
        if (!deviceNode->BootResources) {

            deviceNode->BootResources = ExAllocatePoolIORL(PagedPool, size);
            if (!deviceNode->BootResources) {

                return STATUS_INSUFFICIENT_RESOURCES;
            }
            RtlCopyMemory(deviceNode->BootResources, BootResources, size);
        }
    } else {

        deviceNode = NULL;
    }
    //
    // Delay BOOT allocation since arbiters may not be around.
    //
    resourceRecord = (PIOP_RESERVED_RESOURCES_RECORD) ExAllocatePoolIORRR(
                        PagedPool,
                        sizeof(IOP_RESERVED_RESOURCES_RECORD));
    if (!resourceRecord) {
        //
        // Free memory we allocated and return failure.
        //
        if (deviceNode && deviceNode->BootResources) {

            ExFreePool(deviceNode->BootResources);
            deviceNode->BootResources = NULL;
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    if (deviceNode) {

        resourceRecord->ReservedResources   = deviceNode->BootResources;
    } else {

        resourceRecord->ReservedResources   = BootResources;
    }
    resourceRecord->DeviceObject            = DeviceObject;
    //
    // Link this record into our list.
    //
    resourceRecord->Next                    = IopInitReservedResourceList;
    IopInitReservedResourceList             = resourceRecord;

    return STATUS_SUCCESS;
}

NTSTATUS
IopAllocateLegacyBootResources (
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber
    )

/*++

Routine Description:

    This routine is called to reserve legacy BOOT resources for the specified
    InterfaceType and BusNumber. This is done everytime a new bus with a legacy
    InterfaceType gets enumerated.

Parameters:

    InterfaceType   - Legacy InterfaceType.

    BusNumber       - Legacy BusNumber.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS                        status;
    PIOP_RESERVED_RESOURCES_RECORD  resourceRecord;
    PIOP_RESERVED_RESOURCES_RECORD  prevRecord;
    PCM_RESOURCE_LIST               newList;
    PCM_RESOURCE_LIST               remainingList;
    PCM_RESOURCE_LIST               resourceList;

    if (IopInitHalDeviceNode && IopInitHalResources) {

        remainingList = NULL;
        newList = IopCreateCmResourceList(
                    IopInitHalResources,
                    InterfaceType,
                    BusNumber,
                    &remainingList);
        if (newList) {
            //
            // Sanity check that there was no error.
            //
            if (remainingList == NULL) {
                //
                // Full match.
                //
                ASSERT(newList == IopInitHalResources);
            } else {
                //
                // Partial match.
                //
                ASSERT(IopInitHalResources != newList);
                ASSERT(IopInitHalResources != remainingList);
            }
            if (remainingList) {

                ExFreePool(IopInitHalResources);
            }
            IopInitHalResources         = remainingList;
            remainingList               = IopInitHalDeviceNode->BootResources;
            IopInitHalDeviceNode->Flags |= DNF_HAS_BOOT_CONFIG;
            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Allocating HAL reported resources on interface=%x and "
                "bus number=%x...\n", InterfaceType, BusNumber));
            status = IopAllocateBootResources(
                        ArbiterRequestHalReported,
                        IopInitHalDeviceNode->PhysicalDeviceObject,
                        newList);
            IopInitHalDeviceNode->BootResources = IopCombineCmResourceList(
                                                    remainingList,
                                                    newList);
            ASSERT(IopInitHalDeviceNode->BootResources);
            //
            // Free previous BOOT config if any.
            //
            if (remainingList) {

                ExFreePool(remainingList);
            }
        } else {
            //
            // No match. Sanity check that there was no error.
            //
            ASSERT(remainingList && remainingList == IopInitHalResources);
        }
    }
    prevRecord      = NULL;
    resourceRecord  = IopInitReservedResourceList;
    while (resourceRecord) {

        resourceList = resourceRecord->ReservedResources;
        if (    resourceList->List[0].InterfaceType == InterfaceType &&
                resourceList->List[0].BusNumber == BusNumber) {

            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Allocating boot config for made-up device on interface=%x and"
                " bus number=%x...\n", InterfaceType, BusNumber));
            status = IopAllocateBootResources(
                        ArbiterRequestPnpEnumerated,
                        resourceRecord->DeviceObject,
                        resourceList);
            if (resourceRecord->DeviceObject == NULL) {

                ExFreePool(resourceList);
            }
            if (prevRecord) {

                prevRecord->Next            = resourceRecord->Next;
            } else {

                IopInitReservedResourceList = resourceRecord->Next;
            }
            ExFreePool(resourceRecord);
            if (prevRecord) {

                resourceRecord = prevRecord->Next;
            } else {

                resourceRecord = IopInitReservedResourceList;
            }
        } else {

            prevRecord      = resourceRecord;
            resourceRecord  = resourceRecord->Next;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopAllocateBootResourcesInternal (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    )

/*++

Routine Description:

    This routine reports boot resources for the specified device to
    arbiters.

Parameters:

    ArbiterRequestSource    - Source of this resource request.

    DeviceObject            - If non-NULL, the boot resources are
        pre-allocated. These resources will not be given out until they are
        released to the arbiters. If NULL, the boot resources get reserved and
        may be given out if there is no other choice.

    BootResources           - Supplies a pointer to the BOOT resources. If
        DeviceObject is NULL, caller should release this pool.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    NTSTATUS                        status;
    PDEVICE_NODE                    deviceNode;
    PIO_RESOURCE_REQUIREMENTS_LIST  ioResources;
    PREQ_LIST                       reqList;
    IOP_RESOURCE_REQUEST            request;

    PAGED_CODE();

    ioResources = IopCmResourcesToIoResources(
                    0,
                    BootResources,
                    LCPRI_BOOTCONFIG);
    if (ioResources) {

        deviceNode = PP_DO_TO_DN(DeviceObject);
        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "\n===================================\n"
                     ));
        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "Boot Resource List:: "));
        IopDumpResourceRequirementsList(ioResources);
        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            " ++++++++++++++++++++++++++++++\n"));
        request.AllocationType = ArbiterRequestSource;
        request.ResourceRequirements = ioResources;
        request.PhysicalDevice = DeviceObject;
        status = IopResourceRequirementsListToReqList(
                    &request,
                    &reqList);
        if (NT_SUCCESS(status)) {

            if (reqList) {

                status = IopBootAllocation(reqList);
                if (NT_SUCCESS(status)) {

                    if (deviceNode) {

                        deviceNode->Flags |= DNF_BOOT_CONFIG_RESERVED;
                        if (!deviceNode->BootResources) {

                            ULONG   size;

                            size = IopDetermineResourceListSize(BootResources);
                            deviceNode->BootResources = ExAllocatePoolIORL(
                                                            PagedPool,
                                                            size);
                            if (!deviceNode->BootResources) {

                                return STATUS_INSUFFICIENT_RESOURCES;
                            }
                            RtlCopyMemory(
                                deviceNode->BootResources,
                                BootResources,
                                size);
                        }
                    }
                }
                IopFreeReqList(reqList);
            } else {

                status = STATUS_UNSUCCESSFUL;
            }
        }
        ExFreePool(ioResources);
    } else {

        status = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(status)) {

        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "IopAllocateBootResourcesInternal: Failed with status = %08X\n",
            status));
    }

    return status;
}

NTSTATUS
IopBootAllocation (
    IN PREQ_LIST ReqList
    )

/*++

Routine Description:

    This routine calls the arbiters for the ReqList to do BootAllocation.

Parameters:

    ReqList - List of BOOT resources in internal format.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS                    status;
    NTSTATUS                    returnStatus;
    LIST_ENTRY                  activeArbiterList;
    PLIST_ENTRY                 listEntry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    ARBITER_PARAMETERS          p;

    PAGED_CODE();

    returnStatus = STATUS_SUCCESS;
    InitializeListHead(&activeArbiterList);
    ReqList->SelectedAlternative = ReqList->AlternativeTable;
    IopAddRemoveReqDescs(   (*ReqList->SelectedAlternative)->DescTable,
                            (*ReqList->SelectedAlternative)->DescCount,
                            &activeArbiterList,
                            TRUE);
    listEntry = activeArbiterList.Flink;
    while (listEntry != &activeArbiterList){

        arbiterEntry = CONTAINING_RECORD(
                        listEntry,
                        PI_RESOURCE_ARBITER_ENTRY,
                        ActiveArbiterList);
        listEntry = listEntry->Flink;
        if (arbiterEntry->ResourcesChanged == FALSE) {

            continue;
        }
        ASSERT(IsListEmpty(&arbiterEntry->ResourceList) == FALSE);
        p.Parameters.BootAllocation.ArbitrationList =
            &arbiterEntry->ResourceList;
        status = arbiterEntry->ArbiterInterface->ArbiterHandler(
                    arbiterEntry->ArbiterInterface->Context,
                    ArbiterActionBootAllocation,
                    &p);

        if (!NT_SUCCESS(status)) {

            PARBITER_LIST_ENTRY arbiterListEntry;

            arbiterListEntry = (PARBITER_LIST_ENTRY)
                                arbiterEntry->ResourceList.Flink;
            IopDbgPrint((
                IOP_RESOURCE_ERROR_LEVEL,
                "Allocate Boot Resources Failed ::\n\tCount = %x, PDO = %x\n",
                arbiterListEntry->AlternativeCount,
                arbiterListEntry->PhysicalDeviceObject));
            IopDumpResourceDescriptor("\t", arbiterListEntry->Alternatives);
            returnStatus = status;
        }
        IopInitializeArbiterEntryState(arbiterEntry);
    }

    IopCheckDataStructures(IopRootDeviceNode);

    return returnStatus;
}

PCM_RESOURCE_LIST
IopCreateCmResourceList (
    IN PCM_RESOURCE_LIST    ResourceList,
    IN INTERFACE_TYPE       InterfaceType,
    IN ULONG                BusNumber,
    OUT PCM_RESOURCE_LIST   *RemainingList
    )

/*++

Routine Description:

    This routine returns the CM_RESOURCE_LIST portion out of the specified list
    that matches the specified BusNumber and InterfaceType.

Parameters:

    ResourceList    - Input resource list.

    InterfaceType   - Interface type.

    BusNumber       - Bus number.

    RemainingList   - Portion not matching BusNumber and InterfaceType.

Return Value:

    Returns the matching CM_RESOURCE_LIST if successful, else NULL.

--*/

{
    ULONG                           i;
    ULONG                           j;
    ULONG                           totalSize;
    ULONG                           matchSize;
    ULONG                           listSize;
    PCM_RESOURCE_LIST               newList;
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceDesc;
    PCM_FULL_RESOURCE_DESCRIPTOR    newFullResourceDesc;
    PCM_FULL_RESOURCE_DESCRIPTOR    remainingFullResourceDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;

    PAGED_CODE();

    fullResourceDesc    = &ResourceList->List[0];
    totalSize           = FIELD_OFFSET(CM_RESOURCE_LIST, List);
    matchSize           = 0;
    //
    // Determine the size of memory to be allocated for the matching resource
    // list.
    //
    for (i = 0; i < ResourceList->Count; i++) {
        //
        // Add the size of this descriptor.
        //
        listSize = FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                PartialResourceList) +
                   FIELD_OFFSET(CM_PARTIAL_RESOURCE_LIST,
                                PartialDescriptors);
        partialDescriptor =
            &fullResourceDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < fullResourceDesc->PartialResourceList.Count; j++) {

            ULONG descriptorSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

            if (partialDescriptor->Type == CmResourceTypeDeviceSpecific) {

                descriptorSize +=
                    partialDescriptor->u.DeviceSpecificData.DataSize;
            }
            listSize += descriptorSize;
            partialDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                                    ((PUCHAR)partialDescriptor +
                                            descriptorSize);
        }
        if (    fullResourceDesc->InterfaceType == InterfaceType &&
                fullResourceDesc->BusNumber == BusNumber) {

            matchSize += listSize;
        }
        totalSize += listSize;
        fullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                  ((PUCHAR)fullResourceDesc + listSize);
    }
    if (!matchSize) {

        *RemainingList  = ResourceList;
        return NULL;
    }
    matchSize += FIELD_OFFSET(CM_RESOURCE_LIST, List);
    if (matchSize == totalSize) {

        *RemainingList  = NULL;
        return ResourceList;
    }
    //
    // Allocate memory for both lists.
    //
    newList = (PCM_RESOURCE_LIST)ExAllocatePoolIORRR(PagedPool, matchSize);
    if (newList == NULL) {

        *RemainingList = NULL;
        return NULL;
    }
    *RemainingList = (PCM_RESOURCE_LIST)
                        ExAllocatePoolIORRR(
                            PagedPool,
                            totalSize - matchSize +
                                FIELD_OFFSET(CM_RESOURCE_LIST, List));
    if (*RemainingList == NULL) {

        ExFreePool(newList);
        return NULL;
    }
    newList->Count              = 0;
    (*RemainingList)->Count     = 0;
    newFullResourceDesc         = &newList->List[0];
    remainingFullResourceDesc   = &(*RemainingList)->List[0];
    fullResourceDesc            = &ResourceList->List[0];
    for (i = 0; i < ResourceList->Count; i++) {

        listSize = FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                PartialResourceList) +
                   FIELD_OFFSET(CM_PARTIAL_RESOURCE_LIST,
                                PartialDescriptors);
        partialDescriptor =
            &fullResourceDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < fullResourceDesc->PartialResourceList.Count; j++) {

            ULONG descriptorSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

            if (partialDescriptor->Type == CmResourceTypeDeviceSpecific) {

                descriptorSize +=
                    partialDescriptor->u.DeviceSpecificData.DataSize;
            }
            listSize += descriptorSize;
            partialDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                                    ((PUCHAR)partialDescriptor +
                                        descriptorSize);
        }
        if (    fullResourceDesc->InterfaceType == InterfaceType &&
                fullResourceDesc->BusNumber == BusNumber) {

            newList->Count++;
            RtlCopyMemory(newFullResourceDesc, fullResourceDesc, listSize);
            newFullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                          ((PUCHAR)newFullResourceDesc +
                                            listSize);
        } else {

            (*RemainingList)->Count++;
            RtlCopyMemory(
                remainingFullResourceDesc,
                fullResourceDesc,
                listSize);
            remainingFullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                          ((PUCHAR)remainingFullResourceDesc +
                                            listSize);
        }
        fullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                  ((PUCHAR)fullResourceDesc +
                                    listSize);
    }

    return newList;
}

PCM_RESOURCE_LIST
IopCombineCmResourceList (
    IN PCM_RESOURCE_LIST ResourceListA,
    IN PCM_RESOURCE_LIST ResourceListB
    )

/*++

Routine Description:

    This routine combines the two CM_RESOURCE_LISTs and returns the resulting
    CM_RESOURCE_LIST.

Parameters:

    ResourceListA - ListA.

    ResourceListB - ListB.

Return Value:

    Returns the combined CM_RESOURCE_LIST if successful, else NULL.

--*/

{
    PCM_RESOURCE_LIST   newList;
    ULONG               sizeA;
    ULONG               sizeB;
    ULONG               size;
    ULONG               diff;

    PAGED_CODE();

    if (ResourceListA == NULL) {

        return ResourceListB;
    }

    if (ResourceListB == NULL) {

        return ResourceListA;
    }
    newList = NULL;
    sizeA   = IopDetermineResourceListSize(ResourceListA);
    sizeB   = IopDetermineResourceListSize(ResourceListB);
    if (sizeA && sizeB) {

        diff = sizeof(CM_RESOURCE_LIST) - sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
        size = sizeA + sizeB - diff;
        newList = (PCM_RESOURCE_LIST)ExAllocatePoolIORRR(PagedPool, size);
        if (newList) {

            RtlCopyMemory(newList, ResourceListA, sizeA);
            RtlCopyMemory(
                (PUCHAR)newList + sizeA,
                (PUCHAR)ResourceListB + diff,
                sizeB - diff);
            newList->Count += ResourceListB->Count;
        }
    }

    return newList;
}

/*++

    SECTION = CLEANUP.

    Description:

        This section contains code that performs clean up like releasing storage
        for various data structures..

--*/

VOID
IopFreeReqAlternative (
    IN PREQ_ALTERNATIVE ReqAlternative
    )

/*++

Routine Description:

    This routine release the storage for the ReqAlternative by freeing the
    contained descriptors.

Parameters:

    ReqList - REQ_ALTERNATIVE to be freed.

Return Value:

    None.

--*/

{
    PREQ_DESC   reqDesc;
    PREQ_DESC   reqDescx;
    ULONG       i;

    PAGED_CODE();

    if (ReqAlternative) {
        //
        // Free all REQ_DESC making this REQ_ALTERNATIVE.
        //
        for (i = 0; i < ReqAlternative->DescCount; i++) {
            //
            // Free the list of translated REQ_DESCs for this REQ_DESC.
            //
            reqDesc     = ReqAlternative->DescTable[i];
            reqDescx    = reqDesc->TranslatedReqDesc;
            while (reqDescx && IS_TRANSLATED_REQ_DESC(reqDescx)) {
                //
                // Free storage for alternative descriptors if any.
                //
                if (reqDescx->AlternativeTable.Alternatives) {

                    ExFreePool(reqDescx->AlternativeTable.Alternatives);
                }
                reqDesc     = reqDescx;
                reqDescx    = reqDescx->TranslatedReqDesc;
                ExFreePool(reqDesc);
            }
        }
    }
}

VOID
IopFreeReqList (
    IN PREQ_LIST ReqList
    )

/*++

Routine Description:

    This routine release the storage for the ReqList by freeing the contained
    alternatives.

Parameters:

    ReqList - REQ_LIST to be freed.

Return Value:

    None.

--*/

{
    ULONG i;

    PAGED_CODE();

    if (ReqList) {
        //
        // Free all alternatives making this REQ_LIST.
        //
        for (i = 0; i < ReqList->AlternativeCount; i++) {

            IopFreeReqAlternative(ReqList->AlternativeTable[i]);
        }
        ExFreePool(ReqList);
    }
}

VOID
IopFreeResourceRequirementsForAssignTable(
    IN PIOP_RESOURCE_REQUEST RequestTable,
    IN PIOP_RESOURCE_REQUEST RequestTableEnd
    )

/*++

Routine Description:

    For each resource request in the table, this routine frees its
    associated REQ_LIST.

Parameters:

    RequestTable    - Start of request table.

    RequestTableEnd - End of request table.

Return Value:

    None.

--*/

{
    PIOP_RESOURCE_REQUEST request;

    PAGED_CODE();

    for (request = RequestTable; request < RequestTableEnd; request++) {

        IopFreeReqList(request->ReqList);
        request->ReqList = NULL;
        if (    request->Flags & IOP_ASSIGN_KEEP_CURRENT_CONFIG &&
                request->ResourceRequirements) {
            //
            // The REAL resreq list is cached in DeviceNode->ResourceRequirements.
            // We need to free the filtered list.
            //
            ExFreePool(request->ResourceRequirements);
            request->ResourceRequirements = NULL;
        }
    }
}

#if DBG_SCOPE
VOID
IopCheckDataStructures (
    IN PDEVICE_NODE DeviceNode
    )

{
    PDEVICE_NODE    sibling;

    PAGED_CODE();

    //
    // Process all the siblings.
    //
    for (sibling = DeviceNode; sibling; sibling = sibling->Sibling) {

        IopCheckDataStructuresWorker(sibling);
    }
    for (sibling = DeviceNode; sibling; sibling = sibling->Sibling) {
        //
        // Recursively check all the children.
        //
        if (sibling->Child) {
            IopCheckDataStructures(sibling->Child);
        }
    }
}

VOID
IopCheckDataStructuresWorker (
    IN PDEVICE_NODE Device
    )

/*++

Routine Description:

    This routine sanity checks the arbiter related data structures for the
    specified device.

Parameters:

    DeviceNode - Device node whose structures are to be checked.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listHead, listEntry;
    PPI_RESOURCE_ARBITER_ENTRY arbiterEntry;

    PAGED_CODE();

    listHead    = &Device->DeviceArbiterList;
    listEntry   = listHead->Flink;
    while (listEntry != listHead) {

        arbiterEntry = CONTAINING_RECORD(
                        listEntry,
                        PI_RESOURCE_ARBITER_ENTRY,
                        DeviceArbiterList);
        if (arbiterEntry->ArbiterInterface != NULL) {

            if (!IsListEmpty(&arbiterEntry->ResourceList)) {
                IopDbgPrint((
                    IOP_RESOURCE_ERROR_LEVEL,
                    "Arbiter on %wZ should have empty resource list\n",
                    &Device->InstancePath));
            }
            if (!IsListEmpty(&arbiterEntry->ActiveArbiterList)) {
                IopDbgPrint((
                    IOP_RESOURCE_ERROR_LEVEL,
                    "Arbiter on %wZ should not be in the active arbiter list\n",
                    &Device->InstancePath));
            }
        }
        listEntry = listEntry->Flink;
    }
}

VOID
IopDumpResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResources
    )

/*++

Routine Description:

    This routine dumps IoResources

Parameters:

    IoResources - Supplies a pointer to the IO resource requirements list

Return Value:

    None.

--*/

{
    PIO_RESOURCE_LIST       IoResourceList;
    PIO_RESOURCE_DESCRIPTOR IoResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR IoResourceDescriptorEnd;
    LONG                    IoResourceListCount;

    PAGED_CODE();

    if (IoResources == NULL) {

        return;
    }
    IoResourceList      = IoResources->List;
    IoResourceListCount = (LONG) IoResources->AlternativeLists;
    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "ResReqList: Interface: %x, Bus: %x, Slot: %x, AlternativeLists: %x\n",
         IoResources->InterfaceType,
         IoResources->BusNumber,
         IoResources->SlotNumber,
         IoResources->AlternativeLists));
    while (--IoResourceListCount >= 0) {

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "  Alternative List: DescCount: %x\n",
            IoResourceList->Count));
        IoResourceDescriptor = IoResourceList->Descriptors;
        IoResourceDescriptorEnd = IoResourceDescriptor + IoResourceList->Count;
        while(IoResourceDescriptor < IoResourceDescriptorEnd) {

            IopDumpResourceDescriptor("    ", IoResourceDescriptor++);
        }
        IoResourceList = (PIO_RESOURCE_LIST) IoResourceDescriptorEnd;
    }
    IopDbgPrint((IOP_RESOURCE_VERBOSE_LEVEL,"\n"));
}

VOID
IopDumpResourceDescriptor (
    IN PCHAR Indent,
    IN PIO_RESOURCE_DESCRIPTOR  Desc
    )
{
    PAGED_CODE();

    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "%sOpt: %x, Share: %x\t",
        Indent,
        Desc->Option,
        Desc->ShareDisposition));
    switch (Desc->Type) {
    case CmResourceTypePort:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "IO  Min: %x:%08x, Max: %x:%08x, Algn: %x, Len %x\n",
            Desc->u.Port.MinimumAddress.HighPart,
            Desc->u.Port.MinimumAddress.LowPart,
            Desc->u.Port.MaximumAddress.HighPart,
            Desc->u.Port.MaximumAddress.LowPart,
            Desc->u.Port.Alignment,
            Desc->u.Port.Length));
            break;

    case CmResourceTypeMemory:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "MEM Min: %x:%08x, Max: %x:%08x, Algn: %x, Len %x\n",
            Desc->u.Memory.MinimumAddress.HighPart,
            Desc->u.Memory.MinimumAddress.LowPart,
            Desc->u.Memory.MaximumAddress.HighPart,
            Desc->u.Memory.MaximumAddress.LowPart,
            Desc->u.Memory.Alignment,
            Desc->u.Memory.Length));
            break;

    case CmResourceTypeInterrupt:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "INT Min: %x, Max: %x\n",
            Desc->u.Interrupt.MinimumVector,
            Desc->u.Interrupt.MaximumVector));
            break;

    case CmResourceTypeDma:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "DMA Min: %x, Max: %x\n",
            Desc->u.Dma.MinimumChannel,
            Desc->u.Dma.MaximumChannel));
            break;

    case CmResourceTypeDevicePrivate:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "DevicePrivate Data: %x, %x, %x\n",
            Desc->u.DevicePrivate.Data[0],
            Desc->u.DevicePrivate.Data[1],
            Desc->u.DevicePrivate.Data[2]));
            break;

    default:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "Unknown Descriptor type %x\n",
            Desc->Type));
            break;
    }
}

VOID
IopDumpCmResourceList (
    IN PCM_RESOURCE_LIST CmList
    )
/*++

Routine Description:

    This routine displays CM resource list.

Arguments:

    CmList - CM resource list to be dumped.

Return Value:

    None.

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullDesc;
    PCM_PARTIAL_RESOURCE_LIST       partialDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    ULONG                           count;
    ULONG                           i;

    PAGED_CODE();

    if (CmList->Count > 0) {

        if (CmList) {

            fullDesc = &CmList->List[0];
            IopDbgPrint((
                IOP_RESOURCE_VERBOSE_LEVEL,
                "Cm Resource List -\n"));
            IopDbgPrint((
                IOP_RESOURCE_VERBOSE_LEVEL,
                "  List Count = %x, Bus Number = %x\n",
                CmList->Count,
                fullDesc->BusNumber));
            partialDesc = &fullDesc->PartialResourceList;
            IopDbgPrint((
                IOP_RESOURCE_VERBOSE_LEVEL,
                "  Version = %x, Revision = %x, Desc count = %x\n",
                partialDesc->Version,
                partialDesc->Revision,
                partialDesc->Count));
            count = partialDesc->Count;
            desc = &partialDesc->PartialDescriptors[0];
            for (i = 0; i < count; i++) {

                IopDumpCmResourceDescriptor("    ", desc);
                desc++;
            }
        }
    }
}

VOID
IopDumpCmResourceDescriptor (
    IN PCHAR Indent,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Desc
    )
/*++

Routine Description:

    This routine displays a IO_RESOURCE_DESCRIPTOR.

Parameters:

    Indent - # char of indentation.

    Desc - CM_RESOURCE_DESCRIPTOR to be displayed.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    switch (Desc->Type) {
    case CmResourceTypePort:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "%sIO  Start: %x:%08x, Length:  %x\n",
            Indent,
            Desc->u.Port.Start.HighPart,
            Desc->u.Port.Start.LowPart,
            Desc->u.Port.Length));
        break;

    case CmResourceTypeMemory:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "%sMEM Start: %x:%08x, Length:  %x\n",
            Indent,
            Desc->u.Memory.Start.HighPart,
            Desc->u.Memory.Start.LowPart,
            Desc->u.Memory.Length));
        break;

    case CmResourceTypeInterrupt:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "%sINT Level: %x, Vector: %x, Affinity: %x\n",
            Indent,
            Desc->u.Interrupt.Level,
            Desc->u.Interrupt.Vector,
            Desc->u.Interrupt.Affinity));
        break;

    case CmResourceTypeDma:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "%sDMA Channel: %x, Port: %x\n",
            Indent,
            Desc->u.Dma.Channel,
            Desc->u.Dma.Port));
        break;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpstart.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnpstart.c

Abstract:

    This module implements new Plug-And-Play driver entries and IRPs.

Author:

    Shie-Lin Tzong (shielint) June-16-1995

Environment:

    Kernel mode only.

Revision History:

*/

#include "pnpmgrp.h"
#pragma hdrstop

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ddpP')
#endif

typedef struct _DEVICE_LIST_CONTEXT {
    ULONG DeviceCount;
    BOOLEAN Reallocation;
    PDEVICE_OBJECT DeviceList[1];
} DEVICE_LIST_CONTEXT, *PDEVICE_LIST_CONTEXT;

NTSTATUS
IopAssignResourcesToDevices (
    IN ULONG DeviceCount,
    IN PIOP_RESOURCE_REQUEST RequestTable,
    IN BOOLEAN DoBootConfigs,
    OUT PBOOLEAN RebalancePerformed
    );

NTSTATUS
IopGetDriverDeviceList(
   IN PDRIVER_OBJECT DriverObject,
   OUT PDEVICE_LIST_CONTEXT *DeviceList
   );

NTSTATUS
IopProcessAssignResourcesWorker(
   IN PDEVICE_NODE  DeviceNode,
   IN PVOID         Context
   );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopAssignResourcesToDevices)
#pragma alloc_text(PAGE, IopProcessAssignResources)
#pragma alloc_text(PAGE, IopProcessAssignResourcesWorker)
#pragma alloc_text(PAGE, IopWriteAllocatedResourcesToRegistry)
#endif // ALLOC_PRAGMA



//
// The following routines should be removed once the real
// Resource Assign code is done.
//

NTSTATUS
IopAssignResourcesToDevices(
    IN ULONG DeviceCount,
    IN OUT PIOP_RESOURCE_REQUEST RequestTable,
    IN BOOLEAN DoBootConfigs,
    OUT PBOOLEAN RebalancePerformed
    )
/*++

Routine Description:

    This routine takes an input array of IOP_RESOURCE_REQUEST structures, and
    allocates resource for the physical device object specified in
    the structure.   The allocated resources are automatically recorded
    in the registry.

Arguments:

    DeviceCount - Supplies the number of device objects whom we need to
                  allocate resource to.  That is the number of entries
                  in the RequestTable.

    RequestTable - Supplies an array of IOP_RESOURCE_REQUEST structures which
                   contains the Physical device object to allocate resource to.
                   Upon entry, the ResourceAssignment pointer is NULL and on
                   return the allocated resource is returned via the this pointer.

    DoBootConfigs - Allow assignment of BOOT configs.

Return Value:

    The status returned is the final completion status of the operation.

    NOTE:
    If NTSTATUS_SUCCESS is returned, the resource allocation for *all* the devices
    specified is succeeded.  Otherwise, one or more are failed and caller must
    examine the ResourceAssignment pointer in each IOP_RESOURCE_REQUEST structure to
    determine which devices failed and which succeeded.

--*/
{
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    ASSERT(DeviceCount != 0);

    for (i = 0; i < DeviceCount; i++) {

        //
        // Initialize table entry.
        //
        if (PpCallerInitializesRequestTable == TRUE) {

            RequestTable[i].Position = i;
        }
        RequestTable[i].ResourceAssignment = NULL;
        RequestTable[i].Status = 0;
        RequestTable[i].Flags = 0;
        RequestTable[i].AllocationType = ArbiterRequestPnpEnumerated;
        if (((PDEVICE_NODE)(RequestTable[i].PhysicalDevice->DeviceObjectExtension->DeviceNode))->Flags & DNF_MADEUP) {

            ULONG           reportedDevice = 0;
            HANDLE          hInstance;

            status = IopDeviceObjectToDeviceInstance(RequestTable[i].PhysicalDevice, &hInstance, KEY_READ);
            if (NT_SUCCESS(status)) {

                ULONG           resultSize = 0;
                UCHAR           buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
                UNICODE_STRING  unicodeString;

                PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_DEVICE_REPORTED);
                status = ZwQueryValueKey(   hInstance,
                                            &unicodeString,
                                            KeyValuePartialInformation,
                                            (PVOID)buffer,
                                            sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG),
                                            &resultSize);
                if (NT_SUCCESS(status)) {

                    reportedDevice = *(PULONG)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);

                }

                ZwClose(hInstance);
            }

            //
            // Change the AllocationType for reported devices.
            //

            if (reportedDevice) {

                RequestTable[i].AllocationType = ArbiterRequestLegacyReported;

            }

        }
        RequestTable[i].ResourceRequirements = NULL;
    }

    //
    // Allocate memory to build a IOP_ASSIGN table to call IopAllocateResources()
    //

    status = IopAllocateResources(  &DeviceCount,
                                    &RequestTable,
                                    FALSE,
                                    DoBootConfigs,
                                    RebalancePerformed);
    return status;
}

BOOLEAN
IopProcessAssignResources(
   IN   PDEVICE_NODE    DeviceNode,
   IN   BOOLEAN         Reallocation,
   OUT  BOOLEAN        *RebalancePerformed
   )
/*++

Routine Description:

    This function attempts to assign resources to device under the subtree on
    which AddDevice has been performed. Prior to the completion of all Boot Bus
    Extenders in the system, this routine attempts allocation first so that devices
    with no requirements and no boot config get processed. If there are no such devices,
    then it attempts to allocate resources for devices with boot config. If there are no
    devices with boot config, then other devices (requirements but no boot config)
    get processed. During later part of boot, it attempts allocation only once
    (since we should have already reserved all the boot configs).

Parameters:

    DeviceNode - specifies the root of the subtree under which resources will be
                 allocated.

    Reallocation - if TRUE, we will attempt allocation for devices with resource conflict
                   problem in addition to other devices.

    RebalancePerformed - recieves whether a rebalance was successfully comp[eted.

Return Value:

    TRUE if resources got assigned to any device, otherwise FALSE.

--*/
{
    PDEVICE_NODE deviceNode;
    PDEVICE_LIST_CONTEXT context;
    BOOLEAN resourcesAssigned, tryAgain;
    ULONG count, i, attempt, maxAttempts;
    PIOP_RESOURCE_REQUEST requestTable;

    PAGED_CODE();

    resourcesAssigned = FALSE;
    tryAgain = TRUE;
    maxAttempts = (IopBootConfigsReserved)? 1 : 2;
    for (attempt = 0; !resourcesAssigned && tryAgain && attempt < maxAttempts; attempt++) {

        tryAgain = FALSE;

        //
        // Allocate and init memory for resource context
        //
        context = (PDEVICE_LIST_CONTEXT) ExAllocatePool(
                                        PagedPool,
                                        sizeof(DEVICE_LIST_CONTEXT) +
                                        sizeof(PDEVICE_OBJECT) * IopNumberDeviceNodes
                                        );
        if (!context) {

            return FALSE;
        }
        context->DeviceCount = 0;
        context->Reallocation = Reallocation;

        //
        // Parse the device node subtree to determine which devices need resources
        //
        IopProcessAssignResourcesWorker(DeviceNode, context);
        count = context->DeviceCount;
        if (count == 0) {

            ExFreePool(context);
            return FALSE;
        }

        //
        // Need to assign resources to devices.  Build the resource request table and call
        // resource assignment routine.
        //
        requestTable = (PIOP_RESOURCE_REQUEST) ExAllocatePool(
                                        PagedPool,
                                        sizeof(IOP_RESOURCE_REQUEST) * count
                                        );
        if (requestTable) {

            for (i = 0; i < count; i++) {

                requestTable[i].Priority = 0;
                requestTable[i].PhysicalDevice = context->DeviceList[i];
            }

            //
            // Assign resources
            //
            IopAssignResourcesToDevices(
                count,
                requestTable,
                (attempt == 0) ? IopBootConfigsReserved : TRUE,
                RebalancePerformed
                );

            //
            // Check the results
            //
            for (i = 0; i < count; i++) {

                deviceNode = (PDEVICE_NODE)
                              requestTable[i].PhysicalDevice->DeviceObjectExtension->DeviceNode;

                if (NT_SUCCESS(requestTable[i].Status)) {

                    if (requestTable[i].ResourceAssignment) {

                        deviceNode->ResourceList = requestTable[i].ResourceAssignment;
                        deviceNode->ResourceListTranslated = requestTable[i].TranslatedResourceAssignment;
                    } else {

                        deviceNode->Flags |= DNF_NO_RESOURCE_REQUIRED;
                    }
                    PipSetDevNodeState(deviceNode, DeviceNodeResourcesAssigned, NULL);
                    deviceNode->UserFlags &= ~DNUF_NEED_RESTART;
                    resourcesAssigned = TRUE;
                } else {

                    switch (requestTable[i].Status) {
                    
                    case STATUS_RETRY:

                        tryAgain = TRUE;
                        break;

                    case STATUS_DEVICE_CONFIGURATION_ERROR:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_NO_SOFTCONFIG);
                        break;

                    case STATUS_PNP_BAD_MPS_TABLE:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_BIOS_TABLE);
                        break;

                    case STATUS_PNP_TRANSLATION_FAILED:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_TRANSLATION_FAILED);
                        break;

                    case STATUS_PNP_IRQ_TRANSLATION_FAILED:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_IRQ_TRANSLATION_FAILED);
                        break;

                    case STATUS_RESOURCE_TYPE_NOT_FOUND:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_UNKNOWN_RESOURCE);
                        break;

                    default:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_NORMAL_CONFLICT);
                        break;
                    }
                }
            }
            ExFreePool(requestTable);
        }
        ExFreePool(context);
    }

    return resourcesAssigned;
}

NTSTATUS
IopProcessAssignResourcesWorker(
   IN PDEVICE_NODE  DeviceNode,
   IN PVOID         Context
   )
/*++

Routine Description:

    This functions searches the DeviceNode subtree to locate all the device objects
    which have been successfully added to their drivers and waiting for resources to
    be started.

Parameters:

    DeviceNode - specifies the device node whose subtree is to be checked for AssignRes.

    Context - specifies a pointer to a structure to pass resource assignment information.

Return Value:

    TRUE.

--*/
{
    PDEVICE_LIST_CONTEXT resourceContext = (PDEVICE_LIST_CONTEXT) Context;

    PAGED_CODE();

    //
    // If the device node/object has not been add, skip it.
    //

    if (resourceContext->Reallocation &&
        (PipIsDevNodeProblem(DeviceNode, CM_PROB_NORMAL_CONFLICT) ||
         PipIsDevNodeProblem(DeviceNode, CM_PROB_TRANSLATION_FAILED) ||
         PipIsDevNodeProblem(DeviceNode, CM_PROB_IRQ_TRANSLATION_FAILED))) {

        PipClearDevNodeProblem(DeviceNode);
    }

    if (!PipDoesDevNodeHaveProblem(DeviceNode)) {

        //
        // If the device object has not been started and has no resources yet.
        // Append it to our list.
        //

        if (DeviceNode->State == DeviceNodeDriversAdded) {

               resourceContext->DeviceList[resourceContext->DeviceCount] =
                                  DeviceNode->PhysicalDeviceObject;

               resourceContext->DeviceCount++;

        } else {

            //
            // Acquire enumeration mutex to make sure its children won't change by
            // someone else.  Note, the current device node is protected by its parent's
            // Enumeration mutex and it won't disappear either.
            //

            //
            // Recursively mark all of our children deleted.
            //

            PipForAllChildDeviceNodes(DeviceNode, IopProcessAssignResourcesWorker, Context);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopWriteAllocatedResourcesToRegistry (
    PDEVICE_NODE DeviceNode,
    PCM_RESOURCE_LIST CmResourceList,
    ULONG Length
    )

/*++

Routine Description:

    This routine writes allocated resources for a device to its control key of device
    instance path key.

Arguments:

    DeviceNode - Supplies a pointer to the device node structure of the device.

    CmResourceList - Supplies a pointer to the device's allocated CM resource list.

    Length - Supplies the length of the CmResourceList.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject = DeviceNode->PhysicalDeviceObject;
    HANDLE handle, handlex;
    UNICODE_STRING unicodeName;

    PiLockPnpRegistry(FALSE);

    status = IopDeviceObjectToDeviceInstance(
                                    deviceObject,
                                    &handlex,
                                    KEY_ALL_ACCESS);
    if (NT_SUCCESS(status)) {

        //
        // Open the LogConfig key of the device instance.
        //

        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
        status = IopCreateRegistryKeyEx( &handle,
                                         handlex,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_VOLATILE,
                                         NULL
                                         );
        ZwClose(handlex);
        if (NT_SUCCESS(status)) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_ALLOC_CONFIG);
            if (CmResourceList) {
                status = ZwSetValueKey(
                              handle,
                              &unicodeName,
                              TITLE_INDEX_VALUE,
                              REG_RESOURCE_LIST,
                              CmResourceList,
                              Length
                              );
            } else {
                status = ZwDeleteValueKey(handle, &unicodeName);
            }
            ZwClose(handle);
        }
    }
    PiUnlockPnpRegistry();
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnprlist.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnprlist.h

Abstract:

    This file declares the routines and data structures used to manipulate
    relations list.  Relation lists are used by Plug and Play during the
    processing of device removal and ejection.

Author:

    Robert Nelson (robertn) Apr, 1998.

Revision History:

--*/

//
// An IRPLOCK allows for safe cancellation. The idea is to protect the IRP
// while the canceller is calling IoCancelIrp. This is done by wrapping the
// call in InterlockedExchange(s). The roles are as follows:
//
// Initiator/completion: Cancelable --> IoCallDriver() --> Completed
// Canceller: CancelStarted --> IoCancelIrp() --> CancelCompleted
//
// No cancellation:
//   Cancelable-->Completed
//
// Cancellation, IoCancelIrp returns before completion:
//   Cancelable --> CancelStarted --> CancelCompleted --> Completed
//
// Canceled after completion:
//   Cancelable --> Completed -> CancelStarted
//
// Cancellation, IRP completed during call to IoCancelIrp():
//   Cancelable --> CancelStarted -> Completed --> CancelCompleted
//
//  The transition from CancelStarted to Completed tells the completer to block
//  postprocessing (IRP ownership is transfered to the canceller). Similarly,
//  the canceler learns it owns IRP postprocessing (free, completion, etc)
//  during a Completed->CancelCompleted transition.
//
typedef enum {

   IRPLOCK_CANCELABLE,
   IRPLOCK_CANCEL_STARTED,
   IRPLOCK_CANCEL_COMPLETE,
   IRPLOCK_COMPLETED

} IRPLOCK;

//
// A RELATION_LIST_ENTRY is an element of a relation list.
//
// It contains all the PDEVICE_OBJECTS which exist at the same level in the
// DEVICE_NODE tree.
//
// Individual PDEVICE_OBJECT entries are tagged by setting their lowest bit.
//
// MaxCount indicates the size of the Devices array.  Count indicates the number
// of elements which are currently being used.  When a relation list is
// compressed Count will equal MaxCount.
//
typedef struct _RELATION_LIST_ENTRY {
    ULONG                   Count;          // Number of current entries
    ULONG                   MaxCount;       // Size of Entries list
    PDEVICE_OBJECT          Devices[1];     // Variable length list of device objects
}   RELATION_LIST_ENTRY, *PRELATION_LIST_ENTRY;

//
// A RELATION_LIST contains a number of RELATION_LIST_ENTRY structures.
//
// Each entry in Entries describes all the devices of a given level in the
// DEVICE_NODE tree.  In order to conserve memory, space is only allocated for
// the entries between the lowest and highest levels inclusive.  The member
// FirstLevel indicates which level is at index 0 of Entries.  MaxLevel
// indicates the last level represented in Entries.  The number of entries is
// determined by the formula MaxLevel - FirstLevel + 1.  The Entries array can
// be sparse.  Each element of Entries will either be a PRELATION_LIST_ENTRY or
// NULL.
//
// The total number of PDEVICE_OBJECTs in all PRELATION_LIST_ENTRYs is kept in
// Count.  Individual PDEVICE_OBJECTS may be tagged.  The tag is maintained in
// Bit 0 of the PDEVICE_OBJECT.  The total number of PDEVICE_OBJECTs tagged is
// kept in TagCount.  This is used to rapidly determine whether or not all
// objects have been tagged.
//
typedef struct _RELATION_LIST {
    ULONG                   Count;          // Count of Devices in all Entries
    ULONG                   TagCount;       // Count of Tagged Devices
    ULONG                   FirstLevel;     // Level Number of Entries[0]
    ULONG                   MaxLevel;       // - FirstLevel + 1 = Number of Entries
    PRELATION_LIST_ENTRY    Entries[1];     // Variable length list of entries
}   RELATION_LIST, *PRELATION_LIST;

//
// A PENDING_RELATIONS_LIST_ENTRY is used to track relation lists for operations
// which may pend.  This includes removal when open handles exist and device
// ejection.
//
// The Link field is used to link the PENDING_RELATIONS_LIST_ENTRYs together.
//
// The DeviceObject field is the DEVICE_OBJECT to which the operation was
// originally targetted.  It will also exist as a member of the relations list.
//
// The RelationsList is a list of BusRelations, RemovalRelations, (and
// EjectionRelations in the case of eject) which are related to DeviceObject and
// its relations.
//
// The EjectIrp is pointer to the Eject IRP which has been sent to the PDO.  If
// this is a pending surprise removal then EjectIrp is not used.
//
typedef struct _PENDING_RELATIONS_LIST_ENTRY {
    LIST_ENTRY              Link;
    WORK_QUEUE_ITEM         WorkItem;
    PPNP_DEVICE_EVENT_ENTRY DeviceEvent;
    PDEVICE_OBJECT          DeviceObject;
    PRELATION_LIST          RelationsList;
    PIRP                    EjectIrp;
    IRPLOCK                 Lock;
    ULONG                   Problem;
    BOOLEAN                 ProfileChangingEject;
    BOOLEAN                 DisplaySafeRemovalDialog;
    SYSTEM_POWER_STATE      LightestSleepState;
    PDOCK_INTERFACE         DockInterface;
}   PENDING_RELATIONS_LIST_ENTRY, *PPENDING_RELATIONS_LIST_ENTRY;

//
// Functions exported to other kernel modules.
//
NTSTATUS
IopAddRelationToList(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DirectDescendant,
    IN BOOLEAN Tagged
    );

PRELATION_LIST
IopAllocateRelationList(
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode
    );

NTSTATUS
IopCompressRelationList(
    IN OUT PRELATION_LIST *List
    );

BOOLEAN
IopEnumerateRelations(
    IN PRELATION_LIST List,
    IN OUT PULONG Marker,
    OUT PDEVICE_OBJECT *PhysicalDevice,
    OUT BOOLEAN *DirectDescendant, OPTIONAL
    OUT BOOLEAN *Tagged, OPTIONAL
    BOOLEAN Reverse
    );

VOID
IopFreeRelationList(
    IN PRELATION_LIST List
    );

ULONG
IopGetRelationsCount(
    IN PRELATION_LIST List
    );

ULONG
IopGetRelationsTaggedCount(
    IN PRELATION_LIST List
    );

BOOLEAN
IopIsRelationInList(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopMergeRelationLists(
    IN OUT PRELATION_LIST TargetList,
    IN PRELATION_LIST SourceList,
    IN BOOLEAN Tagged
    );

NTSTATUS
IopRemoveIndirectRelationsFromList(
    IN PRELATION_LIST List
    );

NTSTATUS
IopRemoveRelationFromList(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IopSetAllRelationsTags(
    IN PRELATION_LIST List,
    IN BOOLEAN Tagged
    );

NTSTATUS
IopSetRelationsTag(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Tagged
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\ppcddb.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ppcddb.h

Abstract:

    This header exposes various routines needed for Critical Device Database
    processing to the rest of the Plug and Play subsystem.

Author:

    James G. Cavalaris (jamesca) 01-Nov-2001

Environment:

    Kernel mode.

Revision History:

    29-Jul-1997     Jim Cavalaris (t-jcaval)

        Creation and initial implementation.

    01-Nov-2001     Jim Cavalaris (jamesca)

        Added routines for device pre-installation setup.

--*/


NTSTATUS
PpCriticalProcessCriticalDevice(
    IN  PDEVICE_NODE    DeviceNode
    );

NTSTATUS
PpCriticalGetDeviceLocationStrings(
    IN  PDEVICE_NODE    DeviceNode,
    OUT PWCHAR         *DeviceLocationStrings
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpsubs.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpsubs.c

Abstract:

    This module contains the plug-and-play subroutines for the
    I/O system.


Author:

    Shie-Lin Tzong (shielint) 3-Jan-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// Data structure for each entry in the device reference table.
//
typedef struct _DEVICE_REFERENCE {
    PDEVICE_OBJECT  DeviceObject;   // PDO
    PUNICODE_STRING DeviceInstance; // Pointer to instance path for the devnode for the PDO
} DEVICE_REFERENCE, *PDEVICE_REFERENCE;

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'uspP')
#endif

//
// Regular data segment
//

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif

//
// Table to map InstancePath to DO.
//
RTL_GENERIC_TABLE PpDeviceReferenceTable;

//
// Lock to synchronize access to the table.
//
KGUARDED_MUTEX PpDeviceReferenceTableLock;

//
// Table of BusType GUIDs
//
GUID *PpBusTypeGuidArray;

//
// Number of entries in the BusTypeGuid table.
//
ULONG PpBusTypeGuidCount;

//
// Maximum number of entries in the BusTypeGuid table.
//
ULONG PpBusTypeGuidCountMax;

//
// Lock used to synchronize access to the BusTypeGuid table.
//
KGUARDED_MUTEX PpBusTypeGuidLock;

//
// Prototype of internal functions
//

VOID
IopDisableDevice(
    IN PDEVICE_NODE DeviceNode
    );

BOOLEAN
IopDeleteKeyRecursiveCallback(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    );

NTSTATUS
PipGenerateMadeupNodeName (
    IN  PUNICODE_STRING ServiceKeyName,
    OUT PUNICODE_STRING MadeupNodeName
    );

RTL_GENERIC_COMPARE_RESULTS
NTAPI
PiCompareInstancePath (
    PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

ULONG
PiFixupID(
    IN PWCHAR ID,
    IN ULONG MaxIDLength,
    IN BOOLEAN Multi,
    IN ULONG AllowedSeparators,
    IN PUNICODE_STRING LogString OPTIONAL
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PpInitializeDeviceReferenceTable)
#pragma alloc_text(INIT, PipRegMultiSzToUnicodeStrings)
#pragma alloc_text(INIT, PipFreeUnicodeStringList)
#pragma alloc_text(INIT, PpBusTypeGuidInitialize)

#pragma alloc_text(PAGE, PipApplyFunctionToServiceInstances)
#pragma alloc_text(PAGE, PipApplyFunctionToSubKeys)
#pragma alloc_text(PAGE, IopCleanupDeviceRegistryValues)
#pragma alloc_text(PAGE, IopCmResourcesToIoResources)
#pragma alloc_text(PAGE, PipConcatenateUnicodeStrings)
#pragma alloc_text(PAGE, PipCreateMadeupNode)
#pragma alloc_text(PAGE, PipGenerateMadeupNodeName)
#pragma alloc_text(PAGE, IopCreateRegistryKeyEx)
#pragma alloc_text(PAGE, IopDeleteKeyRecursive)
#pragma alloc_text(PAGE, IopDeleteKeyRecursiveCallback)
#pragma alloc_text(PAGE, IopDeleteLegacyKey)
#pragma alloc_text(PAGE, IopDetermineResourceListSize)
#pragma alloc_text(PAGE, PpSaveDeviceCapabilities)
#pragma alloc_text(PAGE, IopQueryAndSaveDeviceNodeCapabilities)
#pragma alloc_text(PAGE, IopDeviceObjectFromDeviceInstance)
#pragma alloc_text(PAGE, IopDeviceObjectToDeviceInstance)
#pragma alloc_text(PAGE, IopDisableDevice)
#pragma alloc_text(PAGE, IopDriverLoadingFailed)
#pragma alloc_text(PAGE, IopFilterResourceRequirementsList)
#pragma alloc_text(PAGE, IopGetDeviceInstanceCsConfigFlags)
#pragma alloc_text(PAGE, IopGetDeviceResourcesFromRegistry)
#pragma alloc_text(PAGE, PipGetServiceInstanceCsConfigFlags)
#pragma alloc_text(PAGE, IopIsAnyDeviceInstanceEnabled)
#pragma alloc_text(PAGE, IopIsDeviceInstanceEnabled)
#pragma alloc_text(PAGE, PipIsDuplicatedDevices)
#pragma alloc_text(PAGE, IopIsLegacyDriver)
#pragma alloc_text(PAGE, IopMergeCmResourceLists)
#pragma alloc_text(PAGE, IopMergeFilteredResourceRequirementsList)
#pragma alloc_text(PAGE, IopOpenCurrentHwProfileDeviceInstanceKey)
#pragma alloc_text(PAGE, IopOpenRegistryKeyEx)
#pragma alloc_text(PAGE, PipOpenServiceEnumKeys)
#pragma alloc_text(PAGE, IopPrepareDriverLoading)
#pragma alloc_text(PAGE, PipReadDeviceConfiguration)
#pragma alloc_text(PAGE, IopRestartDeviceNode)
#pragma alloc_text(PAGE, PipServiceInstanceToDeviceInstance)
#pragma alloc_text(PAGE, IopMapDeviceObjectToDeviceInstance)
#pragma alloc_text(PAGE, PiRegSzToString)
#pragma alloc_text(PAGE, PiCompareInstancePath)
#pragma alloc_text(PAGE, PiAllocateGenericTableEntry)
#pragma alloc_text(PAGE, PiFreeGenericTableEntry)
#pragma alloc_text(PAGE, PpSystemHiveLimitCallback)
#pragma alloc_text(PAGE, PpLogEvent)
#pragma alloc_text(PAGE, PiFixupID)
#pragma alloc_text(PAGE, PpQueryID)
#pragma alloc_text(PAGE, PpQueryDeviceID)
#pragma alloc_text(PAGE, PpQueryBusInformation)
#pragma alloc_text(PAGE, PpBusTypeGuidGetIndex)
#pragma alloc_text(PAGE, PpBusTypeGuidGet)

#if DBG

#pragma alloc_text(PAGE, IopDebugPrint)

#endif
#endif

NTSTATUS
PipCreateMadeupNode(
    IN PUNICODE_STRING ServiceKeyName,
    OUT PHANDLE ReturnedHandle,
    OUT PUNICODE_STRING KeyName,
    OUT PULONG InstanceNumber,
    IN BOOLEAN ResourceOwned
    )

/*++

Routine Description:

    This routine creates a new instance node under System\Enum\Root\LEGACY_<ServiceKeyName>
    key and all the required default value entries.  Also a value entry under
    Service\<ServiceKeyName>\Enum is created to point to the newly created madeup
    entry.  A handle and the keyname of the new key are returned to caller.
    Caller must free the unicode string when he is done with it.

Parameters:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load. This is the RegistryPath parameter
        to the DriverEntry routine.

    ReturnedHandle - Supplies a variable to receive the handle of the
        newly created key.

    KeyName - Supplies a variable to receive the name of the newly created
        key.

    InstanceNumber - supplies a variable to receive the InstanceNumber value
        entry created under service\name\enum subkey.

    ResourceOwned - supplies a BOOLEAN variable to indicate if caller owns
        the registry resource shared.

        ADRIAO N.B. 08/25/2000 - All users of this function pass in TRUE...

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING tmpKeyName, unicodeInstanceName, unicodeString;
    UNICODE_STRING rootKeyName, unicodeValueName, unicodeKeyName;
    HANDLE handle, enumRootHandle;
    ULONG instance;
    UCHAR unicodeBuffer[20];
    ULONG tmpValue, disposition;
    NTSTATUS status;
    PWSTR p;
    BOOLEAN releaseResource;

    PAGED_CODE();

    disposition = 0;
    releaseResource = FALSE;
    if (!ResourceOwned) {

        PiLockPnpRegistry(FALSE);
        releaseResource = TRUE;
    }
    //
    // Open LocalMachine\System\CurrentControlSet\Enum\Root
    //
    status = IopOpenRegistryKeyEx( &enumRootHandle,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumRootName,
                                   KEY_ALL_ACCESS
                                   );
    if (!NT_SUCCESS(status)) {

        goto local_exit0;
    }
    //
    // Generate the LEGACY_<ServiceKeyName> device id name from the ServiceKeyName.
    //
    status = PipGenerateMadeupNodeName( ServiceKeyName,
                                        &unicodeKeyName);
    if (!NT_SUCCESS(status)) {

        ZwClose(enumRootHandle);
        goto local_exit0;
    }
    //
    // Open, and create if not already exist, System\Enum\Root\LEGACY_<ServiceKeyName>
    //
    status = IopCreateRegistryKeyEx( &handle,
                                     enumRootHandle,
                                     &unicodeKeyName,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL);
    ZwClose(enumRootHandle);
    if (!NT_SUCCESS(status)) {

        RtlFreeUnicodeString(&unicodeKeyName);
        goto local_exit0;
    }
    instance = 1;
    PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_NEXT_INSTANCE);
    status = ZwSetValueKey( handle,
                            &unicodeValueName,
                            TITLE_INDEX_VALUE,
                            REG_DWORD,
                            &instance,
                            sizeof(instance));
    instance--;
    *InstanceNumber = instance;
    PiUlongToInstanceKeyUnicodeString(&unicodeInstanceName,
                                      unicodeBuffer + sizeof(WCHAR), // reserve first WCHAR space
                                      20 - sizeof(WCHAR),
                                      instance);
    status = IopCreateRegistryKeyEx( ReturnedHandle,
                                     handle,
                                     &unicodeInstanceName,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     &disposition);
    ZwClose(handle);
    if (!NT_SUCCESS(status)) {

        RtlFreeUnicodeString(&unicodeKeyName);
        goto local_exit0;
    }
    //
    // Prepare newly created registry key name for returning to caller
    //
    *(PWSTR)unicodeBuffer = OBJ_NAME_PATH_SEPARATOR;
    unicodeInstanceName.Buffer = (PWSTR)unicodeBuffer;
    unicodeInstanceName.Length += sizeof(WCHAR);
    unicodeInstanceName.MaximumLength += sizeof(WCHAR);
    PiWstrToUnicodeString(&rootKeyName, REGSTR_KEY_ROOTENUM);
    PiWstrToUnicodeString(&tmpKeyName, L"\\");
    status = PipConcatenateUnicodeStrings(&unicodeString, &tmpKeyName, &unicodeKeyName);
    RtlFreeUnicodeString(&unicodeKeyName);
    if (!NT_SUCCESS(status)) {

        goto local_exit0;
    }
    status = PipConcatenateUnicodeStrings(&tmpKeyName, &rootKeyName, &unicodeString);
    RtlFreeUnicodeString(&unicodeString);
    if (!NT_SUCCESS(status)) {

        goto local_exit0;
    }
    status = PipConcatenateUnicodeStrings(KeyName, &tmpKeyName, &unicodeInstanceName);
    if (!NT_SUCCESS(status)) {

        RtlFreeUnicodeString(&tmpKeyName);
        goto local_exit0;
    }

    if (disposition == REG_CREATED_NEW_KEY) {
        //
        // Create all the default value entry for the newly created key.
        // Service = ServiceKeyName
        // FoundAtEnum = 1
        // Class = "LegacyDriver"
        // ClassGUID = GUID for legacy driver class
        // ConfigFlags = 0
        //
        // Create "Control" subkey with "NewlyCreated" value key
        //
        PiWstrToUnicodeString(&unicodeValueName, REGSTR_KEY_CONTROL);
        status = IopCreateRegistryKeyEx( &handle,
                                         *ReturnedHandle,
                                         &unicodeValueName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_VOLATILE,
                                         NULL);
        if (NT_SUCCESS(status)) {

            PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_NEWLY_CREATED);
            tmpValue = 0;
            ZwSetValueKey(handle,
                          &unicodeValueName,
                          TITLE_INDEX_VALUE,
                          REG_DWORD,
                          &tmpValue,
                          sizeof(tmpValue));
            ZwClose(handle);
        }

        handle = *ReturnedHandle;

        PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_SERVICE);
        p = (PWSTR)ExAllocatePool(PagedPool,
                                  ServiceKeyName->Length + sizeof(UNICODE_NULL));
        if(p) {

            RtlCopyMemory(p, ServiceKeyName->Buffer, ServiceKeyName->Length);
            p[ServiceKeyName->Length / sizeof (WCHAR)] = UNICODE_NULL;
            ZwSetValueKey(
                        handle,
                        &unicodeValueName,
                        TITLE_INDEX_VALUE,
                        REG_SZ,
                        p,
                        ServiceKeyName->Length + sizeof(UNICODE_NULL)
                        );
            //
            // We'll keep the null-terminated service name buffer around for a while,
            // because we may need it later on for the DeviceDesc in case the service
            // has no DisplayName.
            //
        }

        PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_LEGACY);
        tmpValue = 1;
        ZwSetValueKey(
                    handle,
                    &unicodeValueName,
                    TITLE_INDEX_VALUE,
                    REG_DWORD,
                    &tmpValue,
                    sizeof(tmpValue)
                    );

        PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_CONFIG_FLAGS);
        tmpValue = 0;
        ZwSetValueKey(
                    handle,
                    &unicodeValueName,
                    TITLE_INDEX_VALUE,
                    REG_DWORD,
                    &tmpValue,
                    sizeof(tmpValue)
                    );

        PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_CLASS);
        ZwSetValueKey(
                    handle,
                    &unicodeValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    REGSTR_VALUE_LEGACY_DRIVER,
                    sizeof(REGSTR_VALUE_LEGACY_DRIVER)
                    );

        PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_CLASSGUID);
        ZwSetValueKey(
                    handle,
                    &unicodeValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    (PVOID)&REGSTR_VALUE_LEGACY_DRIVER_CLASS_GUID,
                    sizeof(REGSTR_VALUE_LEGACY_DRIVER_CLASS_GUID));
        //
        // Initialize DeviceDesc= value entry.  If the service key has a "DisplayName"
        // value entry, it is used as the DeviceDesc value.  Otherwise, the service key
        // name is used.
        //
        status = PipOpenServiceEnumKeys(ServiceKeyName,
                                        KEY_READ,
                                        &handle,
                                        NULL,
                                        FALSE);
        if (NT_SUCCESS(status)) {

            keyValueInformation = NULL;
            unicodeString.Length = 0;
            status = IopGetRegistryValue(handle,
                                         REGSTR_VALUE_DISPLAY_NAME,
                                         &keyValueInformation
                                        );
            if (NT_SUCCESS(status)) {

                if (keyValueInformation->Type == REG_SZ) {

                    if (keyValueInformation->DataLength > sizeof(UNICODE_NULL)) {

                        IopRegistryDataToUnicodeString(&unicodeString,
                                                       (PWSTR)KEY_VALUE_DATA(keyValueInformation),
                                                       keyValueInformation->DataLength
                                                       );
                    }
                }
            }
            if ((unicodeString.Length == 0) && p) {
                //
                // No DisplayName--use the service key name.
                //
                unicodeString.Length = ServiceKeyName->Length;
                unicodeString.MaximumLength = ServiceKeyName->Length + sizeof(UNICODE_NULL);
                unicodeString.Buffer = p;
            }

            if(unicodeString.Length) {

                PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_DEVICE_DESC);
                ZwSetValueKey(*ReturnedHandle,
                              &unicodeValueName,
                              TITLE_INDEX_VALUE,
                              REG_SZ,
                              unicodeString.Buffer,
                              unicodeString.Length + sizeof(UNICODE_NULL)
                              );
            }
            if (keyValueInformation) {

                ExFreePool(keyValueInformation);
            }
            ZwClose(handle);
        }

        if(p) {

            ExFreePool(p);
        }
    }

    //
    // Create new value entry under ServiceKeyName\Enum to reflect the newly
    // added made-up device instance node.
    //

    PiUnlockPnpRegistry();
    releaseResource = FALSE;

    status = PpDeviceRegistration(KeyName, TRUE, NULL);

    if (ResourceOwned) {

        PiLockPnpRegistry(FALSE);
    }
    RtlFreeUnicodeString(&tmpKeyName);
    if (!NT_SUCCESS(status)) {
        //
        // There is no registry key for the ServiceKeyName information.
        //
        ZwClose(*ReturnedHandle);
        RtlFreeUnicodeString(KeyName);
    }

local_exit0:

    if (releaseResource) {

        PiUnlockPnpRegistry();
    }

    return status;
}

NTSTATUS
PipGenerateMadeupNodeName (
    IN  PUNICODE_STRING ServiceKeyName,
    OUT PUNICODE_STRING MadeupNodeName
    )

/*++

Routine Description:

    This routine parses the ServiceKeyName string and replaces any space
    characters with an underscore character, and any invalid characters (not
    allowed in a "device instance") with their hexadecimal character
    representation.

    Invalid characters are:
        c <  0x20 (' ')
        c >  0x7F
        c == 0x2C (',')

    The resulting modified ServiceKeyName string is used to create a valid
    device id.  Paged pool space is allocated for the destination string.
    Caller must release the space once done with it.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load. This is the RegistryPath parameter
        to the DriverEntry routine.

    MadeupNodeName - Supplies a variable to receive the name of madeup device
        id.  If successful, the caller is responsible for freeing the allocated
        buffer.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    PWCHAR BufferEnd, p, q;
    ULONG length;
    PWSTR buffer;

    //
    // We'll need at least as much room as the size of the unicode service key
    // name, plus the LEGACY_ prefix and terminating NULL char..
    //
    length = sizeof(REGSTR_KEY_MADEUP) + ServiceKeyName->Length;

    p = ServiceKeyName->Buffer;
    BufferEnd = (PWCHAR)((PUCHAR)p + ServiceKeyName->Length);
    while(p != BufferEnd) {
        if ((*p < L' ') || (*p > (WCHAR)0x7F) || (*p == L',')) {
            //
            // Each "invalid" character will be replaced with a '*' character
            // (size already accounted for in calculated length), plus one
            // character for each nibble of each byte in the invalid character.
            //
            length += 2*sizeof(WCHAR)*sizeof(WCHAR);
        }
        p++;
    }

    //
    // Allocate a buffer large enough to hold the converted
    // LEGACY_<ServiceKeyName> string.
    //
    buffer = (PWSTR)ExAllocatePool(PagedPool, length);
    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MadeupNodeName->Buffer = buffer;
    MadeupNodeName->Length = (USHORT)(length - sizeof(UNICODE_NULL));
    MadeupNodeName->MaximumLength = (USHORT)length;

    RtlCopyMemory(buffer, REGSTR_KEY_MADEUP, sizeof(REGSTR_KEY_MADEUP));

    q = buffer + (sizeof(REGSTR_KEY_MADEUP) - sizeof(UNICODE_NULL))/sizeof(WCHAR);

    p = ServiceKeyName->Buffer;
    BufferEnd = (PWCHAR)((PUCHAR)p + ServiceKeyName->Length);
    while(p != BufferEnd) {
        if (*p == L' ') {
            //
            // replace ' ' with '_'
            //
            *q = L'_';
            q++;

        } else if ((*p < L' ')  || (*p > (WCHAR)0x7F) || (*p == L',')) {
            //
            // replace invalid characters with '*' plus a character string
            // representation of the hexadecimal digits.
            //
            int i, nibble;

            *q = L'*';
            q++;

            for (i = 1; i <= 2*sizeof(WCHAR); i++) {
                nibble = ((USHORT)((*p) >> (0x10 - 4*i)) & 0xF);
                *q = nibble > 9 ? (WCHAR)(nibble - 10 + L'A') : (WCHAR)(nibble + L'0');
                q++;
            }

        } else {
            //
            // copy the existing character.
            //
            *q = *p;
            q++;
        }
        p++;
    }

    *q = UNICODE_NULL;

    //
    // Upcase the resulting device id.
    //

    RtlUpcaseUnicodeString(MadeupNodeName, MadeupNodeName, FALSE);

    //
    // Sanity check to make sure that the device id we generated is valid.  At
    // this point, there should be absolutely no reason that it wouldn't be.
    //

    if (!PiFixupID(MadeupNodeName->Buffer, MAX_DEVICE_ID_LEN, FALSE, 0, NULL)) {
        ASSERT(0);
        RtlFreeUnicodeString(MadeupNodeName);
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PipConcatenateUnicodeStrings (
    OUT PUNICODE_STRING Destination,
    IN  PUNICODE_STRING String1,
    IN  PUNICODE_STRING String2  OPTIONAL
    )

/*++

Routine Description:

    This routine returns a buffer containing the concatenation of the
    two specified strings.  Since String2 is optional, this function may
    also be used to make a copy of a unicode string.  Paged pool space
    is allocated for the destination string.  Caller must release the
    space once done with it.

Parameters:

    Destination - Supplies a variable to receive the concatenated
        UNICODE_STRING.

    String1 - Supplies a pointer to the frist UNICODE_STRING.

    String2 - Supplies an optional pointer to the second UNICODE_STRING.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    ULONG length;

    PAGED_CODE();

    length = String1->Length;
    if (ARGUMENT_PRESENT(String2)) {

        length += String2->Length;
    }
    status = IopAllocateUnicodeString(Destination, 
                                      (USHORT)length
                                      );
    if (NT_SUCCESS(status)) {

        RtlCopyUnicodeString(Destination, String1);
        if (ARGUMENT_PRESENT(String2)) {

            RtlAppendUnicodeStringToString(Destination, String2);
        }
    }

    return status;
}

NTSTATUS
IopPrepareDriverLoading (
    IN PUNICODE_STRING KeyName,
    IN HANDLE KeyHandle,
    IN PVOID ImageBase,
    IN BOOLEAN IsFilter
    )

/*++

Routine Description:

    This routine first checks if the driver is loadable.  If its a
    PnP driver, it will always be loaded (we trust it to do the right
    things.)  If it is a legacy driver, we need to check if its device
    has been disabled.  Once we decide to load the driver, the Enum
    subkey of the service node will be checked for duplicates, if any.

Parameters:

    KeyName - Supplies a pointer to the driver's service key unicode string

    KeyHandle - Supplies a handle to the driver service node in the registry
        that describes the driver to be loaded.

Return Value:

    The function value is the final status of the load operation.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    ULONG tmp, count;
    HANDLE serviceEnumHandle = NULL, sysEnumXxxHandle, controlHandle;
    UNICODE_STRING unicodeKeyName, unicodeValueName;
    BOOLEAN IsPlugPlayDriver;
    PIMAGE_NT_HEADERS header;
    GUID blockedDriverGuid;

    header = RtlImageNtHeader(ImageBase);
    status = STATUS_SUCCESS;
    IsPlugPlayDriver = (header &&
                        (header->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_WDM_DRIVER))? TRUE : FALSE;

    if (!IopIsAnyDeviceInstanceEnabled(KeyName, KeyHandle, (BOOLEAN)(IsPlugPlayDriver ? FALSE : TRUE))) {

        if (!IsPlugPlayDriver) {

            PiLockPnpRegistry(FALSE);

            //
            // First open registry ServiceKeyName\Enum branch
            //

            PiWstrToUnicodeString(&unicodeKeyName, REGSTR_KEY_ENUM);
            status = IopCreateRegistryKeyEx( &serviceEnumHandle,
                                             KeyHandle,
                                             &unicodeKeyName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_VOLATILE,
                                             NULL
                                             );
            if (NT_SUCCESS(status)) {

                //
                // Find out how many device instances listed in the ServiceName's
                // Enum key.
                //

                count = 0;
                status = IopGetRegistryValue ( serviceEnumHandle,
                                               REGSTR_VALUE_COUNT,
                                               &keyValueInformation);
                if (NT_SUCCESS(status)) {

                    if (    keyValueInformation->Type == REG_DWORD &&
                            keyValueInformation->DataLength >= sizeof(ULONG)) {

                        count = *(PULONG)KEY_VALUE_DATA(keyValueInformation);

                    }

                    ExFreePool(keyValueInformation);

                }
                if (    NT_SUCCESS(status) ||
                        status == STATUS_OBJECT_PATH_NOT_FOUND ||
                        status == STATUS_OBJECT_NAME_NOT_FOUND) {

                    if (count) {

                        status = STATUS_PLUGPLAY_NO_DEVICE;

                    } else {

                        //
                        // If there is no Enum key or instance under Enum for the
                        // legacy driver we will create a madeup node for it.
                        //

                        status = PipCreateMadeupNode(   KeyName,
                                                        &sysEnumXxxHandle,
                                                        &unicodeKeyName,
                                                        &tmp,
                                                        TRUE);
                        if (NT_SUCCESS(status)) {

                            RtlFreeUnicodeString(&unicodeKeyName);

                            //
                            // Create and set Control\ActiveService value
                            //

                            PiWstrToUnicodeString(&unicodeValueName, REGSTR_KEY_CONTROL);
                            status = IopCreateRegistryKeyEx( &controlHandle,
                                                             sysEnumXxxHandle,
                                                             &unicodeValueName,
                                                             KEY_ALL_ACCESS,
                                                             REG_OPTION_VOLATILE,
                                                             NULL
                                                             );
                            if (NT_SUCCESS(status)) {

                                PiWstrToUnicodeString(&unicodeValueName, REGSTR_VAL_ACTIVESERVICE);
                                ZwSetValueKey(  controlHandle,
                                                &unicodeValueName,
                                                TITLE_INDEX_VALUE,
                                                REG_SZ,
                                                KeyName->Buffer,
                                                KeyName->Length + sizeof(UNICODE_NULL));
                                ZwClose(controlHandle);

                            }
                            count++;
                            //
                            // Don't forget to update the "Count=" and "NextInstance=" value entries
                            //

                            PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_COUNT);
                            ZwSetValueKey(  serviceEnumHandle,
                                            &unicodeValueName,
                                            TITLE_INDEX_VALUE,
                                            REG_DWORD,
                                            &count,
                                            sizeof(count));

                            PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_NEXT_INSTANCE);
                            ZwSetValueKey(  serviceEnumHandle,
                                            &unicodeValueName,
                                            TITLE_INDEX_VALUE,
                                            REG_DWORD,
                                            &count,
                                            sizeof(count));

                            ZwClose(sysEnumXxxHandle);
                            status = STATUS_SUCCESS;
                        }
                    }
                }

                ZwClose(serviceEnumHandle);
            }

            PiUnlockPnpRegistry();
        }
    }
    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&blockedDriverGuid, sizeof(GUID));

        status = PpCheckInDriverDatabase(
            KeyName,
            KeyHandle,
            ImageBase,
            header->OptionalHeader.SizeOfImage,
            IsFilter,
            &blockedDriverGuid);

        if (status == STATUS_DRIVER_BLOCKED ||
            status == STATUS_DRIVER_BLOCKED_CRITICAL) {
            //
            // Notify the user-mode Plug and Play manager that a driver was just
            // blocked.
            //
            PpSetBlockedDriverEvent(&blockedDriverGuid);
        }
    }

    return status;
}

NTSTATUS
PipServiceInstanceToDeviceInstance (
    IN  HANDLE ServiceKeyHandle OPTIONAL,
    IN  PUNICODE_STRING ServiceKeyName OPTIONAL,
    IN  ULONG ServiceInstanceOrdinal,
    OUT PUNICODE_STRING DeviceInstanceRegistryPath OPTIONAL,
    OUT PHANDLE DeviceInstanceHandle OPTIONAL,
    IN  ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine reads the service node enum entry to find the desired device instance
    under the System\Enum tree.  It then optionally returns the registry path of the
    specified device instance (relative to HKLM\System\Enum) and an open handle
    to that registry key.

    It is the caller's responsibility to close the handle returned if
    DeviceInstanceHandle is supplied, and also to free the (PagedPool) memory
    allocated for the unicode string buffer of DeviceInstanceRegistryPath, if
    supplied.

Parameters:

    ServiceKeyHandle - Optionally, supplies a handle to the driver service node in the
        registry that controls this device instance.  If this argument is not specified,
        then ServiceKeyName is used to specify the service entry.

    ServiceKeyName - Optionally supplies the name of the service entry that controls
        the device instance. This must be specified if ServiceKeyHandle isn't given.

    ServiceInstanceOrdinal - Supplies the instance value under the service entry's
        volatile Enum subkey that references the desired device instance.

    DeviceInstanceRegistryPath - Optionally, supplies a pointer to a unicode string
        that will be initialized with the registry path (relative to HKLM\System\Enum)
        to the device instance key.

    DeviceInstanceHandle - Optionally, supplies a pointer to a variable that will
        receive a handle to the opened device instance registry key.

    DesiredAccess - If DeviceInstanceHandle is specified (i.e., the device instance
        key is to be opened), then this variable specifies the access that is needed
        to this key.

Return Value:

    NT status code indicating whether the function was successful.

--*/

{
    WCHAR unicodeBuffer[20];
    UNICODE_STRING unicodeKeyName;
    NTSTATUS status;
    HANDLE handle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    //
    // Open registry ServiceKeyName\Enum branch
    //
    if(ARGUMENT_PRESENT(ServiceKeyHandle)) {

        PiWstrToUnicodeString(&unicodeKeyName, REGSTR_KEY_ENUM);
        status = IopOpenRegistryKeyEx( &handle,
                                       ServiceKeyHandle,
                                       &unicodeKeyName,
                                       KEY_READ
                                       );
    } else {

        status = PipOpenServiceEnumKeys(ServiceKeyName,
                                        KEY_READ,
                                        NULL,
                                        &handle,
                                        FALSE
                                       );
    }

    if (!NT_SUCCESS( status )) {

        //
        // There is no registry key for the ServiceKeyName\Enum information.
        //

        return status;
    }

    //
    // Read a path to System\Enum hardware tree branch specified by the service
    // instance ordinal
    //

    StringCbPrintfW(unicodeBuffer, sizeof(unicodeBuffer), REGSTR_VALUE_STANDARD_ULONG_FORMAT, ServiceInstanceOrdinal);
    status = IopGetRegistryValue ( handle,
                                   unicodeBuffer,
                                   &keyValueInformation
                                   );

    ZwClose(handle);
    if (!NT_SUCCESS( status )) {
        return status;
    } else {
        if(keyValueInformation->Type == REG_SZ) {
            IopRegistryDataToUnicodeString(&unicodeKeyName,
                                           (PWSTR)KEY_VALUE_DATA(keyValueInformation),
                                           keyValueInformation->DataLength
                                          );
            if(!unicodeKeyName.Length) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
            }
        } else {
            status = STATUS_INVALID_PLUGPLAY_DEVICE_PATH;
        }

        if(!NT_SUCCESS(status)) {
            goto PrepareForReturn;
        }
    }

    //
    // If the DeviceInstanceHandle argument was specified, open the device instance
    // key under HKLM\System\CurrentControlSet\Enum
    //

    if (ARGUMENT_PRESENT(DeviceInstanceHandle)) {

        status = IopOpenRegistryKeyEx( &handle,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSetEnumName,
                                       KEY_READ
                                       );

        if (NT_SUCCESS( status )) {

            status = IopOpenRegistryKeyEx( DeviceInstanceHandle,
                                           handle,
                                           &unicodeKeyName,
                                           DesiredAccess
                                           );
            ZwClose(handle);
        }

        if (!NT_SUCCESS( status )) {
            goto PrepareForReturn;
        }
    }

    //
    // If the DeviceInstanceRegistryPath argument was specified, then store a
    // copy of the device instance path in the supplied unicode string variable.
    //
    if (ARGUMENT_PRESENT(DeviceInstanceRegistryPath)) {

        status = PipConcatenateUnicodeStrings(  DeviceInstanceRegistryPath,
                                                &unicodeKeyName,
                                                NULL);
        if (!NT_SUCCESS(status)) {

            if(ARGUMENT_PRESENT(DeviceInstanceHandle)) {
                ZwClose(*DeviceInstanceHandle);
            }
        }
    }

PrepareForReturn:

    ExFreePool(keyValueInformation);
    return status;
}

NTSTATUS
IopOpenRegistryKeyEx(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    Opens a registry key using the name passed in based at the BaseHandle node.
    This name may specify a key that is actually a registry path.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Optional handle to the base path from which the key must be
        opened. If this parameter is specified, then KeyName must be a relative
        path.

    KeyName - Name of the Key that must be opened/created (possibly a registry path)

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;

    PAGED_CODE();

    *Handle = NULL;

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL
                                );
    //
    // Simply attempt to open the path, as specified.
    //
    return ZwOpenKey( Handle, DesiredAccess, &objectAttributes );
}

NTSTATUS
IopCreateRegistryKeyEx(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    )

/*++

Routine Description:

    Opens or creates a registry key using the name
    passed in based at the BaseHandle node. This name may specify a key
    that is actually a registry path, in which case each intermediate subkey
    will be created (if Create is TRUE).

    NOTE: Creating a registry path (i.e., more than one of the keys in the path
    do not presently exist) requires that a BaseHandle be specified.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Optional handle to the base path from which the key must be opened.
        If KeyName specifies a registry path that must be created, then this parameter
        must be specified, and KeyName must be a relative path.

    KeyName - Name of the Key that must be opened/created (possibly a registry path)

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    CreateOptions - Options passed to ZwCreateKey.

    Disposition - If Create is TRUE, this optional pointer receives a ULONG indicating
        whether the key was newly created:

            REG_CREATED_NEW_KEY - A new Registry Key was created
            REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition, baseHandleIndex = 0, keyHandleIndex = 1, closeBaseHandle;
    HANDLE handles[2];
    BOOLEAN continueParsing;
    PWCHAR pathEndPtr, pathCurPtr, pathBeginPtr;
    ULONG pathComponentLength;
    UNICODE_STRING unicodeString;
    NTSTATUS status;

    PAGED_CODE();

    *Handle= NULL;

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL
                                );
    //
    // Attempt to create the path as specified. We have to try it this
    // way first, because it allows us to create a key without a BaseHandle
    // (if only the last component of the registry path is not present).
    //
    status = ZwCreateKey(&(handles[keyHandleIndex]),
                         DesiredAccess,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING) NULL,
                         CreateOptions,
                         &disposition
                         );

    if (status == STATUS_OBJECT_NAME_NOT_FOUND && ARGUMENT_PRESENT(BaseHandle)) {
        //
        // If we get to here, then there must be more than one element of the
        // registry path that does not currently exist.  We will now parse the
        // specified path, extracting each component and doing a ZwCreateKey on it.
        //
        handles[baseHandleIndex] = NULL;
        handles[keyHandleIndex] = BaseHandle;
        closeBaseHandle = 0;
        continueParsing = TRUE;
        pathBeginPtr = KeyName->Buffer;
        pathEndPtr = (PWCHAR)((PCHAR)pathBeginPtr + KeyName->Length);
        status = STATUS_SUCCESS;

        while(continueParsing) {
            //
            // There's more to do, so close the previous base handle (if necessary),
            // and replace it with the current key handle.
            //
            if(closeBaseHandle > 1) {
                ZwClose(handles[baseHandleIndex]);
            }
            baseHandleIndex = keyHandleIndex;
            keyHandleIndex = (keyHandleIndex + 1) & 1;  // toggle between 0 and 1.
            handles[keyHandleIndex] = NULL;

            //
            // Extract next component out of the specified registry path.
            //
            for (pathCurPtr = pathBeginPtr;
                ((pathCurPtr < pathEndPtr) && (*pathCurPtr != OBJ_NAME_PATH_SEPARATOR));
                pathCurPtr++);

            pathComponentLength = (ULONG)((PCHAR)pathCurPtr - (PCHAR)pathBeginPtr);
            if (pathComponentLength != 0) {
                //
                // Then we have a non-empty path component (key name).  Attempt
                // to create this key.
                //
                unicodeString.Buffer = pathBeginPtr;
                unicodeString.Length = unicodeString.MaximumLength = (USHORT)pathComponentLength;

                InitializeObjectAttributes(&objectAttributes,
                                           &unicodeString,
                                           OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                           handles[baseHandleIndex],
                                           (PSECURITY_DESCRIPTOR) NULL
                                          );
                status = ZwCreateKey(&(handles[keyHandleIndex]),
                                     DesiredAccess,
                                     &objectAttributes,
                                     0,
                                     (PUNICODE_STRING) NULL,
                                     CreateOptions,
                                     &disposition
                                    );
                if(NT_SUCCESS(status)) {
                    //
                    // Increment the closeBaseHandle value, which basically tells us whether
                    // the BaseHandle passed in has been 'shifted out' of our way, so that
                    // we should start closing our base handles when we're finished with them.
                    //
                    closeBaseHandle++;
                } else {
                    continueParsing = FALSE;
                    continue;
                }
            } else {
                //
                // Either a path separator ('\') was included at the beginning of
                // the path, or we hit 2 consecutive separators.
                //
                status = STATUS_INVALID_PARAMETER;
                continueParsing = FALSE;
                continue;
            }

            if((pathCurPtr == pathEndPtr) ||
               ((pathBeginPtr = pathCurPtr + 1) == pathEndPtr)) {
                //
                // Then we've reached the end of the path
                //
                continueParsing = FALSE;
            }
        }

        if(closeBaseHandle > 1) {
            ZwClose(handles[baseHandleIndex]);
        }
    }

    if(NT_SUCCESS(status)) {
        *Handle = handles[keyHandleIndex];

        if(ARGUMENT_PRESENT(Disposition)) {
            *Disposition = disposition;
        }
    }

    return status;
}

NTSTATUS
PipOpenServiceEnumKeys (
    IN PUNICODE_STRING ServiceKeyName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE ServiceHandle OPTIONAL,
    OUT PHANDLE ServiceEnumHandle OPTIONAL,
    IN BOOLEAN CreateEnum
    )

/*++

Routine Description:

    This routine opens the HKEY_LOCAL_MACHINE\CurrentControlSet\Services\
    ServiceKeyName and its Enum subkey and returns handles for both key.
    It is caller's responsibility to close the returned handles.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load. This is the RegistryPath parameter
        to the DriverEntry routine.

    DesiredAccess - Specifies the desired access to the keys.

    ServiceHandle - Supplies a variable to receive a handle to ServiceKeyName.
        A NULL ServiceHandle indicates caller does not want need the handle to
        the ServiceKeyName.

    ServiceEnumHandle - Supplies a variable to receive a handle to ServiceKeyName\Enum.
        A NULL ServiceEnumHandle indicates caller does not need the handle to
        the ServiceKeyName\Enum.

    CreateEnum - Supplies a BOOLEAN variable to indicate should the Enum subkey be
        created if not present.

Return Value:

    status

--*/

{
    HANDLE handle, serviceHandle, enumHandle;
    UNICODE_STRING enumName;
    NTSTATUS status;

    //
    // Open System\CurrentControlSet\Services
    //

    status = IopOpenRegistryKeyEx( &handle,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetServices,
                                   DesiredAccess
                                   );

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Open the registry ServiceKeyName key.
    //

    status = IopOpenRegistryKeyEx( &serviceHandle,
                                   handle,
                                   ServiceKeyName,
                                   DesiredAccess
                                   );

    ZwClose(handle);
    if (!NT_SUCCESS( status )) {

        //
        // There is no registry key for the ServiceKeyName information.
        //

        return status;
    }

    if (ARGUMENT_PRESENT(ServiceEnumHandle) || CreateEnum) {

        //
        // Open registry ServiceKeyName\Enum branch if caller wants
        // the handle or wants to create it.
        //

        PiWstrToUnicodeString(&enumName, REGSTR_KEY_ENUM);

        if (CreateEnum) {
            status = IopCreateRegistryKeyEx( &enumHandle,
                                             serviceHandle,
                                             &enumName,
                                             DesiredAccess,
                                             REG_OPTION_VOLATILE,
                                             NULL
                                             );
        } else {
            status = IopOpenRegistryKeyEx( &enumHandle,
                                           serviceHandle,
                                           &enumName,
                                           DesiredAccess
                                           );

        }

        if (!NT_SUCCESS( status )) {

            //
            // There is no registry key for the ServiceKeyName\Enum information.
            //

            ZwClose(serviceHandle);
            return status;
        }
        if (ARGUMENT_PRESENT(ServiceEnumHandle)) {
            *ServiceEnumHandle = enumHandle;
        } else {
            ZwClose(enumHandle);
        }
    }

    //
    // if caller wants to have the ServiceKey handle, we return it.  Otherwise
    // we close it.
    //

    if (ARGUMENT_PRESENT(ServiceHandle)) {
        *ServiceHandle = serviceHandle;
    } else {
        ZwClose(serviceHandle);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopGetDeviceInstanceCsConfigFlags(
    IN PUNICODE_STRING DeviceInstance,
    OUT PULONG CsConfigFlags
    )

/*++

Routine Description:

    This routine retrieves the csconfig flags for the specified device.

Arguments:

    DeviceInstance - Supplies a pointer to the devnode's instance path

    CsConfigFlags - Supplies a variable to receive the device's CsConfigFlags

Return Value:

    status

--*/

{
    NTSTATUS status;
    HANDLE handle1, handle2;
    UNICODE_STRING tempUnicodeString;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    PAGED_CODE();

    *CsConfigFlags = 0;

    status = IopOpenRegistryKeyEx( &handle1,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Now, we must open the System\CCS\Enum key under this.
    //
    //
    // Open system\CurrentControlSet under current hardware profile key
    //

    PiWstrToUnicodeString(&tempUnicodeString, REGSTR_PATH_CURRENTCONTROLSET);
    status = IopOpenRegistryKeyEx( &handle2,
                                   handle1,
                                   &tempUnicodeString,
                                   KEY_READ
                                   );
    ZwClose(handle1);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    PiWstrToUnicodeString(&tempUnicodeString, REGSTR_KEY_ENUM);

    status = IopOpenRegistryKeyEx( &handle1,
                                   handle2,
                                   &tempUnicodeString,
                                   KEY_READ
                                   );

    ZwClose(handle2);

    if (!NT_SUCCESS(status)) {

        return status;
    }


    status = IopOpenRegistryKeyEx( &handle2,
                                   handle1,
                                   DeviceInstance,
                                   KEY_READ
                                   );

    ZwClose(handle1);

    if (!NT_SUCCESS(status)) {

        return status;
    }


    status = IopGetRegistryValue( handle2,
                                  REGSTR_VALUE_CSCONFIG_FLAGS,
                                  &keyValueInformation
                                  );

    ZwClose(handle2);

    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {

            *CsConfigFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }

    return status;
}

NTSTATUS
PipGetServiceInstanceCsConfigFlags(
    IN PUNICODE_STRING ServiceKeyName,
    IN ULONG Instance,
    OUT PULONG CsConfigFlags
    )

/*++

Routine Description:

    This routine retrieves the csconfig flags for the specified device
    which is specified by the instance number under ServiceKeyName\Enum.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load.

    Instance - Supplies the instance value under ServiceKeyName\Enum key

    CsConfigFlags - Supplies a variable to receive the device's CsConfigFlags

Return Value:

    status

--*/

{
    NTSTATUS status;
    HANDLE handle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    PAGED_CODE();

    *CsConfigFlags = 0;

    status = IopOpenCurrentHwProfileDeviceInstanceKey(&handle,
                                                      ServiceKeyName,
                                                      Instance,
                                                      KEY_READ,
                                                      FALSE
                                                     );
    if(NT_SUCCESS(status)) {
        status = IopGetRegistryValue(handle,
                                     REGSTR_VALUE_CSCONFIG_FLAGS,
                                     &keyValueInformation
                                    );
        if(NT_SUCCESS(status)) {
            if((keyValueInformation->Type == REG_DWORD) &&
               (keyValueInformation->DataLength >= sizeof(ULONG))) {
                *CsConfigFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            }
            ExFreePool(keyValueInformation);
        }
        ZwClose(handle);
    }
    return status;
}

NTSTATUS
IopOpenCurrentHwProfileDeviceInstanceKey(
    OUT PHANDLE Handle,
    IN  PUNICODE_STRING ServiceKeyName,
    IN  ULONG Instance,
    IN  ACCESS_MASK DesiredAccess,
    IN  BOOLEAN Create
    )

/*++

Routine Description:

    This routine sets the csconfig flags for the specified device
    which is specified by the instance number under ServiceKeyName\Enum.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load. This is the RegistryPath parameter
        to the DriverEntry routine.

    Instance - Supplies the instance value under ServiceKeyName\Enum key

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

    status

--*/

{
    NTSTATUS status;
    UNICODE_STRING tempUnicodeString;
    HANDLE profileHandle, profileEnumHandle, tmpHandle;

    //
    // See if we can open current hardware profile
    //

    if (Create) {
        status = IopCreateRegistryKeyEx( &profileHandle,
                                         NULL,
                                         &CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent,
                                         KEY_READ,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
    } else {
        status = IopOpenRegistryKeyEx( &profileHandle,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent,
                                       KEY_READ
                                       );
    }

    if(NT_SUCCESS(status)) {
        //
        // Now, we must open the System\CCS\Enum key under this.
        //
        //
        // Open system\CurrentControlSet under current hardware profile key
        //

        PiWstrToUnicodeString(&tempUnicodeString, REGSTR_PATH_CURRENTCONTROLSET);
        status = IopOpenRegistryKeyEx( &tmpHandle,
                                       profileHandle,
                                       &tempUnicodeString,
                                       DesiredAccess
                                       );
        ZwClose(profileHandle);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        PiWstrToUnicodeString(&tempUnicodeString, REGSTR_KEY_ENUM);

        if (Create) {
            status = IopCreateRegistryKeyEx( &profileEnumHandle,
                                             tmpHandle,
                                             &tempUnicodeString,
                                             KEY_READ,
                                             REG_OPTION_NON_VOLATILE,
                                             NULL
                                             );
        } else {
            status = IopOpenRegistryKeyEx( &profileEnumHandle,
                                           tmpHandle,
                                           &tempUnicodeString,
                                           KEY_READ
                                           );
        }

        ZwClose(tmpHandle);
        if(NT_SUCCESS(status)) {

            status = PipServiceInstanceToDeviceInstance(NULL,
                                                        ServiceKeyName,
                                                        Instance,
                                                        &tempUnicodeString,
                                                        NULL,
                                                        0
                                                       );
            if (NT_SUCCESS(status)) {
                if (Create) {
                    status = IopCreateRegistryKeyEx( Handle,
                                                     profileEnumHandle,
                                                     &tempUnicodeString,
                                                     DesiredAccess,
                                                     REG_OPTION_NON_VOLATILE,
                                                     NULL
                                                     );
                } else {
                    status = IopOpenRegistryKeyEx( Handle,
                                                   profileEnumHandle,
                                                   &tempUnicodeString,
                                                   DesiredAccess
                                                   );
                }
                RtlFreeUnicodeString(&tempUnicodeString);
            }
            ZwClose(profileEnumHandle);
        }
    }
    return status;
}

NTSTATUS
PipApplyFunctionToSubKeys(
    IN     HANDLE BaseHandle OPTIONAL,
    IN     PUNICODE_STRING KeyName OPTIONAL,
    IN     ACCESS_MASK DesiredAccess,
    IN     ULONG Flags,
    IN     PIOP_SUBKEY_CALLBACK_ROUTINE SubKeyCallbackRoutine,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine enumerates all subkeys under the specified key, and calls
    the specified callback routine for each subkey.

Arguments:

    BaseHandle - Optional handle to the base registry path. If KeyName is also
        specified, then KeyName represents a subkey under this path.  If KeyName
        is not specified, the subkeys are enumerated under this handle.  If this
        parameter is not specified, then the full path to the base key must be
        given in KeyName.

    KeyName - Optional name of the key whose subkeys are to be enumerated.

    DesiredAccess - Specifies the desired access that the callback routine
        needs to the subkeys.  If no desired access is specified (i.e.,
        DesiredAccess is zero), then no handle will be opened for the
        subkeys, and the callback will be passed a NULL for its SubKeyHandle
        parameter.

    Flags - Controls the behavior of subkey enumeration.  Currently, the
        following flags are defined:

        FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS - Specifies whether this
            function should immediately terminate on all errors, or only on
            critical ones.  An example of a non-critical error is when an
            enumerated subkey cannot be opened for the desired access.

        FUNCTION_SUBKEY_DELETE_SUBKEYS - Specifies that each subkey should be
            deleted after the specified SubKeyCallBackRoutine has been performed
            on it.  Note that this is NOT a recursive delete on each of the
            subkeys, just an attempt to delete the subkey itself.  It the subkey
            contains children, this will fail.

    SubKeyCallbackRoutine - Supplies a pointer to a function that will
        be called for each subkey found under the
        specified key.  The prototype of the function
        is as follows:

            typedef BOOLEAN (*PIOP_SUBKEY_CALLBACK_ROUTINE) (
                IN     HANDLE SubKeyHandle,
                IN     PUNICODE_STRING SubKeyName,
                IN OUT PVOID Context
                );

        where SubKeyHandle is the handle to an enumerated subkey under the
        specified key, SubKeyName is its name, and Context is a pointer to
        user-defined data.

        This function should return TRUE to continue enumeration, or
        FALSE to terminate it.

    Context - Supplies a pointer to user-defined data that will be passed
        in to the callback routine at each subkey invocation.

Return Value:

    NT status code indicating whether the subkeys were successfully
    enumerated.  Note that this does not provide information on the
    success or failure of the callback routine--if desired, this
    information should be stored in the Context structure.

--*/

{
    NTSTATUS Status;
    BOOLEAN CloseHandle = FALSE, ContinueEnumeration;
    HANDLE Handle, SubKeyHandle;
    ULONG i, RequiredBufferLength;
    PKEY_BASIC_INFORMATION KeyInformation = NULL;
    // Use an initial key name buffer size large enough for a 20-character key
    // (+ terminating NULL)
    ULONG KeyInformationLength = sizeof(KEY_BASIC_INFORMATION) + (20 * sizeof(WCHAR));
    UNICODE_STRING SubKeyName;

    if(ARGUMENT_PRESENT(KeyName)) {

        Status = IopOpenRegistryKeyEx( &Handle,
                                       BaseHandle,
                                       KeyName,
                                       KEY_READ
                                       );
        if(!NT_SUCCESS(Status)) {
            return Status;
        } else {
            CloseHandle = TRUE;
        }

    } else {

        Handle = BaseHandle;
    }

    //
    // Enumerate the subkeys until we run out of them.
    //
    i = 0;
    SubKeyHandle = NULL;

    for ( ; ; ) {

        if (!KeyInformation) {

            KeyInformation = (PKEY_BASIC_INFORMATION)ExAllocatePool(PagedPool,
                                                                    KeyInformationLength
                                                                   );
            if (!KeyInformation) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        }

        Status = ZwEnumerateKey(Handle,
                                i,
                                KeyBasicInformation,
                                KeyInformation,
                                KeyInformationLength,
                                &RequiredBufferLength
                               );

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_BUFFER_OVERFLOW ||
                Status == STATUS_BUFFER_TOO_SMALL) {
                //
                // Try again with larger buffer.
                //
                ExFreePool(KeyInformation);
                KeyInformation = NULL;
                KeyInformationLength = RequiredBufferLength;
                continue;

            } else {

                if (Status == STATUS_NO_MORE_ENTRIES) {
                    //
                    // No more subkeys.
                    //
                    Status = STATUS_SUCCESS;
                }
                //
                // break out of loop
                //
                break;
            }
        }

        //
        // Initialize a unicode string with this key name.  Note that this string
        // WILL NOT be NULL-terminated.
        //
        SubKeyName.Length = SubKeyName.MaximumLength = (USHORT)KeyInformation->NameLength;
        SubKeyName.Buffer = KeyInformation->Name;

        //
        // If DesiredAccess is non-zero, open a handle to this subkey.
        //
        if (DesiredAccess) {
            Status = IopOpenRegistryKeyEx( &SubKeyHandle,
                                           Handle,
                                           &SubKeyName,
                                           DesiredAccess
                                           );
            if (!NT_SUCCESS(Status)) {
                //
                // This is a non-critical error.
                //
                if(Flags & FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS) {
                    goto ContinueWithNextSubKey;
                } else {
                    break;
                }
            }
        }

        //
        // Invoke the supplied callback function for this subkey.
        //
        ContinueEnumeration = SubKeyCallbackRoutine(SubKeyHandle, &SubKeyName, Context);

        if (DesiredAccess) {
            if (ContinueEnumeration &&
                (Flags & FUNCTIONSUBKEY_FLAG_DELETE_SUBKEYS)) {
                //
                // Delete the key when asked to, only if the callback routine
                // was successful, otherwise we may not be able to.
                //
                Status = ZwDeleteKey(SubKeyHandle);
            }
            ZwClose(SubKeyHandle);
        }

        if(!ContinueEnumeration) {
            //
            // Enumeration has been aborted.
            //
            Status = STATUS_SUCCESS;
            break;

        }

ContinueWithNextSubKey:
        if (!(Flags & FUNCTIONSUBKEY_FLAG_DELETE_SUBKEYS)) {
            //
            // Only increment the enumeration index for non-deleted subkeys
            //
            i++;
        }
    }

    if(KeyInformation) {
        ExFreePool(KeyInformation);
    }

    if(CloseHandle) {
        ZwClose(Handle);
    }

    return Status;
}

NTSTATUS
PipRegMultiSzToUnicodeStrings(
    IN  PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    OUT PUNICODE_STRING *UnicodeStringList,
    OUT PULONG UnicodeStringCount
    )

/*++

Routine Description:

    This routine takes a KEY_VALUE_FULL_INFORMATION structure containing
    a REG_MULTI_SZ value, and allocates an array of UNICODE_STRINGs,
    initializing each one to a copy of one of the strings in the value entry.
    All the resulting UNICODE_STRINGs will be NULL terminated
    (MaximumLength = Length + sizeof(UNICODE_NULL)).

    It is the responsibility of the caller to free the buffers for each
    unicode string, as well as the buffer containing the UNICODE_STRING
    array. This may be done by calling PipFreeUnicodeStringList.

Arguments:

    KeyValueInformation - Supplies the buffer containing the REG_MULTI_SZ
        value entry data.

    UnicodeStringList - Receives a pointer to an array of UNICODE_STRINGs, each
        initialized with a copy of one of the strings in the REG_MULTI_SZ.

    UnicodeStringCount - Receives the number of strings in the
        UnicodeStringList.

Returns:

    NT status code indicating whether the function was successful.

    NOTE: This function is only available during INIT time!

--*/

{
    PWCHAR p, BufferEnd, StringStart;
    ULONG StringCount, i, StringLength;

    //
    // First, make sure this is really a REG_MULTI_SZ value.
    //
    if(KeyValueInformation->Type != REG_MULTI_SZ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make a preliminary pass through the buffer to count the number of strings
    // There will always be at least one string returned (possibly empty).
    //
    // FUTURE: Make this robust against odd length buffers.
    //
    StringCount = 0;
    p = (PWCHAR)KEY_VALUE_DATA(KeyValueInformation);
    BufferEnd = (PWCHAR)((PUCHAR)p + KeyValueInformation->DataLength);
    while(p != BufferEnd) {
        if(!*p) {
            StringCount++;
            if(((p + 1) == BufferEnd) || !*(p + 1)) {
                break;
            }
        }
        p++;
    }
    if(p == BufferEnd) {
        StringCount++;
    }

    *UnicodeStringList = ExAllocatePool(PagedPool, sizeof(UNICODE_STRING) * StringCount);
    if(!(*UnicodeStringList)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now, make a second pass through the buffer making copies of each string.
    //
    i = 0;
    StringStart = p = (PWCHAR)KEY_VALUE_DATA(KeyValueInformation);
    while(p != BufferEnd) {
        if(!*p) {
            StringLength = (ULONG)((PUCHAR)p - (PUCHAR)StringStart) + sizeof(UNICODE_NULL);
            (*UnicodeStringList)[i].Buffer = ExAllocatePool(PagedPool, StringLength);

            if(!((*UnicodeStringList)[i].Buffer)) {
                PipFreeUnicodeStringList(*UnicodeStringList, i);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlCopyMemory((*UnicodeStringList)[i].Buffer, StringStart, StringLength);

            (*UnicodeStringList)[i].Length =
                ((*UnicodeStringList)[i].MaximumLength = (USHORT)StringLength)
                - sizeof(UNICODE_NULL);

            i++;

            if(((p + 1) == BufferEnd) || !*(p + 1)) {
                break;
            } else {
                StringStart = p + 1;
            }
        }
        p++;
    }
    if(p == BufferEnd) {
        StringLength = (ULONG)((PUCHAR)p - (PUCHAR)StringStart);
        (*UnicodeStringList)[i].Buffer = ExAllocatePool(PagedPool,
                                                        StringLength + sizeof(UNICODE_NULL)
                                                       );
        if(!((*UnicodeStringList)[i].Buffer)) {
            PipFreeUnicodeStringList(*UnicodeStringList, i);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        if(StringLength) {
            RtlCopyMemory((*UnicodeStringList)[i].Buffer, StringStart, StringLength);
        }
        (*UnicodeStringList)[i].Buffer[CB_TO_CWC(StringLength)] = UNICODE_NULL;

        (*UnicodeStringList)[i].MaximumLength =
                ((*UnicodeStringList)[i].Length = (USHORT)StringLength)
                + sizeof(UNICODE_NULL);
    }

    *UnicodeStringCount = StringCount;

    return STATUS_SUCCESS;
}

NTSTATUS
PipApplyFunctionToServiceInstances(
    IN     HANDLE ServiceKeyHandle OPTIONAL,
    IN     PUNICODE_STRING ServiceKeyName OPTIONAL,
    IN     ACCESS_MASK DesiredAccess,
    IN     BOOLEAN IgnoreNonCriticalErrors,
    IN     PIOP_SUBKEY_CALLBACK_ROUTINE DevInstCallbackRoutine,
    IN OUT PVOID Context,
    OUT    PULONG ServiceInstanceOrdinal OPTIONAL
    )

/*++

Routine Description:

    This routine enumerates all device instances referenced by the instance
    ordinal entries under a service's volatile Enum key, and calls
    the specified callback routine for each instance's corresponding subkey
    under HKLM\System\Enum.

Arguments:

    ServiceKeyHandle - Optional handle to the service entry. If this parameter
        is not specified, then the service key name must be given in
        ServiceKeyName (if both parameters are specified, then ServiceKeyHandle
        is used, and ServiceKeyName is ignored).

    ServiceKeyName - Optional name of the service entry key (under
        HKLM\CurrentControlSet\Services). If this parameter is not specified,
        then ServiceKeyHandle must contain a handle to the desired service key.

    DesiredAccess - Specifies the desired access that the callback routine
        needs to the enumerated device instance keys.  If no desired access is
        specified (i.e., DesiredAccess is zero), then no handle will be opened
        for the device instance keys, and the callback will be passed a NULL for
        its DeviceInstanceHandle parameter.

    IgnoreNonCriticalErrors - Specifies whether this function should
        immediately terminate on all errors, or only on critical ones.
        An example of a non-critical error is when an enumerated device instance
        key cannot be opened for the desired access.

    DevInstCallbackRoutine - Supplies a pointer to a function that will
        be called for each device instance key referenced by a service instance
        entry under the service's volatile Enum subkey. The prototype of the
        function is as follows:

            typedef BOOLEAN (*PIOP_SUBKEY_CALLBACK_ROUTINE) (
                IN     HANDLE DeviceInstanceHandle,
                IN     PUNICODE_STRING DeviceInstancePath,
                IN OUT PVOID Context
                );

        where DeviceInstanceHandle is the handle to an enumerated device instance
        key, DeviceInstancePath is the registry path (relative to
        HKLM\System\Enum) to this device instance, and Context is a pointer to
        user-defined data.

        This function should return TRUE to continue enumeration, or
        FALSE to terminate it.

    Context - Supplies a pointer to user-defined data that will be passed
        in to the callback routine at each device instance key invocation.

    ServiceInstanceOrdinal - Optionally, receives the service instance ordinal (1 based)
        that terminated the enumeration, or the total number of instances enumerated
        if the enumeration completed without being aborted.

Return Value:

    NT status code indicating whether the device instance keys were successfully
    enumerated.  Note that this does not provide information on the success or
    failure of the callback routine--if desired, this information should be
    stored in the Context structure.

--*/

{
    NTSTATUS Status;
    HANDLE ServiceEnumHandle, SystemEnumHandle, DeviceInstanceHandle;
    UNICODE_STRING TempUnicodeString;
    ULONG ServiceInstanceCount, i, junk;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    BOOLEAN ContinueEnumeration;

    //
    // First, open up the volatile Enum subkey under the specified service entry.
    //

    if(ARGUMENT_PRESENT(ServiceKeyHandle)) {
        PiWstrToUnicodeString(&TempUnicodeString, REGSTR_KEY_ENUM);
        Status = IopOpenRegistryKeyEx( &ServiceEnumHandle,
                                       ServiceKeyHandle,
                                       &TempUnicodeString,
                                       KEY_READ
                                       );
    } else {
        Status = PipOpenServiceEnumKeys(ServiceKeyName,
                                        KEY_READ,
                                        NULL,
                                        &ServiceEnumHandle,
                                        FALSE
                                       );
    }
    if(!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Find out how many instances are referenced in the service's Enum key.
    //

    ServiceInstanceCount = 0;   // assume none.

    Status = IopGetRegistryValue(ServiceEnumHandle,
                                 REGSTR_VALUE_COUNT,
                                 &KeyValueInformation
                                );
    if (NT_SUCCESS(Status)) {

        if((KeyValueInformation->Type == REG_DWORD) &&
           (KeyValueInformation->DataLength >= sizeof(ULONG))) {

            ServiceInstanceCount = *(PULONG)KEY_VALUE_DATA(KeyValueInformation);

        }
        ExFreePool(KeyValueInformation);

    } else if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto PrepareForReturn;
    } else {
        //
        // If 'Count' value entry not found, consider this to mean there are simply
        // no device instance controlled by this service.
        //
        Status = STATUS_SUCCESS;
    }

    //
    // Now, enumerate each service instance, and call the specified callback function
    // for the corresponding device instance.
    //

    if (ServiceInstanceCount) {

        //
        // Set DeviceInstanceHandle to NULL (assume we won't be opening up the
        // device instance keys).
        //

        DeviceInstanceHandle = NULL;
        SystemEnumHandle = NULL;

        if (DesiredAccess) {
            Status = IopOpenRegistryKeyEx( &SystemEnumHandle,
                                           NULL,
                                           &CmRegistryMachineSystemCurrentControlSetEnumName,
                                           KEY_READ
                                           );
            if(!NT_SUCCESS(Status)) {
                goto PrepareForReturn;
            }
        }

        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ExAllocatePool(
                                                              PagedPool,
                                                              PNP_SCRATCH_BUFFER_SIZE);
        if (!KeyValueInformation) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto PrepareForReturn;
        }

        for (i = 0; ; i++) {

            Status = ZwEnumerateValueKey(
                            ServiceEnumHandle,
                            i,
                            KeyValueFullInformation,
                            KeyValueInformation,
                            PNP_SCRATCH_BUFFER_SIZE,
                            &junk
                            );

            if (!NT_SUCCESS (Status)) {
                if (Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                    break;
                } else if (IgnoreNonCriticalErrors) {
                    continue;
                } else {
                    break;
                }
            }

            if (KeyValueInformation->Type != REG_SZ) {
                continue;
            }

            ContinueEnumeration = TRUE;
            TempUnicodeString.Length = 0;
            IopRegistryDataToUnicodeString(&TempUnicodeString,
                                           (PWSTR)KEY_VALUE_DATA(KeyValueInformation),
                                           KeyValueInformation->DataLength
                                           );
            if (TempUnicodeString.Length) {

                //
                // We have retrieved a (non-empty) string for this service instance.
                // If the user specified a non-zero value for the DesiredAccess
                // parameter, we will attempt to open up the corresponding device
                // instance key under HKLM\System\Enum.
                //
                if (DesiredAccess) {
                    Status = IopOpenRegistryKeyEx( &DeviceInstanceHandle,
                                                   SystemEnumHandle,
                                                   &TempUnicodeString,
                                                   DesiredAccess
                                                   );
                }

                if (NT_SUCCESS(Status)) {
                    //
                    // Invoke the specified callback routine for this device instance.
                    //
                    ContinueEnumeration = DevInstCallbackRoutine(DeviceInstanceHandle,
                                                                 &TempUnicodeString,
                                                                 Context
                                                                );
                    if (DesiredAccess) {
                        ZwClose(DeviceInstanceHandle);
                    }
                } else if (IgnoreNonCriticalErrors) {
                    continue;
                } else {
                    break;
                }
            } else {
                continue;
            }
            if (!ContinueEnumeration) {
                break;
            }
        }

        if (ARGUMENT_PRESENT(ServiceInstanceOrdinal)) {
            *ServiceInstanceOrdinal = i;
        }

        if (DesiredAccess) {
            ZwClose(SystemEnumHandle);
        }
        ExFreePool(KeyValueInformation);
    }


PrepareForReturn:

    ZwClose(ServiceEnumHandle);

    return Status;
}

BOOLEAN
PipIsDuplicatedDevices(
    IN PCM_RESOURCE_LIST Configuration1,
    IN PCM_RESOURCE_LIST Configuration2,
    IN PHAL_BUS_INFORMATION BusInfo1 OPTIONAL,
    IN PHAL_BUS_INFORMATION BusInfo2 OPTIONAL
    )

/*++

Routine Description:

    This routine compares two set of configurations and bus information to
    determine if the resources indicate the same device.  If BusInfo1 and
    BusInfo2 both are absent, it means caller wants to compare the raw
    resources.

Arguments:

    Configuration1 - Supplies a pointer to the first set of resource.

    Configuration2 - Supplies a pointer to the second set of resource.

    BusInfo1 - Supplies a pointer to the first set of bus information.

    BusInfo2 - Supplies a pointer to the second set of bus information.

Return Value:

    returns TRUE if the two set of resources indicate the same device;
    otherwise a value of FALSE is returned.

--*/

{
    PCM_PARTIAL_RESOURCE_LIST list1, list2;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor1, descriptor2;

    ULONG i, j;
    ULONG pass = 0;

    //
    // The BusInfo for both resources must be both present or not present.
    //

    if ((ARGUMENT_PRESENT(BusInfo1) && !ARGUMENT_PRESENT(BusInfo2)) ||
        (!ARGUMENT_PRESENT(BusInfo1) && ARGUMENT_PRESENT(BusInfo2))) {

        //
        // Unable to determine.
        //

        return FALSE;
    }

    //
    // Next check resources used by the two devices.
    // Currently, we *only* check the Io ports.
    //

    if (Configuration1->Count == 0 || Configuration2->Count == 0) {

        //
        // If any one of the configuration data is empty, we assume
        // the devices are not duplicates.
        //

        return FALSE;
    }

RedoScan:

    list1 = &(Configuration1->List[0].PartialResourceList);
    list2 = &(Configuration2->List[0].PartialResourceList);

    for(i = 0, descriptor1 = list1->PartialDescriptors;
        i < list1->Count;
        i++, descriptor1++) {

        //
        // If this is an i/o port or a memory range then look for a match
        // in the other list.
        //

        if((descriptor1->Type == CmResourceTypePort) ||
           (descriptor1->Type == CmResourceTypeMemory)) {

            for(j = 0, descriptor2 = list2->PartialDescriptors;
                j < list2->Count;
                j++, descriptor2++) {

                //
                // If the types match then check to see if both addresses
                // match as well.  If bus info was provided then go ahead
                // and translate the ranges first.
                //

                if(descriptor1->Type == descriptor2->Type) {

                    PHYSICAL_ADDRESS range1, range1Translated;
                    PHYSICAL_ADDRESS range2, range2Translated;
                    ULONG range1IoSpace, range2IoSpace;

                    range1 = descriptor1->u.Generic.Start;
                    range2 = descriptor2->u.Generic.Start;

                    if((range1.QuadPart == 0) ||
                       (BusInfo1 == NULL) ||
                       (HalTranslateBusAddress(
                            BusInfo1->BusType,
                            BusInfo1->BusNumber,
                            range1,
                            &range1IoSpace,
                            &range1Translated) == FALSE)) {

                        range1Translated = range1;
                        range1IoSpace =
                            (descriptor1->Type == CmResourceTypePort) ? TRUE :
                                                                        FALSE;
                    }

                    if((range2.QuadPart == 0) ||
                       (BusInfo2 == NULL) ||
                       (HalTranslateBusAddress(
                            BusInfo2->BusType,
                            BusInfo2->BusNumber,
                            range2,
                            &range2IoSpace,
                            &range2Translated) == FALSE)) {

                        range2Translated = range2;
                        range2IoSpace =
                            (descriptor2->Type == CmResourceTypePort) ? TRUE :
                                                                        FALSE;
                    }

                    //
                    // If the ranges are in the same space and start at the
                    // same location then break out and go on to the next
                    // range
                    //

                    if((range1Translated.QuadPart == range2Translated.QuadPart) &&
                       (range1IoSpace == range2IoSpace)) {

                        break;
                    }
                }
            }

            //
            // If we made it all the way through the resource list without
            // finding a match then these are not duplicates.
            //

            if(j == list2->Count) {
                return FALSE;
            }
        }
    }

    //
    // If every resource in list 1 exists in list 2 then we also need to make
    // sure that every resource in list 2 exists in list 1.
    //

    if(pass == 0) {

        PVOID tmp ;

        tmp = Configuration2;
        Configuration2 = Configuration1;
        Configuration1 = tmp;

        tmp = BusInfo2;
        BusInfo2 = BusInfo1;
        BusInfo1 = tmp;

        pass = 1;

        goto RedoScan;
    }

    return TRUE;
}

VOID
PipFreeUnicodeStringList(
    IN PUNICODE_STRING UnicodeStringList,
    IN ULONG StringCount
    )

/*++

Routine Description:

    This routine frees the buffer for each UNICODE_STRING in the specified list
    (there are StringCount of them), and then frees the memory used for the
    string list itself.

Arguments:

    UnicodeStringList - Supplies a pointer to an array of UNICODE_STRINGs.

    StringCount - Supplies the number of strings in the UnicodeStringList array.

Returns:

    None.

    NOTE: This function is only available during INIT time!

--*/

{
    ULONG i;

    if(UnicodeStringList) {

        for(i = 0; i < StringCount; i++) {

            if(UnicodeStringList[i].Buffer) {

                ExFreePool(UnicodeStringList[i].Buffer);
            }
        }
        ExFreePool(UnicodeStringList);
    }
}

NTSTATUS
IopDriverLoadingFailed(
    IN HANDLE ServiceHandle OPTIONAL,
    IN PUNICODE_STRING ServiceName OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked when driver failed to start.  All the device
    instances controlled by this driver/service are marked as failing to
    start.

Arguments:

    ServiceKeyHandle - Optionally, supplies a handle to the driver service node in the
        registry that controls this device instance.  If this argument is not specified,
        then ServiceKeyName is used to specify the service entry.

    ServiceKeyName - Optionally supplies the name of the service entry that controls
        the device instance. This must be specified if ServiceKeyHandle isn't given.

Returns:

    None.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    BOOLEAN closeHandle = FALSE, deletePdo;
    HANDLE handle, serviceEnumHandle, controlHandle, devInstHandle;
    HANDLE sysEnumHandle = NULL;
    ULONG deviceFlags, count, newCount, i, j;
    UNICODE_STRING unicodeValueName, deviceInstanceName;
    WCHAR unicodeBuffer[20];

    PAGED_CODE();

    //
    // Open registry ServiceKeyName\Enum branch
    //

    if (!ARGUMENT_PRESENT(ServiceHandle)) {
        status = PipOpenServiceEnumKeys(ServiceName,
                                        KEY_READ,
                                        &ServiceHandle,
                                        &serviceEnumHandle,
                                        FALSE
                                        );
        closeHandle = TRUE;
    } else {
        PiWstrToUnicodeString(&unicodeValueName, REGSTR_KEY_ENUM);
        status = IopOpenRegistryKeyEx( &serviceEnumHandle,
                                       ServiceHandle,
                                       &unicodeValueName,
                                       KEY_READ
                                       );
    }
    if (!NT_SUCCESS( status )) {

        //
        // No Service Enum key? no device instance.  Return FALSE.
        //

        return status;
    }

    //
    // Set "STARTFAILED" flags.  So, we won't load it again.
    //

    PiWstrToUnicodeString(&unicodeValueName, L"INITSTARTFAILED");
    deviceFlags = 1;
    ZwSetValueKey(
                serviceEnumHandle,
                &unicodeValueName,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                &deviceFlags,
                sizeof(deviceFlags)
                );

    //
    // Find out how many device instances listed in the ServiceName's
    // Enum key.
    //

    status = IopGetRegistryValue ( serviceEnumHandle,
                                   REGSTR_VALUE_COUNT,
                                   &keyValueInformation
                                   );
    count = 0;
    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {

            count = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }
    if (count == 0) {
        ZwClose(serviceEnumHandle);
        if (closeHandle) {
            ZwClose(ServiceHandle);
        }
        return status;
    }

    //
    // Open HTREE\ROOT\0 key so later we can remove device instance key
    // from its AttachedComponents value name.
    //

    status = IopOpenRegistryKeyEx( &sysEnumHandle,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_ALL_ACCESS
                                   );

    //
    // Walk through each registered device instance to mark its Problem and
    // StatusFlags as fail to start and reset its ActiveService
    //

    newCount = count;
    for (i = 0; i < count; i++) {
        deletePdo = FALSE;
        status = PipServiceInstanceToDeviceInstance (
                     ServiceHandle,
                     ServiceName,
                     i,
                     &deviceInstanceName,
                     &handle,
                     KEY_ALL_ACCESS
                     );

        if (NT_SUCCESS(status)) {

            PDEVICE_OBJECT deviceObject;
            PDEVICE_NODE deviceNode;

            //
            // If the device instance is a detected device reported during driver's
            // DriverEntry we need to clean it up.
            //

            deviceObject = IopDeviceObjectFromDeviceInstance(&deviceInstanceName);
            if (deviceObject) {
                deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
                if (deviceNode) {

                    IopReleaseDeviceResources(deviceNode, TRUE);

                    if ((deviceNode->Flags & DNF_MADEUP) &&
                        ((deviceNode->State == DeviceNodeStarted) ||
                        (deviceNode->State == DeviceNodeStartPostWork))) {

                        //
                        // Now mark this one deleted.
                        //
                        PipSetDevNodeState(deviceNode, DeviceNodeRemoved, NULL);

                        PipSetDevNodeProblem(deviceNode, CM_PROB_DEVICE_NOT_THERE);

                        deletePdo = TRUE;
                    }
                }
                ObDereferenceObject(deviceObject);  // added via IopDeviceObjectFromDeviceInstance
            }

            PiLockPnpRegistry(FALSE);

            PiWstrToUnicodeString(&unicodeValueName, REGSTR_KEY_CONTROL);
            controlHandle = NULL;
            status = IopOpenRegistryKeyEx( &controlHandle,
                                           handle,
                                           &unicodeValueName,
                                           KEY_ALL_ACCESS
                                           );
            if (NT_SUCCESS(status)) {

                status = IopGetRegistryValue(controlHandle,
                                             REGSTR_VALUE_NEWLY_CREATED,
                                             &keyValueInformation);
                if (NT_SUCCESS(status)) {
                    ExFreePool(keyValueInformation);
                }
                if ((status != STATUS_OBJECT_NAME_NOT_FOUND) &&
                    (status != STATUS_OBJECT_PATH_NOT_FOUND)) {

                    //
                    // Remove the instance value name from service enum key
                    //

                    PiUlongToUnicodeString(&unicodeValueName, unicodeBuffer, 20, i);
                    status = ZwDeleteValueKey (serviceEnumHandle, &unicodeValueName);
                    if (NT_SUCCESS(status)) {

                        //
                        // If we can successfaully remove the instance value entry
                        // from service enum key, we then remove the device instance key
                        // Otherwise, we go thru normal path to mark driver loading failed
                        // in the device instance key.
                        //

                        newCount--;

                        ZwDeleteKey(controlHandle);
                        ZwDeleteKey(handle);


                        //
                        // We also want to delete the ROOT\LEGACY_<driver> key
                        //

                        if (sysEnumHandle) {
                            deviceInstanceName.Length -= 5 * sizeof(WCHAR);
                            deviceInstanceName.Buffer[deviceInstanceName.Length / sizeof(WCHAR)] =
                                                 UNICODE_NULL;
                            status = IopOpenRegistryKeyEx( &devInstHandle,
                                                           sysEnumHandle,
                                                           &deviceInstanceName,
                                                           KEY_ALL_ACCESS
                                                           );
                            deviceInstanceName.Buffer[deviceInstanceName.Length / sizeof(WCHAR)] =
                                                 OBJ_NAME_PATH_SEPARATOR;
                            deviceInstanceName.Length += 5 * sizeof(WCHAR);
                            if (NT_SUCCESS(status)) {
                                ZwDeleteKey(devInstHandle);
                                ZwClose(devInstHandle);
                            }
                        }

                        //
                        // If there is a PDO for this device, remove it
                        //

                        if (deletePdo) {
                            IoDeleteDevice(deviceObject);
                        }

                        ZwClose(controlHandle);
                        ZwClose(handle);
                        IopCleanupDeviceRegistryValues(&deviceInstanceName);

                        ExFreePool(deviceInstanceName.Buffer);
                        PiUnlockPnpRegistry();
                        continue;
                    }
                }
            }

            //
            // Reset Control\ActiveService value name.
            //

            if (controlHandle) {
                PiWstrToUnicodeString(&unicodeValueName, REGSTR_VAL_ACTIVESERVICE);
                ZwDeleteValueKey(controlHandle, &unicodeValueName);
                ZwClose(controlHandle);
            }

            ZwClose(handle);
            ExFreePool(deviceInstanceName.Buffer);

            PiUnlockPnpRegistry();
        }
    }

    //
    // If some instance value entry is deleted, we need to update the count of instance
    // value entries and rearrange the instance value entries under service enum key.
    //

    if (newCount != count) {

        PiLockPnpRegistry(FALSE);

        if (newCount != 0) {
            j = 0;
            i = 0;
            while (i < count) {
                PiUlongToUnicodeString(&unicodeValueName, unicodeBuffer, 20, i);
                status = IopGetRegistryValue(serviceEnumHandle,
                                             unicodeValueName.Buffer,
                                             &keyValueInformation
                                             );
                if (NT_SUCCESS(status)) {
                    if (i != j) {

                        //
                        // Need to change the instance i to instance j
                        //

                        ZwDeleteValueKey(serviceEnumHandle, &unicodeValueName);

                        PiUlongToUnicodeString(&unicodeValueName, unicodeBuffer, 20, j);
                        ZwSetValueKey (serviceEnumHandle,
                                       &unicodeValueName,
                                       TITLE_INDEX_VALUE,
                                       REG_SZ,
                                       (PVOID)KEY_VALUE_DATA(keyValueInformation),
                                       keyValueInformation->DataLength
                                       );
                    }
                    ExFreePool(keyValueInformation);
                    j++;
                }
                i++;
            }
        }

        //
        // Don't forget to update the "Count=" and "NextInstance=" value entries
        //

        PiWstrToUnicodeString( &unicodeValueName, REGSTR_VALUE_COUNT);

        ZwSetValueKey(serviceEnumHandle,
                      &unicodeValueName,
                      TITLE_INDEX_VALUE,
                      REG_DWORD,
                      &newCount,
                      sizeof (newCount)
                      );
        PiWstrToUnicodeString( &unicodeValueName, REGSTR_VALUE_NEXT_INSTANCE);

        ZwSetValueKey(serviceEnumHandle,
                      &unicodeValueName,
                      TITLE_INDEX_VALUE,
                      REG_DWORD,
                      &newCount,
                      sizeof (newCount)
                      );

        PiUnlockPnpRegistry();
    }
    ZwClose(serviceEnumHandle);
    if (closeHandle) {
        ZwClose(ServiceHandle);
    }
    if (sysEnumHandle) {
        ZwClose(sysEnumHandle);
    }

    return STATUS_SUCCESS;
}

VOID
IopDisableDevice(
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine tries to ask a bus driver stopping decoding resources

Arguments:

    DeviceNode - Specifies the device to be disabled.

    Handle - specifies the device instance handle.

Returns:

    None.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // If the device has boot config, we will query-remove and remove the device to free
    // the boot config if possible.
    //
    status = IopRemoveDevice (DeviceNode->PhysicalDeviceObject, IRP_MN_QUERY_REMOVE_DEVICE);

    if (NT_SUCCESS(status)) {

        status = IopRemoveDevice (DeviceNode->PhysicalDeviceObject, IRP_MN_REMOVE_DEVICE);
        ASSERT(NT_SUCCESS(status));
        IopReleaseDeviceResources(DeviceNode, TRUE);

    } else {

        IopRemoveDevice (DeviceNode->PhysicalDeviceObject, IRP_MN_CANCEL_REMOVE_DEVICE);
    }

    if (PipDoesDevNodeHaveProblem(DeviceNode)) {

        ASSERT(PipIsDevNodeProblem(DeviceNode, CM_PROB_NOT_CONFIGURED) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_FAILED_INSTALL) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_REINSTALL));

        PipClearDevNodeProblem(DeviceNode);
    }

    PipSetDevNodeProblem(DeviceNode, CM_PROB_DISABLED);
}

BOOLEAN
IopIsAnyDeviceInstanceEnabled(
    IN PUNICODE_STRING ServiceKeyName,
    IN HANDLE ServiceHandle OPTIONAL,
    IN BOOLEAN LegacyIncluded
    )

/*++

Routine Description:

    This routine checks if any of the devices instances is turned on for the 
    specified service. This routine is used for Pnp Driver only and is temporary 
    function to support SUR.

Arguments:

    ServiceKeyName - Specifies the service key unicode name

    ServiceHandle - Optionally supplies a handle to the service key to be 
        checked.

    LegacyIncluded - TRUE, a legacy device instance key is counted as a device 
        instance.
                     FALSE, a legacy device instance key is not counted.

Returns:

    A BOOLEAN value.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    HANDLE serviceEnumHandle, handle, controlHandle;
    ULONG i, count, legacy;
    UNICODE_STRING unicodeName, instancePath;
    BOOLEAN enabled, closeHandle, instanceEnabled;

    PAGED_CODE();

    //
    // Initialize for proper cleanup.
    //
    closeHandle = FALSE;

    //
    // Initialize for all instances disabled.
    //
    enabled = FALSE;

    //
    // Open registry ServiceKeyName\Enum branch
    //
    if (!ARGUMENT_PRESENT(ServiceHandle)) {

        status = PipOpenServiceEnumKeys(ServiceKeyName,
                                        KEY_READ,
                                        &ServiceHandle,
                                        &serviceEnumHandle,
                                        FALSE
                                        );
        if (NT_SUCCESS(status)) {

            closeHandle = TRUE;
        }

    } else {

        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_ENUM);
        status = IopOpenRegistryKeyEx(&serviceEnumHandle,
                                      ServiceHandle,
                                      &unicodeName,
                                      KEY_READ
                                      );
    }
    if (!NT_SUCCESS(status)) {

        //
        // No Service Enum key? no device instance.  Return FALSE.
        //
        goto exit;
    }

    //
    // Find out how many device instances listed in the ServiceName's
    // Enum key.
    //
    count = 0;
    status = IopGetRegistryValue(serviceEnumHandle,
                                 REGSTR_VALUE_COUNT,
                                 &keyValueInformation
                                 );
    if (NT_SUCCESS(status)) {

        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {

            count = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }

        ExFreePool(keyValueInformation);
    }
    ZwClose(serviceEnumHandle);

    if (count == 0) {

        goto exit;
    }

    //
    // Walk through each registered device instance to check if it is enabled.
    //
    for (i = 0; i < count; i++) {

        //
        // Get device instance handle.  If it fails, we will skip this device
        // instance.
        //
        status = PipServiceInstanceToDeviceInstance(ServiceHandle,
                                                    NULL,
                                                    i,
                                                    &instancePath,
                                                    &handle,
                                                    KEY_ALL_ACCESS
                                                    );
        if (!NT_SUCCESS(status)) {

            continue;
        }

        instanceEnabled = IopIsDeviceInstanceEnabled(NULL, &instancePath, TRUE);
        ExFreePool(instancePath.Buffer);

        if (instanceEnabled) {

            legacy = 0;
            if (LegacyIncluded == FALSE) {

                //
                // Get the legacy count.
                //
                status = IopGetRegistryValue(handle,
                                             REGSTR_VALUE_LEGACY,
                                             &keyValueInformation
                                             );
                if (NT_SUCCESS(status)) {

                    if (    keyValueInformation->Type == REG_DWORD &&
                            keyValueInformation->DataLength == sizeof(ULONG)) {

                        legacy = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                    }

                    ExFreePool(keyValueInformation);
                }
            }
            if (legacy == 0) {

                //
                // Mark that the driver has at least one device instance to work 
                // with.
                //
                PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
                status = IopCreateRegistryKeyEx(&controlHandle,
                                                handle,
                                                &unicodeName,
                                                KEY_ALL_ACCESS,
                                                REG_OPTION_VOLATILE,
                                                NULL
                                                );
                if (NT_SUCCESS(status)) {

                    PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_ACTIVESERVICE);
                    ZwSetValueKey(controlHandle,
                                  &unicodeName,
                                  TITLE_INDEX_VALUE,
                                  REG_SZ,
                                  ServiceKeyName->Buffer,
                                  ServiceKeyName->Length + sizeof(UNICODE_NULL)
                                  );

                    ZwClose(controlHandle);
                }

                //
                // At least one instance is enabled.
                //
                enabled = TRUE;
            }
        }

        ZwClose(handle);
    }

exit:

    if (closeHandle) {

        ZwClose(ServiceHandle);
    }

    return enabled;
}

BOOLEAN
IopIsDeviceInstanceEnabled(
    IN HANDLE DeviceInstanceHandle      OPTIONAL,
    IN PUNICODE_STRING DeviceInstance,
    IN BOOLEAN Disable
    )

/*++

Routine Description:

    This routine checks if the specified devices instances is enabled.

Arguments:

    DeviceInstanceHandle - Optionally supplies a handle to the device instance
        key to be checked.

    DeviceInstance - Specifies the device instance key unicode name.  Caller
        must at least specified DeviceInstanceHandle or DeviceInstance.

    Disable - If this flag is set, and the device should be disabled
        but is currently disabled, then the device is disabled.

Returns:

    A BOOLEAN value.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    HANDLE handle, controlHandle;
    ULONG deviceFlags, disableCount;
    BOOLEAN enabled, closeHandle;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    //
    // Initialize for proper cleanup.
    //
    deviceObject = NULL;
    closeHandle = FALSE;

    //
    // Assume device is enabled.
    //
    enabled = TRUE;

    //
    // First check if the device node is already disabled.
    //
    deviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);
    deviceNode = PP_DO_TO_DN(deviceObject);
    if (deviceNode) {

        if (    PipIsDevNodeProblem(deviceNode, CM_PROB_DISABLED) || 
                PipIsDevNodeProblem(deviceNode, CM_PROB_HARDWARE_DISABLED)) {

            enabled = FALSE;
            goto exit;
        }
    }

    //
    // Open the device instance key if not specified.
    //
    if (!ARGUMENT_PRESENT(DeviceInstanceHandle)) {

        status = IopOpenRegistryKeyEx( 
                    &handle,
                    NULL,
                    &CmRegistryMachineSystemCurrentControlSetEnumName,
                    KEY_READ);
        if (NT_SUCCESS(status)) {

            status = IopOpenRegistryKeyEx( 
                        &DeviceInstanceHandle,
                        handle,
                        DeviceInstance,
                        KEY_READ);

            ZwClose(handle);
        }

        //
        // If we cannot open the device instance key
        //
        if (!NT_SUCCESS(status)) {

            enabled = FALSE;
            goto exit;
        }

        //
        // Remember to close the key since we opened it.
        //
        closeHandle = TRUE;
    }

    //
    // First check if the device has been disabled by the global CONFIGFLAG.
    //
    deviceFlags = 0;
    status = IopGetRegistryValue(DeviceInstanceHandle,
                                 REGSTR_VALUE_CONFIG_FLAGS,
                                 &keyValueInformation);
    if (NT_SUCCESS(status)) {

        if (    keyValueInformation->Type == REG_DWORD &&
                keyValueInformation->DataLength == sizeof(ULONG)) {

            deviceFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }

        ExFreePool(keyValueInformation);
    }

    if (deviceFlags & CONFIGFLAG_DISABLED) {

        deviceFlags = CSCONFIGFLAG_DISABLED;
    } else {

        //
        // Get the configflags for this device in the current profile.
        //
        IopGetDeviceInstanceCsConfigFlags(DeviceInstance, &deviceFlags);
    }

    //
    // Determine if the device should be disabled based on flags.
    //
    if (    (deviceFlags & CSCONFIGFLAG_DISABLED) ||
            (deviceFlags & CSCONFIGFLAG_DO_NOT_CREATE) ||
            (deviceFlags & CSCONFIGFLAG_DO_NOT_START)) {

        enabled = FALSE;
    }

    if (enabled) {

        //
        // Get the disable count on this device.
        //
        disableCount = 0;
        PiWstrToUnicodeString(&unicodeString, REGSTR_KEY_CONTROL);
        status = IopOpenRegistryKeyEx(&controlHandle,
                                      DeviceInstanceHandle,
                                      &unicodeString,
                                      KEY_READ
                                      );
        if (NT_SUCCESS(status)) {

            status = IopGetRegistryValue(
                        controlHandle, 
                        REGSTR_VALUE_DISABLECOUNT, 
                        &keyValueInformation);
            if (NT_SUCCESS(status)) {

                if (    keyValueInformation->Type == REG_DWORD &&
                        keyValueInformation->DataLength == sizeof(ULONG)) {

                    disableCount = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                }

                ExFreePool(keyValueInformation);
            }

            ZwClose(controlHandle);
        }

        //
        // Device should be disabled if there is a non-zero DisableCount on it.
        //
        if (disableCount) {

            enabled = FALSE;
        }

    }

    if (enabled == FALSE) {

        //
        // Device should be disabled. If there is a devnode, disable if 
        // specified.
        //
        if (Disable && deviceNode) {

            IopDisableDevice(deviceNode);
        }
    }

exit:

    //
    // Cleanup.
    //
    if (deviceObject) {

        ObDereferenceObject(deviceObject);
    }
    if (closeHandle) {

        ZwClose(DeviceInstanceHandle);
    }

    return enabled;
}

ULONG
IopDetermineResourceListSize(
    IN PCM_RESOURCE_LIST ResourceList
    )

/*++

Routine Description:

    This routine determines size of the passed in ResourceList
    structure.

Arguments:

    Configuration1 - Supplies a pointer to the resource list.

Return Value:

    size of the resource list structure.

--*/

{
    ULONG totalSize, listSize, descriptorSize, i, j;
    PCM_FULL_RESOURCE_DESCRIPTOR fullResourceDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;

    if (!ResourceList) {
        totalSize = 0;
    } else {
        totalSize = FIELD_OFFSET(CM_RESOURCE_LIST, List);
        fullResourceDesc = &ResourceList->List[0];
        for (i = 0; i < ResourceList->Count; i++) {
            listSize = FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                    PartialResourceList) +
                       FIELD_OFFSET(CM_PARTIAL_RESOURCE_LIST,
                                    PartialDescriptors);
            partialDescriptor = &fullResourceDesc->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < fullResourceDesc->PartialResourceList.Count; j++) {
                descriptorSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                if (partialDescriptor->Type == CmResourceTypeDeviceSpecific) {
                    descriptorSize += partialDescriptor->u.DeviceSpecificData.DataSize;
                }
                listSize += descriptorSize;
                partialDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                                        ((PUCHAR)partialDescriptor + descriptorSize);
            }
            totalSize += listSize;
            fullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                      ((PUCHAR)fullResourceDesc + listSize);
        }
    }
    return totalSize;
}

VOID
PpInitializeDeviceReferenceTable(
    VOID
    )

/*++

Routine Description:

    This routine initializes data structures associated with the device
    reference table.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KeInitializeGuardedMutex(&PpDeviceReferenceTableLock);
    RtlInitializeGenericTable(  &PpDeviceReferenceTable,
                                PiCompareInstancePath,
                                PiAllocateGenericTableEntry,
                                PiFreeGenericTableEntry,
                                NULL);
}

RTL_GENERIC_COMPARE_RESULTS
NTAPI
PiCompareInstancePath(
    IN  PRTL_GENERIC_TABLE          Table,
    IN  PVOID                       FirstStruct,
    IN  PVOID                       SecondStruct
    )

/*++

Routine Description:

    This routine is the callback for the generic table routines.

Arguments:

    Table       - Table for which this is invoked.

    FirstStruct - An element in the table to compare.

    SecondStruct - Another element in the table to compare.

Return Value:

    RTL_GENERIC_COMPARE_RESULTS.

--*/

{
    PUNICODE_STRING lhs = ((PDEVICE_REFERENCE)FirstStruct)->DeviceInstance;
    PUNICODE_STRING rhs = ((PDEVICE_REFERENCE)SecondStruct)->DeviceInstance;
    LONG            result;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Table);

    result = RtlCompareUnicodeString(lhs, rhs, TRUE);
    if (result < 0) {

        return GenericLessThan;
    } else if (result > 0) {

        return GenericGreaterThan;
    }
    return GenericEqual;
}

PVOID
NTAPI
PiAllocateGenericTableEntry(
    IN  PRTL_GENERIC_TABLE          Table,
    IN  CLONG                       ByteSize
    )

/*++

Routine Description:

    This routine is the callback for allocation for entries in the generic table.

Arguments:

    Table       - Table for which this is invoked.

    ByteSize    - Amount of memory to allocate.

Return Value:

    Pointer to allocated memory if successful, else NULL.

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER (Table);

    return ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, ByteSize);
}

VOID
NTAPI
PiFreeGenericTableEntry(
    IN  PRTL_GENERIC_TABLE          Table,
    IN  PVOID                       Buffer
    )

/*++

Routine Description:

    This routine is the callback for releasing memory for entries in the generic
    table.

Arguments:

    Table       - Table for which this is invoked.

    Buffer      - Buffer to free.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER (Table);

    ExFreePool(Buffer);
}

NTSTATUS
IopMapDeviceObjectToDeviceInstance(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PUNICODE_STRING  DeviceInstance
    )
/*++

Routine Description:

    This routine adds a reference for the specified device to the
    PpDeviceReferenceTable lookup table.

    Note, caller must own the PpRegistryDeviceResource before calling the
    function.

Arguments:
        
    DeviceObject - supplies a pointer to a physical device object.

    DeviceInstance - supplies a UNICODE_STRING to specify the device instance path.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS    status;
    HANDLE      hEnum, hInstance, hControl;
    UNICODE_STRING unicodeKeyName;
    DEVICE_REFERENCE deviceReference;
#if DBG
    PDEVICE_OBJECT oldDeviceObject;
#endif

    PAGED_CODE();        

#if DBG
    oldDeviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);
    ASSERT(!oldDeviceObject);
    if (oldDeviceObject) {

        ObDereferenceObject(oldDeviceObject);
    }
#endif

    deviceReference.DeviceObject    = DeviceObject;
    deviceReference.DeviceInstance  = DeviceInstance;
    KeAcquireGuardedMutex(&PpDeviceReferenceTableLock);
    if (RtlInsertElementGenericTable(&PpDeviceReferenceTable,
                                     (PVOID)&deviceReference,
                                     (CLONG)sizeof(DEVICE_REFERENCE),
                                     NULL)) {
        status = STATUS_SUCCESS;
    } else {

        status = STATUS_UNSUCCESSFUL;
    }
    KeReleaseGuardedMutex(&PpDeviceReferenceTableLock);

    if (NT_SUCCESS(status)) {
        //
        // Create the volatile Control subkey for this device instance,
        // since user-mode depends on it to be present for non-phantom
        // devices.
        //
        // NTRAID #174944-2000/08/30-jamesca:
        // Remove dependence on the presence of volatile Control subkey
        // for present devices.
        //
        status = IopOpenRegistryKeyEx(&hEnum,
                                      NULL,
                                      &CmRegistryMachineSystemCurrentControlSetEnumName,
                                      KEY_READ);
        if (NT_SUCCESS(status)) {
            status = IopOpenRegistryKeyEx(&hInstance,
                                          hEnum,
                                          DeviceInstance,
                                          KEY_ALL_ACCESS);
            if (NT_SUCCESS(status)) {
                PiWstrToUnicodeString(&unicodeKeyName, REGSTR_KEY_CONTROL);
                status = IopCreateRegistryKeyEx(&hControl,
                                                hInstance,
                                                &unicodeKeyName,
                                                KEY_ALL_ACCESS,
                                                REG_OPTION_VOLATILE,
                                                NULL);
                if (NT_SUCCESS(status)) {
                    ZwClose(hControl);
                }
                ZwClose(hInstance);
            }
            ZwClose(hEnum);
        }

        //
        // The attempt to create the volatile Control subkey should always
        // succeed, but just in case it didn't, make sure to always return
        // STATUS_SUCCESS when the device reference is successfully added to
        // the table.
        //
        ASSERT(NT_SUCCESS(status));
        status = STATUS_SUCCESS;
    }

    return status;
}

PDEVICE_OBJECT
IopDeviceObjectFromDeviceInstance(
    IN PUNICODE_STRING  DeviceInstance
    )

/*++

Routine Description:

    This routine receives a DeviceInstance path (or DeviceInstance handle) and
    returns a reference to a bus device object for the DeviceInstance.

    Note, caller must owner the PpRegistryDeviceResource before calling the function,

Arguments:

    DeviceInstance - supplies a UNICODE_STRING to specify the device instance path.

Returns:

    A reference to the desired bus device object.

--*/

{
    DEVICE_REFERENCE    key;
    PDEVICE_REFERENCE   deviceReference;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_NODE        deviceNode;

    PAGED_CODE();
    //
    // Look-up the DO in our table.
    //
    deviceObject        = NULL;
    key.DeviceObject    = NULL;
    key.DeviceInstance  = DeviceInstance;
    KeAcquireGuardedMutex(&PpDeviceReferenceTableLock);

    deviceReference = RtlLookupElementGenericTable(&PpDeviceReferenceTable, (PVOID)&key);
    if (deviceReference) {

        deviceObject = deviceReference->DeviceObject;
        ASSERT(deviceObject);
        if (deviceObject) {

            ASSERT(deviceObject->Type == IO_TYPE_DEVICE);
            if (deviceObject->Type != IO_TYPE_DEVICE) {

                deviceObject = NULL;
            } else {

                deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
                ASSERT(deviceNode && (deviceNode->PhysicalDeviceObject == deviceObject));
                if (!deviceNode || deviceNode->PhysicalDeviceObject != deviceObject) {

                    deviceObject = NULL;
                }
            }
        }
    }
    //
    // Take a reference if we found the device object.
    //
    if (deviceObject) {

        ObReferenceObject(deviceObject);
    }

    KeReleaseGuardedMutex(&PpDeviceReferenceTableLock);

    return deviceObject;
}

NTSTATUS
IopDeviceObjectToDeviceInstance (
    IN PDEVICE_OBJECT DeviceObject,
    IN PHANDLE DeviceInstanceHandle,
    IN  ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine receives a DeviceObject pointer and returns a handle to the device
    instance path under registry System\ENUM key.

    Note, caller must owner the PpRegistryDeviceResource before calling the function,

Arguments:

    DeviceObject - supplies a pointer to a physical device object.

    DeviceInstanceHandle - Supplies a variable to receive the handle to the registry
             device instance key.

    DesiredAccess - specifies the access that is needed to this key.

Returns:

    NTSTATUS code to indicate success or failure.

--*/

{
    NTSTATUS status;
    HANDLE handle;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    status = IopOpenRegistryKeyEx( &handle,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS( status )) {
        return status;
    }

    deviceNode = (PDEVICE_NODE) DeviceObject->DeviceObjectExtension->DeviceNode;
    if (deviceNode && (deviceNode->InstancePath.Length != 0)) {
        status = IopOpenRegistryKeyEx( DeviceInstanceHandle,
                                       handle,
                                       &deviceNode->InstancePath,
                                       DesiredAccess
                                       );
    } else {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    ZwClose(handle);

    return status;
}

NTSTATUS
IopCleanupDeviceRegistryValues (
    IN PUNICODE_STRING InstancePath
    )

/*++

Routine Description:

    This routine cleans up a device instance key when the device is no
    longer present/enumerated.  If the device is registered to a Service
    the Service's enum key will also been cleaned up.

    Note the caller must lock the RegistryDeviceResource

Arguments:

    InstancePath - supplies a pointer to the name of the device instance key.

Return Value:

    status

--*/

{
    DEVICE_REFERENCE    key;
    NTSTATUS            status;
#if DBG
    PDEVICE_OBJECT      deviceObject;
#endif

    PAGED_CODE();

    //
    // Delete the mapping between this instance path and corresponding DO.
    //
    key.DeviceObject         = NULL;
    key.DeviceInstance       = InstancePath;

    KeAcquireGuardedMutex(&PpDeviceReferenceTableLock);
    RtlDeleteElementGenericTable(&PpDeviceReferenceTable, (PVOID)&key);
    KeReleaseGuardedMutex(&PpDeviceReferenceTableLock);
#if DBG
    deviceObject = IopDeviceObjectFromDeviceInstance(InstancePath);
    ASSERT(!deviceObject);
    if (deviceObject) {

        ObDereferenceObject(deviceObject);
    }
#endif

    //
    // Deregister the device from its controlling service's service enum key
    //

    status = PiDeviceRegistration( InstancePath, FALSE, NULL );

    return status;
}

NTSTATUS
IopGetDeviceResourcesFromRegistry (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ResourceType,
    IN ULONG Preference,
    OUT PVOID *Resource,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine determines the resources decoded by the device specified.
    If the device object is a madeup device, we will try to read the resources
    from registry.  Otherwise, we need to traverse the internal assigned resource
    list to compose the resource list.

Arguments:

    DeviceObject - supplies a pointer to a device object whose registry
        values are to be cleaned up.

    ResourceType - 0 for CM_RESOURCE_LIST and 1 for IO_RESOURCE_REQUIREMENTS_LIS

    Flags - specify the preference.

    Resource - Specified a variable to receive the required resources.

    Length - Specified a variable to receive the length of the resource structure.

Return Value:

    status

--*/

{
    HANDLE handle, handlex;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING unicodeName;
    PWCHAR valueName = NULL;

    PAGED_CODE();

    *Resource = NULL;
    *Length = 0;

    //
    // Open the LogConfig key of the device instance.
    //

    status = IopDeviceObjectToDeviceInstance(DeviceObject, &handlex, KEY_READ);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (ResourceType == QUERY_RESOURCE_LIST) {

        //
        // Caller is asking for CM_RESOURCE_LIST
        //

        if (Preference & REGISTRY_ALLOC_CONFIG) {

            //
            // Try alloc config first
            //

            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
            status = IopOpenRegistryKeyEx( &handle,
                                           handlex,
                                           &unicodeName,
                                           KEY_READ
                                           );
            if (NT_SUCCESS(status)) {
                status = PipReadDeviceConfiguration (handle, REGISTRY_ALLOC_CONFIG, (PCM_RESOURCE_LIST *)Resource, Length);
                ZwClose(handle);
                if (NT_SUCCESS(status)) {
                    ZwClose(handlex);
                    return status;
                }
            }
        }

        handle = NULL;
        if (Preference & REGISTRY_FORCED_CONFIG) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
            status = IopOpenRegistryKeyEx( &handle,
                                           handlex,
                                           &unicodeName,
                                           KEY_READ
                                           );
            if (NT_SUCCESS(status)) {
                status = PipReadDeviceConfiguration (handle, REGISTRY_FORCED_CONFIG, (PCM_RESOURCE_LIST *)Resource, Length);
                if (NT_SUCCESS(status)) {
                    ZwClose(handle);
                    ZwClose(handlex);
                    return status;
                }
            } else {
                ZwClose(handlex);
                return status;
            }
        }
        if (Preference & REGISTRY_BOOT_CONFIG) {

            //
            // Try alloc config first
            //

            if (handle == NULL) {
                PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
                status = IopOpenRegistryKeyEx( &handle,
                                               handlex,
                                               &unicodeName,
                                               KEY_READ
                                               );
                if (!NT_SUCCESS(status)) {
                    ZwClose(handlex);
                    return status;
                }
            }
            status = PipReadDeviceConfiguration( handle,
                                                 REGISTRY_BOOT_CONFIG,
                                                 (PCM_RESOURCE_LIST *)Resource,
                                                 Length);
        }
        if (handle) {
            ZwClose(handle);
        }
    } else {

        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
        status = IopOpenRegistryKeyEx( &handle,
                                       handlex,
                                       &unicodeName,
                                       KEY_READ
                                       );
        if (NT_SUCCESS(status)) {

            if (Preference & REGISTRY_OVERRIDE_CONFIGVECTOR) {
                valueName = REGSTR_VALUE_OVERRIDE_CONFIG_VECTOR;
            } else if (Preference & REGISTRY_BASIC_CONFIGVECTOR) {
                valueName = REGSTR_VALUE_BASIC_CONFIG_VECTOR;
            }
            if (valueName) {

                //
                // Try to read device's configuration vector
                //

                status = IopGetRegistryValue (handle,
                                              valueName,
                                              &keyValueInformation);
                if (NT_SUCCESS(status)) {

                    //
                    // Try to read what caller wants.
                    //

                    if ((keyValueInformation->Type == REG_RESOURCE_REQUIREMENTS_LIST) &&
                        (keyValueInformation->DataLength != 0)) {

                        *Resource = ExAllocatePool(PagedPool,
                                                   keyValueInformation->DataLength);
                        if (*Resource) {
                            PIO_RESOURCE_REQUIREMENTS_LIST ioResource;

                            *Length = keyValueInformation->DataLength;
                            RtlCopyMemory(*Resource,
                                          KEY_VALUE_DATA(keyValueInformation),
                                          keyValueInformation->DataLength);

                            //
                            // Process the io resource requirements list to change undefined
                            // interface type to our default type.
                            //

                            ioResource = *Resource;
                            if (ioResource->InterfaceType == InterfaceTypeUndefined) {
                                ioResource->BusNumber = 0;
                                ioResource->InterfaceType = PnpDefaultInterfaceType;
                            }
                        } else {
                            status = STATUS_INVALID_PARAMETER_2;
                        }
                    }
                    ExFreePool(keyValueInformation);
                }
            }
            ZwClose(handle);
        }
    }
    ZwClose(handlex);
    return status;
}

NTSTATUS
PipReadDeviceConfiguration (
    IN HANDLE Handle,
    IN ULONG Flags,
    OUT PCM_RESOURCE_LIST *CmResource,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine read the specified ALLOC config or ForcedConfig or Boot config.

Arguments:

    Hanle - supplies a handle to the registry key to read resources.

Return Value:

    status

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PWCHAR valueName;
    PCM_RESOURCE_LIST resourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
    ULONG j, k, size;

    PAGED_CODE();

    *CmResource = NULL;
    *Length = 0;

    switch (Flags) {
    
        case REGISTRY_ALLOC_CONFIG:
            valueName = REGSTR_VALUE_ALLOC_CONFIG;
            break;
    
        case REGISTRY_FORCED_CONFIG:
            valueName = REGSTR_VALUE_FORCED_CONFIG;
            break;
    
        case REGISTRY_BOOT_CONFIG:
            valueName = REGSTR_VALUE_BOOT_CONFIG;
            break;
    
        default:
            return STATUS_INVALID_PARAMETER_2;
    }

    //
    // Read the registry value of the desired value name
    //
    status = IopGetRegistryValue(Handle,
                                 valueName,
                                 &keyValueInformation
                                 );
    if (NT_SUCCESS(status)) {

        if (    keyValueInformation->Type == REG_RESOURCE_LIST &&
                keyValueInformation->DataLength != 0) {

            *CmResource = ExAllocatePool(PagedPool,
                                         keyValueInformation->DataLength
                                         );
            if (*CmResource) {

                *Length = keyValueInformation->DataLength;
                RtlCopyMemory(*CmResource,
                              KEY_VALUE_DATA(keyValueInformation),
                              keyValueInformation->DataLength
                              );
                //
                // Process the resource list read from Registry to change undefined
                // interface type to our default interface type.
                //
                resourceList = *CmResource;
                cmFullDesc = &resourceList->List[0];
                for (j = 0; j < resourceList->Count; j++) {

                    if (cmFullDesc->InterfaceType == InterfaceTypeUndefined) {

                        cmFullDesc->BusNumber = 0;
                        cmFullDesc->InterfaceType = PnpDefaultInterfaceType;
                    }

                    cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
                    for (k = 0; k < cmFullDesc->PartialResourceList.Count; k++) {

                        size = 0;
                        switch (cmPartDesc->Type) {
                        case CmResourceTypeDeviceSpecific:
                             size = cmPartDesc->u.DeviceSpecificData.DataSize;
                             break;
                        }
                        cmPartDesc++;
                        cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
                    }
                    cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
                }
            } else {

                status = STATUS_INSUFFICIENT_RESOURCES;
            }

        } else if (keyValueInformation->Type != REG_RESOURCE_LIST) {

            status = STATUS_UNSUCCESSFUL;
        }

        ExFreePool(keyValueInformation);
    }

    return status;
}

PIO_RESOURCE_REQUIREMENTS_LIST
IopCmResourcesToIoResources(
    IN ULONG SlotNumber,
    IN PCM_RESOURCE_LIST CmResourceList,
    IN ULONG Priority
    )

/*++

Routine Description:

    This routines converts the input CmResourceList to IO_RESOURCE_REQUIREMENTS_LIST.

Arguments:

    SlotNumber - supplies the SlotNumber the resources refer to.

    CmResourceList - the cm resource list to convert.

    Priority - specifies the priority of the logconfig

Return Value:

    returns a IO_RESOURCE_REQUIREMENTS_LISTST if succeeds.  Otherwise a NULL value is
    returned.

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST ioResReqList;
    ULONG count = 0, size, i, j;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
    PIO_RESOURCE_DESCRIPTOR ioDesc;

    PAGED_CODE();

    //
    // First determine number of descriptors required.
    //
    cmFullDesc = &CmResourceList->List[0];
    for (i = 0; i < CmResourceList->Count; i++) {
        count += cmFullDesc->PartialResourceList.Count;
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            switch (cmPartDesc->Type) {
            case CmResourceTypeDeviceSpecific:
                 size = cmPartDesc->u.DeviceSpecificData.DataSize;
                 count--;
                 break;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }

    if (count == 0) {
        return NULL;
    }

    //
    // Count the extra descriptors for InterfaceType and BusNumber information.
    //

    count += CmResourceList->Count - 1;

    //
    // Allocate heap space for IO RESOURCE REQUIREMENTS LIST
    //

    count++;           // add one for CmResourceTypeConfigData
    ioResReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)ExAllocatePool(
                       PagedPool,
                       sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                           count * sizeof(IO_RESOURCE_DESCRIPTOR)
                       );
    if (!ioResReqList) {
        return NULL;
    }

    //
    // Parse the cm resource descriptor and build its corresponding IO resource descriptor
    //

    ioResReqList->InterfaceType = CmResourceList->List[0].InterfaceType;
    ioResReqList->BusNumber = CmResourceList->List[0].BusNumber;
    ioResReqList->SlotNumber = SlotNumber;
    ioResReqList->Reserved[0] = 0;
    ioResReqList->Reserved[1] = 0;
    ioResReqList->Reserved[2] = 0;
    ioResReqList->AlternativeLists = 1;
    ioResReqList->List[0].Version = 1;
    ioResReqList->List[0].Revision = 1;
    ioResReqList->List[0].Count = count;

    //
    // Generate a CmResourceTypeConfigData descriptor
    //

    ioDesc = &ioResReqList->List[0].Descriptors[0];
    ioDesc->Option = IO_RESOURCE_PREFERRED;
    ioDesc->Type = CmResourceTypeConfigData;
    ioDesc->ShareDisposition = CmResourceShareShared;
    ioDesc->Flags = 0;
    ioDesc->Spare1 = 0;
    ioDesc->Spare2 = 0;
    ioDesc->u.ConfigData.Priority = Priority;
    ioDesc++;

    cmFullDesc = &CmResourceList->List[0];
    for (i = 0; i < CmResourceList->Count; i++) {
        if (i != 0) {

            //
            // Set up descriptor to remember the InterfaceType and BusNumber.
            //

            ioDesc->Option = IO_RESOURCE_PREFERRED;
            ioDesc->Type = CmResourceTypeReserved;
            ioDesc->ShareDisposition = CmResourceShareUndetermined;
            ioDesc->Flags = 0;
            ioDesc->Spare1 = 0;
            ioDesc->Spare2 = 0;
            if (cmFullDesc->InterfaceType == InterfaceTypeUndefined) {
                ioDesc->u.DevicePrivate.Data[0] = PnpDefaultInterfaceType;
            } else {
                ioDesc->u.DevicePrivate.Data[0] = cmFullDesc->InterfaceType;
            }
            ioDesc->u.DevicePrivate.Data[1] = cmFullDesc->BusNumber;
            ioDesc->u.DevicePrivate.Data[2] = 0;
            ioDesc++;
        }
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            ioDesc->Option = IO_RESOURCE_PREFERRED;
            ioDesc->Type = cmPartDesc->Type;
            ioDesc->ShareDisposition = cmPartDesc->ShareDisposition;
            ioDesc->Flags = cmPartDesc->Flags;
            ioDesc->Spare1 = 0;
            ioDesc->Spare2 = 0;

            size = 0;
            switch (cmPartDesc->Type) {
            case CmResourceTypePort:
                 ioDesc->u.Port.MinimumAddress = cmPartDesc->u.Port.Start;
                 ioDesc->u.Port.MaximumAddress.QuadPart = cmPartDesc->u.Port.Start.QuadPart +
                                                             cmPartDesc->u.Port.Length - 1;
                 ioDesc->u.Port.Alignment = 1;
                 ioDesc->u.Port.Length = cmPartDesc->u.Port.Length;
                 ioDesc++;
                 break;
            case CmResourceTypeInterrupt:
#if defined(_X86_)
                ioDesc->u.Interrupt.MinimumVector = ioDesc->u.Interrupt.MaximumVector =
                   cmPartDesc->u.Interrupt.Level;
#else
                 ioDesc->u.Interrupt.MinimumVector = ioDesc->u.Interrupt.MaximumVector =
                    cmPartDesc->u.Interrupt.Vector;
#endif
                 ioDesc++;
                 break;
            case CmResourceTypeMemory:
                 ioDesc->u.Memory.MinimumAddress = cmPartDesc->u.Memory.Start;
                 ioDesc->u.Memory.MaximumAddress.QuadPart = cmPartDesc->u.Memory.Start.QuadPart +
                                                               cmPartDesc->u.Memory.Length - 1;
                 ioDesc->u.Memory.Alignment = 1;
                 ioDesc->u.Memory.Length = cmPartDesc->u.Memory.Length;
                 ioDesc++;
                 break;
            case CmResourceTypeDma:
                 ioDesc->u.Dma.MinimumChannel = cmPartDesc->u.Dma.Channel;
                 ioDesc->u.Dma.MaximumChannel = cmPartDesc->u.Dma.Channel;
                 ioDesc++;
                 break;
            case CmResourceTypeDeviceSpecific:
                 size = cmPartDesc->u.DeviceSpecificData.DataSize;
                 break;
            case CmResourceTypeBusNumber:
                 ioDesc->u.BusNumber.MinBusNumber = cmPartDesc->u.BusNumber.Start;
                 ioDesc->u.BusNumber.MaxBusNumber = cmPartDesc->u.BusNumber.Start +
                                                    cmPartDesc->u.BusNumber.Length - 1;
                 ioDesc->u.BusNumber.Length = cmPartDesc->u.BusNumber.Length;
                 ioDesc++;
                 break;
            default:
                 ioDesc->u.DevicePrivate.Data[0] = cmPartDesc->u.DevicePrivate.Data[0];
                 ioDesc->u.DevicePrivate.Data[1] = cmPartDesc->u.DevicePrivate.Data[1];
                 ioDesc->u.DevicePrivate.Data[2] = cmPartDesc->u.DevicePrivate.Data[2];
                 ioDesc++;
                 break;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }
    ioResReqList->ListSize = (ULONG)((ULONG_PTR)ioDesc - (ULONG_PTR)ioResReqList);
    return ioResReqList;
}

NTSTATUS
IopFilterResourceRequirementsList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList,
    IN PCM_RESOURCE_LIST CmList,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *FilteredList,
    OUT PBOOLEAN ExactMatch
    )

/*++

Routine Description:

    This routines adjusts the input IoList based on input BootConfig.


Arguments:

    IoList - supplies the pointer to an IoResourceRequirementsList

    CmList - supplies the pointer to a BootConfig.

    FilteredList - Supplies a variable to receive the filtered resource
             requirements list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST ioList, newList;
    PIO_RESOURCE_LIST ioResourceList, newIoResourceList, selectedResourceList = NULL;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor, ioResourceDescriptorEnd;
    PIO_RESOURCE_DESCRIPTOR newIoResourceDescriptor, configDataDescriptor;
    LONG ioResourceDescriptorCount = 0;
    USHORT version;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptor;
    ULONG cmDescriptorCount = 0;
    ULONG size, i, j, oldCount, phase;
    LONG k, alternativeLists;
    BOOLEAN exactMatch;

    PAGED_CODE();

    *FilteredList = NULL;
    *ExactMatch = FALSE;

    //
    // Make sure there is some resource requirements to be filtered.
    // If no, we will convert CmList/BootConfig to an IoResourceRequirementsList
    //

    if (IoList == NULL || IoList->AlternativeLists == 0) {
        if (CmList && CmList->Count != 0) {
            *FilteredList = IopCmResourcesToIoResources (0, CmList, LCPRI_BOOTCONFIG);
        }
        return STATUS_SUCCESS;
    }

    //
    // Make a copy of the Io Resource Requirements List
    //

    ioList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, IoList->ListSize);
    if (ioList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(ioList, IoList, IoList->ListSize);

    //
    // If there is no BootConfig, simply return the copy of the input Io list.
    //

    if (CmList == NULL || CmList->Count == 0) {
        *FilteredList = ioList;
        return STATUS_SUCCESS;
    }

    //
    // First determine minimum number of descriptors required.
    //

    cmFullDesc = &CmList->List[0];
    for (i = 0; i < CmList->Count; i++) {
        cmDescriptorCount += cmFullDesc->PartialResourceList.Count;
        cmDescriptor = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            switch (cmDescriptor->Type) {
            case CmResourceTypeConfigData:
            case CmResourceTypeDevicePrivate:
                 cmDescriptorCount--;
                 break;
            case CmResourceTypeDeviceSpecific:
                 size = cmDescriptor->u.DeviceSpecificData.DataSize;
                 cmDescriptorCount--;
                 break;
            default:

                 //
                 // Invalid cmresource list.  Ignore it and use io resources
                 //

                 if (cmDescriptor->Type == CmResourceTypeNull ||
                     cmDescriptor->Type >= CmResourceTypeMaximum) {
                     cmDescriptorCount--;
                 }
            }
            cmDescriptor++;
            cmDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDescriptor;
    }

    if (cmDescriptorCount == 0) {
        *FilteredList = ioList;
        return STATUS_SUCCESS;
    }

    //
    // cmDescriptorCount is the number of BootConfig Descriptors needs.
    //
    // For each IO list Alternative ...
    //

    ioResourceList = ioList->List;
    k = ioList->AlternativeLists;
    while (--k >= 0) {
        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;
        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
            ioResourceDescriptor->Spare1 = 0;
            ioResourceDescriptor++;
        }
        ioResourceList = (PIO_RESOURCE_LIST) ioResourceDescriptorEnd;
    }

    ioResourceList = ioList->List;
    k = alternativeLists = ioList->AlternativeLists;
    while (--k >= 0) {
        version = ioResourceList->Version;
        if (version == 0xffff) {  // Convert bogus version to valid number
            version = 1;
        }

        //
        // We use Version field to store number of BootConfig found.
        // Count field to store new number of descriptor in the alternative list.
        //

        ioResourceList->Version = 0;
        oldCount = ioResourceList->Count;

        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;

        if (ioResourceDescriptor == ioResourceDescriptorEnd) {

            //
            // An alternative list with zero descriptor count
            //

            ioResourceList->Version = 0xffff;  // Mark it as invalid
            ioList->AlternativeLists--;
            continue;
        }

        exactMatch = TRUE;

        //
        // For each Cm Resource descriptor ... except DevicePrivate and
        // DeviceSpecific...
        //

        cmFullDesc = &CmList->List[0];
        for (i = 0; i < CmList->Count; i++) {
            cmDescriptor = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
                size = 0;
                switch (cmDescriptor->Type) {
                case CmResourceTypeDevicePrivate:
                     break;
                case CmResourceTypeDeviceSpecific:
                     size = cmDescriptor->u.DeviceSpecificData.DataSize;
                     break;
                default:
                    if (cmDescriptor->Type == CmResourceTypeNull ||
                        cmDescriptor->Type >= CmResourceTypeMaximum) {
                        break;
                    }

                    //
                    // Check CmDescriptor against current Io Alternative list
                    //

                    for (phase = 0; phase < 2; phase++) {
                        ioResourceDescriptor = ioResourceList->Descriptors;
                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                            if ((ioResourceDescriptor->Type == cmDescriptor->Type) &&
                                (ioResourceDescriptor->Spare1 == 0)) {
                                ULONGLONG min1, max1, min2, max2;
                                ULONG len1 = 1, len2 = 1, align1, align2;
                                UCHAR share1, share2;

                                share2 = ioResourceDescriptor->ShareDisposition;
                                share1 = cmDescriptor->ShareDisposition;
                                if ((share1 == CmResourceShareUndetermined) ||
                                    (share1 > CmResourceShareShared)) {
                                    share1 = share2;
                                }
                                if ((share2 == CmResourceShareUndetermined) ||
                                    (share2 > CmResourceShareShared)) {
                                    share2 = share1;
                                }
                                align1 = align2 = 1;

                                switch (cmDescriptor->Type) {
                                case CmResourceTypePort:
                                case CmResourceTypeMemory:
                                    min1 = cmDescriptor->u.Port.Start.QuadPart;
                                    max1 = cmDescriptor->u.Port.Start.QuadPart + cmDescriptor->u.Port.Length - 1;
                                    len1 = cmDescriptor->u.Port.Length;
                                    min2 = ioResourceDescriptor->u.Port.MinimumAddress.QuadPart;
                                    max2 = ioResourceDescriptor->u.Port.MaximumAddress.QuadPart;
                                    len2 = ioResourceDescriptor->u.Port.Length;
                                    align2 = ioResourceDescriptor->u.Port.Alignment;
                                    break;
                                case CmResourceTypeInterrupt:
                                    max1 = min1 = cmDescriptor->u.Interrupt.Vector;
                                    min2 = ioResourceDescriptor->u.Interrupt.MinimumVector;
                                    max2 = ioResourceDescriptor->u.Interrupt.MaximumVector;
                                    break;
                                case CmResourceTypeDma:
                                    min1 = max1 =cmDescriptor->u.Dma.Channel;
                                    min2 = ioResourceDescriptor->u.Dma.MinimumChannel;
                                    max2 = ioResourceDescriptor->u.Dma.MaximumChannel;
                                    break;
                                case CmResourceTypeBusNumber:
                                    min1 = cmDescriptor->u.BusNumber.Start;
                                    max1 = cmDescriptor->u.BusNumber.Start + cmDescriptor->u.BusNumber.Length - 1;
                                    len1 = cmDescriptor->u.BusNumber.Length;
                                    min2 = ioResourceDescriptor->u.BusNumber.MinBusNumber;
                                    max2 = ioResourceDescriptor->u.BusNumber.MaxBusNumber;
                                    len2 = ioResourceDescriptor->u.BusNumber.Length;
                                    break;
                                default:
                                    ASSERT(0);
                                    max1 = max2 = min1 = min2 = 0;
                                    break;
                                }
                                if (phase == 0) {
                                    if (share1 == share2 && min2 == min1 && max2 >= max1 && len2 >= len1) {

                                        //
                                        // For phase 0 match, we want near exact match...
                                        //

                                        if (max2 != max1) {
                                            exactMatch = FALSE;
                                        }
                                        ioResourceList->Version++;
                                        ioResourceDescriptor->Spare1 = 0x80;
                                        if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                            PIO_RESOURCE_DESCRIPTOR ioDesc;

                                            ioDesc = ioResourceDescriptor;
                                            ioDesc--;
                                            while (ioDesc >= ioResourceList->Descriptors) {
                                                ioDesc->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                if (ioDesc->Option == IO_RESOURCE_ALTERNATIVE) {
                                                    ioDesc--;
                                                } else {
                                                    break;
                                                }
                                            }
                                        }
                                        ioResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
                                        ioResourceDescriptor->Flags = cmDescriptor->Flags;
                                        if (ioResourceDescriptor->Type == CmResourceTypePort ||
                                            ioResourceDescriptor->Type == CmResourceTypeMemory) {
                                            ioResourceDescriptor->u.Port.MinimumAddress.QuadPart = min1;
                                            ioResourceDescriptor->u.Port.MaximumAddress.QuadPart = min1 + len2 - 1;
                                            ioResourceDescriptor->u.Port.Alignment = 1;
                                        } else if (ioResourceDescriptor->Type == CmResourceTypeBusNumber) {
                                            ioResourceDescriptor->u.BusNumber.MinBusNumber = (ULONG)min1;
                                            ioResourceDescriptor->u.BusNumber.MaxBusNumber = (ULONG)(min1 + len2 - 1);
                                        }
                                        ioResourceDescriptor++;
                                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                                            if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                                ioResourceDescriptor->Type = CmResourceTypeNull;
                                                ioResourceDescriptor++;
                                                ioResourceList->Count--;
                                            } else {
                                                break;
                                            }
                                        }
                                        phase = 1;   // skip phase 1
                                        break;
                                    } else {
                                        ioResourceDescriptor++;
                                    }
                                } else {
                                    exactMatch = FALSE;
                                    if (share1 == share2 && min2 <= min1 && max2 >= max1 && len2 >= len1 &&
                                        (min1 & (align2 - 1)) == 0) {

                                        //
                                        // Io range covers Cm range ... Change the Io range to what is specified
                                        // in BootConfig.
                                        //
                                        //

                                        switch (cmDescriptor->Type) {
                                        case CmResourceTypePort:
                                        case CmResourceTypeMemory:
                                            ioResourceDescriptor->u.Port.MinimumAddress.QuadPart = min1;
                                            ioResourceDescriptor->u.Port.MaximumAddress.QuadPart = min1 + len2 - 1;
                                            break;
                                        case CmResourceTypeInterrupt:
                                        case CmResourceTypeDma:
                                            ioResourceDescriptor->u.Interrupt.MinimumVector = (ULONG)min1;
                                            ioResourceDescriptor->u.Interrupt.MaximumVector = (ULONG)max1;
                                            break;
                                        case CmResourceTypeBusNumber:
                                            ioResourceDescriptor->u.BusNumber.MinBusNumber = (ULONG)min1;
                                            ioResourceDescriptor->u.BusNumber.MaxBusNumber = (ULONG)(min1 + len2 - 1);
                                            break;
                                        }
                                        ioResourceList->Version++;
                                        ioResourceDescriptor->Spare1 = 0x80;
                                        ioResourceDescriptor->Flags = cmDescriptor->Flags;
                                        if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                            PIO_RESOURCE_DESCRIPTOR ioDesc;

                                            ioDesc = ioResourceDescriptor;
                                            ioDesc--;
                                            while (ioDesc >= ioResourceList->Descriptors) {
                                                ioDesc->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                if (ioDesc->Option == IO_RESOURCE_ALTERNATIVE) {
                                                    ioDesc--;
                                                } else {
                                                    break;
                                                }
                                            }
                                        }
                                        ioResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
                                        ioResourceDescriptor++;
                                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                                            if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                                ioResourceDescriptor->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                ioResourceDescriptor++;
                                            } else {
                                                break;
                                            }
                                        }
                                        break;
                                    } else {
                                        ioResourceDescriptor++;
                                    }
                                }
                            } else {
                                ioResourceDescriptor++;
                            }
                        } // Don't add any instruction after this ...
                    } // phase
                } // switch

                //
                // Move to next Cm Descriptor
                //

                cmDescriptor++;
                cmDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor + size);
            }

            //
            // Move to next Cm List
            //

            cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDescriptor;
        }

        if (ioResourceList->Version != (USHORT)cmDescriptorCount) {

            //
            // If the current alternative list does not cover all the boot config
            // descriptors, make it as invalid.
            //

            ioResourceList->Version = 0xffff;
            ioList->AlternativeLists--;
        } else {
            if ((ioResourceList->Count == cmDescriptorCount) ||
                (ioResourceList->Count == (cmDescriptorCount + 1) &&
                 ioResourceList->Descriptors[0].Type == CmResourceTypeConfigData)) {
                if (selectedResourceList) {
                    ioResourceList->Version = 0xffff;
                    ioList->AlternativeLists--;
                } else {
                    selectedResourceList = ioResourceList;
                    ioResourceDescriptorCount += ioResourceList->Count;
                    ioResourceList->Version = version;
                    if (exactMatch) {
                        *ExactMatch = TRUE;
                    }
                }
            } else {
                ioResourceDescriptorCount += ioResourceList->Count;
                ioResourceList->Version = version;
            }
        }
        ioResourceList->Count = oldCount;

        //
        // Move to next Io alternative list.
        //

        ioResourceList = (PIO_RESOURCE_LIST) ioResourceDescriptorEnd;
    }

    //
    // If there is not any valid alternative, convert CmList to Io list.
    //

    if (ioList->AlternativeLists == 0) {
         *FilteredList = IopCmResourcesToIoResources (0, CmList, LCPRI_BOOTCONFIG);
        ExFreePool(ioList);
        return STATUS_SUCCESS;
    }

    //
    // we have finished filtering the resource requirements list.  Now allocate memory
    // and rebuild a new list.
    //

    size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
               sizeof(IO_RESOURCE_LIST) * (ioList->AlternativeLists - 1) +
               sizeof(IO_RESOURCE_DESCRIPTOR) * (ioResourceDescriptorCount);
    newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, size);
    if (newList == NULL) {
        ExFreePool(ioList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Walk through the io resource requirements list and pick up any valid descriptor.
    //

    newList->ListSize = size;
    newList->InterfaceType = CmList->List->InterfaceType;
    newList->BusNumber = CmList->List->BusNumber;
    newList->SlotNumber = ioList->SlotNumber;
    if (ioList->AlternativeLists > 1) {
        *ExactMatch = FALSE;
    }
    newList->AlternativeLists = ioList->AlternativeLists;
    ioResourceList = ioList->List;
    newIoResourceList = newList->List;
    while (--alternativeLists >= 0) {
        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;
        if (ioResourceList->Version == 0xffff) {
            ioResourceList = (PIO_RESOURCE_LIST)ioResourceDescriptorEnd;
            continue;
        }
        newIoResourceList->Version = ioResourceList->Version;
        newIoResourceList->Revision = ioResourceList->Revision;

        newIoResourceDescriptor = newIoResourceList->Descriptors;
        if (ioResourceDescriptor->Type != CmResourceTypeConfigData) {
            newIoResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
            newIoResourceDescriptor->Type = CmResourceTypeConfigData;
            newIoResourceDescriptor->ShareDisposition = CmResourceShareShared;
            newIoResourceDescriptor->Flags = 0;
            newIoResourceDescriptor->Spare1 = 0;
            newIoResourceDescriptor->Spare2 = 0;
            newIoResourceDescriptor->u.ConfigData.Priority = LCPRI_BOOTCONFIG;
            configDataDescriptor = newIoResourceDescriptor;
            newIoResourceDescriptor++;
        } else {
            newList->ListSize -= sizeof(IO_RESOURCE_DESCRIPTOR);
            configDataDescriptor = newIoResourceDescriptor;
        }

        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
            if (ioResourceDescriptor->Type != CmResourceTypeNull) {
                *newIoResourceDescriptor = *ioResourceDescriptor;
                newIoResourceDescriptor++;
            }
            ioResourceDescriptor++;
        }
        newIoResourceList->Count = (ULONG)(newIoResourceDescriptor - newIoResourceList->Descriptors);

        //if (newIoResourceList->Count == (cmDescriptorCount + 1)) {
        configDataDescriptor->u.ConfigData.Priority =  LCPRI_BOOTCONFIG;
        //}

        //
        // Move to next Io alternative list.
        //

        newIoResourceList = (PIO_RESOURCE_LIST) newIoResourceDescriptor;
        ioResourceList = (PIO_RESOURCE_LIST) ioResourceDescriptorEnd;
    }
    ASSERT((PUCHAR)newIoResourceList == ((PUCHAR)newList + newList->ListSize));

    *FilteredList = newList;
    ExFreePool(ioList);
    return STATUS_SUCCESS;
}

NTSTATUS
IopMergeFilteredResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList1,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList2,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *MergedList
    )

/*++

Routine Description:

    This routines merges two IoLists into one.


Arguments:

    IoList1 - supplies the pointer to the first IoResourceRequirementsList

    IoList2 - supplies the pointer to the second IoResourceRequirementsList

    MergedList - Supplies a variable to receive the merged resource
             requirements list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_RESOURCE_REQUIREMENTS_LIST ioList, newList;
    ULONG size;
    PUCHAR p;

    PAGED_CODE();

    *MergedList = NULL;

    //
    // First handle the easy cases that both IO Lists are empty or any one of
    // them is empty.
    //

    if ((IoList1 == NULL || IoList1->AlternativeLists == 0) &&
        (IoList2 == NULL || IoList2->AlternativeLists == 0)) {
        return status;
    }
    ioList = NULL;
    if (IoList1 == NULL || IoList1->AlternativeLists == 0) {
        ioList = IoList2;
    } else if (IoList2 == NULL || IoList2->AlternativeLists == 0) {
        ioList = IoList1;
    }
    if (ioList) {
        newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, ioList->ListSize);
        if (newList == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory(newList, ioList, ioList->ListSize);
        *MergedList = newList;
        return status;
    }

    //
    // Do real work...
    //

    size = IoList1->ListSize + IoList2->ListSize - FIELD_OFFSET(IO_RESOURCE_REQUIREMENTS_LIST, List);
    newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(
                          PagedPool,
                          size
                          );
    if (newList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    p = (PUCHAR)newList;
    RtlCopyMemory(p, IoList1, IoList1->ListSize);
    p += IoList1->ListSize;
    RtlCopyMemory(p,
                  &IoList2->List[0],
                  size - IoList1->ListSize
                  );
    newList->ListSize = size;
    newList->AlternativeLists += IoList2->AlternativeLists;
    *MergedList = newList;
    return status;

}

NTSTATUS
IopMergeCmResourceLists (
    IN PCM_RESOURCE_LIST List1,
    IN PCM_RESOURCE_LIST List2,
    IN OUT PCM_RESOURCE_LIST *MergedList
    )

/*++

Routine Description:

    This routines merges two IoLists into one.


Arguments:

    IoList1 - supplies the pointer to the first CmResourceList

    IoList2 - supplies the pointer to the second CmResourceList

    MergedList - Supplies a variable to receive the merged resource
             list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PCM_RESOURCE_LIST cmList, newList;
    ULONG size, size1, size2;
    PUCHAR p;

    PAGED_CODE();

    *MergedList = NULL;

    //
    // First handle the easy cases that both IO Lists are empty or any one of
    // them is empty.
    //

    if ((List1 == NULL || List1->Count == 0) &&
        (List2 == NULL || List2->Count == 0)) {
        return status;
    }

    cmList = NULL;
    if (List1 == NULL || List1->Count == 0) {
        cmList = List2;
    } else if (List2 == NULL || List2->Count == 0) {
        cmList = List1;
    }
    if (cmList) {
        size =  IopDetermineResourceListSize(cmList);
        newList = (PCM_RESOURCE_LIST) ExAllocatePool(PagedPool, size);
        if (newList == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory(newList, cmList, size);
        *MergedList = newList;
        return status;
    }

    //
    // Do real work...
    //

    size1 =  IopDetermineResourceListSize(List1);
    size2 =  IopDetermineResourceListSize(List2);
    size = size1 + size2;
    newList = (PCM_RESOURCE_LIST) ExAllocatePool(
                          PagedPool,
                          size
                          );
    if (newList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    p = (PUCHAR)newList;
    RtlCopyMemory(p, List1, size1);
    p += size1;
    RtlCopyMemory(p,
                  &List2->List[0],
                  size2 - FIELD_OFFSET(CM_RESOURCE_LIST, List)
                  );
    newList->Count = List1->Count + List2->Count;
    *MergedList = newList;
    return status;

}

BOOLEAN
IopIsLegacyDriver (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine checks if the driver object specifies a legacy driver.

Arguments:

    DriverObject - supplies a pointer to the driver object to be checked.

Return Value:

    BOOLEAN

--*/

{

    PAGED_CODE();

    //
    // If AddDevice entry is not empty it is a wdm driver
    //
    if (DriverObject->DriverExtension->AddDevice) {

        return FALSE;
    }

    //
    // Else if LEGACY flag is set in the driver object, it's a legacy driver.
    //
    if (DriverObject->Flags & DRVO_LEGACY_DRIVER) {

        return TRUE;
    } else {

        return FALSE;
    }
}

VOID
IopDeleteLegacyKey(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine checks if the Legacy= value of the driver's legacy_xxx key
    is one.  If yes, it deletes the Legacy key.

Parameters:

    DriverObject - supplies a pointer to the driver object.

Return Value:

    None.  If anything fails in this routine, the legacy key stays.

--*/

{
    WCHAR buffer[MAX_DEVICE_ID_LEN], *end;
    NTSTATUS status;
    UNICODE_STRING deviceName, instanceName, unicodeName, *serviceName;
    ULONG length;
    HANDLE handle, handle1, handlex, enumHandle;
    ULONG legacy;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode, devNodex, devNodey;
    BOOLEAN deletedPDO;

    //
    // Initialize for proper cleanup.
    //
    enumHandle = NULL;
    handle1 = NULL;
    handle = NULL;

    serviceName = &DriverObject->DriverExtension->ServiceKeyName;

    PiLockPnpRegistry(FALSE);

    status = IopOpenRegistryKeyEx(&enumHandle,
                                  NULL,
                                  &CmRegistryMachineSystemCurrentControlSetEnumName,
                                  KEY_ALL_ACCESS
                                  );
    if (!NT_SUCCESS(status)) {

        goto exit;
    }

    status = PipGenerateMadeupNodeName(serviceName,
                                       &deviceName
                                       );
    if (!NT_SUCCESS(status)) {

        goto exit;
    }

    StringCchPrintfExW(buffer, 
                       sizeof(buffer) / sizeof(WCHAR), 
                       &end, 
                       NULL, 
                       0, 
                       L"%s\\%s", 
                       REGSTR_KEY_ROOTENUM, 
                       deviceName.Buffer
                       );   
    length = (ULONG)(end - buffer);

    RtlFreeUnicodeString(&deviceName);

    deviceName.MaximumLength = sizeof(buffer);
    ASSERT(length <= sizeof(buffer) - 10);
    deviceName.Length = (USHORT)(length * sizeof(WCHAR));
    deviceName.Buffer = buffer;

    RtlUpcaseUnicodeString(&deviceName, &deviceName, FALSE);

    status = IopOpenRegistryKeyEx(&handle1,
                                  enumHandle,
                                  &deviceName,
                                  KEY_ALL_ACCESS
                                  );

    if (!NT_SUCCESS(status)) {

        goto exit;
    }

    deviceName.Buffer[deviceName.Length / sizeof(WCHAR)] =
               OBJ_NAME_PATH_SEPARATOR;
    deviceName.Length += sizeof(WCHAR);
    PiUlongToInstanceKeyUnicodeString(
                            &instanceName,
                            buffer + deviceName.Length / sizeof(WCHAR),
                            sizeof(buffer) - deviceName.Length,
                            0
                            );
    deviceName.Length = (USHORT)(deviceName.Length + instanceName.Length);

    //
    // deviceName is now the full InstancePath (ROOT\LEGACY_service\0000)
    // and instancePath points to the instance ID (0000)
    //
    status = IopOpenRegistryKeyEx(&handle,
                                  handle1,
                                  &instanceName,
                                  KEY_ALL_ACCESS
                                  );
    if (!NT_SUCCESS(status)) {

        goto exit;
    }

    legacy = 1;
    status = IopGetRegistryValue(handle,
                                 REGSTR_VALUE_LEGACY,
                                 &keyValueInformation
                                 );
    if (NT_SUCCESS(status)) {

        if (    keyValueInformation->Type == REG_DWORD &&
                keyValueInformation->DataLength >= sizeof(ULONG)) {

            legacy = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }

        ExFreePool(keyValueInformation);
    }

    if (legacy == 0) {

        goto exit;
    }

    //
    // We also want to delete the madeup device node
    //
    deletedPDO = FALSE;
    deviceObject = IopDeviceObjectFromDeviceInstance(&deviceName);
    if (deviceObject) {
        
        deviceNode = PP_DO_TO_DN(deviceObject);
        if (deviceNode != NULL && (deviceNode->Flags & DNF_MADEUP)) {
    
            //
            // Now mark this one deleted.
            //
            if (!PipDoesDevNodeHaveProblem(deviceNode)) {
    
                PipSetDevNodeState(deviceNode, DeviceNodeRemoved, NULL);
                PipSetDevNodeProblem(deviceNode, CM_PROB_DEVICE_NOT_THERE);
            }
    
            IopReleaseDeviceResources(deviceNode, FALSE);

            devNodex = deviceNode;
            while (devNodex) {

                devNodey = devNodex;
                devNodex = (PDEVICE_NODE)devNodey->OverUsed2.NextResourceDeviceNode;
                devNodey->OverUsed2.NextResourceDeviceNode = NULL;
                devNodey->OverUsed1.LegacyDeviceNode = NULL;
            }   
            deviceNode->Flags &= ~DNF_MADEUP;

            IoDeleteDevice(deviceObject);
            deletedPDO = TRUE;
        }
        ObDereferenceObject(deviceObject);
    }    

    PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
    status = IopOpenRegistryKeyEx(&handlex,
                                  handle,
                                  &unicodeName,
                                  KEY_ALL_ACCESS
                                  );
    if (NT_SUCCESS(status)) {

        ZwDeleteKey(handlex);
        ZwClose(handlex);
    }

    PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
    status = IopOpenRegistryKeyEx(&handlex,
                                  handle,
                                  &unicodeName,
                                  KEY_ALL_ACCESS
                                  );
    if (NT_SUCCESS(status)) {

        ZwDeleteKey(handlex);
        ZwClose(handlex);
    }
        
    //
    // We need to call IopCleanupDeviceRegistryValue even we are going to
    // delete it.  Because, it also cleans up related value names in other
    // keys.
    //
    if (deletedPDO) {
    
        IopCleanupDeviceRegistryValues(&deviceName);
    }

    ZwDeleteKey(handle);
    ZwDeleteKey(handle1);

exit:

    PiUnlockPnpRegistry();

    if (handle) {

        ZwClose(handle);
    }
    if (handle1) {

        ZwClose(handle1);
    }

    if (enumHandle) {

        ZwClose(enumHandle);
    }

    return;
}

NTSTATUS
IopQueryAndSaveDeviceNodeCapabilities (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    Called after start to refresh Capability flags

Arguments:

    DeviceObject - supplies a pointer to a device object whose registry
        values are to be updated.

Return Value:

    status

--*/

{
    NTSTATUS status;
    DEVICE_CAPABILITIES capabilities;

    PAGED_CODE();

    ASSERT(DeviceNode != NULL);

    //
    // Open the device instance key
    //

    status = PpIrpQueryCapabilities(DeviceNode->PhysicalDeviceObject, &capabilities);
    if (!NT_SUCCESS(status)) {

        return status;
    }

    return PpSaveDeviceCapabilities(DeviceNode,&capabilities);
}

NTSTATUS
PpSaveDeviceCapabilities (
    IN PDEVICE_NODE DeviceNode,
    IN PDEVICE_CAPABILITIES Capabilities
    )

/*++

Routine Description:

    This routine updates device capabilities, must be called after a valid device instance key has been created
    Called directly from IopProcessNewDeviceNode, and indirecly via IopQueryAndSaveDeviceNodeCapabilities
    after device is started.

Arguments:

    DeviceObject - supplies a pointer to a device object whose registry
        values are to be updated.

Return Value:

    status

--*/

{
    NTSTATUS status;
    UNICODE_STRING unicodeName;
    ULONG value;
    HANDLE handle;

    PAGED_CODE();

    ASSERT(DeviceNode != NULL);
    ASSERT(Capabilities != NULL);

    //
    // Open the device instance key
    //
    status = IopDeviceObjectToDeviceInstance(DeviceNode->PhysicalDeviceObject, &handle, KEY_ALL_ACCESS);
    if (NT_SUCCESS(status)) {

        if (DeviceNode->Flags & DNF_HAS_BOOT_CONFIG) {

            Capabilities->SurpriseRemovalOK = 0;
        }
        //
        // Assert the bit fields are completely contained in a ULONG. This is a
        // public structure, so it shouldn't ever change, but paranoia is a good
        // thing...
        //
        ASSERT((FIELD_OFFSET(DEVICE_CAPABILITIES, Address) -
                FIELD_OFFSET(DEVICE_CAPABILITIES, Version) -
                FIELD_SIZE  (DEVICE_CAPABILITIES, Version)) == sizeof(ULONG));

        DeviceNode->CapabilityFlags =
            *((PULONG) (((PUCHAR) Capabilities) +
            FIELD_OFFSET(DEVICE_CAPABILITIES, Version) +
            FIELD_SIZE(DEVICE_CAPABILITIES, Version)));

        value =    (Capabilities->LockSupported)          |
                   (Capabilities->EjectSupported    << 1) |
                   (Capabilities->WarmEjectSupported<< 1) |
                   (Capabilities->Removable         << 2) |
                   (Capabilities->DockDevice        << 3) |
                   (Capabilities->UniqueID          << 4) |
                   (Capabilities->SilentInstall     << 5) |
                   (Capabilities->RawDeviceOK       << 6) |
                   (Capabilities->SurpriseRemovalOK << 7) |
                   (Capabilities->HardwareDisabled  << 8) |
                   (Capabilities->NonDynamic        << 9);

        PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_CAPABILITIES);
        ZwSetValueKey(
            handle,
            &unicodeName,
            TITLE_INDEX_VALUE,
            REG_DWORD,
            &value,
            sizeof(value));

        PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_UI_NUMBER);
        value = Capabilities->UINumber;
        if(value != (ULONG)-1) {

            ZwSetValueKey(
                handle,
                &unicodeName,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                &value,
                sizeof(value));
        } else {

            ZwDeleteValueKey(handle, &unicodeName);
        }

        ZwClose(handle);
    }

    ASSERT(NT_SUCCESS(status));

    return status;
}

NTSTATUS
IopRestartDeviceNode(
    IN PDEVICE_NODE DeviceNode
    )
{
    PAGED_CODE();

    PpDevNodeLockTree(PPL_TREEOP_BLOCK_READS_FROM_ALLOW);

    ASSERT(DeviceNode->State == DeviceNodeRemoved ||
           DeviceNode->State == DeviceNodeInitialized );

    ASSERT(!PipDoesDevNodeHaveProblem(DeviceNode));

    ASSERT(DeviceNode->Flags & DNF_ENUMERATED);

    if (!(DeviceNode->Flags & DNF_ENUMERATED)) {

        PpDevNodeUnlockTree(PPL_TREEOP_BLOCK_READS_FROM_ALLOW);
        return STATUS_UNSUCCESSFUL;
    }

    DeviceNode->UserFlags &= ~DNUF_NEED_RESTART;
    DeviceNode->Flags &= ~(DNF_DRIVER_BLOCKED | DNF_HARDWARE_VERIFICATION);

#if DBG_SCOPE
    DeviceNode->FailureStatus = 0;
    if (DeviceNode->PreviousResourceList) {
        ExFreePool(DeviceNode->PreviousResourceList);
        DeviceNode->PreviousResourceList = NULL;
    }
    if (DeviceNode->PreviousResourceRequirements) {
        ExFreePool(DeviceNode->PreviousResourceRequirements);
        DeviceNode->PreviousResourceRequirements = NULL;
    }
#endif

    //
    //     Prepare to set the device state back to DeviceNodeUninitialized. To
    // do this we free any existing devnode strings so we can recreate them
    // during enumeration.
    //
    // ADRIAO N.B. 8/19/2000 -
    //     We don't restore the state to DeviceNodeInitialized to maintain Win2K
    // behavior. We have no idea if anyone actually depends on this. In theory
    // this would let a bus driver get away with changing a child's IDs after a
    // remove.
    //

    if (DeviceNode->State != DeviceNodeUninitialized) {

        DeviceNode->Flags &= ~(DNF_NO_RESOURCE_REQUIRED |
                               DNF_RESOURCE_REQUIREMENTS_CHANGED);

        if (DeviceNode->ServiceName.Length != 0) {
            ExFreePool(DeviceNode->ServiceName.Buffer);
            PiWstrToUnicodeString(&DeviceNode->ServiceName, NULL);
        }

        if (DeviceNode->ResourceRequirements != NULL) {
            ExFreePool(DeviceNode->ResourceRequirements);
            DeviceNode->ResourceRequirements = NULL;
            DeviceNode->Flags &= ~DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED;
        }
    }

    ASSERT(DeviceNode->ServiceName.Length == 0 &&
           DeviceNode->ServiceName.MaximumLength == 0 &&
           DeviceNode->ServiceName.Buffer == NULL);

    ASSERT(!(DeviceNode->Flags &
           ~(DNF_MADEUP | DNF_ENUMERATED | DNF_HAS_BOOT_CONFIG | DNF_IDS_QUERIED |
             DNF_BOOT_CONFIG_RESERVED | DNF_NO_RESOURCE_REQUIRED)));

    PipSetDevNodeState(DeviceNode, DeviceNodeUninitialized, NULL);

    PpDevNodeUnlockTree(PPL_TREEOP_BLOCK_READS_FROM_ALLOW);

    return STATUS_SUCCESS;
}

BOOLEAN
IopDeleteKeyRecursiveCallback(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    )
/*++

Routine Description:

    This is a callback routine to PipApplyFunctionToSubKeys, that gets called
    through IopDeleteKeyRecursive.  This routine prepares a given key for
    deletion by deleting all of its subkeys.  This is done, using
    PipApplyFunctionToSubKeys, with instructions to delete all enumerated
    subkeys, and calling this routine as a callback routine, if necessary, until
    no subkeys remain.  KeyHandle can then be successfully deleted by the
    caller.

Arguments:

    KeyHandle - Handle to a subkey that has been enumerated by
        PipApplyFunctionToSubKeys.

    KeyName - Name of the subkey whose handle is specified by KeyHandle.

    Context - Supplies a pointer to user-defined data that will be passed
        in to the callback routine at each subkey invocation.

Return Value:

    BOOLEAN that returns whether or not the given key can be safely deleted.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(KeyName);

    //
    // delete any subkeys, recursively if necessary
    //
    status = PipApplyFunctionToSubKeys(
                KeyHandle,
                NULL,
                KEY_ALL_ACCESS,
                FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS |
                FUNCTIONSUBKEY_FLAG_DELETE_SUBKEYS,
                IopDeleteKeyRecursiveCallback,
                Context
                );

    *((NTSTATUS *)Context) = status;

    return (BOOLEAN)NT_SUCCESS(status);
}

NTSTATUS
IopDeleteKeyRecursive(
    IN HANDLE ParentKey OPTIONAL,
    IN PWCHAR KeyName
    )
/*++

Routine Description:

    Recursively deletes all subkeys of KeyName, then deletes KeyName.

Arguments:

    ParentKey - Handle to the parent key of KeyName.  If NULL then KeyName is
        expected to start with \Registry.

    KeyName - Name of subkey to delete, as a NULL terminated UNICODE string.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    NTSTATUS       status = STATUS_SUCCESS;
    BOOLEAN        result;
    HANDLE         hKey;
    UNICODE_STRING unicodeKeyName;

    PAGED_CODE();

    //
    // Attempt to open the key name we were given
    //
    RtlInitUnicodeString(&unicodeKeyName, KeyName);
    status = IopOpenRegistryKeyEx(&hKey,
                                  ParentKey,
                                  &unicodeKeyName,
                                  KEY_ALL_ACCESS
                                  );
    if (NT_SUCCESS(status)) {

        //
        // Recusively delete all subkeys
        //
        result = IopDeleteKeyRecursiveCallback(hKey,
                                               &unicodeKeyName,
                                               (PVOID)&status
                                               );
        if (result) {

            //
            // It is safe to delete this key
            //
            status = ZwDeleteKey(hKey);
        }
        ZwClose(hKey);
    }

    return status;
}

BOOLEAN
PiRegSzToString(
    IN  PWCHAR RegSzData,
    IN  ULONG  RegSzLength,
    OUT PULONG StringLength  OPTIONAL,
    OUT PWSTR  *CopiedString OPTIONAL
    )

/*++

Routine Description:

    This routine takes as input a REG_SZ data buffer (as returned in the DataOffset area
    of the buffer in a KEY_VALUE_FULL_INFORMATION structure), as well as the length
    of the buffer, in bytes (as specified by the DataLength field in the above mentioned
    struct).  It optionally returns the length of the contained string (in bytes), not
    including the terminating NULL, as well as an optional copy of the string itself
    (properly NULL-terminated).

    It is the responsibility of the caller to free the (PagedPool) buffer allocated
    for the string copy.

Arguments:

    RegSzData - Supplies a pointer to the REG_SZ data buffer.

    RegSzLength - Supplies the length of the RegSzData buffer, in bytes.

    StringLength - Optionally supplies a pointer to a variable that will receive 
        the length, in bytes, of the string (excluding terminating NULL).

    CopiedString - Optionally supplies a pointer to a wide character pointer 
        that will recieve a (properly NULL-terminated) copy of the specified 
        string. If this paramater is NULL, no copy will be made.

Return Value:

    If success, returns TRUE

    If failure (not able to allocate memory for string copy), returns FALSE

--*/

{
    PWCHAR curPos, endOfRegSzData;
    ULONG actualStringLength;

    //
    // Since we're converting a byte count to a wide-character count (and the
    // compiler is converting it back when adding it to a PWCHAR), we are
    // ensuring that endOfRegSzData is not on an odd-byte boundary, even if
    // the RegSzLength passed in was odd.  This takes care of the case where
    // the REG_SZ buffer retrieved from the registry is bogus (e.g., you have
    // a 5-byte buffer, the 1st unicode character of which is a UNICODE_NULL).
    //
    endOfRegSzData = (curPos = RegSzData) + CB_TO_CWC(RegSzLength);

    while ((curPos < endOfRegSzData) && *curPos) {

        curPos++;
    }

    actualStringLength = (ULONG)((PUCHAR)curPos - (PUCHAR)RegSzData);

    if (ARGUMENT_PRESENT(StringLength)) {

        *StringLength = (ULONG)((PUCHAR)curPos - (PUCHAR)RegSzData);
    }

    if (ARGUMENT_PRESENT(CopiedString)) {

        //
        // Allocate memory for the string (+ terminating NULL)
        //
        *CopiedString = (PWSTR)ExAllocatePool(PagedPool, 
                                              actualStringLength + 
                                                sizeof(UNICODE_NULL));
        if (*CopiedString == NULL) {

            return FALSE;
        }

        //
        // Copy the string and NULL-terminate it.
        //
        if (actualStringLength) {

            RtlCopyMemory(*CopiedString, RegSzData, actualStringLength);
        }

        *(PWCHAR)((PUCHAR)(*CopiedString) + actualStringLength) = UNICODE_NULL;
    }

    return TRUE;
}

ULONG
IopDebugPrint (
    IN ULONG    Level,
    IN PCHAR    Format,
    ...
    )
{
    va_list ap;

    va_start(ap, Format);

    vDbgPrintExWithPrefix("", DPFLTR_NTOSPNP_ID, Level, Format, ap);

    va_end(ap);

    return Level;
}

VOID
PpSystemHiveLimitCallback(
    PSYSTEM_HIVE_LIMITS HiveLimits,
    ULONG Level
    )
{
    PAGED_CODE();

    if (Level >= HiveLimits->High) {

        PpSystemHiveTooLarge = TRUE;
    } else {

        ASSERT(Level <= HiveLimits->Low);

        PpSystemHiveTooLarge = FALSE;

        PpResetProblemDevices(IopRootDeviceNode, CM_PROB_REGISTRY_TOO_LARGE);

        PipRequestDeviceAction(IopRootDeviceNode->PhysicalDeviceObject,
                               RestartEnumeration,
                               FALSE,
                               0,
                               NULL,
                               NULL
                               );

    }
}

VOID
PpLogEvent(
    IN PUNICODE_STRING InsertionString1,
    IN PUNICODE_STRING InsertionString2,
    IN NTSTATUS Status,
    IN PVOID DumpData,
    IN ULONG DumpDataSize
    )
/*++

Routine Description:

    This routine logs the driver block event.

Arguments:

    InsertionString1 - First insertion string for event log entry.

    InsertionString2 - Second insertion string for event log entry.

    Status - Status code to be logged.

    DumpData - Data to be logged with the event.

    DumpDataSize - Size of the data to be logged in bytes.

Return Value:

    None.

--*/
{
    SIZE_T size, stringLength1, stringLength2, stringOffset;
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PUCHAR stringPtr;

    PAGED_CODE();

    stringLength1 = stringLength2 = 0;

    if (InsertionString1) {

        stringLength1 = InsertionString1->Length + sizeof(UNICODE_NULL);
    }

    if (InsertionString2) {

        stringLength2 = InsertionString2->Length + sizeof(UNICODE_NULL);
    }

    //
    // Calculate the size of the the error packet
    //
    size = FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + DumpDataSize;

    //
    // Determine the string offset and size, adjusting for alignment.
    //
    stringOffset = ALIGN_UP_ULONG(size, 2);

    size = stringOffset + stringLength1 + stringLength2;

    if (size <= ERROR_LOG_MAXIMUM_SIZE) {

        //
        // Allocate an error log packet. Note that Io takes care of initializing
        // the header and zeroing all fields (such as NumberOfStrings).
        //
        errorLogEntry = IoAllocateGenericErrorLogEntry((UCHAR)size);

        if (errorLogEntry) {

            errorLogEntry->ErrorCode = Status;
            errorLogEntry->FinalStatus = Status;
            errorLogEntry->DumpDataSize = (USHORT)DumpDataSize;
            errorLogEntry->StringOffset = (USHORT)stringOffset;
            stringPtr = ((PUCHAR)errorLogEntry) + stringOffset;

            if (DumpDataSize) {

                RtlCopyMemory(&errorLogEntry->DumpData[0], DumpData, DumpDataSize);
            }

            if (InsertionString1) {

                errorLogEntry->NumberOfStrings = 1;
                RtlCopyMemory(stringPtr, InsertionString1->Buffer, InsertionString1->Length);
                stringPtr += InsertionString1->Length;
                *(PWCHAR)stringPtr = UNICODE_NULL;
                stringPtr += sizeof(UNICODE_NULL);
            }

            if (InsertionString2) {

                errorLogEntry->NumberOfStrings += 1;
                RtlCopyMemory(stringPtr, InsertionString2->Buffer, InsertionString2->Length);
                stringPtr += InsertionString2->Length;
                *(PWCHAR)stringPtr = UNICODE_NULL;
            }

            IoWriteErrorLogEntry(errorLogEntry);
        }
    } else {

        ASSERT(size <= ERROR_LOG_MAXIMUM_SIZE);
    }
}

ULONG
PiFixupID(
    IN PWCHAR ID,
    IN ULONG MaxIDLength,
    IN BOOLEAN Multi,
    IN ULONG AllowedSeparators,
    IN PUNICODE_STRING LogString OPTIONAL
    )

/*++

Routine Description:

    This routine parses the device instance string and replaces any invalid
    characters (not allowed in a "device instance") with an underscore
    character.

    Invalid characters are:
        c <= 0x20 (' ')
        c >  0x7F
        c == 0x2C (',')

Arguments:

    ID - ID to be fixed up.

    MaxIDLength - Maximum allowed size of ID.

    Multi - Specifies if the ID is MULTI_SZ or not.

    AllowedSeparators - Number of separators allowed in the ID.

Return Value:

    ID length in number of characters.

--*/

{
    PWCHAR p, pMax, lastNull;
    ULONG separators;
    UNICODE_STRING reason;

    PAGED_CODE();

    //
    // BUGBUG - do we need to uppercase these!?
    //
    separators = 0;
    lastNull = NULL;
    for(p = ID, pMax = p + MaxIDLength; p < pMax; p++) {

        if(*p == UNICODE_NULL) {

            if(Multi == FALSE || (lastNull && p == lastNull + 1)) {

                break;
            }
            pMax += MaxIDLength;
            lastNull = p;
            continue;
        }
        if (*p == L' ') {

            *p = L'_';
        } else if ((*p < L' ')  || (*p > (WCHAR)0x7F) || (*p == L',')) {

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PiFixupID: ID at %p has invalid character %02X\n",
                         ID,
                         *p));

            if(LogString) {

                PiWstrToUnicodeString(&reason, L"invalid character");
                PpLogEvent(LogString, &reason, STATUS_PNP_INVALID_ID, p, sizeof(WCHAR));
            }

            return 0;
        } else if ((*p == OBJ_NAME_PATH_SEPARATOR && ++separators > AllowedSeparators)) {

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PiFixupID: ID at %p has too many (%d) separators\n",
                         ID,
                         separators));
            if(LogString) {

                PiWstrToUnicodeString(&reason, L"too many separators");
                PpLogEvent(LogString, 
                           &reason, 
                           STATUS_PNP_INVALID_ID, 
                           &separators, 
                           sizeof(ULONG)
                           );
            }
            return 0;
        }
    }
    if( p >= pMax || 
        (AllowedSeparators != (ULONG)-1 && 
         separators != AllowedSeparators)) {

        IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                     "PiFixupID: ID at %p not terminated, or too long or has invalid number (%d) of separators\n",
                     ID,
                     separators));
        if(LogString) {

            PiWstrToUnicodeString(&reason, 
                                  L"not terminated, too long or invalid number of separators"
                                  );
            PpLogEvent(LogString, &reason, STATUS_PNP_INVALID_ID, NULL, 0);
        }
        return 0;
    }

    return (ULONG)(ULONG_PTR)(p - ID) + 1;
}

NTSTATUS
PpQueryID(
    IN PDEVICE_NODE DeviceNode,
    IN BUS_QUERY_ID_TYPE IDType,
    OUT PWCHAR *ID,
    OUT PULONG IDLength
    )

/*++

Routine Description:

    This routine queries the specified ID and fixes it up. If this
    routine fails, ID will be set to NULL.

Arguments:

    DeviceNode - The devnode whose IDs need to be queried.

    IDType - Type of ID to be queried.

    ID - Receives the ID returned by the driver if any. The caller
    is expected to free the storage for ID on success.
    
    IDLength - Receives the length of the ID (including terminating NULL) in 
        bytes.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    UNICODE_STRING reason;

    PAGED_CODE();

    ASSERT(IDType == BusQueryDeviceID || IDType == BusQueryInstanceID ||
          IDType == BusQueryHardwareIDs || IDType == BusQueryCompatibleIDs);

    *IDLength = 0;
    status = PpIrpQueryID(DeviceNode->PhysicalDeviceObject, IDType, ID);
    if(NT_SUCCESS(status)) {

        switch(IDType) {

            case BusQueryDeviceID:

                *IDLength = PiFixupID(*ID, 
                                      MAX_DEVICE_ID_LEN, 
                                      FALSE, 
                                      1, 
                                      &DeviceNode->Parent->ServiceName
                                      );
                break;

            case BusQueryInstanceID:

                *IDLength = PiFixupID(*ID, 
                                      MAX_DEVICE_ID_LEN, 
                                      FALSE, 
                                      0,
                                      &DeviceNode->Parent->ServiceName
                                      );
                break;

            case BusQueryHardwareIDs:
            case BusQueryCompatibleIDs:

                *IDLength = PiFixupID(*ID, 
                                      MAX_DEVICE_ID_LEN, 
                                      TRUE, 
                                      (ULONG)-1, 
                                      &DeviceNode->Parent->ServiceName
                                      );
                break;

            default:

                *IDLength = 0;
                break;
        }
        (*IDLength) *= sizeof(WCHAR);
        if(*IDLength == 0) {

            status = STATUS_PNP_INVALID_ID;
        }
    }

    if(!NT_SUCCESS(status)) {

        if (status == STATUS_PNP_INVALID_ID || IDType == BusQueryDeviceID) {

            PipSetDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA);
            if ((DeviceNode->Parent->Flags & DNF_CHILD_WITH_INVALID_ID) == 0) {

                DeviceNode->Parent->Flags |= DNF_CHILD_WITH_INVALID_ID;
                PpSetInvalidIDEvent(&DeviceNode->Parent->InstancePath);
            }
        }
        if (status == STATUS_PNP_INVALID_ID) {

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PpQueryID: Bogus ID returned by %wZ\n",
                         &DeviceNode->Parent->ServiceName));
            ASSERT(status != STATUS_PNP_INVALID_ID);

        } else if ( IDType == BusQueryDeviceID && 
                    status != STATUS_INSUFFICIENT_RESOURCES) {
            //
            // DeviceID is not optional.
            //
            PiWstrToUnicodeString(&reason, L"failed IRP_MN_QUERY_ID-BusQueryDeviceID");
            PpLogEvent(
                &DeviceNode->Parent->ServiceName, 
                &reason, 
                status, 
                NULL, 
                0
                );

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PpIrpQueryID: Failed by %wZ, status = %x\n",
                         &DeviceNode->Parent->ServiceName, status));
            ASSERT(IDType != BusQueryDeviceID);
        }

        if(*ID) {

            ExFreePool(*ID);
            *ID = NULL;
            *IDLength = 0;
        }
    }

    return status;
}

NTSTATUS
PpQueryDeviceID(
    IN PDEVICE_NODE DeviceNode,
    OUT PWCHAR *BusID,
    OUT PWCHAR *DeviceID
    )

/*++

Routine Description:

    This routine queries the Device ID and fixes it up. It also parses the 
    DeviceID and returns the pointers to BusID and DeviceID parts. If this 
    routine fails, BusID and DeviceID will be set to NULL.

Arguments:

    DeviceNode - The devnode whose DeviceID needs to be queried.

    BusID - Recieves the pointer to the bus part of DeviceID.

    DeviceID - Recieves the pointer to the device part of DeviceID.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    PWCHAR id, separator;
    ULONG idLength;

    PAGED_CODE();

    *BusID = NULL;
    *DeviceID= NULL;

    status = PpQueryID(DeviceNode, BusQueryDeviceID, &id, &idLength);
    if(NT_SUCCESS(status)) {

        ASSERT(id && idLength);

        *BusID = id;
        separator = wcschr(id, OBJ_NAME_PATH_SEPARATOR);

        ASSERT(separator);

        *separator = UNICODE_NULL;
        *DeviceID = separator + 1;

    } else {

        ASSERT(id == NULL && idLength == 0);
    }

    return status;
}

NTSTATUS
PpQueryBusInformation(
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine queries the bus information.

Arguments:

    DeviceNode - The devnode whose BusInormation needs to be queried.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    PPNP_BUS_INFORMATION busInfo;

    PAGED_CODE();

    status = PpIrpQueryBusInformation(
                DeviceNode->PhysicalDeviceObject, 
                &busInfo
                );
    if(NT_SUCCESS(status)) {

        ASSERT(busInfo);

        DeviceNode->ChildBusTypeIndex = PpBusTypeGuidGetIndex(
                                            &busInfo->BusTypeGuid
                                            );
        DeviceNode->ChildInterfaceType = busInfo->LegacyBusType;
        DeviceNode->ChildBusNumber = busInfo->BusNumber;

        ExFreePool(busInfo);

    } else {

        ASSERT(busInfo == NULL);

        DeviceNode->ChildBusTypeIndex = 0xffff;
        DeviceNode->ChildInterfaceType = InterfaceTypeUndefined;
        DeviceNode->ChildBusNumber = 0xfffffff0;
    }

    return status;
}

NTSTATUS
PpBusTypeGuidInitialize(
    VOID
    )

/*++

Routine Description:

    This routine opens the specified subkey.

Arguments:

    None

Return Value:

    STATUS_SUCCESS.

--*/

{
    PAGED_CODE();

    PpBusTypeGuidCountMax = 16;
    PpBusTypeGuidArray = ExAllocatePool(PagedPool, 
                                        sizeof(GUID) * PpBusTypeGuidCountMax);
    if (PpBusTypeGuidArray == NULL) {

        PpBusTypeGuidCountMax = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    PpBusTypeGuidCount = 0;

    KeInitializeGuardedMutex(&PpBusTypeGuidLock);

    return STATUS_SUCCESS;
}

USHORT
PpBusTypeGuidGetIndex(
    IN LPGUID BusTypeGuid
    )

/*++

Routine Description:

    This routine looks up the BusTypeGuid and returns its index into the table.

Arguments:

    BusTypeGuid - GUID to lookup.

Return Value:

    Index into the table iff successful, else 0xFFFF.

--*/

{
    LPGUID p;
    ULONG i;

    PAGED_CODE();

    KeAcquireGuardedMutex(&PpBusTypeGuidLock);
    //
    // First look it up.
    //
    for (i = 0; i < PpBusTypeGuidCount; i++) {

        if (IopCompareGuid(BusTypeGuid, &PpBusTypeGuidArray[i])) {

            break;
        }
    }
    //
    // If the GUID is not in the table, add it.
    //
    if (i == PpBusTypeGuidCount) {
        //
        // Grow the table if needed.
        //
        if (i == PpBusTypeGuidCountMax) {
            //
            // We grow the table one entry at a time. This should not be a
            // problem since this should not happen often.
            //
            p  = ExAllocatePool(PagedPool, (i + 1) * sizeof(GUID));
            if (p) {
                //
                // Copy the old table.
                //
                RtlCopyMemory(p, 
                              PpBusTypeGuidArray, 
                              PpBusTypeGuidCount * sizeof(GUID)
                              );
                //
                // Update global data.
                //
                PpBusTypeGuidCountMax++;
                if (PpBusTypeGuidArray) {

                    ExFreePool(PpBusTypeGuidArray);
                }
                PpBusTypeGuidArray = p;

            } else {
                //
                // Return invalid index on failure.
                //
                i = (ULONG)-1;
            }
        }
        //
        // Copy the new entry on success.
        //
        if (i != (ULONG)-1) {
            //
            // Copy the new entry.
            //
            RtlCopyMemory(&PpBusTypeGuidArray[PpBusTypeGuidCount], 
                          BusTypeGuid, 
                          sizeof(GUID)
                          );
            //
            // Update global data.
            //
            PpBusTypeGuidCount++;
        }
    }

    KeReleaseGuardedMutex(&PpBusTypeGuidLock);

    return (USHORT)i;
}

NTSTATUS
PpBusTypeGuidGet(
    IN USHORT Index,
    IN OUT LPGUID BusTypeGuid
    )

/*++

Routine Description:

    This routine return the BusTypeGuid in the table at the specified index.

Arguments:

    Index - BusTypeGuid index.

    BusTypeGuid - Recieves the GUID.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    KeAcquireGuardedMutex(&PpBusTypeGuidLock);

    if (Index < PpBusTypeGuidCount) {

        RtlCopyMemory(BusTypeGuid, &PpBusTypeGuidArray[Index], sizeof(GUID));
        status = STATUS_SUCCESS;
    } else {

        status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    KeReleaseGuardedMutex(&PpBusTypeGuidLock);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\ppdrvdb.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    PpDrvDB.h

Abstract:

    Contains PnP routines to deal with driver load\unload.
    
Author:

    Santosh S. Jodh  - January 22, 2001

Revision History:

--*/

NTSTATUS
PpInitializeBootDDB(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
PpReleaseBootDDB(
    VOID
    );

NTSTATUS
PpGetBlockedDriverList(
    IN OUT GUID *Buffer,
    IN OUT PULONG Size,
    IN ULONG Flags
    );

NTSTATUS
PpCheckInDriverDatabase(
    IN PUNICODE_STRING KeyName,
    IN HANDLE KeyHandle,
    IN PVOID ImageBase,
    IN ULONG ImageSize,
    IN BOOLEAN IsFilter,
    OUT LPGUID EntryGuid
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\ppdebug.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ppdebug.h

Abstract:

    This header defines debug macros for the Plug and Play subsystem.

Author:

    Adrian J. Oney (AdriaO) Sept 14, 2000.

Revision History:


--*/

//#define DBG_SCOPE 1     // Enable SOME DBG stuff on ALL builds
#define DBG_SCOPE DBG // Enable only on DBG build

/*++

    Debug output is filtered at two levels: A global level and a component
    specific level.

    Each debug output request specifies a component id and a filter level
    or mask. These variables are used to access the debug print filter
    database maintained by the system. The component id selects a 32-bit
    mask value and the level either specified a bit within that mask or is
    as mask value itself.

    If any of the bits specified by the level or mask are set in either the
    component mask or the global mask, then the debug output is permitted.
    Otherwise, the debug output is filtered and not printed.

    The component mask for filtering the debug output of this component is
    Kd_NTOSPNP_Mask and may be set via the registry or the kernel debugger.

    The global mask for filtering the debug output of all components is
    Kd_WIN2000_Mask and may be set via the registry or the kernel debugger.

    The registry key for setting the mask value for this component is:

    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\
        Debug Print Filter\NTOSPNP

    The key "Debug Print Filter" may have to be created in order to create
    the component key.

    Pnp is divided into the following sub-components for debug spew.
        1. LOADUNLOAD: AddDevice, UnloadDriver etc
        2. RESOURCE: Allocation, rebalance etc
        3. ENUMERATION: Starts, enumerations etc
        4. IOAPI: IO APIs etc
        5. IOEVENT: IO events etc
        6. MAPPER: Firmware mapper etc
        7. PNPBIOS: PnP BIOS etc
    Each sub-component gets 5 debug levels. The error level for each component
    maps to the default error level.

 --*/

#define IOP_ERROR_LEVEL                 DPFLTR_ERROR_LEVEL
#define IOP_WARNING_LEVEL               DPFLTR_WARNING_LEVEL
#define IOP_TRACE_LEVEL                 DPFLTR_TRACE_LEVEL
#define IOP_INFO_LEVEL                  DPFLTR_INFO_LEVEL

#define IOP_LOADUNLOAD_LEVEL            (DPFLTR_INFO_LEVEL + 1)
#define IOP_RESOURCE_LEVEL              (DPFLTR_INFO_LEVEL + 5)
#define IOP_ENUMERATION_LEVEL           (DPFLTR_INFO_LEVEL + 9)
#define IOP_IOAPI_LEVEL                 (DPFLTR_INFO_LEVEL + 13)
#define IOP_IOEVENT_LEVEL               (DPFLTR_INFO_LEVEL + 17)
#define IOP_MAPPER_LEVEL                (DPFLTR_INFO_LEVEL + 21)
#define IOP_PNPBIOS_LEVEL               (DPFLTR_INFO_LEVEL + 25)

//
// All error levels map to the default error level.
//
#define IOP_LOADUNLOAD_ERROR_LEVEL      DPFLTR_ERROR_LEVEL
#define IOP_RESOURCE_ERROR_LEVEL        DPFLTR_ERROR_LEVEL
#define IOP_ENUMERATION_ERROR_LEVEL     DPFLTR_ERROR_LEVEL
#define IOP_IOAPI_ERROR_LEVEL           DPFLTR_ERROR_LEVEL
#define IOP_IOEVENT_ERROR_LEVEL         DPFLTR_ERROR_LEVEL
#define IOP_MAPPER_ERROR_LEVEL          DPFLTR_ERROR_LEVEL
#define IOP_PNPBIOS_ERROR_LEVEL         DPFLTR_ERROR_LEVEL
//
// Component sublevels are based off the component base level.
//
#define IOP_LOADUNLOAD_WARNING_LEVEL    (IOP_LOADUNLOAD_LEVEL + 0)
#define IOP_LOADUNLOAD_TRACE_LEVEL      (IOP_LOADUNLOAD_LEVEL + 1)
#define IOP_LOADUNLOAD_INFO_LEVEL       (IOP_LOADUNLOAD_LEVEL + 2)
#define IOP_LOADUNLOAD_VERBOSE_LEVEL    (IOP_LOADUNLOAD_LEVEL + 3)

#define IOP_RESOURCE_WARNING_LEVEL      (IOP_RESOURCE_LEVEL + 0)
#define IOP_RESOURCE_TRACE_LEVEL        (IOP_RESOURCE_LEVEL + 1)
#define IOP_RESOURCE_INFO_LEVEL         (IOP_RESOURCE_LEVEL + 2)
#define IOP_RESOURCE_VERBOSE_LEVEL      (IOP_RESOURCE_LEVEL + 3)

#define IOP_ENUMERATION_WARNING_LEVEL   (IOP_ENUMERATION_LEVEL + 0)
#define IOP_ENUMERATION_TRACE_LEVEL     (IOP_ENUMERATION_LEVEL + 1)
#define IOP_ENUMERATION_INFO_LEVEL      (IOP_ENUMERATION_LEVEL + 2)
#define IOP_ENUMERATION_VERBOSE_LEVEL   (IOP_ENUMERATION_LEVEL + 3)

#define IOP_IOAPI_WARNING_LEVEL         (IOP_IOAPI_LEVEL + 0)
#define IOP_IOAPI_TRACE_LEVEL           (IOP_IOAPI_LEVEL + 1)
#define IOP_IOAPI_INFO_LEVEL            (IOP_IOAPI_LEVEL + 2)
#define IOP_IOAPI_VERBOSE_LEVEL         (IOP_IOAPI_LEVEL + 3)

#define IOP_IOEVENT_WARNING_LEVEL       (IOP_IOEVENT_LEVEL + 0)
#define IOP_IOEVENT_TRACE_LEVEL         (IOP_IOEVENT_LEVEL + 1)
#define IOP_IOEVENT_INFO_LEVEL          (IOP_IOEVENT_LEVEL + 2)
#define IOP_IOEVENT_VERBOSE_LEVEL       (IOP_IOEVENT_LEVEL + 3)

#define IOP_MAPPER_WARNING_LEVEL        (IOP_MAPPER_LEVEL + 0)
#define IOP_MAPPER_TRACE_LEVEL          (IOP_MAPPER_LEVEL + 1)
#define IOP_MAPPER_INFO_LEVEL           (IOP_MAPPER_LEVEL + 2)
#define IOP_MAPPER_VERBOSE_LEVEL        (IOP_MAPPER_LEVEL + 3)

#define IOP_PNPBIOS_WARNING_LEVEL       (IOP_PNPBIOS_LEVEL + 0)
#define IOP_PNPBIOS_TRACE_LEVEL         (IOP_PNPBIOS_LEVEL + 1)
#define IOP_PNPBIOS_INFO_LEVEL          (IOP_PNPBIOS_LEVEL + 2)
#define IOP_PNPBIOS_VERBOSE_LEVEL       (IOP_PNPBIOS_LEVEL + 3)

#if DBG

ULONG
IopDebugPrint (
    IN ULONG    Level,
    IN PCHAR    Format,
    ...
    );

#define IopDbgPrint(m)  IopDebugPrint m

#else

#define IopDbgPrint(m)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\ppcddb.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ppcddb.c

Abstract:

    This module implements the Plug and Play Critical Device Database (CDDB)
    and related "features".

Author:

    James G. Cavalaris (jamesca) 01-Nov-2001

Environment:

    Kernel mode.

Revision History:

    29-Jul-1997     Jim Cavalaris (t-jcaval)

        Creation and initial implementation.

    01-Nov-2001     Jim Cavalaris (jamesca)

        Added routines for device pre-installation setup.

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#include <wdmguid.h>
#include "picddb.h"

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'dcpP')
#endif


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PpCriticalProcessCriticalDevice)
#pragma alloc_text(PAGE, PpCriticalGetDeviceLocationStrings)

#pragma alloc_text(PAGE, PiCriticalOpenCriticalDeviceKey)
#pragma alloc_text(PAGE, PiCriticalCopyCriticalDeviceProperties)
#pragma alloc_text(PAGE, PiCriticalPreInstallDevice)
#pragma alloc_text(PAGE, PiCriticalOpenDevicePreInstallKey)
#pragma alloc_text(PAGE, PiCriticalOpenFirstMatchingSubKey)
#pragma alloc_text(PAGE, PiCriticalCallbackVerifyCriticalEntry)

#pragma alloc_text(PAGE, PiQueryInterface)
#pragma alloc_text(PAGE, PiCopyKeyRecursive)
#pragma alloc_text(PAGE, PiCriticalQueryRegistryValueCallback)

#endif // ALLOC_PRAGMA

typedef struct _PI_CRITICAL_QUERY_CONTEXT {             
    PVOID Buffer;
    ULONG Size;
}PI_CRITICAL_QUERY_CONTEXT, *PPI_CRITICAL_QUERY_CONTEXT;

//
// Critical Device Database data
//

//
// Specifies whether the critical device database functionality is enabled.
// (currently always TRUE).
//

BOOLEAN PiCriticalDeviceDatabaseEnabled = TRUE;




//
// Critical Device Database routines
//

NTSTATUS
PiCriticalOpenCriticalDeviceKey(
    IN  PDEVICE_NODE    DeviceNode,
    IN  HANDLE          CriticalDeviceDatabaseRootHandle  OPTIONAL,
    OUT PHANDLE         CriticalDeviceEntryHandle
    )

/*++

Routine Description:

    This routine retrieves the registry key containing the critical device
    settings for the specified device.

Arguments:

    DeviceNode -

        Specifies the device whose critical settings are to be retrieved.

    CriticalDeviceDatabaseRootHandle -

        Optionally, specifies a handle to the key that should be considered the
        root of the critical device database to be searched for this device.

        If no handle is supplied, the default critical device database is used:

            System\\CurrentControlSet\\Control\\CriticalDeviceDatabase

    CriticalDeviceEntryHandle -

        Returns a handle to the registry key containing critical device settings
        for the specified device.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS  Status, tmpStatus;
    UNICODE_STRING  UnicodeString;
    HANDLE    DeviceInstanceHandle;
    PWSTR     SearchIds[2];
    ULONG     SearchIdsIndex;
    PKEY_VALUE_FULL_INFORMATION keyValueInfo;
    PWCHAR    DeviceIds;
    HANDLE    DatabaseRootHandle;

    PAGED_CODE();

    //
    // Validate parameters.
    //
    if ((!ARGUMENT_PRESENT(DeviceNode)) ||
        (!ARGUMENT_PRESENT(CriticalDeviceEntryHandle))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize output parameter.
    //
    *CriticalDeviceEntryHandle = NULL;

    if (CriticalDeviceDatabaseRootHandle != NULL) {
        //
        // We were given a root database to be searched.
        //
        DatabaseRootHandle = CriticalDeviceDatabaseRootHandle;

    } else {
        //
        // No root database handle supplied, so we open a key to the default
        // global critical device database root.
        //
        PiWstrToUnicodeString(
            &UnicodeString,
            CM_REGISTRY_MACHINE(REGSTR_PATH_CRITICALDEVICEDATABASE));

        Status =
            IopOpenRegistryKeyEx(
                &DatabaseRootHandle,
                NULL,
                &UnicodeString,
                KEY_READ);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    ASSERT(DatabaseRootHandle != NULL);

    //
    // Open the device instance registry key.
    //
    DeviceInstanceHandle = NULL;

    Status =
        IopDeviceObjectToDeviceInstance(
            DeviceNode->PhysicalDeviceObject,
            &DeviceInstanceHandle,
            KEY_READ);

    if (!NT_SUCCESS(Status)) {
        ASSERT(DeviceInstanceHandle == NULL);
        goto Clean0;
    }

    ASSERT(DeviceInstanceHandle != NULL);

    //
    // Search for a match for this device in the critical device database first
    // by HardwareId, then by CompatibleId.
    //
    SearchIds[0] = REGSTR_VALUE_HARDWAREID;
    SearchIds[1] = REGSTR_VALUE_COMPATIBLEIDS;

    for (SearchIdsIndex = 0;
         SearchIdsIndex < RTL_NUMBER_OF(SearchIds);
         SearchIdsIndex++) {

        //
        // Retrieve the SearchIds for the device.
        //
        // NOTE - we currently retrieve these hardware and compatible ids from
        // the device instance registry key, so they need to have been written
        // there by now, during enumeration.  If a critical device database
        // match for a device is expected to be found prior to that, these
        // properties should be queried directly form the device instead.
        //
        keyValueInfo = NULL;

        Status =
            IopGetRegistryValue(
                DeviceInstanceHandle,
                SearchIds[SearchIdsIndex],
                &keyValueInfo
                );

        if (!NT_SUCCESS(Status)) {
            ASSERT(keyValueInfo == NULL);
            continue;
        }

        ASSERT(keyValueInfo != NULL);

        //
        // Make sure the returned registry value is a multi-sz.
        //
        if (keyValueInfo->Type != REG_MULTI_SZ) {
            Status = STATUS_UNSUCCESSFUL;
            ExFreePool(keyValueInfo);
            continue;
        }

        //
        // Munge all search ids in the multi-sz list.
        //

        DeviceIds = (PWCHAR)KEY_VALUE_DATA(keyValueInfo);

        UnicodeString.Buffer = DeviceIds;
        UnicodeString.Length = (USHORT)keyValueInfo->DataLength;
        UnicodeString.MaximumLength = UnicodeString.Length;

        tmpStatus =
            IopReplaceSeperatorWithPound(
                &UnicodeString,
                &UnicodeString
                );

        ASSERT(NT_SUCCESS(tmpStatus));

        //
        // Check each munged device id for a match in the
        // CriticalDeviceDatabase, by attempting to open the first matching
        // subkey.
        //
        // Use PiCriticalCallbackVerifyCriticalEntry to determine if a matching
        // subkey satisfies additional match requirements.
        //
        // NOTE: 01-Dec-2001 : Jim Cavalaris (jamesca)
        //
        // We do this because the previous implementation of the Critical Device
        // Database match code would search all matching subkeys until it found
        // one with a valid Service.  This may be because matches may not have
        // been found in the most appropriate order of hw-id/compat-ids, by
        // decreasing relevance.  Now that we do so, we should hopefully not
        // need to resort to a less-relevant database match with a service, over
        // a more specific one.  A match with no service should mean none is
        // required.  That however, would involve allowing devices to go through
        // the critical device database, and receive no Service match when we
        // might possibly find one - something we may not have done before.
        //
        // Until all these issues are sorted out, we'll just use a verification
        // callback routine to implement the logic that has always been there -
        // check for Service and ClassGUID entry values before declaring an
        // entry a match.  If we want to change the behavior of what is
        // considered a match, just change the callback routine - OR - provide
        // no callback routine to simply declare the the first matching subkey
        // name as a match.
        //

        Status =
            PiCriticalOpenFirstMatchingSubKey(
                DeviceIds,
                DatabaseRootHandle,
                KEY_READ,
                (PCRITICAL_MATCH_CALLBACK)PiCriticalCallbackVerifyCriticalEntry,
                CriticalDeviceEntryHandle
                );

        ExFreePool(keyValueInfo);

        //
        // Stop if we found a match in this list of device ids.
        //
        if (NT_SUCCESS(Status)) {
            ASSERT(*CriticalDeviceEntryHandle != NULL);
            break;
        }
    }

    //
    // Close the device instance registry key handle.
    //
    ZwClose(DeviceInstanceHandle);

  Clean0:

    //
    // If we opened our own key to the database root, close it now.
    //
    if ((CriticalDeviceDatabaseRootHandle == NULL) &&
        (DatabaseRootHandle != NULL)) {
        ZwClose(DatabaseRootHandle);
    }

    return Status;

} // PiCriticalOpenCriticalDeviceKey



NTSTATUS
PiCriticalCopyCriticalDeviceProperties(
    IN  HANDLE          DeviceInstanceHandle,
    IN  HANDLE          CriticalDeviceEntryHandle
    )

/*++

Routine Description:

    This routine will copy the Service, ClassGUID, LowerFilters and UpperFilters
    device registry properties from the matching database entry to the device
    instance registry key.

Arguments:

   DeviceInstanceHandle -

       Specifies a handle to the device instance key that is to be populated
       with critical entries from the critical device database.

   CriticalDeviceEntryHandle -

       Specifies a handle to the matching critical device database entry that
       contains critical device instance registry values to populate.

Return Value:

    NTSTATUS code.

Notes:

    ** Values places in a given critical device database entry must be
       applicable to ALL INSTANCES OF A MATCHING DEVICE ID.


    ** Specifically, you MUST NOT write/copy values that are SPECIFIC TO A
       SINGLE INSTANCE OF A DEVICE to/from a critical device database entry.

       The "hands-off" list includes (but is not restricted to)
       instance-specific values such as:

         REGSTR_VALUE_DRIVER             ("Driver")
         REGSTR_VAL_LOCATION_INFORMATION ("LocationInformation")
         REGSTR_VALUE_PARENT_ID_PREFIX   ("ParentIdPrefix")
         REGSTR_VALUE_UNIQUE_PARENT_ID   ("UniqueParentID")

--*/

{
    NTSTATUS        Status, tmpStatus;
    RTL_QUERY_REGISTRY_TABLE  QueryParameters[9];
    UNICODE_STRING  Service, ClassGuid, LowerFilters, UpperFilters;
    UNICODE_STRING  UnicodeValueName;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInfo;
    ULONG DeviceType, Characteristics, Exclusive, dummy;
    PI_CRITICAL_QUERY_CONTEXT SecurityContext;

    PAGED_CODE();

    //
    // Validate parameters.
    //
    if ((DeviceInstanceHandle == NULL) ||
        (CriticalDeviceEntryHandle == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Query registry values from the matching critical device database entry.
    //
    // Initialize unicode strings with NULL Buffers.
    // RTL_QUERY_REGISTRY_DIRECT will allocate buffers as necessary.
    //
    PiWstrToUnicodeString(&Service, NULL);
    PiWstrToUnicodeString(&ClassGuid, NULL);
    PiWstrToUnicodeString(&LowerFilters, NULL);
    PiWstrToUnicodeString(&UpperFilters, NULL);

    DeviceType = 0;
    Exclusive = 0;
    Characteristics = 0;
    dummy = 0;
    SecurityContext.Buffer = NULL;
    SecurityContext.Size = 0;

    //
    // RTL_QUERY_REGISTRY_DIRECT uses system provided QueryRoutine.
    // Look at the DDK documentation for more details on this flag.
    //
    RtlZeroMemory(
        QueryParameters,
        sizeof(QueryParameters)
        );

    QueryParameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryParameters[0].Name = REGSTR_VALUE_SERVICE;
    QueryParameters[0].EntryContext = &Service;
    QueryParameters[0].DefaultType = REG_SZ;
    QueryParameters[0].DefaultData = L"";
    QueryParameters[0].DefaultLength = 0;

    QueryParameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryParameters[1].Name = REGSTR_VALUE_CLASSGUID;
    QueryParameters[1].EntryContext = &ClassGuid;
    QueryParameters[1].DefaultType = REG_SZ;
    QueryParameters[1].DefaultData = L"";
    QueryParameters[1].DefaultLength = 0;

    QueryParameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryParameters[2].Name = REGSTR_VALUE_LOWERFILTERS;
    QueryParameters[2].EntryContext = &LowerFilters;
    QueryParameters[2].DefaultType = REG_MULTI_SZ;
    QueryParameters[2].DefaultData = L"";
    QueryParameters[2].DefaultLength = 0;

    QueryParameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryParameters[3].Name = REGSTR_VALUE_UPPERFILTERS;
    QueryParameters[3].EntryContext = &UpperFilters;
    QueryParameters[3].DefaultType = REG_MULTI_SZ;
    QueryParameters[3].DefaultData = L"";
    QueryParameters[3].DefaultLength = 0;

    QueryParameters[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryParameters[4].Name = REGSTR_VAL_DEVICE_TYPE;
    QueryParameters[4].EntryContext = &DeviceType;
    QueryParameters[4].DefaultType = REG_DWORD;
    QueryParameters[4].DefaultData = &dummy;
    QueryParameters[4].DefaultLength = sizeof(DeviceType);

    QueryParameters[5].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryParameters[5].Name = REGSTR_VAL_DEVICE_EXCLUSIVE;
    QueryParameters[5].EntryContext = &Exclusive;
    QueryParameters[5].DefaultType = REG_DWORD;
    QueryParameters[5].DefaultData = &dummy;
    QueryParameters[5].DefaultLength = sizeof(Exclusive);

    QueryParameters[6].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryParameters[6].Name = REGSTR_VAL_DEVICE_CHARACTERISTICS;
    QueryParameters[6].EntryContext = &Characteristics;
    QueryParameters[6].DefaultType = REG_DWORD;
    QueryParameters[6].DefaultData = &dummy;
    QueryParameters[6].DefaultLength = sizeof(Characteristics);

    QueryParameters[7].QueryRoutine = PiCriticalQueryRegistryValueCallback;
    QueryParameters[7].Name = REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR;
    QueryParameters[7].EntryContext = &SecurityContext;
    QueryParameters[7].DefaultType = REG_BINARY;
    QueryParameters[7].DefaultData = NULL;
    QueryParameters[7].DefaultLength = 0;

    Status =
        RtlQueryRegistryValues(
            RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
            (PWSTR)CriticalDeviceEntryHandle,
            QueryParameters,
            NULL,
            NULL
            );

    if (!NT_SUCCESS(Status)) {
        goto Clean0;
    }

    //
    // If successful so far, fix up some values, as needed.
    //

    if ((Service.Length == 0) &&
        (Service.Buffer != NULL)) {
        //
        // Don't write an empty Service string.
        //
        RtlFreeUnicodeString(&Service);
        PiWstrToUnicodeString(&Service, NULL);
    }

    if ((ClassGuid.Length == 0) &&
        (ClassGuid.Buffer != NULL)) {
        //
        // Don't write an empty ClassGUID string.
        //
        RtlFreeUnicodeString(&ClassGuid);
        PiWstrToUnicodeString(&ClassGuid, NULL);
    }

    if ((UpperFilters.Length <= sizeof(UNICODE_NULL)) &&
        (UpperFilters.Buffer != NULL)) {
        //
        // Don't write empty UpperFilter multi-sz values.
        //
        RtlFreeUnicodeString(&UpperFilters);
        PiWstrToUnicodeString(&UpperFilters, NULL);
    }

    if ((LowerFilters.Length <= sizeof(UNICODE_NULL)) &&
        (LowerFilters.Buffer != NULL)) {
        //
        // Don't write empty LowerFilter multi-sz values.
        //
        RtlFreeUnicodeString(&LowerFilters);
        PiWstrToUnicodeString(&LowerFilters, NULL);
    }

    //
    // Set the critical device registry property values only if we have a
    // Service value to set for the device.
    //

    IopDbgPrint((IOP_ENUMERATION_WARNING_LEVEL,
                 "PiCriticalCopyCriticalDeviceProperties: "
                 "Setting up critical service\n"));

    //
    // NOTE: The PiCriticalCallbackVerifyCriticalEntry critical database entry
    // verification callback should never validate a critical device database
    // entry with no REGSTR_VALUE_SERVICE value.
    //

    if (Service.Buffer != NULL) {
        //
        // Set the "Service" device registry property.
        //

        PiWstrToUnicodeString(&UnicodeValueName, REGSTR_VALUE_SERVICE);

        IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                     "PiCriticalCopyCriticalDeviceProperties: "
                     "%wZ: %wZ\n",
                     &UnicodeValueName,
                     &Service));

        ASSERT(DeviceInstanceHandle != NULL);

        //
        // Use the status from attempting to set the Service value as the
        // final status of the critical settings copy operation.
        //

        Status =
            ZwSetValueKey(
                DeviceInstanceHandle,
                &UnicodeValueName,
                TITLE_INDEX_VALUE,
                REG_SZ,
                Service.Buffer,
                Service.Length + sizeof(UNICODE_NULL)
                );

        if (!NT_SUCCESS(Status)) {
            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PiCriticalCopyCriticalDeviceProperties: "
                         "Error setting %wZ, (Status = %#08lx)\n",
                         &UnicodeValueName, Status));
        }


    } else {
        //
        // No Service value to set is considered a failure of the entire
        // critical settings copy operation.
        //

        IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                     "PiCriticalCopyCriticalDeviceProperties: "
                     "No Service for critical entry!\n"));

        //
        // NOTE: We should never encounter this situation because the
        // PiCriticalCallbackVerifyCriticalEntry critical database entry
        // verification callback should never validate a critical device
        // database entry with no Service value, hence the ASSERT.
        //

        ASSERT(Service.Buffer != NULL);

        Status = STATUS_UNSUCCESSFUL;
    }


    //
    // If not successful setting up the service for this device, do not set the
    // other critical settings.
    //

    if (!NT_SUCCESS(Status)) {
        goto Clean0;
    }

    //
    // Set the "ClassGUID" device registry property.
    //

    if (ClassGuid.Buffer != NULL) {

        PiWstrToUnicodeString(&UnicodeValueName, REGSTR_VALUE_CLASSGUID);

        IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                     "PiCriticalCopyCriticalDeviceProperties: "
                     "%wZ: %wZ\n",
                     &UnicodeValueName,
                     &ClassGuid));

        ZwSetValueKey(
            DeviceInstanceHandle,
            &UnicodeValueName,
            TITLE_INDEX_VALUE,
            REG_SZ,
            ClassGuid.Buffer,
            ClassGuid.Length + sizeof(UNICODE_NULL)
            );
    }

    //
    // Set the "LowerFilters" device registry property.
    //

    if (LowerFilters.Buffer != NULL) {

        PiWstrToUnicodeString(&UnicodeValueName, REGSTR_VALUE_LOWERFILTERS);

        IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                     "PiCriticalCopyCriticalDeviceProperties: "
                     "%wZ:\n",
                     &UnicodeValueName));

        ZwSetValueKey(
            DeviceInstanceHandle,
            &UnicodeValueName,
            TITLE_INDEX_VALUE,
            REG_MULTI_SZ,
            LowerFilters.Buffer,
            LowerFilters.Length
            );
    }

    //
    // Set the "UpperFilters" device registry property.
    //

    if (UpperFilters.Buffer != NULL) {

        PiWstrToUnicodeString(&UnicodeValueName, REGSTR_VALUE_UPPERFILTERS);

        IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                     "PiCriticalCopyCriticalDeviceProperties: "
                     "%wZ:\n",
                     &UnicodeValueName));

        ZwSetValueKey(
            DeviceInstanceHandle,
            &UnicodeValueName,
            TITLE_INDEX_VALUE,
            REG_MULTI_SZ,
            UpperFilters.Buffer,
            UpperFilters.Length
            );
    }

    //
    // Set "DeviceType" device registry property.
    //

    if (DeviceType) {

        //
        // Set the "DeviceType" device registry property.
        //

        PiWstrToUnicodeString(&UnicodeValueName, REGSTR_VAL_DEVICE_TYPE);

        IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                     "PiCriticalCopyCriticalDeviceProperties: "
                     "%wZ: %X\n",
                     &UnicodeValueName,
                     DeviceType));

        //
        // Use the status from attempting to set the DeviceType value as the
        // final status of the critical settings copy operation.
        //

        Status =
            ZwSetValueKey(
                DeviceInstanceHandle,
                &UnicodeValueName,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                &DeviceType,
                sizeof(DeviceType)
                );

        if (!NT_SUCCESS(Status)) {

            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PiCriticalCopyCriticalDeviceProperties: "
                         "Error setting %wZ, (Status = %#08lx)\n",
                         &UnicodeValueName, Status));
        }
    }


    //
    // If not successful setting up the DeviceType for this device, do not set the
    // other critical settings.
    //

    if (!NT_SUCCESS(Status)) {
        goto Clean0;
    }

    //
    // Set "Exclusive" device registry property.
    //

    if (Exclusive) {

        //
        // Set the "Exclusive" device registry property.
        //

        PiWstrToUnicodeString(&UnicodeValueName, REGSTR_VAL_DEVICE_EXCLUSIVE);

        IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                     "PiCriticalCopyCriticalDeviceProperties: "
                     "%wZ: %X\n",
                     &UnicodeValueName,
                     Exclusive));

        //
        // Use the status from attempting to set the Exclusive value as the
        // final status of the critical settings copy operation.
        //

        Status =
            ZwSetValueKey(
                DeviceInstanceHandle,
                &UnicodeValueName,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                &Exclusive,
                sizeof(Exclusive)
                );

        if (!NT_SUCCESS(Status)) {

            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PiCriticalCopyCriticalDeviceProperties: "
                         "Error setting %wZ, (Status = %#08lx)\n",
                         &UnicodeValueName, Status));
        }
    }

    //
    // If not successful setting up the Exclusive for this device, do not set 
    // the other critical settings.
    //

    if (!NT_SUCCESS(Status)) {
        goto Clean0;
    }

    //
    // Set "Characteristics" device registry property.
    //

    if (Characteristics) {

        //
        // Set the "Characteristics" device registry property.
        //

        PiWstrToUnicodeString(&UnicodeValueName, REGSTR_VAL_DEVICE_CHARACTERISTICS);

        IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                     "PiCriticalCopyCriticalDeviceProperties: "
                     "%wZ: %X\n",
                     &UnicodeValueName,
                     Characteristics));

        //
        // Use the status from attempting to set the Characteristics value as the
        // final status of the critical settings copy operation.
        //

        Status =
            ZwSetValueKey(
                DeviceInstanceHandle,
                &UnicodeValueName,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                &Characteristics,
                sizeof(Characteristics)
                );

        if (!NT_SUCCESS(Status)) {

            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PiCriticalCopyCriticalDeviceProperties: "
                         "Error setting %wZ, (Status = %#08lx)\n",
                         &UnicodeValueName, Status));
        }
    }


    //
    // If not successful setting up the Characteristics for this device, do not 
    // set the other critical settings.
    //

    if (!NT_SUCCESS(Status)) {
        goto Clean0;
    }

    if (SecurityContext.Buffer) {

        //
        // Set the "Security" device registry property.
        //
        PiWstrToUnicodeString(&UnicodeValueName, REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR);

        IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                     "PiCriticalCopyCriticalDeviceProperties: "
                     "%wZ\n",
                     &UnicodeValueName));

        //
        // Use the status from attempting to set the Security value as the
        // final status of the critical settings copy operation.
        //

        Status =
            ZwSetValueKey(
                DeviceInstanceHandle,
                &UnicodeValueName,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                SecurityContext.Buffer,
                SecurityContext.Size
                );

        if (!NT_SUCCESS(Status)) {

            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PiCriticalCopyCriticalDeviceProperties: "
                         "Error setting %wZ, (Status = %#08lx)\n",
                         &UnicodeValueName, Status));
        }
    }


    //
    // If not successful setting up the Characteristics for this device, do not 
    // set the other critical settings.
    //

    if (!NT_SUCCESS(Status)) {
        goto Clean0;
    }

    //
    // Now, check the critical device entry registry key for the flag that
    // indicates that the device settings are complete, and should be respected
    // by user-mode device installation.  If it exists, set that value on the
    // device instance registry key for the device whose critical settings we
    // are copying.
    //

    keyValueFullInfo = NULL;

    tmpStatus =
        IopGetRegistryValue(
            CriticalDeviceEntryHandle,
            REGSTR_VAL_PRESERVE_PREINSTALL,
            &keyValueFullInfo);

    if (NT_SUCCESS(tmpStatus)) {

        ASSERT(keyValueFullInfo != NULL);
        ASSERT(keyValueFullInfo->Type == REG_DWORD);
        ASSERT(keyValueFullInfo->DataLength == sizeof(ULONG));

        if ((keyValueFullInfo->Type == REG_DWORD) &&
            (keyValueFullInfo->DataLength == sizeof(ULONG))) {

            //
            // Write the value to the device instance registry key.
            //

            PiWstrToUnicodeString(
                &UnicodeValueName,
                REGSTR_VAL_PRESERVE_PREINSTALL);

            tmpStatus =
                ZwSetValueKey(
                    DeviceInstanceHandle,
                    &UnicodeValueName,
                    keyValueFullInfo->TitleIndex,
                    keyValueFullInfo->Type,
                    (PVOID)((PUCHAR)keyValueFullInfo + keyValueFullInfo->DataOffset),
                    keyValueFullInfo->DataLength);

            if (!NT_SUCCESS(tmpStatus)) {
                IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                             "PiCriticalCopyCriticalDeviceProperties: "
                             "Unable to set %wZ value to instance key.\n",
                             &UnicodeValueName));
            }
        }

        ExFreePool(keyValueFullInfo);
    }

  Clean0:

    //
    // Free any allocated unicode strings.
    // (RtlFreeUnicodeString can handle NULL strings)
    //

    RtlFreeUnicodeString(&Service);
    RtlFreeUnicodeString(&ClassGuid);
    RtlFreeUnicodeString(&LowerFilters);
    RtlFreeUnicodeString(&UpperFilters);

    if (SecurityContext.Buffer) {

        ExFreePool(SecurityContext.Buffer);
    }

    return Status;

} // PiCriticalCopyCriticalDeviceProperties



NTSTATUS
PpCriticalProcessCriticalDevice(
    IN  PDEVICE_NODE    DeviceNode
    )

/*++

Routine Description:

    This routine checks the critical device database for a match against one of
    the device's hardware or compatible ids.  If a device is found, then it will
    be assigned a Service, ClassGUID, and potentiall LowerFilters and
    UpperFilters, and based on the contents of the matching database entry.

Arguments:

    DeviceNode -

        Specifies the device node to be processed via the critical device
        database.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS  Status, tmpStatus;
    HANDLE    CriticalDeviceEntryHandle, DeviceInstanceHandle;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInfo;
    UNICODE_STRING  UnicodeValueName;
    ULONG ConfigFlags;

    PAGED_CODE();

    //
    // First, make sure that the critical device database is currently enabled.
    //
    if (!PiCriticalDeviceDatabaseEnabled) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Validate parameters
    //
    if (!ARGUMENT_PRESENT(DeviceNode)) {
        return STATUS_INVALID_PARAMETER;
    }

    CriticalDeviceEntryHandle = NULL;
    DeviceInstanceHandle = NULL;

    //
    // Attempt to open the matching critical device entry key.
    //

    Status =
        PiCriticalOpenCriticalDeviceKey(
            DeviceNode,
            NULL, // use default CriticalDeviceDatabase root key
            &CriticalDeviceEntryHandle
            );

    if (!NT_SUCCESS(Status)) {
        ASSERT(CriticalDeviceEntryHandle == NULL);
        goto Clean0;
    }

    ASSERT(CriticalDeviceEntryHandle != NULL);

    //
    // Open the device instance registry key.
    //

    Status =
        IopDeviceObjectToDeviceInstance(
            DeviceNode->PhysicalDeviceObject,
            &DeviceInstanceHandle,
            KEY_ALL_ACCESS
            );

    if (!NT_SUCCESS(Status)) {
        ASSERT(DeviceInstanceHandle == NULL);
        goto Clean0;
    }

    ASSERT(DeviceInstanceHandle != NULL);

    //
    // Copy critical device entries for this device.  The return status
    // indicates that a Service was successfully set up for this device.  Only
    // in that case should we clear the device of any problems it may have.
    //

    Status =
        PiCriticalCopyCriticalDeviceProperties(
            DeviceInstanceHandle,
            CriticalDeviceEntryHandle
            );

    //
    // NOTE: The Status returned by this routine indicates whether the Service
    // value was successfully copied to the device instance key.  Only f we
    // successfully processed this device as a critical device should we:
    //
    // - attempt pre-installation of settings (should not preinstall a device
    //   that could not be critically installed).
    //
    // - clear the reinstall and failed install config flags, and set the
    //   finish-install configflag (should not attempt to start the device
    //   otherwise).
    //

    if (NT_SUCCESS(Status)) {

        //
        // First, attempt pre-installation of settings for devices matching an
        // entry in the critical device database.
        //

        //
        // Use the matching critical device database entry key for this device
        // as the root of the preinstall database.
        //
        //   i.e. <CriticalDeviceDatabaseRoot>\\<CriticalDeviceEntry>
        //
        // This allows pre-install settings settings to be applied to a device
        // at a specific location, only if it matches some device id.
        //

        tmpStatus =
            PiCriticalPreInstallDevice(
                DeviceNode,
                CriticalDeviceEntryHandle
                );

        if (NT_SUCCESS(tmpStatus)) {
            IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                         "PpCriticalProcessCriticalDevice: "
                         "Pre-installation successfully completed for devnode %#08lx\n",
                         DeviceNode));
        }

        //
        // Next, set the ConfigFlags appropriately.
        //

        //
        // Initialize the ConfigFlags to 0, in case none exist yet.
        //

        ConfigFlags = 0;

        //
        // Retrieve the existing ConfigFlags for the device.
        //

        keyValueFullInfo = NULL;

        tmpStatus =
            IopGetRegistryValue(
                DeviceInstanceHandle,
                REGSTR_VALUE_CONFIG_FLAGS,
                &keyValueFullInfo
                );

        //
        // If ConfigFlags were successfully retrieved, use them instead.
        //

        if (NT_SUCCESS(tmpStatus)) {

            ASSERT(keyValueFullInfo != NULL);

            if (keyValueFullInfo->Type == REG_DWORD && keyValueFullInfo->DataLength == sizeof(ULONG)) {
                ConfigFlags = *(PULONG)KEY_VALUE_DATA(keyValueFullInfo);
            }

            ExFreePool(keyValueFullInfo);
        }

        //
        // Clear the "needs re-install" and "failed install" ConfigFlags.
        //

        ConfigFlags &= ~(CONFIGFLAG_REINSTALL | CONFIGFLAG_FAILEDINSTALL);

        //
        // Installation is not considered complete, so set
        // CONFIGFLAG_FINISH_INSTALL so we will still get a new hw found popup
        // and go through the class installer.
        //

        ConfigFlags |= CONFIGFLAG_FINISH_INSTALL;

        PiWstrToUnicodeString(&UnicodeValueName, REGSTR_VALUE_CONFIG_FLAGS);

        ZwSetValueKey(
            DeviceInstanceHandle,
            &UnicodeValueName,
            TITLE_INDEX_VALUE,
            REG_DWORD,
            &ConfigFlags,
            sizeof(ULONG)
            );

        //
        // Make sure the device does not have any problems relating to
        // either being not configured or not installed.
        //
        ASSERT(!PipDoesDevNodeHaveProblem(DeviceNode) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_NOT_CONFIGURED) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_FAILED_INSTALL) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_REINSTALL));

        PipClearDevNodeProblem(DeviceNode);
    }

  Clean0:

    if (CriticalDeviceEntryHandle != NULL) {
        ZwClose(CriticalDeviceEntryHandle);
    }

    if (DeviceInstanceHandle != NULL) {
        ZwClose(DeviceInstanceHandle);
    }

    return Status;

} // PpCriticalProcessCriticalDevice



//
// Critical Device Database routines related to device pre-installation.
//

NTSTATUS
PiCriticalPreInstallDevice(
    IN  PDEVICE_NODE    DeviceNode,
    IN  HANDLE          PreInstallDatabaseRootHandle  OPTIONAL
    )

/*++

Routine Description:

    This routine attempts to pre-install instance-specific settings for
    non-configured devices that will be started based on information in
    the Plug and Play Critical Device Database (CDDB).

    It is intended to complement the CriticalDeviceDatabase by applying
    instance-specific settings to a device, rather than the hardware-id /
    compatible-id specific settings applied by the CriticalDeviceDatabase.

    Matches for a specific device-instance are made by comparing device location
    information returned by the device and its ancestors with pre-seeded
    database entries of the same format.

Arguments:

    DeviceNode -

        Specifies the device whose settings are to be pre-installed.

    PreInstallDatabaseRootHandle -

        Optionally, specifies a handle to the key that should be considered the
        root of the pre-install database to be searched for this device.

        This may be a handle to the key for the CriticalDeviceDatabase entry
        that matched this device - OR - may be the root of a single database
        that contains pre-install settings for all devices in the system.

        If no handle is supplied, the default global pre-install database is
        used:

            System\\CurrentControlSet\\Control\\CriticalPreInstallDatabase

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS Status, tmpStatus;
    HANDLE PreInstallHandle, DeviceInstanceHandle;
    HANDLE DeviceHardwareKeyHandle, DeviceSoftwareKeyHandle;
    HANDLE PreInstallHardwareKeyHandle, PreInstallSoftwareKeyHandle;
    UNICODE_STRING UnicodeString;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInfo;

    PAGED_CODE();

    //
    // Validate parameters
    //
    if (!ARGUMENT_PRESENT(DeviceNode)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Open the device pre-install settings root key.
    //
    PreInstallHandle = NULL;

    Status =
        PiCriticalOpenDevicePreInstallKey(
            DeviceNode,
            PreInstallDatabaseRootHandle,
            &PreInstallHandle
            );

    if (!NT_SUCCESS(Status)) {
        IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                     "PiCriticalPreInstallDevice: "
                     "No pre-install settings found for devnode %#08lx\n",
                     DeviceNode));
        ASSERT(PreInstallHandle == NULL);
        goto Clean0;
    }

    ASSERT(PreInstallHandle != NULL);

    //
    // Open the pre-install settings Hardware subkey.
    //
    PiWstrToUnicodeString(&UnicodeString, _REGSTR_KEY_PREINSTALL_HARDWARE);

    PreInstallHardwareKeyHandle = NULL;

    Status =
        IopOpenRegistryKeyEx(
            &PreInstallHardwareKeyHandle,
            PreInstallHandle,
            &UnicodeString,
            KEY_READ
            );

    if (NT_SUCCESS(Status)) {

        ASSERT(PreInstallHardwareKeyHandle != NULL);

        //
        // We have hardware settings to pre-install for this device, so open
        // the device's hardware key.
        //
        DeviceHardwareKeyHandle = NULL;

        Status =
            IoOpenDeviceRegistryKey(
                DeviceNode->PhysicalDeviceObject,
                PLUGPLAY_REGKEY_DEVICE,
                KEY_ALL_ACCESS,
                &DeviceHardwareKeyHandle);

        if (NT_SUCCESS(Status)) {

            IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                         "PiCriticalPreInstallDevice: "
                         "DeviceHardwareKeyHandle (%#08lx) successfully opened for devnode %#08lx\n",
                         DeviceHardwareKeyHandle, DeviceNode));
            ASSERT(DeviceHardwareKeyHandle != NULL);

            //
            // Copy the pre-install hardware settings to the device's
            // hardware key.
            //
            // NOTE that we specify that existing hardware settings for the
            // device should NOT be replaced with values from the pre-install
            // database.  This is because:
            //
            //   - If the device is truly being installed from scratch, then it
            //     will have no pre-existing values in this key, and all values
            //     will be copied from the pre-install database anyways.
            //
            //   - If the device does happen to have pre-existing settings, but
            //     happened to get processed by the CDDB for some wacky reason
            //     like it was just missing ConfigFlags, we don't want to
            //     override them, just add to them.
            //
            Status =
                PiCopyKeyRecursive(
                    PreInstallHardwareKeyHandle, // SourceKey
                    DeviceHardwareKeyHandle,     // TargetKey
                    NULL,
                    NULL,
                    FALSE,  // CopyAlways
                    FALSE   // ApplyACLsAlways
                    );

            ZwClose(DeviceHardwareKeyHandle);

        } else {

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PiCriticalPreInstallDevice: "
                         "DeviceHardwareKeyHandle was NOT successfully opened for devnode %#08lx\n",
                         DeviceNode));
            ASSERT(DeviceHardwareKeyHandle == NULL);
        }

        ZwClose(PreInstallHardwareKeyHandle);

    } else {
        IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                     "PiCriticalPreInstallDevice: "
                     "No hardware pre-install settings found for devnode %#08lx\n",
                     DeviceNode));
        ASSERT(PreInstallHardwareKeyHandle == NULL);
    }

    //
    // Open the pre-install settings Software subkey.
    //
    PiWstrToUnicodeString(&UnicodeString, _REGSTR_KEY_PREINSTALL_SOFTWARE);

    PreInstallSoftwareKeyHandle = NULL;

    Status =
        IopOpenRegistryKeyEx(
            &PreInstallSoftwareKeyHandle,
            PreInstallHandle,
            &UnicodeString,
            KEY_READ
            );

    if (NT_SUCCESS(Status)) {

        ASSERT(PreInstallSoftwareKeyHandle != NULL);

        //
        // We have software settings to pre-install for this device, so
        // open/create the device's software key.
        //
        DeviceSoftwareKeyHandle = NULL;

        Status =
            IopOpenOrCreateDeviceRegistryKey(
                DeviceNode->PhysicalDeviceObject,
                PLUGPLAY_REGKEY_DRIVER,
                KEY_ALL_ACCESS,
                TRUE,
                &DeviceSoftwareKeyHandle);

        if (NT_SUCCESS(Status)) {

            IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                         "PiCriticalPreInstallDevice: "
                         "DeviceSoftwareKeyHandle (%#08lx) successfully opened for devnode %#08lx\n",
                         DeviceSoftwareKeyHandle, DeviceNode));
            ASSERT(DeviceSoftwareKeyHandle != NULL);

            //
            // Copy the pre-install software settings to the device's
            // software key.
            //
            // NOTE that we specify that existing software settings for the
            // device should NOT be replaced with values from the pre-install
            // database.  This is because:
            //
            //   - If the device is truly being installed from scratch, then it
            //     will have no pre-existing values in this key, and all values
            //     will be copied from the pre-install database anyways.
            //
            //   - If the device does happen to have pre-existing settings, but
            //     happened to get processed by the CDDB for some wacky reason
            //     like it was just missing ConfigFlags, we don't want to
            //     override them, just add to them.
            //
            Status =
                PiCopyKeyRecursive(
                    PreInstallSoftwareKeyHandle, // SourceKey
                    DeviceSoftwareKeyHandle,     // TargetKey
                    NULL,
                    NULL,
                    FALSE,  // CopyAlways
                    FALSE   // ApplyACLsAlways,
                    );

            ZwClose(DeviceSoftwareKeyHandle);

        } else {

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PiCriticalPreInstallDevice: "
                         "DeviceSoftwareKeyHandle was NOT successfully opened for devnode %#08lx\n",
                         DeviceNode));
            ASSERT(DeviceSoftwareKeyHandle == NULL);
        }

        ZwClose(PreInstallSoftwareKeyHandle);

    } else {
        IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                     "PiCriticalPreInstallDevice: "
                     "No software pre-install settings found for devnode %#08lx\n",
                     DeviceNode));
        ASSERT(PreInstallSoftwareKeyHandle == NULL);
    }

    //
    // Now, check the device pre-install registry key for the flag that
    // indicates that the pre-install settings are complete, and should be
    // respected by user-mode device installation.
    //

    keyValueFullInfo = NULL;

    tmpStatus =
        IopGetRegistryValue(
            PreInstallHandle,
            REGSTR_VAL_PRESERVE_PREINSTALL,
            &keyValueFullInfo);

    if (NT_SUCCESS(tmpStatus)) {

        ASSERT(keyValueFullInfo != NULL);

        //
        // Open the device instance registry key.
        //
        DeviceInstanceHandle = NULL;

        tmpStatus =
            IopDeviceObjectToDeviceInstance(
                DeviceNode->PhysicalDeviceObject,
                &DeviceInstanceHandle,
                KEY_ALL_ACCESS);

        if (NT_SUCCESS(tmpStatus)) {

            ASSERT(DeviceInstanceHandle != NULL);

            //
            // Write the value to the device instance registry key.
            //

            PiWstrToUnicodeString(
                &UnicodeString,
                REGSTR_VAL_PRESERVE_PREINSTALL);

            tmpStatus =
                ZwSetValueKey(
                    DeviceInstanceHandle,
                    &UnicodeString,
                    keyValueFullInfo->TitleIndex,
                    keyValueFullInfo->Type,
                    (PVOID)((PUCHAR)keyValueFullInfo + keyValueFullInfo->DataOffset),
                    keyValueFullInfo->DataLength);

            if (!NT_SUCCESS(tmpStatus)) {
                IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                             "PiCriticalPreInstallDevice: "
                             "Unable to set %wZ value in instance key for devnode %#08lx\n",
                             &UnicodeString, DeviceNode));
            }

            ZwClose(DeviceInstanceHandle);

        } else {
            IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                         "PiCriticalPreInstallDevice: "
                         "Unable to open device instance key for devnode %#08lx\n",
                         DeviceNode));
            ASSERT(DeviceInstanceHandle == NULL);
        }

        ExFreePool(keyValueFullInfo);
    }

    ZwClose(PreInstallHandle);

  Clean0:

    return Status;

} // PiCriticalPreInstallDevice



NTSTATUS
PiCriticalOpenDevicePreInstallKey(
    IN  PDEVICE_NODE    DeviceNode,
    IN  HANDLE          PreInstallDatabaseRootHandle  OPTIONAL,
    OUT PHANDLE         PreInstallHandle
    )

/*++

Routine Description:

    This routine retrieves the registry key containing the pre-install settings
    for the specified device.

Arguments:

    DeviceNode -

        Specifies the device whose pre-install settings are to be retrieved.

    PreInstallDatabaseRootHandle -

        Optionally, specifies a handle to the key that should be considered the
        root of the pre-install database to be searched for this device.

        This may be a handle to the key for the CriticalDeviceDatabase entry
        that matched this device - OR - may be the root of a single database
        that contains pre-install settings for all devices in the system.

    PreInstallHandle -

        Returns a handle to the registry key containing the pre-install settings
        for the specified device.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING UnicodeString;
    HANDLE DatabaseRootHandle = NULL, DevicePathsHandle;
    PWCHAR DeviceLocationStrings = NULL;

    PAGED_CODE();

    //
    // Validate parameters.
    //
    if ((!ARGUMENT_PRESENT(DeviceNode)) ||
        (!ARGUMENT_PRESENT(PreInstallHandle))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize output parameter.
    //
    *PreInstallHandle = NULL;

    if (PreInstallDatabaseRootHandle != NULL) {
        //
        // We were given a root database to be searched.
        //
        DatabaseRootHandle = PreInstallDatabaseRootHandle;

    } else {
        //
        // No root database handle supplied, so we open a key to the default
        // global device pre-install database root.
        //
        PiWstrToUnicodeString(
            &UnicodeString,
            CM_REGISTRY_MACHINE(_REGSTR_PATH_DEFAULT_PREINSTALL_DATABASE_ROOT));

        Status =
            IopOpenRegistryKeyEx(
                &DatabaseRootHandle,
                NULL,
                &UnicodeString,
                KEY_READ);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    ASSERT(DatabaseRootHandle != NULL);

    //
    // Open the DevicePaths subkey of the pre-install database root.
    //
    // This key contains subkeys which are device location paths for devices
    // that may potentially be present on the system.  These are devices whose
    // settings we would like to pre-install, so that they may be used the very
    // first time the device is started, rather than requiring the plug and play
    // config manager, and/or user intervention.
    //
    PiWstrToUnicodeString(&UnicodeString, _REGSTR_KEY_DEVICEPATHS);
    DevicePathsHandle = NULL;

    Status =
        IopOpenRegistryKeyEx(
            &DevicePathsHandle,
            DatabaseRootHandle,
            &UnicodeString,
            KEY_READ);

    //
    // If we opened our own key to the database root, close it now.
    //
    if ((PreInstallDatabaseRootHandle == NULL) &&
        (DatabaseRootHandle != NULL)) {
        ZwClose(DatabaseRootHandle);
    }

    //
    // If unsuccessful opening the DevicePaths key, we're done.
    //
    if (!NT_SUCCESS(Status)) {
        ASSERT(DevicePathsHandle == NULL);
        goto Clean0;
    }

    ASSERT(DevicePathsHandle != NULL);

    //
    // Retrieve the multi-sz list of device location string paths for this
    // device.
    //
    Status =
        PpCriticalGetDeviceLocationStrings(
            DeviceNode,
            &DeviceLocationStrings
            );
    if (!NT_SUCCESS(Status)) {
        ASSERT(DeviceLocationStrings == NULL);
        ZwClose(DevicePathsHandle);
        goto Clean0;
    }

    ASSERT(DeviceLocationStrings != NULL);

    //
    // Open the first matching subkey.
    // No verification callback needed, the first match will do.
    //
    Status =
        PiCriticalOpenFirstMatchingSubKey(
            DeviceLocationStrings,
            DevicePathsHandle,
            KEY_READ,
            (PCRITICAL_MATCH_CALLBACK)NULL,
            PreInstallHandle
            );

    //
    // Close the DevicePaths key.
    //
    ZwClose(DevicePathsHandle);

  Clean0:

    //
    // Free the list of device location path strings, if we received one.
    //
    if (DeviceLocationStrings != NULL) {
        ExFreePool(DeviceLocationStrings);
    }

    return Status;

} // PiCriticalOpenDevicePreInstallKey



NTSTATUS
PiCriticalOpenFirstMatchingSubKey(
    IN  PWCHAR          MultiSzKeyNames,
    IN  HANDLE          RootHandle,
    IN  ACCESS_MASK     DesiredAccess,
    IN  PCRITICAL_MATCH_CALLBACK  MatchingSubkeyCallback  OPTIONAL,
    OUT PHANDLE         MatchingKeyHandle
    )

/*++

Routine Description:

    This routine retrieves the first subkey of the supplied root that matched a
    string in the multi-sz list.

Arguments:

    MultiSzKeyNames -

        Supplies a multi-sz list of possible matching subkey names.

    RootHandle -

        Specifies a handle to the root key that should be searched for a
        matching subkey.

    DesiredAccess -

        Specifies the desired access the matching subkey should be opened with,
        if found.

    MatchingSubkeyCallback -

        Optionally, specifies a callback routine to be called with matching
        subkeys to perform additional verification of potential subkey matches.
        If the callback routine returns FALSE for a potential match, the subkey
        is then considered NOT to be a match, and the search will continue.

    MatchingKeyHandle -

        Specifies the address of a variable to retrieve the open handle to the
        first matching subkey.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS        Status;
    PWSTR           p;
    UNICODE_STRING  UnicodeString;

    PAGED_CODE();

    //
    // Validate parameters.
    //
    if ((!ARGUMENT_PRESENT(MultiSzKeyNames)) ||
        (RootHandle == NULL) ||
        (!ARGUMENT_PRESENT(MatchingKeyHandle))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize output parameter.
    //
    *MatchingKeyHandle = NULL;

    //
    // Start with no match found yet, in case the multi-sz is empty.
    //
    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // Check each string in the multi-sz list.
    //
    for (p = MultiSzKeyNames; *p != UNICODE_NULL; p += wcslen(p)+1) {

        //
        // Attempt to open a corresponding subkey of the root.
        //
        RtlInitUnicodeString(&UnicodeString, p);

        Status =
            IopOpenRegistryKeyEx(
                MatchingKeyHandle,
                RootHandle,
                &UnicodeString,
                DesiredAccess);

        if (NT_SUCCESS(Status)) {

            ASSERT(*MatchingKeyHandle != NULL);

            //
            // We have a conditional match - check the MatchingSubkeyCallback
            // for verification, if we have one.
            //

            if ((ARGUMENT_PRESENT(MatchingSubkeyCallback)) &&
                (!(MatchingSubkeyCallback(*MatchingKeyHandle)))) {

                //
                // Not a match.
                //

                Status = STATUS_OBJECT_NAME_NOT_FOUND;

                //
                // Close the key and continue.
                //

                ZwClose(*MatchingKeyHandle);
                *MatchingKeyHandle = NULL;

                continue;
            }

            //
            // Match!
            //
            break;
        }

        ASSERT(*MatchingKeyHandle == NULL);
        *MatchingKeyHandle = NULL;
    }

    if (NT_SUCCESS(Status)) {
        ASSERT(*MatchingKeyHandle != NULL);
    } else {
        ASSERT(*MatchingKeyHandle == NULL);
    }

    return Status;

} // PiCriticalOpenFirstMatchingSubKey



BOOLEAN
PiCriticalCallbackVerifyCriticalEntry(
    IN  HANDLE          CriticalDeviceEntryHandle
    )

/*++

Routine Description:

    This routine is a callback routine to verify that the specified critical
    device database entry key can be used to supply critical device settings.

Arguments:

    CriticalDeviceEntryHandle -

        Specifies a handle to the registry key containing critical device
        settings for the specified device.

Return Value:

    Returns TRUE if the key conatins valid settings for a matching critical
    device database entry, FALSE otherwise.

--*/

{
    NTSTATUS  Status;
    PKEY_VALUE_FULL_INFORMATION  keyValueFullInfo;
    ULONG     DataType, DataLength;

    PAGED_CODE();

    //
    // Validate parameters.
    //
    if (CriticalDeviceEntryHandle == NULL) {
        return FALSE;
    }

    //
    // For critical device database entries, a match is only a match if it
    // contains a "Service" value.
    //
    keyValueFullInfo = NULL;

    Status =
        IopGetRegistryValue(CriticalDeviceEntryHandle,
                            REGSTR_VALUE_SERVICE,
                            &keyValueFullInfo);

    if (!NT_SUCCESS(Status)) {
        ASSERT(keyValueFullInfo == NULL);
        goto Clean0;
    }

    ASSERT(keyValueFullInfo != NULL);

    DataType = keyValueFullInfo->Type;
    DataLength = keyValueFullInfo->DataLength;

    ExFreePool(keyValueFullInfo);

    //
    // Make sure the returned registry value is a non-null reg sz.
    //
    if ((DataType != REG_SZ) || (DataLength <= sizeof(UNICODE_NULL))) {
        Status = STATUS_UNSUCCESSFUL;
        goto Clean0;
    }

    //
    // so far, so good...
    //

    //
    // For critical device database entries, a match is only a match if it
    // contains a valid "ClassGUID" value - or none at all.
    //
    keyValueFullInfo = NULL;

    Status =
        IopGetRegistryValue(
            CriticalDeviceEntryHandle,
            REGSTR_VALUE_CLASSGUID,
            &keyValueFullInfo
            );

    if (!NT_SUCCESS(Status)) {

        ASSERT(keyValueFullInfo == NULL);

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            //
            // No ClassGUID entry is considered a valid match.
            //
            Status = STATUS_SUCCESS;
        }
        goto Clean0;
    }

    ASSERT(keyValueFullInfo != NULL);

    DataType = keyValueFullInfo->Type;
    DataLength = keyValueFullInfo->DataLength;

    ExFreePool(keyValueFullInfo);

    //
    // Make sure the returned registry value is a reg-sz of the right size.  The
    // data must be at least as the length of the data for a stringified-GUID.
    // No ClassGUID value is also valid, so a null reg-sz ClassGUID entry is
    // also considered a valid match.  Anything else is invalid, and shouldn't
    // be used.
    //
    // NOTE: 01-Dec-2001 : Jim Cavalaris (jamesca)
    //
    //   A ClassGUID value with Data that is too long for a stringified GUID
    //   will actually still be considered valid.  We should fix this to
    //   consider only valid stringified GUIDs, but this is way this was done
    //   previously, so we won't change it for this release.  Something to
    //   consider in the future.
    //
    if ((DataType != REG_SZ) ||
        ((DataLength < (GUID_STRING_LEN*sizeof(WCHAR)-sizeof(UNICODE_NULL))) &&
         (DataLength > sizeof(UNICODE_NULL)))) {
        Status = STATUS_UNSUCCESSFUL;
        goto Clean0;
    }

  Clean0:

    return ((BOOLEAN)NT_SUCCESS(Status));

} // PiCriticalCallbackVerifyCriticalEntry



NTSTATUS
PpCriticalGetDeviceLocationStrings(
    IN  PDEVICE_NODE    DeviceNode,
    OUT PWCHAR         *DeviceLocationStrings
    )

/*++

Routine Description:

    This routine retrieves the device location string for a device node.

Arguments:

    DeviceNode -

        Specifies the device whose location strings are to be retrieved.

    DeviceLocationStrings -

        Returns a multi-sz string of the device location path strings, composed
        from the set of location strings returned from each device in the
        anscestry of the specified device.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_NODE deviceNode;

    ULONG  QueriedLocationStringsArraySize;
    PWSTR *QueriedLocationStrings = NULL;
    PULONG QueriedLocationStringsCount = NULL;

    PNP_LOCATION_INTERFACE LocationInterface;
    PWSTR TempMultiSz;
    ULONG TempMultiSzLength;

    PWSTR p, pdlp;
    ULONG LongestStringLengthAtLevel;
    ULONG FinalStringLevel, i;

    ULONG DeviceLocationPathMultiSzStringCount;
    ULONG DeviceLocationPathMultiSzLength;
    PWCHAR DeviceLocationPathMultiSz = NULL;

    ULONG CombinationsRemaining, CombinationEnumIndex;
    ULONG MultiSzIndex, MultiSzLookupIndex, StringLength;

    PAGED_CODE();

    //
    // Validate parameters.
    //
    if ((!ARGUMENT_PRESENT(DeviceNode)) ||
        (!ARGUMENT_PRESENT(DeviceLocationStrings))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize out parameters.
    //
    *DeviceLocationStrings = NULL;

    //
    // We should NEVER have to query for the location of the root devnode.
    //
    if (DeviceNode == IopRootDeviceNode) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Count the number of devnodes in the ancestry of the device to find out
    // the max number of location string sets we may have to query for.
    //
    QueriedLocationStringsArraySize = 0;
    for (deviceNode = DeviceNode;
         deviceNode != IopRootDeviceNode;
         deviceNode = deviceNode->Parent) {
        QueriedLocationStringsArraySize++;
    }

    ASSERT(QueriedLocationStringsArraySize > 0);

    //
    // Allocate and initialize an array of string buffer pointers for all
    // devices in the ancestry, and a corresponding array for the number of
    // strings retrieved for each device.
    //
    QueriedLocationStrings =
        (PWSTR*)ExAllocatePool(PagedPool,
                               QueriedLocationStringsArraySize*sizeof(PWSTR));

    if (QueriedLocationStrings == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean0;
    }

    RtlZeroMemory(QueriedLocationStrings,
                  QueriedLocationStringsArraySize*sizeof(PWSTR));


    QueriedLocationStringsCount =
        (ULONG*)ExAllocatePool(PagedPool,
                               QueriedLocationStringsArraySize*sizeof(ULONG));

    if (QueriedLocationStringsCount == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean0;
    }

    RtlZeroMemory(QueriedLocationStringsCount,
                  QueriedLocationStringsArraySize*sizeof(ULONG));

    //
    // Starting at the target device, walk up the devnode tree, retrieving the
    // set of location strings for all ancestors up to (but not including) the
    // root devnode.  We'll stop when we've reached the top of the tree, or when
    // some intermediate device has explicitly declared that the translation is
    // complete.
    //
    i = 0;

    //
    // Along the way, we count the total number of string combinations that can
    // be formed by taking a single string from the multi-sz list at each level.
    // This is simply the product of the number of string elements in the
    // multi-sz list at each level.
    //
    DeviceLocationPathMultiSzStringCount = 1;

    //
    // Also along the way, calculate the length (in chars) of the longest device
    // location path that can be generated from all combinations.  This is just
    // the sum of the longest string at each level (LongestStringLengthAtLevel
    // below), plus the necessary path component separator strings and NULL
    // terminating character.
    //
    //
    //            WARNING!! EXCESSIVELY VERBOSE COMMENT AHEAD!!
    //
    // NOTE: 27-Nov-2001 : Jim Cavalaris (jamesca)
    //
    //   We use this length to calculate the length of the buffer required to
    //   hold the entire multi-sz list of device location paths ASSUMING ALL
    //   GENERATED STRINGS ARE EQUALLY AS LONG.  This is an UPPER-BOUND, so we
    //   may end up allocating more memory than we actually need.
    //
    //   This should be ok, since in the ideal (and assumed to be most-common)
    //   case, only one location string will ever be returned per device - in
    //   which case this calculation will be exactly the size required.
    //
    //   In the event that multiple strings are returned per device, we should
    //   expect these strings to all be relatively short, and equal (or similar)
    //   in length.  In that case, this calculation will be exactly the size
    //   required (or similar).
    //
    //   We also currently do not expect to have to query many devices in the
    //   ancestry to complete the translation, so we shouldn't event expect too
    //   many combinations.
    //
    //   These are our assumptions, so consider yourself warned!  If any of
    //   these change such that we would need to allocate an excessive amount of
    //   memory, you will want to either run through the same algorithm the
    //   device location path generation code runs through just to calculate the
    //   exact size, or find some way to enumerate the device location path
    //   combinations incrementally.
    //
    DeviceLocationPathMultiSzLength = 0;

    for (deviceNode = DeviceNode;
         deviceNode != IopRootDeviceNode;
         deviceNode = deviceNode->Parent) {

        //
        // Query the device for the location interface.
        //
        Status = PiQueryInterface(deviceNode->PhysicalDeviceObject,
                                  &GUID_PNP_LOCATION_INTERFACE,
                                  PNP_LOCATION_INTERFACE_VERSION,
                                  sizeof(PNP_LOCATION_INTERFACE),
                                  (PINTERFACE)&LocationInterface);

        if (!NT_SUCCESS(Status)) {
            //
            // If the location interface was not available for some device
            // before translation is complete, the entire operation is
            // unsuccessful.
            //
            ASSERT((Status == STATUS_NOT_SUPPORTED) || (Status == STATUS_INSUFFICIENT_RESOURCES));
            goto Clean0;
        }

        //
        // If the location interface is supported, the required interface
        // routines must be supplied.
        //
        ASSERT(LocationInterface.InterfaceReference != NULL);
        ASSERT(LocationInterface.InterfaceDereference != NULL);
        ASSERT(LocationInterface.GetLocationString != NULL);

        if (LocationInterface.GetLocationString != NULL) {

            //
            // Initialize the location string.
            //
            TempMultiSz = NULL;

            //
            // Get the set of location strings for this device.
            //
            Status = LocationInterface.GetLocationString(
                LocationInterface.Context,
                &TempMultiSz);

            if (NT_SUCCESS(Status)) {
                //
                // If successful, the caller must have supplied us with a
                // buffer.
                //
                ASSERT(TempMultiSz != NULL);

                //
                // If not, the call was not really successful.
                //
                if (TempMultiSz == NULL) {
                    Status = STATUS_NOT_SUPPORTED;
                }
            }

            if (NT_SUCCESS(Status)) {
                //
                // If a multi-sz list of device location strings was returned,
                // inspect it, and keep note of a few things.  Specifically, the
                // number of strings in the multi-sz list, the length of the
                // multi-sz list, and the length of the longest string in the
                // list.
                //
                QueriedLocationStringsCount[i] = 0;
                TempMultiSzLength = 0;
                LongestStringLengthAtLevel = 0;

                for (p = TempMultiSz; *p != UNICODE_NULL; p += wcslen(p)+1) {
                    //
                    // Count the number of strings at this level (in this
                    // multi-sz list).
                    //
                    QueriedLocationStringsCount[i]++;

                    //
                    // Determine the length (in chars) of the multi-sz list so
                    // we can allocate our own buffer, and copy it.
                    //
                    TempMultiSzLength += (ULONG)(wcslen(p) + 1);

                    //
                    // Also determine the length of the longest string of all
                    // strings in this multi-sz list so we can estimate the
                    // length required for all device location path
                    // combinations.
                    //
                    StringLength = (ULONG)wcslen(p);
                    if (StringLength > LongestStringLengthAtLevel) {

                        LongestStringLengthAtLevel = StringLength;
                    }
                }

                ASSERT(QueriedLocationStringsCount[i] > 0);
                ASSERT(TempMultiSzLength > 0);
                ASSERT(LongestStringLengthAtLevel > 0);

                //
                // Include the length of the double NULL-terminating character.
                //
                TempMultiSzLength += 1;

                //
                // After analyzing the device location strings at each level,
                // update the number of device path combinations possible by
                // simply multiplying the combinations possible so far by the
                // number of strings retrieved for this level (in this multi-sz list).
                //
                DeviceLocationPathMultiSzStringCount *= QueriedLocationStringsCount[i];

                //
                // Also, update the length of the longest device location path
                // possible by adding the length of the longest string available
                // at this level.
                //
                DeviceLocationPathMultiSzLength += LongestStringLengthAtLevel;

                //
                // Make our own copy of the caller supplied multi-sz list of
                // device location strings.
                //
                QueriedLocationStrings[i] =
                    (PWSTR)ExAllocatePool(PagedPool,
                                          TempMultiSzLength*sizeof(WCHAR));

                if (QueriedLocationStrings[i] != NULL) {
                    //
                    // Note on array element ordering - since we start at the
                    // target devnode and walk up the chain of parents, we don't
                    // yet know just how high up the translation will go.  We
                    // add children towards the front of the array, so if
                    // translation is complete before every ancestor is queried,
                    // we'll just end up with some empty entries at the end.
                    //
                    RtlCopyMemory(QueriedLocationStrings[i],
                                  TempMultiSz,
                                  TempMultiSzLength*sizeof(WCHAR));
                    i++;

                } else {
                    //
                    // Unable to allocate a buffer for our own list of pointers.
                    //
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                //
                // Free the callee-allocated buffer.
                //
                ExFreePool(TempMultiSz);
                TempMultiSz = NULL;

            } else {
                //
                // If unsuccessful, make sure no location string was returned by
                // the interface routine.
                //
                ASSERT(TempMultiSz == NULL);

                //
                // If the driver failed the call, but still allocated memory for
                // us anyways, we'll clean up after it.
                //
                if (TempMultiSz != NULL) {
                    ExFreePool(TempMultiSz);
                    TempMultiSz = NULL;
                }
            }

        } else {
            //
            // If a GetLocationString location interface routine was not
            // supplied with the interface for some device before translation is
            // complete, the entire operation is unsuccessful.
            //
            // Fall through to dereference the interface below, then exit.
            //
            Status = STATUS_UNSUCCESSFUL;
        }

        //
        // Dereference the Location Interface.
        //
        if (LocationInterface.InterfaceDereference != NULL) {
            LocationInterface.InterfaceDereference(LocationInterface.Context);
        }

        if (!NT_SUCCESS(Status)) {
            //
            // If unsuccessful while requesting location information for some
            // device before translation was complete, the entire operation is
            // unsuccessful.
            //
            goto Clean0;

        } else if ((Status == STATUS_TRANSLATION_COMPLETE) ||
                   (i == QueriedLocationStringsArraySize)) {
            //
            // If successful, and the last device queried specifically indicated
            // the end of the translation - OR - this is the last device in the
            // ancestry, and therefore translation is explicitly complete, note
            // translation is complete.
            //
            Status = STATUS_TRANSLATION_COMPLETE;

            //
            // Account for the length of the NULL-terminating character in our
            // longest-length single string component estimate.
            //
            DeviceLocationPathMultiSzLength += 1;

            //
            // Stop walking up the device tree.
            //
            break;

        }

        //
        // Success so far, but we still need to query more devices for
        // location strings.
        //
        ASSERT(i < QueriedLocationStringsArraySize);

        //
        // Account for the length of a location path separator after every
        // path component but the last.
        //
        DeviceLocationPathMultiSzLength +=
            IopConstStringLength(_CRITICAL_DEVICE_LOCATION_PATH_SEPARATOR_STRING);
    }

    //
    // The location information of every device in the ancestry has been queried
    // successfully.
    //
    ASSERT(Status == STATUS_TRANSLATION_COMPLETE);

    if (NT_SUCCESS(Status)) {
        Status = STATUS_SUCCESS;
    } else {
        goto Clean0;
    }

    //
    // Make sure we queried at least one device.
    //
    ASSERT(i > 0);

    //
    // Allocate a buffer large enough to assume that all device location path
    // string combinations are as long as the longest device location path
    // string formed.  Also account for the double NULL-terminating character.
    //
    DeviceLocationPathMultiSzLength *= DeviceLocationPathMultiSzStringCount;
    DeviceLocationPathMultiSzLength += 1;

    DeviceLocationPathMultiSz =
        (PWCHAR)ExAllocatePool(PagedPool,
                               DeviceLocationPathMultiSzLength*sizeof(WCHAR));

    if (DeviceLocationPathMultiSz == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean0;
    }

    RtlZeroMemory(DeviceLocationPathMultiSz,
                  DeviceLocationPathMultiSzLength*sizeof(WCHAR));

    //
    // We should now have an array of multi-sz strings returned by the location
    // string interface routine for a set of devices in the ancestry of the
    // specified device.  From these multi-sz strings, we now need to build all
    // possible device paths.
    //

    //
    // First, determine where the first string in the device path is stored.
    // Since we stored these in the array in order, starting with the child
    // device, the last non-NULL string placed in the array (i - 1) is the most
    // significant location string.
    //
    FinalStringLevel = i-1;
    ASSERT(QueriedLocationStrings[FinalStringLevel] != NULL);
    ASSERT(QueriedLocationStringsCount[FinalStringLevel] > 0);

    //
    // Build all string combinations by enumerating the total number of possible
    // combinations, and picking the appropriate string element from each
    // multi-sz list on each iteration.
    //
    pdlp = DeviceLocationPathMultiSz;

    for (CombinationEnumIndex = 0;
         CombinationEnumIndex < DeviceLocationPathMultiSzStringCount;
         CombinationEnumIndex++) {

        //
        // Start with the multi-sz list at the FinalStringLevel, and work down
        // to level 0.
        //
        i = FinalStringLevel;

        //
        // When starting from level 0, the number of combinations remaining is
        // simply the total number of combinations that can be formed from all
        // levels.  The number of combination remaining will be adjusted after
        // selecting a string from each subsequent level, by discounting the
        // combinations that the level contributed.
        //
        CombinationsRemaining = DeviceLocationPathMultiSzStringCount;

        for ( ; ; ) {

            ASSERT(CombinationsRemaining != 0);

            //
            // Calculate the index of the string in the multi-sz list at this
            // level that is needed by this enumeration.
            //
            if (CombinationEnumIndex == 0) {

                //
                // On the first enumeration, just pick the first element from
                // every level.
                //
                MultiSzLookupIndex = 0;

            } else {

                //
                // NOTE: 27-Nov-2001 : Jim Cavalaris (jamesca)
                //
                // For subsequent enumerations, the element to pick at each
                // level to generate this enumeration's device location path is
                // calculated based on:
                //
                // - the enumeration element we require,
                // - the number of combinations remaining to be generated,
                // - the number of elements to choose from at this level.
                //
                // This will will build all possible combinations of device
                // location paths, enumerating elements from the least
                // significant device (the target device) to the most
                // significant device (tranlstaion complete), considering the
                // the order of the strings at a particular level have been
                // placed in the multi-sz list in order of decreasing relevance
                // (i.e. most relevant location string for a device first).
                //

                //
                // - CombinationsRemaining is the number of complete elements
                //   that must be built from the selections available from all
                //   levels above the current level.
                //
                // - (CombinationsRemaining / QueriedLocationStringsCount[i])
                //   describes the number of iterations through each element at
                //   the current level that are required before selecting the next
                //   element.
                //
                // - dividing that number into the index of the current
                //   enumeration gives the absolute index of the element in the
                //   expanded version of the selections at that level.
                //
                // - mod by the number of elements actually at this level to
                //   indicate which one to select.
                //

                MultiSzLookupIndex =
                    (CombinationEnumIndex /
                     (CombinationsRemaining / QueriedLocationStringsCount[i])) %
                    QueriedLocationStringsCount[i];

                //
                // (you may just want to trust me on this one.)
                //
            }

            //
            // Find the calculated string.
            //
            MultiSzIndex = 0;
            for (p = QueriedLocationStrings[i]; MultiSzIndex < MultiSzLookupIndex; p += wcslen(p)+1) {
                MultiSzIndex++;
                ASSERT(*p != UNICODE_NULL);
                ASSERT(MultiSzIndex < QueriedLocationStringsCount[i]);
            }

            //
            // Append the string to the buffer.
            //
            RtlCopyMemory(pdlp, p, wcslen(p)*sizeof(WCHAR));
            pdlp += wcslen(p);

            if (i == 0) {
                //
                // This is the last level.  NULL terminate this device location
                // path combination string just formed.
                //
                *pdlp = UNICODE_NULL;
                pdlp += 1;
                break;
            }

            //
            // If there are still more levels to process, append the device
            // location path separator string.
            //
            RtlCopyMemory(pdlp,
                          _CRITICAL_DEVICE_LOCATION_PATH_SEPARATOR_STRING,
                          IopConstStringSize(_CRITICAL_DEVICE_LOCATION_PATH_SEPARATOR_STRING));
            pdlp += IopConstStringLength(_CRITICAL_DEVICE_LOCATION_PATH_SEPARATOR_STRING);

            //
            // Adjust the total remaining number of string combinations that are
            // possible to form from the string lists at the remaining levels.
            //
            CombinationsRemaining /= QueriedLocationStringsCount[i];

            //
            // Process the next level down.
            //
            i--;
        }
    }

    //
    // Double-NULL terminate the entire device location path multi-sz list.
    //
    *pdlp = UNICODE_NULL;

    //
    // The multi-sz list of device location paths for this device has been built
    // successfully.
    //

    *DeviceLocationStrings = DeviceLocationPathMultiSz;

  Clean0:

    //
    // Free any memory we may have allocated along the way.
    //
    if (QueriedLocationStrings != NULL) {
        ASSERT(QueriedLocationStringsArraySize > 0);
        for (i = 0; i < QueriedLocationStringsArraySize; i++) {
            if (QueriedLocationStrings[i] != NULL) {
                ExFreePool(QueriedLocationStrings[i]);
            }
        }
        ExFreePool(QueriedLocationStrings);
    }
    if (QueriedLocationStringsCount != NULL) {
        ASSERT(QueriedLocationStringsArraySize > 0);
        ExFreePool(QueriedLocationStringsCount);
    }

    //
    // If unsuccesful, make sure we don't return a buffer to the caller.
    //
    if (!NT_SUCCESS(Status)) {

        ASSERT(*DeviceLocationStrings == NULL);

        ASSERT(DeviceLocationPathMultiSz == NULL);
        if (DeviceLocationPathMultiSz != NULL) {
            ExFreePool(DeviceLocationPathMultiSz);
        }

    } else {
        ASSERT(*DeviceLocationStrings != NULL);
    }

    return Status;

} // PpCriticalGetDeviceLocationStrings



//
// Generic synchronous query interface routine
// (may be moved from this as a public utility routine as needed)
//


NTSTATUS
PiQueryInterface(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  CONST GUID *    InterfaceGuid,
    IN  USHORT          InterfaceVersion,
    IN  USHORT          InterfaceSize,
    OUT PINTERFACE      Interface
    )

/*++

Routine Description:

    Queries the specified device for the requested interface.

Arguments:

    DeviceObject -
        Specifies a device object in the stack to query.
        The query-interface irp will be sent to the top of the stack.

    InterfaceGuid -
        The GUID of the interface requested.

    InterfaceVersion -
        The version of the interface requested.

    InterfaceSize -
        The size of the interface requested.

    Interface -
        The place in which to return the interface.

Return Value:

    Returns STATUS_SUCCESS if the interface was retrieved, else an error.

--*/

{
    NTSTATUS            Status;
    KEVENT              Event;
    PDEVICE_OBJECT      deviceObject;
    IO_STATUS_BLOCK     IoStatusBlock;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpStackNext;

    PAGED_CODE();

    //
    // There is no file object associated with this Irp, so the event may be located
    // on the stack as a non-object manager object.
    //

    KeInitializeEvent(&Event, NotificationEvent, FALSE);


    //
    // Get a pointer to the topmost device object in the stack of devices.
    //
    deviceObject = IoGetAttachedDeviceReference(DeviceObject);

    Irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        deviceObject,
        NULL,
        0,
        NULL,
        &Event,
        &IoStatusBlock);

    if (Irp) {
        Irp->RequestorMode = KernelMode;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IrpStackNext = IoGetNextIrpStackLocation(Irp);

        //
        // Create an interface query out of the Irp.
        //
        IrpStackNext->MinorFunction = IRP_MN_QUERY_INTERFACE;
        IrpStackNext->Parameters.QueryInterface.InterfaceType = (GUID*)InterfaceGuid;
        IrpStackNext->Parameters.QueryInterface.Size = InterfaceSize;
        IrpStackNext->Parameters.QueryInterface.Version = InterfaceVersion;
        IrpStackNext->Parameters.QueryInterface.Interface = (PINTERFACE)Interface;
        IrpStackNext->Parameters.QueryInterface.InterfaceSpecificData = NULL;

        Status = IoCallDriver(deviceObject, Irp);

        if (Status == STATUS_PENDING) {
            //
            // This waits using KernelMode, so that the stack, and therefore the
            // event on that stack, is not paged out.
            //
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            Status = IoStatusBlock.Status;
        }

    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ObDereferenceObject(deviceObject);

    return Status;

} // PpQueryInterface



//
// Recursive registry key/value copy utility routine.
// (may be moved from this as a public utility routine as needed)
//


NTSTATUS
PiCopyKeyRecursive(
    IN  HANDLE          SourceKeyRootHandle,
    IN  HANDLE          TargetKeyRootHandle,
    IN  PWSTR           SourceKeyPath   OPTIONAL,
    IN  PWSTR           TargetKeyPath   OPTIONAL,
    IN  BOOLEAN         CopyValuesAlways,
    IN  BOOLEAN         ApplyACLsAlways
    )

/*++

Routine Description:

    This routine recursively copies a source key to a target key.  Any new keys
    that are created will receive the same security that is present on the
    source key.

Arguments:

    SourceKeyRootHandle -

        Handle to root source key

    TargetKeyRootHandle -

        Handle to root target key

    SourceKeyPath -

        Source key relative path to the subkey which needs to be recursively
        copied.  If this is NULL, SourceKeyRootHandle is the key from which the
        recursive copy is to be done.

    TargetKeyPath -

        Target root key relative path to the subkey which needs to be
        recursively copied.  if this is NULL, TargetKeyRootHandle is the key from
        which the recursive copy is to be done.

    CopyValuesAlways -

        If FALSE, this routine doesn't copy values which are already there on
        the target tree.

    ApplyACLsAlways -

        If TRUE, attempts to copy ACLs to existing registry keys.  Otherwise,
        the ACL of the source keys are only applied to new registry keys.

Return Value:

    NTSTATUS code.

Notes:

    Partially based on the recursive key copy routine implemented for text-mode
    setup, setupdd!SppCopyKeyRecursive.

--*/

{
    NTSTATUS             Status = STATUS_SUCCESS;
    HANDLE               SourceKeyHandle = NULL, TargetKeyHandle = NULL;
    OBJECT_ATTRIBUTES    ObjaSource, ObjaTarget;
    UNICODE_STRING       UnicodeStringSource, UnicodeStringTarget, UnicodeStringValue;
    NTSTATUS             TempStatus;
    ULONG                ResultLength, Index;
    PSECURITY_DESCRIPTOR Security = NULL;

    PKEY_FULL_INFORMATION KeyFullInfoBuffer;
    ULONG MaxNameLen, MaxValueNameLen;
    PKEY_VALUE_FULL_INFORMATION ValueFullInfoBuffer;

    PVOID  KeyInfoBuffer;
    PKEY_BASIC_INFORMATION KeyBasicInfo;

    PVOID ValueInfoBuffer;
    PKEY_VALUE_BASIC_INFORMATION ValueBasicInfo;

    PAGED_CODE();

    //
    // Get a handle to the source key.
    //

    if (!ARGUMENT_PRESENT(SourceKeyPath)) {
        //
        // No path supplied; make sure that we at least have a source root key.
        //
        ASSERT(SourceKeyRootHandle != NULL);

        if (SourceKeyRootHandle == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto Clean0;
        }

        //
        // Use source root as the source key.
        //
        SourceKeyHandle = SourceKeyRootHandle;

    } else {
        //
        // Open the specified source key path off the root.
        // SourceKeyRootHandle may be NULL if SourceKeyPath is a fully qualified
        // registry path.
        //
        RtlInitUnicodeString(
            &UnicodeStringSource,
            SourceKeyPath);

        InitializeObjectAttributes(
            &ObjaSource,
            &UnicodeStringSource,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            SourceKeyRootHandle,
            (PSECURITY_DESCRIPTOR)NULL);

        Status =
            ZwOpenKey(
                &SourceKeyHandle,
                KEY_READ,
                &ObjaSource);

        if (!NT_SUCCESS(Status)) {
            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PiCopyKeyRecursive: unable to open key %ws in the source hive (%lx)\n",
                         SourceKeyPath, Status));
            goto Clean0;
        }
    }

    //
    // Should have source key now.
    //
    ASSERT(SourceKeyHandle != NULL);

    //
    // Next, get the security descriptor from the source key so we can create
    // the target key with the correct ACL.
    //
    TempStatus =
        ZwQuerySecurityObject(
            SourceKeyHandle,
            DACL_SECURITY_INFORMATION,
            NULL,
            0,
            &ResultLength);

    if (TempStatus == STATUS_BUFFER_TOO_SMALL) {

        Security =
            (PSECURITY_DESCRIPTOR)ExAllocatePool(PagedPool,
                                                 ResultLength);

        if (Security != NULL) {

            TempStatus =
                ZwQuerySecurityObject(
                    SourceKeyHandle,
                    DACL_SECURITY_INFORMATION,
                    Security,
                    ResultLength,
                    &ResultLength);

            if (!NT_SUCCESS(TempStatus)) {
                ExFreePool(Security);
                Security = NULL;
            }
        }
    }

    if (Security == NULL) {
        //
        // We'll continue the copy, but won't be able to apply the source ACL to
        // the target.
        //
        IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                     "PiCopyKeyRecursive: unable to query security for key %ws in the source hive (%lx)\n",
                     SourceKeyPath, TempStatus));
    }


    //
    // Get a handle to the target key.
    //

    if (!ARGUMENT_PRESENT(TargetKeyPath)) {
        //
        // No path supplied; make sure that we at least have a target root key.
        //
        ASSERT(TargetKeyRootHandle != NULL);

        if (TargetKeyRootHandle == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto Clean0;
        }

        //
        // No path supplied; use target root as the target key.
        //
        TargetKeyHandle = TargetKeyRootHandle;

    } else {
        //
        // Attempt to open (not create) the target key first.
        // TargetKeyRootHandle may be NULL if TargetKeyPath is a fully qualified
        // registry path.
        //
        RtlInitUnicodeString(
            &UnicodeStringTarget,
            TargetKeyPath);

        InitializeObjectAttributes(
            &ObjaTarget,
            &UnicodeStringTarget,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            TargetKeyRootHandle,
            (PSECURITY_DESCRIPTOR)NULL);

        Status =
            ZwOpenKey(
                &TargetKeyHandle,
                KEY_ALL_ACCESS,
                &ObjaTarget);

        if (!NT_SUCCESS(Status)) {
            //
            // Assume that failure was because the key didn't exist.
            //
            ASSERT(Status == STATUS_OBJECT_NAME_NOT_FOUND);

            //
            // If we can't open the key because it doesn't exist, then we'll
            // create it and apply the security present on the source key (if
            // available).
            //
            // NOTE: 01-Dec-2001 : Jim Cavalaris (jamesca)
            //
            // Security attributes of the source key are always applied to the
            // newly created target key root, rather than inherited from the
            // target key root handle - irespective of the ApplyACLsAlways
            // parameter.  This may not be desired in all cases!
            //
            ObjaTarget.SecurityDescriptor = Security;

            Status =
                ZwCreateKey(
                    &TargetKeyHandle,
                    KEY_ALL_ACCESS,
                    &ObjaTarget,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    NULL);

            if (!NT_SUCCESS(Status)) {
                IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                             "PiCopyKeyRecursive: unable to create target key %ws(%lx)\n",
                             TargetKeyPath, Status));
                goto Clean0;
            }

        } else if (ApplyACLsAlways) {
            //
            // Key already exists - apply the source ACL to the target.
            //
            TempStatus =
                ZwSetSecurityObject(
                    TargetKeyHandle,
                    DACL_SECURITY_INFORMATION,
                    Security);

            if (!NT_SUCCESS(TempStatus)) {
                //
                // Unable to apply source ACL to target.
                //
                IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                             "PiCopyKeyRecursive: unable to copy ACL to existing key %ws(%lx)\n",
                             TargetKeyPath, TempStatus));
            }
        }
    }

    //
    // Should have target key now.
    //
    ASSERT(TargetKeyHandle != NULL);

    //
    // Query the source key to determine the size of the buffer required to
    // enumerated the longest key and value names.  If successful, we are
    // responsible for freeing the returned buffer.
    //
    KeyFullInfoBuffer = NULL;

    Status =
        IopGetRegistryKeyInformation(
            SourceKeyHandle,
            &KeyFullInfoBuffer);

    if (!NT_SUCCESS(Status)) {
        ASSERT(KeyFullInfoBuffer == NULL);
        goto Clean0;
    }

    ASSERT(KeyFullInfoBuffer != NULL);

    //
    // Note the longest subkey name and value name length for the source key.
    //
    MaxNameLen = KeyFullInfoBuffer->MaxNameLen + 1;
    MaxValueNameLen = KeyFullInfoBuffer->MaxValueNameLen + 1;

    ExFreePool(KeyFullInfoBuffer);

    //
    // Allocate a key info buffer large enough to hold the basic information for
    // the enumerated key with the longest name.
    //
    KeyInfoBuffer =
        (PVOID)ExAllocatePool(PagedPool,
                              sizeof(KEY_BASIC_INFORMATION) +
                              (MaxNameLen*sizeof(WCHAR)));
    if (KeyInfoBuffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean0;
    }

    KeyBasicInfo = (PKEY_BASIC_INFORMATION)KeyInfoBuffer;

    for (Index = 0; ; Index++) {

        //
        // Enumerate source subkeys.
        //
        Status =
            ZwEnumerateKey(
                SourceKeyHandle,
                Index,
                KeyBasicInformation,
                KeyBasicInfo,
                sizeof(KEY_BASIC_INFORMATION)+(MaxNameLen*sizeof(WCHAR)),
                &ResultLength);

        if (!NT_SUCCESS(Status)) {

            //
            // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
            // was not enough room for even the fixed portions of the structure.
            // Since we queried the key for the MaxNameLength prior to
            // allocating, we shouldn't get STATUS_BUFFER_OVERFLOW either.
            //
            ASSERT(Status != STATUS_BUFFER_TOO_SMALL);
            ASSERT(Status != STATUS_BUFFER_OVERFLOW);

            if (Status == STATUS_NO_MORE_ENTRIES) {
                //
                // Finished enumerating keys.
                //
                Status = STATUS_SUCCESS;

            } else {
                //
                // Some other error while enumerating keys.
                //
                if (ARGUMENT_PRESENT(SourceKeyPath)) {
                    IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                                 "PiCopyKeyRecursive: unable to enumerate subkeys in key %ws(%lx)\n",
                                 SourceKeyPath, Status));
                } else {
                    IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                                 "PiCopyKeyRecursive: unable to enumerate subkeys in root key(%lx)\n",
                                 Status));
                }
            }
            break;
        }

        //
        // NULL-terminate the subkey name just in case.
        //
        KeyBasicInfo->Name[KeyBasicInfo->NameLength/sizeof(WCHAR)] = UNICODE_NULL;

        //
        // Recursively create the subkey in the target key.
        //
        Status =
            PiCopyKeyRecursive(
                SourceKeyHandle,
                TargetKeyHandle,
                KeyBasicInfo->Name,
                KeyBasicInfo->Name,
                CopyValuesAlways,
                ApplyACLsAlways);

        if (!NT_SUCCESS(Status)) {
            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PiCopyKeyRecursive: unable to copy subkey recursively in key %ws(%lx)\n",
                         KeyBasicInfo->Name, Status));
            break;
        }
    }

    //
    // Free the key info buffer.
    //
    ASSERT(KeyInfoBuffer);
    ExFreePool(KeyInfoBuffer);
    KeyInfoBuffer = NULL;

    //
    // Stop copying if we encountered some error along the way.
    //
    if (!NT_SUCCESS(Status)) {
        goto Clean0;
    }


    //
    // Allocate a value name info buffer large enough to hold the basic value
    // information for the enumerated value with the longest name.
    //
    ValueInfoBuffer =
        (PVOID)ExAllocatePool(PagedPool,
                              sizeof(KEY_VALUE_FULL_INFORMATION) +
                              (MaxValueNameLen*sizeof(WCHAR)));
    if (ValueInfoBuffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean0;
    }


    ValueBasicInfo = (PKEY_VALUE_BASIC_INFORMATION)ValueInfoBuffer;

    for (Index = 0; ; Index++) {

        //
        // Enumerate source key values.
        //
        Status =
            ZwEnumerateValueKey(
                SourceKeyHandle,
                Index,
                KeyValueBasicInformation,
                ValueBasicInfo,
                sizeof(KEY_VALUE_FULL_INFORMATION) + (MaxValueNameLen*sizeof(WCHAR)),
                &ResultLength);

        if (!NT_SUCCESS(Status)) {

            //
            // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
            // was not enough room for even the fixed portions of the structure.
            // Since we queried the key for the MaxValueNameLength prior to
            // allocating, we shouldn't get STATUS_BUFFER_OVERFLOW either.
            //
            ASSERT(Status != STATUS_BUFFER_TOO_SMALL);
            ASSERT(Status != STATUS_BUFFER_OVERFLOW);

            if (Status == STATUS_NO_MORE_ENTRIES) {
                //
                // Finished enumerating values.
                //
                Status = STATUS_SUCCESS;

            } else {
                //
                // Some other error while enumerating values.
                //
                if (ARGUMENT_PRESENT(SourceKeyPath)) {
                    IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                                 "PiCopyKeyRecursive: unable to enumerate values in key %ws(%lx)\n",
                                 SourceKeyPath, Status));

                } else {
                    IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                                 "PiCopyKeyRecursive: unable to enumerate values in root key(%lx)\n",
                                 Status));
                }
            }
            break;
        }

        //
        // NULL-terminate the value name just in case.
        //
        ValueBasicInfo->Name[ValueBasicInfo->NameLength/sizeof(WCHAR)] = UNICODE_NULL;

        UnicodeStringValue.Buffer = ValueBasicInfo->Name;
        UnicodeStringValue.Length = (USHORT)ValueBasicInfo->NameLength;
        UnicodeStringValue.MaximumLength = UnicodeStringValue.Length;

        //
        // If it is a conditional copy, we need to check if the value already
        // exists in the target, in which case we shouldn't set the value.
        //
        if (!CopyValuesAlways) {

            KEY_VALUE_BASIC_INFORMATION TempValueBasicInfo;

            //
            // To see if the value exists, we attempt to get basic information
            // on the key value and pass in a buffer that's large enough only
            // for the fixed part of the basic info structure.  If this is
            // successful or reports buffer overflow, then the key
            // exists. Otherwise it doesn't exist.
            //

            Status =
                ZwQueryValueKey(
                    TargetKeyHandle,
                    &UnicodeStringValue,
                    KeyValueBasicInformation,
                    &TempValueBasicInfo,
                    sizeof(TempValueBasicInfo),
                    &ResultLength);

            //
            // STATUS_BUFFER_TOO_SMALL would mean that there was not enough room
            // for even the fixed portions of the structure.
            //
            ASSERT(Status != STATUS_BUFFER_TOO_SMALL);

            if ((NT_SUCCESS(Status)) ||
                (Status == STATUS_BUFFER_OVERFLOW)) {
                //
                // Value exists, and we shouldn't change it.
                //
                Status = STATUS_SUCCESS;
                continue;
            }
        }

        //
        // Retrieve the full source value information.
        //
        ValueFullInfoBuffer = NULL;

        Status =
            IopGetRegistryValue(
                SourceKeyHandle,
                UnicodeStringValue.Buffer,
                &ValueFullInfoBuffer);

        if (NT_SUCCESS(Status)) {

            ASSERT(ValueFullInfoBuffer != NULL);

            //
            // If successful, write it to the target key.
            //
            Status =
                ZwSetValueKey(
                    TargetKeyHandle,
                    &UnicodeStringValue,
                    ValueFullInfoBuffer->TitleIndex,
                    ValueFullInfoBuffer->Type,
                    (PVOID)((PUCHAR)ValueFullInfoBuffer + ValueFullInfoBuffer->DataOffset),
                    ValueFullInfoBuffer->DataLength);

            ExFreePool(ValueFullInfoBuffer);
        }

        if (!NT_SUCCESS(Status)) {

            if (ARGUMENT_PRESENT(TargetKeyPath)) {
                IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                             "PiCopyKeyRecursive: unable to set value %ws in key %ws(%lx)\n",
                             UnicodeStringValue.Buffer, TargetKeyPath, Status));
            } else {
                IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                             "PiCopyKeyRecursive: unable to set value %ws(%lx)\n",
                             UnicodeStringValue.Buffer, Status));
            }
            break;
        }
    }

    //
    // Free the value info buffer.
    //
    ASSERT(ValueInfoBuffer);
    ExFreePool(ValueInfoBuffer);

  Clean0:

    if (Security != NULL) {
        ExFreePool(Security);
    }

    //
    // Close handles only if explicitly opened by this routine.
    //
    if ((ARGUMENT_PRESENT(SourceKeyPath)) &&
        (SourceKeyHandle != NULL)) {
        ASSERT(SourceKeyHandle != SourceKeyRootHandle);
        ZwClose(SourceKeyHandle);
    }

    if ((ARGUMENT_PRESENT(TargetKeyPath)) &&
        (TargetKeyHandle != NULL)) {
        ASSERT(TargetKeyHandle != TargetKeyRootHandle);
        ZwClose(TargetKeyHandle);
    }

    return Status;

} // PiCopyKeyRecursive

NTSTATUS
PiCriticalQueryRegistryValueCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    PPI_CRITICAL_QUERY_CONTEXT context = (PPI_CRITICAL_QUERY_CONTEXT)EntryContext;

    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(ValueName);

    if (ValueType == REG_BINARY && ValueLength && ValueData) {
        
        context->Buffer = ExAllocatePool(PagedPool, ValueLength);
        if (context->Buffer) {

            RtlCopyMemory(context->Buffer, ValueData, ValueLength);
            context->Size = ValueLength;
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\ppcontrol.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ppcontrol.c

Abstract:

    User-mode -> Kernel-mode PnP Manager control routines.

Author:

    Lonny McMichael (lonnym) 02/14/95

Revision History:

--*/

#include "pnpmgrp.h"
#include "picontrol.h"
#define _APPHELP_CACHE_INIT_
#include "ahcache.h"
#pragma hdrstop

//
// Global driver object that is used by calls to NtPlugPlayControl
// with control type of PlugPlayControlDetectResourceConflict.
//
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#endif

//
// Define mask of devnode flags that are settable from user-mode via the
// NtPlugPlayControl, PlugPlayControlGetDeviceStatus (which is a misnomer,
// since it can perform both gets and sets).
//
#define DEVICE_NODE_SETTABLE_FLAG_BITS (DNF_HAS_PROBLEM         | \
                                        DNF_HAS_PRIVATE_PROBLEM   \
                                       )

NTSTATUS
PiControlCopyUserModeCallersBuffer(
    IN PVOID Destination,
    IN PVOID Src,
    IN ULONG Length,
    IN ULONG Alignment,
    IN KPROCESSOR_MODE CallerMode,
    IN BOOLEAN ReadUserModeBuffer
    );

NTSTATUS
PiGetInterfaceDeviceAlias(
    IN  PUNICODE_STRING SymbolicLinkName,
    IN  LPGUID AliasClassGuid,
    OUT PWSTR AliasSymbolicLinkName,
    IN OUT PULONG AliasSymbolicLinkNameLength
    );

NTSTATUS
PiGenerateLegacyDeviceInstance(
    IN  PUNICODE_STRING ServiceKeyName,
    OUT PWSTR DeviceInstance,
    IN OUT PULONG DeviceInstanceLength
    );

NTSTATUS
PiQueueQueryAndRemoveEvent(
    IN  PUNICODE_STRING DeviceInstance,
    IN  PPNP_VETO_TYPE VetoType,
    IN  LPWSTR VetoName,
    IN  PULONG VetoNameLength,
    IN  ULONG Flags
    );

NTSTATUS
PiQueueDeviceRequest(
    IN PUNICODE_STRING DeviceInstance,
    IN DEVICE_REQUEST_TYPE RequestType,
    IN ULONG Flags,
    IN BOOLEAN Synchronous
    );

NTSTATUS
PiInitializeDevice(
    IN  PUNICODE_STRING DeviceInstance
    );

NTSTATUS
PiDetectResourceConflict(
    IN PCM_RESOURCE_LIST  ResourceList,
    IN ULONG              ResourceListSize
    );

NTSTATUS
PiGetInterfaceDeviceList(
    IN  GUID *InterfaceGuid,
    IN  PUNICODE_STRING DeviceInstance,
    IN  ULONG Flags,
    OUT PWSTR InterfaceList,
    IN OUT PULONG InterfaceListSize
    );

NTSTATUS
PiDeviceClassAssociation(
    IN PUNICODE_STRING DeviceInstance,
    IN GUID * ClassGuid,
    IN PUNICODE_STRING Reference,   OPTIONAL
    IN OUT PWSTR SymbolicLink,
    IN OUT PULONG SymbolicLinkLength,
    IN BOOLEAN Register
    );

NTSTATUS
PiGetRelatedDevice(
    IN  PUNICODE_STRING TargetDeviceInstance,
    OUT LPWSTR RelatedDeviceInstance,
    IN OUT PULONG RelatedDeviceInstanceLength,
    IN  ULONG Relation
    );

NTSTATUS
PiQueryDeviceRelations(
    IN PUNICODE_STRING DeviceInstance,
    IN PNP_QUERY_RELATION Operation,
    OUT PULONG BufferLength,
    OUT LPWSTR Buffer
    );

DEVICE_RELATION_TYPE
PiDeviceRelationType(
    PNP_QUERY_RELATION  Operation
    );

NTSTATUS
PiControlGetBlockedDriverData(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA    BlockedDriverData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, PpShutdownSystem)                    // this gets called after paging shutdown
#pragma alloc_text(PAGE, NtPlugPlayControl)
#pragma alloc_text(PAGE, PiControlMakeUserModeCallersCopy)
#pragma alloc_text(PAGE, PiControlCopyUserModeCallersBuffer)
#pragma alloc_text(PAGE, PiGetInterfaceDeviceAlias)
#pragma alloc_text(PAGE, PiGenerateLegacyDeviceInstance)
#pragma alloc_text(PAGE, PiQueueQueryAndRemoveEvent)
#pragma alloc_text(PAGE, PiInitializeDevice)
#pragma alloc_text(PAGE, PiDetectResourceConflict)
#pragma alloc_text(PAGE, PiGetInterfaceDeviceList)
#pragma alloc_text(PAGE, PiDeviceClassAssociation)
#pragma alloc_text(PAGE, PiGetRelatedDevice)
#pragma alloc_text(PAGE, PiQueryDeviceRelations)
#pragma alloc_text(PAGE, PiDeviceRelationType)
#pragma alloc_text(PAGE, PiControlGetUserFlagsFromDeviceNode)
#pragma alloc_text(PAGE, PiQueueDeviceRequest)
#pragma alloc_text(PAGE, PiControlEnumerateDevice)
#pragma alloc_text(PAGE, PiControlRegisterNewDevice)
#pragma alloc_text(PAGE, PiControlDeregisterDevice)
#pragma alloc_text(PAGE, PiControlInitializeDevice)
#pragma alloc_text(PAGE, PiControlStartDevice)
#pragma alloc_text(PAGE, PiControlResetDevice)
#pragma alloc_text(PAGE, PiControlQueryAndRemoveDevice)
#pragma alloc_text(PAGE, PiControlUserResponse)
#pragma alloc_text(PAGE, PiControlGenerateLegacyDevice)
#pragma alloc_text(PAGE, PiControlGetInterfaceDeviceList)
#pragma alloc_text(PAGE, PiControlGetPropertyData)
#pragma alloc_text(PAGE, PiControlDeviceClassAssociation)
#pragma alloc_text(PAGE, PiControlGetRelatedDevice)
#pragma alloc_text(PAGE, PiControlGetInterfaceDeviceAlias)
#pragma alloc_text(PAGE, PiControlGetSetDeviceStatus)
#pragma alloc_text(PAGE, PiControlGetDeviceDepth)
#pragma alloc_text(PAGE, PiControlQueryDeviceRelations)
#pragma alloc_text(PAGE, PiControlQueryTargetDeviceRelation)
#pragma alloc_text(PAGE, PiControlQueryConflictList)
#pragma alloc_text(PAGE, PiControlGetDevicePowerData)
#pragma alloc_text(PAGE, PiControlRetrieveDockData)
#pragma alloc_text(PAGE, PiControlHaltDevice)
#pragma alloc_text(PAGE, PiControlGetBlockedDriverData)

#if DBG
#pragma alloc_text(PAGE, PiControlExceptionFilter)
#endif
#endif // ALLOC_PRAGMA

//
// This table contains handlers for all the messages coming from the
// umpnpmgr.dll.
//
PLUGPLAY_CONTROL_HANDLER_DATA PlugPlayHandlerTable[] = {

    { PlugPlayControlEnumerateDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlEnumerateDevice },

    { PlugPlayControlRegisterNewDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlRegisterNewDevice },

    { PlugPlayControlDeregisterDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlDeregisterDevice },

    { PlugPlayControlInitializeDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlInitializeDevice },

    { PlugPlayControlStartDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlStartDevice },

    { PlugPlayControlUnlockDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      NULL },

    { PlugPlayControlQueryAndRemoveDevice,
      sizeof(PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA),
      PiControlQueryAndRemoveDevice },

    { PlugPlayControlUserResponse,
      sizeof(PLUGPLAY_CONTROL_USER_RESPONSE_DATA),
      PiControlUserResponse },

    { PlugPlayControlGenerateLegacyDevice,
      sizeof(PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA),
      PiControlGenerateLegacyDevice },

    { PlugPlayControlGetInterfaceDeviceList,
      sizeof(PLUGPLAY_CONTROL_INTERFACE_LIST_DATA),
      PiControlGetInterfaceDeviceList },

    { PlugPlayControlProperty,
      sizeof(PLUGPLAY_CONTROL_PROPERTY_DATA),
      PiControlGetPropertyData },

    { PlugPlayControlDeviceClassAssociation,
      sizeof(PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA),
      PiControlDeviceClassAssociation },

    { PlugPlayControlGetRelatedDevice,
      sizeof(PLUGPLAY_CONTROL_RELATED_DEVICE_DATA),
      PiControlGetRelatedDevice },

    { PlugPlayControlGetInterfaceDeviceAlias,
      sizeof(PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA),
      PiControlGetInterfaceDeviceAlias },

    { PlugPlayControlDeviceStatus,
      sizeof(PLUGPLAY_CONTROL_STATUS_DATA),
      PiControlGetSetDeviceStatus },

    { PlugPlayControlGetDeviceDepth,
      sizeof(PLUGPLAY_CONTROL_DEPTH_DATA),
      PiControlGetDeviceDepth },

    { PlugPlayControlQueryDeviceRelations,
      sizeof(PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA),
      PiControlQueryDeviceRelations },

    { PlugPlayControlTargetDeviceRelation,
      sizeof(PLUGPLAY_CONTROL_TARGET_RELATION_DATA),
      PiControlQueryTargetDeviceRelation },

    { PlugPlayControlQueryConflictList,
      sizeof(PLUGPLAY_CONTROL_CONFLICT_DATA),
      PiControlQueryConflictList },

    { PlugPlayControlRetrieveDock,
      sizeof(PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA),
      PiControlRetrieveDockData },

    { PlugPlayControlResetDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlResetDevice },

    { PlugPlayControlHaltDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlHaltDevice },

    { PlugPlayControlGetBlockedDriverList,
      sizeof(PLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA),
      PiControlGetBlockedDriverData },

    { MaxPlugPlayControl,
      0,
      NULL }
};

NTSTATUS
NtPlugPlayControl(
    IN     PLUGPLAY_CONTROL_CLASS   PnPControlClass,
    IN OUT PVOID                    PnPControlData,
    IN     ULONG                    PnPControlDataLength
    )
/*++

Routine Description:

    This Plug and Play Manager API provides a mechanism for the user-mode
    PnP Manager to control the activity of its kernel-mode counterpart.

Arguments:

    PnPControlClass - Specifies what action to perform.

    PnPControlData - Supplies a pointer to data specific to this action.

    PnPControlDataLength - Specifies the size, in bytes, of the buffer pointed
                           to by PnPControlData

Return Value:

    NT status code indicating success or failure.  Set of possible return
    values includes the following:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_PARAMETER_1 - The PnPControlClass parameter did not
            specify a valid control class.

        STATUS_INVALID_PARAMETER_MIX - The value of the PnPControlDataLength
            parameter did not match the length required for the control
            class requested by the PnPControlClass parameter.

        STATUS_BUFFER_TOO_SMALL - The size of the supplied output buffer is not
            large enough to hold the output generated by this control class.

        STATUS_ACCESS_VIOLATION - One of the following pointers specified
            an invalid address: (1) the PnPControlData buffer pointer,
            (2) some pointer contained in the PnPControlData buffer.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/
{
    NTSTATUS status, tempStatus;
    KPROCESSOR_MODE previousMode;
    ULONG index;
    PPLUGPLAY_CONTROL_HANDLER_DATA handlerData;
    PVOID controlDataSnapshot;

    PAGED_CODE();
    //
    // Get previous processor mode and probe arguments if necessary.
    //
    previousMode = KeGetPreviousMode();
    if (previousMode != KernelMode) {
        //
        // Does the caller have "trusted computer base" privilge?
        //
        if (!SeSinglePrivilegeCheck(SeTcbPrivilege, UserMode)) {

            IopDbgPrint((IOP_IOAPI_WARNING_LEVEL,
                       "NtPlugPlayControl: SecurityCheck failed\n"));
            return STATUS_PRIVILEGE_NOT_HELD;
        }
    }
    //
    // Look through the table to find the appropriate handler. Note that
    // the control class *should* be an index into the table itself.
    //
    index = (ULONG)PnPControlClass;
    handlerData = NULL;
    if (index < MaxPlugPlayControl) {

        if (PlugPlayHandlerTable[index].ControlCode == PnPControlClass) {

            handlerData = &PlugPlayHandlerTable[index];
        } else {
            //
            // Someone broke the table.
            //
            IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
                       "NtPlugPlayControl: Lookup table isn't ordered correctly (entry %d)!\n",
                       PnPControlClass));

            ASSERT(PlugPlayHandlerTable[index].ControlCode == PnPControlClass);

            return STATUS_INTERNAL_ERROR;
        }
    }
    //
    // Do we have handler data?
    //
    if (handlerData == NULL) {
        //
        // Invalid control class.
        //
        IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
                   "NtPlugPlayControl: Unknown control class, Class = %d, Size = %d\n",
                   PnPControlClass,
                   PnPControlDataLength));
        return STATUS_INVALID_PARAMETER_1;
    }
    //
    // No control function means not implemented.
    //
    if (handlerData->ControlFunction == NULL) {

        return STATUS_NOT_IMPLEMENTED;
    }
    //
    // Check the data size.
    //
    if (handlerData->ControlDataSize != PnPControlDataLength) {

        IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
                   "NtPlugPlayControl: Invalid size for control, Class = %d, Size = %d\n",
                   PnPControlClass,
                   PnPControlDataLength));
        return STATUS_INVALID_PARAMETER_MIX;
    }
    //
    // Make copy of caller's buffer.
    //
    status = PiControlMakeUserModeCallersCopy(
        &controlDataSnapshot,
        PnPControlData,
        PnPControlDataLength,
        sizeof(ULONG),
        previousMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        return status;
    }
    //
    // Invoke the handler.
    //
    status = handlerData->ControlFunction(
        PnPControlClass,
        controlDataSnapshot,
        PnPControlDataLength,
        previousMode
        );
    //
    // Copy the buffer if the operation was successful or the value is
    // a warning like STATUS_BUFFER_OVERFLOW.
    //
    // ISSUE - 2000/09/11 - Misused STATUS code
    //    Here we hack around the fact that we've been returning
    // STATUS_BUFFER_TOO_SMALL instead of STATUS_BUFFER_OVERFLOW. This
    // should be fixed here and in UMPNPMGR.
    //
    if ((!NT_ERROR(status)) || (status == STATUS_BUFFER_TOO_SMALL)) {

        //
        // Copy result back into caller's buffer.
        //
        tempStatus = PiControlMakeUserModeCallersCopy(
            &PnPControlData,
            controlDataSnapshot,
            PnPControlDataLength,
            sizeof(ULONG),
            previousMode,
            FALSE
            );
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    //
    // Free buffer allocated for user mode caller.
    //
    PiControlFreeUserModeCallersBuffer(previousMode, controlDataSnapshot);

    return status;
}

NTSTATUS
PiControlCopyUserModeCallersBuffer(
    IN PVOID Destination,
    IN PVOID Src,
    IN ULONG Length,
    IN ULONG Alignment,
    IN KPROCESSOR_MODE CallerMode,
    IN BOOLEAN ReadUserModeBuffer
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    if (CallerMode == KernelMode) {
        //
        // Copy from Src to Destination.
        //
        RtlCopyMemory(
            Destination,
            Src,
            Length);

        return status;
    }
    try {

        if (ReadUserModeBuffer) {
            //
            // Probe user-mode buffer before reading from it.
            //
            ProbeForRead(
                Src,
                Length,
                Alignment);
        } else {
            //
            // Probe user-mode buffer before writing to it.
            //
            ProbeForWrite(
                Destination,
                Length,
                Alignment);
        }
        //
        // Copy from Src to Destination.
        //
        RtlCopyMemory(
            Destination,
            Src,
            Length);

    } except(PiControlExceptionFilter(GetExceptionInformation())) {

        status = GetExceptionCode();
        IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
                   "PiControlMakeUserModeCallersCopy: Exception 0x%08x copying data to or from user's buffer\n", status));
    }

    return status;
}

NTSTATUS
PiControlMakeUserModeCallersCopy(
    IN OUT PVOID       *Destination,
    IN PVOID           Src,
    IN ULONG           Length,
    IN ULONG           Alignment,
    IN KPROCESSOR_MODE CallerMode,
    IN BOOLEAN         AllocateDestination
    )

/*++

Routine Description:

    This routine copies data from and to a callers (potentially UserMode) buffer
    after appropriate probing and under try-except.
    If CallerMode is KernelMode, then it does not do any copy.
    If CallerMode is not KernelMode and AllocateDestination is TRUE, Src is a user
    mode buffer that will be probed. We will also allocate the Destination buffer and
    make a copy of the user mode buffer.
    If CallerMode is not KernelMode and AllocateDestination is FALSE, Src is the kernel
    mode buffer whose data needs to be copied into Destination.

Arguments:

    Destination - Receives pointer to buffer allocated if AllocateDestination is TRUE,
        else contains the pointer to the buffer where data needs to be copied.

    Src - Pointer to data to be copied.

    Length - Length of data to be copied in bytes.

    Alignment - Alignment for probing user mode buffer.

    CallerMode - KernelMode\UserMode

    AllocateDestination - If TRUE, allocate Length sized buffer and return the pointer
    in Destination.

Return Value:

    A NTSTATUS code indicating success or cause of failure.

--*/

{
    NTSTATUS    status;

    PAGED_CODE();

    if (CallerMode == KernelMode) {
        //
        // We really dont need to call this function when CallerMode == KernelMode but
        // we do so that the callee does not have to special case.
        //
        *Destination = Src;
        return STATUS_SUCCESS;

    }
    if (Length == 0) {

        *Destination = NULL;
        return STATUS_SUCCESS;
    }
    if (AllocateDestination) {
        //
        // Allocate kernel mode buffer to copy user data.
        //
        *Destination = ExAllocatePoolWithQuota(
            PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
            Length);
        if (*Destination == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    status = STATUS_SUCCESS;
    if (*Destination) {

        status = PiControlCopyUserModeCallersBuffer(
                    *Destination,
                    Src,
                    Length,
                    Alignment,
                    CallerMode,
                    AllocateDestination);
        if (!NT_SUCCESS(status)) {

            if (AllocateDestination == TRUE) {

                ExFreePool(*Destination);
                *Destination = NULL;
            }
        }
    }
    //
    // Return final status.
    //
    return status;
}

NTSTATUS
PiGetInterfaceDeviceAlias(
    IN  PUNICODE_STRING SymbolicLinkName,
    IN  LPGUID AliasClassGuid,
    OUT PWSTR AliasSymbolicLinkName,
    IN OUT PULONG AliasSymbolicLinkNameLength
    )

/*++

Routine Description:

    This routine retrieves the interface device of the specified class that aliases
    a particular interface device.  See IoGetAliasForDeviceClassAssociation for
    more details.

Arguments:

    SymbolicLinkName - Supplies the name of the interface device whose alias is to
        be retrieved.

    AliasClassGuid - Supplies a pointer to the GUID representing the interface class
        in which an alias of SymbolicLinkName is to be found.

    AliasSymbolicLinkName - Supplies a character buffer that, upon success, receives
        the name of the alias interface device.

    AliasSymbolicLinkNameLength - Supplies the length, in bytes, of the
        AliasSymbolicLinkName character buffer.

    RequiredLength - Supplies the address of a variable that will be filled in with
        the number of bytes (including terminating NULL) required to store the
        interface device name in the AliasSymbolicLinkName buffer.  This will be
        filled in upon successful return, or when the return is STATUS_BUFFER_TOO_SMALL.

Return Value:

    A NTSTATUS code indicating success or cause of failure.

--*/

{
    NTSTATUS status;
    UNICODE_STRING aliasString;

    PAGED_CODE();

    status = IoGetDeviceInterfaceAlias( SymbolicLinkName,
                                        AliasClassGuid,
                                        &aliasString);
    if (NT_SUCCESS(status)) {

        if (aliasString.Length < *AliasSymbolicLinkNameLength) {

            RtlCopyMemory(AliasSymbolicLinkName, aliasString.Buffer, aliasString.Length);
            *(PWCHAR)((PUCHAR)AliasSymbolicLinkName + aliasString.Length) = L'\0';

            *AliasSymbolicLinkNameLength = aliasString.Length;

        } else {

            *AliasSymbolicLinkNameLength = aliasString.Length + sizeof(UNICODE_NULL);
            status = STATUS_BUFFER_TOO_SMALL;
        }

        ExFreePool(aliasString.Buffer);
    }

    return status;
}

NTSTATUS
PiGenerateLegacyDeviceInstance(
    IN  PUNICODE_STRING ServiceKeyName,
    OUT PWSTR DeviceInstance,
    IN OUT PULONG DeviceInstanceLength
    )

/*++

Routine Description:

    This routine creates a new instance node under System\Enum\Root\LEGACY_<Name>
    key and all the required default value entries.  Also a value entry under
    Service\ServiceKeyName\Enum is created to point to the newly created madeup
    entry.  A handle and the keyname of the new key are returned to caller.
    Caller must free the unicode string when he is done with it.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load.

    DeviceInstance - Supplies a pointer to the character buffer that receives the
        newly-generated device instance name.

    DeviceInstanceLength - Supplies the size, in bytes, of the DeviceInstance
        buffer.

Return Value:

    A NTSTATUS code.
    If the legacy device instance exists already, this function returns success.

--*/

{
    NTSTATUS status;
    HANDLE handle;
    ULONG junk;
    UNICODE_STRING tempUnicodeString;

    PAGED_CODE();

    PiLockPnpRegistry(FALSE);

    status = PipCreateMadeupNode(ServiceKeyName,
                                 &handle,
                                 &tempUnicodeString,
                                 &junk,
                                 TRUE
                                 );
    if (NT_SUCCESS(status)) {
        //
        // We have successfully retrieved the newly-generated device instance name.
        // Now store it in the supplied buffer.
        //
        ZwClose(handle);

        if (tempUnicodeString.Length < *DeviceInstanceLength) {

            RtlCopyMemory(DeviceInstance,
                          tempUnicodeString.Buffer,
                          tempUnicodeString.Length);
            *(PWCHAR)((PUCHAR)DeviceInstance + tempUnicodeString.Length) = L'\0';

            *DeviceInstanceLength = tempUnicodeString.Length;

        } else {

            *DeviceInstanceLength = tempUnicodeString.Length + sizeof(UNICODE_NULL);
            status = STATUS_BUFFER_TOO_SMALL;
        }

        RtlFreeUnicodeString(&tempUnicodeString);
    }

    PiUnlockPnpRegistry();

    return status;
}

NTSTATUS
PiQueueQueryAndRemoveEvent(
    IN  PUNICODE_STRING DeviceInstance,
    IN  PPNP_VETO_TYPE VetoType,
    IN  LPWSTR VetoName,
    IN  PULONG VetoNameLength,
    IN  ULONG Flags
    )

/*++

Routine Description:

    This routine queues an event to handle the specified operation later in
    the context of a system thread. There is one master event queue and all
    events are handled in the order they were submitted.

    This routine also handles user-mode requests to eject the device specified
    in DeviceInstance.  If the device's capabilities report the device
    ejectable or lockable then it is handled by the same code that processes
    IoRequestDeviceEject, otherwise the driver stack is removed and the device
    node is marked with the problem CM_PROB_DEVICE_NOT_THERE which prevents it
    from being reenumerated until the device is physically removed.  This later
    method is used primarily for things like PCCARD devices.

Arguments:

    DeviceInstance - Supplies the device instance name of the device that is
            the target of the event.

    EventGuid - This is the GUID that uniquely identifies the type of event.

    Synchronous - This is a boolean flag indicating whether the action should
            be performed synchronously or asynchronously (synchronous if TRUE).

Return Value:

    A NTSTATUS code.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;
    PDEVICE_NODE deviceNode = NULL;
    UNICODE_STRING vetoNameString;
    PUNICODE_STRING vetoNameStringPtr;
    BOOLEAN noRestart, doEject, onlyRestartRelations;
    ULONG problem;
    KEVENT userEvent;
    ULONG  eventResult;

    PAGED_CODE();

    deviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);

    if (!deviceObject) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean1;
    }
    //
    // Retrieve the device node for this device object.
    //
    deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean1;
    }

    if (deviceNode == IopRootDeviceNode) {

        status = STATUS_ACCESS_DENIED;
        goto Clean1;
    }

    vetoNameString.Length = 0;
    vetoNameString.MaximumLength = (USHORT)(*VetoNameLength);

    if (vetoNameString.MaximumLength != 0) {

        vetoNameString.Buffer = ExAllocatePool(PagedPool, vetoNameString.MaximumLength);
        if (vetoNameString.Buffer == NULL) {

            vetoNameString.MaximumLength = 0;
        }

        vetoNameStringPtr = &vetoNameString;

    } else {

        vetoNameString.Buffer = NULL;
        vetoNameStringPtr = NULL;
    }
    //
    // Do preprocessing of device node before queueing notification.
    //
    if (Flags & (PNP_QUERY_AND_REMOVE_DISABLE |
                 PNP_QUERY_AND_REMOVE_EJECT_DEVICE)) {

        noRestart = TRUE;

    } else {

        noRestart = FALSE;
    }
    //
    // Nobody has ever used this flag. We should not see it here, and we ignore
    // it if we do see it.
    //
    ASSERT(!(Flags & PNP_QUERY_AND_REMOVE_UNINSTALL));

    onlyRestartRelations = FALSE;
    if (Flags & PNP_QUERY_AND_REMOVE_DISABLE) {
        //
        // this particular problem may cause a
        // "NonDisableable" Veto
        //
        problem = CM_PROB_DISABLED;
        doEject = FALSE;

    } else if (Flags & PNP_QUERY_AND_REMOVE_EJECT_DEVICE) {

        problem = CM_PROB_HELD_FOR_EJECT;
        doEject = TRUE;

    } else {

        problem = CM_PROB_WILL_BE_REMOVED;
        doEject = FALSE;

        if (Flags & PNP_QUERY_AND_REMOVE_NO_RESTART) {

            onlyRestartRelations = TRUE;
        }
    }
    //
    // Queue this device event
    //
    KeInitializeEvent(&userEvent, NotificationEvent, FALSE);
    //
    // Queue the event, this call will return immediately. Note that status
    // is the status of the PpSetTargetDeviceChange while result is the
    // outcome of the actual event.
    //
    status = PpSetTargetDeviceRemove(deviceObject,
                                     FALSE,
                                     noRestart,
                                     onlyRestartRelations,
                                     doEject,
                                     problem,
                                     &userEvent,
                                     &eventResult,
                                     VetoType,
                                     vetoNameStringPtr);
    //
    // Drop the ref since there is now one in PpSetTargetDeviceRemove itself.
    //
    ObDereferenceObject(deviceObject);
    deviceObject = NULL;

    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // Wait for the event we just queued to finish since synchronous operation
    // was requested (non alertable wait).
    //
    // FUTURE ITEM - Use a timeout here?
    //
    status = KeWaitForSingleObject(&userEvent, Executive, KernelMode, FALSE, NULL);
    if (NT_SUCCESS(status)) {

        status = eventResult;
    }
    if (vetoNameString.Length != 0) {

        if (vetoNameString.Length >= vetoNameString.MaximumLength) {

            vetoNameString.Length--;
        }

        RtlCopyMemory(VetoName, vetoNameString.Buffer, vetoNameString.Length);
        VetoName[ vetoNameString.Length / sizeof(WCHAR) ] = L'\0';
    }

    if (VetoNameLength != NULL) {

        *VetoNameLength = vetoNameString.Length;
    }

Clean0:

    if (vetoNameString.Buffer != NULL) {

        ExFreePool(vetoNameString.Buffer);
    }

Clean1:

    if (deviceObject) {

        ObDereferenceObject(deviceObject);
    }

    return status;
} // PiQueueDeviceEvent

NTSTATUS
PiInitializeDevice(
    IN  PUNICODE_STRING DeviceInstance
    )

/*++

Routine Description:

    This routine creates a devnode for the device instance and performs
    any other necessary initialization of the device instance.

Arguments:

    DeviceInstance - Supplies the path in the registry (relative to
        HKLM\System\Enum) to the device instance to initalize.

Return Value:

    NT status code indicating success or failure of this routine.

--*/

{
    NTSTATUS status;
    UNICODE_STRING serviceName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    ULONG deviceFlags;
    HANDLE hEnum, hDevInst;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode = NULL;

    PAGED_CODE();

    hEnum = NULL;
    hDevInst = NULL;
    keyValueInformation = NULL;
    //
    // Acquire lock on the registry before we do any initialization.
    //
    PiLockPnpRegistry(TRUE);

    deviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);
    if (deviceObject) {

        ObDereferenceObject(deviceObject);
        status = STATUS_SUCCESS;
        goto Clean0;
    }
    //
    // Open a key to HKLM\SYSTEM\CCC\Enum
    //
    status = IopOpenRegistryKeyEx( &hEnum,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_ALL_ACCESS);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // Open a key to the specified device instance
    //
    status = IopCreateRegistryKeyEx( &hDevInst,
                                     hEnum,
                                     DeviceInstance,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // We need to propagate the ConfigFlag to problem and values (devnode flags)
    //
    deviceFlags = 0;
    status = IopGetRegistryValue(hDevInst,
                                 REGSTR_VALUE_CONFIG_FLAGS,
                                 &keyValueInformation);
    if (NT_SUCCESS(status)) {

        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {

            deviceFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
        keyValueInformation = NULL;
    }
    //
    // Get the "Service=" value entry from KeyHandle
    //
    PiWstrToUnicodeString(&serviceName, NULL);
    status = IopGetRegistryValue(hDevInst,
                                 REGSTR_VALUE_SERVICE,
                                 &keyValueInformation);
    if (NT_SUCCESS(status)) {

        if ((keyValueInformation->Type == REG_SZ) &&
            (keyValueInformation->DataLength != 0)) {
            //
            // Set up ServiceKeyName unicode string
            //
            IopRegistryDataToUnicodeString(&serviceName,
                                           (PWSTR)KEY_VALUE_DATA(keyValueInformation),
                                           keyValueInformation->DataLength);
        }
        //
        // Do not free keyValueInformation right now (contains Service Name).
        //
    }
    //
    // Create madeup PDO and device node to represent the root device.
    //
    status = IoCreateDevice( IoPnpDriverObject,
                             0,
                             NULL,
                             FILE_DEVICE_CONTROLLER,
                             FILE_AUTOGENERATED_DEVICE_NAME,
                             FALSE,
                             &deviceObject);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }

    deviceObject->Flags |= DO_BUS_ENUMERATED_DEVICE;
    status = PipAllocateDeviceNode(deviceObject, &deviceNode);
    if (!deviceNode) {

        if (status == STATUS_SYSTEM_HIVE_TOO_LARGE) {

            status = STATUS_INSUFFICIENT_RESOURCES;
        }
        goto Clean0;
    }

    deviceNode->Flags = DNF_MADEUP | DNF_ENUMERATED;

    PipSetDevNodeState(deviceNode, DeviceNodeInitialized, NULL);

    if (deviceFlags & CONFIGFLAG_REINSTALL) {

        PipSetDevNodeProblem(deviceNode, CM_PROB_REINSTALL);

    } else if (deviceFlags & CONFIGFLAG_PARTIAL_LOG_CONF) {

        PipSetDevNodeProblem(deviceNode, CM_PROB_PARTIAL_LOG_CONF);
    }
    //
    // Make a copy of the device instance path and save it in
    // device node.
    //
    status = PipConcatenateUnicodeStrings(&deviceNode->InstancePath,
                                          DeviceInstance,
                                          NULL);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    if (serviceName.Length != 0) {
        //
        // Make a copy of the service name and save it in device node.
        //
        status = PipConcatenateUnicodeStrings(&deviceNode->ServiceName,
                                              &serviceName,
                                              NULL);
    } else {

        PiWstrToUnicodeString(&deviceNode->ServiceName, NULL);
    }
    //
    // Add an entry into the table to set up a mapping between the DO
    // and the instance path.
    //
    status = IopMapDeviceObjectToDeviceInstance(
                deviceNode->PhysicalDeviceObject,
                &deviceNode->InstancePath);
    if (NT_SUCCESS(status)) {

        PpDevNodeInsertIntoTree(IopRootDeviceNode, deviceNode);
        //
        // Add an event so user-mode will attempt to install this device later.
        //
        PpSetPlugPlayEvent(&GUID_DEVICE_ENUMERATED,
                           deviceNode->PhysicalDeviceObject);
    }

Clean0:
    //
    // Clean up.
    //
    if (!NT_SUCCESS(status)) {

        if (deviceObject) {

            IoDeleteDevice(deviceObject);
        }
    }
    //
    // Release the registry lock.
    //
    PiUnlockPnpRegistry();

    if (keyValueInformation != NULL) {

        ExFreePool(keyValueInformation);
    }
    if (hDevInst) {

        ZwClose(hDevInst);
    }
    if (hEnum) {

        ZwClose(hEnum);
    }

    return status;
} // PiInitializeDevice

NTSTATUS
PiDetectResourceConflict(
    IN PCM_RESOURCE_LIST  ResourceList,
    IN ULONG              ResourceListSize
    )

/*++

Routine Description:

    This routine is invoked to test whether the specified resource
    list conflicts with any already assigned resources.

Arguments:

    ResourceList - Specifies a resource list buffer.

    ResourceListSize - Specifies the size of the resource list buffer.

Return Value:

    The function value is an NTSTATUS value; STATUS_SUCCESS indicates
    that the resources do not conflict, STATUS_INSUFFICIENT_RESOURCES
    indicates that the resource conflict with already assigned
    resources (or some other NTSTATUS value may indicate a different
    internal error).

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE handle;
    PWSTR buffer;
    NTSTATUS status;
    UNICODE_STRING DriverName;
    ULONG i;
    BOOLEAN bTemp;
    CM_RESOURCE_LIST EmptyResourceList;
    static PDRIVER_OBJECT driverObject = NULL;

    PAGED_CODE();

    if (driverObject == NULL) {
        //
        // Driver object has not been created yet, do that now.
        //
        PiWstrToUnicodeString(&DriverName, L"\\Device\\PlugPlay");
        //
        // Begin by creating the permanent driver object.
        //
        InitializeObjectAttributes(&objectAttributes,
                                   &DriverName,
                                   OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
                                   (HANDLE)NULL,
                                   (PSECURITY_DESCRIPTOR)NULL);
        //
        // Specify "KernelMode" here since it refers to the source of
        // the objectAttributes buffer, not the previous operating system
        // mode.
        //
        status = ObCreateObject(KernelMode,
                                IoDriverObjectType,
                                &objectAttributes,
                                KernelMode,
                                (PVOID)NULL,
                                (ULONG)(sizeof(DRIVER_OBJECT) + sizeof(DRIVER_EXTENSION)),
                                0,
                                0,
                                (PVOID)&driverObject);
        if (!NT_SUCCESS(status)) {

            return status;
        }
        //
        // Initialize the driver object.
        //
        RtlZeroMemory(driverObject,
                      sizeof(DRIVER_OBJECT) + sizeof(DRIVER_EXTENSION));
        driverObject->DriverExtension = (PDRIVER_EXTENSION)(driverObject + 1);
        driverObject->DriverExtension->DriverObject = driverObject;
        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

            driverObject->MajorFunction[i] = NULL;        // OK???
        }
        driverObject->Type = IO_TYPE_DRIVER;
        driverObject->Size = sizeof(DRIVER_OBJECT);
        driverObject->DriverInit = NULL;
        //
        // Insert the driver object into the object table.
        //
        status = ObInsertObject(driverObject,
                                NULL,
                                FILE_READ_DATA,
                                0,
                                (PVOID *)NULL,
                                &handle);
        if (!NT_SUCCESS(status)) {
            //
            // Object is dereferenced by the object manager if insert fails.
            //
            return status;
        }
        //
        // Save the name of the driver so that it can be easily located by functions
        // such as error logging.
        //
        buffer = ExAllocatePool(PagedPool, DriverName.MaximumLength + 2);
        if (buffer) {

            driverObject->DriverName.Buffer = buffer;
            driverObject->DriverName.MaximumLength = DriverName.MaximumLength;
            driverObject->DriverName.Length = DriverName.Length;

            RtlCopyMemory(driverObject->DriverName.Buffer,
                          DriverName.Buffer,
                          DriverName.MaximumLength);
            buffer[DriverName.Length / sizeof(UNICODE_NULL)] = L'\0';
        }
    }
    //
    // Attempt to acquire the resource, if successful, we know the
    // resource is avaiable, overwise assume it conflicts with another
    // devices resource's.
    //
    status = IoReportResourceUsage(NULL,
                                   driverObject,
                                   ResourceList,
                                   ResourceListSize,
                                   NULL,
                                   NULL,
                                   0,
                                   FALSE,
                                   &bTemp);
    if (NT_SUCCESS(status)) {
        //
        // Clear any resources that might have been assigned to my fake device.
        //
        RtlZeroMemory(&EmptyResourceList, sizeof(CM_RESOURCE_LIST));

        IoReportResourceUsage(NULL,
                              driverObject,
                              &EmptyResourceList,
                              sizeof(CM_RESOURCE_LIST),
                              NULL,
                              NULL,
                              0,
                              FALSE,
                              &bTemp);
    }

    if (status == STATUS_CONFLICTING_ADDRESSES) {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;

} // PiDetectResourceConflict

NTSTATUS
PiGetInterfaceDeviceList(
    IN  GUID *InterfaceGuid,
    IN  PUNICODE_STRING DeviceInstance,
    IN  ULONG Flags,
    OUT PWSTR InterfaceList,
    IN OUT PULONG InterfaceListSize
    )

/*++

Routine Description:

    This routine is invoked to return an interface device list based on
    the specified interface device guid class and optional device instance.

Arguments:


Return Value:

    The function value is an NTSTATUS.

--*/

{
    NTSTATUS status;
    PWSTR tempBuffer = NULL;
    ULONG tempSize = 0;

    PAGED_CODE();

    //
    // Note: This Iop routine allocates a memory buffer and store the
    // interface device list in that buffer. I need to copy it to the
    // users buffer (if any) and then free it before returning.
    //
    if (DeviceInstance->Length == 0) {

        status = IopGetDeviceInterfaces(InterfaceGuid,
                                        NULL,
                                        Flags,
                                        TRUE,    // user-mode format
                                        &tempBuffer,
                                        &tempSize);
    } else {

        status = IopGetDeviceInterfaces(InterfaceGuid,
                                        DeviceInstance,
                                        Flags,
                                        TRUE,    // user-mode format
                                        &tempBuffer,
                                        &tempSize);
    }
    if (NT_SUCCESS(status)) {

        if (InterfaceList) {
            //
            // Not just asking for the size, copy the buffer too.
            //
            if (tempSize > *InterfaceListSize) {

                status = STATUS_BUFFER_TOO_SMALL;
            } else {

                RtlCopyMemory(InterfaceList, tempBuffer, tempSize);
            }
        }
        *InterfaceListSize = tempSize;

        ExFreePool(tempBuffer);
    }

    return status;
} // PiGetInterfaceDeviceList

NTSTATUS
PiDeviceClassAssociation(
    IN PUNICODE_STRING DeviceInstance,
    IN GUID * InterfaceGuid,
    IN PUNICODE_STRING Reference,   OPTIONAL
    IN OUT LPWSTR SymbolicLink,
    IN OUT PULONG SymbolicLinkLength,
    IN BOOLEAN Register
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING tempString;

    PAGED_CODE();

    if (Register) {
        //
        // An interface GUID and device instance are required to register a
        // symbolic link.
        //
        if (!ARGUMENT_PRESENT(InterfaceGuid)) {

            return STATUS_INVALID_PARAMETER;
        }

        if ((!ARGUMENT_PRESENT(DeviceInstance)) ||
            (DeviceInstance->Buffer == NULL) ||
            (DeviceInstance->Length == 0)) {

            return STATUS_INVALID_PARAMETER;
        }

        status = IopRegisterDeviceInterface(DeviceInstance,
                                            InterfaceGuid,
                                            Reference,
                                            TRUE,      // user-mode format
                                            &tempString);
        if (NT_SUCCESS(status)) {

            ASSERT(tempString.Buffer);

            if ((tempString.Length + sizeof(UNICODE_NULL)) <= *SymbolicLinkLength) {
                //
                // copy the returned symbolic link to user buffer
                //
                RtlCopyMemory(SymbolicLink, tempString.Buffer, tempString.Length);
                SymbolicLink[tempString.Length / sizeof(WCHAR)] = L'\0';

                *SymbolicLinkLength = tempString.Length + sizeof(UNICODE_NULL);

            } else {
                //
                // return only the length of the registered symbolic link.
                //
                *SymbolicLinkLength = tempString.Length + sizeof(UNICODE_NULL);
                status = STATUS_BUFFER_TOO_SMALL;
            }

            ExFreePool(tempString.Buffer);
        }

    } else {
        //
        // A symbolic link name is required to unregister a device interface.
        //
        if ((!ARGUMENT_PRESENT(SymbolicLink)) ||
            (!ARGUMENT_PRESENT(SymbolicLinkLength)) ||
            (*SymbolicLinkLength == 0)) {

            return STATUS_INVALID_PARAMETER;
        }

        RtlInitUnicodeString(&tempString, SymbolicLink);

        //
        // Unregister any interfaces using this symbolic link
        //
        status = IopUnregisterDeviceInterface(&tempString);
    }

    return status;
} // PiDeviceClassAssociation

NTSTATUS
PiGetRelatedDevice(
    IN  PUNICODE_STRING TargetDeviceInstance,
    OUT LPWSTR RelatedDeviceInstance,
    IN OUT PULONG RelatedDeviceInstanceLength,
    IN  ULONG Relation
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject, relatedDeviceObject;
    PDEVICE_NODE deviceNode, originalDeviceNode, relatedDeviceNode;

    PAGED_CODE();

    PpDevNodeLockTree(PPL_SIMPLE_READ);

    //
    // Retrieve the PDO from the device instance string.
    //
    deviceObject = IopDeviceObjectFromDeviceInstance(TargetDeviceInstance);
    if (!deviceObject) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }
    //
    // Retrieve the devnode from the PDO
    //
    deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    originalDeviceNode = deviceNode;

    if ((deviceNode->State == DeviceNodeDeleted) ||
        (deviceNode->State == DeviceNodeDeletePendingCloses)) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    switch (Relation) {
    case PNP_RELATION_PARENT:
        relatedDeviceNode = deviceNode->Parent;
        break;

    case PNP_RELATION_CHILD:
        relatedDeviceNode = deviceNode->Child;
        if (relatedDeviceNode &&
            PipIsDevNodeProblem(relatedDeviceNode, CM_PROB_DEVICE_NOT_THERE) &&
            (relatedDeviceNode->Flags & DNF_LEGACY_DRIVER)) {
            deviceNode = relatedDeviceNode;
            //
            // Fall through...
            //
        } else {

            break;
        }

    case PNP_RELATION_SIBLING:
        relatedDeviceNode = deviceNode->Sibling;
        while (relatedDeviceNode &&
            PipIsDevNodeProblem(relatedDeviceNode, CM_PROB_DEVICE_NOT_THERE) &&
            (relatedDeviceNode->Flags & DNF_LEGACY_DRIVER)) {

            relatedDeviceNode = relatedDeviceNode->Sibling;
        }
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
        goto Clean0;
    }

    //
    // We now have what we think is the relatedDeviceNode but we need to make
    // sure that it hasn't been uninstalled or had its registry info
    // removed in some other way.  Otherwise we won't be able to find its
    // siblings.  If we can't map from its InstancePath to a PDO skip it and go
    // on to the next sibling.
    //

    if (Relation != PNP_RELATION_PARENT)  {

        PiLockPnpRegistry(FALSE);

        while (relatedDeviceNode) {

            if (relatedDeviceNode->InstancePath.Length != 0) {
                //
                // Retrieve the PDO from the device instance string.
                //
                relatedDeviceObject = IopDeviceObjectFromDeviceInstance(&relatedDeviceNode->InstancePath);

                if (relatedDeviceObject != NULL) {

                    ObDereferenceObject(relatedDeviceObject);
                    break;
                }
            }

            relatedDeviceNode = relatedDeviceNode->Sibling;
        }

        PiUnlockPnpRegistry();
    }

    if (relatedDeviceNode != NULL) {

        if (*RelatedDeviceInstanceLength > relatedDeviceNode->InstancePath.Length) {

            RtlCopyMemory(RelatedDeviceInstance,
                        relatedDeviceNode->InstancePath.Buffer,
                        relatedDeviceNode->InstancePath.Length);
            *(PWCHAR)((PUCHAR)RelatedDeviceInstance + relatedDeviceNode->InstancePath.Length) = L'\0';

            *RelatedDeviceInstanceLength = relatedDeviceNode->InstancePath.Length;
        } else {

            *RelatedDeviceInstanceLength = relatedDeviceNode->InstancePath.Length + sizeof(UNICODE_NULL);
            status = STATUS_BUFFER_TOO_SMALL;
        }
    } else {

        status = STATUS_NO_SUCH_DEVICE;
    }

Clean0:

    PpDevNodeUnlockTree(PPL_SIMPLE_READ);

    if (deviceObject) {

        ObDereferenceObject(deviceObject);
    }

    return status;
} // PiGetRelatedDevice

NTSTATUS
PiQueryDeviceRelations(
    IN PUNICODE_STRING DeviceInstance,
    IN PNP_QUERY_RELATION Operation,
    OUT PULONG BufferLength,
    OUT LPWSTR Buffer
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;
    PDEVICE_NODE deviceNode, relatedDeviceNode;
    IO_STACK_LOCATION irpSp;
    PDEVICE_RELATIONS deviceRelations = NULL;
    DEVICE_RELATION_TYPE relationType;
    ULONG length = 0, i;
    ULONG maxCount, currentCount;
    LPWSTR pBuffer;

    PAGED_CODE();
    //
    // Map the private operation code into a DEVICE_RELATION_TYPE enum value.
    //
    relationType = PiDeviceRelationType(Operation);
    if (relationType == (ULONG)-1) {

        return STATUS_INVALID_PARAMETER;
    }

    PpDevNodeLockTree(PPL_SIMPLE_READ);
    //
    // Retrieve the device object from the device instance string.
    //
    deviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);
    if (!deviceObject) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }
    deviceNode = deviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode != NULL);
    //
    // We don't want to bother with things not in the tree...
    //
    if ((deviceNode->State == DeviceNodeDeletePendingCloses) ||
        (deviceNode->State == DeviceNodeDeleted)) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }
    if (relationType == BusRelations) {
        //
        // Querying the bus relations from the FDO has side effects.  Besides
        // we are really interested in the current relations, not those that
        // may be appearing or disappearing.
        //
        //
        // Walk the bus relations list counting the number of children
        //
        maxCount = 0;

        for (relatedDeviceNode = deviceNode->Child;
             relatedDeviceNode != NULL;
             relatedDeviceNode = relatedDeviceNode->Sibling) {

            maxCount++;
        }

        deviceRelations = ExAllocatePool( PagedPool,
                                          sizeof(DEVICE_RELATIONS) +
                                          maxCount * sizeof(PDEVICE_OBJECT));
        if (deviceRelations != NULL) {

            deviceRelations->Count = maxCount;
            currentCount = 0;
            //
            // Walk the bus relations list counting the number of relations.
            // Note that we carefully take into account that legacy devnodes
            // can be added to the root totally asynchronously!
            //
            for (relatedDeviceNode = deviceNode->Child;
                 ((relatedDeviceNode != NULL) && (currentCount < maxCount));
                 relatedDeviceNode = relatedDeviceNode->Sibling) {

                ObReferenceObject(relatedDeviceNode->PhysicalDeviceObject);

                deviceRelations->Objects[currentCount++] =
                    relatedDeviceNode->PhysicalDeviceObject;
            }

            ASSERT(currentCount == deviceRelations->Count);
        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {
        //
        // Initialize the stack location to pass to IopSynchronousCall()
        //
        RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));
        //
        // Query the device's relations.
        //
        irpSp.MajorFunction = IRP_MJ_PNP_POWER;
        irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
        irpSp.Parameters.QueryDeviceRelations.Type = relationType;
        status = IopSynchronousCall(deviceObject, &irpSp, (PULONG_PTR)&deviceRelations);

        if (!NT_SUCCESS(status)) {

            deviceRelations = NULL;
        }
    }
    //
    // Convert these relation device objects into a multisz list of device instances
    //
    if (deviceRelations && (deviceRelations->Count > 0)) {

        pBuffer = Buffer;
        length = sizeof(UNICODE_NULL);     // account for that last extra trailing null
        for (i = 0; i < deviceRelations->Count; i++) {

            relatedDeviceNode = deviceRelations->Objects[i]->DeviceObjectExtension->DeviceNode;
            //
            // The devnode might be NULL if:
            // 1) A driver make a mistake
            // 2) We got back a removal/ejection relation on a newly created
            //    PDO that hasn't made it's way back up to the OS (we don't
            //    raise the tree lock to BlockReads while an enumeration
            //    IRP is outstanding...)
            //
            if (relatedDeviceNode) {

                if (pBuffer) {
                    //
                    // We're retrieving the device instance strings (not just determining
                    // required buffer size). Validate buffer size (including room for
                    // null terminator).
                    //
                    if (*BufferLength < length + relatedDeviceNode->InstancePath.Length + sizeof(UNICODE_NULL)) {
                        //
                        // ADRIAO ISSUE 02/06/2001 -
                        //     We aren't returning the proper length here. We
                        // need to continue on, copying nothing more yet
                        // continuing to calculate the length. This should be
                        // fixed this in XP+1, once we have time to verify no
                        // one will get an app compat break.
                        //
                        status = STATUS_BUFFER_TOO_SMALL;
                        goto Clean0;
                    }
                    //
                    // Copy this device instance over to the buffer, null terminate it, and
                    // update the length used in the buffer so far.
                    //
                    RtlCopyMemory(pBuffer,
                                  relatedDeviceNode->InstancePath.Buffer,
                                  relatedDeviceNode->InstancePath.Length);
                    pBuffer += relatedDeviceNode->InstancePath.Length / sizeof(UNICODE_NULL);
                    *pBuffer++ = L'\0';   // always need the single-term
                }

                length += relatedDeviceNode->InstancePath.Length + sizeof(UNICODE_NULL);
            }

            ObDereferenceObject(deviceRelations->Objects[i]);
        }
        if (pBuffer) {

            *pBuffer = L'\0';   // This is the last, double-term
        }
    }

Clean0:

    PpDevNodeUnlockTree(PPL_SIMPLE_READ);

    if (NT_SUCCESS(status)) {

        *BufferLength = length;
    } else {

        *BufferLength = 0;
    }

    if (deviceRelations) {

        ExFreePool(deviceRelations);
    }

    if (deviceObject) {

        ObDereferenceObject(deviceObject);
    }

    return status;
} // PiQueryDeviceRelations

DEVICE_RELATION_TYPE
PiDeviceRelationType(
    PNP_QUERY_RELATION  Operation
    )

/*++

Routine Description:

    This private routine converts the PNP_QUERY_RELATION enum value into a
    DEVICE_RELATION_TYPE enum value. User-mode and kernel-mode both know about
    PNP_QUERY_RELATION but only kernel-mode knows about DEVICE_RELATION_TYPE.

Arguments:

    Operation - Specifies a PNP_QUERY_RELATION enum value


Return Value:

    The function returns a DEVICE_RELATION_TYPE enum value.

--*/
{
    PAGED_CODE();

    switch (Operation) {
    case PnpQueryEjectRelations:
        return EjectionRelations;

    case PnpQueryRemovalRelations:
        return RemovalRelations;

    case PnpQueryPowerRelations:
        return PowerRelations;

    case PnpQueryBusRelations:
        return BusRelations;

    default:
        return (ULONG)-1;
    }

} // PiDeviceRelationType

VOID
PiControlGetUserFlagsFromDeviceNode(
    IN  PDEVICE_NODE    DeviceNode,
    OUT ULONG          *StatusFlags
    )
/*++

Routine Description:

    This private routine converts the DeviceNode's state into the
    corresponding user-mode StatusFlags.

Arguments:

    DeviceNode - Specifies the DeviceNode get retrieve user flags for.

    StatusFlags - Receives the corresponding user-mode status flags.

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    ULONG returnedFlags;

    PAGED_CODE();

    //
    // Convert DNF_Xxx flags to the appropriate status and problem values.
    // With problems, order is important since we only keep track of a single
    // problem (use the most recent problem that occured if possible).
    //
    returnedFlags = (DN_NT_DRIVER | DN_NT_ENUMERATOR);

    if (PipAreDriversLoaded(DeviceNode)) {

        returnedFlags |= DN_DRIVER_LOADED;
    }
    if (PipIsDevNodeDNStarted(DeviceNode)) {

        returnedFlags |= DN_STARTED;
    }
    if (DeviceNode->UserFlags & DNUF_WILL_BE_REMOVED) {

        returnedFlags |= DN_WILL_BE_REMOVED;
    }
    if (DeviceNode->UserFlags & DNUF_DONT_SHOW_IN_UI) {

        returnedFlags |= DN_NO_SHOW_IN_DM;
    }
    if (DeviceNode->UserFlags & DNUF_NEED_RESTART) {

        returnedFlags |= DN_NEED_RESTART;
    }
    if (DeviceNode->Flags & DNF_HAS_PRIVATE_PROBLEM) {

        returnedFlags |= DN_PRIVATE_PROBLEM;
    }
    if (DeviceNode->Flags & DNF_HAS_PROBLEM) {

        returnedFlags |= DN_HAS_PROBLEM;
    }
    if ((DeviceNode->Flags & DNF_DRIVER_BLOCKED)) {

        returnedFlags |= DN_DRIVER_BLOCKED;
    }
    if ((DeviceNode->Flags & DNF_LEGACY_DRIVER)) {

        returnedFlags |= DN_LEGACY_DRIVER;
    }
    if ((DeviceNode->Flags & DNF_CHILD_WITH_INVALID_ID)) {

        returnedFlags |= DN_CHILD_WITH_INVALID_ID;
    }
    if (DeviceNode->DisableableDepends == 0) {
        //
        // if there's no reason for us not to be disableable, flag we are disableable
        //
        returnedFlags |= DN_DISABLEABLE;
    }
    //
    // DN_ROOT_ENUMERATED is currently set on umpnpmgr side based on device
    // instance name.  We should be able to simply set this flag
    // based on the devnode's LevelNumber except that we don't want BIOS
    // enumerated devices to have the DN_ROOT_ENUMERATED flag even though they
    // are being enumerated by the root enumerator.
    //
    // DN_REMOVABLE - set on umpnpmgr side based on capabilities bits
    // DN_MANUAL - set on umpnpmgr side based on CONFIGFLAG_MANUAL_INSTALL bit.
    // DN_NO_WAIT_INSTALL ???

    *StatusFlags = returnedFlags;
}

VOID
PpShutdownSystem (
    IN BOOLEAN Reboot,
    IN ULONG Phase,
    IN OUT PVOID *Context
    )

/*++

Routine Description:

    This routine invokes real code to performs Pnp shutdown preparation.
    This is nonpage code and that's why it is so small.

Arguments:

    Reboot - specifies if the system is going to reboot.

    Phase - specifies the shutdown phase.

    Context - at phase 0, it supplies a variable to receive the returned context info.
              at phase 1, it supplies a variable to specify the context info.

Return Value:

    None.

--*/

{
#if defined(_X86_)

    if (Reboot) {

        if (!PpDisableFirmwareMapper) {

            PnPBiosShutdownSystem(Phase, Context);
        }
    }

#else

    UNREFERENCED_PARAMETER( Reboot );
    UNREFERENCED_PARAMETER( Phase );
    UNREFERENCED_PARAMETER( Context );

#endif

    if (Phase == 0) {
        ApphelpCacheShutdown(Phase);
    }

}

NTSTATUS
PiQueueDeviceRequest(
    IN PUNICODE_STRING      DeviceInstance,
    IN DEVICE_REQUEST_TYPE  RequestType,
    IN ULONG                Flags,
    IN BOOLEAN              Synchronous
    )
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;
    KEVENT completionEvent;
    NTSTATUS status;

    PAGED_CODE();

    deviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);
    if (!deviceObject) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }
    deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }
    if (Synchronous) {

        KeInitializeEvent(&completionEvent, NotificationEvent, FALSE);
    }
    status = PipRequestDeviceAction( deviceObject,
                                     RequestType,
                                     FALSE,
                                     Flags,
                                     Synchronous ? &completionEvent : NULL,
                                     NULL);
    if (NT_SUCCESS(status) && Synchronous) {

        status = KeWaitForSingleObject( &completionEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);
    }

Clean0:

    if (deviceObject != NULL) {

        ObDereferenceObject( deviceObject );
    }

    return status;
}

NTSTATUS
PiControlStartDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine starts the specified device instance.

Arguments:

    PnPControlClass - Should be PlugPlayControlStartDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be started.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlStartDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
    //
    // Validate supplied DeviceInstance.
    //
    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    //
    // Make a copy of caller supplied DeviceInstance.
    //
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                DeviceControlData->DeviceInstance.Buffer,
                instance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (NT_SUCCESS(status)) {
        //
        // Queue an event to start the device
        //
        status = PiQueueDeviceRequest(
                    &instance,
                    StartDevice,
                    0,
                    TRUE);
        //
        // Free the copy of user mode supplied DeviceInstance.
        //
        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }

    return status;
}


NTSTATUS
PiControlResetDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine "resets" a devnode, which means bringing it out of the removed
    state without actually starting it.

Arguments:

    PnPControlClass - Should be PlugPlayControlResetDevice

    ConflictData - Points to buffer that receives conflict data.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertible to user-mode Win32 error)

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    UNREFERENCED_PARAMETER (PnPControlDataLength);
    UNREFERENCED_PARAMETER (PnPControlClass);

    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                DeviceControlData->DeviceInstance.Buffer,
                DeviceControlData->DeviceInstance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (NT_SUCCESS(status)) {
        //
        // Queue an event to start the device
        //
        status = PiQueueDeviceRequest(
                    &instance,
                    ResetDevice,
                    0,
                    TRUE);

        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }
    return status;
}


NTSTATUS
PiControlInitializeDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine initializes the specified device instance.

Arguments:

    PnPControlClass - Should be PlugPlayControlInitializeDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be initialized.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlInitializeDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
    //
    // Make a copy of caller supplied DeviceInstance.
    //
    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                DeviceControlData->DeviceInstance.Buffer,
                instance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (NT_SUCCESS(status)) {

        status = PiInitializeDevice(&instance);
        //
        // Free the copy of user mode supplied DeviceInstance.
        //
        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }

    return status;
}


NTSTATUS
PiControlDeregisterDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine deregisters the specified device instance.

Arguments:

    PnPControlClass - Should be PlugPlayControlDeregisterDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be deregistered.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlDeregisterDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
    //
    // Make a copy of caller supplied DeviceInstance.
    //
    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                DeviceControlData->DeviceInstance.Buffer,
                instance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (NT_SUCCESS(status)) {
        //
        // Acquire PnP device-specific registry resource for exclusive (read/write) access.
        //
        PiLockPnpRegistry(TRUE);

        status = PiDeviceRegistration(&instance,
                                      FALSE,
                                      NULL);
        if (NT_SUCCESS(status)) {
            //
            // Remove all interfaces to this device.
            //
            IopRemoveDeviceInterfaces(&instance);
        }

        PiUnlockPnpRegistry();
        //
        // Free the copy of user mode supplied DeviceInstance.
        //
        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }

    return status;
}

NTSTATUS
PiControlRegisterNewDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine registers the specified device instance.

Arguments:

    PnPControlClass - Should be PlugPlayControlRegisterNewDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be registered.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlRegisterNewDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
    //
    // Make a copy of caller supplied DeviceInstance.
    //
    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                DeviceControlData->DeviceInstance.Buffer,
                instance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (NT_SUCCESS(status)) {

        status = PpDeviceRegistration(
                    &instance,
                    TRUE,
                    NULL);
        //
        // Free the copy of user mode supplied DeviceInstance.
        //
        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }

    return status;
}

NTSTATUS
PiControlEnumerateDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to queue reenumeration of the specified device.

Arguments:

    PnPControlClass - Should be PlugPlayControlEnumerateDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be reenumerated.

        Flags - Specifies type of reenumeration.  The following flags are
                currently defined:

          PNP_ENUMERATE_DEVICE_ONLY - Specifies shallow re-enumeration of
                specified device.  If not specified, perfoms reenumeration of
                the entire device subtree rooted at the specified device.

          PNP_ENUMERATE_ASYNCHRONOUS - Specifies that the re-enumeration should
                be done asynchronously.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlEnumerateDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));

    //
    // Make a copy of caller supplied DeviceInstance.
    //
    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                DeviceControlData->DeviceInstance.Buffer,
                instance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        return status;
    }
    //
    // Queue a request to enumerate the device
    //
    status = PiQueueDeviceRequest(
                &instance,
                (DeviceControlData->Flags & PNP_ENUMERATE_DEVICE_ONLY)  ? ReenumerateDeviceOnly : ReenumerateDeviceTree,
                0,
                (DeviceControlData->Flags & PNP_ENUMERATE_ASYNCHRONOUS) ? FALSE : TRUE);
    //
    // Free the copy of user mode supplied DeviceInstance.
    //
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);

    return status;
}

NTSTATUS
PiControlQueryAndRemoveDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA  QueryAndRemoveData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to queue query removal of the specified device.

Arguments:

    PnPControlClass - Should be PlugPlayControlQueryAndRemoveDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be query removed.

        VetoType - Vetotype for query remove failure.

        VetoName - Veto information for query remove failure.

        VetoNameLength - Length of VetoName buffer.

        Flags - Remove specific flags.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING instance;
    PWCHAR  vetoName;
    ULONG   vetoNameLength;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlQueryAndRemoveDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA));
    //
    // Validate input device instance length.
    //
    instance.Length = instance.MaximumLength = QueryAndRemoveData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    vetoName = NULL;
    instance.Buffer = NULL;
    //
    // Check if the caller wants veto information or not.
    //
    if (QueryAndRemoveData->VetoNameLength && QueryAndRemoveData->VetoName) {

        vetoNameLength = QueryAndRemoveData->VetoNameLength * sizeof(WCHAR);
    } else {

        QueryAndRemoveData->VetoNameLength = vetoNameLength = 0;
    }
    //
    // Allocate our own buffer for veto information for user mode callers,
    // otherwise use the supplied one.
    //
    status = PiControlAllocateBufferForUserModeCaller(
                &vetoName,
                vetoNameLength,
                CallerMode,
                QueryAndRemoveData->VetoName);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // Make a copy of caller supplied DeviceInstance.
    //
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                QueryAndRemoveData->DeviceInstance.Buffer,
                instance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // Queue an event to query remove the device
    //
    status = PiQueueQueryAndRemoveEvent(
                &instance,
                &QueryAndRemoveData->VetoType,
                vetoName,
                &vetoNameLength,
                QueryAndRemoveData->Flags);
    if (vetoName) {

        tempStatus = PiControlMakeUserModeCallersCopy(
                        &QueryAndRemoveData->VetoName,
                        vetoName,
                        QueryAndRemoveData->VetoNameLength * sizeof(WCHAR),
                        sizeof(WCHAR),
                        CallerMode,
                        FALSE);
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    QueryAndRemoveData->VetoNameLength = vetoNameLength / sizeof(WCHAR);
    //
    // Free vetoName buffer if we allocate one on behalf of user mode caller.
    //
Clean0:

    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, vetoName);

    return status;
}

NTSTATUS
PiControlUserResponse(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_USER_RESPONSE_DATA UserResponseData,
    IN     ULONG                                PnPControlDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    )
/*++

Routine Description:

    This routine is used to accept user mode response.

Arguments:

    PnPControlClass - Should be PlugPlayControlUserResponse.

    UserResponseData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_USER_RESPONSE_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    PWCHAR vetoName;
    ULONG vetoNameLength;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlUserResponse);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_USER_RESPONSE_DATA));

    if (UserResponseData->VetoNameLength && UserResponseData->VetoName) {

        vetoNameLength = UserResponseData->VetoNameLength * sizeof(WCHAR);
    } else {

        vetoNameLength = 0;
    }
    //
    // Make a copy of callers buffer.
    //
    status = PiControlMakeUserModeCallersCopy(
                &vetoName,
                UserResponseData->VetoName,
                vetoNameLength,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        return status;
    }
    //
    // Copy the user response.
    //
    PiUserResponse(
        UserResponseData->Response,
        UserResponseData->VetoType,
        vetoName,
        vetoNameLength);

    PiControlFreeUserModeCallersBuffer(CallerMode, vetoName);

    return STATUS_SUCCESS;
}

NTSTATUS
PiControlGenerateLegacyDevice(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA LegacyDevGenData,
    IN     ULONG                                PnPControlDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    )
/*++

Routine Description:

    This routine is used to generate legacy device instance.

Arguments:

    PnPControlClass - Should be PlugPlayControlGenerateLegacyDevice.

    UserResponseData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING service;
    ULONG instanceLength;
    PWCHAR instance;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlGenerateLegacyDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA));
    //
    // Validate service name length.
    //
    service.Length = service.MaximumLength = LegacyDevGenData->ServiceName.Length;
    if (    service.Length == 0 ||
            service.Length > CWC_TO_CB(MAX_SERVICE_NAME_LEN) ||
            (service.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    instance = NULL;
    service.Buffer = NULL;
    instanceLength = LegacyDevGenData->DeviceInstanceLength * sizeof(WCHAR);
    status = PiControlAllocateBufferForUserModeCaller(
                &instance,
                instanceLength,
                CallerMode,
                LegacyDevGenData->DeviceInstance);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiControlMakeUserModeCallersCopy(
                &service.Buffer,
                LegacyDevGenData->ServiceName.Buffer,
                service.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiGenerateLegacyDeviceInstance(
                &service,
                instance,
                &instanceLength);
    //
    // Copy the instance and length to the callers buffer.
    //
    if (instance) {

        tempStatus = PiControlMakeUserModeCallersCopy(
                        &LegacyDevGenData->DeviceInstance,
                        instance,
                        LegacyDevGenData->DeviceInstanceLength * sizeof(WCHAR),
                        sizeof(WCHAR),
                        CallerMode,
                        FALSE);
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    LegacyDevGenData->DeviceInstanceLength = instanceLength / sizeof(WCHAR);
    //
    // Release any allocated storage.
    //
Clean0:

    PiControlFreeUserModeCallersBuffer(CallerMode, service.Buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, instance);

    return status;
}

NTSTATUS
PiControlGetInterfaceDeviceList(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_INTERFACE_LIST_DATA    InterfaceData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to get devices with specified interface.

Arguments:

    PnPControlClass - Should be PlugPlayControlGetInterfaceDeviceList.

    InterfaceData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_INTERFACE_LIST_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING instance;
    PWCHAR list;
    ULONG listSize;
    GUID *guid;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlGetInterfaceDeviceList);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_INTERFACE_LIST_DATA));
    //
    // Validate device instance length if provided.
    //
    if (InterfaceData->DeviceInstance.Buffer) {

        instance.Length = instance.MaximumLength = InterfaceData->DeviceInstance.Length;
        if (    instance.Length == 0 ||
                instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
                (instance.Length & 1)) {

            return STATUS_INVALID_PARAMETER;
        }
        instance.Buffer = NULL;
    } else {

        PiWstrToUnicodeString(&instance, NULL);
    }
    list = NULL;
    guid = NULL;
    //
    // For user mode callers, allocate storage to retrieve the interfacelist.
    //
    if (InterfaceData->InterfaceListSize && InterfaceData->InterfaceList) {

        listSize = InterfaceData->InterfaceListSize * sizeof(WCHAR);
    } else {

        listSize = 0;
    }
    status = PiControlAllocateBufferForUserModeCaller(
                &list,
                listSize,
                CallerMode,
                InterfaceData->InterfaceList);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // Copy the user supplied interface GUID.
    //
    status = PiControlMakeUserModeCallersCopy(
                &guid,
                InterfaceData->InterfaceGuid,
                sizeof(GUID),
                sizeof(UCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // Copy the user supplied DeviceInstance.
    //
    if (InterfaceData->DeviceInstance.Buffer) {

        status = PiControlMakeUserModeCallersCopy(
                    &instance.Buffer,
                    InterfaceData->DeviceInstance.Buffer,
                    instance.Length,
                    sizeof(WCHAR),
                    CallerMode,
                    TRUE);
        if (!NT_SUCCESS(status)) {

            goto Clean0;
        }
    }
    //
    // Get the interface list.
    //
    status = PiGetInterfaceDeviceList(
                guid,
                &instance,
                InterfaceData->Flags,
                list,
                &listSize);
    if (list) {
        //
        // Copy the results into the caller's buffer.
        //
        tempStatus = PiControlMakeUserModeCallersCopy(
                        &InterfaceData->InterfaceList,
                        list,
                        InterfaceData->InterfaceListSize * sizeof(WCHAR),
                        sizeof(WCHAR),
                        CallerMode,
                        FALSE);
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    InterfaceData->InterfaceListSize = listSize / sizeof(WCHAR);

Clean0:
    //
    // Clean up.
    //
    PiControlFreeUserModeCallersBuffer(CallerMode, guid);
    PiControlFreeUserModeCallersBuffer(CallerMode, list);
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);

    return status;
}

NTSTATUS
PiControlGetPropertyData(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_PROPERTY_DATA  PropertyData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    )
/*++

Routine Description:

    This routine is used to get specified property data.

Arguments:

    PnPControlClass - Should be PlugPlayControlProperty.

    PropertyData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_PROPERTY_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING instance;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;
    PVOID buffer;
    ULONG bufferSize;
    DEVICE_REGISTRY_PROPERTY property;
    PWCHAR deviceLocationStrings, p;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlProperty);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_PROPERTY_DATA));

    buffer = NULL;
    instance.Length = instance.MaximumLength = PropertyData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                PropertyData->DeviceInstance.Buffer,
                instance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        return status;
    }
    //
    // Retrieve the physical device object that corresponds to this devinst
    //
    PpDevNodeLockTree(PPL_SIMPLE_READ);

    deviceObject = IopDeviceObjectFromDeviceInstance(&instance);

    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    if (!deviceObject) {

        PpDevNodeUnlockTree(PPL_SIMPLE_READ);
        return STATUS_NO_SUCH_DEVICE;
    }
    //
    // Retrieve the device node for this device object.
    //
    deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {

        status = STATUS_NO_SUCH_DEVICE;
        bufferSize = 0;
        goto Clean0;
    }
    bufferSize = PropertyData->BufferSize;
    status = PiControlAllocateBufferForUserModeCaller(
        &buffer,
        bufferSize,
        CallerMode,
        PropertyData->Buffer
        );

    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }

    switch(PropertyData->PropertyType) {

        case PNP_PROPERTY_PDONAME:
            property = DevicePropertyPhysicalDeviceObjectName;
            break;

        case PNP_PROPERTY_BUSTYPEGUID:
            property = DevicePropertyBusTypeGuid;
            break;

        case PNP_PROPERTY_LEGACYBUSTYPE:
            property = DevicePropertyLegacyBusType;
            break;

        case PNP_PROPERTY_BUSNUMBER:
            property = DevicePropertyBusNumber;
            break;

        case PNP_PROPERTY_ADDRESS:
            property = DevicePropertyAddress;
            break;

        case PNP_PROPERTY_POWER_DATA:
            status = PiControlGetDevicePowerData(
                deviceNode,
                CallerMode,
                bufferSize,
                buffer,
                &PropertyData->BufferSize
                );
            if (status == STATUS_BUFFER_OVERFLOW) {

                //
                // See comment in NtPlugPlayControl.
                //
                status = STATUS_BUFFER_TOO_SMALL;
            }
            goto Clean0;

        case PNP_PROPERTY_REMOVAL_POLICY:
            property = DevicePropertyRemovalPolicy;
            break;

        case PNP_PROPERTY_REMOVAL_POLICY_OVERRIDE:

            status = PiGetDeviceRegistryProperty(
                deviceObject,
                REG_DWORD,
                REGSTR_VALUE_REMOVAL_POLICY,
                NULL,
                buffer,
                &PropertyData->BufferSize
                );

            goto Clean0;

        case PNP_PROPERTY_REMOVAL_POLICY_HARDWARE_DEFAULT:

            if (bufferSize >= sizeof(ULONG)) {

                PpHotSwapGetDevnodeRemovalPolicy(
                    deviceNode,
                    FALSE, // Include Registry Override
                    (PDEVICE_REMOVAL_POLICY) buffer
                    );

                status = STATUS_SUCCESS;
            } else {

                status = STATUS_BUFFER_TOO_SMALL;
            }

            PropertyData->BufferSize = sizeof(ULONG);

            goto Clean0;

        case PNP_PROPERTY_INSTALL_STATE:
            property = DevicePropertyInstallState;
            break;

        case PNP_PROPERTY_LOCATION_PATHS:

            deviceLocationStrings = NULL;

            status =
                PpCriticalGetDeviceLocationStrings(
                    deviceNode,
                    &deviceLocationStrings);

            if (NT_SUCCESS(status)) {

                ASSERT(deviceLocationStrings != NULL);

                //
                // Compute the length of the returned multi-sz list.
                //

                p = deviceLocationStrings;

                while (*p != UNICODE_NULL) {
                    p += wcslen(p) + 1;
                }

                //
                // Compute the required buffer length, in bytes.
                //
                PropertyData->BufferSize =
                    (ULONG)(((PUCHAR)p - (PUCHAR)deviceLocationStrings) + sizeof(UNICODE_NULL));

                if (PropertyData->BufferSize <= bufferSize) {

                    RtlCopyMemory(
                        buffer,
                        deviceLocationStrings,
                        PropertyData->BufferSize);

                } else {
                    status = STATUS_BUFFER_TOO_SMALL;
                }

                ExFreePool(deviceLocationStrings);
            }
            goto Clean0;

        default:
            status = STATUS_INVALID_PARAMETER;
            property = DevicePropertyInstallState;  // satisfy W4 compiler
            break;
    }
    if (NT_SUCCESS(status)) {

        status = IoGetDeviceProperty( deviceObject,
                                      property,
                                      bufferSize,
                                      buffer,
                                      &PropertyData->BufferSize
                                      );
    }

Clean0:

    PpDevNodeUnlockTree(PPL_SIMPLE_READ);
    ObDereferenceObject(deviceObject);

    tempStatus = PiControlMakeUserModeCallersCopy(
        &PropertyData->Buffer,
        buffer,
        bufferSize,
        sizeof(UCHAR),
        CallerMode,
        FALSE
        );
    if (!NT_SUCCESS(tempStatus)) {

        status = tempStatus;
    }
    PiControlFreeUserModeCallersBuffer(CallerMode, buffer);

    return status;
}

NTSTATUS
PiControlDeviceClassAssociation(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA AssociationData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to get device class association.

Arguments:

    PnPControlClass - Should be PlugPlayControlDeviceClassAssociation.

    AssociationData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    GUID *guid;
    ULONG symLinkLength;
    PWCHAR symLink;
    UNICODE_STRING instance, reference;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlDeviceClassAssociation);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA));
    //
    // Validate lengths of unicode strings.
    //
    if (AssociationData->Register) {

        instance.Length = instance.MaximumLength = AssociationData->DeviceInstance.Length;
        if (    instance.Length == 0 ||
                instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
                (instance.Length & 1)) {

            return STATUS_INVALID_PARAMETER;
        }
        reference.Length = reference.MaximumLength = AssociationData->Reference.Length;
        if (reference.Length & 1) {

            return STATUS_INVALID_PARAMETER;
        }
    }
    symLink = NULL;
    guid = NULL;
    instance.Buffer = NULL;
    reference.Buffer = NULL;

    if (AssociationData->SymLinkLength && AssociationData->SymLink) {

        symLinkLength = AssociationData->SymLinkLength * sizeof(WCHAR);
    } else {

        symLinkLength = 0;
    }
    if (AssociationData->Register) {
        //
        // If registering a device interface, allocate a buffer that is the same
        // size as the one supplied by the caller.
        //
        status = PiControlAllocateBufferForUserModeCaller(
                    &symLink,
                    symLinkLength,
                    CallerMode,
                    AssociationData->SymLink);
        if (!NT_SUCCESS(status)) {

            goto Clean0;
        }
        //
        // Copy the user supplied interface GUID, DeviceInstance and Reference.
        //
        status = PiControlMakeUserModeCallersCopy(
                    &guid,
                    AssociationData->InterfaceGuid,
                    AssociationData->InterfaceGuid ? sizeof(GUID) : 0,
                    sizeof(UCHAR),
                    CallerMode,
                    TRUE);
        if (!NT_SUCCESS(status)) {

            goto Clean0;
        }
        status = PiControlMakeUserModeCallersCopy(
                    &instance.Buffer,
                    AssociationData->DeviceInstance.Buffer,
                    AssociationData->DeviceInstance.Length,
                    sizeof(WCHAR),
                    CallerMode,
                    TRUE);
        if (!NT_SUCCESS(status)) {

            goto Clean0;
        }
        status = PiControlMakeUserModeCallersCopy(
                    &reference.Buffer,
                    AssociationData->Reference.Buffer,
                    AssociationData->Reference.Length,
                    sizeof(WCHAR),
                    CallerMode,
                    TRUE);
        if (!NT_SUCCESS(status)) {

            goto Clean0;
        }

    } else {
        //
        // If unregistering a device interface, allocate and copy only the
        // symbolic link path supplied by the caller.  Interface GUID,
        // DeviceInstance, and Reference are not required for unregistration.
        //
        if (symLinkLength < sizeof(UNICODE_NULL)) {

            status = STATUS_INVALID_PARAMETER;
            goto Clean0;
        }

        status = PiControlMakeUserModeCallersCopy(
                    &symLink,
                    AssociationData->SymLink,
                    symLinkLength,
                    sizeof(WCHAR),
                    CallerMode,
                    TRUE);
        if (!NT_SUCCESS(status)) {

            goto Clean0;
        }
        //
        // Make sure the user-supplied buffer is NULL terminated, (the length
        // supplied must reflect that).
        //
        symLink[(symLinkLength - sizeof(UNICODE_NULL)) / sizeof(WCHAR)] = L'\0';
    }
    //
    // Register or unregister the device class association.
    //
    status = PiDeviceClassAssociation(
                &instance,
                guid,
                &reference,
                symLink,
                &symLinkLength,
                AssociationData->Register);
    //
    // If a symbolic link was registered, copy the symbolic link name to the
    // caller's buffer.
    //
    if (AssociationData->Register && symLink && NT_SUCCESS(status)) {

        tempStatus = PiControlMakeUserModeCallersCopy(
                        &AssociationData->SymLink,
                        symLink,
                        AssociationData->SymLinkLength * sizeof(WCHAR),
                        sizeof(WCHAR),
                        CallerMode,
                        FALSE);
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    //
    // Return the size of the symbolic link name, in characters.
    //
    AssociationData->SymLinkLength = symLinkLength / sizeof(WCHAR);

Clean0:
    //
    // Clean up.
    //
    PiControlFreeUserModeCallersBuffer(CallerMode, guid);
    PiControlFreeUserModeCallersBuffer(CallerMode, symLink);
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, reference.Buffer);

    return status;
}

NTSTATUS
PiControlGetRelatedDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_RELATED_DEVICE_DATA    RelatedData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to get a related device.

Arguments:

    PnPControlClass - Should be PlugPlayControlGetRelatedDevice.

    RelatedData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_RELATED_DEVICE_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING instance;
    PWCHAR buffer;
    ULONG length;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlGetRelatedDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_RELATED_DEVICE_DATA));
    //
    // Validate length of device instance.
    //
    instance.Length = instance.MaximumLength = RelatedData->TargetDeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    buffer = NULL;
    instance.Buffer = NULL;
    if (RelatedData->RelatedDeviceInstance && RelatedData->RelatedDeviceInstanceLength) {

        length = RelatedData->RelatedDeviceInstanceLength * sizeof(WCHAR);
    } else {

        length = 0;
    }
    status = PiControlAllocateBufferForUserModeCaller(
                &buffer,
                length,
                CallerMode,
                RelatedData->RelatedDeviceInstance);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                RelatedData->TargetDeviceInstance.Buffer,
                instance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiGetRelatedDevice(
                &instance,
                buffer,
                &length,
                RelatedData->Relation);
    if (buffer) {

        tempStatus = PiControlMakeUserModeCallersCopy(
                        &RelatedData->RelatedDeviceInstance,
                        buffer,
                        RelatedData->RelatedDeviceInstanceLength * sizeof(WCHAR),
                        sizeof(WCHAR),
                        CallerMode,
                        FALSE);
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    RelatedData->RelatedDeviceInstanceLength = length / sizeof(WCHAR);

Clean0:
    //
    // Release any allocated storage.
    //
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, buffer);

    return status;
}

NTSTATUS
PiControlGetInterfaceDeviceAlias(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA   InterfaceAliasData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to get alias for device interface.

Arguments:

    PnPControlClass - Should be PlugPlayControlGetInterfaceDeviceAlias.

    InterfaceAliasData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    PWCHAR alias;
    UNICODE_STRING linkName;
    GUID *guid;
    ULONG aliasLength;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlGetInterfaceDeviceAlias);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA));
    //
    // Validate length of unicode string.
    //
    linkName.Length = linkName.MaximumLength = InterfaceAliasData->SymbolicLinkName.Length;
    if (linkName.Length & 1) {

        return STATUS_INVALID_PARAMETER;
    }
    alias = NULL;
    guid = NULL;
    linkName.Buffer = NULL;
    if (InterfaceAliasData->AliasSymbolicLinkName && InterfaceAliasData->AliasSymbolicLinkNameLength) {

        aliasLength = InterfaceAliasData->AliasSymbolicLinkNameLength * sizeof(WCHAR);
    } else {

        aliasLength = 0;
    }
    status = PiControlAllocateBufferForUserModeCaller(
                &alias,
                aliasLength,
                CallerMode,
                InterfaceAliasData->AliasSymbolicLinkName);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiControlMakeUserModeCallersCopy(
                &guid,
                InterfaceAliasData->AliasClassGuid,
                sizeof(GUID),
                sizeof(UCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiControlMakeUserModeCallersCopy(
                &linkName.Buffer,
                InterfaceAliasData->SymbolicLinkName.Buffer,
                linkName.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiGetInterfaceDeviceAlias(
                &linkName,
                guid,
                alias,
                &aliasLength);
    if (alias) {

        tempStatus = PiControlMakeUserModeCallersCopy(
                        &InterfaceAliasData->AliasSymbolicLinkName,
                        alias,
                        InterfaceAliasData->AliasSymbolicLinkNameLength * sizeof(WCHAR),
                        sizeof(WCHAR),
                        CallerMode,
                        FALSE);
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    InterfaceAliasData->AliasSymbolicLinkNameLength = aliasLength / sizeof(WCHAR);

Clean0:
    //
    // Release any allocated storage.
    //
    PiControlFreeUserModeCallersBuffer(CallerMode, alias);
    PiControlFreeUserModeCallersBuffer(CallerMode, guid);
    PiControlFreeUserModeCallersBuffer(CallerMode, linkName.Buffer);

    return status;
}


NTSTATUS
PiControlGetSetDeviceStatus(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_STATUS_DATA    StatusData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    )
/*++

Routine Description:

    This routine is used to get the cfgmgr32 status and problem values from
    the specified device instance, or to set the appropriate flags on the devnode
    so that they reflect the status and problem values (used by CM_Set_DevNode_Status).

Arguments:

    PnPControlClass - Should be PlugPlayControlDeviceStatus.

    StatusData - Points to buffer describing the operation.

        PNP_GET_STATUS:

            DeviceInstance - specifies the device instance name of the devnode
                             to return status information for.

            Status - returns the current devnode status.

            Problem - returns the current devnode problem (most recent).

        PNP_SET_STATUS or PNP_CLEAR_STATUS:

            DeviceInstance - specifies the device instance name of the devnode
                             whose internal flags are to be modified.

            Status - supplies the address of a variable containing cfgmgr32
                     status flags to be translated into their DNF counterparts
                     to be set/cleared.

            Problem - supplies the address of a variable containing a cfgmgr32
                      problem value to be translated into their DNF
                      counterparts to be set/cleared.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_STATUS_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    UNICODE_STRING instance;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode = NULL;
    NTSTATUS status, result;
    KEVENT event;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlDeviceStatus);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_STATUS_DATA));

    instance.Length = instance.MaximumLength = StatusData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                StatusData->DeviceInstance.Buffer,
                StatusData->DeviceInstance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        return status;
    }
    PpDevNodeLockTree(PPL_SIMPLE_READ);
    //
    // Retrieve the PDO from the device instance string.
    //
    deviceObject = IopDeviceObjectFromDeviceInstance(&instance);

    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    if (deviceObject != NULL) {
        //
        // Retrieve the devnode from the PDO
        //
        deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    }
    PpDevNodeUnlockTree(PPL_SIMPLE_READ);

    if (deviceNode == NULL ||
        deviceNode == IopRootDeviceNode) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    switch(StatusData->Operation) {

        case PNP_GET_STATUS:

            //
            // Retrieve the status from the devnode and convert it to a
            // user-mode Win95 style Problem and Status flag values.
            //
            PiControlGetUserFlagsFromDeviceNode(
                deviceNode,
                &StatusData->DeviceStatus);

            StatusData->DeviceProblem = deviceNode->Problem;

            status = STATUS_SUCCESS;
            break;

        case PNP_SET_STATUS:

            KeInitializeEvent(&event, NotificationEvent, FALSE);

            status = PipRequestDeviceAction( deviceObject,
                                             SetDeviceProblem,
                                             FALSE,
                                             (ULONG_PTR) StatusData,
                                             &event,
                                             &result);

            if (NT_SUCCESS(status)) {

                status = KeWaitForSingleObject( &event,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);
                if (status == STATUS_WAIT_0) {

                    status = result;
                }
            }

            break;

        case PNP_CLEAR_STATUS:

            KeInitializeEvent(&event, NotificationEvent, FALSE);

            status = PipRequestDeviceAction( deviceObject,
                                             ClearDeviceProblem,
                                             FALSE,
                                             0,
                                             &event,
                                             &result);
            if (NT_SUCCESS(status)) {

                status = KeWaitForSingleObject( &event,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);
                if (status == STATUS_WAIT_0) {

                    status = result;
                }

            }
            break;

        default:
            //
            // ISSUE - 2000/08/16 - ADRIAO: Maintain behavior?
            //     We always used to succeed anything not understood!
            //
            status = STATUS_SUCCESS;
            //status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

Clean0:
    //
    // Release any reference to the device object before returning.
    //
    if (deviceObject != NULL) {

        ObDereferenceObject(deviceObject);
    }

    return status;
}


NTSTATUS
PiControlGetDeviceDepth(
    IN     PLUGPLAY_CONTROL_CLASS       PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEPTH_DATA DepthData,
    IN     ULONG                        PnPControlDataLength,
    IN     KPROCESSOR_MODE              CallerMode
    )
/*++

Routine Description:

    This routine is invoked to return the depth of a particular devnode (i.e,
    it's depth in the hierarchical devnode tree of parent-child relations).

Arguments:

    PnPControlClass - Should be PlugPlayControlGetDeviceDepth.

    DepthData - Points to buffer that receives the depth.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEPTH_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertible to user-mode Win32 error)

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;
    UNICODE_STRING instance;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlGetDeviceDepth);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEPTH_DATA));

    instance.Length = instance.MaximumLength = DepthData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                DepthData->DeviceInstance.Buffer,
                DepthData->DeviceInstance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        return status;
    }
    status = STATUS_NO_SUCH_DEVICE;
    //
    // Initiliaze output parameter.
    //
    DepthData->DeviceDepth = 0;

    PpDevNodeLockTree(PPL_SIMPLE_READ);
    //
    // Retrieve the PDO from the device instance string.
    //
    deviceObject = IopDeviceObjectFromDeviceInstance(&instance);
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    if (deviceObject) {

        //
        // Retrieve the devnode from the PDO
        //
        deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
        if (deviceNode) {

            DepthData->DeviceDepth = deviceNode->Level;
            status = STATUS_SUCCESS;
        }
        ObDereferenceObject(deviceObject);
    }

    PpDevNodeUnlockTree(PPL_SIMPLE_READ);

    return status;
}

NTSTATUS
PiControlQueryDeviceRelations(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA  RelationsData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is invoked to query and return the device relations of a
    particular devnode.

Arguments:

    PnPControlClass - Should be PlugPlayControlQueryDeviceRelations.

    RelationsData - Points to buffer that receives the depth.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertible to user-mode Win32 error)

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING instance;
    ULONG length;
    PVOID buffer;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlQueryDeviceRelations);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA));
    //
    // Validate device instance.
    //
    instance.Length = instance.MaximumLength = RelationsData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    buffer = NULL;
    instance.Buffer = NULL;
    if (RelationsData->BufferLength && RelationsData->Buffer) {

        length = RelationsData->BufferLength * sizeof(WCHAR);
    } else {

        length = 0;
    }
    status = PiControlAllocateBufferForUserModeCaller(
                &buffer,
                length,
                CallerMode,
                RelationsData->Buffer);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                RelationsData->DeviceInstance.Buffer,
                instance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiQueryDeviceRelations(&instance,
                                    RelationsData->Operation,
                                    &length,
                                    buffer);
    if (buffer) {

        tempStatus = PiControlMakeUserModeCallersCopy(
                        &RelationsData->Buffer,
                        buffer,
                        RelationsData->BufferLength * sizeof(WCHAR),
                        sizeof(WCHAR),
                        CallerMode,
                        FALSE);
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    RelationsData->BufferLength  = length / sizeof(WCHAR);

Clean0:

    PiControlFreeUserModeCallersBuffer(CallerMode, buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);

    return status;
}

NTSTATUS
PiControlQueryTargetDeviceRelation(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_TARGET_RELATION_DATA   TargetData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is invoked to query and return the target device relations of a
    particular devnode.

Arguments:

    PnPControlClass - Should be PlugPlayControlTargetDeviceRelation.

    TargetData - Points to buffer that receives the depth.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_TARGET_RELATION_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertible to user-mode Win32 error)

--*/
{
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_NODE deviceNode;
    ULONG requiredLength;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlTargetDeviceRelation);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_TARGET_RELATION_DATA));
    //
    // Retrieve the file object for the specified file handle.
    //
    status = ObReferenceObjectByHandle(
                TargetData->UserFileHandle,
                FILE_ANY_ACCESS,
                IoFileObjectType,
                CallerMode,
                (PVOID *)&fileObject,
                NULL);
    if (!NT_SUCCESS(status)) {

        return status;
    }
    deviceNode = NULL;
    TargetData->DeviceInstanceLen *= sizeof(WCHAR);
    //
    // Now retrieve the actual target device object associate with this
    // file object.
    //
    status = IopGetRelatedTargetDevice(fileObject, &deviceNode);
    if (!NT_SUCCESS(status)) {

        goto Clean;
    }
    ASSERT(deviceNode);

    requiredLength = deviceNode->InstancePath.Length + sizeof(UNICODE_NULL);
    if (TargetData->DeviceInstanceLen < requiredLength) {

        status = STATUS_BUFFER_TOO_SMALL;
        TargetData->DeviceInstanceLen = requiredLength;
        goto Clean;
    }
    TargetData->DeviceInstanceLen = requiredLength;
    status = PiControlCopyUserModeCallersBuffer(
                TargetData->DeviceInstance,
                deviceNode->InstancePath.Buffer,
                requiredLength,
                sizeof(WCHAR),
                CallerMode,
                FALSE);

Clean:

    TargetData->DeviceInstanceLen /= sizeof(WCHAR);
    if (deviceNode) {
        //
        // Drop the reference placed by IopGetRelatedTargetDevice.
        //
        ObDereferenceObject(deviceNode->PhysicalDeviceObject);
    }

    ObDereferenceObject(fileObject);

    return status;
}

NTSTATUS
PiControlQueryConflictList(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_CONFLICT_DATA  ConflictData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    )
/*++

Routine Description:

    This routine retrieves device conflict data.

    NOTE: This routine surpasses PiDetectResourceConflict in functionality

Arguments:

    PnPControlClass - Should be PlugPlayControlQueryConflictList

    ConflictData - Points to buffer that receives conflict data.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_CONFLICT_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertible to user-mode Win32 error)

--*/
{
    NTSTATUS status, tempStatus;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;
    PVOID list, buffer;
    UNICODE_STRING instance;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlQueryConflictList);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_CONFLICT_DATA));
    //
    // Sanity check the conflict list size.
    //
    if (    ConflictData->ConflictBuffer == NULL ||
            ConflictData->ConflictBufferSize < MIN_CONFLICT_LIST_SIZE) {

        return STATUS_BUFFER_TOO_SMALL;
    }
    //
    // Make sure the resource list has one and only one descriptor.
    //
    if (    ConflictData->ResourceList == NULL ||
            ConflictData->ResourceListSize < sizeof(CM_RESOURCE_LIST) ||
            ConflictData->ResourceList->Count != 1 ||
            ConflictData->ResourceList->List[0].PartialResourceList.Count != 1) {

        return STATUS_INVALID_PARAMETER;
    }
    //
    // Validate instance path.
    //
    instance.Length = instance.MaximumLength = ConflictData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    list = NULL;
    buffer = NULL;
    deviceObject = NULL;
    instance.Buffer = NULL;
    status = PiControlMakeUserModeCallersCopy(
                &list,
                ConflictData->ResourceList,
                ConflictData->ResourceListSize,
                sizeof(UCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiControlAllocateBufferForUserModeCaller(
                &buffer,
                ConflictData->ConflictBufferSize,
                CallerMode,
                ConflictData->ConflictBuffer);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                ConflictData->DeviceInstance.Buffer,
                ConflictData->DeviceInstance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // Preinit for failure
    //
    status = STATUS_NO_SUCH_DEVICE;
    //
    // We don't do simple reads because we want to ensure we don't send this
    // while a remove is in progress...
    //
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);
    //
    // Retrieve the PDO from the device instance string.
    //
    deviceObject = IopDeviceObjectFromDeviceInstance(&instance);
    if (deviceObject) {
        //
        // Retrieve the devnode from the PDO
        //
        deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
        //
        // We don't want to bother with things not in the tree, and we want to
        // skip the root.
        //
        if (    deviceNode && deviceNode != IopRootDeviceNode &&
                deviceNode->State != DeviceNodeDeletePendingCloses &&
                deviceNode->State != DeviceNodeDeleted) {
            //
            // parameters validated
            //
            status = IopQueryConflictList(
                        deviceObject,
                        list,
                        ConflictData->ResourceListSize,
                        buffer,
                        ConflictData->ConflictBufferSize,
                        ConflictData->Flags);

            tempStatus = PiControlMakeUserModeCallersCopy(
                            &ConflictData->ConflictBuffer,
                            buffer,
                            ConflictData->ConflictBufferSize,
                            sizeof(UCHAR),
                            CallerMode,
                            FALSE);
            if (!NT_SUCCESS(tempStatus)) {

                status = tempStatus;
            }
        }
    }

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

Clean0:

    PiControlFreeUserModeCallersBuffer(CallerMode, list);
    PiControlFreeUserModeCallersBuffer(CallerMode, buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    if (deviceObject) {

        ObDereferenceObject(deviceObject);
    }

    ConflictData->Status = status;
    return status;
}

NTSTATUS
PiControlRetrieveDockData(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA DockData,
    IN     ULONG                                PnPControlDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    )
/*++

Routine Description:

    This routine retrieves dock data.

Arguments:

    PnPControlClass - Should be PlugPlayControlRetrieveDock

    ConflictData - Points to buffer that receives conflict data.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertible to user-mode Win32 error)

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT dockDevice;
    PDEVICE_NODE deviceNode;
    ULONG requiredSize;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    ASSERT(PnPControlClass == PlugPlayControlRetrieveDock);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA));

    requiredSize = DockData->DeviceInstanceLength * sizeof(WCHAR);
    dockDevice = PpProfileRetrievePreferredDockToEject();
    if (dockDevice == NULL) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }
    deviceNode = (PDEVICE_NODE)dockDevice->DeviceObjectExtension->DeviceNode;
    if (deviceNode == NULL) {

        ASSERT(deviceNode);
        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }
    requiredSize = deviceNode->InstancePath.Length + sizeof(UNICODE_NULL);
    if (DockData->DeviceInstanceLength < requiredSize) {

        status = STATUS_BUFFER_TOO_SMALL;
        goto Clean0;
    }
    status = PiControlCopyUserModeCallersBuffer(
                DockData->DeviceInstance,
                deviceNode->InstancePath.Buffer,
                requiredSize,
                sizeof(WCHAR),
                CallerMode,
                FALSE);
Clean0:

    DockData->DeviceInstanceLength = requiredSize / sizeof(WCHAR);
    if (dockDevice) {

        ObDereferenceObject(dockDevice);
    }

    return status;
}

NTSTATUS
PiControlGetDevicePowerData(
    IN  PDEVICE_NODE        DeviceNode,
    IN  KPROCESSOR_MODE     CallerMode,
    IN  ULONG               OutputBufferLength,
    IN  PVOID               PowerDataBuffer     OPTIONAL,
    OUT ULONG              *BytesWritten
    )
/*++

Routine Description:

    This routine retrieves power information for a given devnode.

Arguments:

    DeviceNode - The device node to retrieve CM_POWER_DATA for.

    CallerMode - Processor mode of caller (UserMode/KernelMode)

    OutputBufferLength - Size of the output buffer.

    PowerDataBuffer - Points to buffer that receives the power data.

    BytesWritten - Receives the number of bytes written into the buffer.

Return Value:

    NTSTATUS code (note: must be convertible to user-mode Win32 error)
                  If the status is STATUS_BUFFER_OVERFLOW, BytesWritten isn't
                  filled with OutputBufferLength, but rather the full size of
                  the requested structure.

--*/
{
    NTSTATUS status;
    DEVICE_CAPABILITIES deviceCapabilities;
    DEVICE_POWER_STATE dState, deepestDeviceWakeState;
    SYSTEM_POWER_STATE sState;
    ULONG i;
    CM_POWER_DATA cmPowerData;

    UNREFERENCED_PARAMETER (CallerMode);

    //
    // The structure size serves as a versioning mechanism. Since we only have
    // one version of the data today, we don't have to test OutputBufferLength.
    //
    cmPowerData.PD_Size = sizeof(CM_POWER_DATA);

    *BytesWritten = 0;
    if (OutputBufferLength < sizeof(ULONG)) {

        //
        // Assume the *minimum* structure size.
        //
        *BytesWritten = cmPowerData.PD_Size;
        return STATUS_BUFFER_OVERFLOW;
    }

    status = PpIrpQueryCapabilities(DeviceNode->PhysicalDeviceObject, &deviceCapabilities);

    if (!NT_SUCCESS(status)) {

        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Fill out the "current" power state. Nonstarted devices are said to be
    // in D3.
    //
    if (PipIsDevNodeDNStarted(DeviceNode)) {

        PoGetDevicePowerState(
            DeviceNode->PhysicalDeviceObject,
            &cmPowerData.PD_MostRecentPowerState
            );

    } else {

        cmPowerData.PD_MostRecentPowerState = PowerDeviceD3;
    }

    //
    // Fill out the power data.
    //
    cmPowerData.PD_Capabilities = PDCAP_D0_SUPPORTED | PDCAP_D3_SUPPORTED;

    if (deviceCapabilities.DeviceD1) {

        cmPowerData.PD_Capabilities |= PDCAP_D1_SUPPORTED;
    }

    if (deviceCapabilities.DeviceD2) {

        cmPowerData.PD_Capabilities |= PDCAP_D2_SUPPORTED;
    }

    if (deviceCapabilities.WakeFromD0) {

        cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D0_SUPPORTED;
    }

    if (deviceCapabilities.WakeFromD1) {

        cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D1_SUPPORTED;
    }

    if (deviceCapabilities.WakeFromD2) {

        cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D2_SUPPORTED;
    }

    if (deviceCapabilities.WakeFromD3) {

        cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D3_SUPPORTED;
    }

    if (deviceCapabilities.WarmEjectSupported) {

        cmPowerData.PD_Capabilities |= PDCAP_WARM_EJECT_SUPPORTED;
    }

    RtlCopyMemory(
        cmPowerData.PD_PowerStateMapping,
        deviceCapabilities.DeviceState,
        sizeof(cmPowerData.PD_PowerStateMapping)
        );

    cmPowerData.PD_D1Latency = deviceCapabilities.D1Latency;
    cmPowerData.PD_D2Latency = deviceCapabilities.D2Latency;
    cmPowerData.PD_D3Latency = deviceCapabilities.D3Latency;

    //
    // First examine DeviceWake, then SystemWake, and update the Wake/D-state
    // bits appropriately. This is for those older WDM 1.0 bus drivers that
    // don't bother to set the DeviceDx and WakeFromDx fields.
    //
    dState = deviceCapabilities.DeviceWake;
    for(i=0; i<2; i++) {

        switch(dState) {

            case PowerDeviceD0:
                cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D0_SUPPORTED;
                break;
            case PowerDeviceD1:
                cmPowerData.PD_Capabilities |= ( PDCAP_D1_SUPPORTED |
                                                 PDCAP_WAKE_FROM_D1_SUPPORTED );
                break;
            case PowerDeviceD2:
                cmPowerData.PD_Capabilities |= ( PDCAP_D2_SUPPORTED |
                                                 PDCAP_WAKE_FROM_D2_SUPPORTED );
                break;
            case PowerDeviceD3:
                cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D3_SUPPORTED;
                break;
            default:
                ASSERT(0);
            case PowerDeviceUnspecified:
                break;
        }

        if (deviceCapabilities.SystemWake != PowerSystemUnspecified) {

            dState = deviceCapabilities.DeviceState[deviceCapabilities.SystemWake];

        } else {

            dState = PowerDeviceUnspecified;
        }
    }

    //
    // Calculate the deepest D state for wake
    //
    if (cmPowerData.PD_Capabilities & PDCAP_WAKE_FROM_D3_SUPPORTED) {

        deepestDeviceWakeState = PowerDeviceD3;

    } else if (cmPowerData.PD_Capabilities & PDCAP_WAKE_FROM_D2_SUPPORTED) {

        deepestDeviceWakeState = PowerDeviceD2;

    } else if (cmPowerData.PD_Capabilities & PDCAP_WAKE_FROM_D1_SUPPORTED) {

        deepestDeviceWakeState = PowerDeviceD1;

    } else if (cmPowerData.PD_Capabilities & PDCAP_WAKE_FROM_D0_SUPPORTED) {

        deepestDeviceWakeState = PowerDeviceD0;

    } else {

        deepestDeviceWakeState = PowerDeviceUnspecified;
    }

    //
    // Now fill in the SystemWake field. If this field is unspecified, then we
    // should infer it from the D-state information.
    //
    sState = deviceCapabilities.SystemWake;
    if (sState != PowerSystemUnspecified) {

        //
        // The D-state for SystemWake should provide enough power to cover
        // the deepest device wake state we've found. The only reason this field
        // exists is:
        // 1) Some systems can handle WakeFromS4/S5, while most can't.
        // 2) Some systems use the S state as a proxy for describing
        //    D3Hot/D3Cold dependancies.
        //
        ASSERT(deviceCapabilities.DeviceState[sState] <= deepestDeviceWakeState);

    } else if (deepestDeviceWakeState != PowerDeviceUnspecified) {

        //
        // A system wake state wasn't specified, examine each S state and pick
        // the first one that supplies enough power to wake the system. Note
        // that we start with S3. If a driver doesn't set the SystemWake field
        // but can wake the system from D3, we do *not* assume the driver can
        // wake the system from S4 or S5.
        //
        for(sState=PowerSystemSleeping3; sState>=PowerSystemWorking; sState--) {

            if ((deviceCapabilities.DeviceState[i] != PowerDeviceUnspecified) &&
                (deviceCapabilities.DeviceState[i] <= deepestDeviceWakeState)) {

                break;
            }
        }

        //
        // If we didn't find a state, sState is PowerSystemUnspecified.
        //
    }

    cmPowerData.PD_DeepestSystemWake = sState;

    if (OutputBufferLength < cmPowerData.PD_Size) {

        if (ARGUMENT_PRESENT(PowerDataBuffer)) {

            RtlCopyMemory(PowerDataBuffer, &cmPowerData, OutputBufferLength);
        }

        *BytesWritten = cmPowerData.PD_Size;
        status = STATUS_BUFFER_OVERFLOW;

    } else {

        if (ARGUMENT_PRESENT(PowerDataBuffer)) {

            RtlCopyMemory(PowerDataBuffer, &cmPowerData, cmPowerData.PD_Size);
        }

        *BytesWritten = cmPowerData.PD_Size;
        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
PiControlHaltDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine simulates a surprise remove for a given device.

Arguments:

    PnPControlClass - Should be PlugPlayControlHaltDevice

    ConflictData - Points to buffer that receives conflict data.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertible to user-mode Win32 error)

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlClass);
    UNREFERENCED_PARAMETER (PnPControlDataLength);

    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    if (    instance.Length == 0 ||
            instance.Length > CWC_TO_CB(MAX_DEVICE_ID_LEN) ||
            (instance.Length & 1)) {

        return STATUS_INVALID_PARAMETER;
    }
    status = PiControlMakeUserModeCallersCopy(
                &instance.Buffer,
                DeviceControlData->DeviceInstance.Buffer,
                DeviceControlData->DeviceInstance.Length,
                sizeof(WCHAR),
                CallerMode,
                TRUE);
    if (NT_SUCCESS(status)) {

        //
        // Queue an event to start the device
        //
        status = PiQueueDeviceRequest(
                    &instance,
                    HaltDevice,
                    DeviceControlData->Flags,
                    TRUE);

        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }
    return status;
}

NTSTATUS
PiControlGetBlockedDriverData(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA    BlockedDriverData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine retrieves the information about drivers blocked from loading
    on this boot.

Arguments:

    PnPControlClass - Should be PlugPlayControlHaltDevice

    BlockedDriverData - Points to buffer that receives blocked driver data.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertible to user-mode Win32 error)

--*/
{
    NTSTATUS status, tempStatus;
    ULONG length;
    PWCHAR buffer;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (PnPControlDataLength);
    UNREFERENCED_PARAMETER (PnPControlClass);

    buffer = NULL;

    if (BlockedDriverData->BufferLength && BlockedDriverData->Buffer) {

        length = BlockedDriverData->BufferLength;
    } else {

        length = 0;
    }
    status = PiControlAllocateBufferForUserModeCaller(
                &buffer,
                length,
                CallerMode,
                BlockedDriverData->Buffer);
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PpGetBlockedDriverList(
                (GUID *)buffer,
                &length,
                BlockedDriverData->Flags);
    if (buffer && NT_SUCCESS(status)) {

        tempStatus = PiControlMakeUserModeCallersCopy(
                        &BlockedDriverData->Buffer,
                        buffer,
                        BlockedDriverData->BufferLength,
                        sizeof(ULONG),
                        CallerMode,
                        FALSE);
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    BlockedDriverData->BufferLength = length;

Clean0:
    //
    // Release any allocated storage.
    //
    PiControlFreeUserModeCallersBuffer(CallerMode, buffer);

    return status;
}

#if DBG

LONG
PiControlExceptionFilter(
    IN  PEXCEPTION_POINTERS ExceptionPointers
    )
{
    PAGED_CODE();

    IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
              "PiExceptionFilter: Exception = 0x%08X, Exception Record = 0x%p, Context Record = 0x%p\n",
              ExceptionPointers->ExceptionRecord->ExceptionCode,
              ExceptionPointers->ExceptionRecord,
              ExceptionPointers->ContextRecord));

    DbgBreakPoint();

    return EXCEPTION_EXECUTE_HANDLER;
}

#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pphandle.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PpLastGood.h

Abstract:

    This header exposes routines for enumerating handles opened against a PDO
    stack.

Author:

    Adrian J. Oney  - April 4, 2001

Revision History:

--*/

typedef LOGICAL (*PHANDLE_ENUMERATION_CALLBACK)(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PEPROCESS       Process,
    IN  PFILE_OBJECT    FileObject,
    IN  HANDLE          HandleId,
    IN  PVOID           Context
    );

LOGICAL
PpHandleEnumerateHandlesAgainstPdoStack(
    IN  PDEVICE_OBJECT                  PhysicalDeviceObject,
    IN  PHANDLE_ENUMERATION_CALLBACK    HandleEnumCallBack,
    IN  PVOID                           Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\ppdrvdb.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    PpDrvDB.c

Abstract:

    This module containst PnP routines related to Defective Driver Database
    (DDB) support.

Author:

    Santosh S. Jodh - 22 Jan 2001

Environment:

    Kernel mode

Revision History:


--*/

#include "pnpmgrp.h"
#include "shimdb.h"
#pragma hdrstop

#if defined(NT_UP)
#define DDB_MAX_CACHE_SIZE              128
#else
#define DDB_MAX_CACHE_SIZE              256
#endif

#define PiLogDriverBlockedEvent(s, d, l, st)  { \
    UNICODE_STRING u;                           \
    RtlInitUnicodeString(&u, s);                \
    PpLogEvent(&u, NULL, st, d, l);             \
}

// Bit 0 indicates policy for filters (0 = critical, 1 = non-critical)
#define DDB_DRIVER_POLICY_CRITICAL_BIT          (1 << 0)
// Bit 1 indicates policy for user-mode setup blocking (0 = block, 1 = no-block)
#define DDB_DRIVER_POLICY_SETUP_NO_BLOCK_BIT    (1 << 1)

#define DDB_BOOT_NOT_LOADED_ERROR       (1 << 0)
#define DDB_BOOT_OUT_OF_MEMORY_ERROR    (1 << 1)
#define DDB_BOOT_INIT_ERROR             (1 << 2)
#define DDB_DRIVER_PATH_ERROR           (1 << 3)
#define DDB_OPEN_FILE_ERROR             (1 << 4)
#define DDB_CREATE_SECTION_ERROR        (1 << 5)
#define DDB_MAP_SECTION_ERROR           (1 << 6)
#define DDB_MAPPED_INIT_ERROR           (1 << 7)
#define DDB_READ_INFORMATION_ERROR      (1 << 8)

#define INVALID_HANDLE_VALUE    ((HANDLE)-1)

typedef struct _DDBCACHE_ENTRY {
    //
    // Links entries in the LRU list.
    //
    LIST_ENTRY      Entry;
    //
    // These fields are used as matching critereon for cache lookup.
    //
    UNICODE_STRING  Name;           // Driver name
    ULONG           TimeDateStamp;  // Link date of the driver
    //
    // Reference data for the cached entry.
    //
    NTSTATUS        Status;         // Status from the DDB lookup
    GUID            Guid;

} DDBCACHE_ENTRY, *PDDBCACHE_ENTRY;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif

//
// Constants.
//
const PWSTR PiSetupDDBPath = TEXT("\\$WIN_NT$.~BT\\drvmain.sdb");
const PWSTR PiNormalDDBPath = TEXT("\\SystemRoot\\AppPatch\\drvmain.sdb");
//
// Data.
//
// Handle to the driver database.
//
HSDB PpDDBHandle = NULL;
//
// Copy to the in memory image of driver database. Used only during boot.
//
PVOID PpBootDDB = NULL;
//
// Lock for synchronizing access to the driver database.
//
ERESOURCE PiDDBLock;
//
// We use RTL AVL table for our cache.
//
RTL_GENERIC_TABLE PiDDBCacheTable;
//
// We use a list for implementing LRU logic for capping the cache size.
//
LIST_ENTRY PiDDBCacheList;
//
// Path for the DDB.
//
PWSTR PiDDBPath = NULL;
//
// Mask to record already logged events.
//
ULONG PiLoggedErrorEventsMask = 0;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

NTSTATUS
PiLookupInDDB(
    IN PUNICODE_STRING  FullPath,
    IN PVOID            ImageBase,
    IN ULONG            ImageSize,
    OUT LPGUID          EntryGuid
    );

NTSTATUS
PiIsDriverBlocked(
    IN HSDB             SdbHandle,
    IN PUNICODE_STRING  FullPath,
    IN PVOID            ImageBase,
    IN ULONG            ImageSize,
    OUT LPGUID          EntryGuid
    );

NTSTATUS
PiInitializeDDBCache(
    VOID
    );

RTL_GENERIC_COMPARE_RESULTS
NTAPI
PiCompareDDBCacheEntries(
    IN  PRTL_GENERIC_TABLE          Table,
    IN  PVOID                       FirstStruct,
    IN  PVOID                       SecondStruct
    );

NTSTATUS
PiLookupInDDBCache(
    IN PUNICODE_STRING    FullPath,
    IN PVOID              ImageBase,
    IN ULONG              ImageSize,
    OUT LPGUID            EntryGuid
    );

VOID
PiUpdateDriverDBCache(
    IN PUNICODE_STRING      FullPath,
    IN PVOID                ImageBase,
    IN ULONG                ImageSize,
    IN NTSTATUS             Status,
    IN GUID                 *Guid
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PpInitializeBootDDB)
#pragma alloc_text(INIT, PpReleaseBootDDB)
#pragma alloc_text(INIT, PiInitializeDDBCache)
#pragma alloc_text(PAGE, PpCheckInDriverDatabase)
#pragma alloc_text(PAGE, PiLookupInDDB)
#pragma alloc_text(PAGE, PiIsDriverBlocked)
#pragma alloc_text(PAGE, PiCompareDDBCacheEntries)
#pragma alloc_text(PAGE, PiLookupInDDBCache)
#pragma alloc_text(PAGE, PiUpdateDriverDBCache)
#pragma alloc_text(PAGE, PpGetBlockedDriverList)
#endif

NTSTATUS
PpInitializeBootDDB(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine initializes the DDB from the image copied by ntldr.

Arguments:

    LoaderBlock - Pointer to loader block.

Return Value:

    NTSTATUS.

--*/
{
    PAGED_CODE();

    PpDDBHandle = NULL;
    PpBootDDB = NULL;
    //
    // Initialize the lock for serializing access to the DDB.
    //
    ExInitializeResource(&PiDDBLock);
    PiDDBPath = (ExpInTextModeSetup)? PiSetupDDBPath : PiNormalDDBPath;
    //
    // Initialize DDB cache.
    //
    PiInitializeDDBCache();
    //
    // Return failure if the loader did not load the database.
    //
    if (LoaderBlock->Extension->DrvDBSize == 0 ||
        LoaderBlock->Extension->DrvDBImage == NULL) {

        if (!(PiLoggedErrorEventsMask & DDB_BOOT_NOT_LOADED_ERROR)) {

            IopDbgPrint((IOP_ERROR_LEVEL,
                         "PpInitializeDriverDB: Driver database not loaded!\n"));

            PiLoggedErrorEventsMask |= DDB_BOOT_NOT_LOADED_ERROR;
            PiLogDriverBlockedEvent(
                TEXT("DATABASE NOT LOADED"),
                NULL,
                0,
                STATUS_DRIVER_DATABASE_ERROR);
        }

        return STATUS_UNSUCCESSFUL;
    }
    //
    // Make a copy of the database in pageable memory since the loader memory
    // will soon get claimed.
    // If this becomes a perf issue, we need to add
    // support for a new loader memory type (PAGEABLE DATA).
    //
    PpBootDDB = ExAllocatePool(PagedPool, LoaderBlock->Extension->DrvDBSize);
    if (PpBootDDB == NULL) {

        IopDbgPrint((IOP_ERROR_LEVEL,
                     "PpInitializeDriverDB: Failed to allocate memory to copy driver database!\n"));
        ASSERT(PpBootDDB);

        if (!(PiLoggedErrorEventsMask & DDB_BOOT_OUT_OF_MEMORY_ERROR)) {

            PiLoggedErrorEventsMask |= DDB_BOOT_OUT_OF_MEMORY_ERROR;
            PiLogDriverBlockedEvent(
                TEXT("OUT OF MEMORY"),
                NULL,
                0,
                STATUS_DRIVER_DATABASE_ERROR);
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory(PpBootDDB, LoaderBlock->Extension->DrvDBImage, LoaderBlock->Extension->DrvDBSize);
    //
    // Initialize the database from the memory image.
    //
    PpDDBHandle = SdbInitDatabaseInMemory(PpBootDDB, LoaderBlock->Extension->DrvDBSize);
    if (PpDDBHandle == NULL) {

        ExFreePool(PpBootDDB);
        PpBootDDB = NULL;
        IopDbgPrint((IOP_ERROR_LEVEL,
                     "PpInitializeDriverDB: Failed to initialize driver database!\n"));
        ASSERT(PpDDBHandle);

        if (!(PiLoggedErrorEventsMask & DDB_BOOT_INIT_ERROR)) {

            PiLoggedErrorEventsMask |= DDB_BOOT_INIT_ERROR;
            PiLogDriverBlockedEvent(
                TEXT("INIT DATABASE FAILED"),
                NULL,
                0,
                STATUS_DRIVER_DATABASE_ERROR);
        }

        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PpReleaseBootDDB(
    VOID
    )
/*++

Routine Description:

    This routine frees up the boot DDB once we are dont loading most drivers
    during boot.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Lock the DDB before freeing it.
    //
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&PiDDBLock, TRUE);
    //
    // Free the DDB if any.
    //
    if (PpDDBHandle) {

        ASSERT(PpBootDDB);
        SdbReleaseDatabase(PpDDBHandle);
        PpDDBHandle = NULL;
        ExFreePool(PpBootDDB);
        PpBootDDB = NULL;
        status = STATUS_SUCCESS;
    } else {

        IopDbgPrint((IOP_WARNING_LEVEL,
                     "PpReleaseBootDDB called with uninitialized database!\n"));
        status = STATUS_UNSUCCESSFUL;
    }
    //
    // Unlock the DDB.
    //
    ExReleaseResourceLite(&PiDDBLock);
    KeLeaveCriticalRegion();

    return status;
}

NTSTATUS
PpCheckInDriverDatabase(
    IN PUNICODE_STRING KeyName,
    IN HANDLE KeyHandle,
    IN PVOID ImageBase,
    IN ULONG ImageSize,
    IN BOOLEAN IsFilter,
    OUT LPGUID EntryGuid
    )
/*++

Routine Description:

    This routine checks the DDB for the presence of this driver.

Arguments:

    KeyName - Supplies a pointer to the driver's service key unicode string

    KeyHandle - Supplies a handle to the driver service node in the registry
        that describes the driver to be loaded.

    Header - Driver image header.

    IsFilter - Specifies whether this is a filter driver or not.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;
    UNICODE_STRING fullPath;

    PAGED_CODE();
    //
    // No driver blocking during textmode setup.
    //
    if (ExpInTextModeSetup) {
        return STATUS_SUCCESS;
    }

    status = IopBuildFullDriverPath(KeyName, KeyHandle, &fullPath);
    if (NT_SUCCESS(status)) {
        //
        // Lock the database access.
        //
        KeEnterCriticalRegion();
        ExAcquireResourceExclusiveLite(&PiDDBLock, TRUE);
        //
        // First check the cache.
        //
        status = PiLookupInDDBCache(&fullPath, ImageBase, ImageSize, EntryGuid);
        if (status == STATUS_UNSUCCESSFUL) {
            //
            // Cache miss, try the database.
            //
            status = PiLookupInDDB(&fullPath, ImageBase, ImageSize, EntryGuid);
        }
        //
        // Non-filters are automatically critical.
        //
        if (status == STATUS_DRIVER_BLOCKED && IsFilter == FALSE) {

            status = STATUS_DRIVER_BLOCKED_CRITICAL;
        }
        //
        // Unlock the database.
        //
        ExReleaseResourceLite(&PiDDBLock);
        KeLeaveCriticalRegion();

        ExFreePool(fullPath.Buffer);
    } else {

        IopDbgPrint((IOP_ERROR_LEVEL,
                     "IopCheckInDriverDatabase: Failed to build full driver path!\n"));
        ASSERT(NT_SUCCESS(status));

        if (!(PiLoggedErrorEventsMask & DDB_DRIVER_PATH_ERROR)) {

            PiLoggedErrorEventsMask |= DDB_DRIVER_PATH_ERROR;
            PiLogDriverBlockedEvent(
                TEXT("BUILD DRIVER PATH FAILED"),
                NULL,
                0,
                STATUS_DRIVER_DATABASE_ERROR);
        }
    }
    //
    // Ingore errors.
    //
    if (status != STATUS_DRIVER_BLOCKED &&
        status != STATUS_DRIVER_BLOCKED_CRITICAL) {

        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
PiLookupInDDB(
    IN PUNICODE_STRING   FullPath,
    IN PVOID             ImageBase,
    IN ULONG             ImageSize,
    OUT LPGUID           EntryGuid
    )
/*++

Routine Description:

    This routine checks the DDB for the presence of this driver. During BOOT,
    it uses the boot DDB loaded by ntldr. Once the system is booted, it maps the
    DDB in memory.

Arguments:

    FullPath - Full driver path

    Header - Driver image header.

Return Value:

    NTSTATUS.

--*/
{
    UNICODE_STRING fileName;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE sectionHandle, fileHandle;
    NTSTATUS status, unmapStatus;
    IO_STATUS_BLOCK ioStatus;
    PVOID ddbAddress;
    SIZE_T ddbSize;

    PAGED_CODE();

    fileHandle = (HANDLE)0;
    sectionHandle = (HANDLE)0;
    ddbAddress = NULL;
    if (PpDDBHandle == NULL) {
        //
        // Map the database in memory and initialize it.
        //
        RtlInitUnicodeString(&fileName, PiDDBPath);
        InitializeObjectAttributes(&objectAttributes,
                                   &fileName,
                                   (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                   NULL,
                                   NULL);
        status = ZwOpenFile (&fileHandle,
                             GENERIC_READ,
                             &objectAttributes,
                             &ioStatus,
                             FILE_SHARE_READ | FILE_SHARE_DELETE,
                             0);
        if (!NT_SUCCESS(status)) {

            if (!(PiLoggedErrorEventsMask & DDB_OPEN_FILE_ERROR)) {

                IopDbgPrint((IOP_ERROR_LEVEL,
                             "PiLookupInDDB: Failed to open driver database %wZ!\n", &fileName));

                PiLoggedErrorEventsMask |= DDB_OPEN_FILE_ERROR;
                PiLogDriverBlockedEvent(
                    TEXT("DATABASE OPEN FAILED"),
                    NULL,
                    0,
                    STATUS_DRIVER_DATABASE_ERROR);
            }

            goto Cleanup;
        }
        status = ZwCreateSection(
            &sectionHandle,
            SECTION_MAP_READ,
            NULL,
            NULL,
            PAGE_READONLY,
            SEC_COMMIT,
            fileHandle);
        if (!NT_SUCCESS(status)) {

            IopDbgPrint((IOP_ERROR_LEVEL,
                         "PiLookupInDDB: Failed to create section to map driver database %wZ!\n", &fileName));
            ASSERT(NT_SUCCESS(status));

            if (!(PiLoggedErrorEventsMask & DDB_CREATE_SECTION_ERROR)) {

                PiLoggedErrorEventsMask |= DDB_CREATE_SECTION_ERROR;
                PiLogDriverBlockedEvent(
                    TEXT("DATABASE SECTION FAILED"),
                    NULL,
                    0,
                    STATUS_DRIVER_DATABASE_ERROR);
            }

            goto Cleanup;
        }
        ddbSize = 0;
        status = ZwMapViewOfSection(
            sectionHandle,
            ZwCurrentProcess(),
            &ddbAddress,
            0,
            0,
            NULL,
            &ddbSize,
            ViewShare,
            0,
            PAGE_READONLY
            );
        if (!NT_SUCCESS(status)) {

            IopDbgPrint((IOP_ERROR_LEVEL,
                         "PiLookupInDDB: Failed to map driver database %wZ!\n", &fileName));
            ASSERT(NT_SUCCESS(status));

            if (!(PiLoggedErrorEventsMask & DDB_MAP_SECTION_ERROR)) {

                PiLoggedErrorEventsMask |= DDB_MAP_SECTION_ERROR;
                PiLogDriverBlockedEvent(
                    TEXT("DATABASE MAPPING FAILED"),
                    NULL,
                    0,
                    STATUS_DRIVER_DATABASE_ERROR);
            }

            goto Cleanup;
        }
        PpDDBHandle = SdbInitDatabaseInMemory(ddbAddress, (ULONG)ddbSize);
        if (PpDDBHandle == NULL) {

            IopDbgPrint((IOP_ERROR_LEVEL,
                         "PiLookupInDDB: Failed to initialize mapped driver database %wZ!\n", &fileName));
            status = STATUS_UNSUCCESSFUL;
            ASSERT(PpDDBHandle);

            if (!(PiLoggedErrorEventsMask & DDB_MAPPED_INIT_ERROR)) {

                PiLoggedErrorEventsMask |= DDB_MAPPED_INIT_ERROR;
                PiLogDriverBlockedEvent(
                    TEXT("INIT DATABASE FAILED"),
                    NULL,
                    0,
                    STATUS_DRIVER_DATABASE_ERROR);
            }

            goto Cleanup;
        }
    }
    //
    // Lookup the driver in the DDB.
    //
    status = PiIsDriverBlocked(PpDDBHandle, FullPath, ImageBase, ImageSize, EntryGuid);
    if (ddbAddress) {

        SdbReleaseDatabase(PpDDBHandle);
        PpDDBHandle = NULL;
    }

Cleanup:

    if (ddbAddress) {

        unmapStatus = ZwUnmapViewOfSection(ZwCurrentProcess(), ddbAddress);
        ASSERT(NT_SUCCESS(unmapStatus));
    }
    if (sectionHandle) {

        ZwClose(sectionHandle);
    }
    if (fileHandle) {

        ZwClose(fileHandle);
    }

    return status;
}

NTSTATUS
PiIsDriverBlocked(
    IN HSDB             SdbHandle,
    IN PUNICODE_STRING  FullPath,
    IN PVOID            ImageBase,
    IN ULONG            ImageSize,
    OUT LPGUID          EntryGuid
    )
/*++

Routine Description:

    This routine checks the DDB for the presence of this driver. During BOOT,
    it uses the boot DDB loaded by ntldr. Once the system is booted, it maps the
    DDB in memory.

Arguments:

    SdbHandle - Handle to the DDB to be used.

    FullPath - Full driver path

    Header - Driver image header.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;
    TAGREF driverTag;
    SDBENTRYINFO entryInfo;
    ULONG type, size, policy;
    HANDLE fileHandle;
    PWCHAR fileName;

    PAGED_CODE();

    fileHandle = INVALID_HANDLE_VALUE;

    ASSERT(ARGUMENT_PRESENT(EntryGuid));
    ASSERT(SdbHandle != NULL);

    driverTag = SdbGetDatabaseMatch(SdbHandle, FullPath->Buffer, fileHandle, ImageBase, ImageSize);
    if (TAGREF_NULL != driverTag) {
        //
        // Read the driver policy (we care only about bit 0).
        //
        size = sizeof(policy);
        type = REG_DWORD;
        policy= 0;
        if (    SdbQueryDriverInformation(  SdbHandle,
                                            driverTag,
                                            L"Policy",
                                            &type,
                                            &policy,
                                            &size) != ERROR_SUCCESS ||
                (policy & DDB_DRIVER_POLICY_CRITICAL_BIT) == 0) {

            status =  STATUS_DRIVER_BLOCKED_CRITICAL;
        } else {
            //
            // Bit 0 of POLICY==1 for a filter, means ok to start the devnode minus this filter.
            //
            status = STATUS_DRIVER_BLOCKED;
        }
        if (!SdbReadDriverInformation(SdbHandle, driverTag, &entryInfo)) {

            IopDbgPrint((IOP_ERROR_LEVEL,
                         "PiIsDriverBlocked: Failed to read the GUID from the database for driver %wZ!\n", FullPath));
            ASSERT(0);

            if (!(PiLoggedErrorEventsMask & DDB_READ_INFORMATION_ERROR)) {

                PiLoggedErrorEventsMask |= DDB_READ_INFORMATION_ERROR;
                PiLogDriverBlockedEvent(
                    TEXT("READ DRIVER ID FAILED"),
                    NULL,
                    0,
                    STATUS_DRIVER_DATABASE_ERROR);
            }

        } else {

            IopDbgPrint((IOP_INFO_LEVEL,
                         "PiIsDriverBlocked: Driver entry GUID = {%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
                         entryInfo.guidID.Data1,
                         entryInfo.guidID.Data2,
                         entryInfo.guidID.Data3,
                         entryInfo.guidID.Data4[0],
                         entryInfo.guidID.Data4[1],
                         entryInfo.guidID.Data4[2],
                         entryInfo.guidID.Data4[3],
                         entryInfo.guidID.Data4[4],
                         entryInfo.guidID.Data4[5],
                         entryInfo.guidID.Data4[6],
                         entryInfo.guidID.Data4[7]
                         ));
        }
    } else {
        //
        // Driver not found in the database.
        //
        status = STATUS_SUCCESS;
    }
    //
    // Write an entry to the event log.
    //
    if (status == STATUS_DRIVER_BLOCKED_CRITICAL ||
        status == STATUS_DRIVER_BLOCKED) {

        IopDbgPrint((IOP_ERROR_LEVEL,
                     "PiIsDriverBlocked: %wZ blocked from loading!!!\n", FullPath));

        fileName = wcsrchr(FullPath->Buffer, L'\\');
        if (fileName == NULL) {

            fileName = FullPath->Buffer;
        } else {

            fileName++;
        }
        PiLogDriverBlockedEvent(
            fileName,
            &entryInfo.guidID,
            sizeof(entryInfo.guidID),
            status);
    }
    //
    // Update the cache if neccessary.
    //
    if (status == STATUS_DRIVER_BLOCKED_CRITICAL ||
        status == STATUS_DRIVER_BLOCKED ||
        status == STATUS_SUCCESS) {
        //
        // Update our cache with the results.
        //
        PiUpdateDriverDBCache(
            FullPath,
            ImageBase,
            ImageSize,
            status,
            &entryInfo.guidID);

        //
        // If the driver was blocked, return the entry GUID.
        //
        if ((status == STATUS_DRIVER_BLOCKED_CRITICAL ||
            status == STATUS_DRIVER_BLOCKED) && (ARGUMENT_PRESENT(EntryGuid))) {
            RtlCopyMemory(EntryGuid, &entryInfo.guidID, sizeof(GUID));
        }
    }

    if (fileHandle != INVALID_HANDLE_VALUE) {

        ZwClose(fileHandle);
    }

    return status;
}

NTSTATUS
PiInitializeDDBCache(
    VOID
    )
/*++

Routine Description:

    This routine initializes the RTL Generic table that is used as the cache
    layer on top of DDB.

Arguments:

    None

Return Value:

    None.

--*/
{
    PAGED_CODE();

    RtlInitializeGenericTable(
        &PiDDBCacheTable,
        PiCompareDDBCacheEntries,
        PiAllocateGenericTableEntry,
        PiFreeGenericTableEntry,
        NULL);

    InitializeListHead(&PiDDBCacheList);

    return STATUS_SUCCESS;
}

RTL_GENERIC_COMPARE_RESULTS
NTAPI
PiCompareDDBCacheEntries(
    IN  PRTL_GENERIC_TABLE          Table,
    IN  PVOID                       FirstStruct,
    IN  PVOID                       SecondStruct
    )
/*++

Routine Description:

    This routine is the callback for the generic table routines.

Arguments:

    Table       - Table for which this is invoked.

    FirstStruct - An element in the table to compare.

    SecondStruct - Another element in the table to compare.

Return Value:

    RTL_GENERIC_COMPARE_RESULTS.

--*/
{
    PDDBCACHE_ENTRY lhs = (PDDBCACHE_ENTRY)FirstStruct;
    PDDBCACHE_ENTRY rhs = (PDDBCACHE_ENTRY)SecondStruct;
    LONG result;

    PAGED_CODE();

    result = RtlCompareUnicodeString(&lhs->Name, &rhs->Name, TRUE);
    if (result < 0) {

        return GenericLessThan;
    } else if (result > 0) {

        return GenericGreaterThan;
    }
    if (!Table->TableContext) {
        //
        // Link date as other matching criteria.
        //
        if (lhs->TimeDateStamp < rhs->TimeDateStamp) {

            return GenericLessThan;
        } else if (lhs->TimeDateStamp > rhs->TimeDateStamp) {

            return GenericGreaterThan;
        }
    }

    return GenericEqual;
}

NTSTATUS
PiLookupInDDBCache(
    IN  PUNICODE_STRING     FullPath,
    IN  PVOID               ImageBase,
    IN  ULONG               ImageSize,
    OUT LPGUID              EntryGuid
    )
/*++

Routine Description:

    This routine looks up the driver in the DDB cache.

Arguments:

    FullPath - Full driver path

    Header - Driver image header

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;
    PDDBCACHE_ENTRY cachedEntry;
    DDBCACHE_ENTRY key;
    PIMAGE_NT_HEADERS header;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ImageSize);

    ASSERT(ARGUMENT_PRESENT(EntryGuid));

    status = STATUS_UNSUCCESSFUL;
    PiDDBCacheTable.TableContext = NULL;
    if (!RtlIsGenericTableEmpty(&PiDDBCacheTable)) {
        //
        // Lookup in the cache.
        //
        header = RtlImageNtHeader(ImageBase);
        key.Name.Buffer = wcsrchr(FullPath->Buffer, L'\\');
        if (!key.Name.Buffer) {

            key.Name.Buffer = FullPath->Buffer;
        }
        key.Name.Length = (USHORT)(wcslen(key.Name.Buffer) * sizeof(WCHAR));
        key.Name.MaximumLength = key.Name.Length + sizeof(UNICODE_NULL);
        key.TimeDateStamp = header->FileHeader.TimeDateStamp;
        cachedEntry = (PDDBCACHE_ENTRY)RtlLookupElementGenericTable(
            &PiDDBCacheTable,
            &key);
        if (cachedEntry) {

            IopDbgPrint((IOP_WARNING_LEVEL,
                         "PiLookupInDDBCache: Found cached entry for %ws (status = %08x)!\n",
                         cachedEntry->Name.Buffer,
                         cachedEntry->Status));
            //
            // Move this entry to the end of the LRU list.
            //
            RemoveEntryList(&cachedEntry->Entry);
            InsertTailList(&PiDDBCacheList, &cachedEntry->Entry);
            //
            // Return the cached information.
            //
            status = cachedEntry->Status;
            if (ARGUMENT_PRESENT(EntryGuid)) {
                RtlCopyMemory(EntryGuid, &cachedEntry->Guid, sizeof(GUID));
            }
        }
    }

    return status;
}

VOID
PiUpdateDriverDBCache(
    IN PUNICODE_STRING      FullPath,
    IN PVOID                ImageBase,
    IN ULONG                ImageSize,
    IN NTSTATUS             Status,
    IN GUID                 *Guid
    )
/*++

Routine Description:

    This routine updates the DDB cache with information about this driver.

Arguments:

    FullPath - Full driver path

    Header - Driver image header

    Status - Lookup status to be cached.

Return Value:

    NTSTATUS.

--*/
{
    PDDBCACHE_ENTRY cachedEntry;
    DDBCACHE_ENTRY key;
    PWCHAR name;
    PIMAGE_NT_HEADERS header;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ImageSize);

    header = RtlImageNtHeader(ImageBase);
    //
    // We only want to match using name while updating the cache.
    //
    PiDDBCacheTable.TableContext = (PVOID)1;
    key.Name = *FullPath;
    cachedEntry = (PDDBCACHE_ENTRY)RtlLookupElementGenericTable(
       &PiDDBCacheTable,
       &key);
    if (cachedEntry == NULL) {

        if (RtlNumberGenericTableElements(&PiDDBCacheTable) >= DDB_MAX_CACHE_SIZE) {

            cachedEntry = CONTAINING_RECORD(
                            RemoveHeadList(&PiDDBCacheList),
                            DDBCACHE_ENTRY,
                            Entry);
        }
    } else {

        RemoveEntryList(&cachedEntry->Entry);
    }
    if (cachedEntry) {

        IopDbgPrint((IOP_INFO_LEVEL,
                     "PiUpdateDriverDBCache: Found previously cached entry for %wZ with status=%08x!\n",
                     &cachedEntry->Name,
                     cachedEntry->Status));
        //
        // Remove any previous entry.
        //
        name = cachedEntry->Name.Buffer;
        RtlDeleteElementGenericTable(&PiDDBCacheTable, cachedEntry);
        ExFreePool(name);
        name = NULL;
    }
    //
    // Cache the new entry.
    //
    key.Guid = *Guid;
    key.Status = Status;
    key.TimeDateStamp = header->FileHeader.TimeDateStamp;
    name = wcsrchr(FullPath->Buffer, L'\\');
    if (!name) {

        name = FullPath->Buffer;
    } else {

        name++;
    }
    key.Name.Length = key.Name.MaximumLength = (USHORT)(wcslen(name) * sizeof(WCHAR));
    key.Name.Buffer = ExAllocatePool(PagedPool, key.Name.MaximumLength);
    if (key.Name.Buffer) {

        RtlCopyMemory(key.Name.Buffer, name, key.Name.Length);
        cachedEntry = RtlInsertElementGenericTable(
                        &PiDDBCacheTable,
                        (PVOID)&key,
                        (CLONG)sizeof(DDBCACHE_ENTRY),
                        NULL);
        if (cachedEntry) {
            //
            // Insert at the end of LRU list.
            //
            InsertTailList(&PiDDBCacheList, &cachedEntry->Entry);
        }
    } else {

        IopDbgPrint((IOP_WARNING_LEVEL,
                     "PiUpdateDriverDBCache: Could not allocate memory to update driver database cache!\n"));
    }
}

NTSTATUS
PpGetBlockedDriverList(
    IN OUT GUID  *Buffer,
    IN OUT PULONG  Size,
    IN ULONG Flags
    )
/*++

Routine Description:

    This routine returns the MULTI_SZ list of currently blocked drivers.

Arguments:

    Buffer - Recieves the MULTI_SZ list of drivers blocked.

    Size - Buffer size on input, the actual size gets returned in this (both in
    characters).

Return Value:

    NTSTATUS.

--*/
{
    PDDBCACHE_ENTRY ptr;
    ULONG resultSize;
    GUID *result;
    NTSTATUS status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Flags);

    resultSize = 0;

    //
    // Lock the database access.
    //
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&PiDDBLock, TRUE);

    //
    // Enumerate all entries in our cache and compute the buffer size to hold
    // the MULTI_SZ string.
    //
    for (ptr = (PDDBCACHE_ENTRY)RtlEnumerateGenericTable(&PiDDBCacheTable, TRUE);
         ptr != NULL;
         ptr = (PDDBCACHE_ENTRY)RtlEnumerateGenericTable(&PiDDBCacheTable, FALSE)) {

        if (ptr->Status != STATUS_SUCCESS) {

            resultSize += sizeof(GUID);
        }
    }
    if (*Size >= resultSize) {
        //
        // Enumerate all entries in our cache.
        //
        result = Buffer;
        for (ptr = (PDDBCACHE_ENTRY)RtlEnumerateGenericTable(&PiDDBCacheTable, TRUE);
             ptr != NULL;
             ptr = (PDDBCACHE_ENTRY)RtlEnumerateGenericTable(&PiDDBCacheTable, FALSE)) {

            if (ptr->Status != STATUS_SUCCESS) {

                *result = ptr->Guid;
                result++;
            }
        }
        *Size = resultSize;
        status = STATUS_SUCCESS;
    } else {

        *Size = resultSize;
        status = STATUS_BUFFER_TOO_SMALL;
    }
    //
    // Unlock the database.
    //
    ExReleaseResourceLite(&PiDDBLock);
    KeLeaveCriticalRegion();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pphandle.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PpHandle.c

Abstract:

    This module implements handle location code for the Plug and Play subsystem.

Author:

    Adrian J. Oney  - April 4, 2001

Revision History:

--*/

#include "pnpmgrp.h"
#include "pihandle.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
//#pragma alloc_text(NONPAGE, PpHandleEnumerateHandlesAgainstPdoStack)
#pragma alloc_text(PAGE, PiHandleEnumerateHandlesAgainstDeviceObject)
#pragma alloc_text(PAGE, PiHandleProcessWalkWorker)
#endif


LOGICAL
PpHandleEnumerateHandlesAgainstPdoStack(
    IN  PDEVICE_OBJECT                  PhysicalDeviceObject,
    IN  PHANDLE_ENUMERATION_CALLBACK    HandleEnumCallBack,
    IN  PVOID                           Context
    )
/*++

Routine Description:

    This routine walks every device object in the WDM device stack along with
    all filesystem device objects on the other side of a VPB. If any handles
    are opened against such device objects, the specified callback is invoked.

Arguments:

    PhysicalDeviceObject - Supplies a pointer to the device object at the
                           bottom of the WDM device stack.

    HandleEnumCallBack - Pointer the callback function.

    Context - Pointer to information to be passed into the callback function.

Return Value:

    TRUE if the enumeration was halted, FALSE otherwise.

--*/
{
    PDEVICE_OBJECT currentDevObj, nextDevObj, vpbObj, vpbBottomObj;
    LOGICAL stopEnum;
    KIRQL oldIrql;
    PVPB vpb;

    //
    // Preinit
    //
    stopEnum = FALSE;

    //
    // Start with the device object at the bottom of the stack
    //
    currentDevObj = PhysicalDeviceObject;
    ObReferenceObject(currentDevObj);

    do {

        //
        // Dump any handles opened directly against the specified device object
        //
        stopEnum = PiHandleEnumerateHandlesAgainstDeviceObject(
            currentDevObj,
            HandleEnumCallBack,
            Context
            );

        if (stopEnum) {

            ObDereferenceObject(currentDevObj);
            break;
        }

        //
        // Look for a VPB
        //
        IoAcquireVpbSpinLock(&oldIrql);

        vpb = currentDevObj->Vpb;
        vpbObj = NULL;

        if (vpb) {

            vpbObj = vpb->DeviceObject;
            if (vpbObj) {

                ObReferenceObject(vpbObj);
            }
        }

        IoReleaseVpbSpinLock(oldIrql);

        //
        // If we have a vpb object, dump any handles queued against it.
        //
        if (vpbObj) {

            vpbBottomObj = IoGetDeviceAttachmentBaseRef(vpbObj);

            stopEnum = PiHandleEnumerateHandlesAgainstDeviceObject(
                vpbBottomObj,
                HandleEnumCallBack,
                Context
                );

            ObDereferenceObject(vpbBottomObj);
            ObDereferenceObject(vpbObj);

            if (stopEnum) {

                ObDereferenceObject(currentDevObj);
                break;
            }
        }

        //
        // Advance to the next DO.
        //
        oldIrql = KeAcquireQueuedSpinLock(LockQueueIoDatabaseLock);

        nextDevObj = currentDevObj->AttachedDevice;

        if (nextDevObj) {

            ObReferenceObject(nextDevObj);
        }

        KeReleaseQueuedSpinLock(LockQueueIoDatabaseLock, oldIrql);

        //
        // Drop ref on old DO.
        //
        ObDereferenceObject(currentDevObj);

        //
        // Loop.
        //
        currentDevObj = nextDevObj;

    } while (currentDevObj);

    return stopEnum;
}


LOGICAL
PiHandleEnumerateHandlesAgainstDeviceObject(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PHANDLE_ENUMERATION_CALLBACK    HandleEnumCallBack,
    IN  PVOID                           Context
    )
/*++

Routine Description:

    This routine walks the handle table for each process in the system looking
    for handles opened against the passed in device object.

Arguments:

    PhysicalDeviceObject - Supplies a pointer to the device object at the
                           bottom of the WDM device stack.

    HandleEnumCallBack - Pointer the callback function.

    Context - Pointer to information to be passed into the callback function.

Return Value:

    TRUE if the enumeration was halted, FALSE otherwise.

--*/
{
    PEPROCESS process;
    PHANDLE_TABLE objectTable;
    HANDLE_ENUM_CONTEXT handleEnumContext;
    LOGICAL stopEnum = FALSE;

    for(process = PsGetNextProcess(NULL);
        process != NULL;
        process = PsGetNextProcess(process)) {

        objectTable = ObReferenceProcessHandleTable(process);

        if (objectTable) {

            handleEnumContext.DeviceObject = DeviceObject;
            handleEnumContext.Process = process;
            handleEnumContext.CallBack = HandleEnumCallBack;
            handleEnumContext.Context = Context;

            stopEnum = (LOGICAL) ExEnumHandleTable(
                objectTable,
                PiHandleProcessWalkWorker,
                (PVOID) &handleEnumContext,
                NULL
                );

            ObDereferenceProcessHandleTable(process);

            if (stopEnum) {

                PsQuitNextProcess(process);
                break;
            }
        }
    }

    return stopEnum;
}


BOOLEAN
PiHandleProcessWalkWorker(
    IN  PHANDLE_TABLE_ENTRY     ObjectTableEntry,
    IN  HANDLE                  HandleId,
    IN  PHANDLE_ENUM_CONTEXT    EnumContext
    )
/*++

Routine Description:

    This routine gets called back for each handle in a given process. It
    examines each handle to see if it is a file object opened against the
    device object we are looking for.

Arguments:

    ObjectTableEntry - Points to the handle table entry of interest.

    HandleId - Supplies the handle.

    EnumContext - Context passed in for the enumeration.

Return Value:

    TRUE if the enumeration should be stopped, FALSE otherwise.

--*/
{
    PDEVICE_OBJECT deviceObject;
    POBJECT_HEADER objectHeader;
    PFILE_OBJECT fileObject;

    objectHeader = OBJECT_FROM_EX_TABLE_ENTRY(ObjectTableEntry);

    if (objectHeader->Type != IoFileObjectType) {

        //
        // Not a file object
        //
        return FALSE;
    }

    fileObject = (PFILE_OBJECT) &objectHeader->Body;

    deviceObject = IoGetBaseFileSystemDeviceObject( fileObject );

    if (deviceObject != EnumContext->DeviceObject) {

        //
        // Not our device object
        //
        return FALSE;
    }

    //
    // Found one, invoke the callback!
    //
    return (BOOLEAN) EnumContext->CallBack(
        EnumContext->DeviceObject,
        EnumContext->Process,
        fileObject,
        HandleId,
        EnumContext->Context
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pphotswap.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    PpHotSwap.h

Abstract:

    This file exposes public prototypes for hotswap device support.

Author:

    Adrian J. Oney (AdriaO) Feb 2001

Revision History:


--*/

VOID
PpHotSwapInitRemovalPolicy(
    OUT PDEVICE_NODE    DeviceNode
    );

VOID
PpHotSwapUpdateRemovalPolicy(
    IN  PDEVICE_NODE    DeviceNode
    );

VOID
PpHotSwapGetDevnodeRemovalPolicy(
    IN  PDEVICE_NODE            DeviceNode,
    IN  BOOLEAN                 IncludeRegistryOverride,
    OUT PDEVICE_REMOVAL_POLICY  RemovalPolicy
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pplastgood.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PpLastGood.h

Abstract:

    This header exposed various routines needed for last known good processing
    in the IO subsystem.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

VOID
PpLastGoodDoBootProcessing(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\ppmacro.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ppmacro.h

Abstract:

    This header defines various generic macros for the Plug and Play subsystem.

Author:

    Adrian J. Oney (AdriaO) July 26, 2000.

Revision History:


--*/

//
// This is to make all the TEXT(...) macros come out right. As of 07/27/2000,
// UNICODE isn't defined in kernel space by default.
//
#define UNICODE

//
// This macro is used to convert HKLM relative paths from user-mode accessable
// headers into a form usable by kernel mode. Eventually this macro should be
// moved to somewhere like cm.h so the entire kernel can use it.
//
#define CM_REGISTRY_MACHINE(x) L"\\Registry\\Machine\\"##x
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pplastgood.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PpLastGood.c

Abstract:

    This module handles last known good processing for the IO subsystem.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

#include "pnpmgrp.h"
#include "pilastgood.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PpLastGoodDoBootProcessing)
#pragma alloc_text(INIT, PiLastGoodRevertLastKnownDirectory)
#pragma alloc_text(INIT, PiLastGoodRevertCopyCallback)
#pragma alloc_text(INIT, PiLastGoodCopyKeyContents)
#endif

#define POOLTAG_LASTGOOD ('gLpP')

VOID
PpLastGoodDoBootProcessing(
    VOID
    )
/*++

Routine Description:

    This rolls back the system files to the state they were during the last
    known good boot. It should only be called from within a last known good
    boot, and at the earliest point possible.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UNICODE_STRING lastKnownGoodPath, lastKnownGoodTmpPath;
    UNICODE_STRING lastKnownGoodDelKey, lastKnownGoodTmpDelKey;
    NTSTATUS status;

    RtlInitUnicodeString(
        &lastKnownGoodPath,
        L"\\SystemRoot\\LastGood"
        );

    RtlInitUnicodeString(
        &lastKnownGoodDelKey,
        CM_REGISTRY_MACHINE(REGSTR_PATH_LASTGOOD)
        );

    RtlInitUnicodeString(
        &lastKnownGoodTmpPath,
        L"\\SystemRoot\\LastGood.Tmp"
        );

    RtlInitUnicodeString(
        &lastKnownGoodTmpDelKey,
        CM_REGISTRY_MACHINE(REGSTR_PATH_LASTGOODTMP)
        );

    if (!CmIsLastKnownGoodBoot()) {

        //
        // If we are in safe mode we don't do anything to commit the current
        // boot.
        //
        if (InitSafeBootMode) {

            return;
        }

        //
        // We are in a non-last known good boot. We immediately move all the
        // previous last known good info into the tmp subtree. We do this
        // because we will taint the normal LKG path prior to marking it good
        // (eg pre-logon server side install of PnP devices). Note that if the
        // tmp directory already exists, we *don't* perform the copy, as a good
        // boot is signified by deleting that directory.
        //
        status = IopFileUtilRename(
            &lastKnownGoodPath,
            &lastKnownGoodTmpPath,
            FALSE
            );

        if (!NT_SUCCESS(status)) {

            return;
        }

        //
        // It worked, now we also take care of the registry info.
        //
        PiLastGoodCopyKeyContents(
            &lastKnownGoodDelKey,
            &lastKnownGoodTmpDelKey,
            TRUE
            );

        return;
    }

    //
    // Revert the LastGood tree. This tree contains the changes made after
    // SMSS.EXE's initialization.
    //
    PiLastGoodRevertLastKnownDirectory(
        &lastKnownGoodPath,
        &lastKnownGoodDelKey
        );

    //
    // Revert the LastGood.Tmp tree. This tree contains the changes made on
    // a prior boot if we crashed between SMSS.EXE's initialization and login.
    //
    PiLastGoodRevertLastKnownDirectory(
        &lastKnownGoodTmpPath,
        &lastKnownGoodTmpDelKey
        );
}


VOID
PiLastGoodRevertLastKnownDirectory(
    IN PUNICODE_STRING  LastKnownGoodDirectory,
    IN PUNICODE_STRING  LastKnownGoodRegPath
    )
/*++

Routine Description:

    This function commits the changes specified by a given last known good
    directory and reg key. All files in the directory are first copied over any
    existing files. Subsequently, any files specified in the reg key are
    deleted.

Arguments:

    LastKnownGoodDirectory - Directory subtree to copy over \SystemRoot. This
                             path is emptied when the copy is complete.

    LastKnownGoodRegPath   - Key containing files to delete. Each value entry
                             is relative to \SystemRoot, and the value itself
                             contains the name of the file to delete.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    UNICODE_STRING fileToDelete, fileName;
    OBJECT_ATTRIBUTES lastKnownGoodKeyAttributes;
    OBJECT_ATTRIBUTES fileAttributes;
    HANDLE lastGoodRegHandle;
    UCHAR keyBuffer[sizeof(KEY_VALUE_FULL_INFORMATION) + 256*sizeof(WCHAR) + sizeof(ULONG)];
    WCHAR filePathName[255 + sizeof("\\SystemRoot\\")];
    PKEY_VALUE_FULL_INFORMATION pFullKeyInformation;
    ULONG resultLength, i, j, optionValue;

    //
    // Preinit our pointer to the full information buffer.
    //
    pFullKeyInformation = (PKEY_VALUE_FULL_INFORMATION) keyBuffer;

    //
    // Preform the file copy.
    //
    IopFileUtilWalkDirectoryTreeTopDown(
        LastKnownGoodDirectory,
        ( DIRWALK_INCLUDE_FILES | DIRWALK_CULL_DOTPATHS | DIRWALK_TRAVERSE ),
        PiLastGoodRevertCopyCallback,
        (PVOID) LastKnownGoodDirectory
        );

    //
    // Delete all the files specified in by the registry keys.
    //
    InitializeObjectAttributes(
        &lastKnownGoodKeyAttributes,
        LastKnownGoodRegPath,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwOpenKey(
        &lastGoodRegHandle,
        KEY_ALL_ACCESS,
        &lastKnownGoodKeyAttributes
        );

    if (!NT_SUCCESS(status)) {

        return;
    }

    i = 0;
    while (1) {

        status = ZwEnumerateValueKey(
            lastGoodRegHandle,
            i++,
            KeyValueFullInformation,
            pFullKeyInformation,
            sizeof(keyBuffer),
            &resultLength
            );

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_NO_MORE_ENTRIES) {

                status = STATUS_SUCCESS;
            }

            break;
        }

        if (resultLength == 0) {

            continue;
        }

        if (pFullKeyInformation->Type != REG_DWORD) {

            continue;
        }

        if (pFullKeyInformation->DataLength != sizeof(ULONG)) {

            continue;
        }

        optionValue = *((PULONG) (((PUCHAR) pFullKeyInformation) +
            pFullKeyInformation->DataOffset));

        //
        // We only understand deletes (and no flags).
        //
        if ((optionValue & 0xFF) != 1) {

            continue;
        }

        fileToDelete.Buffer = filePathName;
        fileToDelete.Length = (USHORT) 0;
        fileToDelete.MaximumLength = sizeof(filePathName);

        fileName.Buffer = (PWSTR) pFullKeyInformation->Name;
        fileName.Length = (USHORT) pFullKeyInformation->NameLength;
        fileName.MaximumLength = fileName.Length;

        RtlAppendUnicodeToString(&fileToDelete, L"\\SystemRoot\\");
        RtlAppendUnicodeStringToString(&fileToDelete, &fileName);

        //
        // Note that the key name has all '\'s changed to '/'s. Here we change
        // them back as the file systems are *almost* but not quite slash-tilt
        // agnostic.
        //
        for(j = sizeof(L"\\SystemRoot\\")/sizeof(WCHAR);
            j < fileToDelete.Length/sizeof(WCHAR);
            j++) {

            if (filePathName[j] == L'/') {

                filePathName[j] = L'\\';
            }
        }

        IopFileUtilClearAttributes(
            &fileToDelete,
            ( FILE_ATTRIBUTE_READONLY |
              FILE_ATTRIBUTE_HIDDEN |
              FILE_ATTRIBUTE_SYSTEM )
            );

        InitializeObjectAttributes(
            &fileAttributes,
            &fileToDelete,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

        ZwDeleteFile(&fileAttributes);
    }

    ZwDeleteKey(&lastGoodRegHandle);
    ZwClose(lastGoodRegHandle);
}


NTSTATUS
PiLastGoodRevertCopyCallback(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    )
/*++

Routine Description:

    This function is called back for each file in each of the appropriate
    LastKnownGood directories. It's job is to move the specified file into the
    appropriate mainline directory.

Arguments:

    FullPathName - Full path name of the identified file, relative to SystemRoot

    FileName - Filename portion, exempts directory.

    Context - Unicode string name of the root directory scanned. The string
              should not have a trailing '\\'

Return Value:

    NTSTATUS (Unsuccessful statusi abort further copies).

--*/
{
    NTSTATUS status;
    const USHORT rootLength = sizeof(L"\\SystemRoot\\")-sizeof(WCHAR);
    USHORT lastGoodLength;
    UNICODE_STRING targetFile;
    PWCHAR newPathText;

    UNREFERENCED_PARAMETER (FileAttributes);
    UNREFERENCED_PARAMETER (FileName);

    //
    // Add in an extra character to skip past the '\\'
    //
    lastGoodLength = ((PUNICODE_STRING) Context)->Length + sizeof(WCHAR);

    newPathText = ExAllocatePoolWithTag(
        PagedPool,
        FullPathName->Length,
        POOLTAG_LASTGOOD
        );

    if (newPathText == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Change \\SystemRoot\LastGood\Blah... to \\SystemRoot\Blah...
    //
    RtlCopyMemory(
        newPathText,
        FullPathName->Buffer,
        rootLength
        );

    RtlCopyMemory(
        newPathText + rootLength/sizeof(WCHAR),
        FullPathName->Buffer + lastGoodLength/sizeof(WCHAR),
        FullPathName->Length - lastGoodLength
        );

    //
    // Setup our unicode string path.
    //
    targetFile.Length = FullPathName->Length - lastGoodLength + rootLength;
    targetFile.MaximumLength = targetFile.Length;
    targetFile.Buffer = newPathText;

    //
    // Perform the rename.
    //
    status = IopFileUtilRename(FullPathName, &targetFile, TRUE);

    //
    // Cleanup and exit.
    //
    ExFreePool(newPathText);
    return status;
}


NTSTATUS
PiLastGoodCopyKeyContents(
    IN PUNICODE_STRING  SourceRegPath,
    IN PUNICODE_STRING  DestinationRegPath,
    IN BOOLEAN          DeleteSourceKey
    )
/*++

Routine Description:

    This function copies all the value keys in one source path to the
    destination path.

    NOTE: This function's implementation currently restricts the total of value
          and name lengths to 512 bytes, and is therefore not a generic key
          copy function.

Arguments:

    SourcePath - Registry path to enumerate and copy keys from.

    DestinationPath - Registry path to receive new value keys. This key will
                      be created if it does not exist.

    DeleteSourceKey - If TRUE, source key is deleted upn successful completion
                      of copy.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES sourceKeyAttributes, destinationKeyAttributes;
    HANDLE sourceRegHandle, destinationRegHandle;
    UCHAR keyBuffer[sizeof(KEY_VALUE_FULL_INFORMATION) + 512*sizeof(WCHAR)];
    PKEY_VALUE_FULL_INFORMATION pFullKeyInformation;
    ULONG resultLength, i, disposition;
    UNICODE_STRING valueName;

    //
    // Prep the buffer.
    //
    pFullKeyInformation = (PKEY_VALUE_FULL_INFORMATION) keyBuffer;

    //
    // Open the source key.
    //
    InitializeObjectAttributes(
        &sourceKeyAttributes,
        SourceRegPath,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwOpenKey(
        &sourceRegHandle,
        KEY_ALL_ACCESS,
        &sourceKeyAttributes
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Open or create the destination key.
    //
    InitializeObjectAttributes(
        &destinationKeyAttributes,
        DestinationRegPath,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwCreateKey(
        &destinationRegHandle,
        KEY_ALL_ACCESS,
        &destinationKeyAttributes,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        &disposition
        );

    if (!NT_SUCCESS(status)) {

        ZwClose(sourceRegHandle);
        return status;
    }

    //
    // Iterate over all the value keys, copying each.
    //
    i = 0;
    while (1) {

        status = ZwEnumerateValueKey(
            sourceRegHandle,
            i++,
            KeyValueFullInformation,
            pFullKeyInformation,
            sizeof(keyBuffer),
            &resultLength
            );

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_NO_MORE_ENTRIES) {

                status = STATUS_SUCCESS;
            }

            break;
        }

        valueName.Buffer = pFullKeyInformation->Name;
        valueName.Length = (USHORT) pFullKeyInformation->NameLength;
        valueName.MaximumLength = valueName.Length;

        status = ZwSetValueKey(
            destinationRegHandle,
            &valueName,
            0,
            pFullKeyInformation->Type,
            ((PUCHAR) pFullKeyInformation) + pFullKeyInformation->DataOffset,
            pFullKeyInformation->DataLength
            );

        if (!NT_SUCCESS(status)) {

            break;
        }
    }

    //
    // Cleanup time.
    //
    if (NT_SUCCESS(status) && DeleteSourceKey) {

        ZwDeleteKey(sourceRegHandle);
    }

    ZwClose(sourceRegHandle);
    ZwClose(destinationRegHandle);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pphotswap.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PpHotSwap.c

Abstract:

    This file implements support for hotswap devices.

Author:

    Adrian J. Oney (AdriaO) Feb 2001

Revision History:


--*/

#include "pnpmgrp.h"
#include "pihotswap.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PpHotSwapInitRemovalPolicy)
#pragma alloc_text(PAGE, PpHotSwapUpdateRemovalPolicy)
#pragma alloc_text(PAGE, PpHotSwapGetDevnodeRemovalPolicy)
#pragma alloc_text(PAGE, PiHotSwapGetDefaultBusRemovalPolicy)
#pragma alloc_text(PAGE, PiHotSwapGetDetachableNode)
#endif


VOID
PpHotSwapInitRemovalPolicy(
    OUT PDEVICE_NODE    DeviceNode
    )
/*++

Routine Description:

    This function initializes the removal policy information for a device node.

Arguments:

    DeviceNode - DevNode to update policy.

Return Value:

    Nothing.

--*/
{
    PAGED_CODE();

    DeviceNode->RemovalPolicy = (UCHAR) RemovalPolicyNotDetermined;
    DeviceNode->HardwareRemovalPolicy = (UCHAR) RemovalPolicyNotDetermined;
}


VOID
PpHotSwapUpdateRemovalPolicy(
    IN  PDEVICE_NODE            DeviceNode
    )
/*++

Routine Description:

    This function updates the removal policy by retrieving the appropriate
    data from the registry or drivers.

Arguments:

    DeviceNode - DevNode to update policy on.

Return Value:

    Nothing.

--*/
{
    NTSTATUS status;
    DEVICE_REMOVAL_POLICY deviceRemovalPolicy, parentPolicy;
    PDEVICE_NODE detachableNode;
    ULONG policyLength, policyCharacteristics;

    PAGED_CODE();

    PPDEVNODE_ASSERT_LOCK_HELD(PPL_TREEOP_ALLOW_READS);

    //
    // First find the detachable node - it holds our policy data, and is
    // special as it may make suggestions.
    //
    PiHotSwapGetDetachableNode(DeviceNode, &detachableNode);

    //
    // We aren't in fact removable. Finish now.
    //
    if (detachableNode == NULL) {

        DeviceNode->RemovalPolicy = (UCHAR) RemovalPolicyExpectNoRemoval;
        DeviceNode->HardwareRemovalPolicy = (UCHAR) RemovalPolicyExpectNoRemoval;
        return;
    }

    //
    // Check the stack for an explicit policy...
    //
    policyCharacteristics =
        ((DeviceNode->PhysicalDeviceObject->Characteristics) &
         FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK);

    if (policyCharacteristics == FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL) {

        deviceRemovalPolicy = RemovalPolicyExpectOrderlyRemoval;

    } else if (policyCharacteristics == FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL) {

        deviceRemovalPolicy = RemovalPolicyExpectSurpriseRemoval;

    } else if (DeviceNode != detachableNode) {

        //
        // We didn't get any good guesses. Therefore use the weakest policy.
        //
        deviceRemovalPolicy = RemovalPolicyUnspecified;

    } else {

        //
        // If we're the detach point, then we win.
        //
        PiHotSwapGetDefaultBusRemovalPolicy(DeviceNode, &deviceRemovalPolicy);
    }

    if (DeviceNode != detachableNode) {

        //
        // Do we have a winning policy? There are two possible algorithms for
        // coming to such a decision.
        // 1) Best policy is stored back at the detach point. If a child has a
        //    better policy, the detach point is updated.
        // 2) Policy is inherited downwards from the parent.
        //
        // We choose the second algorithm because devnode start orders may
        // change scenario to scenario, and we favor determinism (same results
        // each time) over opportunism (nonmarked child gets write caching
        // enabled only on Tuesdays.)
        //
        parentPolicy = DeviceNode->Parent->RemovalPolicy;
        if (deviceRemovalPolicy > parentPolicy) {

            //
            // Seems dad was right afterall...
            //
            deviceRemovalPolicy = parentPolicy;
        }
    }

    //
    // Update the policy hardware policy and the overall policy in case there's
    // no registry override.
    //
    DeviceNode->RemovalPolicy = (UCHAR) deviceRemovalPolicy;
    DeviceNode->HardwareRemovalPolicy = (UCHAR) deviceRemovalPolicy;

    //
    // We might not have to ask the stack anything. Check for a registry
    // override.
    //
    policyLength = sizeof(DEVICE_REMOVAL_POLICY);

    status = PiGetDeviceRegistryProperty(
        DeviceNode->PhysicalDeviceObject,
        REG_DWORD,
        REGSTR_VALUE_REMOVAL_POLICY,
        NULL,
        &deviceRemovalPolicy,
        &policyLength
        );

    //
    // If we have an override, set that as the policy.
    //
    if (NT_SUCCESS(status) &&
        ((deviceRemovalPolicy == RemovalPolicyExpectOrderlyRemoval) ||
         (deviceRemovalPolicy == RemovalPolicyExpectSurpriseRemoval))) {

        DeviceNode->RemovalPolicy = (UCHAR) deviceRemovalPolicy;
    }
}


VOID
PpHotSwapGetDevnodeRemovalPolicy(
    IN  PDEVICE_NODE            DeviceNode,
    IN  BOOLEAN                 IncludeRegistryOverride,
    OUT PDEVICE_REMOVAL_POLICY  RemovalPolicy
    )
/*++

Routine Description:

    This function retrieves the removal policy for a device node.

Arguments:

    DeviceNode - DevNode to retrieve policy from.

    IncludeRegistryOverride - TRUE if a registry override should be taken into
                              account if present. FALSE if the check should be
                              restricted to the hardware.

    RemovalPolicy - Receives removal policy.

Return Value:

    Nothing.

--*/
{
    PDEVICE_NODE detachableNode;
    DEVICE_REMOVAL_POLICY reportedPolicy;

    PAGED_CODE();

    //
    // Ensure the tree won't be edited while we examine it.
    //
    PpDevNodeLockTree(PPL_SIMPLE_READ);

    if (IncludeRegistryOverride) {

        reportedPolicy = DeviceNode->RemovalPolicy;

    } else {

        reportedPolicy = DeviceNode->HardwareRemovalPolicy;
    }

    if (reportedPolicy == RemovalPolicyNotDetermined) {

        //
        // We haven't started yet or asked the bus. Our policy is based on
        // whether the device is removable or ejectable.
        //
        PiHotSwapGetDetachableNode(DeviceNode, &detachableNode);

        if (detachableNode == NULL) {

            reportedPolicy = RemovalPolicyExpectNoRemoval;

        } else if (IopDeviceNodeFlagsToCapabilities(detachableNode)->EjectSupported) {

            //
            // Ejectable devices require orderly removal. We will assume the
            // user knows this.
            //
            reportedPolicy = RemovalPolicyExpectOrderlyRemoval;

        } else {

            ASSERT(IopDeviceNodeFlagsToCapabilities(detachableNode)->Removable);

            //
            // Removal nonstarted devices can be pulled at any instant.
            //
            reportedPolicy = RemovalPolicyExpectSurpriseRemoval;
        }

    } else {

        //
        // The devnode has a cached policy. Cut down on the options.
        //
        switch(reportedPolicy) {

            case RemovalPolicyExpectNoRemoval:
            case RemovalPolicyExpectOrderlyRemoval:
            case RemovalPolicyExpectSurpriseRemoval:
                //
                // Leave unchanged.
                //
                break;

            case RemovalPolicySuggestSurpriseRemoval:
                reportedPolicy = RemovalPolicyExpectSurpriseRemoval;
                break;

            default:
                ASSERT(0);

                //
                // Fall through.
                //

            case RemovalPolicyUnspecified:

                //
                // Unspecified is treated as orderly since the diversity of
                // busses favor high-speed orderly connections over consumer
                // connections.
                //
                // Fall through
                //

            case RemovalPolicySuggestOrderlyRemoval:
                reportedPolicy = RemovalPolicyExpectOrderlyRemoval;
                break;
        }
    }

    PpDevNodeUnlockTree(PPL_SIMPLE_READ);
    *RemovalPolicy = reportedPolicy;
}


VOID
PiHotSwapGetDefaultBusRemovalPolicy(
    IN  PDEVICE_NODE            DeviceNode,
    OUT PDEVICE_REMOVAL_POLICY  RemovalPolicy
    )
/*++

Routine Description:

    This function gets the default removal policy for a bus. This should be
    turned into a query in future designs.

Arguments:

    DeviceNode - DevNode to examine. This devnode should be the detach point.

    RemovalPolicy - Receives removal policy for the node.

Return Value:

    None.

--*/
{
    DEVICE_REMOVAL_POLICY deviceRemovalPolicy;

    PAGED_CODE();

    PPDEVNODE_ASSERT_LOCK_HELD(PPL_TREEOP_ALLOW_READS);

    if ((DeviceNode->InstancePath.Length > 8) &&
        (!_wcsnicmp(DeviceNode->InstancePath.Buffer, L"USB\\", 4))) {

        deviceRemovalPolicy = RemovalPolicySuggestSurpriseRemoval;

    } else if ((DeviceNode->InstancePath.Length > 10) &&
               (!_wcsnicmp(DeviceNode->InstancePath.Buffer, L"1394\\", 5))) {

        deviceRemovalPolicy = RemovalPolicySuggestSurpriseRemoval;

    } else if ((DeviceNode->InstancePath.Length > 10) &&
               (!_wcsnicmp(DeviceNode->InstancePath.Buffer, L"SBP2\\", 5))) {

        deviceRemovalPolicy = RemovalPolicySuggestSurpriseRemoval;

    } else if ((DeviceNode->InstancePath.Length > 14) &&
               (!_wcsnicmp(DeviceNode->InstancePath.Buffer, L"PCMCIA\\", 7))) {

        deviceRemovalPolicy = RemovalPolicySuggestSurpriseRemoval;

    } else if ((DeviceNode->InstancePath.Length > 8) &&
               (!_wcsnicmp(DeviceNode->InstancePath.Buffer, L"PCI\\", 4)) &&
               (DeviceNode->Parent->ServiceName.Length == 12) &&
               (!_wcsicmp(DeviceNode->Parent->ServiceName.Buffer, L"PCMCIA"))) {

        deviceRemovalPolicy = RemovalPolicySuggestSurpriseRemoval;

    } else {

        deviceRemovalPolicy = RemovalPolicySuggestOrderlyRemoval;
    }

    *RemovalPolicy = deviceRemovalPolicy;
}


VOID
PiHotSwapGetDetachableNode(
    IN  PDEVICE_NODE    DeviceNode,
    OUT PDEVICE_NODE   *DetachableNode
    )
/*++

Routine Description:

    This function starts at the DeviceNode and walks up the tree to find the
    first node that is removable.

Arguments:

    DeviceNode - DevNode to start walk from.

    DetachableNode - Receives detachable node, NULL if none.

Return Value:

    Nothing.

--*/
{
    PDEVICE_NODE currentNode;

    PAGED_CODE();

    PPDEVNODE_ASSERT_LOCK_HELD(PPL_SIMPLE_READ);

    //
    // We haven't started yet or asked the bus. Our policy is based on
    // whether the device is removable or ejectable.
    //
    for(currentNode = DeviceNode;
        currentNode != NULL;
        currentNode = currentNode->Parent) {

        if ((IopDeviceNodeFlagsToCapabilities(currentNode)->Removable) ||
            (IopDeviceNodeFlagsToCapabilities(currentNode)->EjectSupported)) {

            break;
        }
    }

    *DetachableNode = currentNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\ppprofile.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PpProfile.h

Abstract:

    This header contains prototypes for managing hardware profiles and
    docking stations.

Author:

    Adrian J. Oney (AdriaO) 07/19/2000

Revision History:

--*/

typedef enum _HARDWARE_PROFILE_BUS_TYPE {

    HardwareProfileBusTypeACPI

} HARDWARE_PROFILE_BUS_TYPE, *PHARDWARE_PROFILE_BUS_TYPE;

VOID
PpProfileInit(
    VOID
    );

VOID
PpProfileBeginHardwareProfileTransition(
    IN BOOLEAN SubsumeExistingDeparture
    );

VOID
PpProfileIncludeInHardwareProfileTransition(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PROFILE_STATUS  ChangeInPresence
    );

NTSTATUS
PpProfileQueryHardwareProfileChange(
    IN  BOOLEAN                     SubsumeExistingDeparture,
    IN  PROFILE_NOTIFICATION_TIME   NotificationTime,
    OUT PPNP_VETO_TYPE              VetoType,
    OUT PUNICODE_STRING             VetoName OPTIONAL
    );

VOID
PpProfileCommitTransitioningDock(
    IN PDEVICE_NODE     DeviceNode,
    IN PROFILE_STATUS   ChangeInPresence
    );

VOID
PpProfileCancelTransitioningDock(
    IN PDEVICE_NODE     DeviceNode,
    IN PROFILE_STATUS   ChangeInPresence
    );

VOID
PpProfileCancelHardwareProfileTransition(
    VOID
    );

VOID
PpProfileMarkAllTransitioningDocksEjected(
    VOID
    );

PDEVICE_OBJECT
PpProfileRetrievePreferredDockToEject(
    VOID
    );

VOID
PpProfileProcessDockDeviceCapability(
    IN PDEVICE_NODE DeviceNode,
    IN PDEVICE_CAPABILITIES Capabilities
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pppagepath.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    PpPathPath.c

Abstract:

    The file implements support for managing devices on the paging path.

Author:

    Adrian J. Oney (AdriaO) February 3rd, 2001

Revision History:

    Originally taken from ChuckL's implementation in mm\modwrite.c.

--*/

#include "pnpmgrp.h"
#include "pipagepath.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PpPagePathAssign)
#pragma alloc_text(PAGE, PpPagePathRelease)
#pragma alloc_text(PAGE, PiPagePathSetState)
#endif


NTSTATUS
PpPagePathAssign(
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine informs driver stacks that they are now on the paging path.
    Drivers need to take appropriate actions when on the path, such as failing
    IRP_MN_QUERY_STOP and IRP_MN_QUERY_REMOVE, locking their code and clearing
    the DO_POWER_PAGABLE bit, etc.

Arguments:

    FileObject - File object for the paging file itself.

Return Value:

    NTSTATUS.

--*/
{
    PAGED_CODE();

    return PiPagePathSetState(FileObject, TRUE);
}


NTSTATUS
PpPagePathRelease(
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine informs driver stacks that the passed in file is no longer a
    paging file. Each driver stack notified may still be on the paging path
    however if their hardware supports a different paging file on another drive.

Arguments:

    FileObject - File object for the paging file itself.

Return Value:

    NTSTATUS.

--*/
{
    PAGED_CODE();

    return PiPagePathSetState(FileObject, FALSE);
}


NTSTATUS
PiPagePathSetState(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN      InPath
    )
/*++

Routine Description:

    This routine notifies driver stacks when a paging file is shut down on their
    device, or if a paging file is being started up on their device. If a paging
    file is being started up, this request is also a query as the stack may not
    be able to support a pagefile.

Arguments:

    FileObject - File object for the paging file itself.

    InPath - Whether the page file is being started or shut down.

Return Value:

    NTSTATUS.

--*/
{
    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;

    PAGED_CODE();

    //
    // Reference the file object here so that no special checks need be made
    // in I/O completion to determine whether or not to dereference the file
    // object.
    //
    ObReferenceObject(FileObject);

    //
    // Initialize the local event.
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Get the address of the target device object.
    //
    deviceObject = IoGetRelatedDeviceObject(FileObject);

    //
    // Allocate and initialize the irp for this operation.
    //
    irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

    if (irp == NULL) {

        //
        // Don't dereference the file object, our caller will take care of that.
        //
        return STATUS_NO_MEMORY;
    }

    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //
    irp->UserEvent = &event;
    irp->Flags = IRP_SYNCHRONOUS_API;
    irp->UserIosb = &localIoStatus;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_DEVICE_USAGE_NOTIFICATION;
    irpSp->FileObject = FileObject;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->AssociatedIrp.SystemBuffer = NULL;
    // irp->Flags = 0;

    irpSp->Parameters.UsageNotification.InPath = InPath;
    irpSp->Parameters.UsageNotification.Type = DeviceUsageTypePaging;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //
    IoQueueThreadIrp(irp);

    //
    // Acquire the engine lock to ensure no rebalances, removes, or power
    // operations are in progress during this notification.
    //
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //
    status = IoCallDriver(deviceObject, irp);

    //
    // Wait for the local event and copy the final status information
    // back to the caller.
    //
    if (status == STATUS_PENDING) {

        (VOID) KeWaitForSingleObject(&event,
                                     Executive,
                                     KernelMode,
                                     FALSE,
                                     NULL);

        status = localIoStatus.Status;
    }

    //
    // Unlock the tree.
    //
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\ppprofile.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PpProfile.c

Abstract:

    Kernel-mode Plug and Play Manager Docking and Hardware Profile Support
    Routines.

Author:

    Adrian J. Oney (AdriaO) June 1998
    Kenneth D. Ray (kenray) June 1998

Revision History:



--*/

#include "pnpmgrp.h"

//
// ISSUE-2000/07/24-AdriaO - Header mess
//     We should not be including private headers from CM.
//
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#include "..\config\cmp.h"
#include "piprofile.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PpProfileInit)
#pragma alloc_text(PAGE, PpProfileBeginHardwareProfileTransition)
#pragma alloc_text(PAGE, PpProfileIncludeInHardwareProfileTransition)
#pragma alloc_text(PAGE, PpProfileQueryHardwareProfileChange)
#pragma alloc_text(PAGE, PpProfileCommitTransitioningDock)
#pragma alloc_text(PAGE, PpProfileCancelTransitioningDock)
#pragma alloc_text(PAGE, PpProfileCancelHardwareProfileTransition)
#pragma alloc_text(PAGE, PpProfileMarkAllTransitioningDocksEjected)
#pragma alloc_text(PAGE, PpProfileProcessDockDeviceCapability)
#pragma alloc_text(PAGE, PiProfileSendHardwareProfileCommit)
#pragma alloc_text(PAGE, PiProfileSendHardwareProfileCancel)
#pragma alloc_text(PAGE, PiProfileConvertFakeDockToRealDock)
#pragma alloc_text(PAGE, PiProfileRetrievePreferredCallback)
#pragma alloc_text(PAGE, PpProfileRetrievePreferredDockToEject)
#pragma alloc_text(PAGE, PiProfileUpdateDeviceTree)
#pragma alloc_text(PAGE, PiProfileUpdateDeviceTreeWorker)
#pragma alloc_text(PAGE, PiProfileUpdateDeviceTreeCallback)
#endif

//
// List of current dock devices, and the number of dockdevices.
// Must hold PiProfileDeviceListLock to change these values.
//
LIST_ENTRY  PiProfileDeviceListHead;
ULONG       PiProfileDeviceCount;
KGUARDED_MUTEX PiProfileDeviceListLock;
KSEMAPHORE  PiProfileChangeSemaphore;
BOOLEAN     PiProfileChangeCancelRequired;
LONG        PiProfileDevicesInTransition;


VOID
PpProfileInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes docking support for Win2K.

Arguments:

    None.

Return Value:

    Nope.

--*/
{
    //
    // Initialize the list of dock devices, and its lock.
    //
    InitializeListHead(&PiProfileDeviceListHead);
    KeInitializeGuardedMutex(&PiProfileDeviceListLock);
    PiProfileDeviceCount = 0;
    KeInitializeSemaphore(&PiProfileChangeSemaphore, 1, 1);
}


VOID
PpProfileBeginHardwareProfileTransition(
    IN BOOLEAN SubsumeExistingDeparture
    )
/*++

Routine Description:

    This routine must be called before any dock devnodes can be marked for
    transition (ie arriving or departing). After calling this function,
    PpProfileIncludeInHardwareProfileTransition should be called for each dock
    that is appearing or disappearing.

    Functionally, this code acquires the profile change semaphore. Future
    changes in the life of the added dock devnodes cause it to be released.

Arguments:

    SubsumeExistingDeparture - Set if we are ejecting the parent of a
                               device that is still in the process of
                               ejecting...

Return Value:

    None.

--*/
{
    NTSTATUS status;

    if (SubsumeExistingDeparture) {

        //
        // We will already have queried in this case. Also, enumeration is
        // locked right now, so the appropriate devices found cannot disappear.
        // Assert everything is consistant.
        //
        ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);
        ASSERT(PiProfileDevicesInTransition != 0);
        return;
    }

    //
    // Take the profile change semaphore. We do this whenever a dock is
    // in our list, even if no query is going to occur.
    //
    status = KeWaitForSingleObject(
        &PiProfileChangeSemaphore,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    ASSERT(status == STATUS_SUCCESS);
}


VOID
PpProfileIncludeInHardwareProfileTransition(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PROFILE_STATUS  ChangeInPresence
    )
/*++

Routine Description:

    This routine is called to mark a dock as "in transition", ie it is either
    disappearing or appearing, the results of which determine our final
    hardware profile state. After all the docks that are transitioning have
    been passed into this function, PiProfileQueryHardwareProfileChange is
    called.

Arguments:

    DeviceNode          - The dock devnode that is appearing or disappearing
    ChangeInPresence    - Either DOCK_DEPARTING or DOCK_ARRIVING

Return Value:

    Nope.

--*/
{
    PWCHAR          deviceSerialNumber;
    PDEVICE_OBJECT  deviceObject;
    NTSTATUS        status;

    //
    // Verify we are under semaphore, we aren't marking the dock twice, and
    // our parameters are sensable.
    //
    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);
    ASSERT(DeviceNode->DockInfo.DockStatus == DOCK_QUIESCENT);
    ASSERT((ChangeInPresence == DOCK_DEPARTING)||
           (ChangeInPresence == DOCK_ARRIVING));

    if (ChangeInPresence == DOCK_ARRIVING) {

        //
        // First, ensure this dock is a member of the dock list.
        //
        // ADRIAO N.B. 07/09/2000 -
        //     We should move this into IopProcessNewDeviceNode, or perhaps
        // PipStartPhaseN.
        //
        if (IsListEmpty(&DeviceNode->DockInfo.ListEntry)) {

            //
            // Acquire the lock on the list of dock devices
            //
            KeAcquireGuardedMutex(&PiProfileDeviceListLock);

            //
            // Add this element to the head of the list
            //
            InsertHeadList(&PiProfileDeviceListHead,
                           &DeviceNode->DockInfo.ListEntry);
            PiProfileDeviceCount++;

            //
            // Release the lock on the list of dock devices
            //
            KeReleaseGuardedMutex(&PiProfileDeviceListLock);
        }

        //
        // Retrieve the Serial Number from this dock device. We do this just
        // to test the BIOS today. Later we will be acquiring the information
        // to determine the profile we are *about* to enter.
        //
        deviceObject = DeviceNode->PhysicalDeviceObject;

        status = PpQuerySerialNumber(
            DeviceNode,
            &deviceSerialNumber
            );

        if (NT_SUCCESS(status) && (deviceSerialNumber != NULL)) {

            ExFreePool(deviceSerialNumber);
        }

    } else {

        //
        // DOCK_DEPARTING case, we must be a member of the dock list...
        //
        ASSERT(!IsListEmpty(&DeviceNode->DockInfo.ListEntry));
    }

    InterlockedIncrement(&PiProfileDevicesInTransition);
    DeviceNode->DockInfo.DockStatus = ChangeInPresence;
}


NTSTATUS
PpProfileQueryHardwareProfileChange(
    IN  BOOLEAN                     SubsumingExistingDeparture,
    IN  PROFILE_NOTIFICATION_TIME   InPnpEvent,
    OUT PPNP_VETO_TYPE              VetoType,
    OUT PUNICODE_STRING             VetoName OPTIONAL
    )
/*++

Routine Description:

    This function queries drivers to see if it is OK to exit the current
    hardware profile and enter next one (as determined by which docks have
    been marked). One of two functions should be used subsequently to this
    call:
        PpProfileCommitTransitioningDock
            (call when a dock has been successfully started or has disappeared)
        PpProfileCancelHardwareProfileTransition
            (call to abort a transition, say if a dock failed to start or a
             query returned failure for eject)

Arguments:

    InPnpEvent  - This argument indicates whether an operation is being done
                  within the context of another PnpEvent or not. If not, we
                  will queue such an event and block on it. If so, we cannot
                  queue&block (we'd deadlock), so we do the query manually.
    VetoType    - If this function returns false, this parameter will describe
                  who failed the query profile change. The below optional
                  parameter will contain the name of said vetoer.
    VetoName    - This optional parameter will get the name of the vetoer (ie
                  devinst, service name, application name, etc). If VetoName
                  is supplied, the caller must free the buffer returned.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;
    BOOLEAN arrivingDockFound;
    PLIST_ENTRY listEntry;
    PDEVICE_NODE devNode;

    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);

    //
    // Acquire the lock on the list of dock devices and determine whether any
    // dock devnodes are arriving.
    //
    KeAcquireGuardedMutex(&PiProfileDeviceListLock);

    ASSERT(PiProfileDevicesInTransition);

    arrivingDockFound = FALSE;
    for (listEntry  = PiProfileDeviceListHead.Flink;
        listEntry != &(PiProfileDeviceListHead);
        listEntry  = listEntry->Flink ) {

        devNode = CONTAINING_RECORD(listEntry,
                                    DEVICE_NODE,
                                    DockInfo.ListEntry);

        ASSERT((devNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE)&&
               (devNode->DockInfo.DockStatus != DOCK_EJECTIRP_COMPLETED));

        if (devNode->DockInfo.DockStatus == DOCK_ARRIVING) {

            arrivingDockFound = TRUE;
        }
    }

    //
    // Release the lock on the list of dock devices
    //
    KeReleaseGuardedMutex(&PiProfileDeviceListLock);

    if (SubsumingExistingDeparture) {

        ASSERT(PiProfileChangeCancelRequired);
        //
        // We're nesting. Work off the last query, and don't requery.
        //
        return STATUS_SUCCESS;
    }

    if (arrivingDockFound) {

        //
        // We currently don't actually query for hardware profile change on a
        // dock event as the user may have the lid closed. If we ever find a
        // piece of hardware that needs to be updated *prior* to actually
        // switching over, we will have to remove this bit of code.
        //
        PiProfileChangeCancelRequired = FALSE;
        return STATUS_SUCCESS;
    }

    IopDbgPrint((IOP_TRACE_LEVEL,
               "NTOSKRNL: Sending HW profile change [query]\n"));

    status = IopRequestHwProfileChangeNotification(
        (LPGUID) &GUID_HWPROFILE_QUERY_CHANGE,
        InPnpEvent,
        VetoType,
        VetoName
        );

    if (NT_SUCCESS(status)) {
        PiProfileChangeCancelRequired = TRUE;
    } else {
        PiProfileChangeCancelRequired = FALSE;
    }
    return status;
}


VOID
PpProfileCommitTransitioningDock(
    IN PDEVICE_NODE     DeviceNode,
    IN PROFILE_STATUS   ChangeInPresence
    )
/*++

Routine Description:

    This routine finalized the state the specified device in the list of
    current dock devices and requests a Hardware Profile change.

Arguments:

    DeviceNode - The dock devnode that has finished being started or removed.
    ChangeInPresence - Either DOCK_DEPARTING or DOCK_ARRIVING

Return Value:

    None.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PWCHAR deviceSerialNumber;
    BOOLEAN profileChanged;
    LONG remainingDockCount;

    //
    // If we are commiting a dock, the transition list should not be empty.
    // all dock devices present, the list should not be empty.
    //
    ASSERT(!IsListEmpty(&DeviceNode->DockInfo.ListEntry));
    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);

    if (ChangeInPresence == DOCK_DEPARTING) {

        ASSERT((DeviceNode->DockInfo.DockStatus == DOCK_DEPARTING) ||
               (DeviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED));

        //
        // Free up the serial number
        //
        if (DeviceNode->DockInfo.SerialNumber != NULL) {

            ExFreePool(DeviceNode->DockInfo.SerialNumber);
            DeviceNode->DockInfo.SerialNumber = NULL;
        }

        //
        // Acquire the lock on the list of dock devices
        //
        KeAcquireGuardedMutex(&PiProfileDeviceListLock);

        //
        // Remove the current devnode from the list of docks
        //
        RemoveEntryList(&DeviceNode->DockInfo.ListEntry);
        InitializeListHead(&DeviceNode->DockInfo.ListEntry);
        PiProfileDeviceCount--;

        //
        // Release the lock on the list of dock devices
        //
        KeReleaseGuardedMutex(&PiProfileDeviceListLock);

    } else {

        ASSERT(DeviceNode->DockInfo.DockStatus == DOCK_ARRIVING);

        //
        // We only add one dock at a time. So this should have been the last!
        //
        ASSERT(PiProfileDevicesInTransition == 1);

        //
        // Retrieve the Serial Number from this dock device if we don't already
        // have it.
        //
        if (DeviceNode->DockInfo.SerialNumber == NULL) {

            deviceObject = DeviceNode->PhysicalDeviceObject;

            status = PpQuerySerialNumber(
                        DeviceNode,
                        &deviceSerialNumber);

            DeviceNode->DockInfo.SerialNumber = deviceSerialNumber;
        }
    }

    DeviceNode->DockInfo.DockStatus = DOCK_QUIESCENT;
    remainingDockCount = InterlockedDecrement(&PiProfileDevicesInTransition);
    ASSERT(remainingDockCount >= 0);

    if (remainingDockCount) {

        return;
    }

    profileChanged = FALSE;

    if ((ChangeInPresence == DOCK_ARRIVING) &&
        (DeviceNode->DockInfo.SerialNumber == NULL)) {

        //
        // Couldn't get Serial Number for this dock device, or serial number
        // was NULL. We can make this check here as only one dock at a time
        // can currently arrive.
        //
        status = STATUS_UNSUCCESSFUL;
        goto BroadcastAndLeave;
    }

    //
    // Update the current Hardware Profile now that the transition list has
    // been emptied. This routine does two things for us:
    // 1) It determines whether the profile actually changed and updates
    //    the global flag IopProfileChangeOccured appropriately.
    // 2) If the profile changed, this routine updates the registry.
    //
    status = PiProfileUpdateHardwareProfile(&profileChanged);
    if (!NT_SUCCESS(status)) {

        IopDbgPrint((IOP_TRACE_LEVEL,
                   "PiProfileUpdateHardwareProfile failed with status == %lx\n", status));
    }

BroadcastAndLeave:

    //
    // Clean up
    //
    if (NT_SUCCESS(status) && profileChanged) {

        PiProfileSendHardwareProfileCommit();
        PiProfileUpdateDeviceTree();

    } else if (PiProfileChangeCancelRequired) {

        PiProfileSendHardwareProfileCancel();
    }

    KeReleaseSemaphore(
        &PiProfileChangeSemaphore,
        IO_NO_INCREMENT,
        1,
        FALSE
        );

    return;
}


VOID
PpProfileCancelTransitioningDock(
    IN PDEVICE_NODE     DeviceNode,
    IN PROFILE_STATUS   ChangeInPresence
    )
/*++

Routine Description:

    This routine is called when a dock that was marked to disappear didn't (ie,
    after the eject, the dock device still enumerated). We remove it from the
    transition list and complete/cancel the HW profile change as appropriate.
    See PpProfileMarkAllTransitioningDocksEjected.

Arguments:

    DeviceNode - The dock devnode that either didn't start or didn't disappear.
    ChangeInPresence - Either DOCK_DEPARTING or DOCK_ARRIVING

    N.B. - Currently only DOCK_DEPARTING is supported.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    BOOLEAN  profileChanged;
    LONG     remainingDockCount;

#if !DBG
    UNREFERENCED_PARAMETER (ChangeInPresence);
#endif

    ASSERT(ChangeInPresence == DOCK_DEPARTING);

    //
    // Acquire the lock on the list of dock devices
    //
    KeAcquireGuardedMutex(&PiProfileDeviceListLock);

    //
    // Since we are about to remove this dock device from the list of
    // all dock devices present, the list should not be empty.
    //
    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);
    ASSERT(DeviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED);
    ASSERT(!IsListEmpty(&DeviceNode->DockInfo.ListEntry));

    DeviceNode->DockInfo.DockStatus = DOCK_QUIESCENT;
    remainingDockCount = InterlockedDecrement(&PiProfileDevicesInTransition);
    ASSERT(remainingDockCount >= 0);

    //
    // Release the lock on the list of dock devices
    //
    KeReleaseGuardedMutex(&PiProfileDeviceListLock);

    if (remainingDockCount) {

        return;
    }

    //
    // Update the current Hardware Profile after removing this device.
    //
    status = PiProfileUpdateHardwareProfile(&profileChanged);

    if (!NT_SUCCESS(status)) {

        //
        // So we're there physically, but not mentally? Too bad, where broadcasting
        // change either way.
        //
        IopDbgPrint((IOP_TRACE_LEVEL,
                   "PiProfileUpdateHardwareProfile failed with status == %lx\n", status));

        ASSERT(NT_SUCCESS(status));
    }

    if (NT_SUCCESS(status) && profileChanged) {

        PiProfileSendHardwareProfileCommit();
        PiProfileUpdateDeviceTree();

    } else {

        ASSERT(PiProfileChangeCancelRequired);
        PiProfileSendHardwareProfileCancel();
    }

    KeReleaseSemaphore(
        &PiProfileChangeSemaphore,
        IO_NO_INCREMENT,
        1,
        FALSE
        );

    return;
}


VOID
PpProfileCancelHardwareProfileTransition(
    VOID
    )
/*++

Routine Description:

    This routine unmarks any marked devnodes (ie, sets them to no change,
    appearing or disappearing), and sends the CancelQueryProfileChange as
    appropriate. Once called, other profile changes can occur.

Arguments:

    None.

Return Value:

    Nodda.

--*/
{
    PLIST_ENTRY  listEntry;
    PDEVICE_NODE devNode;

    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);

    //
    // Acquire the lock on the list of dock devices
    //
    KeAcquireGuardedMutex(&PiProfileDeviceListLock);

    for (listEntry  = PiProfileDeviceListHead.Flink;
        listEntry != &(PiProfileDeviceListHead);
        listEntry  = listEntry->Flink ) {

        devNode = CONTAINING_RECORD(listEntry,
                                    DEVICE_NODE,
                                    DockInfo.ListEntry);

        ASSERT((devNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE)&&
               (devNode->DockInfo.DockStatus != DOCK_EJECTIRP_COMPLETED));
        if (devNode->DockInfo.DockStatus != DOCK_QUIESCENT) {

            InterlockedDecrement(&PiProfileDevicesInTransition);
            devNode->DockInfo.DockStatus = DOCK_QUIESCENT;
        }
    }

    ASSERT(!PiProfileDevicesInTransition);

    //
    // Release the lock on the list of dock devices
    //
    KeReleaseGuardedMutex(&PiProfileDeviceListLock);

    if (PiProfileChangeCancelRequired) {

        PiProfileSendHardwareProfileCancel();
    }

    KeReleaseSemaphore(
        &PiProfileChangeSemaphore,
        IO_NO_INCREMENT,
        1,
        FALSE
        );
}


VOID
PpProfileMarkAllTransitioningDocksEjected(
    VOID
    )
/*++

Routine Description:

    This routine moves any departing devnodes to the ejected state. If any
    subsequent enumeration lists the device as present, we know the eject
    failed and we appropriately cancel that piece of the profile change.
    PpProfileCancelTransitioningDock can only be called after this function
    is called.

Arguments:

    None.

Return Value:

    Nodda.

--*/
{
    PLIST_ENTRY  listEntry;
    PDEVICE_NODE devNode;

    //
    // The semaphore might not be signalled if the dock was resurrected before
    // the eject completed. This can happen in warm undock scenarios where the
    // machine is resumed inside the dock instead of being detached.
    //
    //ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);

    //
    // Acquire the lock on the list of dock devices
    //
    KeAcquireGuardedMutex(&PiProfileDeviceListLock);

    for (listEntry  = PiProfileDeviceListHead.Flink;
        listEntry != &(PiProfileDeviceListHead);
        listEntry  = listEntry->Flink ) {

        devNode = CONTAINING_RECORD(listEntry,
                                    DEVICE_NODE,
                                    DockInfo.ListEntry);

        ASSERT((devNode->DockInfo.DockStatus == DOCK_QUIESCENT)||
               (devNode->DockInfo.DockStatus == DOCK_DEPARTING));
        if (devNode->DockInfo.DockStatus != DOCK_QUIESCENT) {

            devNode->DockInfo.DockStatus = DOCK_EJECTIRP_COMPLETED;
        }
    }

    //
    // Release the lock on the list of dock devices
    //
    KeReleaseGuardedMutex(&PiProfileDeviceListLock);
}


VOID
PiProfileSendHardwareProfileCommit(
    VOID
    )
/*++

Routine Description:

    This routine (internal to ppdock.c) simply sends the change complete message.
    We do not wait for this, as it is asynchronous...

Arguments:

    None.

Return Value:

    Nodda.

--*/
{
    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);
    IopDbgPrint((IOP_TRACE_LEVEL,
               "NTOSKRNL: Sending HW profile change [commit]\n"));

    IopRequestHwProfileChangeNotification(
        (LPGUID) &GUID_HWPROFILE_CHANGE_COMPLETE,
        PROFILE_PERHAPS_IN_PNPEVENT,
        NULL,
        NULL
        );
}


VOID
PiProfileSendHardwareProfileCancel(
    VOID
    )
/*++

Routine Description:

    This routine (internal to ppdock.c) simply sends the cancel.

Arguments:

    None.

Return Value:

    Nodda.

--*/
{
    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);
    IopDbgPrint((IOP_TRACE_LEVEL,
               "NTOSKRNL: Sending HW profile change [cancel]\n"));

    IopRequestHwProfileChangeNotification(
        (LPGUID) &GUID_HWPROFILE_CHANGE_CANCELLED,
        PROFILE_PERHAPS_IN_PNPEVENT,
        NULL,
        NULL
        );
}


NTSTATUS
PiProfileUpdateHardwareProfile(
    OUT BOOLEAN     *ProfileChanged
    )
/*++

Routine Description:

    This routine scans the list of current dock devices, builds a list of serial
    numbers from those devices, and calls for the Hardware Profile to be
    changed, based on that list.

Arguments:

    ProfileChanged - Supplies a variable to receive TRUE if the current hardware
                     profile changes as a result of calling this routine.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PLIST_ENTRY  listEntry;
    PDEVICE_NODE devNode;
    PWCHAR  *profileSerialNumbers, *p;
    HANDLE  hProfileKey=NULL;
    ULONG   len, numProfiles;
    HANDLE  hCurrent, hIDConfigDB;
    UNICODE_STRING unicodeName;

    //
    // Acquire the lock on the list of dock devices
    //
    KeAcquireGuardedMutex(&PiProfileDeviceListLock);

    //
    // Update the flag for Ejectable Docks (flag is the count of docks)
    //
    PiWstrToUnicodeString(&unicodeName, CM_HARDWARE_PROFILE_STR_DATABASE);
    if(NT_SUCCESS(IopOpenRegistryKeyEx(&hIDConfigDB,
                                       NULL,
                                       &unicodeName,
                                       KEY_READ) )) {

        PiWstrToUnicodeString(&unicodeName, CM_HARDWARE_PROFILE_STR_CURRENT_DOCK_INFO);
        if(NT_SUCCESS(IopOpenRegistryKeyEx(&hCurrent,
                                           hIDConfigDB,
                                           &unicodeName,
                                           KEY_READ | KEY_WRITE) )) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_EJECTABLE_DOCKS);
            ZwSetValueKey(hCurrent,
                          &unicodeName,
                          0,
                          REG_DWORD,
                          &PiProfileDeviceCount,
                          sizeof(PiProfileDeviceCount));
            ZwClose(hCurrent);
        }
        ZwClose(hIDConfigDB);
    }

    if (PiProfileDeviceCount == 0) {
        //
        // if there are no dock devices, the list should
        // contain a single null entry, in addition to the null
        // termination.
        //
        numProfiles = 1;
        ASSERT(IsListEmpty(&PiProfileDeviceListHead));
    } else {
        numProfiles = PiProfileDeviceCount;
        ASSERT(!IsListEmpty(&PiProfileDeviceListHead));
    }

    //
    // Allocate space for a null-terminated list of SerialNumber lists.
    //
    len = (numProfiles+1)*sizeof(PWCHAR);
    profileSerialNumbers = ExAllocatePool(NonPagedPool, len);

    if (profileSerialNumbers) {

        p = profileSerialNumbers;

        //
        // Create the list of Serial Numbers
        //
        for (listEntry  = PiProfileDeviceListHead.Flink;
             listEntry != &(PiProfileDeviceListHead);
             listEntry  = listEntry->Flink ) {

            devNode = CONTAINING_RECORD(listEntry,
                                        DEVICE_NODE,
                                        DockInfo.ListEntry);

            ASSERT(devNode->DockInfo.DockStatus == DOCK_QUIESCENT);
            if (devNode->DockInfo.SerialNumber) {
                *p = devNode->DockInfo.SerialNumber;
                p++;
            }
        }

        KeReleaseGuardedMutex(&PiProfileDeviceListLock);

        if (p == profileSerialNumbers) {
            //
            // Set a single list entry to NULL if we look to be in an "undocked"
            // profile
            //
            *p = NULL;
            p++;
        }

        //
        // Null-terminate the list
        //
        *p = NULL;

        numProfiles = (ULONG)(p - profileSerialNumbers);

        //
        // Change the current Hardware Profile based on the new Dock State
        // and perform notification that the Hardware Profile has changed
        //
        status = IopExecuteHardwareProfileChange(HardwareProfileBusTypeACPI,
                                                 profileSerialNumbers,
                                                 numProfiles,
                                                 &hProfileKey,
                                                 ProfileChanged);
        if (hProfileKey) {
            ZwClose(hProfileKey);
        }
        ExFreePool (profileSerialNumbers);

    } else {

        KeReleaseGuardedMutex(&PiProfileDeviceListLock);

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


PDEVICE_OBJECT
PpProfileRetrievePreferredDockToEject(
    VOID
    )
/*++

Routine Description:

    This routine is called to retrieve the dock that should be ejected via
    start menu UI.

Arguments:

    None.

Return Value:

    Dock device object if one exists.

++*/
{
    BEST_DOCK_TO_EJECT  bestDock;
    //
    // Search for the Dock Nodes
    //
    bestDock.PhysicalDeviceObject = NULL;
    PipForAllDeviceNodes(PiProfileRetrievePreferredCallback, (PVOID)&bestDock);

    return bestDock.PhysicalDeviceObject;
}


PDEVICE_NODE
PiProfileConvertFakeDockToRealDock(
    IN  PDEVICE_NODE    FakeDockDevnode
    )
/*++

Routine Description:

    Given a docking Physical Device Object for a fake dock, walk its ejection
    relations to find out the corresponding real dock node.

Arguments:

    FakeDockDevnode - Fake Dock node

Returns

    Real Dock (PDO referenced once), NULL if none.

--*/
{
    ULONG               i;
    NTSTATUS            status;
    PDEVICE_OBJECT      devobj;
    PDEVICE_NODE        devnode, realDock;
    PDEVICE_RELATIONS   ejectRelations = NULL;
    IO_STACK_LOCATION   irpSp;

    //
    // Obtain the list of ejection relations.
    //
    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
    irpSp.Parameters.QueryDeviceRelations.Type = EjectionRelations;

    status = IopSynchronousCall(
        FakeDockDevnode->PhysicalDeviceObject,
        &irpSp,
        (PULONG_PTR) &ejectRelations
        );

    if ((!NT_SUCCESS(status)) || (ejectRelations == NULL)) {

        return NULL;
    }

    //
    // Walk the eject relations looking for the depth.
    //
    realDock = NULL;
    for(i = 0; i < ejectRelations->Count; i++) {

        devobj = ejectRelations->Objects[i];

        //
        // The last ejection relation is the one that points to the
        // underlying physically enumerated device.
        //
        if (i == ejectRelations->Count-1) {

            devnode = (PDEVICE_NODE) devobj->DeviceObjectExtension->DeviceNode;

            //
            // The devnode might be NULL if:
            // 1) A driver make a mistake
            // 2) We got back an ejection relation on a newly created PDO
            //    that hasn't made it's way back up to the OS (we don't
            //    raise the tree lock to BlockReads while an enumeration
            //    IRP is outstanding...)
            //
            if (devnode) {

                realDock = devnode;
                ObReferenceObject(devobj);
            }
        }

        ObDereferenceObject(devobj);
    }

    ExFreePool(ejectRelations);
    return realDock;
}


NTSTATUS
PiProfileRetrievePreferredCallback(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID        Context
    )
/*++

Routine Description:

    Scan the list of device nodes for docks, and keep the one with the most
    attractive depth (ie, the one eject PC should select.)

Arguments:

    DeviceNode - Possible docking station DevNode.

    Context - Pointer to the BEST_DOCK_TO_EJECT structure to fill in. The
              PhysicalDeviceObject pointer in this structure should be
              preinited to NULL. The located docking station PDO will be
              referenced.

Returns:

    NTSTATUS (Unsuccessful status's stop the enumeration of devnodes)

--*/
{
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    PBEST_DOCK_TO_EJECT pBestDock;
    PDEVICE_NODE realDock, curDock;
    NTSTATUS status;
    ULONG dockDepth = 0;
    HANDLE hDeviceKey;

    //
    // Cast the context appropriately.
    //
    pBestDock = (PBEST_DOCK_TO_EJECT) Context;

    //
    // If it's not a dock device, we will ignore it...
    //
    if (!IopDeviceNodeFlagsToCapabilities(DeviceNode)->DockDevice) {

        //
        // Continue enumerating.
        //
        return STATUS_SUCCESS;
    }

    //
    // First get the corresponding real dock that goes with the fake dock
    // created by ACPI.
    //
    realDock = PiProfileConvertFakeDockToRealDock(DeviceNode);

    //
    // Search for overrides. Examine the real dock first, then the fake
    //
    curDock = realDock ? realDock : DeviceNode;
    while(1) {

        //
        // Examine the devnode for a specified ejection priority.
        //
        status = IoOpenDeviceRegistryKey(
            curDock->PhysicalDeviceObject,
            PLUGPLAY_REGKEY_DEVICE,
            KEY_READ,
            &hDeviceKey
            );

        if (NT_SUCCESS(status)) {

            RtlZeroMemory(queryTable, sizeof(queryTable));

            dockDepth = 0;
            queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
            queryTable[0].Name          = (PWSTR) REGSTR_VAL_EJECT_PRIORITY;
            queryTable[0].EntryContext  = &dockDepth;
            queryTable[0].DefaultType   = REG_NONE;
            queryTable[0].DefaultData   = NULL;
            queryTable[0].DefaultLength = 0;

            status = RtlQueryRegistryValues(
                RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                hDeviceKey,
                queryTable,
                NULL,
                NULL
                );

            if (NT_SUCCESS(status)) {

                //
                // Promote manually specified priorities over inferred ones.
                // Note that we _add_ in 0x80000000 rather than _or_ it in.
                // This lets us wrap in case we ever need to specify a priority
                // lower than what's inferred.
                //
                dockDepth += 0x80000000;
            }

            ZwClose(hDeviceKey);
        }

        if (NT_SUCCESS(status) || (curDock == DeviceNode)) {

            break;
        }

        curDock = DeviceNode;
    }

    if (!NT_SUCCESS(status)) {

        //
        // If we can find no eject preference order, use the depth of the
        // dock devnode.
        //
        dockDepth = realDock ? realDock->Level : DeviceNode->Level;
    }

    if (realDock) {

        ObDereferenceObject(realDock->PhysicalDeviceObject);
    }

    //
    // The best dock is selected as the dock with the deepest ejected device.
    //
    if ((pBestDock->PhysicalDeviceObject == NULL) ||
        (dockDepth > pBestDock->Depth)) {

        if (pBestDock->PhysicalDeviceObject) {

            ObDereferenceObject(pBestDock->PhysicalDeviceObject);
        }

        pBestDock->PhysicalDeviceObject = DeviceNode->PhysicalDeviceObject;
        pBestDock->Depth = dockDepth;

        ObReferenceObject(pBestDock->PhysicalDeviceObject);
    }

    //
    // Continue enumerating.
    //
    return STATUS_SUCCESS;
}


NTSTATUS
PiProfileUpdateDeviceTree(
    VOID
    )
/*++

Routine Description:

    This function is called after the system has transitioned into a new
    hardware profile. The thread from which it is called may be holding an
    enumeration lock. Calling this function does two tasks:

    1) If a disabled devnode in the tree should be enabled in this new hardware
       profile state, it will be started.

    2) If an enabled devnode in the tree should be disabled in this new hardware
       profile state, it will be (surprise) removed.

    ADRIAO N.B. 02/19/1999 -
        Why surprise remove? There are four cases to be handled:
        a) Dock disappearing, need to enable device in new profile
        b) Dock appearing, need to enable device in new profile
        c) Dock disappearing, need to disable device in new profile
        d) Dock appearing, need to disable device in new profile

        a) and b) are trivial. c) involves treating the appropriate devices as
        if they were in the removal relation lists for the dock. d) is another
        matter altogether as we need to query-remove/remove devices before
        starting another. NT5's PnP state machine cannot handle this, so for
        this release we cleanup rather hastily after the profile change.

Parameters:

    NONE.

Return Value:

    NTSTATUS.

--*/
{
    PWORK_QUEUE_ITEM workQueueItem;

    PAGED_CODE();

    workQueueItem = (PWORK_QUEUE_ITEM) ExAllocatePool(
        NonPagedPool,
        sizeof(WORK_QUEUE_ITEM)
        );

    if (workQueueItem) {

        //
        // Queue this up so we can walk the tree outside of the enumeration lock.
        //
        ExInitializeWorkItem(
            workQueueItem,
            PiProfileUpdateDeviceTreeWorker,
            workQueueItem
            );

        ExQueueWorkItem(
            workQueueItem,
            CriticalWorkQueue
            );

        return STATUS_SUCCESS;

    } else {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
}


VOID
PiProfileUpdateDeviceTreeWorker(
    IN PVOID Context
    )
/*++

Routine Description:

    This function is called on a work thread by PiProfileUpdateDeviceTree
    when the system has transitioned to a new hardware profile.

Parameters:

    NONE.

Return Value:

    NONE.

--*/
{
    PAGED_CODE();

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);
    PipForAllDeviceNodes(PiProfileUpdateDeviceTreeCallback, NULL);
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    ExFreePool(Context);
}


NTSTATUS
PiProfileUpdateDeviceTreeCallback(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID Context
    )
/*++

Routine Description:

    This function is called for each devnode after the system has transitioned
    hardware profile states.

Parameters:

    NONE.

Return Value:

    NONE.

--*/
{
    PDEVICE_NODE parentDevNode;

    UNREFERENCED_PARAMETER( Context );

    PAGED_CODE();

    if (DeviceNode->State == DeviceNodeStarted) {

        //
        // Calling this function will disable the device if it is appropriate
        // to do so.
        //
        if (!IopIsDeviceInstanceEnabled(NULL, &DeviceNode->InstancePath, FALSE)) {

            PipRequestDeviceRemoval(DeviceNode, FALSE, CM_PROB_DISABLED);
        }

    } else if (((DeviceNode->State == DeviceNodeInitialized) ||
                (DeviceNode->State == DeviceNodeRemoved)) &&
               PipIsDevNodeProblem(DeviceNode, CM_PROB_DISABLED)) {

        //
        // We might be turning on the device. So we will clear the problem
        // flags iff the device problem was CM_PROB_DISABLED. We must clear the
        // problem code or otherwise IopIsDeviceInstanceEnabled will ignore us.
        //
        PipClearDevNodeProblem(DeviceNode);

        //
        // Make sure the device stays down iff appropriate.
        //
        if (IopIsDeviceInstanceEnabled(NULL, &DeviceNode->InstancePath, FALSE)) {

            //
            // This device should come back online. Bring it out of the
            // removed state and queue up an enumeration at the parent level
            // to resurrect him.
            //
            IopRestartDeviceNode(DeviceNode);

            parentDevNode = DeviceNode->Parent;

            IoInvalidateDeviceRelations(
                parentDevNode->PhysicalDeviceObject,
                BusRelations
                );

        } else {

            //
            // Restore the problem code.
            //
            PipSetDevNodeProblem(DeviceNode, CM_PROB_DISABLED);
        }

    } else {

         ASSERT((!PipIsDevNodeProblem(DeviceNode, CM_PROB_DISABLED)) ||
                ((DeviceNode->State == DeviceNodeAwaitingQueuedRemoval) ||
                 (DeviceNode->State == DeviceNodeAwaitingQueuedDeletion)));
    }

    return STATUS_SUCCESS;
}

VOID
PpProfileProcessDockDeviceCapability(
    IN PDEVICE_NODE DeviceNode,
    IN PDEVICE_CAPABILITIES Capabilities
    )
{
    PAGED_CODE();

    if (Capabilities->DockDevice) {

        if (DeviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED) {

            ASSERT(DeviceNode->DockInfo.DockStatus != DOCK_EJECTIRP_COMPLETED);
            PpProfileCancelTransitioningDock(DeviceNode, DOCK_DEPARTING);
        }
        DeviceNode->DockInfo.DockStatus = DOCK_QUIESCENT;
    } else {

        DeviceNode->DockInfo.DockStatus = DOCK_NOTDOCKDEVICE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\remlock.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    remlock.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Peter Wieland
    Kenneth Ray

Environment:

    kernel mode only

Notes:



Revision History:

--*/

#define IO_REMOVE_LOCK_SIG     'COLR'

typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK {
    struct _IO_REMOVE_LOCK_TRACKING_BLOCK * Link;
    PVOID           Tag;
    LARGE_INTEGER   TimeLocked;
    PCSTR           File;
    ULONG           Line;
} IO_REMOVE_LOCK_TRACKING_BLOCK, *PIO_REMOVE_LOCK_TRACKING_BLOCK;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\ppvutil.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ppvutil.h

Abstract:

    This header exposes various utilities required to do driver verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\trackirp.h

--*/

#ifndef _PPVUTIL_H_
#define _PPVUTIL_H_

typedef enum {

    PPVERROR_DUPLICATE_PDO_ENUMERATED           = 0,
    PPVERROR_MISHANDLED_TARGET_DEVICE_RELATIONS,
    PPVERROR_DDI_REQUIRES_PDO

} PPVFAILURE_TYPE;

typedef enum {

    PPVREMOVAL_SHOULD_DELETE           = 0,
    PPVREMOVAL_SHOULDNT_DELETE,
    PPVREMOVAL_MAY_DEFER_DELETION

} PPVREMOVAL_OPTION;

VOID
FASTCALL
PpvUtilInit(
    VOID
    );

NTSTATUS
FASTCALL
PpvUtilCallAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType
    );

VOID
FASTCALL
PpvUtilTestStartedPdoStack(
    IN  PDEVICE_OBJECT  DeviceObject
    );

PPVREMOVAL_OPTION
FASTCALL
PpvUtilGetDevnodeRemovalOption(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    );

VOID
FASTCALL
PpvUtilFailDriver(
    IN  PPVFAILURE_TYPE FailureType,
    IN  PVOID           CulpritAddress,
    IN  PDEVICE_OBJECT  DeviceObject    OPTIONAL,
    IN  PVOID           ExtraneousInfo  OPTIONAL
    );

BOOLEAN
FASTCALL
PpvUtilIsHardwareBeingVerified(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    );

#endif // _PPVUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\regstrp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    regstrp.h

Abstract:

    This module contains the registry strings for keys, paths and values,
    that are not already defined in the system regstr.h file.  This is
    generally the "NT" specific registry strings. This module is used by
    kernel mode Pnp managers only.

Author:

    Shie-Lin Tzong (shielint) 10/03/1995


Revision History:


--*/

#ifndef _KERNEL_REGSTRP_H_
#define _KERNEL_REGSTRP_H_

#undef TEXT
#define TEXT(quote) L##quote

#define _IN_KERNEL_
#include <regstr.h>
#include <pnpmgr.h>

//
// Redefine the names used in regstr.h

#define REGSTR_VALUE_SLOTNUMBER                     REGSTR_VAL_SLOTNUMBER
#define REGSTR_VALUE_ATTACHEDCOMPONENTS             REGSTR_VAL_ATTACHEDCOMPONENTS
#define REGSTR_VALUE_BASEDEVICEPATH                 REGSTR_VAL_BASEDEVICEPATH
#define REGSTR_VALUE_SYSTEMBUSNUMBER                REGSTR_VAL_SYSTEMBUSNUMBER
#define REGSTR_VALUE_BUSDATATYPE                    REGSTR_VAL_BUSDATATYPE
#define REGSTR_VALUE_INTERFACETYPE                  REGSTR_VAL_INTERFACETYPE
#define REGSTR_VALUE_SERVICE                        REGSTR_VAL_SERVICE
#define REGSTR_VALUE_DETECTSIGNATURE                REGSTR_VAL_DETECTSIGNATURE
#define REGSTR_VALUE_INSTANCEIDENTIFIER             REGSTR_VAL_INSTANCEIDENTIFIER
#define REGSTR_VALUE_DUPLICATEOF                    REGSTR_VAL_DUPLICATEOF
#define REGSTR_VALUE_STATUSFLAGS                    REGSTR_VAL_STATUSFLAGS
#define REGSTR_VALUE_UNKNOWNPROBLEMS                REGSTR_VAL_UNKNOWNPROBLEMS
#define REGSTR_VALUE_FRIENDLYNAME                   REGSTR_VAL_FRIENDLYNAME
#define REGSTR_VALUE_UPPERFILTERS                   REGSTR_VAL_UPPERFILTERS
#define REGSTR_VALUE_LOWERFILTERS                   REGSTR_VAL_LOWERFILTERS
#define REGSTR_VALUE_REMOVAL_POLICY                 REGSTR_VAL_REMOVAL_POLICY
#define REGSTR_VALUE_DISABLECOUNT                   REGSTR_VAL_DISABLECOUNT

//
// kernel mode specific definitions
//
#define REGSTR_VALUE_LOCATION_INFORMATION            REGSTR_VAL_LOCATION_INFORMATION
#define REGSTR_VALUE_CAPABILITIES                    REGSTR_VAL_CAPABILITIES
#define REGSTR_VALUE_UI_NUMBER                       REGSTR_VAL_UI_NUMBER
#define REGSTR_VALUE_HARDWAREID                      REGSTR_VAL_HARDWAREID
#define REGSTR_VALUE_COMPATIBLEIDS                   REGSTR_VAL_COMPATIBLEIDS
#define REGSTR_VALUE_CLASSGUID                       REGSTR_VAL_CLASSGUID
#define REGSTR_VALUE_DEVICE_IDS                      TEXT("DeviceIDs")
#define REGSTR_VALUE_COUNT                           TEXT("Count")
#define REGSTR_KEY_INSTANCE_KEY_FORMAT               TEXT("%04u")
#define REGSTR_VALUE_STANDARD_ULONG_FORMAT           TEXT("%u")
#define REGSTR_VALUE_GROUP                           TEXT("Group")
#define REGSTR_VALUE_NT_PHYSICAL_DEVICE_PATHS        TEXT("NtPhysicalDevicePaths")
#define REGSTR_VALUE_NT_LOGICAL_DEVICE_PATHS         TEXT("NtLogicalDevicePaths")
#define REGSTR_VALUE_STATIC                          TEXT("Static")
#define REGSTR_VALUE_NEXT_INSTANCE                   TEXT("NextInstance")
#define REGSTR_KEY_MADEUP                            TEXT("LEGACY_")
#define REGSTR_VALUE_CSCONFIG_FLAGS                  REGSTR_VAL_CSCONFIGFLAGS
#define REGSTR_PATH_CONTROL_IDCONFIGDB               TEXT("Control\\IDConfigDB")
#define REGSTR_VALUE_CURRENT_CONFIG                  REGSTR_VAL_CURCONFIG
#define REGSTR_KEY_BIB_FORMAT                        TEXT("*BIB%04X")
#define REGSTR_VALUE_INTERFACE_TYPE_FORMAT           TEXT("InterfaceType%04u")
#define REGSTR_PATH_CONTROL_CLASS                    TEXT("Control\\Class")
#define REGSTR_VALUE_CLASS                           REGSTR_VAL_CLASS
#define REGSTR_PATH_SYSTEM_RESOURCES_BUS_VALUES      TEXT("Control\\SystemResources\\BusValues")
#define REGSTR_VALUE_DEVICE_STATUS_FORMAT            TEXT("DeviceStatus%u")
#define REGSTR_VALUE_DRIVER                          REGSTR_VAL_DRIVER
#define REGSTR_VALUE_HTREE_ROOT_0                    REGSTR_VAL_ROOT_DEVNODE
// #define REGSTR_VALUE_UNKNOWN_CLASS_GUID              TEXT("{4D36E97E-E325-11CE-BFC1-08002BE10318}")
#define REGSTR_VALUE_LEGACY_DRIVER_CLASS_GUID        TEXT("{8ECC055D-047F-11D1-A537-0000F8753ED1}")
// DEFINE_GUID(REGSTR_VALUE_LEGACY_DRIVER_CLASS_GUID, 0x8ECC055D, 0x047F, 0x11D1, 0xA5, 0x37, 0x00, 0x00, 0xF8, 0x75, 0x3E, 0xD1);
// #define REGSTR_VALUE_UNKNOWN                         TEXT("Unknown")
#define REGSTR_VALUE_LEGACY_DRIVER                   TEXT("LegacyDriver")
#define REGSTR_VALUE_DISPLAY_NAME                    REGSTR_VAL_UNINSTALLER_DISPLAYNAME
#define REGSTR_VALUE_DEVICE_DESC                     REGSTR_VAL_DEVDESC
#define REGSTR_VALUE_PROBLEM                         REGSTR_VAL_PROBLEM
#define REGSTR_VALUE_CONFIG_FLAGS                    REGSTR_VAL_CONFIGFLAGS
#define REGSTR_VALUE_NEWLY_CREATED                   TEXT("*NewlyCreated*")
#define REGSTR_VALUE_MIGRATED                        TEXT("Migrated")
#define REGSTR_KEY_LOG_CONF                          TEXT("LogConf")
#define REGSTR_VALUE_ALLOC_CONFIG                    TEXT("AllocConfig")
#define REGSTR_VALUE_FORCED_CONFIG                   TEXT("ForcedConfig")
#define REGSTR_VALUE_BOOT_CONFIG                     TEXT("BootConfig")
#define REGSTR_VALUE_FILTERED_CONFIG_VECTOR          TEXT("FilteredConfigVector")
#define REGSTR_VALUE_OVERRIDE_CONFIG_VECTOR          TEXT("OverrideConfigVector")
#define REGSTR_VALUE_BASIC_CONFIG_VECTOR             TEXT("BasicConfigVector")
#define REGSTR_VALUE_DEVICE_REPORTED                 TEXT("DeviceReported")
#define REGSTR_VALUE_DETECTED_DEVICE                 TEXT("PhysicalDeviceObject")
#define REGSTR_VALUE_LEGACY                          TEXT("Legacy")
#define REGSTR_VALUE_NO_RESOURCE_AT_INIT             TEXT("NoResourceAtInitTime")
#define PNPMGR_STR_PNP_MANAGER                       TEXT("PnP Manager")
#define PNPMGR_STR_PNP_DRIVER                        TEXT("\\Driver\\PnpManager")    // Must be the same
#define REGSTR_KEY_PNP_DRIVER                        TEXT("PnpManager")              // Must be the same
#define REGSTR_FULL_PATH_DEVICE_CLASSES              TEXT("\\Registry\\Machine\\") REGSTR_PATH_DEVICE_CLASSES
#define REGSTR_PATH_CONTROL_PNP                      TEXT("Control\\Pnp")
#define REGSTR_KEY_PARAMETERS                        TEXT("Parameters")
#define REGSTR_VALUE_NEXT_PARENT_ID                  TEXT("NextParentID")
#define REGSTR_VALUE_BUS_TYPE_GUID                   TEXT("BusTypeGuid")
#define REGSTR_VALUE_DISABLE_FIRMWARE_MAPPER         TEXT("DisableFirmwareMapper")
#define REGSTR_VAL_REFERENCECOUNT                    TEXT("ReferenceCount")
#define REGSTR_VAL_FIRMWAREDISABLED                  TEXT("FirmwareDisabled")
#define REGSTR_VAL_WIN2000STARTORDER                 TEXT("Win2000StartOrder")
#define REGSTR_VAL_RETURNHANDLEINFO                  TEXT("ReturnHandleInfo")
#endif // _KERNEL_REGSTRP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\remlock.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    remlock.c

Abstract:

    This code implements remove locks.

Authors:

    Peter Wieland
    Kenneth Ray

Environment:

    kernel mode only

Notes:



Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#include <remlock.h>

#pragma alloc_text(PAGE, IoInitializeRemoveLockEx)
#pragma alloc_text(PAGE, IoReleaseRemoveLockAndWaitEx)

#define MinutesToTicks(x) \
        (ULONGLONG) KeQueryTimeIncrement() * \
        10 * \
        1000 * \
        1000 * \
        60 * \
        x

// 10 -> microseconds, 1000 -> miliseconds, 1000 -> seconds, 60 -> minutes


typedef struct _IO_PRIVATE_REMOVE_LOCK {
    IO_REMOVE_LOCK_COMMON_BLOCK Common;
    IO_REMOVE_LOCK_DBG_BLOCK Dbg;
} IO_PRIVATE_REMOVE_LOCK, *PIO_PRIVATE_REMOVE_LOCK;


#define FREESIZE sizeof (IO_REMOVE_LOCK_COMMON_BLOCK)
#define CHECKEDSIZE sizeof (IO_PRIVATE_REMOVE_LOCK)


NTSYSAPI
VOID
NTAPI
IoInitializeRemoveLockEx(
    IN  PIO_REMOVE_LOCK PublicLock,
    IN  ULONG   AllocateTag, // Used only on checked kernels
    IN  ULONG   MaxLockedMinutes, // Used only on checked kernels
    IN  ULONG   HighWatermark, // Used only on checked kernels
    IN  ULONG   RemlockSize // are we checked or free
    )
/*++

Routine Description:

    This routine is called to initialize the remove lock for a device object.

--*/
{
    PIO_PRIVATE_REMOVE_LOCK Lock = (PIO_PRIVATE_REMOVE_LOCK) PublicLock;

    PAGED_CODE ();

    ASSERTMSG("HighWatermark too large, use 0 if you dont know a reasonable value", 
              (HighWatermark < MAXLONG));

    if (Lock) {

        switch (RemlockSize) {

        case CHECKEDSIZE:
            Lock->Dbg.Signature = IO_REMOVE_LOCK_SIG;
            Lock->Dbg.HighWatermark = HighWatermark;
            Lock->Dbg.MaxLockedTicks = MinutesToTicks (MaxLockedMinutes);
            Lock->Dbg.AllocateTag = AllocateTag;
            KeInitializeSpinLock (&Lock->Dbg.Spin);
            Lock->Dbg.LowMemoryCount = 0;
            Lock->Dbg.Blocks = NULL;

            //
            // fall through
            //
        case FREESIZE:
            Lock->Common.Removed = FALSE;
            Lock->Common.IoCount = 1;
            KeInitializeEvent(&Lock->Common.RemoveEvent,
                              SynchronizationEvent,
                              FALSE);
            break;

        default:
            break;
        }
    }
}


NTSYSAPI
NTSTATUS
NTAPI
IoAcquireRemoveLockEx(
    IN PIO_REMOVE_LOCK PublicLock,
    IN OPTIONAL PVOID   Tag,
    IN PCSTR            File,
    IN ULONG            Line,
    IN ULONG            RemlockSize // are we checked or free
    )

/*++

Routine Description:

    This routine is called to acquire the remove lock for a device object.
    While the lock is held, the caller can assume that no pending pnp REMOVE
    requests will be completed.

    The lock should be acquired immediately upon entering a dispatch routine.
    It should also be acquired before creating any new reference to the
    device object if there's a chance of releasing the reference before the
    new one is done.

Arguments:

    RemoveLock - A pointer to an initialized REMOVE_LOCK structure.

    Tag - Used for tracking lock allocation and release.  If an irp is
          specified when acquiring the lock then the same Tag must be
          used to release the lock before the Tag is completed.

    File - set to __FILE__ as the location in the code where the lock was taken.

    Line - set to __LINE__.

Return Value:

    Returns whether or not the remove lock was obtained.
    If successful the caller should continue with work calling
    IoReleaseRemoveLock when finished.

    If not successful the lock was not obtained.  The caller should abort the
    work but not call IoReleaseRemoveLock.

--*/

{
    PIO_PRIVATE_REMOVE_LOCK Lock = (PIO_PRIVATE_REMOVE_LOCK) PublicLock;
    LONG        lockValue;
    NTSTATUS    status;

    PIO_REMOVE_LOCK_TRACKING_BLOCK trackingBlock;

    //
    // Grab the remove lock
    //

    lockValue = InterlockedIncrement(&Lock->Common.IoCount);

    ASSERTMSG("IoAcquireRemoveLock - lock value was negative : ",
              (lockValue > 0));

    if (! Lock->Common.Removed) {

        switch (RemlockSize) {
        case CHECKEDSIZE:

            ASSERTMSG("RemoveLock increased to meet LockHighWatermark",
                      ((0 == Lock->Dbg.HighWatermark) ||
                       ((ULONG)lockValue <= Lock->Dbg.HighWatermark)));

            trackingBlock = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(IO_REMOVE_LOCK_TRACKING_BLOCK),
                                Lock->Dbg.AllocateTag);

            if (NULL == trackingBlock) {

                // ASSERTMSG ("insufficient resources", FALSE);
                InterlockedIncrement (& Lock->Dbg.LowMemoryCount);
                //
                // Let the acquire go through but without adding the
                // tracking block.
                // When we are later releasing the lock, but the tracking
                // block does not exist, deduct from this value to see if the
                // release was still valuable.
                //

            } else {

                KIRQL oldIrql;

                RtlZeroMemory (trackingBlock,
                               sizeof (IO_REMOVE_LOCK_TRACKING_BLOCK));

                trackingBlock->Tag = Tag;
                trackingBlock->File = File;
                trackingBlock->Line = Line;

                KeQueryTickCount(&trackingBlock->TimeLocked);

                ExAcquireSpinLock (&Lock->Dbg.Spin, &oldIrql);
                trackingBlock->Link = Lock->Dbg.Blocks;
                Lock->Dbg.Blocks = trackingBlock;
                ExReleaseSpinLock(&Lock->Dbg.Spin, oldIrql);
            }
            break;

        case FREESIZE:
            break;

        default:
            break;
        }

        status = STATUS_SUCCESS;

    } else {

        if (0 == InterlockedDecrement (&Lock->Common.IoCount)) {
            KeSetEvent (&Lock->Common.RemoveEvent, 0, FALSE);
        }
        status = STATUS_DELETE_PENDING;
    }

    return status;
}


NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockEx(
    IN PIO_REMOVE_LOCK PublicLock,
    IN PVOID            Tag,
    IN ULONG            RemlockSize // are we checked or free
    )

/*++

Routine Description:

    This routine is called to release the remove lock on the device object.  It
    must be called when finished using a previously locked reference to the
    device object.  If an Tag was specified when acquiring the lock then the
    same Tag must be specified when releasing the lock.

    When the lock count reduces to zero, this routine will signal the waiting
    event to release the waiting thread deleting the device object protected
    by this lock.

Arguments:

    DeviceObject - the device object to lock

    Tag - The tag (if any) specified when acquiring the lock.  This is used
          for lock tracking purposes

Return Value:

    none

--*/

{
    PIO_PRIVATE_REMOVE_LOCK Lock = (PIO_PRIVATE_REMOVE_LOCK) PublicLock;
    LONG            lockValue;
    KIRQL           oldIrql;
    LARGE_INTEGER   ticks;
    LONGLONG        difference;
    BOOLEAN         found;

    PIO_REMOVE_LOCK_TRACKING_BLOCK last;
    PIO_REMOVE_LOCK_TRACKING_BLOCK current;

    switch (RemlockSize) {
    case CHECKEDSIZE:

        //
        // Check the tick count and make sure this thing hasn't been locked
        // for more than MaxLockedMinutes.
        //

        found = FALSE;
        ExAcquireSpinLock(&Lock->Dbg.Spin, &oldIrql);
        last = (Lock->Dbg.Blocks);
        current = last;

        KeQueryTickCount((&ticks));

        while (NULL != current) {

            if (Lock->Dbg.MaxLockedTicks) {
                difference = ticks.QuadPart - current->TimeLocked.QuadPart;

                if (Lock->Dbg.MaxLockedTicks < difference) {

                    IopDbgPrint((   IOP_ERROR_LEVEL,
                                    "IoReleaseRemoveLock: Lock %#08lx (tag %#08lx) "
                                    "locked for %I64d ticks - TOO LONG\n",
                                    Lock,
                                    current->Tag,
                                    difference));

                    IopDbgPrint((   IOP_ERROR_LEVEL,
                                    "IoReleaseRemoveLock: Lock acquired in file "
                                    "%s on line %d\n",
                                    current->File,
                                    current->Line));
                    ASSERT(FALSE);
                }
            }

            if ((!found) && (current->Tag == Tag)) {
                found = TRUE;
                if (current == Lock->Dbg.Blocks) {
                    Lock->Dbg.Blocks = current->Link;
                    ExFreePool (current);
                    current = Lock->Dbg.Blocks;
                } else {
                    last->Link = current->Link;
                    ExFreePool (current);
                    current = last->Link;
                }
                continue;
            }

            last = current;
            current = current->Link;
        }

        ExReleaseSpinLock(&Lock->Dbg.Spin, oldIrql);

        if (!found) {
            //
            // Check to see if we have any credits in our Low Memory Count.
            // In this fassion we can tell if we have acquired any locks without
            // the memory for adding tracking blocks.
            //
            if (InterlockedDecrement (& Lock->Dbg.LowMemoryCount) < 0) {
                //
                // We have just released a lock that neither had a corresponding
                // tracking block, nor a credit in LowMemoryCount.
                //
                InterlockedIncrement (& Lock->Dbg.LowMemoryCount);
                IopDbgPrint ((  IOP_ERROR_LEVEL,
                                "IoReleaseRemoveLock: Couldn't find Tag %#08lx "
                                "in the lock tracking list\n",
                                Tag));
                ASSERT(FALSE);
            }
        }
        break;

    case FREESIZE:
        break;

    default:
        break;
    }

    lockValue = InterlockedDecrement(&Lock->Common.IoCount);

    ASSERT(0 <= lockValue);

    if (0 == lockValue) {

        ASSERT (Lock->Common.Removed);

        //
        // The device needs to be removed.  Signal the remove event
        // that it's safe to go ahead.
        //

        KeSetEvent(&Lock->Common.RemoveEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
    return;
}


NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockAndWaitEx (
    IN PIO_REMOVE_LOCK PublicLock,
    IN PVOID            Tag,
    IN ULONG            RemlockSize // are we checked or free
    )

/*++

Routine Description:

    This routine is called when the client would like to delete the remove-
    locked resource.
    This routine will block until all the remove locks have completed.

    This routine MUST be called after acquiring once more the lock.

Arguments:

    RemoveLock -

Return Value:

    none

--*/
{
    PIO_PRIVATE_REMOVE_LOCK Lock = (PIO_PRIVATE_REMOVE_LOCK) PublicLock;
    LONG    ioCount;

    PAGED_CODE ();

    Lock->Common.Removed = TRUE;

    ioCount = InterlockedDecrement (&Lock->Common.IoCount);
    ASSERT (0 < ioCount);

    if (0 < InterlockedDecrement (&Lock->Common.IoCount)) {
        KeWaitForSingleObject (&Lock->Common.RemoveEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);
    }

    switch (RemlockSize) {
    case CHECKEDSIZE:

        ASSERT (Lock->Dbg.Blocks);
        if (Tag != Lock->Dbg.Blocks->Tag) {
            IopDbgPrint ((  IOP_ERROR_LEVEL,
                            "IoRelaseRemoveLockAndWait last tag invalid %x %x\n",
                            Tag,
                            Lock->Dbg.Blocks->Tag));

            ASSERT (Tag != Lock->Dbg.Blocks->Tag);
        }

        ExFreePool (Lock->Dbg.Blocks);
        break;

    case FREESIZE:
        break;

    default:
        break;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=io

TARGETNAME=pnpmgr
TARGETTYPE=LIBRARY
TARGETPATH=obj

MSC_WARNING_LEVEL=/W4 /WX
BUILD_PRODUCES=ntospnpmgr$(NT_UP)

INCLUDES=..;..\..;\
         ..\..\..\inc;\
         ..\..\..\pnp;\
         $(WINDOWS_INC_PATH);\
         $(DDK_INC_PATH);\
         $(NET_INC_PATH);\
         $(HALKIT_INC_PATH)

SOURCES=   \
        ..\assign.c   \
        ..\devices.c  \
        ..\devnode.c  \
        ..\devintrf.c \
        ..\dockhwp.c  \
        ..\iofileutil.c \
        ..\mapper.c   \
        ..\notify.c   \
        ..\pnpbusno.c \
        ..\pnpcvrt.c  \
        ..\pnpdata.c  \
        ..\pnpdd.c    \
        ..\pnpdel.c   \
        ..\pnpdma.c   \
        ..\pnpeisa.c  \
        ..\pnpenum.c  \
        ..\pnpevent.c  \
        ..\pnpinit.c  \
        ..\pnpioapi.c \
        ..\pnpirp.c   \
        ..\pnpirq.c   \
        ..\pnpmap.c   \
        ..\pnpmemio.c \
        ..\pnppower.c \
        ..\pnpres.c   \
        ..\pnprlist.c \
        ..\pnpstart.c  \
        ..\pnpsubs.c  \
        ..\ppcddb.c   \
        ..\ppcontrol.c  \
        ..\pphandle.c \
        ..\pphotswap.c \
        ..\pplastgood.c \
        ..\pppagepath.c \
        ..\ppdrvdb.c \
        ..\ppprofile.c  \
        ..\ppvutil.c \
        ..\remlock.c \
        ..\report.c

NTTEST=

PRECOMPILED_INCLUDE=..\pnpmgrp.h
PRECOMPILED_PCH=pnpmgrp.pch
PRECOMPILED_OBJ=pnpmgrp.obj

#  SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\i386\pbiosa.asm ===
title  "Pnp Bios Bus Extender ASM support routines"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved.
;
; Module Name:
;
;    pbiosa.asm
;
; Abstract:
;
;    This file contains Pnp Bios ASM support routines.
;
; Author:
;
;    Shie-Lin Tzong (shielint) Jan 15, 1998
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
.xlist
include callconv.inc                    ; calling convention macros
.list

        EXTRNP  _RtlMoveMemory, 3
        EXTRNP  _KeI386Call16BitCStyleFunction, 4

PAGELK  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; PbCallPnpBiosWorker (
;     IN ULONG EntryOffset,
;     IN ULONG EntrySelector,
;     IN PUSHORT Parameters,
;     IN ULONG ParameterSize
;     );
;
; Routine Description:
;
;     This routines copies the specified parameters to stack and invokes
;     Pnp Bios Entry point.
;
; Arguments:
;
;     EntryOffset and EntrySelector - supplies the entry point of the bios function.
;
;     Parameters - Supplies a pointer to argument block.
;
;     ParameterSize - Size of the argument block
;
; Return Value:
;
;     Registers/context contains the register values returned from pnp bios.
;
;--

EntryOffset     equ     [ebp + 8]
EntrySelector   equ     [ebp + 12]
Parameters      equ     [ebp + 16]
ParameterSize   equ     [ebp + 20]

cPublicProc _PbCallPnpBiosWorker, 4

        push    ebp
        mov     ebp, esp
        sub     esp, ParameterSize
        mov     eax, esp

        stdCall _RtlMoveMemory, <eax, Parameters, ParameterSize>

        stdCall _KeI386Call16BitCStyleFunction, <EntryOffset, EntrySelector, Parameters, ParameterSize>

        mov     esp, ebp
        pop     ebp
        stdRET  _PbCallPnpBiosWorker

stdENDP _PbCallPnpBiosWorker

PAGELK  ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\report.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    report.c

Abstract:

    This module contains the subroutines used to report resources used by
    the drivers and the HAL into the registry resource map.

Author:

    Andre Vachon (andreva) 15-Dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop

#include <hdlsblk.h>
#include <hdlsterm.h>

#define DBG_AR 0

#define MAX_MEMORY_RUN_LENGTH   ((ULONG)~(PAGE_SIZE - 1))

extern const WCHAR IopWstrRaw[];
extern const WCHAR IopWstrTranslated[];
extern const WCHAR IopWstrBusTranslated[];
extern const WCHAR IopWstrOtherDrivers[];

extern const WCHAR IopWstrHal[];
extern const WCHAR IopWstrSystem[];
extern const WCHAR IopWstrPhysicalMemory[];
extern const WCHAR IopWstrSpecialMemory[];
extern const WCHAR IopWstrLoaderReservedMemory[];

BOOLEAN
IopChangeInterfaceType(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST IoResources,
    IN OUT PCM_RESOURCE_LIST *AllocatedResource
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoReportResourceUsageInternal)
#pragma alloc_text(PAGE, IoReportResourceUsage)
#pragma alloc_text(PAGE, IoReportResourceForDetection)
#pragma alloc_text(PAGE, IopChangeInterfaceType)
#pragma alloc_text(PAGE, IopWriteResourceList)
#pragma alloc_text(INIT, IopInitializeResourceMap)
#pragma alloc_text(INIT, IoReportHalResourceUsage)
#endif


VOID
IopInitializeResourceMap (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

    Initializes the resource map by adding in the physical memory
    which is in use by the system.

--*/
{
    ULONG i, j, pass, length;
    LARGE_INTEGER li;
    HANDLE keyHandle;
    UNICODE_STRING  unicodeString, systemString, listString;
    NTSTATUS status;
    PCM_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor;
    BOOLEAN IncludeType[LoaderMaximum];
    PPHYSICAL_MEMORY_DESCRIPTOR MemoryBlock;
    LONGLONG rangeLength;

    RtlInitUnicodeString( &systemString,  IopWstrSystem);
    for (pass=0; pass < 3; pass += 1) {
        switch (pass) {
            case 0:
                //
                // Add MmPhysicalMemoryBlock to registry
                //

                RtlInitUnicodeString( &unicodeString, IopWstrPhysicalMemory);
                RtlInitUnicodeString( &listString, IopWstrTranslated );

                MemoryBlock = MmPhysicalMemoryBlock;
                break;

            case 1:

                //
                // Add LoaderSpecialMemory and LoaderHALCachedMemory
                // to registry
                //

                RtlInitUnicodeString( &unicodeString, IopWstrSpecialMemory);
                RtlInitUnicodeString( &listString, IopWstrTranslated );

                //
                // Compute memory limits of LoaderSpecialMemory and
                // LoaderHalCachedMemory
                //

                for (j=0; j < LoaderMaximum; j += 1) {
                    IncludeType[j] = FALSE;
                }
                IncludeType[LoaderSpecialMemory] = TRUE;
                IncludeType[LoaderHALCachedMemory] = TRUE;

                MemoryBlock = MmInitializeMemoryLimits (LoaderBlock,
                                                        IncludeType,
                                                        NULL);

                if (MemoryBlock == NULL) {
                    continue;
                }

                break;
            case 2:
            default:
                
                //
                // Create registry key that includes:
                //     LoaderBad
                //     LoaderFirmwarePermanent
                //     LoaderSpecialMemory
                //     LoaderBBTMemory
                //     LoaderHALCachedMemory
                //

                RtlInitUnicodeString( &unicodeString, IopWstrLoaderReservedMemory);
                RtlInitUnicodeString( &listString, IopWstrRaw );

                //
                // Compute memory limits of specified loader memory
                // descriptors.
                //

                for (j=0; j < LoaderMaximum; j += 1) {
                    IncludeType[j] = FALSE;
                }
                IncludeType[LoaderBad] = TRUE;
                IncludeType[LoaderFirmwarePermanent] = TRUE;
                IncludeType[LoaderSpecialMemory] = TRUE;
                IncludeType[LoaderBBTMemory] = TRUE;
                IncludeType[LoaderHALCachedMemory] = TRUE;

                MemoryBlock = MmInitializeMemoryLimits (LoaderBlock,
                                                        IncludeType,
                                                        NULL);

                if (MemoryBlock == NULL) {
                    return;
                }
                
                break;
        }

        //
        // Allocate and build a CM_RESOURCE_LIST to describe all
        // of physical memory
        //

        j = MemoryBlock->NumberOfRuns;
        if (j == 0) {
            if (pass != 0) {
                ExFreePool (MemoryBlock);
            }
            continue;
        }

        //
        // This is to take care of systems where individual memory run can 
        // exceed 4G since our current descriptors only have 32-bit length.
        // Account for runs with length > MAX_MEMORY_RUN_LENGTH by splitting
        // them into lengths <= MAX_MEMORY_RUN_LENGTH.
        //

        for (i = 0; i < MemoryBlock->NumberOfRuns; i += 1) {

            rangeLength = ((LONGLONG)MemoryBlock->Run[i].PageCount) << PAGE_SHIFT;
            while ((rangeLength -= MAX_MEMORY_RUN_LENGTH) > 0) {
                j += 1;
            }
        }

        length = sizeof(CM_RESOURCE_LIST) + (j-1) * sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR);
        ResourceList = (PCM_RESOURCE_LIST) ExAllocatePool (PagedPool, length);
        if (!ResourceList) {
            if (pass != 0) {
                ExFreePool (MemoryBlock);
            }
            return;
        }
        RtlZeroMemory ((PVOID) ResourceList, length);

        ResourceList->Count = 1;
        ResourceList->List[0].PartialResourceList.Count = j;
        CmDescriptor = ResourceList->List[0].PartialResourceList.PartialDescriptors;

        for (i=0; i < MemoryBlock->NumberOfRuns; i += 1) {
            rangeLength = ((LONGLONG)MemoryBlock->Run[i].PageCount) << PAGE_SHIFT;
            li.QuadPart = ((LONGLONG)MemoryBlock->Run[i].BasePage) << PAGE_SHIFT;

            //
            // Split up runs > MAX_MEMORY_RUN_LENGTH into multiple descriptors
            // with lengths <= MAX_MEMORY_RUN_LENGTH. All descriptors (except 
            // the last one) have length = MAX_MEMORY_RUN_LENGTH. Length of the 
            // last one is the remaining portion.
            //

            do {                
                CmDescriptor->Type = CmResourceTypeMemory;
                CmDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                CmDescriptor->u.Memory.Start  = li;
                CmDescriptor->u.Memory.Length = MAX_MEMORY_RUN_LENGTH;
                CmDescriptor++;
                li.QuadPart += MAX_MEMORY_RUN_LENGTH;                
            } while ((rangeLength -= MAX_MEMORY_RUN_LENGTH) > 0);
            //
            // Adjust the length of the last one.
            //
            (CmDescriptor - 1)->u.Memory.Length = (ULONG)(rangeLength + MAX_MEMORY_RUN_LENGTH);
        }

        //
        // Add the resource list to the resourcemap
        //

        status = IopCreateRegistryKeyEx( &keyHandle,
                                         (HANDLE) NULL,
                                         &CmRegistryMachineHardwareResourceMapName,
                                         KEY_READ | KEY_WRITE,
                                         REG_OPTION_VOLATILE,
                                         NULL );
        if (NT_SUCCESS( status )) {
            IopWriteResourceList ( keyHandle,
                                   &systemString,
                                   &unicodeString,
                                   &listString,
                                   ResourceList,
                                   length
                                   );
            ZwClose( keyHandle );
        }
        ExFreePool (ResourceList);
        if (pass != 0) {
            ExFreePool (MemoryBlock);
        }
    }
}

NTSTATUS
IoReportHalResourceUsage(
    IN PUNICODE_STRING HalName,
    IN PCM_RESOURCE_LIST RawResourceList,
    IN PCM_RESOURCE_LIST TranslatedResourceList,
    IN ULONG ResourceListSize
    )

/*++

Routine Description:

    This routine is called by the HAL to report its resources.
    The HAL is the first component to report its resources, so we don't need
    to acquire the resourcemap semaphore and we do not need to check for
    conflicts.

Arguments:

    HalName - Name of the HAL reporting the resources.

    RawResourceList - Pointer to the HAL's raw resource list.

    TranslatedResourceList - Pointer to the HAL's translated resource list.

    DriverListSize - Value determining the size of the HAL's resource list.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    HANDLE keyHandle;
    UNICODE_STRING halString;
    UNICODE_STRING listString;
    NTSTATUS status;
    PCM_RESOURCE_LIST NewList = NULL;
    ULONG NewListSize;
    PCM_RESOURCE_LIST NewTranslatedList;
    ULONG NewTranslatedListSize;

    PAGED_CODE();

    //
    // First open a handle to the RESOURCEMAP key.
    //

    RtlInitUnicodeString( &halString, IopWstrHal );

    status = IopCreateRegistryKeyEx( &keyHandle,
                                     (HANDLE) NULL,
                                     &CmRegistryMachineHardwareResourceMapName,
                                     KEY_READ | KEY_WRITE,
                                     REG_OPTION_VOLATILE,
                                     NULL );

    //
    // Write out the raw resource list
    //

    if (NT_SUCCESS( status )) {

        RtlInitUnicodeString( &listString, IopWstrRaw);

        //
        // Add any resources that Headless is reserving.
        //
        status = HeadlessTerminalAddResources(RawResourceList,
                                              ResourceListSize,
                                              FALSE,
                                              &NewList,
                                              &NewListSize
                                             );

        if (NT_SUCCESS(status)) {

            status = IopWriteResourceList( keyHandle,
                                           &halString,
                                           HalName,
                                           &listString,
                                           (NewList != NULL) ? NewList : RawResourceList,
                                           (NewList != NULL) ? NewListSize : ResourceListSize
                                         );

        }

        //
        // If we successfully wrote out the raw resource list, write out
        // the translated resource list.
        //

        if (NT_SUCCESS( status )) {

            RtlInitUnicodeString( &listString, IopWstrTranslated);

            //
            // Add any resources that Headless is reserving.
            //
            status = HeadlessTerminalAddResources(TranslatedResourceList,
                                                  ResourceListSize,
                                                  TRUE,
                                                  &NewTranslatedList,
                                                  &NewTranslatedListSize
                                                 );

            if (NT_SUCCESS(status)) {

                status = IopWriteResourceList(keyHandle,
                                              &halString,
                                              HalName,
                                              &listString,
                                              (NewTranslatedList != NULL) ?
                                                   NewTranslatedList : TranslatedResourceList,
                                              (NewTranslatedList != NULL) ?
                                                   NewTranslatedListSize : ResourceListSize
                                             );

                if (NewTranslatedList != NULL) {
                    ExFreePool(NewTranslatedList);
                }

            }

        }

        ZwClose( keyHandle );
    }

    //
    // If every resource looks fine, we will store the copy of the HAL
    // resources so we can call Arbiters to reserve the resources after
    // they are initialized.
    //
    if (NT_SUCCESS(status)) {

        if (NewList != NULL) {

            //
            // An easy way is if headless created a new list for us, just don't free it.
            //
            IopInitHalResources = NewList;

        } else {

            //
            // Otherwise we have to create a copy ourselves.
            //
            IopInitHalResources = (PCM_RESOURCE_LIST) ExAllocatePool(PagedPool,
                                                                     ResourceListSize
                                                                    );
            if (IopInitHalResources != NULL) {
                RtlCopyMemory(IopInitHalResources, RawResourceList, ResourceListSize);
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

        }

    } else if (NewList != NULL) {

        //
        // Free any failed list
        //
        ExFreePool(NewList);

    }

    return status;
}

NTSTATUS
IoReportResourceForDetection(
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    OUT PBOOLEAN ConflictDetected
    )

/*++

Routine Description:

    This routine will automatically search through the configuration
    registry for resource conflicts between resources requested by a device
    and the resources already claimed by previously installed drivers. The
    contents of the DriverList and the DeviceList will be matched against
    all the other resource list stored in the registry to determine
    conflicts.

    The function may be called more than once for a given device or driver.
    If a new resource list is given, the previous resource list stored in
    the registry will be replaced by the new list.

    Note, this function is for the drivers acquiring resources for detection.

Arguments:

    DriverObject - Pointer to the driver's driver object.

    DriverList - Optional pointer to the driver's resource list.

    DriverListSize - Optional value determining the size of the driver's
        resource list.

    DeviceObject - Optional pointer to driver's device object.

    DeviceList - Optional pointer to the device's resource list.

    DriverListSize - Optional value determining the size of the device's
        resource list.

    ConflictDetected - Supplies a pointer to a boolean that is set to TRUE
        if the resource list conflicts with an already existing resource
        list in the configuration registry.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();
    //
    // Sanity check that the caller did not pass in a PnP PDO.
    //

    if (DeviceObject) {

        if (    DeviceObject->DeviceObjectExtension->DeviceNode &&
                !(((PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode)->Flags & DNF_LEGACY_RESOURCE_DEVICENODE)) {

            PP_SAVE_DRIVEROBJECT_TO_TRIAGE_DUMP(DriverObject);
            PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(DeviceObject);
            KeBugCheckEx(PNP_DETECTED_FATAL_ERROR, PNP_ERR_INVALID_PDO, (ULONG_PTR)DeviceObject, (ULONG_PTR)DriverObject, 0);

        }

    }

    return IoReportResourceUsageInternal(   ArbiterRequestPnpDetected,
                                            NULL,
                                            DriverObject,
                                            DriverList,
                                            DriverListSize,
                                            DeviceObject,
                                            DeviceList,
                                            DeviceListSize,
                                            FALSE,
                                            ConflictDetected);
}

NTSTATUS
IoReportResourceUsage(
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    )

/*++

Routine Description:

    This routine will automatically search through the configuration
    registry for resource conflicts between resources requested by a device
    and the resources already claimed by previously installed drivers. The
    contents of the DriverList and the DeviceList will be matched against
    all the other resource list stored in the registry to determine
    conflicts.

    If not conflict was detected, or if the OverrideConflict flag is set,
    this routine will create appropriate entries in the system resource map
    (in the registry) that will contain the specified resource lists.

    The function may be called more than once for a given device or driver.
    If a new resource list is given, the previous resource list stored in
    the registry will be replaced by the new list.

Arguments:

    DriverClassName - Optional pointer to a UNICODE_STRING which describes
        the class of driver under which the driver information should be
        stored. A default type is used if none is given.

    DriverObject - Pointer to the driver's driver object.

    DriverList - Optional pointer to the driver's resource list.

    DriverListSize - Optional value determining the size of the driver's
        resource list.

    DeviceObject - Optional pointer to driver's device object.

    DeviceList - Optional pointer to the device's resource list.

    DriverListSize - Optional value determining the size of the driver's
        resource list.

    OverrideConflict - Determines if the information should be reported
        in the configuration registry eventhough a conflict was found with
        another driver or device.

    ConflictDetected - Supplies a pointer to a boolean that is set to TRUE
        if the resource list conflicts with an already existing resource
        list in the configuration registry.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    if (DeviceObject) {

        if (    DeviceObject->DeviceObjectExtension->DeviceNode &&
                !(((PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode)->Flags & DNF_LEGACY_RESOURCE_DEVICENODE)) {

            PP_SAVE_DRIVEROBJECT_TO_TRIAGE_DUMP(DriverObject);
            PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(DeviceObject);
            KeBugCheckEx(PNP_DETECTED_FATAL_ERROR, PNP_ERR_INVALID_PDO, (ULONG_PTR)DeviceObject, (ULONG_PTR)DriverObject, 0);

        }

    }

    return IoReportResourceUsageInternal(   ArbiterRequestLegacyReported,
                                            DriverClassName,
                                            DriverObject,
                                            DriverList,
                                            DriverListSize,
                                            DeviceObject,
                                            DeviceList,
                                            DeviceListSize,
                                            OverrideConflict,
                                            ConflictDetected);
}

NTSTATUS
IoReportResourceUsageInternal(
    IN ARBITER_REQUEST_SOURCE AllocationType,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    )

/*++

Routine Description:

    This internal routine will do all the work for IoReportResourceUsage.

Arguments:

    AllocationType - Specifies the request type.

    DriverClassName - Optional pointer to a UNICODE_STRING which describes
        the class of driver under which the driver information should be
        stored. A default type is used if none is given.

    DriverObject - Pointer to the driver's driver object.

    DriverList - Optional pointer to the driver's resource list.

    DriverListSize - Optional value determining the size of the driver's
        resource list.

    DeviceObject - Optional pointer to driver's device object.

    DeviceList - Optional pointer to the device's resource list.

    DriverListSize - Optional value determining the size of the driver's
        resource list.

    OverrideConflict - Determines if the information should be reported
        in the configuration registry eventhough a conflict was found with
        another driver or device.

    ConflictDetected - Supplies a pointer to a boolean that is set to TRUE
        if the resource list conflicts with an already existing resource
        list in the configuration registry.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;
    PCM_RESOURCE_LIST               resourceList;
    PCM_RESOURCE_LIST               allocatedResources;
    PIO_RESOURCE_REQUIREMENTS_LIST  resourceRequirements;
    ULONG                           attempt;
    BOOLEAN                         freeAllocatedResources;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( DriverClassName );
    UNREFERENCED_PARAMETER( DriverListSize );
    UNREFERENCED_PARAMETER( DeviceListSize );
    UNREFERENCED_PARAMETER( OverrideConflict );

    ASSERT(DriverObject && ConflictDetected);

    if (DeviceList) {

        resourceList = DeviceList;

    } else if (DriverList) {

        resourceList = DriverList;

    } else {

        resourceList = NULL;

    }

    resourceRequirements = NULL;

    if (resourceList) {

        if (resourceList->Count && resourceList->List[0].PartialResourceList.Count) {

            resourceRequirements = IopCmResourcesToIoResources (0, resourceList, LCPRI_NORMAL);

            if (resourceRequirements == NULL) {

                return status;

            }

        } else {

            resourceList = NULL;

        }

    }

    *ConflictDetected = TRUE;
    attempt = 0;
    allocatedResources = resourceList;
    freeAllocatedResources = FALSE;
    do {

        //
        // Do the legacy resource allocation.
        //

        status = IopLegacyResourceAllocation (  AllocationType,
                                                DriverObject,
                                                DeviceObject,
                                                resourceRequirements,
                                                &allocatedResources);

        if (NT_SUCCESS(status)) {

            *ConflictDetected = FALSE;
            break;
        }

        //
        // Change the interface type and try again.
        //

        if (!IopChangeInterfaceType(resourceRequirements, &allocatedResources)) {

            break;
        }
        freeAllocatedResources = TRUE;

    } while (++attempt < 2);

    if (resourceRequirements) {

        ExFreePool(resourceRequirements);

    }

    if (freeAllocatedResources) {

        ExFreePool(allocatedResources);
    }

    if (NT_SUCCESS(status)) {

        status = STATUS_SUCCESS;

    } else if (status != STATUS_INSUFFICIENT_RESOURCES) {

        status = STATUS_CONFLICTING_ADDRESSES;

    }

    return status;
}

BOOLEAN
IopChangeInterfaceType(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST IoResources,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    )

/*++

Routine Description:

    This routine takes an Io resourcelist and changes its interfacetype
    from internal to default type (isa or eisa or mca).

Arguments:

    IoResources - Pointer to requirement list.

    AllocatedResources - Pointer to a variable that receives the pointer to the resource list.

Return Value:

    BOOLEAN value to indicate if the change was made or not.

--*/

{
    PIO_RESOURCE_LIST       IoResourceList;
    PIO_RESOURCE_DESCRIPTOR IoResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR IoResourceDescriptorEnd;
    LONG                    IoResourceListCount;
    BOOLEAN                 changed;

    PAGED_CODE();

    ASSERT(AllocatedResources);

    changed = FALSE;

    if (!IoResources) {

        return changed;

    }

    if (IoResources->InterfaceType == Internal) {

        IoResources->InterfaceType = PnpDefaultInterfaceType;
        changed = TRUE;

    }

    IoResourceList = IoResources->List;
    IoResourceListCount = IoResources->AlternativeLists;
    while (--IoResourceListCount >= 0) {

        IoResourceDescriptor = IoResourceList->Descriptors;
        IoResourceDescriptorEnd = IoResourceDescriptor + IoResourceList->Count;

        for (;IoResourceDescriptor < IoResourceDescriptorEnd; IoResourceDescriptor++) {

            if (IoResourceDescriptor->Type == CmResourceTypeReserved &&
                IoResourceDescriptor->u.DevicePrivate.Data[0] == Internal) {

                IoResourceDescriptor->u.DevicePrivate.Data[0] = PnpDefaultInterfaceType;
                changed = TRUE;

            }
        }
        IoResourceList = (PIO_RESOURCE_LIST) IoResourceDescriptorEnd;
    }

    if (changed) {

        PCM_RESOURCE_LIST               oldResources = *AllocatedResources;
        PCM_RESOURCE_LIST               newResources;
        PCM_FULL_RESOURCE_DESCRIPTOR    cmFullDesc;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
        ULONG                           size;

        if (oldResources) {

            size = IopDetermineResourceListSize(oldResources);
            newResources = ExAllocatePool(PagedPool, size);
            if (newResources == NULL) {

                changed = FALSE;

            } else {

                ULONG   i;
                ULONG   j;


                RtlCopyMemory(newResources, oldResources, size);

                //
                // Fix up the interface type
                //

                cmFullDesc = &newResources->List[0];
                for (i = 0; i < oldResources->Count; i++) {

                    if (cmFullDesc->InterfaceType == Internal) {

                        cmFullDesc->InterfaceType = PnpDefaultInterfaceType;

                    }
                    cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
                    for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {

                        size = 0;
                        switch (cmPartDesc->Type) {

                        case CmResourceTypeDeviceSpecific:
                            size = cmPartDesc->u.DeviceSpecificData.DataSize;
                            break;

                        }
                        cmPartDesc++;
                        cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
                    }

                    cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
                }

                *AllocatedResources = newResources;
            }
        }
    }

    return changed;
}

NTSTATUS
IopWriteResourceList(
    HANDLE ResourceMapKey,
    PUNICODE_STRING ClassName,
    PUNICODE_STRING DriverName,
    PUNICODE_STRING DeviceName,
    PCM_RESOURCE_LIST ResourceList,
    ULONG ResourceListSize
    )

/*++

Routine Description:

    This routine takes a resourcelist and stores it in the registry resource
    map, using the ClassName, DriverName and DeviceName as the path of the
    key to store it in.

Arguments:

    ResourceMapKey - Handle to the root of the resource map.

    ClassName - Pointer to a Unicode String that contains the name of the Class
        for this resource list.

    DriverName - Pointer to a Unicode String that contains the name of the
        Driver for this resource list.

    DeviceName - Pointer to a Unicode String that contains the name of the
        Device for this resource list.

    ResourceList - P to the resource list.

    ResourceListSize - Value determining the size of the resource list.

Return Value:

    The status returned is the final completion status of the operation.

--*/


{
    NTSTATUS status;
    HANDLE classKeyHandle;
    HANDLE driverKeyHandle;

    PAGED_CODE();

    status = IopCreateRegistryKeyEx( &classKeyHandle,
                                     ResourceMapKey,
                                     ClassName,
                                     KEY_READ | KEY_WRITE,
                                     REG_OPTION_VOLATILE,
                                     NULL );

    if (NT_SUCCESS( status )) {

        //
        // Take the resulting name to create the key.
        //

        status = IopCreateRegistryKeyEx( &driverKeyHandle,
                                         classKeyHandle,
                                         DriverName,
                                         KEY_READ | KEY_WRITE,
                                         REG_OPTION_VOLATILE,
                                         NULL );

        ZwClose( classKeyHandle );


        if (NT_SUCCESS( status )) {

            //
            // With this key handle, we can now store the required information
            // in the value entries of the key.
            //

            //
            // Store the device name as a value name and the device information
            // as the rest of the data.
            // Only store the information if the CM_RESOURCE_LIST was present.
            //

            if (ResourceList->Count == 0) {

                status = ZwDeleteValueKey( driverKeyHandle,
                                           DeviceName );

            } else {

                status = ZwSetValueKey( driverKeyHandle,
                                        DeviceName,
                                        0L,
                                        REG_RESOURCE_LIST,
                                        ResourceList,
                                        ResourceListSize );

            }

            ZwClose( driverKeyHandle );

        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\ppvutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ppvutil.c

Abstract:

    This module implements various utilities required to do driver verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\trackirp.c

--*/

#include "pnpmgrp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, PpvUtilInit)
//#pragma alloc_text(PAGEVRFY, PpvUtilFailDriver)
//#pragma alloc_text(PAGEVRFY, PpvUtilCallAddDevice)
//#pragma alloc_text(PAGEVRFY, PpvUtilTestStartedPdoStack)

#ifndef NO_VERIFIER
#pragma alloc_text(PAGEVRFY, PpvUtilGetDevnodeRemovalOption)
#pragma alloc_text(PAGEVRFY, PpvUtilIsHardwareBeingVerified)
#endif // NO_VERIFIER

#endif // ALLOC_PRAGMA


//
// This entire implementation is specific to the verifier
//
#ifndef NO_VERIFIER

BOOLEAN PpvUtilVerifierEnabled = FALSE;


VOID
FASTCALL
PpvUtilInit(
    VOID
    )
{
    PpvUtilVerifierEnabled = TRUE;
}


NTSTATUS
FASTCALL
PpvUtilCallAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType
    )
{
    NTSTATUS status;

    if (!PpvUtilVerifierEnabled) {

        return AddDeviceFunction(DriverObject, PhysicalDeviceObject);
    }

    //
    // Notify the verifier prior to AddDevice
    //
    VfDevObjPreAddDevice(
        PhysicalDeviceObject,
        DriverObject,
        AddDeviceFunction,
        DevObjType
        );

    status = AddDeviceFunction(DriverObject, PhysicalDeviceObject);

    //
    // Let the verifier know how it turned out.
    //
    VfDevObjPostAddDevice(
        PhysicalDeviceObject,
        DriverObject,
        AddDeviceFunction,
        DevObjType,
        status
        );

    return status;
}


VOID
FASTCALL
PpvUtilTestStartedPdoStack(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    if (PpvUtilVerifierEnabled) {

        VfMajorTestStartedPdoStack(DeviceObject);
    }
}


VOID
FASTCALL
PpvUtilFailDriver(
    IN  PPVFAILURE_TYPE FailureType,
    IN  PVOID           CulpritAddress,
    IN  PDEVICE_OBJECT  DeviceObject    OPTIONAL,
    IN  PVOID           ExtraneousInfo  OPTIONAL
    )
{
    if (!PpvUtilVerifierEnabled) {

        return;
    }

    switch(FailureType) {

        case PPVERROR_DUPLICATE_PDO_ENUMERATED:
            WDM_FAIL_ROUTINE((
                DCERROR_DUPLICATE_ENUMERATION,
                DCPARAM_ROUTINE + DCPARAM_DEVOBJ*2,
                CulpritAddress,
                DeviceObject,
                ExtraneousInfo
                ));
            break;

        case PPVERROR_MISHANDLED_TARGET_DEVICE_RELATIONS:
            WDM_FAIL_ROUTINE((
                DCERROR_MISHANDLED_TARGET_DEVICE_RELATIONS,
                DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                CulpritAddress,
                DeviceObject
                ));
            break;

        case PPVERROR_DDI_REQUIRES_PDO:
            WDM_FAIL_ROUTINE((
                DCERROR_DDI_REQUIRES_PDO,
                DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                CulpritAddress,
                DeviceObject
                ));
            break;

        default:
            break;
    }
}


PPVREMOVAL_OPTION
FASTCALL
PpvUtilGetDevnodeRemovalOption(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )
{
    PDEVICE_NODE devNode;

    devNode = PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;

    if (devNode == NULL) {

        //
        // This must be PartMgr device, we have no opinion
        //
        return PPVREMOVAL_MAY_DEFER_DELETION;
    }

    if (devNode->Flags & DNF_ENUMERATED) {

        //
        // It's still present, so it mustn't delete itself.
        //
        return PPVREMOVAL_SHOULDNT_DELETE;

    } else if (devNode->Flags & DNF_DEVICE_GONE) {

        //
        // It's been reported missing, it must delete itself now as it's parent
        // may already have been removed.
        //
        return PPVREMOVAL_SHOULD_DELETE;

    } else {

        //
        // Corner case - in theory it should delete itself, but it's parent
        // will get a remove immediately after it does. As such it can defer
        // it's deletion.
        //
        return PPVREMOVAL_MAY_DEFER_DELETION;
    }
}


BOOLEAN
FASTCALL
PpvUtilIsHardwareBeingVerified(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )
{
    PDEVICE_NODE devNode;

    if (!IS_PDO(PhysicalDeviceObject)) {

        return FALSE;
    }

    devNode = PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;

    if ((devNode->Flags & DNF_HARDWARE_VERIFICATION) != 0) {
        return TRUE;
    }

    return FALSE;
}


#else // NO_VERIFIER


//
// The code below should be built into a future stub that deadens out IO
// support for the verifier.
//

VOID
FASTCALL
PpvUtilInit(
    VOID
    )
{
}


NTSTATUS
FASTCALL
PpvUtilCallAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType
    )
{
    UNREFERENCED_PARAMETER(DevObjType);

    return AddDeviceFunction(DriverObject, PhysicalDeviceObject);
}


VOID
FASTCALL
PpvUtilTestStartedPdoStack(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    UNREFERENCED_PARAMETER(DeviceObject);
}


VOID
FASTCALL
PpvUtilFailDriver(
    IN  PPVFAILURE_TYPE FailureType,
    IN  PVOID           CulpritAddress,
    IN  PDEVICE_OBJECT  DeviceObject    OPTIONAL,
    IN  PVOID           ExtraneousInfo  OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(FailureType);
    UNREFERENCED_PARAMETER(CulpritAddress);
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(ExtraneousInfo);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\kdinit.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdinit.c

Abstract:

    This module implements the initialization for the portable kernel debgger.

Author:

    David N. Cutler 27-July-1990

Revision History:

--*/

#include "kdp.h"



BOOLEAN
KdRegisterDebuggerDataBlock(
    IN ULONG Tag,
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader,
    IN ULONG Size
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdInitSystem)
#pragma alloc_text(PAGEKD, KdUpdateDataBlock)
#pragma alloc_text(PAGEKD, KdRegisterDebuggerDataBlock)
#endif

BOOLEAN KdBreakAfterSymbolLoad;

VOID
KdUpdateDataBlock(
    VOID
    )
/*++

Routine Description:

    We have to update this variable seperately since it is initialized at a
    later time by PS.  PS will call us to update the data block.

--*/
{
    KdDebuggerDataBlock.KeUserCallbackDispatcher = (ULONG_PTR) KeUserCallbackDispatcher;
}


ULONG_PTR
KdGetDataBlock(
    VOID
    )
/*++

Routine Description:

    Called by crashdump to get the address of this data block
    This routine can not be paged.

--*/
{
    return (ULONG_PTR)(&KdDebuggerDataBlock);
}



BOOLEAN
KdInitSystem(
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock OPTIONAL
    )

/*++

Routine Description:

    This routine initializes the portable kernel debugger.

Arguments:

    Phase - Initialization phase

    LoaderBlock - Supplies a pointer to the LOADER_PARAMETER_BLOCK passed
        in from the OS Loader.

Return Value:

    None.

--*/

{
    ULONG Index;
    BOOLEAN Initialize;
    PLIST_ENTRY NextEntry;
    PCHAR Options;

    if (Phase == 0) {

        //
        // If kernel debugger is already initialized, then return.
        //

        if (KdDebuggerEnabled != FALSE) {
            return TRUE;
        }

        KiDebugRoutine = KdpStub;
        KdBreakAfterSymbolLoad = FALSE;

        //
        // Determine whether or not the debugger should be enabled.
        //
        // Note that if LoaderBlock == NULL, then KdInitSystem was called
        // from BugCheck code. For this case the debugger is always enabled
        // to report the bugcheck if possible.
        //

        if (!KdpDebuggerDataListHead.Flink)
        {
#ifdef _IA64_
            KdDebuggerDataBlock.MmVirtualTranslationBase =
                KeGetPcr()->PteUbase;
#endif
            
            InitializeListHead(&KdpDebuggerDataListHead);

            KdRegisterDebuggerDataBlock(KDBG_TAG,
                                        &KdDebuggerDataBlock.Header,
                                        sizeof(KdDebuggerDataBlock));

            KdVersionBlock.MinorVersion = (short)NtBuildNumber;
            KdVersionBlock.MajorVersion = (short)((NtBuildNumber >> 28) & 0xFFFFFFF);

            KdVersionBlock.MaxStateChange =
                (UCHAR)(DbgKdMaximumStateChange - DbgKdMinimumStateChange);
            KdVersionBlock.MaxManipulate =
                (UCHAR)(DbgKdMaximumManipulate - DbgKdMinimumManipulate);

            KdVersionBlock.PsLoadedModuleList =
                (ULONG64)(LONG64)(LONG_PTR)&PsLoadedModuleList;
            KdVersionBlock.DebuggerDataList =
                (ULONG64)(LONG64)(LONG_PTR)&KdpDebuggerDataListHead;

#if !defined(NT_UP)
            KdVersionBlock.Flags |= DBGKD_VERS_FLAG_MP;
#endif

#if defined(_AMD64_) || defined(_X86_)

            //
            // Enable this for all platforms when VersionBlock is added
            // to all the KPCR definitions.
            //

            KeGetPcr()->KdVersionBlock = &KdVersionBlock;
#endif
        }

        if (LoaderBlock != NULL) {

            // If the debugger is being initialized during boot, PsNtosImageBase
            // and PsLoadedModuleList are not yet valid.  KdInitSystem got
            // the image base from the loader block.
            // On the other hand, if the debugger was initialized by a bugcheck,
            // it didn't get a loader block to look at, but the system was
            // running so the other variables are valid.
            //

            KdVersionBlock.KernBase = (ULONG64)(LONG64)(LONG_PTR)
                                      CONTAINING_RECORD(
                                          (LoaderBlock->LoadOrderListHead.Flink),
                                          KLDR_DATA_TABLE_ENTRY,
                                          InLoadOrderLinks)->DllBase;

            //
            // Fill in and register the debugger's debugger data blocks.
            // Most fields are already initialized, some fields will not be
            // filled in until later.
            //

            if (LoaderBlock->LoadOptions != NULL) {
                Options = LoaderBlock->LoadOptions;
                _strupr(Options);

                //
                // If any of the port option, baud option, or debug is
                // specified, then enable the debugger unless it is explictly
                // disabled.
                //

                Initialize = TRUE;
                if (strstr(Options, "DEBUG") == NULL) {
                    Initialize = FALSE;
                }

                //
                // If the debugger is explicitly disabled, then set to NODEBUG.
                //

                if (strstr(Options, "NODEBUG")) {
                    Initialize = FALSE;
                    KdPitchDebugger = TRUE;
                }

                if (strstr(Options, "CRASHDEBUG")) {
                    Initialize = FALSE;
                    KdPitchDebugger = FALSE;
                }

            } else {

                //
                // If the load options are not specified, then set to NODEBUG.
                //

                KdPitchDebugger = TRUE;
                Initialize = FALSE;
            }

        } else {
            KdVersionBlock.KernBase = (ULONG64)(LONG64)(LONG_PTR)PsNtosImageBase;
            Initialize = TRUE;
        }

        KdDebuggerDataBlock.KernBase = (ULONG_PTR) KdVersionBlock.KernBase;

        if (Initialize == FALSE) {
            return(TRUE);
        }

        if (!NT_SUCCESS(KdDebuggerInitialize0(LoaderBlock))) {
            return TRUE;
        }

        //
        // Set address of kernel debugger trap routine.
        //

        KiDebugRoutine = KdpTrap;

        if (!KdpDebuggerStructuresInitialized) {

            KdpContext.KdpControlCPending = FALSE;

            // Retries are set to this after boot
            KdpContext.KdpDefaultRetries = MAXIMUM_RETRIES;

            KiDebugSwitchRoutine = KdpSwitchProcessor;

#if !defined(_TRUSTED_WINDOWS_)
            //
            // Initialize TimeSlip
            //
            KeInitializeDpc(&KdpTimeSlipDpc, KdpTimeSlipDpcRoutine, NULL);
            KeInitializeTimer(&KdpTimeSlipTimer);
            ExInitializeWorkItem(&KdpTimeSlipWorkItem, KdpTimeSlipWork, NULL);
#endif

            KdpDebuggerStructuresInitialized = TRUE ;
        }

        KdTimerStart.HighPart = 0L;
        KdTimerStart.LowPart = 0L;

        //
        // Mark debugger enabled.
        //

        KdPitchDebugger = FALSE;
        KdDebuggerEnabled = TRUE;
        SharedUserData->KdDebuggerEnabled = 0x00000001;

        //
        // If the loader block address is specified, then scan the loaded
        // module list and load the image symbols via the kernel debugger
        // for the system and the HAL. If the host debugger has been started
        // with the -d option a break into the kernel debugger will occur at
        // this point.
        //

        if (LoaderBlock != NULL) {
            Index = 0;
            NextEntry = LoaderBlock->LoadOrderListHead.Flink;
            while ((NextEntry != &LoaderBlock->LoadOrderListHead) &&
                   (Index < 2)) {

                CHAR Buffer[256];
                ULONG Count;
                PKLDR_DATA_TABLE_ENTRY DataTableEntry;
                WCHAR *Filename;
                ULONG Length;
                STRING NameString;

                //
                // Get the address of the data table entry for the next component.
                //

                DataTableEntry = CONTAINING_RECORD(NextEntry,
                                                   KLDR_DATA_TABLE_ENTRY,
                                                   InLoadOrderLinks);

                //
                // Load the symbols for the next component.
                //

                Filename = DataTableEntry->FullDllName.Buffer;
                Length = DataTableEntry->FullDllName.Length / sizeof(WCHAR);
                Count = 0;
                do {
                    Buffer[Count++] = (CHAR)*Filename++;
                } while (Count < Length);

                Buffer[Count] = 0;
                RtlInitString(&NameString, Buffer);
                DbgLoadImageSymbols(&NameString,
                                    DataTableEntry->DllBase,
                                    (ULONG)-1);

                NextEntry = NextEntry->Flink;
                Index += 1;
            }
        }

        //
        // If -b was specified when the host debugger was started, then set up
        // to break after symbols are loaded for the kernel, hal, and drivers
        // that were loaded by the loader.
        //

        if (LoaderBlock != NULL) {
            KdBreakAfterSymbolLoad = KdPollBreakIn();
        }

    } else {

        //
        //  Initialize timer facility - HACKHACK
        //

        KeQueryPerformanceCounter(&KdPerformanceCounterRate);
    }

    return TRUE;
}


BOOLEAN
KdRegisterDebuggerDataBlock(
    IN ULONG Tag,
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader,
    IN ULONG Size
    )
/*++

Routine Description:

    This routine is called by a component or driver to register a
    debugger data block.  The data block is made accessible to the
    kernel debugger, thus providing a reliable method of exposing
    random data to debugger extensions.

Arguments:

    Tag - Supplies a unique 4 byte tag which is used to identify the
            data block.

    DataHeader - Supplies the address of the debugger data block header.
            The OwnerTag field must contain a unique value, and the Size
            field must contain the size of the data block, including the
            header.  If this block is already present, or there is
            already a block with the same value for OwnerTag, this one
            will not be inserted.  If Size is incorrect, this code will
            not notice, but the usermode side of the debugger might not
            function correctly.

    Size - Supplies the size of the data block, including the header.

Return Value:

    TRUE if the block was added to the list, FALSE if not.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY List;
    PDBGKD_DEBUG_DATA_HEADER64 Header;

    KeAcquireSpinLock(&KdpDataSpinLock, &OldIrql);

    //
    // Look for a record with the same tag or address
    //

    List = KdpDebuggerDataListHead.Flink;

    while (List != &KdpDebuggerDataListHead) {

        Header = CONTAINING_RECORD(List, DBGKD_DEBUG_DATA_HEADER64, List);

        List = List->Flink;

        if ((Header == DataHeader) || (Header->OwnerTag == Tag)) {
            KeReleaseSpinLock(&KdpDataSpinLock, OldIrql);
            return FALSE;
        }
    }

    //
    // It wasn't already there, so add it.
    //

    DataHeader->OwnerTag = Tag;
    DataHeader->Size = Size;

    InsertTailList(&KdpDebuggerDataListHead, (PLIST_ENTRY)(&DataHeader->List));

    KeReleaseSpinLock(&KdpDataSpinLock, OldIrql);

    return TRUE;
}


VOID
KdDeregisterDebuggerDataBlock(
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader
    )
/*++

Routine Description:

    This routine is called to deregister a data block previously
    registered with KdRegisterDebuggerDataBlock.  If the block is
    found in the list, it is removed.

Arguments:

    DataHeader - Supplies the address of the data block which is
                to be removed from the list.

Return Value:

    None

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY List;
    PDBGKD_DEBUG_DATA_HEADER64 Header;

    KeAcquireSpinLock(&KdpDataSpinLock, &OldIrql);

    //
    // Make sure the data block is on our list before removing it.
    //

    List = KdpDebuggerDataListHead.Flink;

    while (List != &KdpDebuggerDataListHead) {

        Header = CONTAINING_RECORD(List, DBGKD_DEBUG_DATA_HEADER64, List);
        List = List->Flink;

        if (DataHeader == Header) {
            RemoveEntryList((PLIST_ENTRY)(&DataHeader->List));
            break;
        }
    }

    KeReleaseSpinLock(&KdpDataSpinLock, OldIrql);
}


VOID
KdLogDbgPrint(
    IN PSTRING String
    )
{
    KIRQL OldIrql;
    ULONG Length;
    ULONG LengthCopied;

    for (; ;) {
        if (KeTestSpinLock (&KdpPrintSpinLock)) {
            KeRaiseIrql (HIGH_LEVEL, &OldIrql);
            if (KeTryToAcquireSpinLockAtDpcLevel(&KdpPrintSpinLock)) {
                break;          // got the lock
            }
            KeLowerIrql(OldIrql);
        }
    }

    if (KdPrintCircularBuffer) {
        Length = String->Length;
        //
        // truncate ridiculous strings
        //
        if (Length > KdPrintBufferSize) {
            Length = KdPrintBufferSize;
        }

        if (KdPrintWritePointer + Length <= KdPrintCircularBuffer + KdPrintBufferSize) {
            KdpCopyFromPtr(KdPrintWritePointer, String->Buffer, Length, &LengthCopied);
            KdPrintWritePointer += LengthCopied;
            if (KdPrintWritePointer >= KdPrintCircularBuffer + KdPrintBufferSize) {
                KdPrintWritePointer = KdPrintCircularBuffer;
                KdPrintRolloverCount++;
            }
        } else {
            ULONG First = (ULONG)(KdPrintCircularBuffer + KdPrintBufferSize - KdPrintWritePointer);
            KdpCopyFromPtr(KdPrintWritePointer,
                           String->Buffer,
                           First,
                           &LengthCopied);
            if (LengthCopied == First) {
                KdpCopyFromPtr(KdPrintCircularBuffer,
                               String->Buffer + First,
                               Length - First,
                               &LengthCopied);
                LengthCopied += First;
            }
            if (LengthCopied > First) {
                KdPrintWritePointer = KdPrintCircularBuffer + LengthCopied - First;
                KdPrintRolloverCount++;
            } else {
                KdPrintWritePointer += LengthCopied;
                if (KdPrintWritePointer >= KdPrintCircularBuffer + KdPrintBufferSize) {
                    KdPrintWritePointer = KdPrintCircularBuffer;
                    KdPrintRolloverCount++;
                }
            }
        }
    }

    KiReleaseSpinLock(&KdpPrintSpinLock);
    KeLowerIrql(OldIrql);
}


NTSTATUS
KdSetDbgPrintBufferSize(
    IN ULONG Size
    )
{
    KIRQL OldIrql;
    PUCHAR OldBuffer;
    PUCHAR NewBuffer;

    // If kd isn't active just fail.
    if (KdPitchDebugger) {
        return STATUS_ACCESS_DENIED;
    }
    
    //
    // First attempt to allocate the new buffer.  If the given
    // buffer size fits in the default buffer, use it.
    //
    // We don't attempt to detect if we can reuse an existing
    // allocated buffer to avoid having to take the lock to
    // keep such a pointer valid while checking.  This operation
    // should be infrequent so such an optimization is unnecessary.
    //

    // Disallow excessively large requests.  16MB is the current limit.
    if (Size >= 0x1000000) {
        return STATUS_INVALID_PARAMETER_1;
    }
    
    if (Size > KDPRINTDEFAULTBUFFERSIZE) {
        NewBuffer = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool, Size, 'bPdK');
        if (!NewBuffer) {
            return STATUS_NO_MEMORY;
        }

    } else {
        // Size == 0 means just set the default.
        if (!Size) {
            Size = KDPRINTDEFAULTBUFFERSIZE;

        }
        NewBuffer = KdPrintDefaultCircularBuffer;
    }

    //
    // Now take the lock and swap in the new buffer.
    //
    
    for (; ;) {
        if (KeTestSpinLock (&KdpPrintSpinLock)) {
            KeRaiseIrql (HIGH_LEVEL, &OldIrql);
            if (KeTryToAcquireSpinLockAtDpcLevel(&KdpPrintSpinLock)) {
                break;          // got the lock
            }
            KeLowerIrql(OldIrql);
        }
    }

    // Buffer must be zeroed as the write pointer is
    // being reset.  This has to be done inside the lock
    // to avoid races when the new buffer is the same
    // as the old.
    RtlZeroMemory(NewBuffer, Size);
    
    OldBuffer = KdPrintCircularBuffer;
    KdPrintCircularBuffer = NewBuffer;
    KdPrintBufferSize = Size;
    KdPrintWritePointer = NewBuffer;
    KdPrintRolloverCount = 0;
    KdPrintBufferChanges++;
    
    KiReleaseSpinLock(&KdpPrintSpinLock);
    KeLowerIrql(OldIrql);

    //
    // Free any old buffer that was replaced.
    //
    
    if (OldBuffer && OldBuffer != KdPrintDefaultCircularBuffer) {
        ExFreePool(OldBuffer);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\kdbreak.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdbreak.c

Abstract:

    This module implements machine dependent functions to add and delete
    breakpoints from the kernel debugger breakpoint table.

Author:

    David N. Cutler 2-Aug-1990

Revision History:

--*/

#include "kdp.h"

//
// Define external references.
//

VOID
KdSetOwedBreakpoints(
    VOID
    );

BOOLEAN
KdpLowWriteContent(
    ULONG Index
    );

BOOLEAN
KdpLowRestoreBreakpoint(
    ULONG Index
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpAddBreakpoint)
#pragma alloc_text(PAGEKD, KdpDeleteBreakpoint)
#pragma alloc_text(PAGEKD, KdpDeleteBreakpointRange)
#pragma alloc_text(PAGEKD, KdpSuspendBreakpoint)
#pragma alloc_text(PAGEKD, KdpSuspendAllBreakpoints)
#pragma alloc_text(PAGEKD, KdpRestoreAllBreakpoints)
#pragma alloc_text(PAGEKD, KdpLowWriteContent)
#pragma alloc_text(PAGEKD, KdpLowRestoreBreakpoint)
#if defined(_IA64_)
#pragma alloc_text(PAGEKD, KdpSuspendBreakpointRange)
#pragma alloc_text(PAGEKD, KdpRestoreBreakpointRange)
#endif
#endif

#if 0
#define BPVPRINT(Args) DPRINT(Args)
#else
#define BPVPRINT(Args)
#endif


ULONG
KdpAddBreakpoint (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine adds an entry to the breakpoint table and returns a handle
    to the breakpoint table entry.

Arguments:

    Address - Supplies the address where to set the breakpoint.

Return Value:

    A value of zero is returned if the specified address is already in the
    breakpoint table, there are no free entries in the breakpoint table, the
    specified address is not correctly aligned, or the specified address is
    not valid. Otherwise, the index of the assigned breakpoint table entry
    plus one is returned as the function value.

--*/

{

    KDP_BREAKPOINT_TYPE Content;
    ULONG Index;
    LOGICAL Accessible;

    BPVPRINT(("KD: Setting breakpoint at 0x%p\n", Address));

    //
    // If the specified address is not properly aligned, then return zero.
    //

    if (((ULONG_PTR)Address & KDP_BREAKPOINT_ALIGN) != 0) {
        return 0;
    }


    //
    // Don't allow setting the same breakpoint twice.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) != 0 &&
            KdpBreakpointTable[Index].Address == Address) {

            if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) != 0) {

                //
                // Breakpoint was set, the page was written out and was not
                // accessible when the breakpoint was cleared.  Now the breakpoint
                // is being set again.  Just clear the defer flag:
                //
                KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_REPLACE;
                return Index + 1;

            } else {

                DPRINT(("KD: Attempt to set breakpoint %08x twice!\n", Address));
                return 0;

            }
        }
    }

    //
    // Search the breakpoint table for a free entry.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if (KdpBreakpointTable[Index].Flags == 0) {
            break;
        }
    }

    //
    // If a free entry was found, then write breakpoint and return the handle
    // value plus one. Otherwise, return zero.
    //

    if (Index == BREAKPOINT_TABLE_SIZE) {
        DPRINT(("KD: ran out of breakpoints!\n"));
        return 0;
    }


    BPVPRINT(("KD: using Index %d\n", Index));

    //
    // Get the instruction to be replaced. If the instruction cannot be read,
    // then mark breakpoint as not accessible.
    //

    Accessible = NT_SUCCESS(KdpCopyFromPtr(&Content,
                                           Address,
                                           sizeof(KDP_BREAKPOINT_TYPE),
                                           NULL));
    BPVPRINT(("KD: memory %saccessible\n", Accessible ? "" : "in"));

#if defined(_IA64_)
    if ( Accessible ) {
        KDP_BREAKPOINT_TYPE mBuf;
        PVOID BundleAddress;

        // change template to type 0 if current instruction is MLI

        // read in intruction template if current instruction is NOT slot 0.
        // check for two-slot MOVL instruction. Reject request if attempt to
        // set break in slot 2 of MLI template.

        if (((ULONG_PTR)Address & 0xf) != 0) {
            BundleAddress = (PVOID)((ULONG_PTR)Address & ~(0xf));
            if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                           BundleAddress,
                                           sizeof(KDP_BREAKPOINT_TYPE),
                                           NULL))) {
                BPVPRINT(("KD: read 0x%p template failed\n", BundleAddress));
                return 0;
            } else {
                if (((mBuf & INST_TEMPL_MASK) >> 1) == 0x2) {
                    if (((ULONG_PTR)Address & 0xf) == 4) {
                        // if template= type 2 MLI, change to type 0
                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1);
                        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IA64_MOVL;
                        if (!NT_SUCCESS(KdpCopyToPtr(BundleAddress,
                                                     &mBuf,
                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                     NULL))) {
                            BPVPRINT(("KD: write to 0x%p template failed\n", BundleAddress));
                            return 0;
                         }
                         else {
                             BPVPRINT(("KD: change MLI template to type 0 at 0x%p set\n", Address));
                         }
                    } else {
                         // set breakpoint at slot 2 of MOVL is illegal
                         BPVPRINT(("KD: illegal to set BP at slot 2 of MOVL at 0x%p\n", BundleAddress));
                         return 0;
                    }
                }
            }
        }

        // insert break instruction

        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Content = Content;
        KdpBreakpointTable[Index].Flags &= ~(KD_BREAKPOINT_STATE_MASK);
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IN_USE;
        if (Address < (PVOID)GLOBAL_BREAKPOINT_LIMIT) {
            KdpBreakpointTable[Index].DirectoryTableBase =
                KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0];
            }
            switch ((ULONG_PTR)Address & 0xf) {
            case 0:
                Content = (Content & ~(INST_SLOT0_MASK)) | (KdpBreakpointInstruction << 5);
                break;

            case 4:
                Content = (Content & ~(INST_SLOT1_MASK)) | (KdpBreakpointInstruction << 14);
                break;

            case 8:
                Content = (Content & ~(INST_SLOT2_MASK)) | (KdpBreakpointInstruction << 23);
                break;

            default:
                BPVPRINT(("KD: KdpAddBreakpoint bad instruction slot#\n"));
                return 0;
            }
            if (!NT_SUCCESS(KdpCopyToPtr(Address,
                                         &Content,
                                         sizeof(KDP_BREAKPOINT_TYPE),
                                         NULL))) {

                BPVPRINT(("KD: Unable to write BP!\n"));
                return 0;
            }
            else {
                BPVPRINT(("KD: breakpoint at 0x%p set\n", Address));
            }

    } else {  // memory not accessible
        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Flags &= ~(KD_BREAKPOINT_STATE_MASK);
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IN_USE;
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        BPVPRINT(("KD: breakpoint write deferred\n"));
        if (Address < (PVOID)GLOBAL_BREAKPOINT_LIMIT) {
            KdpBreakpointTable[Index].DirectoryTableBase =
                KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0];
        }
    }
#else
    if ( Accessible ) {
        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Content = Content;
        KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE;
        if (Address < (PVOID)GLOBAL_BREAKPOINT_LIMIT) {
            KdpBreakpointTable[Index].DirectoryTableBase =
                KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0];
        }
        if (!NT_SUCCESS(KdpCopyToPtr(Address,
                                     &KdpBreakpointInstruction,
                                     sizeof(KDP_BREAKPOINT_TYPE),
                                     NULL))) {

            DPRINT(("KD: Unable to write BP!\n"));
        }
    } else {
        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE | KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        BPVPRINT(("KD: breakpoint write deferred\n"));
        if (Address < (PVOID)GLOBAL_BREAKPOINT_LIMIT) {
            KdpBreakpointTable[Index].DirectoryTableBase =
                KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0];
        }
    }
#endif  // IA64

    return Index + 1;

}



VOID
KdSetOwedBreakpoints(
    VOID
    )

/*++

Routine Description:

    This function is called after returning from memory management calls
    that may cause an inpage.  Its purpose is to store pending
    breakpoints in pages just made valid.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KDP_BREAKPOINT_TYPE Content;
    BOOLEAN Enable;
    LONG Index;

    //
    // If we don't owe any breakpoints then return
    //

    if ( !KdpOweBreakpoint ) {
        return;
    }


    //
    // Freeze all other processors, disable interrupts, and save debug
    // port state.
    //

    Enable = KdEnterDebugger(NULL, NULL);
    KdpOweBreakpoint = FALSE;

    //
    // Search the breakpoint table for breakpoints that need to be
    // written or replaced.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if (KdpBreakpointTable[Index].Flags &
                (KD_BREAKPOINT_NEEDS_WRITE | KD_BREAKPOINT_NEEDS_REPLACE) ) {

            //
            // Breakpoint needs to be written
            //
            //BPVPRINT(("KD: Breakpoint %d at 0x%p: trying to %s after page in.\n",
            //          Index,
            //          KdpBreakpointTable[Index].Address,
            //          (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) ?
            //          "set" : "clear"));

            if ((KdpBreakpointTable[Index].Address >= (PVOID)GLOBAL_BREAKPOINT_LIMIT) ||
                (KdpBreakpointTable[Index].DirectoryTableBase ==
                 KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0])) {

                //
                // Breakpoint is global, or its directory base matches
                //

                if (!NT_SUCCESS(KdpCopyFromPtr(&Content,
                                               KdpBreakpointTable[Index].Address,
                                               sizeof(KDP_BREAKPOINT_TYPE),
                                               NULL))) {

                    //BPVPRINT(("KD: read from 0x%p failed\n", KdpBreakpointTable[Index].Address));

                    KdpOweBreakpoint = TRUE;

                } else {
                    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) {
                        KdpBreakpointTable[Index].Content = Content;
#if defined(_IA64_)
                        switch ((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) {
                        case 0:
                            Content = (Content & ~(INST_SLOT0_MASK)) | (KdpBreakpointInstruction << 5);
                            break;

                        case 4:
                            Content = (Content & ~(INST_SLOT1_MASK)) | (KdpBreakpointInstruction << 14);
                            break;

                        case 8:
                            Content = (Content & ~(INST_SLOT2_MASK)) | (KdpBreakpointInstruction << 23);
                            break;

                        default:
                            BPVPRINT(("KD: illegal instruction address 0x%p\n", KdpBreakpointTable[Index].Address));
                            break;
                        }
                        if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                                     &Content,
                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                     NULL))) {
                            KdpOweBreakpoint = TRUE;
                            BPVPRINT(("KD: write to 0x%p failed\n", KdpBreakpointTable[Index].Address));
                        }

                        // read in intruction template if current instruction is NOT slot 0.
                        // check for two-slot MOVL instruction. Reject request if attempt to
                        // set break in slot 2 of MLI template.
                        
                        else if (((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) != 0) {
                            KDP_BREAKPOINT_TYPE mBuf;
                            PVOID BundleAddress;

                            BundleAddress = (PVOID)((ULONG_PTR)KdpBreakpointTable[Index].Address  & ~(0xf));
                            if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                                           BundleAddress,
                                                           sizeof(KDP_BREAKPOINT_TYPE),
                                                           NULL))) {
                                KdpOweBreakpoint = TRUE;
                                BPVPRINT(("KD: read 0x%p template failed\n", KdpBreakpointTable[Index].Address));
                            } else {
                                if (((mBuf & INST_TEMPL_MASK) >> 1) == 0x2) {
                                    if (((ULONG_PTR)KdpBreakpointTable[Index].Address  & 0xf) == 4) {
                                        // if template= type 2 MLI, change to type 0
                                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1);
                                        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IA64_MOVL;
                                        if (!NT_SUCCESS(KdpCopyToPtr(BundleAddress,
                                                                     &mBuf,
                                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                                     NULL))) {
                                            KdpOweBreakpoint = TRUE;
                                            BPVPRINT(("KD: write to 0x%p template failed\n", KdpBreakpointTable[Index].Address));
                                        }
                                        else {
                                            KdpBreakpointTable[Index].Flags &= ~(KD_BREAKPOINT_STATE_MASK);
                                            KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IN_USE;
                                            BPVPRINT(("KD: write to 0x%p ok\n", KdpBreakpointTable[Index].Address));
                                        }
                                    } else {
                                        // set breakpoint at slot 2 of MOVL is illegal
                                        KdpOweBreakpoint = TRUE;
                                        BPVPRINT(("KD: illegal attempt to set BP at slot 2 of 0x%p\n", KdpBreakpointTable[Index].Address));
                                    }
                                }
                                else {
                                    KdpBreakpointTable[Index].Flags &= ~(KD_BREAKPOINT_STATE_MASK);
                                    KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IN_USE;
                                    BPVPRINT(("KD: write to 0x%p ok\n", KdpBreakpointTable[Index].Address));
                                }
                            }
                        } else {
                            KdpBreakpointTable[Index].Flags &= ~(KD_BREAKPOINT_STATE_MASK);
                            KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IN_USE;
                            BPVPRINT(("KD: write to 0x%p ok\n", KdpBreakpointTable[Index].Address));
                        }
#else
                        if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                                     &KdpBreakpointInstruction,
                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                     NULL))) {
                            KdpOweBreakpoint = TRUE;
                            DPRINT(("KD: write to 0x%p failed\n", KdpBreakpointTable[Index].Address));
                        } else {
                            KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE;
                            DPRINT(("KD: write to 0x%p ok\n", KdpBreakpointTable[Index].Address));
                        }
#endif
                    } else {
#if defined(_IA64_)

                        KDP_BREAKPOINT_TYPE mBuf;
                        PVOID BundleAddress;

                        // restore original instruction content

                        // Read in memory since adjancent instructions in the same bundle may have
                        // been modified after we save them.
                        if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                                       KdpBreakpointTable[Index].Address,
                                                       sizeof(KDP_BREAKPOINT_TYPE),
                                                       NULL))) {
                            KdpOweBreakpoint = TRUE;
                            BPVPRINT(("KD: read 0x%p template failed\n", KdpBreakpointTable[Index].Address));
                        }
                        else {
                            switch ((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) {
                            case 0:
                                mBuf = (mBuf & ~(INST_SLOT0_MASK))
                                             | (KdpBreakpointTable[Index].Content & INST_SLOT0_MASK);
                                break;

                            case 4:
                                mBuf = (mBuf & ~(INST_SLOT1_MASK))
                                             | (KdpBreakpointTable[Index].Content & INST_SLOT1_MASK);
                                break;

                            case 8:
                                mBuf = (mBuf & ~(INST_SLOT2_MASK))
                                             | (KdpBreakpointTable[Index].Content & INST_SLOT2_MASK);
                                break;

                            default:
                                KdpOweBreakpoint = TRUE;
                                BPVPRINT(("KD: illegal instruction address 0x%p\n", KdpBreakpointTable[Index].Address));
                            }

                            if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                                         &mBuf,
                                                         sizeof(KDP_BREAKPOINT_TYPE),
                                                         NULL))) {
                                KdpOweBreakpoint = TRUE;
                                BPVPRINT(("KD: write to 0x%p failed\n", KdpBreakpointTable[Index].Address));
                            }
                            else {
                                 // restore template to MLI if displaced instruction was MOVL

                                if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IA64_MOVL) {
                                    BundleAddress = (PVOID)((ULONG_PTR)KdpBreakpointTable[Index].Address & ~(0xf));
                                    if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                                                   BundleAddress,
                                                                   sizeof(KDP_BREAKPOINT_TYPE),
                                                                   NULL))) {
                                        KdpOweBreakpoint = TRUE;
                                        BPVPRINT(("KD: read template 0x%p failed\n", KdpBreakpointTable[Index].Address));
                                    }
                                    else {
                                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1); // set template to MLI
                                        mBuf |= 0x4;

                                        if (!NT_SUCCESS(KdpCopyToPtr(BundleAddress,
                                                                     &mBuf,
                                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                                     NULL))) {
                                            KdpOweBreakpoint = TRUE;
                                            BPVPRINT(("KD: write template to 0x%p failed\n", KdpBreakpointTable[Index].Address));
                                        } else {
                                            BPVPRINT(("KD: write to 0x%p ok\n", KdpBreakpointTable[Index].Address));
                                            if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
                                                KdpBreakpointTable[Index].Flags |= (KD_BREAKPOINT_SUSPENDED | KD_BREAKPOINT_IN_USE);
                                            } else {
                                                KdpBreakpointTable[Index].Flags = 0;
                                            }
                                        }
                                    }
                                } else {
                                    BPVPRINT(("KD: write to 0x%p ok\n", KdpBreakpointTable[Index].Address));
                                    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
                                        KdpBreakpointTable[Index].Flags |= (KD_BREAKPOINT_SUSPENDED | KD_BREAKPOINT_IN_USE);
                                    } else {
                                        KdpBreakpointTable[Index].Flags = 0;
                                    }
                                }
                            }
                        }
#else
                        if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                                     &KdpBreakpointTable[Index].Content,
                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                     NULL))) {
                            KdpOweBreakpoint = TRUE;
                            DPRINT(("KD: write to 0x%p failed\n", KdpBreakpointTable[Index].Address));
                        } else {
                            BPVPRINT(("KD: write to 0x%p ok\n", KdpBreakpointTable[Index].Address));
                            if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
                                KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_SUSPENDED | KD_BREAKPOINT_IN_USE;
                            } else {
                                KdpBreakpointTable[Index].Flags = 0;
                            }
                        }
#endif // _IA64_

                    }
                }

            } else {

                //
                // Breakpoint is local and its directory base does not match
                //

                KdpOweBreakpoint = TRUE;
            }
        }
    }

    KdExitDebugger(Enable);
    return;
}


BOOLEAN
KdpLowWriteContent (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to replace the code that a breakpoint is
    written over.  This routine, KdpAddBreakpoint,
    KdpLowRestoreBreakpoint and KdSetOwedBreakpoints are responsible
    for getting data written as requested.  Callers should not
    examine or use KdpOweBreakpoints, and they should not set the
    NEEDS_WRITE or NEEDS_REPLACE flags.

    Callers must still look at the return value from this function,
    however: if it returns FALSE, the breakpoint record must not be
    reused until KdSetOwedBreakpoints has finished with it.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be deleted.

Return Value:

    Returns TRUE if the breakpoint was removed, FALSE if it was deferred.

--*/

{
#if defined(_IA64_)
    KDP_BREAKPOINT_TYPE mBuf;
    PVOID BundleAddress;
#endif

    //
    // Do the contents need to be replaced at all?
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) {

        //
        // The breakpoint was never written out.  Clear the flag
        // and we are done.
        //

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_WRITE;
        BPVPRINT(("KD: Breakpoint at 0x%p never written; flag cleared.\n",
                  KdpBreakpointTable[Index].Address));
        return TRUE;
    }

#if !defined(_IA64_)
    if (KdpBreakpointTable[Index].Content == KdpBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        BPVPRINT(("KD: Breakpoint at 0x%p; instr is really BP; flag cleared.\n",
                  KdpBreakpointTable[Index].Address));

        return TRUE;
    }
#endif


    //
    // Restore the instruction contents.
    //

#if defined(_IA64_)
    // Read in memory since adjancent instructions in the same bundle may have
    // been modified after we save them.
    if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                   KdpBreakpointTable[Index].Address,
                                   sizeof(KDP_BREAKPOINT_TYPE),
                                   NULL))) {
        KdpOweBreakpoint = TRUE;
        BPVPRINT(("KD: read 0x%p failed\n", KdpBreakpointTable[Index].Address));
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
        return FALSE;
    }
    else {

        switch ((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) {
        case 0:
            mBuf = (mBuf & ~(INST_SLOT0_MASK))
                         | (KdpBreakpointTable[Index].Content & INST_SLOT0_MASK);
            break;

        case 4:
            mBuf = (mBuf & ~(INST_SLOT1_MASK))
                         | (KdpBreakpointTable[Index].Content & INST_SLOT1_MASK);
            break;

        case 8:
            mBuf = (mBuf & ~(INST_SLOT2_MASK))
                         | (KdpBreakpointTable[Index].Content & INST_SLOT2_MASK);
            break;

        default:
            KdpOweBreakpoint = TRUE;
            BPVPRINT(("KD: illegal instruction address 0x%p\n", KdpBreakpointTable[Index].Address));
            return FALSE;
        }

        if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                     &mBuf,
                                     sizeof(KDP_BREAKPOINT_TYPE),
                                     NULL))) {
            KdpOweBreakpoint = TRUE;
            BPVPRINT(("KD: write to 0x%p failed\n", KdpBreakpointTable[Index].Address));
            KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
            return FALSE;
        }
        else {

            if (NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                          KdpBreakpointTable[Index].Address,
                                          sizeof(KDP_BREAKPOINT_TYPE),
                                          NULL))) {
                BPVPRINT(("\tcontent after memory move = 0x%08x 0x%08x\n", (ULONG)(mBuf >> 32), (ULONG)mBuf));
            }

            // restore template to MLI if displaced instruction was MOVL

            if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IA64_MOVL) {
                BundleAddress = (PVOID)((ULONG_PTR)KdpBreakpointTable[Index].Address & ~(0xf));
                if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                               BundleAddress,
                                               sizeof(KDP_BREAKPOINT_TYPE),
                                               NULL))) {
                    KdpOweBreakpoint = TRUE;
                    BPVPRINT(("KD: read template 0x%p failed\n", KdpBreakpointTable[Index].Address));
                    KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
                    return FALSE;
                }
                else {
                    mBuf &= ~((INST_TEMPL_MASK >> 1) << 1); // set template to MLI
                    mBuf |= 0x4;

                    if (!NT_SUCCESS(KdpCopyToPtr(BundleAddress,
                                                 &mBuf,
                                                 sizeof(KDP_BREAKPOINT_TYPE),
                                                 NULL))) {
                        KdpOweBreakpoint = TRUE;
                        BPVPRINT(("KD: write template to 0x%p failed\n", KdpBreakpointTable[Index].Address));
                        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
                        return FALSE;
                    } else {
                        BPVPRINT(("KD: Breakpoint at 0x%p cleared.\n",
                                  KdpBreakpointTable[Index].Address));
                        return TRUE;
                    }
                }
            }
            else {   // not MOVL
                BPVPRINT(("KD: Breakpoint at 0x%p cleared.\n",
                          KdpBreakpointTable[Index].Address));
                return TRUE;
            }
        }
    }
#else
    if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                 &KdpBreakpointTable[Index].Content,
                                 sizeof(KDP_BREAKPOINT_TYPE),
                                 NULL))) {

        KdpOweBreakpoint = TRUE;
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
        BPVPRINT(("KD: Breakpoint at 0x%p; unable to clear, flag set.\n",
                  KdpBreakpointTable[Index].Address));
        return FALSE;
    } else {
        BPVPRINT(("KD: Breakpoint at 0x%p cleared.\n",
                  KdpBreakpointTable[Index].Address));
        return TRUE;
    }
#endif

}



BOOLEAN
KdpDeleteBreakpoint (
    IN ULONG Handle
    )

/*++

Routine Description:

    This routine deletes an entry from the breakpoint table.

Arguments:

    Handle - Supplies the index plus one of the breakpoint table entry
        which is to be deleted.

Return Value:

    A value of FALSE is returned if the specified handle is not a valid
    value or the breakpoint cannot be deleted because the old instruction
    cannot be replaced. Otherwise, a value of TRUE is returned.

--*/

{
    ULONG Index = Handle - 1;

    //
    // If the specified handle is not valid, then return FALSE.
    //

    if ((Handle == 0) || (Handle > BREAKPOINT_TABLE_SIZE)) {
        DPRINT(("KD: Breakpoint %d invalid.\n", Index));
        return FALSE;
    }

    //
    // If the specified breakpoint table entry is not valid, then return FALSE.
    //

    if (KdpBreakpointTable[Index].Flags == 0) {
        BPVPRINT(("KD: Breakpoint %d already clear.\n", Index));
        return FALSE;
    }

    //
    // If the breakpoint is already suspended, just delete it from the table.
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
        BPVPRINT(("KD: Deleting suspended breakpoint %d \n", Index));
        if ( !(KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) ) {
            BPVPRINT(("KD: already clear.\n"));
            KdpBreakpointTable[Index].Flags = 0;
            return TRUE;
        }
    }

    //
    // Replace the instruction contents.
    //

    if (KdpLowWriteContent(Index)) {

        //
        // Delete breakpoint table entry
        //

        BPVPRINT(("KD: Breakpoint %d deleted successfully.\n", Index));
        KdpBreakpointTable[Index].Flags = 0;
    }

    return TRUE;
}


BOOLEAN
KdpDeleteBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine deletes all breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to remove BPs.

    Upper - include upper address of range from which to remove BPs.

Return Value:

    TRUE if any breakpoints removed, FALSE otherwise.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //
    // Examine each entry in the table in turn
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++)
    {
        if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
             ((KdpBreakpointTable[Index].Address >= Lower) &&
              (KdpBreakpointTable[Index].Address <= Upper)) )
        {

            //
            // Breakpoint is in use and falls in range, clear it.
            //

            if (KdpDeleteBreakpoint(Index+1))
            {
                ReturnStatus = TRUE;
            }
        }
    }

    return ReturnStatus;

}

VOID
KdpSuspendBreakpoint (
    ULONG Handle
    )
{
    ULONG Index = Handle - 1;

    if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
        !(KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) ) {

        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_SUSPENDED;
        KdpLowWriteContent(Index);
    }

    return;

} // KdpSuspendBreakpoint

VOID
KdpSuspendAllBreakpoints (
    VOID
    )
{
    ULONG Handle;

    BreakpointsSuspended = TRUE;

    for ( Handle = 1; Handle <= BREAKPOINT_TABLE_SIZE; Handle++ ) {
        KdpSuspendBreakpoint(Handle);
    }

    return;

} // KdpSuspendAllBreakpoints

#if defined(_IA64_)


BOOLEAN
KdpSuspendBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine suspend all breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to suspend BPs.

    Upper - include upper address of range from which to suspend BPs.

Return Value:

    TRUE if any breakpoints suspended, FALSE otherwise.

Notes:
    The order of suspending breakpoints is opposite that of setting
    them in KdpAddBreakpoint() in case of duplicate addresses.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    BPVPRINT(("\nKD: entering KdpSuspendBreakpointRange() at 0x%p 0x%p\n", Lower, Upper));

    //
    // Examine each entry in the table in turn
    //

    for (Index = BREAKPOINT_TABLE_SIZE - 1; Index != -1; Index--) {

        if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
             ((KdpBreakpointTable[Index].Address >= Lower) &&
              (KdpBreakpointTable[Index].Address <= Upper))
           ) {

            //
            // Breakpoint is in use and falls in range, suspend it.
            //

            KdpSuspendBreakpoint(Index+1);
            ReturnStatus = TRUE;
        }
    }
    BPVPRINT(("KD: exiting KdpSuspendBreakpointRange() return 0x%d\n", ReturnStatus));

    return ReturnStatus;

} // KdpSuspendBreakpointRange



BOOLEAN
KdpRestoreBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine writes back breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to rewrite BPs.

    Upper - include upper address of range from which to rewrite BPs.

Return Value:

    TRUE if any breakpoints written, FALSE otherwise.

Notes:
    The order of writing breakpoints is opposite that of removing
    them in KdpSuspendBreakpointRange() in case of duplicate addresses.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    BPVPRINT(("\nKD: entering KdpRestoreBreakpointRange() at 0x%p 0x%p\n", Lower, Upper));

    //
    // Examine each entry in the table in turn
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++) {

        if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
             ((KdpBreakpointTable[Index].Address >= Lower) &&
              (KdpBreakpointTable[Index].Address <= Upper))
           ) {

            //
            // suspended breakpoint that falls in range, unsuspend it.
            //

            if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {

                KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_SUSPENDED;
                ReturnStatus = ReturnStatus || KdpLowRestoreBreakpoint(Index);
            }
        }
    }

    BPVPRINT(("KD: exiting KdpRestoreBreakpointRange() return 0x%d\n", ReturnStatus));

    return ReturnStatus;

} // KdpRestoreBreakpointRange

#endif // _IA64_


BOOLEAN
KdpLowRestoreBreakpoint (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to write a breakpoint instruction.
    The old contents must have already been stored in the
    breakpoint record.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be written.

Return Value:

    Returns TRUE if the breakpoint was written, FALSE if it was
    not and has been marked for writing later.

--*/

{
#if defined(_IA64_)
    KDP_BREAKPOINT_TYPE mBuf;
    PVOID BundleAddress;
#endif
    //
    // Does the breakpoint need to be written at all?
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) {

        //
        // The breakpoint was never removed.  Clear the flag
        // and we are done.
        //

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_REPLACE;
        return TRUE;
    }

    //
    // Replace the instruction contents.
    //

#if !defined(_IA64_)
    if (KdpBreakpointTable[Index].Content == KdpBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        return TRUE;
    }
#endif

    //
    // Replace the instruction contents.
    //

#if defined(_IA64_)

    // read in intruction in case the adjacent instruction has been modified.

    if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                   KdpBreakpointTable[Index].Address,
                                   sizeof(KDP_BREAKPOINT_TYPE),
                                   NULL))) {
        BPVPRINT(("KD: read 0x%p template failed\n", KdpBreakpointTable[Index].Address));
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        return FALSE;
    }

    switch ((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) {
        case 0:
            mBuf = (mBuf & ~(INST_SLOT0_MASK)) | (KdpBreakpointInstruction << 5);
            break;

        case 4:
            mBuf = (mBuf & ~(INST_SLOT1_MASK)) | (KdpBreakpointInstruction << 14);
            break;

        case 8:
            mBuf = (mBuf & ~(INST_SLOT2_MASK)) | (KdpBreakpointInstruction << 23);
            break;

        default:
            BPVPRINT(("KD: KdpAddBreakpoint bad instruction slot#\n"));
            return FALSE;
    }
    if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                 &mBuf,
                                 sizeof(KDP_BREAKPOINT_TYPE),
                                 NULL))) {

        BPVPRINT(("KD: Unable to write BP!\n"));
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        return FALSE;
    }
    else {

        // check for two-slot MOVL instruction. Reject request if attempt to
        // set break in slot 2 of MLI template.
        // change template to type 0 if current instruction is MLI

        if (((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) != 0) {
            BundleAddress = (PVOID)((ULONG_PTR)KdpBreakpointTable[Index].Address & ~(0xf));
            if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                           BundleAddress,
                                           sizeof(KDP_BREAKPOINT_TYPE),
                                           NULL))) {
                BPVPRINT(("KD: read template failed at 0x%p\n", BundleAddress));
                KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
                KdpOweBreakpoint = TRUE;
                return FALSE;
            }
            else {
                if (((mBuf & INST_TEMPL_MASK) >> 1) == 0x2) {
                    if (((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) == 4) {
                        // if template= type 2 MLI, change to type 0
                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1);
                        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IA64_MOVL;
                        if (!NT_SUCCESS(KdpCopyToPtr(BundleAddress,
                                                     &mBuf,
                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                     NULL))) {
                            BPVPRINT(("KD: write to 0x%p template failed\n", BundleAddress));
                            KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
                            KdpOweBreakpoint = TRUE;
                            return FALSE;
                        }
                        else {
                             BPVPRINT(("KD: change MLI template to type 0 at 0x%p set\n", BundleAddress));
                        }
                    } else {
                         // set breakpoint at slot 2 of MOVL is illegal
                         BPVPRINT(("KD: illegal to set BP at slot 2 of MOVL at 0x%p\n", BundleAddress));
                         KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
                         KdpOweBreakpoint = TRUE;
                         return FALSE;
                    }
                }
            }
        }
        BPVPRINT(("KD: breakpoint at 0x%p set\n", KdpBreakpointTable[Index].Address));
        return TRUE;
    }

#else
    if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                 &KdpBreakpointInstruction,
                                 sizeof(KDP_BREAKPOINT_TYPE),
                                 NULL))) {

        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        BPVPRINT(("KD: owe breakpoint at 0x%p\n", KdpBreakpointTable[Index].Address));
        return FALSE;

    } else {

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_WRITE;
        BPVPRINT(("KD: breakpoint at 0x%p set\n", KdpBreakpointTable[Index].Address));
        return TRUE;
    }
#endif

}


VOID
KdpRestoreAllBreakpoints (
    VOID
    )
{
    ULONG Index;

    BreakpointsSuspended = FALSE;

    for ( Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++ ) {

        if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
            (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) ) {

            KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_SUSPENDED;
            KdpLowRestoreBreakpoint(Index);
        }
    }

    return;

} // KdpRestoreAllBreakpoints

VOID
KdDeleteAllBreakpoints(
    VOID
    )
{
    ULONG Handle;

    if (KdDebuggerEnabled == FALSE || KdPitchDebugger != FALSE) {
        return;
    }

    BreakpointsSuspended = FALSE;

    for ( Handle = 1; Handle <= BREAKPOINT_TABLE_SIZE; Handle++ ) {
        KdpDeleteBreakpoint(Handle);
    }

    return;
} // KdDeleteAllBreakpoints
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\kdapi.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdapi.c

Abstract:

    Implementation of Kernel Debugger portable remote APIs.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

    John Vert (jvert) 28-May-1991

        Added APIs for reading and writing physical memory
        (KdpReadPhysicalMemory and KdpWritePhysicalMemory)

    Wesley Witt (wesw) 18-Aug-1993

        Added KdpGetVersion, KdpWriteBreakPointEx, & KdpRestoreBreakPointEx


--*/

#include "kdp.h"

#if ACCASM && !defined(_MSC_VER)
long asm(const char *,...);
#pragma intrinsic(asm)
#endif

// XXX drewb - Shortcut to avoid cross-depot checkin
// build delay.  These constants are defined in ntdbg.h
// from the sdktools depot.  Once the internal sdktools
// ntdbg.h is updated from ntdbg.w this can be removed.
#ifndef DBGKD_CACHING_UNKNOWN
#define DBGKD_CACHING_UNKNOWN        0
#define DBGKD_CACHING_CACHED         1
#define DBGKD_CACHING_UNCACHED       2
#define DBGKD_CACHING_WRITE_COMBINED 3
#endif

BOOLEAN KdpContextSent;

LARGE_INTEGER KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    );

extern LARGE_INTEGER Magic10000;
#define SHIFT10000   13
#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

//
// Define forward referenced function prototypes.
//

VOID
KdpProcessInternalBreakpoint (
    ULONG BreakpointNumber
    );

VOID
KdpGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

NTSTATUS
KdpNotSupported(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

VOID
KdpCauseBugCheck(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

NTSTATUS
KdpWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpSearchMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

ULONG
KdpSearchHammingDistance (
    ULONG_PTR Left,
    ULONG_PTR Right
    );

LOGICAL
KdpSearchPhysicalPage (
    IN PFN_NUMBER PageFrameIndex,
    ULONG_PTR RangeStart,
    ULONG_PTR RangeEnd,
    ULONG Flags,
    ULONG MmFlags
    );

LOGICAL
KdpSearchPhysicalMemoryRequested (
    VOID
    );

LOGICAL
KdpSearchPhysicalPageRange (
    ULONG MmFlags
    );

VOID
KdpFillMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpQueryMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PCONTEXT Context
    );


#if i386
VOID
InternalBreakpointCheck (
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
KdGetInternalBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

long
SymNumFor(
    ULONG_PTR pc
    );

void PotentialNewSymbol (ULONG_PTR pc);

void DumpTraceData(PSTRING MessageData);

BOOLEAN
TraceDataRecordCallInfo(
    ULONG InstructionsTraced,
    LONG CallLevelChange,
    ULONG_PTR pc
    );

BOOLEAN
SkippingWhichBP (
    PVOID thread,
    PULONG BPNum
    );

ULONG_PTR
KdpGetReturnAddress(
    IN PCONTEXT ContextRecord
    );

ULONG_PTR
KdpGetCallNextOffset (
    ULONG_PTR Pc,
    IN PCONTEXT ContextRecord
    );

LONG
KdpLevelChange (
    ULONG_PTR Pc,
    PCONTEXT ContextRecord,
    IN OUT PBOOLEAN SpecialCall
    );

#endif // i386

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdEnterDebugger)
#pragma alloc_text(PAGEKD, KdExitDebugger)

#if !defined(_TRUSTED_WINDOWS_)
#pragma alloc_text(PAGEKD, KdpTimeSlipDpcRoutine)
#pragma alloc_text(PAGEKD, KdpTimeSlipWork)
#endif

#pragma alloc_text(PAGEKD, KdpSendWaitContinue)
#pragma alloc_text(PAGEKD, KdpReadVirtualMemory)
//#pragma alloc_text(PAGEKD, KdpReadVirtualMemory64)
#pragma alloc_text(PAGEKD, KdpWriteVirtualMemory)
//#pragma alloc_text(PAGEKD, KdpWriteVirtualMemory64)
#pragma alloc_text(PAGEKD, KdpGetContext)
#pragma alloc_text(PAGEKD, KdpSetContext)
#pragma alloc_text(PAGEKD, KdpWriteBreakpoint)
#pragma alloc_text(PAGEKD, KdpRestoreBreakpoint)
#pragma alloc_text(PAGEKD, KdpReportExceptionStateChange)
#pragma alloc_text(PAGEKD, KdpReportLoadSymbolsStateChange)
#pragma alloc_text(PAGEKD, KdpReportCommandStringStateChange)
#pragma alloc_text(PAGEKD, KdpReadPhysicalMemory)
#pragma alloc_text(PAGEKD, KdpWritePhysicalMemory)
#pragma alloc_text(PAGEKD, KdpReadControlSpace)
#pragma alloc_text(PAGEKD, KdpWriteControlSpace)
#pragma alloc_text(PAGEKD, KdpReadIoSpace)
#pragma alloc_text(PAGEKD, KdpWriteIoSpace)
#pragma alloc_text(PAGEKD, KdpReadIoSpaceExtended)
#pragma alloc_text(PAGEKD, KdpWriteIoSpaceExtended)
#pragma alloc_text(PAGEKD, KdpReadMachineSpecificRegister)
#pragma alloc_text(PAGEKD, KdpWriteMachineSpecificRegister)
#pragma alloc_text(PAGEKD, KdpGetBusData)
#pragma alloc_text(PAGEKD, KdpSetBusData)
#pragma alloc_text(PAGEKD, KdpGetVersion)
#pragma alloc_text(PAGEKD, KdpNotSupported)
#pragma alloc_text(PAGEKD, KdpCauseBugCheck)
#pragma alloc_text(PAGEKD, KdpWriteBreakPointEx)
#pragma alloc_text(PAGEKD, KdpRestoreBreakPointEx)
#pragma alloc_text(PAGEKD, KdpSearchMemory)
#pragma alloc_text(PAGEKD, KdpSearchHammingDistance)
#pragma alloc_text(PAGEKD, KdpSearchPhysicalPage)
#pragma alloc_text(PAGEKD, KdpSearchPhysicalMemoryRequested)
#pragma alloc_text(PAGEKD, KdpSearchPhysicalPageRange)
#pragma alloc_text(PAGEKD, KdpCheckLowMemory)
#pragma alloc_text(PAGEKD, KdpFillMemory)
#pragma alloc_text(PAGEKD, KdpQueryMemory)
#pragma alloc_text(PAGEKD, KdpSysGetVersion)
#pragma alloc_text(PAGEKD, KdpSysReadBusData)
#pragma alloc_text(PAGEKD, KdpSysWriteBusData)
#pragma alloc_text(PAGEKD, KdpSysCheckLowMemory)
#pragma alloc_text(PAGEKD, KdpSendTraceData)
#pragma alloc_text(PAGEKD, KdReportTraceData)
#if DBG
#pragma alloc_text(PAGEKD, KdpDprintf)
#endif
#if i386
#pragma alloc_text(PAGEKD, InternalBreakpointCheck)
#pragma alloc_text(PAGEKD, KdSetInternalBreakpoint)
#pragma alloc_text(PAGEKD, KdGetTraceInformation)
#pragma alloc_text(PAGEKD, KdGetInternalBreakpoint)
#pragma alloc_text(PAGEKD, SymNumFor)
#pragma alloc_text(PAGEKD, PotentialNewSymbol)
#pragma alloc_text(PAGEKD, DumpTraceData)
#pragma alloc_text(PAGEKD, TraceDataRecordCallInfo)
#pragma alloc_text(PAGEKD, SkippingWhichBP)
#pragma alloc_text(PAGEKD, KdQuerySpecialCalls)
#pragma alloc_text(PAGEKD, KdSetSpecialCall)
#pragma alloc_text(PAGEKD, KdClearSpecialCalls)
#pragma alloc_text(PAGEKD, KdpCheckTracePoint)
#pragma alloc_text(PAGEKD, KdpProcessInternalBreakpoint)
#endif // i386
#endif // ALLOC_PRAGMA


//
// This variable has a count for each time KdDisableDebugger has been called.
//
LONG KdDisableCount = 0 ;
BOOLEAN KdPreviouslyEnabled = FALSE ;


#if DBG
VOID
KdpDprintf(
    IN PCHAR f,
    ...
    )
/*++

Routine Description:

    Printf routine for the debugger that is safer than DbgPrint.  Calls
    the packet driver instead of reentering the debugger.

Arguments:

    f - Supplies printf format

Return Value:

    None

--*/
{
    char    buf[100];
    STRING  Output;
    va_list mark;

    va_start(mark, f);
    _vsnprintf(buf, 100, f, mark);
    va_end(mark);

    Output.Buffer = buf;
    Output.Length = (USHORT) strlen(Output.Buffer);
    KdpPrintString(&Output);
}
#endif // DBG


BOOLEAN
KdEnterDebugger(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function is used to enter the kernel debugger. Its purpose
    is to freeze all other processors and aqcuire the kernel debugger
    comm port.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to an exception frame that
        describes the trap.

Return Value:

    Returns the previous interrupt enable.

--*/

{

    BOOLEAN Enable;
#if DBG
    extern ULONG KiFreezeFlag;
#endif

    //
    // HACKHACK - do some crude timer support
    //            but not if called from KdSetOwedBreakpoints()
    //

    if (TrapFrame) {
        KdTimerStop = KdpQueryPerformanceCounter (TrapFrame);
        KdTimerDifference.QuadPart = KdTimerStop.QuadPart - KdTimerStart.QuadPart;
    } else {
        KdTimerStop.QuadPart = 0;
    }

    //
    // Save the current IRQL in the Prcb so the debugger can extract it
    // later on for debugging purposes.
    //

    KeGetCurrentPrcb()->DebuggerSavedIRQL = KeGetCurrentIrql();

    //
    // Freeze all other processors, raise IRQL to HIGH_LEVEL, and save debug
    // port state.  We lock the port so that KdPollBreakin and a debugger
    // operation don't interfere with each other.
    //

    Enable = KeFreezeExecution(TrapFrame, ExceptionFrame);
    KdpPortLocked = KeTryToAcquireSpinLockAtDpcLevel(&KdpDebuggerLock);
    KdSave(FALSE);
    KdEnteredDebugger = TRUE;

#if DBG

    if ((KiFreezeFlag & FREEZE_BACKUP) != 0) {
        DPRINT(("FreezeLock was jammed!  Backup SpinLock was used!\n"));
    }

    if ((KiFreezeFlag & FREEZE_SKIPPED_PROCESSOR) != 0) {
        DPRINT(("Some processors not frozen in debugger!\n"));
    }

    if (KdpPortLocked == FALSE) {
        DPRINT(("Port lock was not acquired!\n"));
    }

#endif

    return Enable;
}

VOID
KdExitDebugger(
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function is used to exit the kernel debugger. It is the reverse
    of KdEnterDebugger.

Arguments:

    Enable - Supplies the previous interrupt enable which is to be restored.

Return Value:

    None.

--*/

{
#if !defined(_TRUSTED_WINDOWS_)
    ULONG Pending;
#endif

    //
    // restore stuff and exit
    //

    KdRestore(FALSE);
    if (KdpPortLocked) {
        KdpPortUnlock();
    }

    KeThawExecution(Enable);

    //
    // Do some crude timer support.  If KdEnterDebugger didn't
    // Query the performance counter, then don't do it here either.
    //

    if (KdTimerStop.QuadPart == 0) {
        KdTimerStart = KdTimerStop;
    } else {
        KdTimerStart = KeQueryPerformanceCounter(NULL);
    }

    //
    // Process a time slip
    //

#if !defined(_TRUSTED_WINDOWS_)
    if (!PoHiberInProgress) {

        Pending = InterlockedIncrement( (PLONG) &KdpTimeSlipPending);

        //
        // If there's wasn't a time slip pending, queue the DPC to handle it
        //

        if (Pending == 1) {
            InterlockedIncrement( (PLONG) &KdpTimeSlipPending);
            KeInsertQueueDpc(&KdpTimeSlipDpc, NULL, NULL);
        }
    }
#endif

    return;
}


#if !defined(_TRUSTED_WINDOWS_)

VOID
KdUpdateTimeSlipEvent(
    PVOID Event
    )

/*++

Routine Description:

    Update the reference to an event object which will be signalled when
    the debugger has caused the system clock to skew.

Arguments:

    Event - Supplies a pointer to an event object

Return Value:

    None

--*/

{
    KIRQL OldIrql;

    KeAcquireSpinLock(&KdpTimeSlipEventLock, &OldIrql);

    //
    // Dereference the old event and forget about it.
    // Remember the new event if there is one.
    //

    if (KdpTimeSlipEvent != NULL) {
        ObDereferenceObject(KdpTimeSlipEvent);
    }

    KdpTimeSlipEvent = Event;

    KeReleaseSpinLock(&KdpTimeSlipEventLock, OldIrql);
}

VOID
KdpTimeSlipDpcRoutine (
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    LONG OldCount, NewCount, j;

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // Reset pending count.  If the current count is 1, then clear
    // the pending count.  if the current count is greater then 1,
    // then set to one and update the time now.
    //

    j = KdpTimeSlipPending;
    do {
        OldCount = j;
        NewCount = OldCount > 1 ? 1 : 0;

        j = InterlockedCompareExchange((PLONG)&KdpTimeSlipPending, NewCount, OldCount);

    } while (j != OldCount);

    //
    // If new count is non-zero, then process a time slip now
    //

    if (NewCount) {
        ExQueueWorkItem(&KdpTimeSlipWorkItem, DelayedWorkQueue);
    }
}

VOID
KdpTimeSlipWork (
    IN PVOID Context
    )
{
    KIRQL               OldIrql;
    LARGE_INTEGER       DueTime;

    UNREFERENCED_PARAMETER (Context);

    //
    // Update time from the real time clock.
    // If the lock is held by somebody else, don't bother as it's not worth
    // tying up a worker thread.
    //

    if (ExAcquireTimeRefreshLock(FALSE)) {
        ExUpdateSystemTimeFromCmos (FALSE, 0);
        ExReleaseTimeRefreshLock();

        //
        // If there's a time service installed, signal it's time slip event
        //

        KeAcquireSpinLock(&KdpTimeSlipEventLock, &OldIrql);
        if (KdpTimeSlipEvent) {
            KeSetEvent (KdpTimeSlipEvent, 0, FALSE);
        }
        KeReleaseSpinLock(&KdpTimeSlipEventLock, OldIrql);

        //
        // Insert a forced delay between time slip operations
        //

        DueTime.QuadPart = -1800000000;
        KeSetTimer (&KdpTimeSlipTimer, DueTime, &KdpTimeSlipDpc);
    }
}

#endif // !defined(_TRUSTED_WINDOWS_)


#if i386

#if 0
#define INTBP_PRINT(Args) DPRINT(Args)
#else
#define INTBP_PRINT(Args)
#endif

VOID
InternalBreakpointCheck (
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    LARGE_INTEGER dueTime;
    ULONG i;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    dueTime.LowPart = (ULONG)(-1 * 10 * 1000 * 1000);
    dueTime.HighPart = -1;

    KeSetTimer(
        &InternalBreakpointTimer,
        dueTime,
        &InternalBreakpointCheckDpc
        );

    for ( i = 0 ; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
             (KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_COUNTONLY) ) {

            PDBGKD_INTERNAL_BREAKPOINT b = KdpInternalBPs + i;
            ULONG callsThisPeriod;

            callsThisPeriod = b->Calls - b->CallsLastCheck;
            if ( callsThisPeriod > b->MaxCallsPerPeriod ) {
                b->MaxCallsPerPeriod = callsThisPeriod;
            }
            b->CallsLastCheck = b->Calls;
        }
    }

    return;

} // InternalBreakpointCheck


VOID
KdSetInternalBreakpoint (
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function sets an internal breakpoint.  "Internal breakpoint"
    means one in which control is not returned to the kernel debugger at
    all, but rather just update internal counting routines and resume.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.
--*/

{
    ULONG i;
    PDBGKD_INTERNAL_BREAKPOINT bp = NULL;
    ULONG savedFlags;

    for ( i = 0 ; i < KdpNumInternalBreakpoints; i++ ) {
        if ( KdpInternalBPs[i].Addr ==
                            m->u.SetInternalBreakpoint.BreakpointAddress ) {
            bp = &KdpInternalBPs[i];
            break;
        }
    }

    if ( !bp ) {
        for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
            if ( KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID ) {
                bp = &KdpInternalBPs[i];
                break;
            }
        }
    }

    if ( !bp ) {
        if ( KdpNumInternalBreakpoints >= DBGKD_MAX_INTERNAL_BREAKPOINTS ) {
            return; // no space.  Probably should report error.
        }
        bp = &KdpInternalBPs[KdpNumInternalBreakpoints++];
        bp->Flags |= DBGKD_INTERNAL_BP_FLAG_INVALID; // force initialization
    }

    if ( bp->Flags & DBGKD_INTERNAL_BP_FLAG_INVALID ) {
        if ( m->u.SetInternalBreakpoint.Flags &
                                        DBGKD_INTERNAL_BP_FLAG_INVALID ) {
            return; // tried clearing a non-existant BP.  Ignore the request
        }
        bp->Calls = bp->MaxInstructions = bp->TotalInstructions = 0;
        bp->CallsLastCheck = bp->MaxCallsPerPeriod = 0;
        bp->MinInstructions = 0xffffffff;
        bp->Handle = 0;
        bp->Thread = 0;
    }

    savedFlags = bp->Flags;
    bp->Flags = m->u.SetInternalBreakpoint.Flags; // this could possibly invalidate the BP
    bp->Addr = m->u.SetInternalBreakpoint.BreakpointAddress;

    if ( bp->Flags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                      DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {

        if ( (bp->Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
             (bp->Thread != 0) ) {
            // The breakpoint is active; defer its deletion
            bp->Flags &= ~DBGKD_INTERNAL_BP_FLAG_INVALID;
            bp->Flags |= DBGKD_INTERNAL_BP_FLAG_DYING;
        }

        // This is really a CLEAR bp request.

        if ( bp->Handle != 0 ) {
            KdpDeleteBreakpoint( bp->Handle );
        }
        bp->Handle = 0;

        return;
    }

    // now set the real breakpoint and remember its handle.

    if ( savedFlags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                       DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {
        // breakpoint was invalid; activate it now
        bp->Handle = KdpAddBreakpoint( (PVOID)(ULONG_PTR)bp->Addr );

        INTBP_PRINT(("Added intbp %d of %d at %I64x, flags %x, handle %x\n",
                     (ULONG)(bp - KdpInternalBPs), KdpNumInternalBreakpoints,
                     bp->Addr, bp->Flags, bp->Handle));
    }

    if ( BreakpointsSuspended ) {
        KdpSuspendBreakpoint( bp->Handle );
    }

} // KdSetInternalBreakpoint

NTSTATUS
KdGetTraceInformation(
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    )

/*++

Routine Description:

    This function gets data about an internal breakpoint and returns it
    in a buffer provided for it.  It is designed to be called from
    NTQuerySystemInformation.  It is morally equivalent to GetInternalBP
    except that it communicates locally, and returns all the breakpoints
    at once.

Arguments:

    SystemInforamtion - the buffer into which to write the result.
    SystemInformationLength - the maximum length to write
    RetrunLength - How much data was really written

Return Value:

    None.

--*/

{
    ULONG numEntries = 0;
    ULONG i = 0;
    PDBGKD_GET_INTERNAL_BREAKPOINT64 outPtr;

    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
            numEntries++;
        }
    }

    *ReturnLength = numEntries * sizeof(DBGKD_GET_INTERNAL_BREAKPOINT64);
    if ( *ReturnLength > SystemInformationLength ) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // We've got enough space.  Copy it in.
    //

    outPtr = (PDBGKD_GET_INTERNAL_BREAKPOINT64)SystemInformation;
    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
            outPtr->BreakpointAddress = KdpInternalBPs[i].Addr;
            outPtr->Flags = KdpInternalBPs[i].Flags;
            outPtr->Calls = KdpInternalBPs[i].Calls;
            outPtr->MaxCallsPerPeriod = KdpInternalBPs[i].MaxCallsPerPeriod;
            outPtr->MinInstructions = KdpInternalBPs[i].MinInstructions;
            outPtr->MaxInstructions = KdpInternalBPs[i].MaxInstructions;
            outPtr->TotalInstructions = KdpInternalBPs[i].TotalInstructions;
            outPtr++;
        }
    }

    return STATUS_SUCCESS;

} // KdGetTraceInformation

VOID
KdGetInternalBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function gets data about an internal breakpoint and returns it
    to the calling debugger.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{
    ULONG i;
    PDBGKD_INTERNAL_BREAKPOINT bp = NULL;
    STRING messageHeader;

    messageHeader.Length = sizeof(*m);
    messageHeader.Buffer = (PCHAR)m;

    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                                          DBGKD_INTERNAL_BP_FLAG_SUSPENDED)) &&
             (KdpInternalBPs[i].Addr ==
                        m->u.GetInternalBreakpoint.BreakpointAddress) ) {
            bp = &KdpInternalBPs[i];
            break;
        }
    }

    if ( !bp ) {
        m->u.GetInternalBreakpoint.Flags = DBGKD_INTERNAL_BP_FLAG_INVALID;
        m->u.GetInternalBreakpoint.Calls = 0;
        m->u.GetInternalBreakpoint.MaxCallsPerPeriod = 0;
        m->u.GetInternalBreakpoint.MinInstructions = 0;
        m->u.GetInternalBreakpoint.MaxInstructions = 0;
        m->u.GetInternalBreakpoint.TotalInstructions = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->u.GetInternalBreakpoint.Flags = bp->Flags;
        m->u.GetInternalBreakpoint.Calls = bp->Calls;
        m->u.GetInternalBreakpoint.MaxCallsPerPeriod = bp->MaxCallsPerPeriod;
        m->u.GetInternalBreakpoint.MinInstructions = bp->MinInstructions;
        m->u.GetInternalBreakpoint.MaxInstructions = bp->MaxInstructions;
        m->u.GetInternalBreakpoint.TotalInstructions = bp->TotalInstructions;
        m->ReturnStatus = STATUS_SUCCESS;
    }

    m->ApiNumber = DbgKdGetInternalBreakPointApi;

    KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &messageHeader,
                 NULL,
                 &KdpContext
                 );

    return;

} // KdGetInternalBreakpoint
#endif // i386

KCONTINUE_STATUS
KdpSendWaitContinue (
    IN ULONG OutPacketType,
    IN PSTRING OutMessageHeader,
    IN PSTRING OutMessageData OPTIONAL,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function sends a packet, and then waits for a continue message.
    BreakIns received while waiting will always cause a resend of the
    packet originally sent out.  While waiting, manipulate messages
    will be serviced.

    A resend always resends the original event sent to the debugger,
    not the last response to some debugger command.

Arguments:

    OutPacketType - Supplies the type of packet to send.

    OutMessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    OutMessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

    ContextRecord - Exception context

Return Value:

    A value of TRUE is returned if the continue message indicates
    success, Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_MANIPULATE_STATE64 ManipulateState;
    ULONG ReturnCode;
    NTSTATUS Status;
    KCONTINUE_STATUS ContinueStatus;

    //
    // Loop servicing state manipulation message until a continue message
    // is received.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)&ManipulateState;
    MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;
    MessageData.Buffer = (PCHAR)KdpMessageBuffer;
    KdpContextSent = FALSE;

ResendPacket:

    //
    // Send event notification packet to debugger on host.  Come back
    // here any time we see a breakin sequence.
    //

    KdSendPacket(
        OutPacketType,
        OutMessageHeader,
        OutMessageData,
        &KdpContext
        );

    //
    // After sending packet, if there is no response from debugger
    // AND the packet is for reporting symbol (un)load, the debugger
    // will be declared to be not present.  Note If the packet is for
    // reporting exception, the KdSendPacket will never stop.
    //

    if (KdDebuggerNotPresent) {
        return ContinueSuccess;
    }

    while (TRUE) {

        //
        // Wait for State Manipulate Packet without timeout.
        //

        do {

            ReturnCode = KdReceivePacket(
                            PACKET_TYPE_KD_STATE_MANIPULATE,
                            &MessageHeader,
                            &MessageData,
                            &Length,
                            &KdpContext
                            );
            if (ReturnCode == (USHORT)KDP_PACKET_RESEND) {
                goto ResendPacket;
            }
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        //
        // Switch on the return message API number.
        //

        switch (ManipulateState.ApiNumber) {

        case DbgKdReadVirtualMemoryApi:
            KdpReadVirtualMemory(&ManipulateState,&MessageData,ContextRecord);
            break;
#if 0
        case DbgKdReadVirtualMemory64Api:
            KdpReadVirtualMemory64(&ManipulateState,&MessageData,ContextRecord);
            break;
#endif
        case DbgKdWriteVirtualMemoryApi:
            KdpWriteVirtualMemory(&ManipulateState,&MessageData,ContextRecord);
            break;
#if 0
        case DbgKdWriteVirtualMemory64Api:
            KdpWriteVirtualMemory64(&ManipulateState,&MessageData,ContextRecord);
            break;
#endif

        case DbgKdCheckLowMemoryApi:
            KdpCheckLowMemory (&ManipulateState);
            break;

        case DbgKdReadPhysicalMemoryApi:
            KdpReadPhysicalMemory(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWritePhysicalMemoryApi:
            KdpWritePhysicalMemory(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdGetContextApi:
            KdpGetContext(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdSetContextApi:
            KdpSetContext(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteBreakPointApi:
            KdpWriteBreakpoint(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdRestoreBreakPointApi:
            KdpRestoreBreakpoint(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdReadControlSpaceApi:
            KdpReadControlSpace(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteControlSpaceApi:
            KdpWriteControlSpace(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdReadIoSpaceApi:
            KdpReadIoSpace(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteIoSpaceApi:
            KdpWriteIoSpace(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdReadIoSpaceExtendedApi:
            KdpReadIoSpaceExtended(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteIoSpaceExtendedApi:
            KdpWriteIoSpaceExtended(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdReadMachineSpecificRegister:
            KdpReadMachineSpecificRegister(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteMachineSpecificRegister:
            KdpWriteMachineSpecificRegister(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdGetBusDataApi:
            KdpGetBusData(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdSetBusDataApi:
            KdpSetBusData(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdContinueApi:
            if (NT_SUCCESS(ManipulateState.u.Continue.ContinueStatus) != FALSE) {
                return ContinueSuccess;
            } else {
                return ContinueError;
            }
            break;

        case DbgKdContinueApi2:
            if (NT_SUCCESS(ManipulateState.u.Continue2.ContinueStatus) != FALSE) {
                KdpGetStateChange(&ManipulateState,ContextRecord);
                return ContinueSuccess;
            } else {
                return ContinueError;
            }
            break;

        case DbgKdRebootApi:
            HalReturnToFirmware(HalRebootRoutine);
            break;

#if defined(i386)
        case DbgKdSetSpecialCallApi:
            KdSetSpecialCall(&ManipulateState,ContextRecord);
            break;

        case DbgKdClearSpecialCallsApi:
            KdClearSpecialCalls();
            break;

        case DbgKdSetInternalBreakPointApi:
            KdSetInternalBreakpoint(&ManipulateState);
            break;

        case DbgKdGetInternalBreakPointApi:
            KdGetInternalBreakpoint(&ManipulateState);
            break;

        case DbgKdClearAllInternalBreakpointsApi:
            KdpNumInternalBreakpoints = 0;
            break;

#endif // i386

        case DbgKdGetVersionApi:
            KdpGetVersion(&ManipulateState);
            break;

        case DbgKdCauseBugCheckApi:
            KdpCauseBugCheck(&ManipulateState);
            break;

        case DbgKdPageInApi:
            KdpNotSupported(&ManipulateState);
            break;

        case DbgKdWriteBreakPointExApi:
            Status = KdpWriteBreakPointEx(&ManipulateState,
                                          &MessageData,
                                          ContextRecord);
            if (Status) {
                ManipulateState.ApiNumber = DbgKdContinueApi;
                ManipulateState.u.Continue.ContinueStatus = Status;
                return ContinueError;
            }
            break;

        case DbgKdRestoreBreakPointExApi:
            KdpRestoreBreakPointEx(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdSwitchProcessor:
            KdRestore(FALSE);
            ContinueStatus = KeSwitchFrozenProcessor(ManipulateState.Processor);
            KdSave(FALSE);
            return ContinueStatus;

        case DbgKdSearchMemoryApi:
            KdpSearchMemory(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdFillMemoryApi:
            KdpFillMemory(&ManipulateState, &MessageData, ContextRecord);
            break;
            
        case DbgKdQueryMemoryApi:
            KdpQueryMemory(&ManipulateState, ContextRecord);
            break;
            
            //
            // Invalid message.
            //

        default:
            MessageData.Length = 0;
            ManipulateState.ReturnStatus = STATUS_UNSUCCESSFUL;
            KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &MessageHeader, &MessageData, &KdpContext);
            break;
        }
    }
}

VOID
KdpReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a read virtual memory 32-bit
    state manipulation message. Its function is to read virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to read.

    Context - Supplies a pointer to the current context.

Return Value:

    None.

--*/

{
    ULONG Length;
    STRING MessageHeader;

    UNREFERENCED_PARAMETER (Context);

    //
    // Trim the transfer count to fit in a single message.
    //

    Length = m->u.ReadMemory.TransferCount;
    if (Length > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    }

    //
    // Move the data to the destination buffer.
    //

    m->ReturnStatus =
        KdpCopyMemoryChunks(m->u.ReadMemory.TargetBaseAddress,
                            AdditionalData->Buffer,
                            Length,
                            0,
                            MMDBG_COPY_UNSAFE,
                            &Length);

    //
    // Set the actual number of bytes read, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    AdditionalData->Length = (USHORT)Length;
    m->u.ReadMemory.ActualBytesRead = Length;

    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData,
                 &KdpContext);

    return;
}

VOID
KdpWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write virtual memory 32-bit
    state manipulation message. Its function is to write virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to write.

    Context - Supplies a pointer to the current context.

Return Value:

    None.

--*/

{

    STRING MessageHeader;

    UNREFERENCED_PARAMETER (Context);

    //
    // Move the data to the destination buffer.
    //

    m->ReturnStatus =
        KdpCopyMemoryChunks(m->u.WriteMemory.TargetBaseAddress,
                            AdditionalData->Buffer,
                            AdditionalData->Length,
                            0,
                            MMDBG_COPY_WRITE | MMDBG_COPY_UNSAFE,
                            &m->u.WriteMemory.ActualBytesWritten);

    //
    // Set the actual number of bytes written, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL,
                 &KdpContext);

    return;
}

VOID
KdpGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a get context state
    manipulation message.  Its function is to return the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    if (m->Processor >= (USHORT)KeNumberProcessors) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->ReturnStatus = STATUS_SUCCESS;
        AdditionalData->Length = sizeof(CONTEXT);
        if (m->Processor == (USHORT)KeGetCurrentProcessorNumber()) {
            KdpQuickMoveMemory(AdditionalData->Buffer, (PCHAR)Context, sizeof(CONTEXT));
        } else {
            KdpQuickMoveMemory(AdditionalData->Buffer,
                          (PCHAR)&KiProcessorBlock[m->Processor]->ProcessorState.ContextFrame,
                          sizeof(CONTEXT)
                         );
        }
        KdpContextSent = TRUE;
    }

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
}

VOID
KdpSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a set context state
    manipulation message.  Its function is set the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == sizeof(CONTEXT));

    if ((m->Processor >= (USHORT)KeNumberProcessors) ||
        (KdpContextSent == FALSE)) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->ReturnStatus = STATUS_SUCCESS;
        if (m->Processor == (USHORT)KeGetCurrentProcessorNumber()) {
            KdpQuickMoveMemory((PCHAR)Context, AdditionalData->Buffer, sizeof(CONTEXT));
        } else {
            KdpQuickMoveMemory((PCHAR)&KiProcessorBlock[m->Processor]->ProcessorState.ContextFrame,
                          AdditionalData->Buffer,
                          sizeof(CONTEXT)
                         );
        }
    }

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}

VOID
KdpWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state
    manipulation message.  Its function is to write a breakpoint
    and return a handle to the breakpoint.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_BREAKPOINT64 a = &m->u.WriteBreakPoint;
    STRING MessageHeader;

#if !DBG
    UNREFERENCED_PARAMETER (AdditionalData);
#endif

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    a->BreakPointHandle = KdpAddBreakpoint((PVOID)(ULONG_PTR)a->BreakPointAddress);
    if (a->BreakPointHandle != 0) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state
    manipulation message.  Its function is to restore a breakpoint
    using the specified handle.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_RESTORE_BREAKPOINT a = &m->u.RestoreBreakPoint;
    STRING MessageHeader;

#if !DBG
    UNREFERENCED_PARAMETER(AdditionalData);
#endif

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);
    if (KdpDeleteBreakpoint(a->BreakPointHandle)) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

#if defined(_X86_)

long
SymNumFor(
    ULONG pc
    )
{
    ULONG index;

    for (index = 0; index < NumTraceDataSyms; index++) {
        if ((TraceDataSyms[index].SymMin <= pc) &&
            (TraceDataSyms[index].SymMax > pc)) return(index);
    }
    return(-1);
}

#if 0
#define TRACE_PRINT(Args) DPRINT(Args)
#else
#define TRACE_PRINT(Args)
#endif

BOOLEAN TraceDataBufferFilled = FALSE;

void PotentialNewSymbol (ULONG pc)
{
    if (!TraceDataBufferFilled &&
        -1 != SymNumFor(pc)) {     // we've already seen this one
        TRACE_PRINT(("PNS %x repeat %d\n", pc, SymNumFor(pc)));
        return;
    }

    TraceDataBufferFilled = FALSE;

    // OK, we've got to start up a TraceDataRecord
    TraceDataBuffer[TraceDataBufferPosition].s.LevelChange = 0;

    if (-1 != SymNumFor(pc)) {
        int sym = SymNumFor(pc);
        TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = (UCHAR) sym;
        KdpCurrentSymbolStart = TraceDataSyms[sym].SymMin;
        KdpCurrentSymbolEnd = TraceDataSyms[sym].SymMax;

        TRACE_PRINT(("PNS %x repeat %d at %d\n",
                     pc, sym, TraceDataBufferPosition));
        return;  // we've already seen this one
    }

    TraceDataSyms[NextTraceDataSym].SymMin = KdpCurrentSymbolStart;
    TraceDataSyms[NextTraceDataSym].SymMax = KdpCurrentSymbolEnd;

    TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = NextTraceDataSym;

    // Bump the "next" pointer, wrapping if necessary.  Also bump the
    // "valid" pointer if we need to.
    NextTraceDataSym = (NextTraceDataSym + 1) % 256;
    if (NumTraceDataSyms < NextTraceDataSym) {
        NumTraceDataSyms = NextTraceDataSym;
    }

    TRACE_PRINT(("PNS %x in %x - %x, next %d, num %d\n", pc,
                 KdpCurrentSymbolStart, KdpCurrentSymbolEnd,
                 NextTraceDataSym, NumTraceDataSyms));
}

void DumpTraceData(PSTRING MessageData)
{
    TraceDataBuffer[0].LongNumber = TraceDataBufferPosition;
    MessageData->Length =
        (USHORT)(sizeof(TraceDataBuffer[0]) * TraceDataBufferPosition);
    MessageData->Buffer = (PVOID)TraceDataBuffer;
    TRACE_PRINT(("DumpTraceData returns %d records\n",
                 TraceDataBufferPosition));
    TraceDataBufferPosition = 1;
}

BOOLEAN
TraceDataRecordCallInfo(
    ULONG InstructionsTraced,
    LONG CallLevelChange,
    ULONG pc
    )
{
    // We've just exited a symbol scope.  The InstructionsTraced number goes
    // with the old scope, the CallLevelChange goes with the new, and the
    // pc fills in the symbol for the new TraceData record.

    long SymNum = SymNumFor(pc);

    if (KdpNextCallLevelChange != 0) {
        TraceDataBuffer[TraceDataBufferPosition].s.LevelChange =
                                                (char) KdpNextCallLevelChange;
        KdpNextCallLevelChange = 0;
    }


    if (InstructionsTraced >= TRACE_DATA_INSTRUCTIONS_BIG) {
       TraceDataBuffer[TraceDataBufferPosition].s.Instructions =
           TRACE_DATA_INSTRUCTIONS_BIG;
       TraceDataBuffer[TraceDataBufferPosition+1].LongNumber =
           InstructionsTraced;
       TraceDataBufferPosition += 2;
    } else {
       TraceDataBuffer[TraceDataBufferPosition].s.Instructions =
           (unsigned short)InstructionsTraced;
       TraceDataBufferPosition++;
    }

    if ((TraceDataBufferPosition + 2 >= TRACE_DATA_BUFFER_MAX_SIZE) ||
        (-1 == SymNum)) {
        if (TraceDataBufferPosition +2 >= TRACE_DATA_BUFFER_MAX_SIZE) {
            TraceDataBufferFilled = TRUE;
        }
       KdpNextCallLevelChange = CallLevelChange;
       TRACE_PRINT(("TDRCI nosym %x, lc %d, pos %d\n", pc, CallLevelChange,
                    TraceDataBufferPosition));
       return FALSE;
    }

    TraceDataBuffer[TraceDataBufferPosition].s.LevelChange =(char)CallLevelChange;
    TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = (UCHAR) SymNum;
    KdpCurrentSymbolStart = TraceDataSyms[SymNum].SymMin;
    KdpCurrentSymbolEnd = TraceDataSyms[SymNum].SymMax;

    TRACE_PRINT(("TDRCI sym %d for %x, %x - %x, lc %d, pos %d\n", SymNum, pc,
                 KdpCurrentSymbolStart, KdpCurrentSymbolEnd, CallLevelChange,
                 TraceDataBufferPosition));
    return TRUE;
}

BOOLEAN
SkippingWhichBP (
    PVOID thread,
    PULONG BPNum
    )

/*
 * Return TRUE iff the pc corresponds to an internal breakpoint
 * that has just been replaced for execution.  If TRUE, then return
 * the breakpoint number in BPNum.
 */

{
    ULONG index;

    if (!IntBPsSkipping) return FALSE;

    for (index = 0; index < KdpNumInternalBreakpoints; index++) {
        if (!(KdpInternalBPs[index].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
            (KdpInternalBPs[index].Thread == thread)) {
            *BPNum = index;
            return TRUE;
        }
    }
    return FALSE; // didn't match any
}


NTSTATUS
KdQuerySpecialCalls (
    IN PDBGKD_MANIPULATE_STATE64 m,
    ULONG Length,
    PULONG RequiredLength
    )
{
    *RequiredLength = sizeof(DBGKD_MANIPULATE_STATE64) +
                        (sizeof(ULONG) * KdNumberOfSpecialCalls);

    if ( Length < *RequiredLength ) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    m->u.QuerySpecialCalls.NumberOfSpecialCalls = KdNumberOfSpecialCalls;
    KdpQuickMoveMemory(
        (PCHAR)(m + 1),
        (PCHAR)KdSpecialCalls,
        sizeof(ULONG) * KdNumberOfSpecialCalls
        );

    return STATUS_SUCCESS;

} // KdQuerySpecialCalls


VOID
KdSetSpecialCall (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function sets the addresses of the "special" call addresses
    that the watchtrace facility pushes back to the kernel debugger
    rather than stepping through.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.
--*/

{
    if ( KdNumberOfSpecialCalls >= DBGKD_MAX_SPECIAL_CALLS ) {
        return; // too bad
    }

    KdSpecialCalls[KdNumberOfSpecialCalls++] = (ULONG_PTR)m->u.SetSpecialCall.SpecialCall;

    NextTraceDataSym = 0;
    NumTraceDataSyms = 0;
    KdpNextCallLevelChange = 0;
    if (ContextRecord && !InstrCountInternal) {
        InitialSP = ContextRecord->Esp;
    }

} // KdSetSpecialCall


VOID
KdClearSpecialCalls (
    VOID
    )

/*++

Routine Description:

    This function clears the addresses of the "special" call addresses
    that the watchtrace facility pushes back to the kernel debugger
    rather than stepping through.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KdNumberOfSpecialCalls = 0;
    return;

} // KdClearSpecialCalls


BOOLEAN
KdpCheckTracePoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    )
{
    ULONG pc = (ULONG)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
    LONG BpNum;
    ULONG SkippedBPNum;
    BOOLEAN AfterSC = FALSE;

    if (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) {
        if (WatchStepOverSuspended) {
            //
            //  For background, see the comment below where WSOThread is
            //  wrong.  We've now stepped over the breakpoint in the non-traced
            //  thread, and need to replace it and restart the non-traced
            //  thread at full speed.
            //

            WatchStepOverHandle = KdpAddBreakpoint((PVOID)WatchStepOverBreakAddr);
            WatchStepOverSuspended = FALSE;
            ContextRecord->EFlags &= ~0x100L; /* clear trace flag */
            return TRUE; // resume non-traced thread at full speed
        }

        if ((!SymbolRecorded) && (KdpCurrentSymbolStart != 0) && (KdpCurrentSymbolEnd != 0)) {
            //
            //  We need to use oldpc here, because this may have been
            //  a 1 instruction call.  We've ALREADY executed the instruction
            //  that the new symbol is for, and if the pc has moved out of
            //  range, we might mess up.  Hence, use the pc from when
            //  SymbolRecorded was set.  Yuck.
            //

            PotentialNewSymbol(oldpc);
            SymbolRecorded = TRUE;
        }

        if (!InstrCountInternal &&
            SkippingWhichBP((PVOID)KeGetCurrentThread(),&SkippedBPNum)) {

            //
            //  We just single-stepped over a temporarily removed internal
            //  breakpoint.
            //  If it's a COUNTONLY breakpoint:
            //      Put the breakpoint instruction back and resume
            //      regular execution.
            //

            if (KdpInternalBPs[SkippedBPNum].Flags &
                DBGKD_INTERNAL_BP_FLAG_COUNTONLY) {

                IntBPsSkipping --;

                KdpRestoreAllBreakpoints();

                ContextRecord->EFlags &= ~0x100L;  // Clear trace flag
                KdpInternalBPs[SkippedBPNum].Thread = 0;

                if (KdpInternalBPs[SkippedBPNum].Flags &
                        DBGKD_INTERNAL_BP_FLAG_DYING) {
                    KdpDeleteBreakpoint(KdpInternalBPs[SkippedBPNum].Handle);
                    KdpInternalBPs[SkippedBPNum].Flags |=
                            DBGKD_INTERNAL_BP_FLAG_INVALID; // bye, bye
                }

                return TRUE;
            }

            //
            //  If it's not:
            //      set up like it's a ww, by setting Begin and KdpCurrentSymbolEnd
            //      and bop off into single step land.  We probably ought to
            //      disable all breakpoints here, too, so that we don't do
            //      anything foul like trying two non-COUNTONLY's at the
            //      same time or something...
            //

            KdpCurrentSymbolEnd = 0;
            KdpCurrentSymbolStart = (ULONG_PTR) KdpInternalBPs[SkippedBPNum].ReturnAddress;

            ContextRecord->EFlags |= 0x100L; /* Trace on. */
            InitialSP = ContextRecord->Esp;

            InstructionsTraced = 1;  /* Count the initial call instruction. */
            InstrCountInternal = TRUE;
        }

    } /* if single step */
    else if (ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) {
        if (WatchStepOver && pc == WatchStepOverBreakAddr) {
            //
            //  This is a breakpoint after completion of a "special call"
            //

            if ((WSOThread != (PVOID)KeGetCurrentThread()) ||
                (WSOEsp + 0x20 < ContextRecord->Esp) ||
                (ContextRecord->Esp + 0x20 < WSOEsp)) {
                //
                //  Here's the story up to this point: the traced thread
                //  cruised along until it it a special call.  The tracer
                //  placed a breakpoint on the instruction immediately after
                //  the special call returns and restarted the traced thread
                //  at full speed.  Then, some *other* thread hit the
                //  breakpoint.  So, to correct for this, we're going to
                //  remove the breakpoint, single step the non-traced
                //  thread one instruction, replace the breakpoint,
                //  restart the non-traced thread at full speed, and wait
                //  for the traced thread to get to this breakpoint, just
                //  like we were when this happened.  The assumption
                //  here is that the traced thread won't hit the breakpoint
                //  while it's removed, which I believe to be true, because
                //  I don't think a context switch can occur during a single
                //  step operation.
                //
                //  For extra added fun, it's possible to execute interrupt
                //  routines IN THE SAME THREAD!!!  That's why we need to keep
                //  the stack pointer as well as the thread address: the APC
                //  code can result in pushing on the stack and doing a call
                //  that's really part on an interrupt service routine in the
                //  context of the current thread.  Lovely, isn't it?
                //

                WatchStepOverSuspended = TRUE;
                KdpDeleteBreakpoint(WatchStepOverHandle);
                ContextRecord->EFlags |= 0x100L; // Set trace flag
                return TRUE; // single step "non-traced" thread
            }

            //
            //  we're in the thread we started in; resume in single-step mode
            //  to continue the trace.
            //

            WatchStepOver = FALSE;
            KdpDeleteBreakpoint(WatchStepOverHandle);
            ContextRecord->EFlags |= 0x100L; // back to single step mode
            AfterSC = TRUE; // put us into the regular watchStep code

        } else {

            for ( BpNum = 0; BpNum < (LONG) KdpNumInternalBreakpoints; BpNum++ ) {
                if ( !(KdpInternalBPs[BpNum].Flags &
                       (DBGKD_INTERNAL_BP_FLAG_INVALID |
                        DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) &&
                     ((ULONG_PTR)KdpInternalBPs[BpNum].Addr == pc) ) {
                    break;
                }
            }

            if ( BpNum < (LONG) KdpNumInternalBreakpoints ) {

                //
                //  This is an internal monitoring breakpoint.
                //  Restore the instruction and start in single-step
                //  mode so that we can retore the breakpoint once the
                //  instruction executes, or continue stepping if this isn't
                //  a COUNTONLY breakpoint.
                //

                KdpProcessInternalBreakpoint( BpNum );
                KdpInternalBPs[BpNum].Thread = (PVOID)KeGetCurrentThread();
                IntBPsSkipping ++;

                KdpSuspendAllBreakpoints();

                ContextRecord->EFlags |= 0x100L;  // Set trace flag
                if (!(KdpInternalBPs[BpNum].Flags &
                        DBGKD_INTERNAL_BP_FLAG_COUNTONLY)) {
                    KdpInternalBPs[BpNum].ReturnAddress =
                                    KdpGetReturnAddress( ContextRecord );
                }
                return TRUE;
            }
        }
    } /* if breakpoint */

//  if (AfterSC) {
//      DPRINT(( "1: KdpCurrentSymbolStart %x  KdpCurrentSymbolEnd %x\n", KdpCurrentSymbolStart, KdpCurrentSymbolEnd ));
//  }

    if ((AfterSC || ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) &&
        KdpCurrentSymbolStart != 0 &&
        ((KdpCurrentSymbolEnd == 0 && ContextRecord->Esp <= InitialSP) ||
         (KdpCurrentSymbolStart <= pc && pc < KdpCurrentSymbolEnd))) {
        ULONG lc;
        BOOLEAN IsSpecialCall;

        //
        //  We've taken a step trace, but are still executing in the current
        //  function.  Remember that we executed an instruction and see if the
        //  instruction changes the call level.
        //

        lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
        InstructionsTraced++;
        CallLevelChange += lc;

        //
        //  See if instruction is a transfer to a special routine, one that we
        //  cannot trace through since it may swap contexts
        //

        if (IsSpecialCall) {

//  DPRINT( ("2: pc=%x, level change %d\n", pc, lc) );

            //
            //  We are about to transfer to a special call routine.  Since we
            //  cannot trace through this routine, we execute it atomically by
            //  setting a breakpoint at the next logical offset.
            //
            //  Note in the case of an indirect jump to a special call routine, the
            //  level change will be -1 and the next offset will be the ULONG that's
            //  on the top of the stack.
            //
            //  However, we've already adjusted the level based on this
            //  instruction.  We need to undo this except for the magic -1 call.
            //

            if (lc != -1) {
                CallLevelChange -= lc;
            }

            //
            //  Set up for stepping over a procedure
            //

            WatchStepOver = TRUE;
            WatchStepOverBreakAddr = KdpGetCallNextOffset( pc, ContextRecord );
            WSOThread = (PVOID)KeGetCurrentThread( );
            WSOEsp = ContextRecord->Esp;

            //
            //  Establish the breakpoint
            //

            WatchStepOverHandle = KdpAddBreakpoint( (PVOID)WatchStepOverBreakAddr );


            //
            //  Note that we are continuing rather than tracing and rely on hitting
            //  the breakpoint in the current thread context to resume the watch
            //  action.
            //

            ContextRecord->EFlags &= ~0x100L;
            return TRUE;
        }

        //
        //  Resume execution with the trace flag set.  Avoid going over the wire to
        //  the remote debugger.
        //

        ContextRecord->EFlags |= 0x100L;  // Set trace flag

        return TRUE;
    }

    if ((AfterSC || (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)) &&
        (KdpCurrentSymbolStart != 0)) {
        //
        // We're WatchTracing, but have just changed symbol range.
        // Fill in the call record and return to the debugger if
        // either we're full or the pc is outside of the known
        // symbol scopes.  Otherwise, resume stepping.
        //
        int lc;
        BOOLEAN IsSpecialCall;

        InstructionsTraced++; // don't forget to count the call/ret instruction.

//  if (AfterSC) {
//      DPRINT(( "3: InstrCountInternal: %x\n", InstrCountInternal ));
//  }

        if (InstrCountInternal) {

            // We've just finished processing a non-COUNTONLY breakpoint.
            // Record the appropriate data and resume full speed execution.

            if (SkippingWhichBP((PVOID)KeGetCurrentThread(),&SkippedBPNum)) {

                KdpInternalBPs[SkippedBPNum].Calls++;


                if (KdpInternalBPs[SkippedBPNum].MinInstructions > InstructionsTraced) {
                    KdpInternalBPs[SkippedBPNum].MinInstructions = InstructionsTraced;
                }
                if (KdpInternalBPs[SkippedBPNum].MaxInstructions < InstructionsTraced) {
                    KdpInternalBPs[SkippedBPNum].MaxInstructions = InstructionsTraced;
                }
                KdpInternalBPs[SkippedBPNum].TotalInstructions += InstructionsTraced;

                KdpInternalBPs[SkippedBPNum].Thread = 0;

                IntBPsSkipping--;
                KdpRestoreAllBreakpoints();

                if (KdpInternalBPs[SkippedBPNum].Flags &
                    DBGKD_INTERNAL_BP_FLAG_DYING) {
                    KdpDeleteBreakpoint(KdpInternalBPs[SkippedBPNum].Handle);
                    KdpInternalBPs[SkippedBPNum].Flags |=
                        DBGKD_INTERNAL_BP_FLAG_INVALID; // bye, bye
                }
            }

            KdpCurrentSymbolStart = 0;
            InstrCountInternal = FALSE;
            ContextRecord->EFlags &= ~0x100L; // clear trace flag
            return TRUE; // Back to normal execution.
        }

        if (TraceDataRecordCallInfo( InstructionsTraced, CallLevelChange, pc)) {

            //
            //  Everything was cool internally.  We can keep executing without
            //  going back to the remote debugger.
            //
            //  We have to compute lc after calling
            //  TraceDataRecordCallInfo, because LevelChange relies on
            //  KdpCurrentSymbolStart and KdpCurrentSymbolEnd corresponding to
            //  the pc.
            //

            lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
            InstructionsTraced = 0;
            CallLevelChange = lc;

            //
            //  See if instruction is a transfer to a special routine, one that we
            //  cannot trace through since it may swap contexts
            //

            if (IsSpecialCall) {

//  DPRINT(( "4: pc=%x, level change %d\n", pc, lc));

                //
                //  We are about to transfer to a special call routine.  Since we
                //  cannot trace through this routine, we execute it atomically by
                //  setting a breakpoint at the next logical offset.
                //
                //  Note in the case of an indirect jump to a special call routine, the
                //  level change will be -1 and the next offset will be the ULONG that's
                //  on the top of the stack.
                //
                //  However, we've already adjusted the level based on this
                //  instruction.  We need to undo this except for the magic -1 call.
                //

                if (lc != -1) {
                    CallLevelChange -= lc;
                }

                //
                //  Set up for stepping over a procedure
                //

                WatchStepOver = TRUE;
                WSOThread = (PVOID)KeGetCurrentThread();

                //
                //  Establish the breakpoint
                //

                WatchStepOverHandle =
                    KdpAddBreakpoint( (PVOID)KdpGetCallNextOffset( pc, ContextRecord ));

                //
                //  Resume execution with the trace flag set.  Avoid going over the wire to
                //  the remote debugger.
                //

                ContextRecord->EFlags &= ~0x100L;
                return TRUE;
            }

            ContextRecord->EFlags |= 0x100L; // Set trace flag
            return TRUE; // Off we go
        }

        lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
        InstructionsTraced = 0;
        CallLevelChange = lc;

        // We need to go back to the remote debugger.  Just fall through.

        if ((lc != 0) && IsSpecialCall) {
            // We're hosed
            DPRINT(( "Special call on first entry to symbol scope @ %x\n", pc ));
        }
    }

    SymbolRecorded = FALSE;
    oldpc = pc;

    return FALSE;
}

#endif // defined(_X86_)

VOID
KdpSetCommonState(
    IN ULONG NewState,
    IN PCONTEXT ContextRecord,
    OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange
    )
{
    PCHAR PcMemory;
    ULONG InstrCount;
    PUCHAR InstrStream;
    
    WaitStateChange->NewState = NewState;
    WaitStateChange->ProcessorLevel = KeProcessorLevel;
    WaitStateChange->Processor = (USHORT)KeGetCurrentProcessorNumber();
    WaitStateChange->NumberProcessors = (ULONG)KeNumberProcessors;
    WaitStateChange->Thread = (ULONG64)(LONG64)(LONG_PTR)KeGetCurrentThread();
    PcMemory = (PCHAR)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
    WaitStateChange->ProgramCounter = (ULONG64)(LONG64)(LONG_PTR)PcMemory;

    RtlZeroMemory(&WaitStateChange->AnyControlReport,
                  sizeof(WaitStateChange->AnyControlReport));
    
    //
    // Copy instruction stream immediately following location of event.
    //

    InstrStream = WaitStateChange->ControlReport.InstructionStream;
    KdpCopyFromPtr(InstrStream, PcMemory, DBGKD_MAXSTREAM, &InstrCount);
    WaitStateChange->ControlReport.InstructionCount = (USHORT)InstrCount;

    //
    // Clear breakpoints in copied area.
    // If there were any breakpoints cleared, recopy the instruction area
    // without them.
    //

    if (KdpDeleteBreakpointRange(PcMemory, PcMemory + InstrCount - 1)) {
        KdpCopyFromPtr(InstrStream, PcMemory, InstrCount, &InstrCount);
    }
}

BOOLEAN
KdpSwitchProcessor (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )
{
    BOOLEAN Status;

    //
    // Save port state
    //

    KdSave(FALSE);

    //
    // Process state change for this processor
    //

    Status = KdpReportExceptionStateChange (
                ExceptionRecord,
                ContextRecord,
                SecondChance
                );

    //
    // Restore port state and return status
    //

    KdRestore(FALSE);
    return Status;
}

BOOLEAN
KdpReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine sends an exception state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    SecondChance - Supplies a boolean value that determines whether this is
        the first or second chance for the exception.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
    KCONTINUE_STATUS Status;

#if i386
    if (KdpCheckTracePoint(ExceptionRecord,ContextRecord)) return TRUE;
#endif

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        KdpSetCommonState(DbgKdExceptionStateChange, ContextRecord,
                          &WaitStateChange);
        
        if (sizeof(EXCEPTION_RECORD) ==
            sizeof(WaitStateChange.u.Exception.ExceptionRecord)) {
            KdpQuickMoveMemory((PCHAR)&WaitStateChange.u.Exception.ExceptionRecord,
                               (PCHAR)ExceptionRecord,
                               sizeof(EXCEPTION_RECORD));
        } else {
            ExceptionRecord32To64((PEXCEPTION_RECORD32)ExceptionRecord,
                                  &WaitStateChange.u.Exception.ExceptionRecord);
        }

        WaitStateChange.u.Exception.FirstChance = !SecondChance;

        KdpSetStateChange(&WaitStateChange,
                          ExceptionRecord,
                          ContextRecord,
                          SecondChance
                          );

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

#if i386
        //
        // Construct the wait state change data and data descriptor.
        //

        DumpTraceData(&MessageData);
#else
        MessageData.Length = 0;
#endif

        //
        // Send packet to the kernel debugger on the host machine,
        // wait for answer.
        //

        Status = KdpSendWaitContinue(
                    PACKET_TYPE_KD_STATE_CHANGE64,
                    &MessageHeader,
                    &MessageData,
                    ContextRecord
                    );

    } while (Status == ContinueProcessorReselected) ;

    return (BOOLEAN) Status;
}


BOOLEAN
KdpReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN BOOLEAN UnloadSymbols,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine sends a load symbols state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    PathName - Supplies a pointer to the pathname of the image whose
        symbols are to be loaded.

    BaseOfDll - Supplies the base address where the image was loaded.

    ProcessId - Unique 32-bit identifier for process that is using
        the symbols.  -1 for system process.

    CheckSum - Unique 32-bit identifier from image header.

    UnloadSymbol - TRUE if the symbols that were previously loaded for
        the named image are to be unloaded from the debugger.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{

    PSTRING AdditionalData;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
    KCONTINUE_STATUS Status;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        KdpSetCommonState(DbgKdLoadSymbolsStateChange, ContextRecord,
                          &WaitStateChange);
        KdpSetContextState(&WaitStateChange, ContextRecord);
        WaitStateChange.u.LoadSymbols.UnloadSymbols = UnloadSymbols;
        WaitStateChange.u.LoadSymbols.BaseOfDll = (ULONG64)SymbolInfo->BaseOfDll;
        WaitStateChange.u.LoadSymbols.ProcessId = (ULONG) SymbolInfo->ProcessId;
        WaitStateChange.u.LoadSymbols.CheckSum = SymbolInfo->CheckSum;
        WaitStateChange.u.LoadSymbols.SizeOfImage = SymbolInfo->SizeOfImage;
        if (ARGUMENT_PRESENT( PathName )) {
            KdpCopyFromPtr(KdpPathBuffer,
                           PathName->Buffer,
                           PathName->Length,
                           &WaitStateChange.u.LoadSymbols.PathNameLength);
            WaitStateChange.u.LoadSymbols.PathNameLength++;

            MessageData.Buffer = (PCHAR) KdpPathBuffer;
            MessageData.Length = (USHORT)WaitStateChange.u.LoadSymbols.PathNameLength;
            MessageData.Buffer[MessageData.Length-1] = '\0';
            AdditionalData = &MessageData;
        } else {
            WaitStateChange.u.LoadSymbols.PathNameLength = 0;
            AdditionalData = NULL;
        }

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

        //
        // Send packet to the kernel debugger on the host machine, wait
        // for the reply.
        //

        Status = KdpSendWaitContinue(
                    PACKET_TYPE_KD_STATE_CHANGE64,
                    &MessageHeader,
                    AdditionalData,
                    ContextRecord
                    );

    } while (Status == ContinueProcessorReselected);

    return (BOOLEAN) Status;
}


VOID
KdpReportCommandStringStateChange (
    IN PSTRING Name,
    IN PSTRING Command,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine sends a command string packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    Name - Identifies the originator of the command.

    Command - Command string.

    ContextRecord - Context information.

Return Value:

    None.

--*/

{

    STRING MessageData;
    STRING MessageHeader;
    DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
    KCONTINUE_STATUS Status;
    ULONG Length, Copied;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        KdpSetCommonState(DbgKdCommandStringStateChange, ContextRecord,
                          &WaitStateChange);
        KdpSetContextState(&WaitStateChange, ContextRecord);
        RtlZeroMemory(&WaitStateChange.u.CommandString,
                      sizeof(WaitStateChange.u.CommandString));

        //
        // Transfer the string data into the message buffer.
        // The name is just a simple identifier so limit
        // it to a relatively short length.
        //

        MessageData.Buffer = (PCHAR) KdpMessageBuffer;

        if (Name->Length > 127) {
            Length = 127;
        } else {
            Length = Name->Length;
        }
        
        KdpCopyFromPtr(MessageData.Buffer, Name->Buffer, Length, &Copied);
        MessageData.Length = (USHORT)Copied + 1;
        MessageData.Buffer[MessageData.Length - 1] = '\0';

        Length = PACKET_MAX_SIZE - sizeof(WaitStateChange) -
            MessageData.Length;
        if (Command->Length < Length) {
            Length = Command->Length;
        }
        KdpCopyFromPtr(MessageData.Buffer + MessageData.Length,
                       Command->Buffer, Length, &Copied);
        Length = Copied + 1;

        MessageData.Length = (USHORT) (MessageData.Length + Length);

        MessageData.Buffer[MessageData.Length - 1] = '\0';
        
        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

        //
        // Send packet to the kernel debugger on the host machine, wait
        // for the reply.
        //

        Status = KdpSendWaitContinue(
                    PACKET_TYPE_KD_STATE_CHANGE64,
                    &MessageHeader,
                    &MessageData,
                    ContextRecord
                    );

    } while (Status == ContinueProcessorReselected);
}


VOID
KdpReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a read physical memory
    state manipulation message. Its function is to read physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    ULONG Length;
    STRING MessageHeader;
    ULONG MmFlags;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // make sure that nothing but a read memory message was transmitted
    //

    ASSERT(AdditionalData->Length == 0);

    //
    // Trim transfer count to fit in a single message
    //

    if (a->TransferCount > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    } else {
        Length = a->TransferCount;
    }

    //
    // Initially there was no way to control the caching
    // flags for physical memory access.  Such control
    // is necessary for robust physical access, though,
    // as the proper kind of access must be made to avoid
    // breaking the processor TBs.  Rather than create a
    // new protocol request, the ActualBytes field
    // has been overridden to pass flags on input.  Prior
    // versions of the debugger set this to zero so this
    // is a compatible change.
    //

    MmFlags = MMDBG_COPY_PHYSICAL | MMDBG_COPY_UNSAFE;
    switch(a->ActualBytesRead)
    {
    case DBGKD_CACHING_CACHED:
        MmFlags |= MMDBG_COPY_CACHED;
        break;
    case DBGKD_CACHING_UNCACHED:
        MmFlags |= MMDBG_COPY_UNCACHED;
        break;
    case DBGKD_CACHING_WRITE_COMBINED:
        MmFlags |= MMDBG_COPY_WRITE_COMBINED;
        break;
    }
    
    m->ReturnStatus =
        KdpCopyMemoryChunks(a->TargetBaseAddress,
                            AdditionalData->Buffer,
                            Length,
                            0,
                            MmFlags,
                            &Length);

    AdditionalData->Length = (USHORT)Length;
    a->ActualBytesRead = Length;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}



VOID
KdpWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a write physical memory
    state manipulation message. Its function is to write physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    STRING MessageHeader;
    ULONG MmFlags;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    // See ReadPhysical for an explanation of the ActualBytes usage.
    MmFlags = MMDBG_COPY_PHYSICAL | MMDBG_COPY_WRITE | MMDBG_COPY_UNSAFE;
    switch(a->ActualBytesWritten)
    {
    case DBGKD_CACHING_CACHED:
        MmFlags |= MMDBG_COPY_CACHED;
        break;
    case DBGKD_CACHING_UNCACHED:
        MmFlags |= MMDBG_COPY_UNCACHED;
        break;
    case DBGKD_CACHING_WRITE_COMBINED:
        MmFlags |= MMDBG_COPY_WRITE_COMBINED;
        break;
    }

    m->ReturnStatus =
        KdpCopyMemoryChunks(a->TargetBaseAddress,
                            AdditionalData->Buffer,
                            a->TransferCount,
                            0,
                            MmFlags,
                            &a->ActualBytesWritten);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a read control space state
    manipulation message.  Its function is to read implementation
    specific system data.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    STRING MessageHeader;
    ULONG Length;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    if (a->TransferCount > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    } else {
        Length = a->TransferCount;
    }

    m->ReturnStatus = KdpSysReadControlSpace(m->Processor,
                                             a->TargetBaseAddress,
                                             AdditionalData->Buffer,
                                             Length, &Length);

    AdditionalData->Length = (USHORT)Length;
    a->ActualBytesRead = Length;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write control space state
    manipulation message.  Its function is to write implementation
    specific system data.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    ULONG Length;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    m->ReturnStatus = KdpSysWriteControlSpace(m->Processor,
                                              a->TargetBaseAddress,
                                              AdditionalData->Buffer,
                                              AdditionalData->Length,
                                              &Length);

    a->ActualBytesWritten = Length;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a read io space state
    manipulation message.  Its function is to read system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;
    ULONG Length;

#if !DBG
    UNREFERENCED_PARAMETER(AdditionalData);
#endif

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    // Zero-fill the entire value so that shorter reads
    // do not leave unset bytes.
    a->DataValue = 0;

    m->ReturnStatus = KdpSysReadIoSpace(Isa, 0, 1, a->IoAddress,
                                        &a->DataValue, a->DataSize, &Length);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write io space state
    manipulation message.  Its function is to write to system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;
    ULONG Length;

#if !DBG
    UNREFERENCED_PARAMETER(AdditionalData);
#endif

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = KdpSysWriteIoSpace(Isa, 0, 1, a->IoAddress,
                                         &a->DataValue, a->DataSize, &Length);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpReadIoSpaceExtended(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a read io space extended state
    manipulation message.  Its function is to read system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO_EXTENDED64 a = &m->u.ReadWriteIoExtended;
    STRING MessageHeader;
    ULONG Length;

#if !DBG
    UNREFERENCED_PARAMETER(AdditionalData);
#endif

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    // Zero-fill the entire value so that shorter reads
    // do not leave unset bytes.
    a->DataValue = 0;

    m->ReturnStatus = KdpSysReadIoSpace(a->InterfaceType, a->BusNumber,
                                        a->AddressSpace, a->IoAddress,
                                        &a->DataValue, a->DataSize, &Length);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpWriteIoSpaceExtended(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write io space extended state
    manipulation message.  Its function is to write to system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO_EXTENDED64 a = &m->u.ReadWriteIoExtended;
    STRING MessageHeader;
    ULONG Length;

#if !DBG
    UNREFERENCED_PARAMETER(AdditionalData);
#endif

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = KdpSysWriteIoSpace(a->InterfaceType, a->BusNumber,
                                         a->AddressSpace, a->IoAddress,
                                         &a->DataValue, a->DataSize, &Length);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpReadMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a read MSR
    manipulation message.  Its function is to read the MSR.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_MSR a = &m->u.ReadWriteMsr;
    STRING MessageHeader;
    ULARGE_INTEGER l;

    UNREFERENCED_PARAMETER(Context);
#if !DBG
    UNREFERENCED_PARAMETER(AdditionalData);
#endif

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = KdpSysReadMsr(a->Msr, &l.QuadPart);

    a->DataValueLow  = l.LowPart;
    a->DataValueHigh = l.HighPart;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}

VOID
KdpWriteMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write of a MSR
    manipulation message.  Its function is to write to the MSR

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_MSR a = &m->u.ReadWriteMsr;
    STRING MessageHeader;
    ULARGE_INTEGER l;

    UNREFERENCED_PARAMETER(Context);
#if !DBG
    UNREFERENCED_PARAMETER(AdditionalData);
#endif

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    l.HighPart = a->DataValueHigh;
    l.LowPart = a->DataValueLow;

    m->ReturnStatus = KdpSysWriteMsr(a->Msr, &l.QuadPart);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}

VOID
KdpGetBusData (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a get bus data state
    manipulation message.  Its function is to read I/O configuration
    space.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_GET_SET_BUS_DATA a = &m->u.GetSetBusData;
    ULONG Length;
    STRING MessageHeader;

    UNREFERENCED_PARAMETER (Context);

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    //
    // Trim length to fit in a single message
    //

    if (a->Length > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    } else {
        Length = a->Length;
    }

    m->ReturnStatus = KdpSysReadBusData(a->BusDataType, a->BusNumber,
                                        a->SlotNumber, a->Offset,
                                        AdditionalData->Buffer,
                                        Length, &Length);

    a->Length = Length;
    AdditionalData->Length = (USHORT)Length;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
}

VOID
KdpSetBusData (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a set bus data state
    manipulation message.  Its function is to write I/O configuration
    space.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_GET_SET_BUS_DATA a = &m->u.GetSetBusData;
    ULONG Length;
    STRING MessageHeader;

    UNREFERENCED_PARAMETER (Context);

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    m->ReturnStatus = KdpSysWriteBusData(a->BusDataType, a->BusNumber,
                                         a->SlotNumber, a->Offset,
                                         AdditionalData->Buffer,
                                         a->Length, &Length);

    a->Length = Length;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}



#if i386
VOID
KdpProcessInternalBreakpoint (
    ULONG BreakpointNumber
    )
{
    if ( !(KdpInternalBPs[BreakpointNumber].Flags &
           DBGKD_INTERNAL_BP_FLAG_COUNTONLY) ) {
        return;     // We only deal with COUNTONLY breakpoints
    }

    //
    // We've hit a real internal breakpoint; make sure the timeout is
    // kicked off.
    //

    if ( !BreakPointTimerStarted ) { // ok, maybe there's a prettier way to do this.
        KeInitializeDpc(
            &InternalBreakpointCheckDpc,
            &InternalBreakpointCheck,
            NULL
            );
        KeInitializeTimer( &InternalBreakpointTimer );
        // KeSetTimer can only be called at <= DISPATCH_LEVEL
        // so just queue the timer DPC routine directly for
        // the initial check.
        KeInsertQueueDpc(&InternalBreakpointCheckDpc, NULL, NULL);
        BreakPointTimerStarted = TRUE;
    }

    KdpInternalBPs[BreakpointNumber].Calls++;

} // KdpProcessInternalBreakpoint
#endif


VOID
KdpGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function returns to the caller a general information packet
    that contains useful information to a debugger.  This packet is also
    used for a debugger to determine if the writebreakpointex and
    readbreakpointex apis are available.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{
    STRING messageHeader;


    messageHeader.Length = sizeof(*m);
    messageHeader.Buffer = (PCHAR)m;

    KdpSysGetVersion(&m->u.GetVersion64);

    //
    // the usual stuff
    //
    m->ReturnStatus = STATUS_SUCCESS;
    m->ApiNumber = DbgKdGetVersionApi;

    KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &messageHeader,
                 NULL,
                 &KdpContext
                 );

    return;
} // KdGetVersion


NTSTATUS
KdpNotSupported(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This routine returns STATUS_UNSUCCESSFUL to the debugger

Arguments:

    m - Supplies a DBGKD_MANIPULATE_STATE64 struct to answer with

Return Value:

    0, to indicate that the system should not continue

--*/

{
    STRING          MessageHeader;

    //
    // setup packet
    //
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    m->ReturnStatus = STATUS_UNSUCCESSFUL;

    //
    // send back our response
    //
    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );

    //
    // return the caller's continue status value.  if this is a non-zero
    // value the system is continued using this value as the continuestatus.
    //
    return 0;
} // KdpNotSupported


VOID
KdpCauseBugCheck(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This routine causes a bugcheck.  It is used for testing the debugger.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER (m);

    KeBugCheckEx( MANUALLY_INITIATED_CRASH, 0, 0, 0, 0 );

} // KdCauseBugCheck


NTSTATUS
KdpWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state 'ex'
    manipulation message.  Its function is to clear breakpoints, write
    new breakpoints, and continue the target system.  The clearing of
    breakpoints is conditional based on the presence of breakpoint handles.
    The setting of breakpoints is conditional based on the presence of
    valid, non-zero, addresses.  The continueing of the target system
    is conditional based on a non-zero continuestatus.

    This api allows a debugger to clear breakpoints, add new breakpoint,
    and continue the target system all in one api packet.  This reduces the
    amount of traffic across the wire and greatly improves source stepping.


Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_BREAKPOINTEX       a = &m->u.BreakPointEx;
    PDBGKD_WRITE_BREAKPOINT64 b;
    STRING                    MessageHeader;
    ULONG                     i;
    ULONG                     Size;
    DBGKD_WRITE_BREAKPOINT64  BpBuf[BREAKPOINT_TABLE_SIZE];

    UNREFERENCED_PARAMETER (Context);

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //
    if (AdditionalData->Length !=
        a->BreakPointCount * sizeof(DBGKD_WRITE_BREAKPOINT64))
    {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        KdSendPacket(
            PACKET_TYPE_KD_STATE_MANIPULATE,
            &MessageHeader,
            AdditionalData,
            &KdpContext
            );
        return m->ReturnStatus;
    }

    KdpCopyFromPtr(BpBuf,
                   AdditionalData->Buffer,
                   a->BreakPointCount * sizeof(DBGKD_WRITE_BREAKPOINT64),
                   &Size);

    if (Size == a->BreakPointCount * sizeof(DBGKD_WRITE_BREAKPOINT64))
    {
        m->ReturnStatus = STATUS_SUCCESS;
    }
    else
    {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        KdSendPacket(
            PACKET_TYPE_KD_STATE_MANIPULATE,
            &MessageHeader,
            AdditionalData,
            &KdpContext
            );
        return m->ReturnStatus;
    }

    //
    // loop thru the breakpoint handles passed in from the debugger and
    // clear any breakpoint that has a non-zero handle
    //
    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointHandle) {
            if (!KdpDeleteBreakpoint(b->BreakPointHandle)) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }
            b->BreakPointHandle = 0;
        }
    }

    //
    // loop thru the breakpoint addesses passed in from the debugger and
    // add any new breakpoints that have a non-zero address
    //
    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointAddress) {
            b->BreakPointHandle = KdpAddBreakpoint( (PVOID)(ULONG_PTR)b->BreakPointAddress );
            if (!b->BreakPointHandle) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }
        }
    }

    //
    // send back our response
    //

    KdpCopyToPtr(AdditionalData->Buffer,
                 BpBuf,
                 a->BreakPointCount * sizeof(DBGKD_WRITE_BREAKPOINT64),
                 &Size);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );

    //
    // return the caller's continue status value.  if this is a non-zero
    // value the system is continued using this value as the continuestatus.
    //
    return a->ContinueStatus;
}


VOID
KdpRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state 'ex'
    manipulation message.  Its function is to clear a list of breakpoints.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_BREAKPOINTEX         a = &m->u.BreakPointEx;
    PDBGKD_RESTORE_BREAKPOINT   b;
    STRING                      MessageHeader;
    ULONG                       i;
    ULONG                       Size;
    DBGKD_RESTORE_BREAKPOINT    BpBuf[BREAKPOINT_TABLE_SIZE];

    UNREFERENCED_PARAMETER (Context);

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //
    if (AdditionalData->Length !=
                       a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT))
    {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
    else
    {
        KdpCopyFromPtr(BpBuf,
                       AdditionalData->Buffer,
                       a->BreakPointCount * sizeof(DBGKD_RESTORE_BREAKPOINT),
                       &Size);

        if (Size == a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT))
        {
            m->ReturnStatus = STATUS_SUCCESS;

            //
            // loop thru the breakpoint handles passed in from the debugger and
            // clear any breakpoint that has a non-zero handle
            //
            b = BpBuf;
            for (i=0; i<a->BreakPointCount; i++,b++) {
                if (!KdpDeleteBreakpoint(b->BreakPointHandle)) {
                    m->ReturnStatus = STATUS_UNSUCCESSFUL;
                }
            }
        }
        else
        {
            m->ReturnStatus = STATUS_UNSUCCESSFUL;
        }
    }

    //
    // send back our response
    //
    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
}

NTSTATUS
KdDisableDebugger(
    VOID
    )
/*++

Routine Description:

    This function is called to disable the debugger.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/

{
    KIRQL oldIrql;
    NTSTATUS Status;

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
    KdpPortLock();

    if (!KdDisableCount) {

        KdPreviouslyEnabled = KdDebuggerEnabled && (!KdPitchDebugger);

        if (KdPreviouslyEnabled &&
            !NT_SUCCESS(Status = KdpAllowDisable())) {
            KdpPortUnlock();
            KeLowerIrql(oldIrql);
            return Status;
        }
        
        if (KdDebuggerEnabled) {

            KdpSuspendAllBreakpoints();
            KiDebugRoutine = KdpStub;
            KdDebuggerEnabled = FALSE ;
            SharedUserData->KdDebuggerEnabled = 0;
        }
    }
    
    KdDisableCount++;
    
    KdpPortUnlock();
    KeLowerIrql(oldIrql);
    return STATUS_SUCCESS;
}

NTSTATUS
KdEnableDebugger(
   VOID
   )
/*++

Routine Description:

    This function is called to reenable the debugger after a call to
    KdDisableDebugger.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    KIRQL oldIrql ;

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql) ;
    KdpPortLock();

    if (KdDisableCount == 0) {
        KdpPortUnlock();
        KeLowerIrql(oldIrql);
        return STATUS_INVALID_PARAMETER;
    }
        
    KdDisableCount-- ;

    if (!KdDisableCount) {
        if (KdPreviouslyEnabled) {

            //
            // Ugly HACKHACK - Make sure the timers aren't reset.
            //
            PoHiberInProgress = TRUE ;
            KdInitSystem(0, NULL);
            KdpRestoreAllBreakpoints();
            PoHiberInProgress = FALSE ;
        }
    }
    
    KdpPortUnlock();
    KeLowerIrql(oldIrql);
    return STATUS_SUCCESS;
}


VOID
KdpSearchMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function implements a memory pattern searcher.  This will
    find an instance of a pattern that begins in the range
    SearchAddress..SearchAddress+SearchLength.  The pattern may
    end outside of the range.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies the pattern to search for

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PUCHAR Pattern = (PUCHAR) AdditionalData->Buffer;
    ULONG_PTR StartAddress = (ULONG_PTR)m->u.SearchMemory.SearchAddress;
    ULONG_PTR EndAddress = (ULONG_PTR)(StartAddress + m->u.SearchMemory.SearchLength);
    ULONG PatternLength = m->u.SearchMemory.PatternLength;

    STRING MessageHeader;
    ULONG MaskIndex;
    PUCHAR PatternTail;
    ULONG_PTR DataTail;
    ULONG TailLength;
    ULONG Data;
    ULONG FirstWordPattern[4];
    ULONG FirstWordMask[4];
    UCHAR DataTailVal;

    UNREFERENCED_PARAMETER (Context);

    //
    // On failure, return STATUS_NO_MORE_ENTRIES.  DON'T RETURN
    // STATUS_UNSUCCESSFUL!  That return status indicates that the
    // operation is not supported, and the debugger will fall back
    // to a debugger-side search.
    //

    m->ReturnStatus = STATUS_NO_MORE_ENTRIES;

    //
    // Do a fast search for the beginning of the pattern
    //

    if (PatternLength > 3) {
        FirstWordMask[0] = 0xffffffff;
    } else {
        FirstWordMask[0] = 0xffffffff >> (8*(4-PatternLength));
    }

    FirstWordMask[1] = FirstWordMask[0] << 8;
    FirstWordMask[2] = FirstWordMask[1] << 8;
    FirstWordMask[3] = FirstWordMask[2] << 8;

    FirstWordPattern[0] = 0;
    KdpQuickMoveMemory((PCHAR)FirstWordPattern,
                       (PCHAR)Pattern,
                       PatternLength < 5 ? PatternLength : 4);

    FirstWordPattern[1] = FirstWordPattern[0] << 8;
    FirstWordPattern[2] = FirstWordPattern[1] << 8;
    FirstWordPattern[3] = FirstWordPattern[2] << 8;


/*
{
    int i;
    for (i = 0; i < (int)PatternLength; i++) {
        KdpDprintf("%08x: %02x\n", &Pattern[i], Pattern[i]);
    }
    for (i = 0; i < 4; i++) {
        KdpDprintf("%d: %08x %08x\n", i, FirstWordPattern[i], FirstWordMask[i]);
    }
}
*/



    //
    // Get starting mask
    //

    MaskIndex = (ULONG) (StartAddress & 3);
    StartAddress = StartAddress & ~3;

    while (StartAddress < EndAddress) {

        // Get the current data DWORD.  StartAddress is
        // properly aligned and we only need the one DWORD
        // so we can directly call MmDbgCopyMemory.
        if (!NT_SUCCESS(MmDbgCopyMemory(StartAddress, &Data, 4,
                                        MMDBG_COPY_UNSAFE))) {
//KdpDprintf("\n%08x: Inaccessible\n", StartAddress);
            StartAddress += 4;
            MaskIndex = 0;
            continue;
        }
        
        //
        // search for a match in each of the 4 starting positions
        //

//KdpDprintf("\n%08x: %08x ", StartAddress, Data);

        for ( ; MaskIndex < 4; MaskIndex++) {
//KdpDprintf(" %d", MaskIndex);

            if ( (Data & FirstWordMask[MaskIndex]) == FirstWordPattern[MaskIndex]) {

                //
                // first word matched
                //

                if ( (4-MaskIndex) >= PatternLength ) {

                    //
                    // string is all in this word; good match
                    //
//KdpDprintf(" %d hit, complete\n", MaskIndex);

                    m->u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
                    m->ReturnStatus = STATUS_SUCCESS;
                    goto done;

                } else {

                    //
                    // string is longer; see if tail matches
                    //
//KdpDprintf(" %d hit, check tail\n", MaskIndex);

                    PatternTail = Pattern + 4 - MaskIndex;
                    DataTail = StartAddress + 4;
                    TailLength = PatternLength - 4 + MaskIndex;

//KdpDprintf("Pattern == %08x\n", Pattern);
//KdpDprintf("PatternTail == %08x\n", PatternTail);
//KdpDprintf("DataTail == %08x\n", DataTail);

                    while (TailLength) {
                        if (!NT_SUCCESS(MmDbgCopyMemory(DataTail,
                                                        &DataTailVal,
                                                        1,
                                                        MMDBG_COPY_UNSAFE))) {
//KdpDprintf("Tail %08x: Inaccessible\n", DataTail);
                            break;
                        }

//KdpDprintf("D: %02x  P: %02x\n", DataTailVal, *PatternTail);

                        if (DataTailVal != *PatternTail) {
//KdpDprintf("Tail failed at %08x\n", DataTail);
                            break;
                        } else {
                            DataTail++;
                            PatternTail++;
                            TailLength--;
                        }
                    }

                    if (TailLength == 0) {

                        //
                        // A winner
                        //

                        m->u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
                        m->ReturnStatus = STATUS_SUCCESS;
                        goto done;

                    }
                }
            }
        }

        StartAddress += 4;
        MaskIndex = 0;
    }

done:
//KdpDprintf("\n");
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );

}


VOID
KdpCheckLowMemory(
    IN PDBGKD_MANIPULATE_STATE64 Message
    )

/*++

Routine Description:


Arguments:

    Message - Supplies the state manipulation message.

Return Value:

    None.

Description:

    This function gets called when the !chklowmem
    debugger extension is used.

--*/

{
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*Message);
    MessageHeader.Buffer = (PCHAR)Message;

    Message->ReturnStatus = KdpSysCheckLowMemory(MMDBG_COPY_UNSAFE);

    //
    // Acknowledge the packet received.
    //

    KdSendPacket (
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}



//
// !search support routines
//



ULONG
KdpSearchHammingDistance (
    ULONG_PTR Left,
    ULONG_PTR Right
    )
/*++

Routine Description:

    This routine computes the Hamming distance (# of positions where the
    values are different).

    If this function becomes a bottleneck we should switch to a function
    table version.

Arguments:

    Left, Right operand.

Return Value:

    Hamming distance.

Environment:

    Any.

--*/

{
    ULONG_PTR Value;
    ULONG Index;
    ULONG Distance;

    Value = Left ^ Right;
    Distance = 0;

    for (Index = 0; Index < 8 * sizeof(ULONG_PTR); Index++) {

        if ((Value & (ULONG_PTR)0x01)) {

            Distance += 1;
        }

        Value >>= 1;
    }

    return Distance;
}



LOGICAL
KdpSearchPhysicalPage (
    IN PFN_NUMBER PageFrameIndex,
    ULONG_PTR RangeStart,
    ULONG_PTR RangeEnd,
    ULONG Flags,
    ULONG MmFlags
    )
/*++

Routine Description:

    This routine searches the physical page corresponding to a
    certain PFN index for any ULONG_PTR values in range [Start..End].

Arguments:

    PageFrameIndex - PFN index

    RangeStart - lowest possible value searched for

    RangeEnd - highest possible value searched for

    Flags - flags to control the search

    MmFlags - flags to control the MmDbg routines for memory access

Return Value:

    TRUE if a hit has been found, FALSE otherwise.
    The function stops after the first hit in the page is
    encountered and the information related to the hit (PFN index,
    offset, corresponding VA) is registered in the hit database.

Environment:

    Call triggered only from Kd extension.

--*/

{
    LOGICAL Status;
    NTSTATUS CopyStatus;
    ULONG Index;
    PHYSICAL_ADDRESS Pa;

    Pa.QuadPart = ((ULONGLONG)PageFrameIndex) << PAGE_SHIFT;

    Status = FALSE;

    if (KdpSearchPfnValue) {

        HARDWARE_PTE PteValue;

        //
        // We need to search for a PFN
        //

        for (Index = 0; Index < PAGE_SIZE; Index += sizeof(HARDWARE_PTE)) {

            CopyStatus = MmDbgCopyMemory ((ULONG64)(Pa.QuadPart) + Index,
                                          &PteValue,
                                          sizeof PteValue,
                                          MMDBG_COPY_PHYSICAL | MmFlags);

            if (NT_SUCCESS(CopyStatus)) {

                if (PteValue.PageFrameNumber == RangeStart) {

                    if (KdpSearchPageHitIndex < SEARCH_PAGE_HIT_DATABASE_SIZE) {

                        KdpSearchPageHits[KdpSearchPageHitIndex] = PageFrameIndex;
                        KdpSearchPageHitOffsets[KdpSearchPageHitIndex] = Index;
                        KdpSearchPageHitIndex += 1;
                    }

                    if ((Flags & KDP_SEARCH_ALL_OFFSETS_IN_PAGE) == 0) {
                        Status = TRUE;
                        break;
                    }
                }
            }
        }
    }
    else {

        ULONG_PTR Value;

        //
        // We need to search for an address pattern
        //
        
        for (Index = 0; Index < PAGE_SIZE; Index += sizeof(ULONG_PTR)) {

            CopyStatus = MmDbgCopyMemory ((ULONG64)(Pa.QuadPart) + Index,
                                          &Value,
                                          sizeof Value,
                                          MMDBG_COPY_PHYSICAL | MmFlags);

            if (NT_SUCCESS(CopyStatus)) {

                if ((Value >= RangeStart && Value <= RangeEnd) ||
                    (KdpSearchHammingDistance(Value, RangeStart) == 1)) {

                    if (KdpSearchPageHitIndex < SEARCH_PAGE_HIT_DATABASE_SIZE) {
                        KdpSearchPageHits[KdpSearchPageHitIndex] = PageFrameIndex;
                        KdpSearchPageHitOffsets[KdpSearchPageHitIndex] = Index;

                        KdpSearchPageHitIndex += 1;
                    }

                    if ((Flags & KDP_SEARCH_ALL_OFFSETS_IN_PAGE) == 0) {
                        Status = TRUE;
                        break;
                    }
                }
            }
        }
    }

    return Status;
}



LOGICAL
KdpSearchPhysicalMemoryRequested (
    VOID
    )
/*++

Routine Description:

    This routine determines if a physical range search has been
    requested. This is controlled by a global variable set in
    the `!search' debug extension.

Arguments:

    None

Return Value:

    TRUE if physical range search was requested.


Environment:

    Call triggered only from Kd extension.

--*/
{
    if (KdpSearchInProgress) {

        return TRUE;
    }
    else {

        return FALSE;
    }

}



LOGICAL
KdpSearchPhysicalPageRange (
    ULONG MmFlags
    )
/*++

Routine Description:

    This routine will start a search in a range of physical pages in case
    `KdpSearchInProgress' is true. the parameters for the search are picked up
    from global vairiables that are set inside a kernel debugger extension.

Arguments:

    MmFlags - flags to control the MmDbg routines for memory access

Return Value:

    TRUE if the function executed a search and FALSE otherwise.
    The results of the search are specified in the KdpSearchPageHits
    and related variables. this global variables offers the mechanism
    for the debugger extension to pickup the results of the search.


Environment:

    Call triggered only from Kd extension.

    Note. The !search extension make sure that the range requested
    is part of the system memory therefore we do not have to
    worry about sparse PFN databases here.

--*/

{
    PFN_NUMBER CurrentFrame;
    ULONG Flags;

    //
    // The debugger extension is supposed to set KdpSearchInProgress
    // to TRUE if a search is requested.
    //

    if (!KdpSearchInProgress) {

        return FALSE;
    }


    Flags = 0;

    //
    // If the search range is only one page we will give all
    // hits inside a page. By default we get only the first hit inside
    // a page.
    //

    if (KdpSearchEndPageFrame == KdpSearchStartPageFrame) {

        KdpSearchEndPageFrame += 1;

        Flags |= KDP_SEARCH_ALL_OFFSETS_IN_PAGE;
    }

    for (CurrentFrame = KdpSearchStartPageFrame;
         CurrentFrame < KdpSearchEndPageFrame;
         CurrentFrame += 1) {

        KdpSearchPhysicalPage (CurrentFrame,
                               KdpSearchAddressRangeStart,
                               KdpSearchAddressRangeEnd,
                               Flags,
                               MmFlags);

    }

    return TRUE;
}

VOID
KdpFillMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    Fill a section of memory with a given pattern.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies the pattern to search for.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    STRING MessageHeader;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length = m->u.FillMemory.Length;
    PUCHAR Pattern = (PUCHAR) AdditionalData->Buffer;
    PUCHAR Pat = Pattern;
    PUCHAR PatEnd = Pat + m->u.FillMemory.PatternLength;
    ULONG Filled = 0;
    ULONG ChunkFlags = MMDBG_COPY_WRITE | MMDBG_COPY_UNSAFE;

    UNREFERENCED_PARAMETER (Context);

    if (m->u.FillMemory.Flags & DBGKD_FILL_MEMORY_PHYSICAL) {
        ChunkFlags |= MMDBG_COPY_PHYSICAL;
    } else if (!(m->u.FillMemory.Flags & DBGKD_FILL_MEMORY_VIRTUAL)) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(Status)) {
        
        ULONG64 Address = m->u.FillMemory.Address;
        
        while (Length-- > 0) {
            ULONG Done;

            if (!NT_SUCCESS(Status =
                            KdpCopyMemoryChunks(Address, Pat, 1, 0,
                                                ChunkFlags, &Done))) {
                break;
            }

            Address++;
            if (++Pat == PatEnd) {
                Pat = Pattern;
            }
            Filled++;
        }

        // If nothing was filled return an error, otherwise
        // consider it a success.
        Status = Filled > 0 ? STATUS_SUCCESS : Status;
        
    }
        
    m->ReturnStatus = Status;
    m->u.FillMemory.Length = Filled;
    
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}

VOID
KdpQueryMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    Query what kind of memory a particular address refers to.

Arguments:

    m - Supplies the state manipulation message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    STRING MessageHeader;
    NTSTATUS Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER (Context);

    if (m->u.QueryMemory.AddressSpace == DBGKD_QUERY_MEMORY_VIRTUAL) {

        PVOID Addr = (PVOID)(ULONG_PTR)m->u.QueryMemory.Address;

        //
        // Right now all we check for is user/session/kernel.
        //
        
        if (Addr < MM_HIGHEST_USER_ADDRESS) {
            m->u.QueryMemory.AddressSpace = DBGKD_QUERY_MEMORY_PROCESS;
        } else if (MmIsSessionAddress(Addr)) {
            m->u.QueryMemory.AddressSpace = DBGKD_QUERY_MEMORY_SESSION;
        } else {
            m->u.QueryMemory.AddressSpace = DBGKD_QUERY_MEMORY_KERNEL;
        }

        // Always return the most permissive flags.
        m->u.QueryMemory.Flags =
            DBGKD_QUERY_MEMORY_READ |
            DBGKD_QUERY_MEMORY_WRITE |
            DBGKD_QUERY_MEMORY_EXECUTE;
    
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }
    
    m->ReturnStatus = Status;
    m->u.QueryMemory.Reserved = 0;
    
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}

VOID
KdpSysGetVersion(
    PDBGKD_GET_VERSION64 Version
    )

/*++

Routine Description:

    This function returns to the caller a general information packet
    that contains useful information to a debugger.  This packet is also
    used for a debugger to determine if the writebreakpointex and
    readbreakpointex apis are available.

Arguments:

    Version - Supplies the structure to fill in

Return Value:

    None.

--*/

{
    *Version = KdVersionBlock;
}

NTSTATUS
KdpSysReadBusData(
    BUS_DATA_TYPE BusDataType,
    ULONG BusNumber,
    ULONG SlotNumber,
    ULONG Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Reads I/O configuration space.

Arguments:

    BusDataType - Bus data type.

    BusNumber - Bus number.

    SlotNumber - Slot number.

    Address - Configuration space address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    *Actual = HalGetBusDataByOffset(BusDataType, BusNumber, SlotNumber,
                                    Buffer, Address, Request);
    return *Actual == Request ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

NTSTATUS
KdpSysWriteBusData(
    BUS_DATA_TYPE BusDataType,
    ULONG BusNumber,
    ULONG SlotNumber,
    ULONG Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Writes I/O configuration space.

Arguments:

    BusDataType - Bus data type.

    BusNumber - Bus number.

    SlotNumber - Slot number.

    Address - Configuration space address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    *Actual = HalSetBusDataByOffset(BusDataType, BusNumber, SlotNumber,
                                    Buffer, Address, Request);
    return *Actual == Request ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}









NTSTATUS
KdpSysCheckLowMemory(
    ULONG MmFlags
    )

/*++

Routine Description:


Arguments:

    MmFlags - 0 or MMDBG_COPY_UNSAFE to indicate whether the routine
              is being used from local kd or from remote kd.

Return Value:

    NTSTATUS.

Description:

    This function gets called when the !chklowmem
    debugger extension is used.

--*/

{
    PFN_NUMBER Page;
    PFN_NUMBER NextPage;
    ULONG CorruptionOffset;
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    if (KdpSearchPhysicalMemoryRequested()) {

        //
        // This is a !search kd extension call.
        //

        KdpSearchPhysicalPageRange(MmFlags);
    }
    else {

        // MmDbgIsLowMemOk is only usable from real kd, not
        // local kd, so don't allow local kd access.
        if ((MmFlags & MMDBG_COPY_UNSAFE) == 0) {
            return STATUS_NOT_IMPLEMENTED;
        }
        
        //
        // Check low physical memory on machines with more than 4GB.
        //

        Page = 0;

        do {

            if (! MmDbgIsLowMemOk (Page, &NextPage, &CorruptionOffset)) {
                Status = (NTSTATUS) Page;
                break;
            }

            Page = NextPage;

        } while (Page != 0);
    }

    return Status;
}

BOOLEAN
KdRefreshDebuggerNotPresent(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    BOOLEAN.

Description:

    KdRefreshDebuggerPresent attempts to communicate with
    the debugger host machine to refresh the state of
    KdDebuggerNotPresent.  It returns the state of
    KdDebuggerNotPresent while the kd locks are held.
    KdDebuggerNotPresent may immediately change state
    after the kd locks are released so it may not
    match the return value.

--*/

{
    STRING Output;
    BOOLEAN Enable;
    BOOLEAN NotPresent;

    if (KdPitchDebugger) {
        // Machine was booted non-debug, so the debugger
        // can't be active.
        return TRUE;
    }
        
    //
    // In order to be compatible with all debuggers this
    // routine doesn't use a new KD API.  Instead it
    // just sends an output string without checking
    // for the current state of KdDebuggerNotPresent.
    // The transport code will automatically update
    // KdDebuggerNotPresent during communication.
    //
    
    Output.Buffer = "KDTARGET: Refreshing KD connection\n";
    Output.Length = (USHORT)strlen(Output.Buffer);

    Enable = KdEnterDebugger(NULL, NULL);
    
    KdpPrintString(&Output);
    NotPresent = KdDebuggerNotPresent;

    KdExitDebugger(Enable);

    return NotPresent;
}

//----------------------------------------------------------------------------
//
// Tracing data support.
//
//----------------------------------------------------------------------------

VOID
KdpSendTraceData(
    PSTRING Data
    )
{
    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_TRACE_IO TraceIo;
    
    //
    // Move the output string to the message buffer.
    //

    KdpCopyFromPtr(KdpMessageBuffer,
                   Data->Buffer,
                   Data->Length,
                   &Length);

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(TraceIo) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(TraceIo);
    }

    //
    // Construct the print string message and message descriptor.
    //

    TraceIo.ApiNumber = DbgKdPrintTraceApi;
    TraceIo.ProcessorLevel = KeProcessorLevel;
    TraceIo.Processor = (USHORT)KeGetCurrentProcessorNumber();
    TraceIo.u.PrintTrace.LengthOfData = Length;
    MessageHeader.Length = sizeof(TraceIo);
    MessageHeader.Buffer = (PCHAR)&TraceIo;

    //
    // Construct the print string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = (PCHAR) KdpMessageBuffer;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdSendPacket(
        PACKET_TYPE_KD_TRACE_IO,
        &MessageHeader,
        &MessageData,
        &KdpContext
        );
}

VOID
KdReportTraceData(
    IN struct _WMI_BUFFER_HEADER* Buffer,
    IN PVOID Context
    )
{
    BOOLEAN Enable;
    STRING Data;

    UNREFERENCED_PARAMETER (Context);

    Data.Buffer = (PCHAR)Buffer;
    if (Buffer->Wnode.BufferSize > 0xffff) {
        Data.Length = 0xffff;
    } else {
        Data.Length = (USHORT)Buffer->Wnode.BufferSize;
    }
    
    if (KdDebuggerNotPresent == FALSE) {
        Enable = KdEnterDebugger(NULL, NULL);

        KdpSendTraceData(&Data);

        KdExitDebugger(Enable);
    }
}

//----------------------------------------------------------------------------
//
// Debugger hibernate/suspend support.
//
//----------------------------------------------------------------------------

NTSTATUS
KdPowerTransition(
    DEVICE_POWER_STATE newDeviceState
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    switch(newDeviceState) {
    
    case PowerDeviceD0:
        KdD0Transition();
        break;
        
    case PowerDeviceD3:
        KdD3Transition();
        break;

    default:
        status = STATUS_INVALID_PARAMETER_1;
    }

    return status;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\kddbgio.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kddbgio.c

Abstract:

    This module implements kernel debugger based Dbg I/O. This
    is the foundation for DbgPrint and DbgPrompt.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "kdp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpPrintString)
#pragma alloc_text(PAGEKD, KdpPromptString)
#pragma alloc_text(PAGEKD, KdpAcquireBreakpoint)
#endif

BOOLEAN
KdpPrintString (
    IN PSTRING Output
    )

/*++

Routine Description:

    This routine prints a string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

Return Value:

    TRUE if Control-C present in input buffer after print is done.
    FALSE otherwise.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;

    //
    // Move the output string to the message buffer.
    //

    KdpCopyFromPtr(KdpMessageBuffer,
                   Output->Buffer,
                   Output->Length,
                   &Length);

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the print string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdPrintStringApi;
    DebugIo.ProcessorLevel = KeProcessorLevel;
    DebugIo.Processor = (USHORT)KeGetCurrentProcessorNumber();
    DebugIo.u.PrintString.LengthOfString = Length;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the print string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = (PCHAR) KdpMessageBuffer;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdSendPacket(
        PACKET_TYPE_KD_DEBUG_IO,
        &MessageHeader,
        &MessageData,
        &KdpContext
        );

    return KdpPollBreakInWithPortLock();
}


BOOLEAN
KdpPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    )

/*++

Routine Description:

    This routine prints a string, then reads a reply string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

    Input - Supplies a pointer to a string descriptor for the input string.
            (Length stored/returned in Input->Length)

Return Value:

    TRUE - A Breakin sequence was seen, caller should breakpoint and retry
    FALSE - No Breakin seen.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;
    ULONG ReturnCode;

    //
    // Move the output string to the message buffer.
    //

    KdpCopyFromPtr(KdpMessageBuffer,
                   Output->Buffer,
                   Output->Length,
                   &Length);

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the prompt string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdGetStringApi;
    DebugIo.ProcessorLevel = KeProcessorLevel;
    DebugIo.Processor = (USHORT)KeGetCurrentProcessorNumber();
    DebugIo.u.GetString.LengthOfPromptString = Length;
    DebugIo.u.GetString.LengthOfStringRead = Input->MaximumLength;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the prompt string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = (PCHAR) KdpMessageBuffer;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdSendPacket(
        PACKET_TYPE_KD_DEBUG_IO,
        &MessageHeader,
        &MessageData,
        &KdpContext
        );


    //
    // Receive packet from the kernel debugger on the host machine.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_DEBUG_IO);
    MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;

    do {
        ReturnCode = KdReceivePacket(
            PACKET_TYPE_KD_DEBUG_IO,
            &MessageHeader,
            &MessageData,
            &Length,
            &KdpContext
            );
        if (ReturnCode == KDP_PACKET_RESEND) {
            return TRUE;
        }
    } while (ReturnCode != KDP_PACKET_RECEIVED);


    if (Length > Input->MaximumLength) {
        Length = Input->MaximumLength;
    }

    KdpCopyToPtr(Input->Buffer,
                 KdpMessageBuffer,
                 Length,
                 &Length);
    Input->Length = (USHORT)Length;

    return FALSE;
}





BOOLEAN
KdpAcquireBreakpoint(
    IN ULONG Number
    )

/*++

Routine Description:

    This routine prints a string, then reads a reply string.

Arguments:

    Number - breakpoint register number being requested.

Return Value:

    TRUE - Breakpoint now reserved for kernel use.
    FALSE - breakpoint not available.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_CONTROL_REQUEST ControlRequest;
    ULONG ReturnCode;

    //
    // Construct the prompt string message and message descriptor.
    //

    ControlRequest.ApiNumber = DbgKdRequestHardwareBp;
    ControlRequest.u.RequestBreakpoint.HardwareBreakPointNumber = Number;
    ControlRequest.u.RequestBreakpoint.Available = FALSE;
    MessageHeader.Length = sizeof(ControlRequest);
    MessageHeader.Buffer = (PCHAR)&ControlRequest;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdSendPacket(PACKET_TYPE_KD_CONTROL_REQUEST,
                 &MessageHeader,
                 NULL,
                 &KdpContext);

    //
    // Receive packet from the kernel debugger on the host machine.
    //

    MessageHeader.MaximumLength = sizeof(PACKET_TYPE_KD_CONTROL_REQUEST);

    MessageData.Buffer = (PCHAR) KdpMessageBuffer;
    MessageData.Length = 0;
    MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;

    do
    {
        ReturnCode = KdReceivePacket(PACKET_TYPE_KD_CONTROL_REQUEST,
                                     &MessageHeader,
                                     &MessageData,
                                     &Length,
                                     &KdpContext);

        if (ReturnCode == KDP_PACKET_RESEND)
        {
            return FALSE;
        }
    } while (ReturnCode != KDP_PACKET_RECEIVED);

    return (BOOLEAN) (ControlRequest.u.RequestBreakpoint.Available == 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\kdlock.c ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    kdlock.c

Abstract:

    This module contains code to synchronize the usage of the port
    used by the kernel debugger.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

--*/

#include "kdp.h"

VOID
KdpPortLock(
    VOID
    )

/*++

Routine Description:

    Acquire the spinlock for the debug port.

    Note that user must call this explicitly, the get/put routines
    do NOT make any use of the lock.

    CALLER MUST HAVE SET PROPER IRQL BEFORE CALLING US.

    We use KiAcquireSpinLock and NOT Ke... because our IRQL may
    be above DISPATCH_LEVEL.

Arguments:

    None.

Return value:

    None.

--*/

{
    KiAcquireSpinLock(&KdpDebuggerLock);
}

VOID
KdpPortUnlock(
    VOID
    )

/*++

Routine Description:

    Release the spinlock for the debug port.

    Note that user must call this explicitly, the get/put routines
    do NOT make any use of the lock.

    CALLER MUST HAVE SET PROPER IRQL BEFORE CALLING US.

    We use KiReleaseSpinLock and NOT Ke... because our IRQL may
    be above DISPATCH_LEVEL.

Arguments:

    None.

Return value:

    None.

--*/

{
    KiReleaseSpinLock(&KdpDebuggerLock);
}

BOOLEAN
KdPollBreakIn(
    VOID
    )

/*++

Routine Description:

    This procedure raises IRQL to high_level, seizes the Debug port
    spinlock, and checks to see if a breakin packet is pending.
    If a packet is present, return TRUE, else FALSE.

    A packet is present if:

    There is a valid character which matches BREAK_CHAR.

    N.B.    Interrupts must be OFF around this call

Return Value:

    TRUE if breakin sequence present, caller should execute int-3.
    FALSE if no breakin seen.

--*/

{

    BOOLEAN BreakIn;
    BOOLEAN Enable;
    ULONG   Status;

#if defined(_IA64_)

    KIRQL   OldIrql;

#endif

    //
    // If the debugger is enabled, see if a breakin by the kernel
    // debugger is pending.
    //

    BreakIn = FALSE;
    if (KdDebuggerEnabled != FALSE) {
        Enable = KeDisableInterrupts();

#if defined(_IA64_)

        KeRaiseIrql(HIGH_LEVEL, &OldIrql);

#endif

        if (KdpContext.KdpControlCPending != FALSE) {
            KdpControlCPressed = TRUE;
            BreakIn = TRUE;
            KdpContext.KdpControlCPending = FALSE;

        } else {
            if (KeTryToAcquireSpinLockAtDpcLevel(&KdpDebuggerLock) != FALSE) {
                Status = KdReceivePacket(PACKET_TYPE_KD_POLL_BREAKIN,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL);

                if (Status == KDP_PACKET_RECEIVED) {
                    BreakIn = TRUE;
                    KdpControlCPressed = TRUE;
                }

                KdpPortUnlock();
            }
        }

#if defined(_IA64_)

        KeLowerIrql(OldIrql);

#endif

        KeEnableInterrupts(Enable);
    }

    return BreakIn;
}

BOOLEAN
KdpPollBreakInWithPortLock(
    VOID
    )

/*++

Routine Description:

    This procedure same as KdPollBreakIn, but assumes the caller
    already holds the port lock.  Returns TRUE if a breakin packet
    is pending.

    A packet is present if:

    There is a valid character which matches BREAK_CHAR.

    N.B.    Interrupts must be OFF around this call

Return Value:

    TRUE if breakin sequence present, caller should execute int-3.
    FALSE if no breakin seen.

--*/

{

    BOOLEAN BreakIn;
    ULONG Status;

    //
    // If the debugger is enabled, see if a breakin by the kernel
    // debugger is pending.
    //

    BreakIn = FALSE;
    if (KdDebuggerEnabled != FALSE) {
        if (KdpContext.KdpControlCPending != FALSE) {
            BreakIn = TRUE;
            KdpContext.KdpControlCPending = FALSE;

        } else {
            Status = KdReceivePacket(PACKET_TYPE_KD_POLL_BREAKIN,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
            if (Status == KDP_PACKET_RECEIVED) {
                BreakIn = TRUE;
            }
        }
    }

    return BreakIn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\file.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    file.c

Abstract:

    This module contains kd host machine file I/O support.

Author:

    Drew Bliss (drewb) 21-Feb-2001

Revision History:

--*/

#include "kdp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdCreateRemoteFile)
#pragma alloc_text(PAGEKD, KdReadRemoteFile)
#pragma alloc_text(PAGEKD, KdWriteRemoteFile)
#pragma alloc_text(PAGEKD, KdCloseRemoteFile)
#pragma alloc_text(PAGEKD, KdPullRemoteFile)
#pragma alloc_text(PAGEKD, KdPushRemoteFile)
#endif

NTSTATUS
KdCreateRemoteFile(
    OUT PHANDLE Handle,
    OUT PULONG64 Length, OPTIONAL
    IN PUNICODE_STRING FileName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )
{
    BOOLEAN Enable;
    DBGKD_FILE_IO Irp;
    ULONG Index;

    if (FileName->Length > PACKET_MAX_SIZE - sizeof(Irp)) {
        return STATUS_INVALID_PARAMETER;
    }
    
    if (KdDebuggerNotPresent != FALSE) {
        return STATUS_DEBUGGER_INACTIVE;
    }
    
    Enable = KdEnterDebugger(NULL, NULL);

    //
    // Look for an open slot.
    //

    for (Index = 0; Index < KD_MAX_REMOTE_FILES; Index++) {
        if (KdpRemoteFiles[Index].RemoteHandle == 0) {
            break;
        }
    }

    if (Index >= KD_MAX_REMOTE_FILES) {
        Irp.Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    Irp.ApiNumber = DbgKdCreateFileApi;
    Irp.u.CreateFile.DesiredAccess = DesiredAccess;
    Irp.u.CreateFile.FileAttributes = FileAttributes;
    Irp.u.CreateFile.ShareAccess = ShareAccess;
    Irp.u.CreateFile.CreateDisposition = CreateDisposition;
    Irp.u.CreateFile.CreateOptions = CreateOptions;

    for (;;) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG Length;

        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;

        // Copy the filename to the message buffer
        // so that a terminator can be added.
        KdpCopyFromPtr(KdpMessageBuffer, FileName->Buffer,
                       FileName->Length, &Length);
        MessageData.Length = (USHORT)Length + sizeof(WCHAR);
        MessageData.Buffer = (PCHAR) KdpMessageBuffer;
        *(PWCHAR)&MessageData.Buffer[MessageData.Length - sizeof(WCHAR)] =
            UNICODE_NULL;
        
        //
        // Send packet to the kernel debugger on the host machine.
        //

        KdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     &MessageData,
                     &KdpContext);

        if (KdDebuggerNotPresent != FALSE) {
            Irp.Status = STATUS_DEBUGGER_INACTIVE;
            break;
        }
    
        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;
        MessageData.Buffer = (PCHAR) KdpMessageBuffer;

        do {
            ReturnCode = KdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &Length,
                                         &KdpContext);
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        if (ReturnCode == KDP_PACKET_RECEIVED) {
            break;
        }
    }
    
    if (NT_SUCCESS(Irp.Status)) {
        
        KdpRemoteFiles[Index].RemoteHandle = Irp.u.CreateFile.Handle;
        // Add one so that zero is reserved for invalid-handle.
        *Handle = UlongToHandle(Index + 1);
        if (ARGUMENT_PRESENT(Length)) {
            *Length = Irp.u.CreateFile.Length;
        }
    }
    
 Exit:
    KdExitDebugger(Enable);
    return Irp.Status;
}

NTSTATUS
KdReadRemoteFile(
    IN HANDLE Handle,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Completed
    )
{
    BOOLEAN Enable;
    DBGKD_FILE_IO Irp;
    ULONG Index;
    ULONG _Completed = 0;

    Index = HandleToUlong(Handle) - 1;
    if (Index >= KD_MAX_REMOTE_FILES) {
        return STATUS_INVALID_PARAMETER;
    }
    
    Enable = KdEnterDebugger(NULL, NULL);

    if (KdpRemoteFiles[Index].RemoteHandle == 0) {
        Irp.Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Irp.ApiNumber = DbgKdReadFileApi;
    Irp.Status = STATUS_SUCCESS;
    Irp.u.ReadFile.Handle = KdpRemoteFiles[Index].RemoteHandle;
    Irp.u.ReadFile.Offset = Offset;

    while (Length > 0) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG RecvLength;

        if (Length > PACKET_MAX_SIZE - sizeof(Irp)) {
            Irp.u.ReadFile.Length = PACKET_MAX_SIZE - sizeof(Irp);
        } else {
            Irp.u.ReadFile.Length = Length;
        }
    
        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;
    
        //
        // Send packet to the kernel debugger on the host machine.
        //

        KdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     NULL,
                     &KdpContext);

        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = (USHORT)Irp.u.ReadFile.Length;
        MessageData.Buffer = Buffer;

        do {
            ReturnCode = KdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &RecvLength,
                                         &KdpContext);
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        if (ReturnCode == KDP_PACKET_RECEIVED) {
            if (!NT_SUCCESS(Irp.Status)) {
                break;
            }

            _Completed += RecvLength;
            Buffer = (PVOID)((PUCHAR)Buffer + RecvLength);
            Irp.u.ReadFile.Offset += RecvLength;
            Length -= RecvLength;
        }
    }
    
    *Completed = _Completed;
    
 Exit:
    KdExitDebugger(Enable);
    return Irp.Status;
}

NTSTATUS
KdWriteRemoteFile(
    IN HANDLE Handle,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Completed
    )
{
    BOOLEAN Enable;
    DBGKD_FILE_IO Irp;
    ULONG Index;
    ULONG _Completed = 0;

    Index = HandleToUlong(Handle) - 1;
    if (Index >= KD_MAX_REMOTE_FILES) {
        return STATUS_INVALID_PARAMETER;
    }
    
    Enable = KdEnterDebugger(NULL, NULL);

    if (KdpRemoteFiles[Index].RemoteHandle == 0) {
        Irp.Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Irp.ApiNumber = DbgKdWriteFileApi;
    Irp.Status = STATUS_SUCCESS;
    Irp.u.WriteFile.Handle = KdpRemoteFiles[Index].RemoteHandle;
    Irp.u.WriteFile.Offset = Offset;

    while (Length > 0) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG RecvLength;

        if (Length > PACKET_MAX_SIZE - sizeof(Irp)) {
            Irp.u.WriteFile.Length = PACKET_MAX_SIZE - sizeof(Irp);
        } else {
            Irp.u.WriteFile.Length = Length;
        }
    
        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;
    
        MessageData.Length = (USHORT)Irp.u.WriteFile.Length;
        MessageData.Buffer = Buffer;

        //
        // Send packet to the kernel debugger on the host machine.
        //

        KdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     &MessageData,
                     &KdpContext);

        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;
        MessageData.Buffer = (PCHAR) KdpMessageBuffer;

        do {
            ReturnCode = KdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &RecvLength,
                                         &KdpContext);
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        if (ReturnCode == KDP_PACKET_RECEIVED) {
            if (!NT_SUCCESS(Irp.Status)) {
                break;
            }

            _Completed += Irp.u.WriteFile.Length;
            Buffer = (PVOID)((PUCHAR)Buffer + Irp.u.WriteFile.Length);
            Irp.u.WriteFile.Offset += Irp.u.WriteFile.Length;
            Length -= Irp.u.WriteFile.Length;
        }
    }
    
    *Completed = _Completed;
    
 Exit:
    KdExitDebugger(Enable);
    return Irp.Status;
}

NTSTATUS
KdCloseRemoteFile(
    IN HANDLE Handle
    )
{
    BOOLEAN Enable;
    DBGKD_FILE_IO Irp;
    ULONG Index;

    Index = HandleToUlong(Handle) - 1;
    if (Index >= KD_MAX_REMOTE_FILES) {
        return STATUS_INVALID_PARAMETER;
    }
    
    Enable = KdEnterDebugger(NULL, NULL);

    if (KdpRemoteFiles[Index].RemoteHandle == 0) {
        Irp.Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Irp.ApiNumber = DbgKdCloseFileApi;
    Irp.u.CloseFile.Handle = KdpRemoteFiles[Index].RemoteHandle;

    for (;;) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG RecvLength;

        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;
    
        //
        // Send packet to the kernel debugger on the host machine.
        //

        KdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     NULL,
                     &KdpContext);

        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;
        MessageData.Buffer = (PCHAR) KdpMessageBuffer;

        do {
            ReturnCode = KdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &RecvLength,
                                         &KdpContext);
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        if (ReturnCode == KDP_PACKET_RECEIVED) {
            break;
        }
    }
    
    if (NT_SUCCESS(Irp.Status)) {
        KdpRemoteFiles[Index].RemoteHandle = 0;
    }
    
 Exit:
    KdExitDebugger(Enable);
    return Irp.Status;
}

#define TRANSFER_LENGTH 8192

NTSTATUS
KdPullRemoteFile(
    IN PUNICODE_STRING FileName,
    IN ULONG FileAttributes,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )
{
    NTSTATUS Status;
    PVOID Buffer = NULL;
    ULONG64 Length;
    HANDLE RemoteHandle = NULL;
    HANDLE LocalHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER LargeInt;
    ULONG64 Offset;

    // Allocate a buffer for data transfers.
    Buffer = ExAllocatePoolWithTag(NonPagedPool, TRANSFER_LENGTH, 'oIdK');
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    // Open the remote file for reading.
    Status = KdCreateRemoteFile(&RemoteHandle, &Length, FileName,
                                FILE_GENERIC_READ, FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ, FILE_OPEN, 0);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    // Open the local file for writing.
    LargeInt.QuadPart = Length;
    InitializeObjectAttributes(&ObjectAttributes, FileName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL, NULL);
    Status = ZwCreateFile(&LocalHandle, FILE_GENERIC_WRITE,
                          &ObjectAttributes, &IoStatus, &LargeInt,
                          FileAttributes, 0, CreateDisposition,
                          CreateOptions, NULL, 0);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    // Copy the file contents.
    Offset = 0;
    while (Length > 0) {
        ULONG ReqLength, ReqCompleted;

        if (Length > TRANSFER_LENGTH) {
            ReqLength = TRANSFER_LENGTH;
        } else {
            ReqLength = (ULONG)Length;
        }
        
        Status = KdReadRemoteFile(RemoteHandle, Offset, Buffer,
                                  ReqLength, &ReqCompleted);
        if (!NT_SUCCESS(Status) || ReqCompleted == 0) {
            break;
        }

        LargeInt.QuadPart = Offset;
        Status = ZwWriteFile(LocalHandle, NULL, NULL, NULL,
                             &IoStatus, Buffer, ReqCompleted,
                             &LargeInt, NULL);
        if (!NT_SUCCESS(Status)) {
            break;
        }
        if (IoStatus.Information < ReqCompleted) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        Offset += IoStatus.Information;
        Length -= IoStatus.Information;
    }
    
 Exit:
    if (RemoteHandle != NULL) {
        KdCloseRemoteFile(RemoteHandle);
    }
    if (LocalHandle != NULL) {
        ZwClose(LocalHandle);
    }
    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
    return Status;
}

NTSTATUS
KdPushRemoteFile(
    IN PUNICODE_STRING FileName,
    IN ULONG FileAttributes,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )
{
    NTSTATUS Status;
    PVOID Buffer = NULL;
    ULONG64 Length;
    HANDLE RemoteHandle = NULL;
    HANDLE LocalHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER LargeInt;
    ULONG64 Offset;
    FILE_END_OF_FILE_INFORMATION EndOfFile;

    // Allocate a buffer for data transfers.
    Buffer = ExAllocatePoolWithTag(NonPagedPool, TRANSFER_LENGTH, 'oIdK');
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    // Open the remote file for writing.
    Status = KdCreateRemoteFile(&RemoteHandle, &Length, FileName,
                                FILE_GENERIC_WRITE, FileAttributes,
                                0, CreateDisposition, CreateOptions);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    // Open the local file for reading.
    InitializeObjectAttributes(&ObjectAttributes, FileName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL, NULL);
    Status = ZwOpenFile(&LocalHandle, FILE_GENERIC_READ,
                        &ObjectAttributes, &IoStatus, FILE_SHARE_READ, 0);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = NtQueryInformationFile(LocalHandle, &IoStatus,
                                    &EndOfFile, sizeof(EndOfFile),
                                    FileEndOfFileInformation);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    // Copy the file contents.
    Offset = 0;
    Length = EndOfFile.EndOfFile.QuadPart;
    while (Length > 0) {
        ULONG ReqLength, ReqCompleted;

        if (Length > TRANSFER_LENGTH) {
            ReqLength = TRANSFER_LENGTH;
        } else {
            ReqLength = (ULONG)Length;
        }
        
        LargeInt.QuadPart = Offset;
        Status = ZwReadFile(LocalHandle, NULL, NULL, NULL,
                            &IoStatus, Buffer, ReqLength,
                            &LargeInt, NULL);
        if (!NT_SUCCESS(Status) || IoStatus.Information == 0) {
            break;
        }

        Status = KdWriteRemoteFile(RemoteHandle, Offset, Buffer,
                                   (ULONG)IoStatus.Information, &ReqCompleted);
        if (!NT_SUCCESS(Status)) {
            break;
        }
        if (ReqCompleted < IoStatus.Information) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        Offset += ReqCompleted;
        Length -= ReqCompleted;
    }
    
 Exit:
    if (RemoteHandle != NULL) {
        KdCloseRemoteFile(RemoteHandle);
    }
    if (LocalHandle != NULL) {
        ZwClose(LocalHandle);
    }
    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\kddata.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kddata.c

Abstract:

    This module contains global data for the portable kernel debgger.

Author:

    Mark Lucovsky 1-Nov-1993

Revision History:

--*/

#include "kdp.h"
#include "ke.h"
#include "pool.h"
#include "stdio.h"


//
// Miscellaneous data from all over the kernel
//


#if !defined(_TRUSTED_WINDOWS_)
extern PHANDLE_TABLE PspCidTable;

extern LIST_ENTRY ExpSystemResourcesList;
extern PPOOL_DESCRIPTOR ExpPagedPoolDescriptor;
extern ULONG ExpNumberOfPagedPools;

extern ULONG KeTimeIncrement;
extern LIST_ENTRY KeBugCheckCallbackListHead;
extern ULONG_PTR KiBugCheckData[];

extern LIST_ENTRY IopErrorLogListHead;

extern POBJECT_DIRECTORY ObpRootDirectoryObject;
extern POBJECT_TYPE ObpTypeObjectType;

extern PVOID MmSystemCacheStart;
extern PVOID MmSystemCacheEnd;

extern PVOID MmPfnDatabase;
extern ULONG MmSystemPtesStart[];
extern ULONG MmSystemPtesEnd[];
extern ULONG MmSubsectionBase;
extern ULONG MmNumberOfPagingFiles;

extern PFN_COUNT MmNumberOfPhysicalPages;

extern ULONG MmMaximumNonPagedPoolInBytes;
extern PVOID MmNonPagedSystemStart;
extern PVOID MmNonPagedPoolStart;
extern PVOID MmNonPagedPoolEnd;

extern PVOID MmPagedPoolStart;
extern PVOID MmPagedPoolEnd;
extern ULONG MmPagedPoolInfo[];
extern ULONG MmSizeOfPagedPoolInBytes;

extern ULONG MmSharedCommit;
extern ULONG MmDriverCommit;
extern ULONG MmProcessCommit;
extern ULONG MmPagedPoolCommit;

extern MMPFNLIST MmZeroedPageListHead;
extern MMPFNLIST MmFreePageListHead;
extern MMPFNLIST MmStandbyPageListHead;
extern MMPFNLIST MmModifiedPageListHead;
extern MMPFNLIST MmModifiedNoWritePageListHead;
extern ULONG MmAvailablePages;
extern LONG MmResidentAvailablePages;
extern LIST_ENTRY MmLoadedUserImageList;

extern PPOOL_TRACKER_TABLE PoolTrackTable;
extern POOL_DESCRIPTOR NonPagedPoolDescriptor;

extern PUNLOADED_DRIVERS MmUnloadedDrivers;
extern ULONG MmLastUnloadedDriver;
extern ULONG MmTriageActionTaken;
extern ULONG MmSpecialPoolTag;
extern LOGICAL KernelVerifier;
extern PVOID MmVerifierData;

extern PFN_NUMBER MmAllocatedNonPagedPool;
extern SIZE_T MmPeakCommitment;
extern SIZE_T MmTotalCommitLimitMaximum;

extern ULONG_PTR MmSessionBase;
extern ULONG_PTR MmSessionSize;
#ifdef _IA64_
extern PFN_NUMBER MmSystemParentTablePage;
#endif

extern ULONG IopNumTriageDumpDataBlocks;
extern PVOID IopTriageDumpDataBlocks[];
#endif

//
// These blocks of data needs to always be present because crashdumps
// need the information.  Otherwise, things like PAGE_SIZE are not available
// in crashdumps, and extensions like !pool fail.
//

DBGKD_GET_VERSION64 KdVersionBlock = {
    0,
    0,
    DBGKD_64BIT_PROTOCOL_VERSION2,

#if defined(_M_AMD64)

    DBGKD_VERS_FLAG_PTR64 | DBGKD_VERS_FLAG_DATA,
    IMAGE_FILE_MACHINE_AMD64,

#elif defined(_M_IX86)

    DBGKD_VERS_FLAG_DATA,
    IMAGE_FILE_MACHINE_I386,

#elif defined(_M_IA64)

    DBGKD_VERS_FLAG_HSS| DBGKD_VERS_FLAG_PTR64 | DBGKD_VERS_FLAG_DATA,
    IMAGE_FILE_MACHINE_IA64,

#endif

    PACKET_TYPE_MAX,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};


#if defined(_TRUSTED_WINDOWS_)
#define TW_EXCLUDE(_data_) 0
#else
#define TW_EXCLUDE(_data_) _data_
#endif

KDDEBUGGER_DATA64 KdDebuggerDataBlock = {
    {0},                                    //  DBGKD_DEBUG_DATA_HEADER Header;
    (ULONG64)0,
    (ULONG64)RtlpBreakWithStatusInstruction,
    (ULONG64)0,
    (USHORT)FIELD_OFFSET(KTHREAD, CallbackStack),   //  USHORT  ThCallbackStack;

#if defined(_AMD64_)

    (USHORT)FIELD_OFFSET(KCALLOUT_FRAME, CallbackStack), //  USHORT  NextCallback;

#else

    (USHORT)FIELD_OFFSET(KCALLOUT_FRAME, CbStk),    //  USHORT  NextCallback;

#endif

    #if defined(_X86_)
    (USHORT)FIELD_OFFSET(KCALLOUT_FRAME, Ebp),
    #else
    (USHORT)0,                                      //  USHORT  FramePointer;
    #endif

    #if defined(_X86PAE_) || defined(_AMD64_)
    (USHORT)1,
    #else
    (USHORT)0,                                      //  USHORT  PaeEnabled;
    #endif

    (ULONG64) TW_EXCLUDE(KiCallUserMode),
    (ULONG64)0,

    (ULONG64)&PsLoadedModuleList,
    (ULONG64) TW_EXCLUDE(&PsActiveProcessHead),
    (ULONG64) TW_EXCLUDE(&PspCidTable),

    (ULONG64) TW_EXCLUDE(&ExpSystemResourcesList),
    (ULONG64) TW_EXCLUDE(&ExpPagedPoolDescriptor),
    (ULONG64) TW_EXCLUDE(&ExpNumberOfPagedPools),

    (ULONG64)&KeTimeIncrement,
    (ULONG64) TW_EXCLUDE(&KeBugCheckCallbackListHead),
    (ULONG64) TW_EXCLUDE(KiBugCheckData),

    (ULONG64) TW_EXCLUDE(&IopErrorLogListHead),

    (ULONG64) TW_EXCLUDE(&ObpRootDirectoryObject),
    (ULONG64) TW_EXCLUDE(&ObpTypeObjectType),

    (ULONG64) TW_EXCLUDE(&MmSystemCacheStart),
    (ULONG64) TW_EXCLUDE(&MmSystemCacheEnd),
    (ULONG64) TW_EXCLUDE(&MmSystemCacheWs),

    (ULONG64) TW_EXCLUDE(&MmPfnDatabase),
    (ULONG64) TW_EXCLUDE(MmSystemPtesStart),
    (ULONG64) TW_EXCLUDE(MmSystemPtesEnd),
    (ULONG64) TW_EXCLUDE(&MmSubsectionBase),
    (ULONG64) TW_EXCLUDE(&MmNumberOfPagingFiles),

    (ULONG64) TW_EXCLUDE(&MmLowestPhysicalPage),
    (ULONG64) TW_EXCLUDE(&MmHighestPhysicalPage),
    (ULONG64) TW_EXCLUDE(&MmNumberOfPhysicalPages),

    (ULONG64) TW_EXCLUDE(&MmMaximumNonPagedPoolInBytes),
    (ULONG64) TW_EXCLUDE(&MmNonPagedSystemStart),
    (ULONG64) TW_EXCLUDE(&MmNonPagedPoolStart),
    (ULONG64) TW_EXCLUDE(&MmNonPagedPoolEnd),

    (ULONG64) TW_EXCLUDE(&MmPagedPoolStart),
    (ULONG64) TW_EXCLUDE(&MmPagedPoolEnd),
    (ULONG64) TW_EXCLUDE(&MmPagedPoolInfo),
    (ULONG64) PAGE_SIZE,
    (ULONG64) TW_EXCLUDE(&MmSizeOfPagedPoolInBytes),

    (ULONG64) TW_EXCLUDE(&MmTotalCommitLimit),
    (ULONG64) TW_EXCLUDE(&MmTotalCommittedPages),
    (ULONG64) TW_EXCLUDE(&MmSharedCommit),
    (ULONG64) TW_EXCLUDE(&MmDriverCommit),
    (ULONG64) TW_EXCLUDE(&MmProcessCommit),
    (ULONG64) TW_EXCLUDE(&MmPagedPoolCommit),
    (ULONG64)0,

    (ULONG64) TW_EXCLUDE(&MmZeroedPageListHead),
    (ULONG64) TW_EXCLUDE(&MmFreePageListHead),
    (ULONG64) TW_EXCLUDE(&MmStandbyPageListHead),
    (ULONG64) TW_EXCLUDE(&MmModifiedPageListHead),
    (ULONG64) TW_EXCLUDE(&MmModifiedNoWritePageListHead),
    (ULONG64) TW_EXCLUDE(&MmAvailablePages),
    (ULONG64) TW_EXCLUDE(&MmResidentAvailablePages),

    (ULONG64) TW_EXCLUDE(&PoolTrackTable),
    (ULONG64) TW_EXCLUDE(&NonPagedPoolDescriptor),

    (ULONG64) TW_EXCLUDE(&MmHighestUserAddress),
    (ULONG64) TW_EXCLUDE(&MmSystemRangeStart),
    (ULONG64) TW_EXCLUDE(&MmUserProbeAddress),

    (ULONG64)KdPrintDefaultCircularBuffer,
    (ULONG64)KdPrintDefaultCircularBuffer +
        sizeof(KdPrintDefaultCircularBuffer),

    (ULONG64)&KdPrintWritePointer,
    (ULONG64)&KdPrintRolloverCount,
    (ULONG64) TW_EXCLUDE(&MmLoadedUserImageList),

    // Nt 5.1 additions

    (ULONG64) TW_EXCLUDE(NtBuildLab),
    #if defined(_IA64_)
    (ULONG64)KiNormalSystemCall,
    #else
    (ULONG64)0,
    #endif
    //

    (ULONG64)KiProcessorBlock,
    (ULONG64) TW_EXCLUDE(&MmUnloadedDrivers),
    (ULONG64) TW_EXCLUDE(&MmLastUnloadedDriver),
    (ULONG64) TW_EXCLUDE(&MmTriageActionTaken),
    (ULONG64) TW_EXCLUDE(&MmSpecialPoolTag),
    (ULONG64) TW_EXCLUDE(&KernelVerifier),
    (ULONG64) TW_EXCLUDE(&MmVerifierData),
    (ULONG64) TW_EXCLUDE(&MmAllocatedNonPagedPool),
    (ULONG64) TW_EXCLUDE(&MmPeakCommitment),
    (ULONG64) TW_EXCLUDE(&MmTotalCommitLimitMaximum),
    (ULONG64) TW_EXCLUDE(&CmNtCSDVersion),

    // Nt 5.1 additions

    (ULONG64)&MmPhysicalMemoryBlock,
    (ULONG64) TW_EXCLUDE(&MmSessionBase),
    (ULONG64) TW_EXCLUDE(&MmSessionSize),
#ifdef _IA64_
    (ULONG64) TW_EXCLUDE(&MmSystemParentTablePage),
#else
    0,
#endif

    // .NET Server additions

    0, // MmVirtualTranslationBase is filled out at init time.
    (USHORT)FIELD_OFFSET(KTHREAD, NextProcessor),
    (USHORT)FIELD_OFFSET(KTHREAD, Teb),
    (USHORT)FIELD_OFFSET(KTHREAD, KernelStack),
    (USHORT)FIELD_OFFSET(KTHREAD, InitialStack),

    (USHORT)FIELD_OFFSET(KTHREAD, ApcState.Process),
    (USHORT)FIELD_OFFSET(KTHREAD, State),
#ifdef _IA64_
    (USHORT)FIELD_OFFSET(KTHREAD, InitialBStore),
    (USHORT)FIELD_OFFSET(KTHREAD, BStoreLimit),
#else
    0,
    0,
#endif

    (USHORT)sizeof(EPROCESS),
    (USHORT)FIELD_OFFSET(EPROCESS, Peb),
    (USHORT)FIELD_OFFSET(EPROCESS, InheritedFromUniqueProcessId),
    (USHORT)FIELD_OFFSET(KPROCESS, DirectoryTableBase),

    (USHORT)sizeof(KPRCB),
    (USHORT)FIELD_OFFSET(KPRCB, DpcRoutineActive),
    (USHORT)FIELD_OFFSET(KPRCB, CurrentThread),
    (USHORT)FIELD_OFFSET(KPRCB, MHz),

#ifdef _IA64_
    (USHORT)FIELD_OFFSET(KPRCB, ProcessorModel),
    (USHORT)FIELD_OFFSET(KPRCB, ProcessorVendorString),
#else
    (USHORT)FIELD_OFFSET(KPRCB, CpuType),
    (USHORT)FIELD_OFFSET(KPRCB, VendorString),
#endif
    (USHORT)FIELD_OFFSET(KPRCB, ProcessorState),
    (USHORT)FIELD_OFFSET(KPRCB, Number),

    (USHORT)sizeof(ETHREAD),

    (ULONG64)&KdPrintCircularBuffer,
    (ULONG64)&KdPrintBufferSize,

    (ULONG64)&KeLoaderBlock,

    (USHORT)0,
    (USHORT)0,
    (USHORT)0,
    (USHORT)0,

    (USHORT)0,
    (USHORT)0,
    (USHORT)0,
    (USHORT)0,

    (USHORT)0,
    (USHORT)0,
    (USHORT)0,
    (USHORT)0,

    (USHORT)0,
    (USHORT)0,
    (USHORT)0,
    (USHORT)0,

    (USHORT)0,
    (USHORT)0,
    (USHORT)0,
    (USHORT)0,

    (ULONG64)TW_EXCLUDE(&IopNumTriageDumpDataBlocks),
    (ULONG64)TW_EXCLUDE(IopTriageDumpDataBlocks),
};

//
// Initialize the component name debug print filter table.
//

ULONG Kd_WIN2000_Mask = 1;

#include "dpfilter.c"

ULONG KdComponentTableSize = sizeof(KdComponentTable) / sizeof(PULONG);

//
// All dta from here on will be paged out if the kernel debugger is
// not enabled.
//

#ifdef _X86_
#pragma data_seg("PAGEKDD")
#endif // _X86_

UCHAR  KdPrintDefaultCircularBuffer[KDPRINTDEFAULTBUFFERSIZE] = {0};
PUCHAR KdPrintCircularBuffer = KdPrintDefaultCircularBuffer;
ULONG  KdPrintBufferSize = KDPRINTDEFAULTBUFFERSIZE;
PUCHAR KdPrintWritePointer = KdPrintDefaultCircularBuffer;
ULONG  KdPrintRolloverCount = 0;
ULONG  KdPrintBufferChanges = 0;


BREAKPOINT_ENTRY KdpBreakpointTable[BREAKPOINT_TABLE_SIZE] = {0};
// The message buffer needs to be 64-bit aligned.
UCHAR DECLSPEC_ALIGN(8) KdpMessageBuffer[KDP_MESSAGE_BUFFER_SIZE] = {0};
UCHAR KdpPathBuffer[KDP_MESSAGE_BUFFER_SIZE] = {0};
DBGKD_INTERNAL_BREAKPOINT KdpInternalBPs[DBGKD_MAX_INTERNAL_BREAKPOINTS] = {0};

KD_REMOTE_FILE KdpRemoteFiles[KD_MAX_REMOTE_FILES];

LARGE_INTEGER  KdPerformanceCounterRate = {0,0};
LARGE_INTEGER  KdTimerStart = {0,0} ;
LARGE_INTEGER  KdTimerStop = {0,0};
LARGE_INTEGER  KdTimerDifference = {0,0};

ULONG_PTR KdpCurrentSymbolStart = 0;
ULONG_PTR KdpCurrentSymbolEnd = 0;
LONG      KdpNextCallLevelChange = 0;   // used only over returns to the debugger.

ULONG_PTR KdSpecialCalls[DBGKD_MAX_SPECIAL_CALLS] = {0};
ULONG     KdNumberOfSpecialCalls = 0;
ULONG_PTR InitialSP = 0;
ULONG     KdpNumInternalBreakpoints = 0;
KTIMER    InternalBreakpointTimer = {0};
KDPC      InternalBreakpointCheckDpc = {0};

BOOLEAN   KdpPortLocked = FALSE;

DBGKD_TRACE_DATA TraceDataBuffer[TRACE_DATA_BUFFER_MAX_SIZE] = {0};
ULONG            TraceDataBufferPosition = 1; // Element # to write next
                                   // Recall elt 0 is a length

TRACE_DATA_SYM   TraceDataSyms[256] = {0};
UCHAR NextTraceDataSym = 0;     // what's the next one to be replaced
UCHAR NumTraceDataSyms = 0;     // how many are valid?

ULONG IntBPsSkipping = 0;       // number of exceptions that are being skipped
                                // now

BOOLEAN   WatchStepOver = FALSE;
BOOLEAN   BreakPointTimerStarted = FALSE;
PVOID     WSOThread = NULL;         // thread doing stepover
ULONG_PTR WSOEsp = 0;               // stack pointer of thread doing stepover (yes, we need it)
ULONG     WatchStepOverHandle = 0;
ULONG_PTR WatchStepOverBreakAddr = 0; // where the WatchStepOver break is set
BOOLEAN   WatchStepOverSuspended = FALSE;
ULONG     InstructionsTraced = 0;
BOOLEAN   SymbolRecorded = FALSE;
LONG      CallLevelChange = 0;
LONG_PTR  oldpc = 0;
BOOLEAN   InstrCountInternal = FALSE; // Processing a non-COUNTONLY?

BOOLEAN   BreakpointsSuspended = FALSE;

BOOLEAN   KdpControlCPressed = FALSE;

KDP_BREAKPOINT_TYPE KdpBreakpointInstruction = KDP_BREAKPOINT_VALUE;

KD_CONTEXT KdpContext;

LIST_ENTRY      KdpDebuggerDataListHead = {NULL,NULL};

//
// !search support variables (page hit database)
//

PFN_NUMBER KdpSearchPageHits [SEARCH_PAGE_HIT_DATABASE_SIZE] = {0};
ULONG KdpSearchPageHitOffsets [SEARCH_PAGE_HIT_DATABASE_SIZE] = {0};
ULONG KdpSearchPageHitIndex = 0;

LOGICAL KdpSearchInProgress = FALSE;

PFN_NUMBER KdpSearchStartPageFrame = 0;
PFN_NUMBER KdpSearchEndPageFrame = 0;

ULONG_PTR KdpSearchAddressRangeStart = 0;
ULONG_PTR KdpSearchAddressRangeEnd = 0;

PFN_NUMBER KdpSearchPfnValue = 0;

ULONG KdpSearchCheckPoint = KDP_SEARCH_SYMBOL_CHECK;

BOOLEAN KdpDebuggerStructuresInitialized = FALSE;

#ifdef _X86_
#ifdef ALLOC_PRAGMA
#pragma data_seg()
#endif
#endif // _X86_

KSPIN_LOCK KdpPrintSpinLock = 0;
KSPIN_LOCK      KdpDataSpinLock = 0;

#if !defined(_TRUSTED_WINDOWS_)
KSPIN_LOCK      KdpTimeSlipEventLock = 0;
PVOID           KdpTimeSlipEvent = NULL;
KDPC            KdpTimeSlipDpc = {0};
WORK_QUEUE_ITEM KdpTimeSlipWorkItem = {NULL};
KTIMER          KdpTimeSlipTimer = {0};
ULONG           KdpTimeSlipPending = 1;
#endif


BOOLEAN KdDebuggerNotPresent = FALSE;
BOOLEAN KdDebuggerEnabled = FALSE;
BOOLEAN KdAutoEnableOnEvent = FALSE;
BOOLEAN KdPitchDebugger = TRUE;
BOOLEAN KdpOweBreakpoint = FALSE;
BOOLEAN KdIgnoreUmExceptions = FALSE;
ULONG KdEnteredDebugger  = FALSE;

#if 0
#if !defined (PERF_DATA)
#if defined(_AMD64_)

C_ASSERT(sizeof(KPRCB) == AMD64_KPRCB_SIZE);
C_ASSERT(sizeof(EPROCESS) == AMD64_EPROCESS_SIZE);
C_ASSERT(FIELD_OFFSET(EPROCESS, Peb) == AMD64_PEB_IN_EPROCESS);
C_ASSERT(sizeof(ETHREAD) == AMD64_ETHREAD_SIZE);
C_ASSERT(sizeof(CONTEXT) == sizeof(AMD64_CONTEXT));
C_ASSERT(sizeof(KSPECIAL_REGISTERS) == sizeof(AMD64_KSPECIAL_REGISTERS));
C_ASSERT(FIELD_OFFSET(KTHREAD, NextProcessor) == AMD64_KTHREAD_NEXTPROCESSOR_OFFSET);
C_ASSERT(FIELD_OFFSET(KTHREAD, Teb) == AMD64_KTHREAD_TEB_OFFSET);

#elif defined(_X86_)

C_ASSERT(sizeof(KPRCB) == X86_NT51_KPRCB_SIZE);
C_ASSERT(sizeof(EPROCESS) == X86_NT511_EPROCESS_SIZE);
C_ASSERT(FIELD_OFFSET(EPROCESS, Peb) == X86_PEB_IN_EPROCESS);
C_ASSERT(sizeof(ETHREAD) == X86_ETHREAD_SIZE);
C_ASSERT(sizeof(CONTEXT) == sizeof(X86_NT5_CONTEXT));
C_ASSERT(sizeof(KSPECIAL_REGISTERS) == sizeof(X86_KSPECIAL_REGISTERS));
C_ASSERT(FIELD_OFFSET(KTHREAD, NextProcessor) == X86_3555_KTHREAD_NEXTPROCESSOR_OFFSET);
C_ASSERT(FIELD_OFFSET(KTHREAD, Teb) == X86_3555_KTHREAD_TEB_OFFSET);

#elif defined(_IA64_)

C_ASSERT(sizeof(KPRCB) == IA64_KPRCB_SIZE);
C_ASSERT(sizeof(EPROCESS) == IA64_EPROCESS_SIZE);
C_ASSERT(FIELD_OFFSET(EPROCESS, Peb) == IA64_3555_PEB_IN_EPROCESS);
C_ASSERT(sizeof(ETHREAD) == IA64_3555_ETHREAD_SIZE);
C_ASSERT(sizeof(CONTEXT) == sizeof(IA64_CONTEXT));
C_ASSERT(sizeof(KSPECIAL_REGISTERS) == sizeof(IA64_KSPECIAL_REGISTERS));
C_ASSERT(FIELD_OFFSET(KTHREAD, NextProcessor) == IA64_3555_KTHREAD_NEXTPROCESSOR_OFFSET);
C_ASSERT(FIELD_OFFSET(KTHREAD, Teb) == IA64_3555_KTHREAD_TEB_OFFSET);
#include <ia64\miia64.h>
C_ASSERT(IA64_PAGE_SIZE              == PAGE_SIZE);
C_ASSERT(IA64_PAGE_SHIFT             == PAGE_SHIFT);
C_ASSERT(IA64_MM_PTE_TRANSITION_MASK == MM_PTE_TRANSITION_MASK);
C_ASSERT(IA64_MM_PTE_PROTOTYPE_MASK  == MM_PTE_PROTOTYPE_MASK);

#else

#error "no target architecture"

#endif
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\i386\pbiosc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pbiosc.c

Abstract:

    This module contains Pnp BIOS dependent routines.  It includes code to initialize
    16 bit GDT selectors and to call pnp bios api.

Author:

    Shie-Lin Tzong (shielint) 15-Jan-1998

Environment:

    Kernel mode only.

Revision History:

--*/


#include "pnpmgrp.h"
#include "pnpcvrt.h"
#include "pbios.h"
#include "..\..\ke\i386\abios.h"

//
// Functions for PNP_BIOS_ENUMERATION_CONTEXT
//

#define PI_SHUTDOWN_EXAMINE_BIOS_DEVICE 1
#define PI_SHUTDOWN_LEGACY_RESOURCES    2

typedef struct _PNP_BIOS_DEVICE_NODE_LIST {
    struct _PNP_BIOS_DEVICE_NODE_LIST *Next;
    PNP_BIOS_DEVICE_NODE DeviceNode;
} PNP_BIOS_DEVICE_NODE_LIST, *PPNP_BIOS_DEVICE_NODE_LIST;

typedef struct _PNP_BIOS_ENUMERATION_CONTEXT {
    PUNICODE_STRING KeyName;
    ULONG Function;
    union {
        struct {
            PVOID BiosInfo;
            ULONG BiosInfoLength;
            PPNP_BIOS_DEVICE_NODE_LIST *DeviceList;
        } ExamineBiosDevice;
        struct {
            PCM_RESOURCE_LIST LegacyResources;
        } LegacyResources;
    } u;
} PNP_BIOS_ENUMERATION_CONTEXT, *PPNP_BIOS_ENUMERATION_CONTEXT;

typedef struct _PNP_BIOS_SHUT_DOWN_CONTEXT {
    PPNP_BIOS_DEVICE_NODE_LIST DeviceList;
    PVOID Resources;
} PNP_BIOS_SHUT_DOWN_CONTEXT, *PPNP_BIOS_SHUT_DOWN_CONTEXT;

//
// A big structure for calling Pnp BIOS functions
//

#define PNP_BIOS_GET_NUMBER_DEVICE_NODES    0
#define PNP_BIOS_GET_DEVICE_NODE            1
#define PNP_BIOS_SET_DEVICE_NODE            2
#define PNP_BIOS_GET_EVENT                  3
#define PNP_BIOS_SEND_MESSAGE               4
#define PNP_BIOS_GET_DOCK_INFORMATION       5
// Function 6 is reserved
#define PNP_BIOS_SELECT_BOOT_DEVICE         7
#define PNP_BIOS_GET_BOOT_DEVICE            8
#define PNP_BIOS_SET_OLD_ISA_RESOURCES      9
#define PNP_BIOS_GET_OLD_ISA_RESOURCES      0xA
#define PNP_BIOS_GET_ISA_CONFIGURATION      0x40

//
// Control Flags for Set_Device_node
//

#define SET_CONFIGURATION_NOW 1
#define SET_CONFIGURATION_FOR_NEXT_BOOT 2

typedef struct _PB_PARAMETERS {
    USHORT Function;
    union {
        struct {
            USHORT *NumberNodes;
            USHORT *NodeSize;
        } GetNumberDeviceNodes;

        struct {
            USHORT *Node;
            PPNP_BIOS_DEVICE_NODE NodeBuffer;
            USHORT Control;
        } GetDeviceNode;

        struct {
            USHORT Node;
            PPNP_BIOS_DEVICE_NODE NodeBuffer;
            USHORT Control;
        } SetDeviceNode;

        struct {
            USHORT *Message;
        } GetEvent;

        struct {
            USHORT Message;
        } SendMessage;

        struct {
            PVOID Resources;
        } SetAllocatedResources;
    } u;
} PB_PARAMETERS, *PPB_PARAMETERS;

#define PB_MAXIMUM_STACK_SIZE (sizeof(PB_PARAMETERS) + sizeof(USHORT) * 2)

//
// Status should be checked before calling PnP BIOS.
//              = STATUS_SUCCESS, can call PnP BIOS
//              = STATUS_NOT_SUPPORTED, dont call PnP BIOS
//              = STATUS_UNSUCCESSFUL, failed initialization, dont call PnP BIOS
//              = STATUS_REINITIALIZATION_NEEDED, try to initialize, call PnP BIOS only if successful.
//

NTSTATUS PbBiosInitialized = STATUS_REINITIALIZATION_NEEDED;

//
// PbBiosCodeSelector contains the selector of the PNP
// BIOS code.
//

USHORT PbBiosCodeSelector;

//
// PbBiosDataSelector contains the selector of the PNP
// BIOS data area (F0000-FFFFF)
//

USHORT PbBiosDataSelector;

//
// PbSelectors[] contains general purpose preallocated selectors
//

USHORT PbSelectors[2];

//
// PbBiosEntryPoint contains the Pnp Bios entry offset
//

ULONG PbBiosEntryPoint;

//
// SpinLock to serialize Pnp Bios call
//

KSPIN_LOCK PbBiosSpinlock;

//
// PiShutdownContext
//

PNP_BIOS_SHUT_DOWN_CONTEXT PiShutdownContext;

//
// External References
//

extern
USHORT
PbCallPnpBiosWorker (
    IN ULONG EntryOffset,
    IN ULONG EntrySelector,
    IN PUSHORT Parameters,
    IN USHORT Size
    );

//
// Internal prototypes
//

VOID
PnPBiosCollectLegacyDeviceResources (
    IN PCM_RESOURCE_LIST  *ReturnedResources
    );

VOID
PnPBiosReserveLegacyDeviceResources (
    IN PUCHAR BiosResources
    );

NTSTATUS
PnPBiosExamineDeviceKeys (
    IN PVOID BiosInfo,
    IN ULONG BiosInfoLength,
    IN OUT PPNP_BIOS_DEVICE_NODE_LIST *DeviceList
    );

BOOLEAN
PnPBiosExamineBiosDeviceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PPNP_BIOS_ENUMERATION_CONTEXT Context
    );

BOOLEAN
PnPBiosExamineBiosDeviceInstanceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PPNP_BIOS_ENUMERATION_CONTEXT Context
    );

NTSTATUS
PnPBiosExtractInfo(
    IN ULONG BiosHandle,
    IN PVOID BiosInfo,
    IN ULONG BiosInfoLength,
    OUT PVOID *Header,
    OUT ULONG *HeaderLength,
    OUT PVOID *Tail,
    OUT ULONG *TailLength
    );

VOID
PnPBiosSetDeviceNodes (
    IN PVOID Context
    );

NTSTATUS
PbHardwareService (
    IN PPB_PARAMETERS Parameters
    );

VOID
PbAddress32ToAddress16 (
    IN PVOID Address32,
    IN PUSHORT Address16,
    IN USHORT Selector
    );

BOOLEAN
PnPBiosGetBiosHandleFromDeviceKey(
    IN HANDLE KeyHandle,
    OUT PULONG BiosDeviceId
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PnPBiosGetBiosHandleFromDeviceKey)
#pragma alloc_text(PAGE, PnPBiosCollectLegacyDeviceResources)
#pragma alloc_text(PAGE, PnPBiosExamineDeviceKeys)
#pragma alloc_text(PAGE, PnPBiosExamineBiosDeviceKey)
#pragma alloc_text(PAGE, PnPBiosExamineBiosDeviceInstanceKey)
#pragma alloc_text(PAGE, PnPBiosExtractInfo)
#pragma alloc_text(PAGE, PnPBiosInitializePnPBios)
#pragma alloc_text(PAGELK, PbAddress32ToAddress16)
#pragma alloc_text(PAGELK, PnPBiosSetDeviceNodes)
#pragma alloc_text(PAGELK, PnPBiosReserveLegacyDeviceResources)
#pragma alloc_text(PAGELK, PbHardwareService)
#pragma alloc_text(PAGELK, PnPBiosShutdownSystem)
#endif

VOID
PnPBiosShutdownSystem (
    IN ULONG Phase,
    IN OUT PVOID *Context
    )

/*++

Routine Description:

    This routine performs the Pnp shutdowm preparation.
    At phase 0, it prepares the data for the Pnp bios devices whose states needed to be
    updated to pnp bios.
    At phase 1, we write the data to pnp bios.

Arguments:

    Phase - specifies the shutdown phase.

    Context - at phase 0, it supplies a variable to receive the returned context info.
              at phase 1, it supplies a variable to specify the context info.

Return Value:

    None.

--*/
{
    PVOID               biosInfo;
    ULONG               length, codeBase;
    NTSTATUS            status;
    PPNP_BIOS_DEVICE_NODE_LIST  pnpBiosDeviceNode;
    PCM_RESOURCE_LIST   legacyResources;
    PUCHAR              biosResources;
    PHYSICAL_ADDRESS    physicalAddr;
    PVOID               virtualAddr;
    KGDTENTRY           gdtEntry;

    ASSERT(!PpDisableFirmwareMapper);
    if (PpDisableFirmwareMapper) {

        return;
    }
    if (Phase == 0) {

        *Context = NULL;

        status = PnPBiosGetBiosInfo(&biosInfo, &length);
        if (NT_SUCCESS(status)) {

            if (PbBiosInitialized == STATUS_REINITIALIZATION_NEEDED) {

                PbBiosInitialized = STATUS_UNSUCCESSFUL;
                PbBiosEntryPoint = (ULONG)
                    ((PPNP_BIOS_INSTALLATION_CHECK)biosInfo)->ProtectedModeEntryOffset;
                //
                // Initialize selectors to use PNP bios code
                //
                gdtEntry.LimitLow                   = 0xFFFF;
                gdtEntry.HighWord.Bytes.Flags1      = 0;
                gdtEntry.HighWord.Bytes.Flags2      = 0;
                gdtEntry.HighWord.Bits.Pres         = 1;
                gdtEntry.HighWord.Bits.Dpl          = DPL_SYSTEM;
                gdtEntry.HighWord.Bits.Granularity  = GRAN_BYTE;
                gdtEntry.HighWord.Bits.Type         = 31;
                gdtEntry.HighWord.Bits.Default_Big  = 0;

                physicalAddr.HighPart = 0;
                physicalAddr.LowPart =
                    ((PPNP_BIOS_INSTALLATION_CHECK)biosInfo)->ProtectedModeCodeBaseAddress;
                virtualAddr = MmMapIoSpace (physicalAddr, 0x10000, TRUE);
                if (virtualAddr) {

                    codeBase = (ULONG)virtualAddr;

                    gdtEntry.BaseLow               = (USHORT) (codeBase & 0xffff);
                    gdtEntry.HighWord.Bits.BaseMid = (UCHAR)  (codeBase >> 16) & 0xff;
                    gdtEntry.HighWord.Bits.BaseHi  = (UCHAR)  (codeBase >> 24) & 0xff;

                    KeI386SetGdtSelector (PbBiosCodeSelector, &gdtEntry);
                    //
                    // initialize 16 bit data selector for Pnp BIOS
                    //
                    gdtEntry.LimitLow                   = 0xFFFF;
                    gdtEntry.HighWord.Bytes.Flags1      = 0;
                    gdtEntry.HighWord.Bytes.Flags2      = 0;
                    gdtEntry.HighWord.Bits.Pres         = 1;
                    gdtEntry.HighWord.Bits.Dpl          = DPL_SYSTEM;
                    gdtEntry.HighWord.Bits.Granularity  = GRAN_BYTE;
                    gdtEntry.HighWord.Bits.Type         = 19;
                    gdtEntry.HighWord.Bits.Default_Big  = 1;

                    physicalAddr.LowPart =
                        ((PPNP_BIOS_INSTALLATION_CHECK)biosInfo)->ProtectedModeDataBaseAddress;
                    virtualAddr = MmMapIoSpace (physicalAddr, 0x10000, TRUE);
                    if (virtualAddr) {

                        codeBase = (ULONG)virtualAddr;

                        gdtEntry.BaseLow               = (USHORT)(codeBase & 0xffff);
                        gdtEntry.HighWord.Bits.BaseMid = (UCHAR)(codeBase >> 16) & 0xff;
                        gdtEntry.HighWord.Bits.BaseHi  = (UCHAR)(codeBase >> 24) & 0xff;

                        KeI386SetGdtSelector (PbBiosDataSelector, &gdtEntry);
                        //
                        // Initialize the other two general purpose data selector such that
                        // on subsequent init we only need to init the base addr.
                        //
                        KeI386SetGdtSelector (PbSelectors[0], &gdtEntry);
                        KeI386SetGdtSelector (PbSelectors[1], &gdtEntry);

                        PbBiosInitialized = STATUS_SUCCESS;
                    }
                }
            }
            PnPBiosExamineDeviceKeys(
                         biosInfo,
                         length,
                         (PPNP_BIOS_DEVICE_NODE_LIST *) &PiShutdownContext.DeviceList
                         );
            PnPBiosCollectLegacyDeviceResources (&legacyResources);
            if (legacyResources) {
                status = PpCmResourcesToBiosResources (legacyResources, NULL, &biosResources, &length);
                if (NT_SUCCESS(status) && biosResources) {
                    PiShutdownContext.Resources = (PCM_RESOURCE_LIST)ExAllocatePool(NonPagedPool, length);
                    if (PiShutdownContext.Resources) {
                        RtlMoveMemory(PiShutdownContext.Resources, biosResources, length);
                    }
                    ExFreePool(biosResources);
                }
                ExFreePool(legacyResources);
            }
            if (PiShutdownContext.DeviceList || PiShutdownContext.Resources) {
                *Context = &PiShutdownContext;
            }
            ExFreePool(biosInfo);
        }

        return;

    } else if (*Context) {
        //
        // Phase 1: Everything below should be PAGELK or NonPaged
        //
        ASSERT(*Context == &PiShutdownContext);
        pnpBiosDeviceNode = PiShutdownContext.DeviceList;
        biosResources = PiShutdownContext.Resources;
        if (pnpBiosDeviceNode || biosResources) {

            //
            // Call pnp bios from boot processor
            //

            KeSetSystemAffinityThread(1);

            if (pnpBiosDeviceNode) {
                PnPBiosSetDeviceNodes(pnpBiosDeviceNode);
            }
            if (biosResources) {
                PnPBiosReserveLegacyDeviceResources(biosResources);
            }

            //
            // Restore old affinity for current thread.
            //

            KeRevertToUserAffinityThread();
        }
    }
}

BOOLEAN
PnPBiosGetBiosHandleFromDeviceKey(
    IN HANDLE KeyHandle,
    OUT PULONG BiosDeviceId
    )
/*++

Routine Description:

    This routine takes a handle to System\Enum\Root\<Device Instance> and sets
    BiosDeviceId to the PNPBIOS ID of the device.

Arguments:

    KeyHandle - handle to System\Enum\Root\<Device Instance>

    BiosDeviceId - After this function is ran, this value will be filled with
                   the ID assigned to the device by PNPBIOS.

Return Value:

    FALSE if the handle does not refer to a PNPBIOS device.

--*/
{
    UNICODE_STRING unicodeName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    NTSTATUS status;
    HANDLE handle;
    ULONG biosDeviceHandle = ~0ul;

    PAGED_CODE();

    //
    // Make sure this is a pnp bios device by checking its pnp bios device
    // handle.
    //
    PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
    status = IopOpenRegistryKeyEx( &handle,
                                   KeyHandle,
                                   &unicodeName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS(status)) {
        return FALSE ;
    }

    status = IopGetRegistryValue (handle,
                                  L"PnpBiosDeviceHandle",
                                  &keyValueInformation);
    ZwClose(handle);

    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength == sizeof(ULONG))) {

            biosDeviceHandle = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }
    if (biosDeviceHandle > 0xffff) {
        return FALSE;
    }
    *BiosDeviceId = biosDeviceHandle ;
    return TRUE ;
}

VOID
PnPBiosCollectLegacyDeviceResources (
    IN PCM_RESOURCE_LIST *ReturnedResources
    )

/*++

Routine Description:


Arguments:

    ReturnedResources - supplies a pointer to a variable to receive legacy resources.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    HANDLE baseHandle;
    PNP_BIOS_ENUMERATION_CONTEXT context;
    PVOID buffer;
    UNICODE_STRING workName, tmpName;

    PAGED_CODE();

    *ReturnedResources = NULL;

    buffer = ExAllocatePool(PagedPool, PNP_LARGE_SCRATCH_BUFFER_SIZE);
    if (!buffer) {
        return;
    }

    //
    // Open System\CurrentControlSet\Enum\Root key and call worker routine to recursively
    // scan through the subkeys.
    //

    status = IopCreateRegistryKeyEx( &baseHandle,
                                     NULL,
                                     &CmRegistryMachineSystemCurrentControlSetEnumRootName,
                                     KEY_READ,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    if (NT_SUCCESS(status)) {

        workName.Buffer = (PWSTR)buffer;
        RtlFillMemory(buffer, PNP_LARGE_SCRATCH_BUFFER_SIZE, 0);
        workName.MaximumLength = PNP_LARGE_SCRATCH_BUFFER_SIZE;
        workName.Length = 0;
        PiWstrToUnicodeString(&tmpName, REGSTR_KEY_ROOTENUM);
        RtlAppendStringToString((PSTRING)&workName, (PSTRING)&tmpName);

        //
        // Enumerate all subkeys under the System\CCS\Enum\Root.
        //

        context.KeyName = &workName;
        context.Function = PI_SHUTDOWN_LEGACY_RESOURCES;
        context.u.LegacyResources.LegacyResources = NULL;
        status = PipApplyFunctionToSubKeys(baseHandle,
                                           NULL,
                                           KEY_READ,
                                           FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS,
                                           PnPBiosExamineBiosDeviceKey,
                                           &context
                                           );
        ZwClose(baseHandle);
        *ReturnedResources = context.u.LegacyResources.LegacyResources;
    }
    ExFreePool(buffer);
}

NTSTATUS
PnPBiosExamineDeviceKeys (
    IN PVOID BiosInfo,
    IN ULONG BiosInfoLength,
    IN OUT PPNP_BIOS_DEVICE_NODE_LIST *DeviceList
    )

/*++

Routine Description:

    This routine scans through System\Enum\Root subtree to build a device node for
    each root device.

Arguments:

    DeviceRelations - supplies a variable to receive the returned DEVICE_RELATIONS structure.

Return Value:

    A NTSTATUS code.

--*/

{
    NTSTATUS status;
    HANDLE baseHandle;
    PNP_BIOS_ENUMERATION_CONTEXT context;
    PVOID buffer;
    UNICODE_STRING workName, tmpName;

    PAGED_CODE();

    buffer = ExAllocatePool(PagedPool, PNP_LARGE_SCRATCH_BUFFER_SIZE);
    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Open System\CurrentControlSet\Enum\Root key and call worker routine to recursively
    // scan through the subkeys.
    //

    status = IopCreateRegistryKeyEx( &baseHandle,
                                     NULL,
                                     &CmRegistryMachineSystemCurrentControlSetEnumRootName,
                                     KEY_READ,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    if (NT_SUCCESS(status)) {
        workName.Buffer = (PWSTR)buffer;
        RtlFillMemory(buffer, PNP_LARGE_SCRATCH_BUFFER_SIZE, 0);
        workName.MaximumLength = PNP_LARGE_SCRATCH_BUFFER_SIZE;
        workName.Length = 0;
        PiWstrToUnicodeString(&tmpName, REGSTR_KEY_ROOTENUM);
        RtlAppendStringToString((PSTRING)&workName, (PSTRING)&tmpName);

        //
        // Enumerate all subkeys under the System\CCS\Enum\Root.
        //

        context.KeyName = &workName;
        context.Function = PI_SHUTDOWN_EXAMINE_BIOS_DEVICE;
        context.u.ExamineBiosDevice.BiosInfo = BiosInfo;
        context.u.ExamineBiosDevice.BiosInfoLength = BiosInfoLength;
        context.u.ExamineBiosDevice.DeviceList = DeviceList;

        status = PipApplyFunctionToSubKeys(baseHandle,
                                           NULL,
                                           KEY_READ,
                                           FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS,
                                           PnPBiosExamineBiosDeviceKey,
                                           &context
                                           );
        ZwClose(baseHandle);
    }
    return status;
}

BOOLEAN
PnPBiosExamineBiosDeviceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PPNP_BIOS_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine is a callback function for PipApplyFunctionToSubKeys.
    It is called for each subkey under HKLM\System\CCS\Enum\BusKey.

Arguments:

    KeyHandle - Supplies a handle to this key.

    KeyName - Supplies the name of this key.

    Context - points to the ROOT_ENUMERATOR_CONTEXT structure.

Returns:

    TRUE to continue the enumeration.
    FALSE to abort it.

--*/
{
    USHORT length;
    PWSTR p;
    PUNICODE_STRING unicodeName;

    PAGED_CODE();

    if (Context->Function != PI_SHUTDOWN_EXAMINE_BIOS_DEVICE ||
        KeyName->Buffer[0] == L'*') {

        unicodeName = ((PPNP_BIOS_ENUMERATION_CONTEXT)Context)->KeyName;
        length = unicodeName->Length;

        p = unicodeName->Buffer;
        if ( unicodeName->Length / sizeof(WCHAR) != 0) {
            p += unicodeName->Length / sizeof(WCHAR);
            *p = OBJ_NAME_PATH_SEPARATOR;
            unicodeName->Length += sizeof (WCHAR);
        }

        RtlAppendStringToString((PSTRING)unicodeName, (PSTRING)KeyName);

        //
        // Enumerate all subkeys under the current device key.
        //

        PipApplyFunctionToSubKeys(KeyHandle,
                                  NULL,
                                  KEY_ALL_ACCESS,
                                  FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS,
                                  PnPBiosExamineBiosDeviceInstanceKey,
                                  Context
                                  );
        unicodeName->Length = length;
    }
    return TRUE;
}

BOOLEAN
PnPBiosExamineBiosDeviceInstanceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PPNP_BIOS_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine is a callback function for PipApplyFunctionToSubKeys.
    It is called for each subkey under HKLM\System\Enum\Root\DeviceKey.

Arguments:

    KeyHandle - Supplies a handle to this key.

    KeyName - Supplies the name of this key.

    Context - points to the ROOT_ENUMERATOR_CONTEXT structure.

Returns:

    TRUE to continue the enumeration.
    FALSE to abort it.

--*/
{
    UNICODE_STRING unicodeName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    NTSTATUS status;
    HANDLE handle;
    ULONG biosDeviceHandle = ~0ul;
    PCM_RESOURCE_LIST config = NULL;
    ULONG length, totalLength;
    PPNP_BIOS_DEVICE_NODE_LIST deviceNode;
    PUCHAR p;
    PVOID header, tail;
    ULONG headerLength, tailLength ;
    PUCHAR biosResources;
    BOOLEAN isEnabled ;

    UNREFERENCED_PARAMETER( KeyName );

    PAGED_CODE();

    if (Context->Function == PI_SHUTDOWN_LEGACY_RESOURCES) {
        ULONG tmp = 0;

        //
        // Skip any firmware identified device.
        //

        status = IopGetRegistryValue (KeyHandle,
                                      L"FirmwareIdentified",
                                      &keyValueInformation);
        if (NT_SUCCESS(status)) {
            if ((keyValueInformation->Type == REG_DWORD) &&
                (keyValueInformation->DataLength == sizeof(ULONG))) {

                tmp = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            }
            ExFreePool(keyValueInformation);
        }
        if (tmp != 0) {
            return TRUE;
        }

        //
        // Skip any IoReportDetectedDevice and virtual/madeup device.
        //

        status = IopGetRegistryValue (KeyHandle,
                                      L"Legacy",
                                      &keyValueInformation);
        if (NT_SUCCESS(status)) {
            ExFreePool(keyValueInformation);
        }
        if (status != STATUS_OBJECT_NAME_NOT_FOUND) {
            return TRUE;
        }

        //
        // Process it.
        // Check if the device has BOOT config
        //

        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
        status = IopOpenRegistryKeyEx( &handle,
                                       KeyHandle,
                                       &unicodeName,
                                       KEY_READ
                                       );
        if (NT_SUCCESS(status)) {
            status = PipReadDeviceConfiguration (
                                    handle,
                                    REGISTRY_BOOT_CONFIG,
                                    &config,
                                    &length);
            ZwClose(handle);
            if (NT_SUCCESS(status) && config && length != 0) {
                PCM_RESOURCE_LIST list;

                list = Context->u.LegacyResources.LegacyResources;
                status = IopMergeCmResourceLists(list, config, &Context->u.LegacyResources.LegacyResources);
                if (NT_SUCCESS(status) && list) {
                    ExFreePool(list);
                }
                ExFreePool(config);
            }
        }
    } else if (Context->Function == PI_SHUTDOWN_EXAMINE_BIOS_DEVICE) {
        //
        // First check if this key was created by firmware mapper.  If yes, make sure
        // the device is still present.
        //

        if (PipIsFirmwareMapperDevicePresent(KeyHandle) == FALSE) {
            return TRUE;
        }

        //
        // Make sure this is a pnp bios device by checking its pnp bios
        // device handle.
        //
        if (!PnPBiosGetBiosHandleFromDeviceKey(KeyHandle, &biosDeviceHandle)) {
            return TRUE ;
        }

        //
        // Get pointers to the header and tail.
        //
        // Gross hack warning -
        //    In the disable case, we need a bios resource template to whack
        // to "off". We will index into header to do this, as header and tail
        // point directly into the BIOS resource list!
        //
        status = PnPBiosExtractInfo (
                            biosDeviceHandle,
                            Context->u.ExamineBiosDevice.BiosInfo,
                            Context->u.ExamineBiosDevice.BiosInfoLength,
                            &header,
                            &headerLength,
                            &tail,
                            &tailLength
                            );

        if (!NT_SUCCESS(status)) {
            return TRUE;
        }

        //
        // Has this PnPBIOS device been disabled?
        //
        // N.B. This check examines flags for the current profile. We actually
        // have no clue what profile we will next be booting into, so the UI
        // should not show disable in current profile for PnPBIOS devices. A
        // work item yet to be done...
        //
        isEnabled = IopIsDeviceInstanceEnabled(KeyHandle, Context->KeyName, FALSE) ;

        if (!isEnabled) {

            //
            // This device is being disabled. Set up and attain a pointer to
            // the appropriately built BIOS resource list.
            //
            biosResources = ((PUCHAR)header) + sizeof(PNP_BIOS_DEVICE_NODE) ;
            PpBiosResourcesSetToDisabled (biosResources, &length);

        } else {

            //
            // Check if the pnp bios device has any assigned ForcedConfig
            //
            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
            status = IopOpenRegistryKeyEx( &handle,
                                           KeyHandle,
                                           &unicodeName,
                                           KEY_READ
                                           );
            if (!NT_SUCCESS(status)) {
                return TRUE ;
            }

            status = PipReadDeviceConfiguration (
                           handle,
                           REGISTRY_FORCED_CONFIG,
                           &config,
                           &length
                           );

            ZwClose(handle);
            if ((!NT_SUCCESS(status)) || (!config) || (length == 0)) {
                return TRUE ;
            }

            status = PpCmResourcesToBiosResources (
                                config,
                                tail,
                                &biosResources,
                                &length
                                );
            ExFreePool(config);
            if (!NT_SUCCESS(status) || !biosResources) {
                return TRUE;
            }
        }

        //
        // Allocate PNP_BIOS_DEVICE_NODE_LIST structure
        //

        totalLength = headerLength + length + tailLength;
        deviceNode = ExAllocatePool(NonPagedPool, totalLength + sizeof(PVOID));
        if (deviceNode) {
           deviceNode->Next = *(Context->u.ExamineBiosDevice.DeviceList);
               *(Context->u.ExamineBiosDevice.DeviceList) = deviceNode;
               p = (PUCHAR)&deviceNode->DeviceNode;
               RtlCopyMemory(p, header, headerLength);
               p += headerLength;
               RtlCopyMemory(p, biosResources, length);
               p += length;
               RtlCopyMemory(p, tail, tailLength);
               deviceNode->DeviceNode.Size = (USHORT)totalLength;
        }

        if (isEnabled) {
            ExFreePool(biosResources);
        }
    }
    return TRUE;
}

NTSTATUS
PnPBiosExtractInfo(
    IN ULONG BiosHandle,
    IN PVOID BiosInfo,
    IN ULONG BiosInfoLength,
    OUT PVOID *Header,
    OUT ULONG *HeaderLength,
    OUT PVOID *Tail,
    OUT ULONG *TailLength
    )

/*++

Routine Description:

    This routine extracts desired information for the specified bios device.

Arguments:

    BiosHandle - specifies the bios device.

    BiosInfo - The PnP BIOS Installation Check Structure followed by the
        DevNode Structures reported by the BIOS.  The detailed format is
        documented in the PnP BIOS spec.

    BiosInfoLength - Length in bytes of the block whose address is stored in
        BiosInfo.

    Header - specifies a variable to receive the beginning address of the bios
             device node structure.

    HeaderLength - specifies a variable to receive the length of the bios device
             node header.

    Tail - specifies a variable to receive the address of the bios device node's
           PossibleResourceBlock.

    TailLength - specifies a variable to receive the size of the tail.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    PCM_PNP_BIOS_INSTALLATION_CHECK biosInstallCheck;
    PCM_PNP_BIOS_DEVICE_NODE        devNodeHeader;
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;
    PUCHAR                          currentPtr;
    int                             lengthRemaining;
    int                             remainingNodeLength;
    int                             numNodes;
    PUCHAR                          configPtr;

    PAGED_CODE();

#if DBG

    //
    // Make sure the data is at least large enough to hold the BIOS Installation
    // Check structure and check that the PnP signature is correct.
    //

    if (BiosInfoLength < sizeof(CM_PNP_BIOS_INSTALLATION_CHECK)) {
        return STATUS_UNSUCCESSFUL;
    }

#endif

    biosInstallCheck = (PCM_PNP_BIOS_INSTALLATION_CHECK)BiosInfo;

#if DBG

    if (biosInstallCheck->Signature[0] != '$' ||
        biosInstallCheck->Signature[1] != 'P' ||
        biosInstallCheck->Signature[2] != 'n' ||
        biosInstallCheck->Signature[3] != 'P') {

        return STATUS_UNSUCCESSFUL;
    }

#endif

    currentPtr = (PUCHAR)BiosInfo + biosInstallCheck->Length;
    lengthRemaining = BiosInfoLength - biosInstallCheck->Length;

    for (numNodes = 0; lengthRemaining > sizeof(CM_PNP_BIOS_DEVICE_NODE); numNodes++) {

        devNodeHeader = (PCM_PNP_BIOS_DEVICE_NODE)currentPtr;

        if (devNodeHeader->Size > lengthRemaining) {
            IopDbgPrint((IOP_PNPBIOS_WARNING_LEVEL,
                        "Node # %d, invalid size (%d), length remaining (%d)\n",
                        devNodeHeader->Node,
                        devNodeHeader->Size,
                        lengthRemaining));
            return STATUS_UNSUCCESSFUL;
        }

        if (devNodeHeader->Node == BiosHandle) {
            *Header = devNodeHeader;
            *HeaderLength = sizeof(CM_PNP_BIOS_DEVICE_NODE);

            configPtr = currentPtr + sizeof(*devNodeHeader);
            remainingNodeLength = devNodeHeader->Size - sizeof(*devNodeHeader) - 1;
            while (*configPtr != TAG_COMPLETE_END && remainingNodeLength) {
                configPtr++;
                remainingNodeLength--;
            }
            if (*configPtr == TAG_COMPLETE_END && remainingNodeLength) {
                configPtr += 2;
                remainingNodeLength--;
            }
            *Tail = configPtr;
            *TailLength = remainingNodeLength;
            status = STATUS_SUCCESS;
            break;
        }
        currentPtr += devNodeHeader->Size;
        lengthRemaining -= devNodeHeader->Size;
    }
    return status;
}

NTSTATUS
PnPBiosInitializePnPBios (
    VOID
    )

/*++

Routine Description:

    This routine setup selectors to invoke Pnp BIOS.

Arguments:

    None.

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
    ULONG i;
    NTSTATUS status;
    USHORT selectors[4];

    PAGED_CODE();
    //
    // Check if we even need to initialize support for PnP BIOS.
    //
    ASSERT(!PpDisableFirmwareMapper);
    if (PpDisableFirmwareMapper) {

        PbBiosInitialized = STATUS_NOT_SUPPORTED;
        return PbBiosInitialized;
    }
    //
    // Initialize BIOS call spinlock
    //
    KeInitializeSpinLock (&PbBiosSpinlock);

    //
    // Call pnp bios from boot processor
    //
    KeSetSystemAffinityThread(1);

    //
    // Initialize stack segment
    //
    KiStack16GdtEntry = KiAbiosGetGdt() + KGDT_STACK16;

    KiInitializeAbiosGdtEntry(
                (PKGDTENTRY)KiStack16GdtEntry,
                0L,
                0xffff,
                TYPE_DATA
                );

    //
    // Allocate 4 selectors for calling PnP Bios APIs.
    //

    i = 4;
    status = KeI386AllocateGdtSelectors (selectors, (USHORT) i);
    if (NT_SUCCESS(status)) {

        PbBiosCodeSelector = selectors[0];
        PbBiosDataSelector = selectors[1];
        PbSelectors[0] = selectors[2];
        PbSelectors[1] = selectors[3];

        PbBiosInitialized = STATUS_REINITIALIZATION_NEEDED;
    } else {

        PbBiosInitialized = STATUS_UNSUCCESSFUL;
        IopDbgPrint((IOP_PNPBIOS_WARNING_LEVEL,
                    "PnpBios: Failed to allocate selectors to call PnP BIOS at shutdown.\n"));
    }

    KeRevertToUserAffinityThread();

    return status;
}

VOID
PnPBiosSetDeviceNodes (
    IN PVOID Context
    )

/*++

Routine Description:

    This function sets the caller specified resource to pnp bios slot/device
    data.

Arguments:

    Context - specifies a list of Pnp bios device to be set.

Return Value:

    NTSTATUS code

--*/
{
    PB_PARAMETERS biosParameters;
    PPNP_BIOS_DEVICE_NODE_LIST deviceList = (PPNP_BIOS_DEVICE_NODE_LIST)Context;
    PPNP_BIOS_DEVICE_NODE deviceNode;

    while (deviceList) {
        deviceNode = &deviceList->DeviceNode;

        //
        // call Pnp Bios to set the resources
        //

        biosParameters.Function = PNP_BIOS_SET_DEVICE_NODE;
        biosParameters.u.SetDeviceNode.Node = deviceNode->Node;
        biosParameters.u.SetDeviceNode.NodeBuffer = deviceNode;
        biosParameters.u.SetDeviceNode.Control = SET_CONFIGURATION_FOR_NEXT_BOOT;
        PbHardwareService (&biosParameters);            // Ignore the return status
        deviceList = deviceList->Next;
    }
}

VOID
PnPBiosReserveLegacyDeviceResources (
    IN PUCHAR biosResources
    )

/*++

Routine Description:


Arguments:

    ReturnedResources - supplies a pointer to a variable to receive legacy resources.

Return Value:

    None.

--*/

{
    PB_PARAMETERS biosParameters;

    //
    // call Pnp Bios to reserve the resources
    //

    biosParameters.Function = PNP_BIOS_SET_OLD_ISA_RESOURCES;
    biosParameters.u.SetAllocatedResources.Resources = biosResources;
    PbHardwareService (&biosParameters);            // Ignore the return status

}

NTSTATUS
PbHardwareService (
    IN PPB_PARAMETERS Parameters
    )

/*++

Routine Description:

    This routine sets up stack parameters and calls an
    assembly worker routine to actually invoke the PNP BIOS code.

Arguments:

    Parameters - supplies a pointer to the parameter block.

Return Value:

    An NTSTATUS code to indicate the result of the operation.

--*/
{
    NTSTATUS status ;
    USHORT stackParameters[PB_MAXIMUM_STACK_SIZE / 2];
    ULONG i = 0;
    USHORT retCode;
    KIRQL oldIrql;

    //
    // Did we initialize correctly?
    //
    status = PbBiosInitialized;
    if (!NT_SUCCESS(status)) {

        return status ;
    }

    //
    // Convert and copy the caller's parameters to the format that
    // will be used to invoked pnp bios.
    //

    stackParameters[i] = Parameters->Function;
    i++;

    switch (Parameters->Function) {
    case PNP_BIOS_SET_DEVICE_NODE:
         stackParameters[i++] = Parameters->u.SetDeviceNode.Node;
         PbAddress32ToAddress16(Parameters->u.SetDeviceNode.NodeBuffer,
                                &stackParameters[i],
                                PbSelectors[0]);
         i += 2;
         stackParameters[i++] = Parameters->u.SetDeviceNode.Control;
         stackParameters[i++] = PbBiosDataSelector;
         break;

    case PNP_BIOS_SET_OLD_ISA_RESOURCES:
         PbAddress32ToAddress16(Parameters->u.SetAllocatedResources.Resources,
                                &stackParameters[i],
                                PbSelectors[0]);
         i += 2;
         stackParameters[i++] = PbBiosDataSelector;
         break;
    default:
        return STATUS_NOT_IMPLEMENTED;
    }

    MmLockPagableSectionByHandle(ExPageLockHandle);
    //
    // Copy the parameters to stack and invoke Pnp Bios.
    //

    ExAcquireSpinLock (&PbBiosSpinlock, &oldIrql);

    retCode = PbCallPnpBiosWorker (
                  PbBiosEntryPoint,
                  PbBiosCodeSelector,
                  stackParameters,
                  (USHORT)(i * sizeof(USHORT)));

    ExReleaseSpinLock (&PbBiosSpinlock, oldIrql);

    MmUnlockPagableImageSection(ExPageLockHandle);

    //
    // Map Bios returned code to nt status code.
    //

    if (retCode == 0) {
        return STATUS_SUCCESS;
    } else {
        IopDbgPrint((IOP_PNPBIOS_WARNING_LEVEL,
                    "PnpBios: Bios API call failed. Returned Code = %x\n", retCode));
        return STATUS_UNSUCCESSFUL;
    }
}

VOID
PbAddress32ToAddress16 (
    IN PVOID Address32,
    IN PUSHORT Address16,
    IN USHORT Selector
    )

/*++

Routine Description:

    This routine converts the 32 bit address to 16 bit selector:offset address
    and stored in user specified location.

Arguments:

    Address32 - the 32 bit address to be converted.

    Address16 - supplies the location to receive the 16 bit sel:offset address

    Selector - the 16 bit selector for seg:offset address

Return Value:

    None.

--*/
{
    KGDTENTRY  gdtEntry;
    ULONG      baseAddr;

    //
    // Map virtual address to selector:0 address
    //

    gdtEntry.LimitLow                   = 0xFFFF;
    gdtEntry.HighWord.Bytes.Flags1      = 0;
    gdtEntry.HighWord.Bytes.Flags2      = 0;
    gdtEntry.HighWord.Bits.Pres         = 1;
    gdtEntry.HighWord.Bits.Dpl          = DPL_SYSTEM;
    gdtEntry.HighWord.Bits.Granularity  = GRAN_BYTE;
    gdtEntry.HighWord.Bits.Type         = 19;
    gdtEntry.HighWord.Bits.Default_Big  = 1;
    baseAddr = (ULONG)Address32;
    gdtEntry.BaseLow               = (USHORT) (baseAddr & 0xffff);
    gdtEntry.HighWord.Bits.BaseMid = (UCHAR)  (baseAddr >> 16) & 0xff;
    gdtEntry.HighWord.Bits.BaseHi  = (UCHAR)  (baseAddr >> 24) & 0xff;
    KeI386SetGdtSelector (Selector, &gdtEntry);
    *Address16 = 0;
    *(Address16 + 1) = Selector;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=kd

TARGETNAME=kd
TARGETTYPE=LIBRARY
TARGETPATH=obj

BUILD_PRODUCES=ntoskd$(NT_UP)

INCLUDES=..;\
    ..\..\inc;\
    ..\..\ke;\
    ..\..\mm;\
    ..\$(TARGET_DIRECTORY);\
    $(PROJECT_ROOT)\published\$(O);\
    $(SDKTOOLS_INC_PATH)

MSC_WARNING_LEVEL=/W4 /WX

SOURCES=..\file.c    \
        ..\kdinit.c  \
        ..\kdbreak.c \
        ..\kdlock.c  \
        ..\kdmove.c  \
        ..\kddbgio.c \
        ..\kdapi.c   \
        ..\kddata.c  \
        ..\print.c   \
        ..\query.c

PRECOMPILED_INCLUDE=..\kdp.h
PRECOMPILED_PCH=kdp.pch
PRECOMPILED_OBJ=kdp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\amd64\kdcmsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcmsup.c

Abstract:

    Com support.  Code to init a com port, store port state, map
    portable procedures to x86 procedures.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

    Shielin Tzong (shielint) 10-Apr-91
                Add packet control protocol.

--*/

#include "kdp.h"

LARGE_INTEGER
KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpQueryPerformanceCounter)
#endif

LARGE_INTEGER
KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

    Routine Description:

        This function optionaly calls KeQueryPerformanceCounter for
        the debugger.  If the trap had interrupts off, then no call
        to KeQueryPerformanceCounter is possible and a NULL is returned.

    Return Value:

        returns KeQueryPerformanceCounter if possible.
        otherwise 0

--*/

{

    if (!(TrapFrame->EFlags & EFLAGS_IF_MASK)) {
        LARGE_INTEGER LargeIntegerZero;

        LargeIntegerZero.QuadPart = 0;
        return LargeIntegerZero;

    } else {
        return KeQueryPerformanceCounter(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\kdmove.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdmove.c

Abstract:

    This module contains code to implement the portable kernel debugger
    memory mover.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "kdp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpQuickMoveMemory)
#pragma alloc_text(PAGEKD, KdpCopyMemoryChunks)
#endif

VOID
KdpQuickMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine does the exact same thing as RtlCopyMemory, BUT it is
    private to the debugger.  This allows folks to set breakpoints and
    watch points in RtlCopyMemory without risk of recursive debugger
    entry and the accompanying hang.

    N.B.  UNLIKE KdpCopyMemoryChunks, this routine does NOT check for
      accessibility and may fault!  Use it ONLY in the debugger and ONLY
      where you could use RtlCopyMemory.

Arguments:

    Destination  - Supplies a pointer to destination of the move operation.

    Source - Supplies a pointer to the source of the move operation.

    Length - Supplies the length of the move operation.

Return Value:

    None.

--*/
{
    while (Length > 0) {
        *Destination = *Source;
        Destination++;
        Source++;
        Length--;
    }
}

NTSTATUS
KdpCopyMemoryChunks(
    ULONG64 Address,
    PVOID Buffer,
    ULONG TotalSize,
    ULONG ChunkSize,
    ULONG Flags,
    PULONG ActualSize OPTIONAL
    )

/*++

Routine Description:

    Copies memory to/from a buffer to/from a system address.
    The address can be physical or virtual.

    The buffer is assumed to be valid for the duration of this call.

Arguments:

    Address - System address.

    Buffer - Buffer to read from or write to.

    TotalSize - Number of bytes to read/write.

    ChunkSize - Maximum single item transfer size, must
                be 1, 2, 4 or 8.
                0 means choose a default.

    Flags - MMDBG_COPY flags for MmDbgCopyMemory.
    
    ActualSize - Number of bytes actually read/written.

Return Value:

    NTSTATUS

--*/

{
    ULONG Length;
    ULONG CopyChunk;
    NTSTATUS Status;
#if defined(_IA64_)
    ULONG64 AddressStart = Address;
#endif

    if (ChunkSize > MMDBG_COPY_MAX_SIZE) {
        ChunkSize = MMDBG_COPY_MAX_SIZE;
    } else if (ChunkSize == 0) {
        // Default to 4 byte chunks as that's
        // what the previous code did.
        ChunkSize = 4;
    }

    //
    // MmDbgCopyMemory only copies a single aligned chunk at a
    // time.  It is Kd's responsibility to chunk up a larger
    // request for individual copy requests.  This gives Kd
    // the flexibility to pick a chunk size and also frees
    // Mm from having to worry about more than a page at a time.
    // Additionally, it is important that we access memory with the
    // largest size possible because we could be accessing
    // memory-mapped I/O space.
    //

    Length = TotalSize;
    CopyChunk = 1;
    
    while (Length > 0) {

        // Expand the chunk size as long as:
        //   We haven't hit the chunk limit.
        //   We have enough data left.
        //   The address is properly aligned.
        while (CopyChunk < ChunkSize &&
               (CopyChunk << 1) <= Length &&
               (Address & ((CopyChunk << 1) - 1)) == 0) {
            CopyChunk <<= 1;
        }
        
        // Shrink the chunk size to fit the available data.
        while (CopyChunk > Length) {
            CopyChunk >>= 1;
        }
        
        Status = MmDbgCopyMemory(Address, Buffer, CopyChunk, Flags);

        if (!NT_SUCCESS(Status)) {
            break;
        }

        Address += CopyChunk;
        Buffer = (PVOID)((PUCHAR)Buffer + CopyChunk);
        Length -= CopyChunk;
    }

    if (ActualSize)
    {
        *ActualSize = TotalSize - Length;
    }

    //
    // Flush the instruction cache in case the write was into the instruction
    // stream.  Only do this when writing into the kernel address space,
    // and if any bytes were actually written
    //

    if ((Flags & MMDBG_COPY_WRITE) &&
        Length < TotalSize) {

#if defined(_IA64_)

        //
        // KeSweepCurrentIcacheRange requires a valid virtual address.
        // It is used because KeSweepCurrentICache does not work until
        // the HAL as been initialized.
        //

        if (Flags & MMDBG_COPY_PHYSICAL) {

            KeSweepCurrentIcache();            

        } else{

            KeSweepCurrentIcacheRange((PVOID)AddressStart, TotalSize - Length);
        }

#else
        KeSweepCurrentIcache();
#endif

    }

    return Length != 0 ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\amd64\kdtrap.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    kdtrap.c

Abstract:

    This module contains code to implement the target side of the portable
    kernel debugger.

Author:

    David N. Cutler (davec) 14-May-2000

Revision History:

--*/

#include "kdp.h"

#pragma alloc_text(PAGEKD, KdpTrap)
#pragma alloc_text(PAGEKD, KdIsThisAKdTrap)

BOOLEAN
KdpTrap (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine is called whenever a exception is dispatched and the kernel
    debugger is active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{

    BOOLEAN Completion = FALSE;
    BOOLEAN UnloadSymbols = FALSE;
    ULONG64 OldRip;

    //
    // Print, Prompt, Load symbols, Unload symbols, are all special
    // cases of STATUS_BREAKPOINT.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_BREAK)) {

        //
        // Switch on the breakpoint code.
        //

        OldRip = ContextRecord->Rip;
        switch (ExceptionRecord->ExceptionInformation[0]) {

            //
            // Print a debug string.
            //
            // Arguments:
            //
            //     rcx - Supplies a pointer to an output string buffer.
            //     dx - Supplies the length of the output string buffer.
            //     r8d - Supplies the Id of the calling component.
            //     r9d - Supplies the output filter level.
            //

        case BREAKPOINT_PRINT:
            ContextRecord->Rax = KdpPrint((ULONG)ContextRecord->R8,
                                          (ULONG)ContextRecord->R9,
                                          (PCHAR)ContextRecord->Rcx,
                                          (USHORT)ContextRecord->Rdx,
                                          PreviousMode,
                                          TrapFrame,
                                          ExceptionFrame,
                                          &Completion);

            break;

            //
            // Print a debug prompt string, then input a string.
            //
            // Arguments:
            //
            //     rcx - Supplies a pointer to an output string buffer.
            //     dx - Supplies the length of the output string buffer.
            //     r8 - Supplies a pointer to an input string buffer.
            //     r9w - Supplies the length of the input string bufffer.
            //

        case BREAKPOINT_PROMPT:
            ContextRecord->Rax = KdpPrompt((PCHAR)ContextRecord->Rcx,
                                           (USHORT)ContextRecord->Rdx,
                                           (PCHAR)ContextRecord->R8,
                                           (USHORT)ContextRecord->R9,
                                           PreviousMode,
                                           TrapFrame,
                                           ExceptionFrame);

            Completion = TRUE;
            break;

            //
            // Load the symbolic information for an image.
            //
            // Arguments:
            //
            //    rcx - Supplies a pointer to a filename string descriptor.
            //    rdx - Supplies the base address of the image.
            //

        case BREAKPOINT_UNLOAD_SYMBOLS:
            UnloadSymbols = TRUE;

            //
            // Fall through
            //

        case BREAKPOINT_LOAD_SYMBOLS:
            KdpSymbol((PSTRING)ContextRecord->Rcx,
                      (PKD_SYMBOLS_INFO)ContextRecord->Rdx,
                      UnloadSymbols,
                      PreviousMode,
                      ContextRecord,
                      TrapFrame,
                      ExceptionFrame);

            Completion = TRUE;
            break;

        case BREAKPOINT_COMMAND_STRING:
            KdpCommandString((PSTRING)ContextRecord->Rcx,
                             (PSTRING)ContextRecord->Rdx,
                             PreviousMode,
                             ContextRecord,
                             TrapFrame,
                             ExceptionFrame);
            Completion = TRUE;
            break;
            
            //
            //  Unknown command
            //

        default:
            break;
        }

        //
        // If the kernel debugger did not update RIP, then increment
        // past the breakpoint instruction.
        //

        if (ContextRecord->Rip == OldRip) {
            ContextRecord->Rip += 1;
        }

    } else {

        //
        // Report state change to the kernel debugger.
        //

        Completion = KdpReport(TrapFrame,
                               ExceptionFrame,
                               ExceptionRecord,
                               ContextRecord,
                               PreviousMode,
                               SecondChance);

    }

    return Completion;
}

BOOLEAN
KdIsThisAKdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine is called whenever a user mode exception occurs and
    it might be a kernel debugger exception (e.g., DbgPrint/DbgPrompt).

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

Return Value:

    A value of TRUE is returned if this is for the kernel debugger.
    Otherwise, a value of FALSE is returned.

--*/

{

    UNREFERENCED_PARAMETER(ContextRecord);
    UNREFERENCED_PARAMETER(PreviousMode);

    if (((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) || 
         (ExceptionRecord->ExceptionCode == STATUS_WX86_BREAKPOINT)) &&
        (ExceptionRecord->NumberParameters > 0) &&
        (ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_BREAK)) {
        return TRUE;

    } else {
        return FALSE;
    }
}

BOOLEAN
KdpStub (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine provides a kernel debugger stub routine to catch debug
    prints in a checked system when the kernel debugger is not active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    UNREFERENCED_PARAMETER(TrapFrame);
    UNREFERENCED_PARAMETER(ExceptionFrame);
    UNREFERENCED_PARAMETER(PreviousMode);
    UNREFERENCED_PARAMETER(SecondChance);

    //
    // If the breakpoint is a debug print or load/unload symbols, then return
    // TRUE. Otherwise, return FALSE.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->NumberParameters > 0) &&
        ((ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_SYMBOLS) ||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_SYMBOLS) ||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_COMMAND_STRING) ||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_PRINT))) {
        ContextRecord->Rip += 1;
        return TRUE;

    } else if (!KdPitchDebugger &&
               KdAutoEnableOnEvent &&
               KdPreviouslyEnabled &&
               !KdDebuggerEnabled) {
        // If there are multiple disables this may not reenable
        // the debugger.  Check before calling the full trap routine.
        if (NT_SUCCESS(KdEnableDebugger()) &&
            KdDebuggerEnabled) {

            return KdpTrap(TrapFrame, ExceptionFrame, ExceptionRecord,
                           ContextRecord, PreviousMode, SecondChance);
            
        } else {
            return FALSE;
        }

    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\print.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module contains the common code to filter and print debug
    messages.

Author:

    David N. Cutler (davec) 12-Jan-2000

Revision History:

--*/

#include "kdp.h"
#pragma hdrstop
#include <malloc.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpPrint)
#pragma alloc_text(PAGEKD, KdpPrompt)
#pragma alloc_text(PAGEKD, KdpSymbol)
#pragma alloc_text(PAGEKD, KdpCommandString)
#endif // ALLOC_PRAGMA

extern PWD_HANDLER ExpWdHandler;
extern PVOID       ExpWdHandlerContext;

#if 0
ULONG gLdrHits;
#endif

NTSTATUS
KdpPrint(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Message,
    IN USHORT Length,
    IN KPROCESSOR_MODE PreviousMode,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    OUT PBOOLEAN Completion
    )

/*++

Routine Description:

    This function filters debug print requests, probes and saves user mode
    message buffers on the stack, logs the print message, and prints the
    message on the debug terminal if apprpriate.

Arguments:

    ComponentId - Supplies the component id of the component that issued
        the debug print.

    Level - Supplies the debug filer level number or mask.

    Message - Supplies a pointer to the output message.

    Length - Supplies the length of the output message.

    PreviousMode - Supplies the previous processor mode.

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to a exception.

    Completion - Supplies a pointer to the variable that receives the
        debug print completion status.

Return Value:

    STATUS_SUCCESS - Is returned if the debug print is filtered or is
        successfully printed.

    STATUS_BREAKPOINT - Is returned if ...

    STATUS_DEVICE_NOT_CONNECTED - Is returned if the kernel debugger is
        not enabled and the debug print message was not filtered.

    STATUS_ACCESS_VIOLATION - Is returned if an access violation occurs
        while attempting to copy a user mode buffer to the kernel stack.

--*/

{

    PCHAR Buffer;
    BOOLEAN Enable;
    ULONG Mask;
    STRING Output;
    NTSTATUS Status;

    //
    // If the the component id if out of range or output is enabled for the
    // specified filter level, then attempt to print the output. Otherwise,
    // immediately return success.
    //

    *Completion = FALSE;
    if (Level > 31) {
        Mask = Level;

    } else {
        Mask = 1 << Level;
    }

    if (((Mask & Kd_WIN2000_Mask) == 0) &&
        (ComponentId < KdComponentTableSize) &&
        ((Mask & *KdComponentTable[ComponentId]) == 0)) {
        Status = STATUS_SUCCESS;

    } else {

        //
        // Limit the message length to 512 bytes.
        //

        if (Length > 512) {
            Length = 512;
        }

        //
        // If the previous mode is user, then probe and capture the
        // message buffer on the stack.
        //

        if (PreviousMode != KernelMode) {
            try {
                ProbeForRead(Message, Length, sizeof(UCHAR));
                Buffer = alloca(512);
                KdpQuickMoveMemory(Buffer, Message, Length);
                Message = Buffer;

            } except (EXCEPTION_EXECUTE_HANDLER) {
                return STATUS_ACCESS_VIOLATION;
            }
        }

        //
        // Log debug output in circular buffer and print output
        // if debugger is enabled.
        //

        Output.Buffer = Message;
        Output.Length = Length;
        KdLogDbgPrint(&Output);
        if (KdDebuggerNotPresent == FALSE) {
            Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
            if (KdpPrintString(&Output)) {
                Status = STATUS_BREAKPOINT;

            } else {
                Status = STATUS_SUCCESS;
            }

            KdExitDebugger(Enable);

        } else {
            Status = STATUS_DEVICE_NOT_CONNECTED;
        }
    }

    *Completion = TRUE;
    return Status;
}

USHORT
KdpPrompt(
    IN PCHAR Message,
    IN USHORT MessageLength,
    IN OUT PCHAR Reply,
    IN USHORT ReplyLength,
    IN KPROCESSOR_MODE PreviousMode,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function filters debug print requests, probes and saves user mode
    message buffers on the stack, logs the print message, and prints the
    message on the debug terminal if apprpriate.

Arguments:

    Message - Supplies a pointer to the output message.

    MessageLength - Supplies the length of the output message.

    Reply - Supplies a pointer to the input buffer.

    ReplyLength - Supplies the length of the output message.

    PreviousMode - Supplies the previous processor mode.

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to a exception.

Return Value:

    The length of the input message is returned as the function value.

--*/

{

    PCHAR Buffer;
    BOOLEAN Enable;
    STRING Input;
    STRING Output;

    //
    // Limit the output and input message length to 512 bytes.
    //

    if (MessageLength > 512) {
        MessageLength = 512;
    }

    if (ReplyLength > 512) {
        ReplyLength = 512;
    }

    //
    // If the previous mode is user, then probe and capture the
    // message buffer on the stack.
    //

    if (PreviousMode != KernelMode) {
        try {
            ProbeForRead(Message, MessageLength, sizeof(UCHAR));
            Buffer = alloca(512);
            KdpQuickMoveMemory(Buffer, Message, MessageLength);
            Message = Buffer;
            ProbeForWrite(Reply, ReplyLength, sizeof(UCHAR));
            Buffer = alloca(512);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return 0;
        }

    } else {
        Buffer = Reply;
    }

    Input.Buffer = Buffer;
    Input.Length = 0;
    Input.MaximumLength = ReplyLength;
    Output.Buffer = Message;
    Output.Length = MessageLength;

    //
    // Log debug output in circular buffer and print the prompt message.
    //

    KdLogDbgPrint(&Output);
    Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
    do {
    } while (KdpPromptString(&Output, &Input) == TRUE);

    KdExitDebugger(Enable);

    //
    // If the previous mode was user, then copy the prompt input to the
    // reply buffer.
    //

    if (PreviousMode == UserMode) {
        try {
            KdpQuickMoveMemory(Reply, Input.Buffer, Input.Length);

        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return Input.Length;
}

BOOLEAN
KdpReport(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This function reports an exception to the host kernel debugger.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the exception.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    The disposition of whether the exception was handled (TRUE) or not is
    returned as the function value.

--*/

{

    BOOLEAN Completion;
    BOOLEAN Enable;
    PKPRCB Prcb;

    UNREFERENCED_PARAMETER (PreviousMode);

    //
    // If the exception code is a breakpoint or single step, or stop
    // on exeception is set, or this is the second change to handle
    // the exception, then attempt to enter the kernel debugger.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) ||
#if defined(_WIN64)
        (ExceptionRecord->ExceptionCode == STATUS_WX86_BREAKPOINT) ||
#endif
        (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)  ||
        ((NtGlobalFlag & FLG_STOP_ON_EXCEPTION) != 0) ||
        (SecondChance != FALSE)) {

        //
        // If this is the first chance to handle the exception and the
        // exception code is either a port disconnected or success code,
        // then do not enter the kernel debugger.
        //

        if ((SecondChance == FALSE) &&
#if defined(_WIN64)
            (ExceptionRecord->ExceptionCode != STATUS_WX86_BREAKPOINT) &&
#endif
            ((ExceptionRecord->ExceptionCode == STATUS_PORT_DISCONNECTED) ||
             (NT_SUCCESS(ExceptionRecord->ExceptionCode)))) {

            //
            // This exception should not be reported to the kernel debugger.
            //

            return FALSE;
        }

        //
        // Debugging help:
        //
        // For user mode breakpoints going to the kernel debugger,
        // try to get the user mode module list and image headers
        // paged in before we call the debugger.  Walk the list twice
        // in case paging in some modules pages out some
        // previously paged in data.
        //
#if 0
        if (PreviousMode == UserMode)
        {
            PPEB Peb = PsGetCurrentProcess()->Peb;
            PPEB_LDR_DATA Ldr;
            PLIST_ENTRY LdrHead, LdrNext;
            PLDR_DATA_TABLE_ENTRY LdrEntry;
            UCHAR DataHeader;
            ULONG i,j;

            try {

                Ldr = Peb->Ldr;

                LdrHead = &Ldr->InLoadOrderModuleList;

                ProbeForRead (LdrHead, sizeof (LIST_ENTRY), sizeof (UCHAR));

                for (j=0; j<2; j++) {

                    for (LdrNext = LdrHead->Flink, i = 0;
                         LdrNext != LdrHead && i < 500;
                         LdrNext = LdrNext->Flink, i++) {

                    // BUGBUG
                    gLdrHits++;

                        LdrEntry = CONTAINING_RECORD (LdrNext, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
                        ProbeForRead (LdrEntry, sizeof (LDR_DATA_TABLE_ENTRY), sizeof (UCHAR));

                        DataHeader = ProbeAndReadUchar((PUCHAR)LdrEntry->DllBase);
                    }
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
            }
        }
#endif
        //
        // Report state change to the host kernel debugger.
        //

        Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);

        Prcb = KeGetCurrentPrcb();
        KiSaveProcessorControlState(&Prcb->ProcessorState);
        KdpQuickMoveMemory((PCHAR)&Prcb->ProcessorState.ContextFrame,
                           (PCHAR)ContextRecord,
                           sizeof(CONTEXT));

        if (ExpWdHandler != NULL) {
            ExpWdHandler( WdActionStopTimer, ExpWdHandlerContext, NULL, TRUE );
        }

        Completion =
            KdpReportExceptionStateChange(ExceptionRecord,
                                          &Prcb->ProcessorState.ContextFrame,
                                          SecondChance);

        KdpQuickMoveMemory((PCHAR)ContextRecord,
                           (PCHAR)&Prcb->ProcessorState.ContextFrame,
                           sizeof(CONTEXT));

        KiRestoreProcessorControlState(&Prcb->ProcessorState);

        if (ExpWdHandler != NULL) {
            ExpWdHandler( WdActionStartTimer, ExpWdHandlerContext, NULL, TRUE );
        }

        KdExitDebugger(Enable);

        KdpControlCPressed = FALSE;
        return Completion;

    } else {

        //
        // This exception should not be reported to the kernel debugger.
        //

        return FALSE;
    }
}

VOID
KdpSymbol(
    IN PSTRING String,
    IN PKD_SYMBOLS_INFO Symbol,
    IN BOOLEAN Unload,
    IN KPROCESSOR_MODE PreviousMode,
    IN PCONTEXT ContextRecord,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function loads or unloads debug symbols.

Arguments:

    String - Supplies a pointer to a string descriptor.

    Symbol - Supplies a pointer to the symbol information.

    Unload - Supplies a boolean value that determines whether the symbols
        are being unloaded (TRUE) or loaded (FALSE).

    PreviousMode - Supplies the previous processor mode.

    ContextRecord - Supplies a pointer to a context record.

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to a exception.

Return Value:

    None.

--*/

{

    BOOLEAN Enable;
    PKPRCB Prcb;

    //
    // If the previous mode is kernel and the kernel debugger is present,
    // then load or unload symbols.
    //

    if ((PreviousMode == KernelMode) &&
        (KdDebuggerNotPresent == FALSE)) {

        //
        // Save and restore the processor context in case the
        // kernel debugger has been configured to stop on dll
        // loads.
        //

        Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);

        Prcb = KeGetCurrentPrcb();
        KiSaveProcessorControlState(&Prcb->ProcessorState);
        KdpQuickMoveMemory((PCHAR)&Prcb->ProcessorState.ContextFrame,
                           (PCHAR)ContextRecord,
                           sizeof(CONTEXT));

        KdpReportLoadSymbolsStateChange(String,
                                        Symbol,
                                        Unload,
                                        &Prcb->ProcessorState.ContextFrame);
        KdpQuickMoveMemory((PCHAR)ContextRecord,
                           (PCHAR)&Prcb->ProcessorState.ContextFrame,
                           sizeof(CONTEXT));

        KiRestoreProcessorControlState(&Prcb->ProcessorState);
        KdExitDebugger(Enable);
    }

    return;
}

VOID
KdpCommandString(
    IN PSTRING Name,
    IN PSTRING Command,
    IN KPROCESSOR_MODE PreviousMode,
    IN PCONTEXT ContextRecord,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function reports an exception to the host kernel debugger.

Arguments:

    Name - Identification of the originator of the command.

    Command - Command string.

    PreviousMode - Supplies the previous processor mode.

    ContextRecord - Supplies a pointer to a context record.

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the exception.

Return Value:

    None.

--*/

{
    //
    // Report state change to the host kernel debugger.
    //

    if ((PreviousMode == KernelMode) &&
        (KdDebuggerNotPresent == FALSE)) {

        BOOLEAN Enable;
        PKPRCB Prcb;

        Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);

        Prcb = KeGetCurrentPrcb();
        KiSaveProcessorControlState(&Prcb->ProcessorState);
        KdpQuickMoveMemory((PCHAR)&Prcb->ProcessorState.ContextFrame,
                           (PCHAR)ContextRecord,
                           sizeof(CONTEXT));

        KdpReportCommandStringStateChange(Name, Command,
                                          &Prcb->ProcessorState.ContextFrame);

        KdpQuickMoveMemory((PCHAR)ContextRecord,
                           (PCHAR)&Prcb->ProcessorState.ContextFrame,
                           sizeof(CONTEXT));

        KiRestoreProcessorControlState(&Prcb->ProcessorState);
        KdExitDebugger(Enable);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\amd64\kdcpuapi.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    kdcpuapi.c

Abstract:

    This module implements CPU specific remote debug APIs.

Author:

    David N. Cutler (davec) 14-May-2000

Revision History:

--*/

#include "kdp.h"
#include <stdio.h>

#pragma alloc_text(PAGEKD, KdpAllowDisable)
#pragma alloc_text(PAGEKD, KdpSetContextState)
#pragma alloc_text(PAGEKD, KdpSetStateChange)
#pragma alloc_text(PAGEKD, KdpGetStateChange)
#pragma alloc_text(PAGEKD, KdpSysReadControlSpace)
#pragma alloc_text(PAGEKD, KdpSysWriteControlSpace)
#pragma alloc_text(PAGEKD, KdpReadIoSpace)
#pragma alloc_text(PAGEKD, KdpWriteIoSpace)
#pragma alloc_text(PAGEKD, KdpReadMachineSpecificRegister)
#pragma alloc_text(PAGEKD, KdpWriteMachineSpecificRegister)

NTSTATUS
KdpAllowDisable(
    VOID
    )
/*++

Routine Description:

    Determines whether the current state of the debugger allows
    disabling or not.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    PKPRCB Prcb;
    ULONG Processor;

    //
    // If any kernel data breakpoints are active on any processor we can't
    // disable the debugger.
    //
    
    for (Processor = 0; Processor < (ULONG)KeNumberProcessors; Processor++) {
        Prcb = KiProcessorBlock[Processor];

        if (Prcb->ProcessorState.SpecialRegisters.KernelDr7 & 0xff) {
            return STATUS_ACCESS_DENIED;
        }
    }

    return STATUS_SUCCESS;
}

VOID
KdpSetContextState (
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    )
{

    PKPRCB Prcb;

    //
    // Copy special registers for the AMD64.
    //

    Prcb = KeGetCurrentPrcb();
    WaitStateChange->ControlReport.Dr6 =
                            Prcb->ProcessorState.SpecialRegisters.KernelDr6;

    WaitStateChange->ControlReport.Dr7 =
                            Prcb->ProcessorState.SpecialRegisters.KernelDr7;

    WaitStateChange->ControlReport.SegCs = ContextRecord->SegCs;
    WaitStateChange->ControlReport.SegDs = ContextRecord->SegDs;
    WaitStateChange->ControlReport.SegEs = ContextRecord->SegEs;
    WaitStateChange->ControlReport.SegFs = ContextRecord->SegFs;
    WaitStateChange->ControlReport.EFlags = ContextRecord->EFlags;
    WaitStateChange->ControlReport.ReportFlags = AMD64_REPORT_INCLUDES_SEGS;

    // If the current code segment is a known flat code
    // segment let the debugger know so that it doesn't
    // have to retrieve the descriptor.
    if (ContextRecord->SegCs == KGDT64_R0_CODE ||
        ContextRecord->SegCs == KGDT64_R3_CODE + 3) {
        WaitStateChange->ControlReport.ReportFlags |= AMD64_REPORT_STANDARD_CS;
    }
}

VOID
KdpSetStateChange (
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    Fill in the Wait_State_Change message record.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    SecondChance - Supplies a boolean value that determines whether this is
        the first or second chance for the exception.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(ExceptionRecord);
    UNREFERENCED_PARAMETER(SecondChance);

    KdpSetContextState(WaitStateChange, ContextRecord);
}

VOID
KdpGetStateChange (
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    Extract continuation control data from manipulate state message.

Arguments:

    ManipulateState - Supplies pointer to manipulate state packet.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{

    ULONG Number;
    PKPRCB Prcb;

    //
    // If the status of the manipulate state message was successful, then
    // extract the continuation control information.
    //

    if (NT_SUCCESS(ManipulateState->u.Continue2.ContinueStatus) != FALSE) {

        //
        // Set or clear the TF flag in the EFLAGS field of the context record.
        //

        if (ManipulateState->u.Continue2.ControlSet.TraceFlag != FALSE) {
            ContextRecord->EFlags |= EFLAGS_TF_MASK;

        } else {
            ContextRecord->EFlags &= ~EFLAGS_TF_MASK;

        }

        //
        // Clear DR6 and set the specified DR7 value for each of the processors.
        //

        for (Number = 0; Number < (ULONG)KeNumberProcessors; Number += 1) {
            Prcb = KiProcessorBlock[Number];
            Prcb->ProcessorState.SpecialRegisters.KernelDr6 = 0;
            Prcb->ProcessorState.SpecialRegisters.KernelDr7 =
                                ManipulateState->u.Continue2.ControlSet.Dr7;
        }
    }

    return;
}

NTSTATUS
KdpSysReadControlSpace (
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    This function reads implementation specific system data for the specified
    processor.

Arguments:

    Processor - Supplies the source processor number.

    Address - Supplies the type of data to read.

    Buffer - Supplies the address of the output buffer.

    Request - Supplies the requested number of bytes of data.

    Actual - Supplies a point to a variable that receives the actual number
        of bytes of data returned.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Data;
    ULONG Length;
    PKPRCB Prcb;
    PVOID Source;

    //
    // If the specified processor number is greater than the number of
    // processors in the system or the specified processor is not in the
    // host configuration, then return an unsuccessful status.
    //

    *Actual = 0;
    if ((Processor >= (ULONG)KeNumberProcessors) ||
        (KiProcessorBlock[Processor] == NULL)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Case on address to determine what part of Control space is being read.
    //

    Prcb = KiProcessorBlock[Processor];
    switch (Address) {

        //
        // Read the address of the PCR for the specified processor.
        //

    case DEBUG_CONTROL_SPACE_PCR:
        Data = CONTAINING_RECORD(Prcb, KPCR, Prcb);
        Source = &Data;
        Length = sizeof(PVOID);
        break;

        //
        // Read the address of the PRCB for the specified processor.
        //

    case DEBUG_CONTROL_SPACE_PRCB:
        Source = &Prcb;
        Length = sizeof(PVOID);
        break;

        //
        // Read the address of the current thread for the specified
        // processor.
        //

    case DEBUG_CONTROL_SPACE_THREAD:
        Source = &Prcb->CurrentThread;
        Length = sizeof(PVOID);
        break;

        //
        // Read the special processor registers structure for the specified
        // processor.
        //

    case DEBUG_CONTROL_SPACE_KSPECIAL:
        Source = &Prcb->ProcessorState.SpecialRegisters;
        Length = sizeof(KSPECIAL_REGISTERS);
        break;

        //
        // Invalid information type.
        //

    default:
        return STATUS_UNSUCCESSFUL;

    }

    //
    // If the length of the data is greater than the request length, then
    // reduce the length to the requested length.
    //

    if (Length > Request) {
        Length = Request;
    }

    //
    // Move the data to the supplied buffer and return status dependent on
    // whether the entire data item can be moved.
    //

    return KdpCopyToPtr(Buffer, Source, Length, Actual);
}

NTSTATUS
KdpSysWriteControlSpace (
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    This function write implementation specific system data for the specified
    processor.

Arguments:

    Processor - Supplies the source processor number.

    Address - Supplies the type of data to write.

    Buffer - Supplies the address of the input buffer.

    Request - Supplies the requested number of bytes of data.

    Actual - Supplies a point to a variable that receives the actual number
        of bytes of data written.

Return Value:

    NTSTATUS.

--*/

{

    PKPRCB Prcb;

    //
    // If the specified processor number is greater than the number of
    // processors in the system or the specified processor is not in the
    // host configuration, then return an unsuccessful status.
    //

    *Actual = 0;
    if ((Processor >= (ULONG)KeNumberProcessors) ||
        (KiProcessorBlock[Processor] == NULL)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Case on address to determine what part of control space is being writen.
    //

    Prcb = KiProcessorBlock[Processor];
    switch (Address) {
    
        //
        // Write the special processor registers structure for the specified
        // processor.
        //

    case DEBUG_CONTROL_SPACE_KSPECIAL:

        //
        // If the length of the data is greater than the request length, then
        // reduce the requested length to the length of the data.
        //

        if (Request > sizeof(KSPECIAL_REGISTERS)) {
            Request = sizeof(KSPECIAL_REGISTERS);
        }
    
        //
        // Move the data to the supplied buffer and return status dependent on
        // whether the entire data item can be moved.
        //

        return KdpCopyFromPtr(&Prcb->ProcessorState.SpecialRegisters,
                              Buffer,
                              Request,
                              Actual);

        //
        // Invalid information type.
        //

    default:
        return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
KdpSysReadIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Reads system I/O locations.

Arguments:

    InterfaceType - I/O interface type.

    BusNumber - Bus number.

    AddressSpace - Address space.

    Address - I/O address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;

    if ((InterfaceType != Isa) || (BusNumber != 0) || (AddressSpace != 1)) {
        *Actual = 0;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Check Size and Alignment
    //

    switch (Request) {
        case 1:
            *(PUCHAR)Buffer = READ_PORT_UCHAR((PUCHAR)Address);
            *Actual = 1;
            break;

        case 2:
            if (Address & 1) {
                Status = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                *(PUSHORT)Buffer = READ_PORT_USHORT((PUSHORT)Address);
                *Actual = 2;
            }

            break;

        case 4:
            if (Address & 3) {
                Status = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                *(PULONG)Buffer = READ_PORT_ULONG((PULONG)Address);
                *Actual = 4;
            }

            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            *Actual = 0;
            break;
    }

    return Status;
}

NTSTATUS
KdpSysWriteIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Writes system I/O locations.

Arguments:

    InterfaceType - I/O interface type.

    BusNumber - Bus number.

    AddressSpace - Address space.

    Address - I/O address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    if ((InterfaceType != Isa) || (BusNumber != 0) || (AddressSpace != 1)) {
        *Actual = 0;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Check Size and Alignment
    //

    switch (Request) {
        case 1:
            WRITE_PORT_UCHAR((PUCHAR)Address, *(PUCHAR)Buffer);
            *Actual = 1;
            break;

        case 2:
            if (Address & 1) {
                Status = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_USHORT((PUSHORT)Address, *(PUSHORT)Buffer);
                *Actual = 2;
            }

            break;

        case 4:
            if (Address & 3) {
                Status = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_ULONG((PULONG)Address, *(PULONG)Buffer);
                *Actual = 4;
            }

            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            *Actual = 0;
            break;
    }

    return Status;
}

NTSTATUS
KdpSysReadMsr(
    ULONG Msr,
    PULONG64 Data
    )

/*++

Routine Description:

    Reads an MSR.

Arguments:

    Msr - MSR index.

    Data - Data buffer.

Return Value:

    NTSTATUS.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;

    try {
        *Data = ReadMSR(Msr);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        *Data = 0;
        Status = STATUS_NO_SUCH_DEVICE;
    }

    return Status;
}

NTSTATUS
KdpSysWriteMsr(
    ULONG Msr,
    PULONG64 Data
    )

/*++

Routine Description:

    Writes an MSR.

Arguments:

    Msr - MSR index.

    Data - Data buffer.

Return Value:

    NTSTATUS.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;

    try {
        WriteMSR(Msr, *Data);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_NO_SUCH_DEVICE;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\kd64\kdp.h ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdp.h

Abstract:

    Private include file for the Kernel Debugger subcomponent
    of the NTOS project

Author:

    Mike O'Leary (mikeol) 29-June-1989

Revision History:

--*/

#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include "ntos.h"
#include "ki.h"

#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "string.h"
#include "stdlib.h"
#include "kddll.h"


#if defined(_ALPHA_)

#include "alphaops.h"

//
// Define KD private PCR routines.
//
// Using the following private KD routines allows the kernel debugger to
// step over breakpoints in modules that call the standard PCR routines.
//

PKPCR KdpGetPcr();

ULONG KdpReadInternalProcessorState(PVOID, ULONG);
ULONG KdpReadInternalProcessorCounters(PVOID, ULONG);

struct _KPRCB *
KdpGetCurrentPrcb();

struct _KTHREAD *
KdpGetCurrentThread();

//
// Redefine the standard PCR routines
//

#undef KiPcr
#define KiPcr KdpGetPcr()

#undef KeGetPcr
#undef KeGetCurrentPrcb
#undef KeGetCurrentThread
#undef KeIsExecutingDpc
#define KeGetPcr() KdpGetPcr()
#define KeGetCurrentPrcb() KdpGetCurrentPrcb()
#define KeGetCurrentThread() KdpGetCurrentThread()

//
// Define TYPES
//

#define KDP_BREAKPOINT_TYPE  ULONG
#define KDP_BREAKPOINT_BUFFER sizeof(ULONG)

// longword aligned
#define KDP_BREAKPOINT_ALIGN 3
#define KDP_BREAKPOINT_INSTR_ALIGN 3

// actual instruction is "call_pal kbpt"
#define KDP_BREAKPOINT_VALUE KBPT_FUNC


#elif defined(_IA64_)

// IA64 instruction is in a 128-bit bundle. Each bundle consists of 3 instruction slots.
// Each instruction slot is 41-bit long.
//
//
//            127           87 86           46 45            5 4      1 0
//            ------------------------------------------------------------
//            |    slot 2     |    slot 1     |    slot 0     |template|S|
//            ------------------------------------------------------------
//
//            127        96 95         64 63          32 31             0
//            ------------------------------------------------------------
//            |  byte 3    |  byte 2     |  byte 1      |   byte 0       |
//            ------------------------------------------------------------
//
// This presents two incompatibilities with conventional processors:
//              1. The IA64 IP address is at the bundle bundary. The instruction slot number is
//                 stored in ISR.ei at the time of exception.
//              2. The 41-bit instruction format is not byte-aligned.
//
// Break instruction insertion must be done with proper bit-shifting to align with the selected
// instruction slot. Further, to insert break instruction insertion at a specific slot, we must
// be able to specify instruction slot as part of the address. We therefore define an EM address as
// bundle address + slot number with the least significant two bit always zero:
//
//                      31                 4 3  2  1  0
//                      --------------------------------
//                      |  bundle address    |slot#|0 0|
//                      --------------------------------
//
// The EM address as defined is the byte-aligned address that is closest to the actual instruction slot.
// i.e., The EM instruction address of slot #0 is equal to bundle address.
//                                     slot #1 is equal to bundle address + 4.
//                                     slot #2 is equal to bundle address + 8.

//
//  Upon exception, the bundle address is kept in IIP, and the instruction slot which caused
//  the exception is in ISR.ei. Kernel exception handler will construct the flat address and
//  export it in ExceptionRecord.ExceptionAddress.


#define KDP_BREAKPOINT_TYPE  ULONGLONG          // 64-bit ULONGLONG type is needed to cover 41-bit EM break instruction.
#define KDP_BREAKPOINT_BUFFER (2 * sizeof(ULONGLONG))
#define KDP_BREAKPOINT_ALIGN 0x3                // An EM address consists of bundle and slot number and is 32-bit aligned.
#define KDP_BREAKPOINT_INSTR_ALIGN 0xf
#define KDP_BREAKPOINT_VALUE (BREAK_INSTR | (BREAKPOINT_STOP << 6))

#elif defined(_X86_) || defined(_AMD64_)

#define KDP_BREAKPOINT_TYPE  UCHAR
#define KDP_BREAKPOINT_BUFFER sizeof(UCHAR)
#define KDP_BREAKPOINT_ALIGN 0
#define KDP_BREAKPOINT_INSTR_ALIGN 0
#define KDP_BREAKPOINT_VALUE 0xcc

#endif

//
// Define constants.
//

//
// Addresses above GLOBAL_BREAKPOINT_LIMIT are either in system space
// or part of dynlink, so we treat them as global.
//

#define GLOBAL_BREAKPOINT_LIMIT 1610612736L // 1.5gigabytes

//
// Define breakpoint table entry structure.
//

#define KD_BREAKPOINT_IN_USE        0x00000001
#define KD_BREAKPOINT_NEEDS_WRITE   0x00000002
#define KD_BREAKPOINT_SUSPENDED     0x00000004
#define KD_BREAKPOINT_NEEDS_REPLACE 0x00000008
// IA64 specific defines
#define KD_BREAKPOINT_STATE_MASK    0x0000000f
#define KD_BREAKPOINT_IA64_MASK     0x000f0000
#define KD_BREAKPOINT_IA64_MODE     0x00010000   // IA64 mode
#define KD_BREAKPOINT_IA64_MOVL     0x00020000   // MOVL instruction displaced

typedef struct _BREAKPOINT_ENTRY {
    ULONG Flags;
    ULONG_PTR DirectoryTableBase;
    PVOID Address;
    KDP_BREAKPOINT_TYPE Content;
} BREAKPOINT_ENTRY, *PBREAKPOINT_ENTRY;

//
// Misc defines
//

#define MAXIMUM_RETRIES 20

#define DBGKD_MAX_SPECIAL_CALLS 10

typedef struct _TRACE_DATA_SYM {
    ULONG SymMin;
    ULONG SymMax;
} TRACE_DATA_SYM, *PTRACE_DATA_SYM;

#define KD_MAX_REMOTE_FILES 16

typedef struct _KD_REMOTE_FILE {
    ULONG64 RemoteHandle;
} KD_REMOTE_FILE, *PKD_REMOTE_FILE;

//
// Define function prototypes.
//

NTSTATUS
KdpPrint(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Message,
    IN USHORT Length,
    IN KPROCESSOR_MODE PreviousMode,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    OUT PBOOLEAN Completion
    );

BOOLEAN
KdpPrintString (
    IN PSTRING Output
    );

USHORT
KdpPrompt(
    IN PCHAR Message,
    IN USHORT MessageLength,
    IN OUT PCHAR Reply,
    IN USHORT ReplyLength,
    IN KPROCESSOR_MODE PreviousMode,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

BOOLEAN
KdpPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    );

BOOLEAN
KdpReport(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    );

VOID
KdpSymbol(
    IN PSTRING String,
    IN PKD_SYMBOLS_INFO Symbol,
    IN BOOLEAN Unload,
    IN KPROCESSOR_MODE PreviousMode,
    IN PCONTEXT ContextRecord,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KdpCommandString(
    IN PSTRING Name,
    IN PSTRING Command,
    IN KPROCESSOR_MODE PreviousMode,
    IN PCONTEXT ContextRecord,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

ULONG
KdpAddBreakpoint (
    IN PVOID Address
    );

BOOLEAN
KdpDeleteBreakpoint (
    IN ULONG Handle
    );

BOOLEAN
KdpDeleteBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );

#if defined(_IA64_)

BOOLEAN
KdpSuspendBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );

BOOLEAN
KdpRestoreBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );
#endif

#if i386

BOOLEAN
KdpCheckTracePoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    );

NTSTATUS
KdGetTraceInformation (
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG RequiredLength
    );

VOID
KdSetInternalBreakpoint (
    IN PDBGKD_MANIPULATE_STATE64 m
    );

#endif

NTSTATUS
KdQuerySpecialCalls (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN ULONG Length,
    OUT PULONG RequiredLength
    );

VOID
KdSetSpecialCall (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PCONTEXT ContextRecord
    );

VOID
KdClearSpecialCalls (
    VOID
    );

VOID
KdpQuickMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    );

NTSTATUS
KdpCopyMemoryChunks(
    ULONG64 Address,
    PVOID Buffer,
    ULONG TotalSize,
    ULONG ChunkSize,
    ULONG Flags,
    PULONG ActualSize OPTIONAL
    );

//
// KdpCopyMemoryChunks always copies between an untrusted address
// and a trusted buffer.  The following two macros express a read
// form of this and a write form in a way similar to RtlCopyMemory
// for convenient replacement of RtlCopyMemory calls.
//

// Read memory from an untrusted pointer into a trusted buffer.
#define KdpCopyFromPtr(Dst, Src, Size, Done) \
    KdpCopyMemoryChunks((ULONG_PTR)(Src), Dst, Size, 0,                       \
                        MMDBG_COPY_UNSAFE, Done)
// Write memory from a trusted buffer through an untrusted pointer.
#define KdpCopyToPtr(Dst, Src, Size, Done) \
    KdpCopyMemoryChunks((ULONG_PTR)(Dst), Src, Size, 0,                       \
                        MMDBG_COPY_WRITE | MMDBG_COPY_UNSAFE, Done)

ULONG
KdpReceivePacket (
    IN ULONG ExpectedPacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength
    );

NTSTATUS
KdpAllowDisable(
    VOID
    );

VOID
KdpSetContextState(
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    );

VOID
KdpSetStateChange(
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

VOID
KdpGetStateChange(
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    );

VOID
KdpSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL
    );

BOOLEAN
KdpTrap (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord64,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpSwitchProcessor (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN BOOLEAN UnloadSymbols,
    IN OUT PCONTEXT ContextRecord
    );

VOID
KdpReportCommandStringStateChange (
    IN PSTRING Name,
    IN PSTRING Command,
    IN OUT PCONTEXT ContextRecord
    );

KCONTINUE_STATUS
KdpSendWaitContinue(
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL,
    IN OUT PCONTEXT ContextRecord
    );

VOID
KdpReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

#if 0
VOID
KdpReadVirtualMemory64(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );
#endif

VOID
KdpWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

#if 0
VOID
KdpWriteVirtualMemory64(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );
#endif

VOID
KdpReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpCheckLowMemory(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

VOID
KdpGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpReadIoSpaceExtended (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWriteIoSpaceExtended (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpReadMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWriteMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpGetBusData (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpSetBusData (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpSendTraceData(
    PSTRING Data
    );


VOID
KdpSuspendBreakpoint (
    ULONG Handle
    );

VOID
KdpSuspendAllBreakpoints (
    VOID
    );

VOID
KdpRestoreAllBreakpoints (
    VOID
    );

#if !defined(_TRUSTED_WINDOWS_)
VOID
KdpTimeSlipDpcRoutine (
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
KdpTimeSlipWork (
    IN PVOID Context
    );
#endif

//
// Routines shared between the debugger and
// NtSystemDebugControl.
//

VOID
KdpSysGetVersion(
    PDBGKD_GET_VERSION64 Version
    );

NTSTATUS
KdpSysReadControlSpace(
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysWriteControlSpace(
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysReadIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysWriteIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysReadMsr(
    ULONG Msr,
    PULONG64 Data
    );

NTSTATUS
KdpSysWriteMsr(
    ULONG Msr,
    PULONG64 Data
    );

NTSTATUS
KdpSysReadBusData(
    BUS_DATA_TYPE BusDataType,
    ULONG BusNumber,
    ULONG SlotNumber,
    ULONG Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysWriteBusData(
    BUS_DATA_TYPE BusDataType,
    ULONG BusNumber,
    ULONG SlotNumber,
    ULONG Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysCheckLowMemory(
    ULONG MmFlags
    );

//
// Define dummy prototype so the address of the standard breakpoint instruction
// can be captured.
//
// N.B. This function is NEVER called.
//

VOID
RtlpBreakWithStatusInstruction (
    VOID
    );

//
// Define external references.
//

#define KDP_MESSAGE_BUFFER_SIZE 4096

extern BREAKPOINT_ENTRY KdpBreakpointTable[BREAKPOINT_TABLE_SIZE];
extern KD_REMOTE_FILE KdpRemoteFiles[KD_MAX_REMOTE_FILES];
extern KSPIN_LOCK KdpDebuggerLock;
extern PKDEBUG_ROUTINE KiDebugRoutine;
extern PKDEBUG_SWITCH_ROUTINE KiDebugSwitchRoutine;
extern KDP_BREAKPOINT_TYPE KdpBreakpointInstruction;
extern UCHAR DECLSPEC_ALIGN(8) KdpMessageBuffer[KDP_MESSAGE_BUFFER_SIZE];
extern UCHAR KdpPathBuffer[KDP_MESSAGE_BUFFER_SIZE];
extern BOOLEAN KdpOweBreakpoint;

extern LARGE_INTEGER KdPerformanceCounterRate;
extern LARGE_INTEGER KdTimerStart;
extern LARGE_INTEGER KdTimerStop;
extern LARGE_INTEGER KdTimerDifference;

extern ULONG KdComponentTableSize;
extern PULONG KdComponentTable[];

extern BOOLEAN BreakpointsSuspended;
extern LIST_ENTRY KdpDebuggerDataListHead;

typedef struct {
    ULONG64 Addr;               // pc address of breakpoint
    ULONG Flags;                // Flags bits
    ULONG Calls;                // # of times traced routine called
    ULONG CallsLastCheck;       // # of calls at last periodic (1s)